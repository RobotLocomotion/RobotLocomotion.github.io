

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>pydrake.multibody.math &mdash; pydrake  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/custom.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="pydrake.multibody.meshcat" href="pydrake.multibody.meshcat.html" />
    <link rel="prev" title="pydrake.multibody.inverse_kinematics" href="pydrake.multibody.inverse_kinematics.html" /> 
</head>

<body class="wy-body-for-nav">

  
<header class="site-header">
  <div class="site-header-inner contain">
    <a class="drake-logo" href="/"><img src="/images/drake-logo-white.svg"></a>
    <div class="menu-mobile-toggle">
      <span></span>
    </div>
    <nav class="site-menu">
      <ul>
        <li class="site-menu-item site-menu-item-main">
          <a class="site-menu-item" href="/">Home</a>
        </li>
        <li class="site-menu-item site-menu-item-main">
          <a class="site-menu-item" href="/installation.html">Installation</a>
        </li>
        <li class="site-menu-item site-menu-item-main">
          <a class="site-menu-item" href="/gallery.html">Gallery</a>
        </li>
        <li class="site-menu-item site-menu-item-main">API Documentation
          <div class="sub">
            <a class="site-menu-item" href="https://drake.mit.edu/doxygen_cxx/index.html">C++</a> <a class="site-menu-item" href="https://drake.mit.edu/pydrake/index.html">Python</a>
          </div>
        </li>
        <li class="site-menu-item site-menu-item-main">Resources
          <div class="sub">
            <a class="site-menu-item" href="/getting_help.html">Getting Help</a> <a class="site-menu-item" href="https://deepnote.com/workspace/Drake-0b3b2c53-a7ad-441b-80f8-bf8350752305/project/Tutorials-2b4fc509-aef2-417d-a40d-6071dfed9199/%2Findex.ipynb">Tutorials</a> <a class="site-menu-item" href="/python_bindings.html">Python Bindings</a> <a class="site-menu-item" href="/developers.html">For Developers</a> <a class="site-menu-item" href="/credits.html">Credits</a>
          </div>
        </li>
        <li class="github-link">
          <a class="site-menu-item" href="https://github.com/RobotLocomotion/drake">GitHub <img src="/third_party/images/GitHub-Mark-Light-64px.png"></a>
        </li>
      </ul>
    </nav>
  </div>
</header>

  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> pydrake
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search pydrake only…" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
  <form id="ddg-search-form" class="wy_form" action="https://duckduckgo.com/" method="get">
    <input type="text" name="q" placeholder="Search all of Drake…" />
    <input type="hidden" name="sites" value="drake.mit.edu" />
  </form>
</div>


          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="pydrake.all.html">pydrake.all</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.autodiffutils.html">pydrake.autodiffutils</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.common.html">pydrake.common</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.examples.html">pydrake.examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.forwarddiff.html">pydrake.forwarddiff</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.geometry.html">pydrake.geometry</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.lcm.html">pydrake.lcm</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.manipulation.html">pydrake.manipulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.math.html">pydrake.math</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="pydrake.multibody.html">pydrake.multibody</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="pydrake.multibody.all.html">pydrake.multibody.all</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.multibody.benchmarks.html">pydrake.multibody.benchmarks</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.multibody.fem.html">pydrake.multibody.fem</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.multibody.inverse_kinematics.html">pydrake.multibody.inverse_kinematics</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">pydrake.multibody.math</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.multibody.meshcat.html">pydrake.multibody.meshcat</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.multibody.optimization.html">pydrake.multibody.optimization</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.multibody.parsing.html">pydrake.multibody.parsing</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.multibody.plant.html">pydrake.multibody.plant</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.multibody.tree.html">pydrake.multibody.tree</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.perception.html">pydrake.perception</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.polynomial.html">pydrake.polynomial</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.solvers.html">pydrake.solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.symbolic.html">pydrake.symbolic</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.systems.html">pydrake.systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.trajectories.html">pydrake.trajectories</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.tutorials.html">pydrake.tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.visualization.html">pydrake.visualization</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">pydrake</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
          <li><a href="pydrake.multibody.html">pydrake.multibody</a> &raquo;</li>
        
      <li>pydrake.multibody.math</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="module-pydrake.multibody.math">
<span id="pydrake-multibody-math"></span><h1>pydrake.multibody.math<a class="headerlink" href="#module-pydrake.multibody.math" title="Permalink to this headline">¶</a></h1>
<p>Bindings for multibody math.</p>
<dl class="attribute">
<dt id="pydrake.multibody.math.SpatialAcceleration">
<code class="descclassname">pydrake.multibody.math.</code><code class="descname">SpatialAcceleration</code><a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pydrake.multibody.math.SpatialAcceleration_[float]" title="pydrake.multibody.math.SpatialAcceleration_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.math.SpatialAcceleration_[float]</span></code></a></p>
</dd></dl>

<dl class="template">
<dt id="pydrake.multibody.math.SpatialAcceleration_">
<em class="property">template </em><code class="descclassname">pydrake.multibody.math.</code><code class="descname">SpatialAcceleration_</code><a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.multibody.math.SpatialAcceleration_[float]" title="pydrake.multibody.math.SpatialAcceleration_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">SpatialAcceleration_[float]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd]" title="pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">SpatialAcceleration_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.math.SpatialAcceleration_[Expression]" title="pydrake.multibody.math.SpatialAcceleration_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">SpatialAcceleration_[Expression]</span></code></a></p>
<dl class="class">
<dt id="pydrake.multibody.math.SpatialAcceleration_.SpatialAcceleration_[float]">
<em class="property">class </em><code class="descname">SpatialAcceleration_[float]</code><a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_.SpatialAcceleration_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>This class represents a <em>spatial acceleration</em> A and has 6 elements
with an angular (rotational) acceleration α (3-element vector) on top
of a translational (linear) acceleration 𝐚 (3-element vector). Spatial
acceleration represents the rotational and translational acceleration
of a frame B with respect to a <em>measured-in</em> frame M. This class
assumes that both the angular acceleration α and translational
acceleration 𝐚 are expressed in the same <em>expressed-in</em> frame E. This
class only stores 6 elements (namely α and 𝐚) and does not store the
underlying frames B, M, E. The user is responsible for explicitly
tracking the underlying frames with multibody_quantities “monogram
notation”. For example, A_MB_E denotes frame B’s spatial acceleration
measured in frame M, expressed in frame E and contains alpha_MB_E (B’s
angular acceleration measured in M, expressed in E) and a_MBo_E (Bo’s
translational acceleration measured in M, expressed in E), where Bo is
frame B’s origin point. For an multibody_frames_and_bodies “offset
frame” Bp, the monogram notation A_MBp_E denotes frame Bp’s spatial
acceleration measured in M, expressed in E. Details on spatial vectors
and monogram notation are in sections multibody_spatial_vectors and
multibody_quantities.</p>
<p>The typeset for A_MB is <span class="math notranslate nohighlight">\(\,{^MA^B}\)</span> and its definition is
<span class="math notranslate nohighlight">\(^MA^B = \frac{^Md}{dt}\,{^MV^B}\,\)</span>, where <span class="math notranslate nohighlight">\({^MV^B}\)</span> is
frame B’s spatial velocity in frame M and <span class="math notranslate nohighlight">\(\frac{^Md}{dt}\)</span>
denotes the time derivative taken in frame M. To differentiate a
vector, we need to specify in what frame the time derivative is taken,
see [Mitiguy 2022, §7.2] for an in-depth discussion. Time derivatives
in different frames are related by the “Transport Theorem”, which in
Drake is implemented in
drake::math::ConvertTimeDerivativeToOtherFrame(). In source code
(monogram) notation, we write A_MB = DtM(V_MB), where DtM() denotes
the time derivative in frame M. Details on vector differentiation is
in section Dt_multibody_quantities.</p>
<p>[Mitiguy 2022] Mitiguy, P., 2022. Advanced Dynamics &amp; Motion
Simulation.</p>
<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_.SpatialAcceleration_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_.SpatialAcceleration_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialAcceleration_[float]) -&gt; None</p>
<blockquote>
<div><p>Constructs to all NaNs.</p>
<dl class="docutils">
<dt>Note:</dt>
<dd><p class="first last">This is different from C++, which in Release builds may leave memory
uninitialized. In pydrake, the function call overhead already trumps
any overhead from NAN-initialization, so we err on the side of
safety.</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialAcceleration_[float], alpha: numpy.ndarray[numpy.float64[3, 1]], a: numpy.ndarray[numpy.float64[3, 1]]) -&gt; None</p>
</li>
</ol>
<p>Constructs a spatial acceleration A from an angular acceleration α
(alpha) and a translational acceleration 𝐚.</p>
<ol class="arabic simple" start="3">
<li>__init__(self: pydrake.multibody.math.SpatialAcceleration_[float], A: numpy.ndarray[numpy.float64[6, 1]]) -&gt; None</li>
</ol>
<p>Constructs a spatial acceleration A from an Eigen expression that
represents a 6-element vector, i.e., a 3-element angular acceleration
α and a 3-element translational acceleration 𝐚. This constructor will
assert the size of A is six (6) either at compile-time for fixed sized
Eigen expressions or at run-time for dynamic sized Eigen expressions.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_.SpatialAcceleration_[float].ComposeWithMovingFrameAcceleration">
<code class="descname">ComposeWithMovingFrameAcceleration</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialAcceleration_[float], position_of_moving_frame: numpy.ndarray[numpy.float64[3, 1]], angular_velocity_of_this_frame: numpy.ndarray[numpy.float64[3, 1]], velocity_of_moving_frame: pydrake.multibody.math.SpatialVelocity_[float], acceleration_of_moving_frame: pydrake.multibody.math.SpatialAcceleration_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialAcceleration_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_.SpatialAcceleration_[float].ComposeWithMovingFrameAcceleration" title="Permalink to this definition">¶</a></dt>
<dd><p>Compose <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial acceleration (measured in some frame M) with
the spatial acceleration of another frame to form the 𝐨𝐭𝐡𝐞𝐫 frame’s
spatial acceleration in frame M. Herein, <code class="docutils literal notranslate"><span class="pre">this</span></code> is the spatial
acceleration of a frame (designated B) in frame M and the 𝐨𝐭𝐡𝐞𝐫 frame
is designated C.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">position_of_moving_frame</span></code>:</dt>
<dd>which is the position vector p_BoCo_E (from frame B’s origin Bo to
frame C’s origin Co), expressed in frame E. p_BoCo_E must have the
same expressed-in frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code>, where <code class="docutils literal notranslate"><span class="pre">this</span></code> is A_MB_E
(frame B’s spatial acceleration measured in M, expressed in E).</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">angular_velocity_of_this_frame</span></code>:</dt>
<dd>which is ω_MB_E, frame B’s angular velocity measured in frame W
and expressed in frame E.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">velocity_of_moving_frame</span></code>:</dt>
<dd>which is V_BC_E, frame C’s spatial velocity measured in frame B,
expressed in frame E.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">acceleration_of_moving_frame</span></code>:</dt>
<dd>which is A_BC_E, frame C’s spatial acceleration measured in frame
B, expressed in frame E.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">A_MC_E</span></code>:</dt>
<dd>frame C’s spatial acceleration measured in frame M, expressed in
frame E.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">SpatialVelocity::ComposeWithMovingFrameVelocity(). Use Shift() if
frames B and C are both fixed to the same frame or body, i.e.,
velocity_of_moving_frame = 0 and acceleration_of_moving_frame = 0.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The returned spatial acceleration A_MC_E contains an angular
acceleration α_MC_E and translational acceleration a_MCo_E that
are calculated as:</p>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">α_MC_E</span>  <span class="o">=</span> <span class="n">α_MB_E</span> <span class="o">+</span> <span class="n">α_BC_E</span> <span class="o">+</span> <span class="n">ω_MB_E</span> <span class="n">x</span> <span class="n">ω_BC_E</span>
 <span class="n">a_MCo_E</span> <span class="o">=</span> <span class="n">a_BCo_E</span> <span class="o">+</span> <span class="n">α_MB_E</span> <span class="n">x</span> <span class="n">p_BoCo_E</span> <span class="o">+</span> <span class="n">ω_MB_E</span> <span class="n">x</span> <span class="p">(</span><span class="n">ω_MB_E</span> <span class="n">x</span> <span class="n">p_BoCo_E</span><span class="p">)</span>
         <span class="o">+</span> <span class="mi">2</span> <span class="n">ω_MB_E</span> <span class="n">x</span> <span class="n">v_BCo_E</span> <span class="o">+</span> <span class="n">a_BCo_E</span>
</pre></div>
</div>
<p>If frame C is rigidly fixed to frame B, A_BC_E = 0 and V_BC_E = 0 and
this method produces a Shift() operation (albeit inefficiently). The
previous equations show composing spatial acceleration is not simply
adding A_MB + A_BC and these equations differ significantly from their
spatial velocity counterparts. For example, angular velocities simply
add as</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ω_MC</span> <span class="o">=</span> <span class="n">ω_MB</span> <span class="o">+</span> <span class="n">ω_BC</span><span class="p">,</span>   <span class="n">but</span> <span class="mi">3</span><span class="n">D</span> <span class="n">angular</span> <span class="n">acceleration</span> <span class="ow">is</span> <span class="n">more</span> <span class="n">complicated</span> <span class="k">as</span>
  <span class="n">α_MC</span> <span class="o">=</span> <span class="n">α_MB</span> <span class="o">+</span> <span class="n">α_BC</span> <span class="o">+</span> <span class="n">ω_MB</span> <span class="n">x</span> <span class="n">ω_BC</span>
</pre></div>
</div>
<p>** Derivation **</p>
<ul class="simple">
<li>Rotational acceleration component *</li>
</ul>
<p>ω_MC (frame C’s angular velocity in frame M) can be calculated with
the angular velocity addition theorem as</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ω_MC</span> <span class="o">=</span> <span class="n">ω_MB</span> <span class="o">+</span> <span class="n">ω_BC</span>
</pre></div>
</div>
<p>α_MC (frame C’s angular acceleration measured in frame M) is defined
as the time-derivative in frame M of ω_MC, and can be calculated using
the “Transport Theorem” (Golden rule for vector differentation) which
converts the time-derivative of a vector in frame M to frame B, e.g.,
as DtM(ω_BC) = DtB(ω_BC) + ω_MB x ω_BC, as</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">α_MC</span> <span class="o">=</span> <span class="n">DtM</span><span class="p">(</span><span class="n">ω_MC</span><span class="p">)</span> <span class="o">=</span> <span class="n">DtM</span><span class="p">(</span><span class="n">ω_MB</span><span class="p">)</span> <span class="o">+</span> <span class="n">DtM</span><span class="p">(</span><span class="n">ω_BC</span><span class="p">)</span>
                   <span class="o">=</span>     <span class="n">α_MB</span>  <span class="o">+</span> <span class="n">DtB</span><span class="p">(</span><span class="n">ω_BC</span><span class="p">)</span> <span class="o">+</span> <span class="n">ω_MB</span> <span class="n">x</span> <span class="n">ω_BC</span>
                   <span class="o">=</span>     <span class="n">α_MB</span>  <span class="o">+</span>     <span class="n">α_BC</span>  <span class="o">+</span> <span class="n">ω_MB</span> <span class="n">x</span> <span class="n">ω_BC</span>   <span class="p">(</span><span class="n">End</span> <span class="n">of</span> <span class="n">proof</span><span class="p">)</span><span class="o">.</span>
</pre></div>
</div>
<ul class="simple">
<li>Translational acceleration component *</li>
</ul>
<p>v_MCo (frame C’s translational velocity in frame M) is calculated in
SpatialVelocity::ComposeWithMovingFrameVelocity) as</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">v_MCo</span> <span class="o">=</span> <span class="n">v_MBo</span> <span class="o">+</span> <span class="n">ω_MB</span> <span class="n">x</span> <span class="n">p_BoCo</span> <span class="o">+</span> <span class="n">v_BCo</span>
</pre></div>
</div>
<p>a_MCo (frame C’s translational acceleration measured in frame M) is
defined as the time-derivative in frame M of v_MCo, calculated as</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a_MCo</span> <span class="o">=</span> <span class="n">DtM</span><span class="p">(</span><span class="n">v_MCo</span><span class="p">)</span>                             <span class="n">Definition</span><span class="o">.</span>
       <span class="o">=</span> <span class="n">DtM</span><span class="p">(</span><span class="n">v_MBo</span> <span class="o">+</span> <span class="n">ω_MB</span> <span class="n">x</span> <span class="n">p_BoCo</span> <span class="o">+</span> <span class="n">v_BCo</span><span class="p">)</span>     <span class="n">Substitution</span><span class="o">.</span>
       <span class="o">=</span> <span class="n">DtM</span><span class="p">(</span><span class="n">v_MBo</span><span class="p">)</span> <span class="o">+</span> <span class="n">DtM</span><span class="p">(</span><span class="n">ω_MB</span><span class="p">)</span> <span class="n">x</span> <span class="n">p_BoCo</span> <span class="o">+</span> <span class="n">ω_MB</span> <span class="n">x</span> <span class="n">DtM</span><span class="p">(</span><span class="n">p_BoCo</span><span class="p">)</span> <span class="o">+</span> <span class="n">DtM</span><span class="p">(</span><span class="n">v_BCo</span><span class="p">)</span>
       <span class="o">=</span>     <span class="n">a_MBo</span>  <span class="o">+</span>     <span class="n">α_MB</span>  <span class="n">x</span> <span class="n">p_BoCo</span> <span class="o">+</span> <span class="n">ω_MB</span> <span class="n">x</span> <span class="n">DtM</span><span class="p">(</span><span class="n">p_BoCo</span><span class="p">)</span> <span class="o">+</span> <span class="n">DtM</span><span class="p">(</span><span class="n">v_BCo</span><span class="p">)</span>
</pre></div>
</div>
<p>The last two terms are modified using the “Transport Theorem” (Golden
rule for vector differentation) which converts time-derivatives of
vectors in frame M to frame B via DtM(vec) = DtB(vec) + ω_MB x vec.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">DtM</span><span class="p">(</span><span class="n">p_BoCo</span><span class="p">)</span> <span class="o">=</span> <span class="n">DtB</span><span class="p">(</span><span class="n">p_BoCo</span><span class="p">)</span> <span class="o">+</span> <span class="n">ω_MB</span> <span class="n">x</span> <span class="n">p_BoCo</span>
             <span class="o">=</span>     <span class="n">v_BCo</span>   <span class="o">+</span> <span class="n">ω_MB</span> <span class="n">x</span> <span class="n">p_BoCo</span>
 <span class="n">DtM</span><span class="p">(</span><span class="n">v_BCo</span><span class="p">)</span>  <span class="o">=</span> <span class="n">DtB</span><span class="p">(</span><span class="n">v_BCo</span><span class="p">)</span>  <span class="o">+</span> <span class="n">ω_MB</span> <span class="n">x</span> <span class="n">v_BCo</span>
             <span class="o">=</span>     <span class="n">a_BCo</span>   <span class="o">+</span> <span class="n">ω_MB</span> <span class="n">x</span> <span class="n">v_BCo</span>
</pre></div>
</div>
<p>Combining the last few equations proves the formula for a_MCo as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a_MCo</span> <span class="o">=</span> <span class="n">a_MBo</span> <span class="o">+</span> <span class="n">α_MB</span> <span class="n">x</span> <span class="n">p_BoCo</span> <span class="o">+</span> <span class="n">ω_MB</span> <span class="n">x</span> <span class="p">(</span><span class="n">ω_MB</span> <span class="n">x</span> <span class="n">p_BoCo</span><span class="p">)</span>
        <span class="o">+</span> <span class="mi">2</span> <span class="n">ω_MB</span> <span class="n">x</span> <span class="n">v_BCo</span> <span class="o">+</span> <span class="n">a_BCo</span>                           <span class="p">(</span><span class="n">End</span> <span class="n">of</span> <span class="n">proof</span><span class="p">)</span><span class="o">.</span>
</pre></div>
</div>
<p>Some terms in the previous equation have names, e.g.,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">centripetal</span> <span class="n">acceleration</span>   <span class="n">ω_MB</span> <span class="n">x</span> <span class="p">(</span><span class="n">ω_MB</span> <span class="n">x</span> <span class="n">p_BoCo</span><span class="p">)</span>
  <span class="n">Coriolis</span> <span class="n">acceleration</span>    <span class="mi">2</span> <span class="n">ω_MB</span> <span class="n">x</span> <span class="n">v_BCo</span>
  <span class="n">Coincident</span> <span class="n">point</span> <span class="n">acceleration</span><span class="p">,</span> <span class="n">i</span><span class="o">.</span><span class="n">e</span><span class="o">.</span><span class="p">,</span> <span class="n">acceleration</span> <span class="n">of</span> <span class="n">the</span> <span class="n">point</span> <span class="n">of</span> <span class="n">frame</span>
  <span class="n">B</span> <span class="n">coincident</span> <span class="k">with</span> <span class="n">Co</span>      <span class="n">a_MBo</span> <span class="o">+</span> <span class="n">α_MB</span> <span class="n">x</span> <span class="n">p_BoCo</span> <span class="o">+</span> <span class="n">ω_MB</span> <span class="n">x</span> <span class="p">(</span><span class="n">ω_MB</span> <span class="n">x</span> <span class="n">p_BoCo</span><span class="p">)</span>
</pre></div>
</div>
<p>Note: The coincident point acceleration can be calculated with a
Shift().</p>
<p>Note: The three cross products appearing in the previous calculation
of a_MCo can be reduced to one, possibly improving efficiency via</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ω_MB</span> <span class="n">x</span> <span class="p">(</span><span class="n">ω_MB</span> <span class="n">x</span> <span class="n">p_BoCo</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span> <span class="n">ω_MB</span> <span class="n">x</span> <span class="n">v_BCo</span> <span class="o">=</span> <span class="n">ω_MB</span> <span class="n">x</span> <span class="p">(</span><span class="n">v_MCo</span> <span class="o">-</span> <span class="n">v_MBo</span> <span class="o">+</span> <span class="n">v_BCo</span><span class="p">)</span>
</pre></div>
</div>
<p>To show this, we rearrange and substitute our expression for v_MCo.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">v_MCo</span> <span class="o">=</span> <span class="n">v_MBo</span> <span class="o">+</span> <span class="n">ω_MB</span> <span class="n">x</span> <span class="n">p_BoCo</span> <span class="o">+</span> <span class="n">v_BCo</span>        <span class="n">which</span> <span class="n">rearranges</span> <span class="n">to</span>
  <span class="n">ω_MB</span> <span class="n">x</span> <span class="n">p_BoCo</span> <span class="o">=</span> <span class="n">v_MCo</span> <span class="o">-</span> <span class="n">v_MBo</span> <span class="o">-</span> <span class="n">v_BCo</span><span class="o">.</span>             <span class="n">Substitution</span> <span class="n">produces</span>
  <span class="n">ω_MB</span> <span class="n">x</span> <span class="p">(</span><span class="n">ω_MB</span> <span class="n">x</span> <span class="n">p_BoCo</span><span class="p">)</span> <span class="o">=</span> <span class="n">ω_MB</span> <span class="n">x</span> <span class="p">(</span><span class="n">v_MCo</span> <span class="o">-</span> <span class="n">v_MBo</span> <span class="o">-</span> <span class="n">v_BCo</span><span class="p">)</span>           <span class="n">Hence</span><span class="p">,</span>
  <span class="n">ω_MB</span> <span class="n">x</span> <span class="p">(</span><span class="n">ω_MB</span> <span class="n">x</span> <span class="n">p_BoCo</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span> <span class="n">ω_MB</span> <span class="n">x</span> <span class="n">v_BCo</span> <span class="o">=</span> <span class="n">ω_MB</span> <span class="n">x</span> <span class="p">(</span><span class="n">v_MCo</span> <span class="o">-</span> <span class="n">v_MBo</span> <span class="o">+</span> <span class="n">v_BCo</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_.SpatialAcceleration_[float].get_coeffs">
<code class="descname">get_coeffs</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialAcceleration_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[6, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_.SpatialAcceleration_[float].get_coeffs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to the underlying storage.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_.SpatialAcceleration_[float].Rotate">
<code class="descname">Rotate</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialAcceleration_[float], R_FE: pydrake.math.RotationMatrix_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialAcceleration_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_.SpatialAcceleration_[float].Rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides a Python-only implementation of rotating / re-expressing a
spatial vector.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is done because defining <code class="docutils literal notranslate"><span class="pre">__rmatmul__</span></code> on this class does
not disambiguate against the definitions of
<code class="docutils literal notranslate"><span class="pre">RotationMatrix.__matmul__</span></code>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_.SpatialAcceleration_[float].rotational">
<code class="descname">rotational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialAcceleration_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_.SpatialAcceleration_[float].rotational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the rotational component of this spatial vector.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_.SpatialAcceleration_[float].SetZero">
<code class="descname">SetZero</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialAcceleration_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialAcceleration_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_.SpatialAcceleration_[float].SetZero" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets both the rotational and translational components of <code class="docutils literal notranslate"><span class="pre">this</span></code>
SpatialVector to zero.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_.SpatialAcceleration_[float].Shift">
<code class="descname">Shift</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialAcceleration_[float], offset: numpy.ndarray[numpy.float64[3, 1]], angular_velocity_of_this_frame: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialAcceleration_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_.SpatialAcceleration_[float].Shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Shifts a SpatialAcceleration from a frame B to a frame C, where both B
and C are fixed to the same frame or rigid body.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">offset</span></code>:</dt>
<dd>which is the position vector p_BoCo_E from Bo (frame B’s origin)
to Co (frame C’s origin), expressed in frame E. p_BoCo_E must have
the same expressed-in frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial acceleration,
where <code class="docutils literal notranslate"><span class="pre">this</span></code> is A_MB_E (frame B’s spatial acceleration measured
in M, expressed in E).</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">angular_velocity_of_this_frame</span></code>:</dt>
<dd>which is ω_MB_E, frame B’s angular velocity measured in frame M
and expressed in frame E.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">A_MC_E</span></code>:</dt>
<dd>which is frame C’s spatial acceleration measured in frame M,
expressed in frame E.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Shift() differs from ShiftInPlace() in that Shift() does not
modify <code class="docutils literal notranslate"><span class="pre">this</span></code> whereas ShiftInPlace() does modify <code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">ShiftInPlace() for more information and how A_MC_E is calculated.
Use ComposeWithMovingFrameAcceleration() if frame C is moving on
frame B.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_.SpatialAcceleration_[float].ShiftWithZeroAngularVelocity">
<code class="descname">ShiftWithZeroAngularVelocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialAcceleration_[float], offset: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialAcceleration_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_.SpatialAcceleration_[float].ShiftWithZeroAngularVelocity" title="Permalink to this definition">¶</a></dt>
<dd><p>(Advanced) Given <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial acceleration A_MB of a frame B
measured in a frame M, shifts SpatialAcceleration from frame B to a
frame C (i.e., A_MB to A_MC), where both B and C are fixed to the same
frame or rigid body and where ω_MB = 0 (frame B’s angular velocity in
frame M is zero).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">offset</span></code>:</dt>
<dd>which is the position vector p_BoCo_E from Bo (frame B’s origin)
to Co (frame C’s origin), expressed in frame E. p_BoCo_E must have
the same expressed-in frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial acceleration,
where <code class="docutils literal notranslate"><span class="pre">this</span></code> is A_MB_E (frame B’s spatial acceleration measured
in M, expressed in E).</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">A_MC_E</span></code>:</dt>
<dd>which is frame C’s spatial acceleration measured in frame M,
expressed in frame E.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">ShiftInPlace() for more information and how A_MC_E is calculated.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">ShiftWithZeroAngularVelocity() speeds the Shift() computation when
ω_MB = 0, even if α_MB ≠ 0 (α_MB is stored in <code class="docutils literal notranslate"><span class="pre">this</span></code>).</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_.SpatialAcceleration_[float].translational">
<code class="descname">translational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialAcceleration_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_.SpatialAcceleration_[float].translational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the translational component of this spatial vector.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.math.SpatialAcceleration_.SpatialAcceleration_[float].Zero">
<em class="property">static </em><code class="descname">Zero</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialAcceleration_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_.SpatialAcceleration_[float].Zero" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory to create a <em>zero</em> spatial vector, i.e., a SpatialVector whose
rotational and translational components are both zero.</p>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.math.</code><code class="descname">SpatialAcceleration_[AutoDiffXd]</code><a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd]" title="Permalink to this definition">¶</a></dt>
<dd><p>This class represents a <em>spatial acceleration</em> A and has 6 elements
with an angular (rotational) acceleration α (3-element vector) on top
of a translational (linear) acceleration 𝐚 (3-element vector). Spatial
acceleration represents the rotational and translational acceleration
of a frame B with respect to a <em>measured-in</em> frame M. This class
assumes that both the angular acceleration α and translational
acceleration 𝐚 are expressed in the same <em>expressed-in</em> frame E. This
class only stores 6 elements (namely α and 𝐚) and does not store the
underlying frames B, M, E. The user is responsible for explicitly
tracking the underlying frames with multibody_quantities “monogram
notation”. For example, A_MB_E denotes frame B’s spatial acceleration
measured in frame M, expressed in frame E and contains alpha_MB_E (B’s
angular acceleration measured in M, expressed in E) and a_MBo_E (Bo’s
translational acceleration measured in M, expressed in E), where Bo is
frame B’s origin point. For an multibody_frames_and_bodies “offset
frame” Bp, the monogram notation A_MBp_E denotes frame Bp’s spatial
acceleration measured in M, expressed in E. Details on spatial vectors
and monogram notation are in sections multibody_spatial_vectors and
multibody_quantities.</p>
<p>The typeset for A_MB is <span class="math notranslate nohighlight">\(\,{^MA^B}\)</span> and its definition is
<span class="math notranslate nohighlight">\(^MA^B = \frac{^Md}{dt}\,{^MV^B}\,\)</span>, where <span class="math notranslate nohighlight">\({^MV^B}\)</span> is
frame B’s spatial velocity in frame M and <span class="math notranslate nohighlight">\(\frac{^Md}{dt}\)</span>
denotes the time derivative taken in frame M. To differentiate a
vector, we need to specify in what frame the time derivative is taken,
see [Mitiguy 2022, §7.2] for an in-depth discussion. Time derivatives
in different frames are related by the “Transport Theorem”, which in
Drake is implemented in
drake::math::ConvertTimeDerivativeToOtherFrame(). In source code
(monogram) notation, we write A_MB = DtM(V_MB), where DtM() denotes
the time derivative in frame M. Details on vector differentiation is
in section Dt_multibody_quantities.</p>
<p>[Mitiguy 2022] Mitiguy, P., 2022. Advanced Dynamics &amp; Motion
Simulation.</p>
<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd]) -&gt; None</p>
<blockquote>
<div><p>Constructs to all NaNs.</p>
<dl class="docutils">
<dt>Note:</dt>
<dd><p class="first last">This is different from C++, which in Release builds may leave memory
uninitialized. In pydrake, the function call overhead already trumps
any overhead from NAN-initialization, so we err on the side of
safety.</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd], alpha: numpy.ndarray[object[3, 1]], a: numpy.ndarray[object[3, 1]]) -&gt; None</p>
</li>
</ol>
<p>Constructs a spatial acceleration A from an angular acceleration α
(alpha) and a translational acceleration 𝐚.</p>
<ol class="arabic simple" start="3">
<li>__init__(self: pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd], A: numpy.ndarray[object[6, 1]]) -&gt; None</li>
</ol>
<p>Constructs a spatial acceleration A from an Eigen expression that
represents a 6-element vector, i.e., a 3-element angular acceleration
α and a 3-element translational acceleration 𝐚. This constructor will
assert the size of A is six (6) either at compile-time for fixed sized
Eigen expressions or at run-time for dynamic sized Eigen expressions.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd].ComposeWithMovingFrameAcceleration">
<code class="descname">ComposeWithMovingFrameAcceleration</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd], position_of_moving_frame: numpy.ndarray[object[3, 1]], angular_velocity_of_this_frame: numpy.ndarray[object[3, 1]], velocity_of_moving_frame: pydrake.multibody.math.SpatialVelocity_[AutoDiffXd], acceleration_of_moving_frame: pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd].ComposeWithMovingFrameAcceleration" title="Permalink to this definition">¶</a></dt>
<dd><p>Compose <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial acceleration (measured in some frame M) with
the spatial acceleration of another frame to form the 𝐨𝐭𝐡𝐞𝐫 frame’s
spatial acceleration in frame M. Herein, <code class="docutils literal notranslate"><span class="pre">this</span></code> is the spatial
acceleration of a frame (designated B) in frame M and the 𝐨𝐭𝐡𝐞𝐫 frame
is designated C.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">position_of_moving_frame</span></code>:</dt>
<dd>which is the position vector p_BoCo_E (from frame B’s origin Bo to
frame C’s origin Co), expressed in frame E. p_BoCo_E must have the
same expressed-in frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code>, where <code class="docutils literal notranslate"><span class="pre">this</span></code> is A_MB_E
(frame B’s spatial acceleration measured in M, expressed in E).</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">angular_velocity_of_this_frame</span></code>:</dt>
<dd>which is ω_MB_E, frame B’s angular velocity measured in frame W
and expressed in frame E.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">velocity_of_moving_frame</span></code>:</dt>
<dd>which is V_BC_E, frame C’s spatial velocity measured in frame B,
expressed in frame E.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">acceleration_of_moving_frame</span></code>:</dt>
<dd>which is A_BC_E, frame C’s spatial acceleration measured in frame
B, expressed in frame E.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">A_MC_E</span></code>:</dt>
<dd>frame C’s spatial acceleration measured in frame M, expressed in
frame E.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">SpatialVelocity::ComposeWithMovingFrameVelocity(). Use Shift() if
frames B and C are both fixed to the same frame or body, i.e.,
velocity_of_moving_frame = 0 and acceleration_of_moving_frame = 0.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The returned spatial acceleration A_MC_E contains an angular
acceleration α_MC_E and translational acceleration a_MCo_E that
are calculated as:</p>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">α_MC_E</span>  <span class="o">=</span> <span class="n">α_MB_E</span> <span class="o">+</span> <span class="n">α_BC_E</span> <span class="o">+</span> <span class="n">ω_MB_E</span> <span class="n">x</span> <span class="n">ω_BC_E</span>
 <span class="n">a_MCo_E</span> <span class="o">=</span> <span class="n">a_BCo_E</span> <span class="o">+</span> <span class="n">α_MB_E</span> <span class="n">x</span> <span class="n">p_BoCo_E</span> <span class="o">+</span> <span class="n">ω_MB_E</span> <span class="n">x</span> <span class="p">(</span><span class="n">ω_MB_E</span> <span class="n">x</span> <span class="n">p_BoCo_E</span><span class="p">)</span>
         <span class="o">+</span> <span class="mi">2</span> <span class="n">ω_MB_E</span> <span class="n">x</span> <span class="n">v_BCo_E</span> <span class="o">+</span> <span class="n">a_BCo_E</span>
</pre></div>
</div>
<p>If frame C is rigidly fixed to frame B, A_BC_E = 0 and V_BC_E = 0 and
this method produces a Shift() operation (albeit inefficiently). The
previous equations show composing spatial acceleration is not simply
adding A_MB + A_BC and these equations differ significantly from their
spatial velocity counterparts. For example, angular velocities simply
add as</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ω_MC</span> <span class="o">=</span> <span class="n">ω_MB</span> <span class="o">+</span> <span class="n">ω_BC</span><span class="p">,</span>   <span class="n">but</span> <span class="mi">3</span><span class="n">D</span> <span class="n">angular</span> <span class="n">acceleration</span> <span class="ow">is</span> <span class="n">more</span> <span class="n">complicated</span> <span class="k">as</span>
  <span class="n">α_MC</span> <span class="o">=</span> <span class="n">α_MB</span> <span class="o">+</span> <span class="n">α_BC</span> <span class="o">+</span> <span class="n">ω_MB</span> <span class="n">x</span> <span class="n">ω_BC</span>
</pre></div>
</div>
<p>** Derivation **</p>
<ul class="simple">
<li>Rotational acceleration component *</li>
</ul>
<p>ω_MC (frame C’s angular velocity in frame M) can be calculated with
the angular velocity addition theorem as</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ω_MC</span> <span class="o">=</span> <span class="n">ω_MB</span> <span class="o">+</span> <span class="n">ω_BC</span>
</pre></div>
</div>
<p>α_MC (frame C’s angular acceleration measured in frame M) is defined
as the time-derivative in frame M of ω_MC, and can be calculated using
the “Transport Theorem” (Golden rule for vector differentation) which
converts the time-derivative of a vector in frame M to frame B, e.g.,
as DtM(ω_BC) = DtB(ω_BC) + ω_MB x ω_BC, as</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">α_MC</span> <span class="o">=</span> <span class="n">DtM</span><span class="p">(</span><span class="n">ω_MC</span><span class="p">)</span> <span class="o">=</span> <span class="n">DtM</span><span class="p">(</span><span class="n">ω_MB</span><span class="p">)</span> <span class="o">+</span> <span class="n">DtM</span><span class="p">(</span><span class="n">ω_BC</span><span class="p">)</span>
                   <span class="o">=</span>     <span class="n">α_MB</span>  <span class="o">+</span> <span class="n">DtB</span><span class="p">(</span><span class="n">ω_BC</span><span class="p">)</span> <span class="o">+</span> <span class="n">ω_MB</span> <span class="n">x</span> <span class="n">ω_BC</span>
                   <span class="o">=</span>     <span class="n">α_MB</span>  <span class="o">+</span>     <span class="n">α_BC</span>  <span class="o">+</span> <span class="n">ω_MB</span> <span class="n">x</span> <span class="n">ω_BC</span>   <span class="p">(</span><span class="n">End</span> <span class="n">of</span> <span class="n">proof</span><span class="p">)</span><span class="o">.</span>
</pre></div>
</div>
<ul class="simple">
<li>Translational acceleration component *</li>
</ul>
<p>v_MCo (frame C’s translational velocity in frame M) is calculated in
SpatialVelocity::ComposeWithMovingFrameVelocity) as</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">v_MCo</span> <span class="o">=</span> <span class="n">v_MBo</span> <span class="o">+</span> <span class="n">ω_MB</span> <span class="n">x</span> <span class="n">p_BoCo</span> <span class="o">+</span> <span class="n">v_BCo</span>
</pre></div>
</div>
<p>a_MCo (frame C’s translational acceleration measured in frame M) is
defined as the time-derivative in frame M of v_MCo, calculated as</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a_MCo</span> <span class="o">=</span> <span class="n">DtM</span><span class="p">(</span><span class="n">v_MCo</span><span class="p">)</span>                             <span class="n">Definition</span><span class="o">.</span>
       <span class="o">=</span> <span class="n">DtM</span><span class="p">(</span><span class="n">v_MBo</span> <span class="o">+</span> <span class="n">ω_MB</span> <span class="n">x</span> <span class="n">p_BoCo</span> <span class="o">+</span> <span class="n">v_BCo</span><span class="p">)</span>     <span class="n">Substitution</span><span class="o">.</span>
       <span class="o">=</span> <span class="n">DtM</span><span class="p">(</span><span class="n">v_MBo</span><span class="p">)</span> <span class="o">+</span> <span class="n">DtM</span><span class="p">(</span><span class="n">ω_MB</span><span class="p">)</span> <span class="n">x</span> <span class="n">p_BoCo</span> <span class="o">+</span> <span class="n">ω_MB</span> <span class="n">x</span> <span class="n">DtM</span><span class="p">(</span><span class="n">p_BoCo</span><span class="p">)</span> <span class="o">+</span> <span class="n">DtM</span><span class="p">(</span><span class="n">v_BCo</span><span class="p">)</span>
       <span class="o">=</span>     <span class="n">a_MBo</span>  <span class="o">+</span>     <span class="n">α_MB</span>  <span class="n">x</span> <span class="n">p_BoCo</span> <span class="o">+</span> <span class="n">ω_MB</span> <span class="n">x</span> <span class="n">DtM</span><span class="p">(</span><span class="n">p_BoCo</span><span class="p">)</span> <span class="o">+</span> <span class="n">DtM</span><span class="p">(</span><span class="n">v_BCo</span><span class="p">)</span>
</pre></div>
</div>
<p>The last two terms are modified using the “Transport Theorem” (Golden
rule for vector differentation) which converts time-derivatives of
vectors in frame M to frame B via DtM(vec) = DtB(vec) + ω_MB x vec.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">DtM</span><span class="p">(</span><span class="n">p_BoCo</span><span class="p">)</span> <span class="o">=</span> <span class="n">DtB</span><span class="p">(</span><span class="n">p_BoCo</span><span class="p">)</span> <span class="o">+</span> <span class="n">ω_MB</span> <span class="n">x</span> <span class="n">p_BoCo</span>
             <span class="o">=</span>     <span class="n">v_BCo</span>   <span class="o">+</span> <span class="n">ω_MB</span> <span class="n">x</span> <span class="n">p_BoCo</span>
 <span class="n">DtM</span><span class="p">(</span><span class="n">v_BCo</span><span class="p">)</span>  <span class="o">=</span> <span class="n">DtB</span><span class="p">(</span><span class="n">v_BCo</span><span class="p">)</span>  <span class="o">+</span> <span class="n">ω_MB</span> <span class="n">x</span> <span class="n">v_BCo</span>
             <span class="o">=</span>     <span class="n">a_BCo</span>   <span class="o">+</span> <span class="n">ω_MB</span> <span class="n">x</span> <span class="n">v_BCo</span>
</pre></div>
</div>
<p>Combining the last few equations proves the formula for a_MCo as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a_MCo</span> <span class="o">=</span> <span class="n">a_MBo</span> <span class="o">+</span> <span class="n">α_MB</span> <span class="n">x</span> <span class="n">p_BoCo</span> <span class="o">+</span> <span class="n">ω_MB</span> <span class="n">x</span> <span class="p">(</span><span class="n">ω_MB</span> <span class="n">x</span> <span class="n">p_BoCo</span><span class="p">)</span>
        <span class="o">+</span> <span class="mi">2</span> <span class="n">ω_MB</span> <span class="n">x</span> <span class="n">v_BCo</span> <span class="o">+</span> <span class="n">a_BCo</span>                           <span class="p">(</span><span class="n">End</span> <span class="n">of</span> <span class="n">proof</span><span class="p">)</span><span class="o">.</span>
</pre></div>
</div>
<p>Some terms in the previous equation have names, e.g.,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">centripetal</span> <span class="n">acceleration</span>   <span class="n">ω_MB</span> <span class="n">x</span> <span class="p">(</span><span class="n">ω_MB</span> <span class="n">x</span> <span class="n">p_BoCo</span><span class="p">)</span>
  <span class="n">Coriolis</span> <span class="n">acceleration</span>    <span class="mi">2</span> <span class="n">ω_MB</span> <span class="n">x</span> <span class="n">v_BCo</span>
  <span class="n">Coincident</span> <span class="n">point</span> <span class="n">acceleration</span><span class="p">,</span> <span class="n">i</span><span class="o">.</span><span class="n">e</span><span class="o">.</span><span class="p">,</span> <span class="n">acceleration</span> <span class="n">of</span> <span class="n">the</span> <span class="n">point</span> <span class="n">of</span> <span class="n">frame</span>
  <span class="n">B</span> <span class="n">coincident</span> <span class="k">with</span> <span class="n">Co</span>      <span class="n">a_MBo</span> <span class="o">+</span> <span class="n">α_MB</span> <span class="n">x</span> <span class="n">p_BoCo</span> <span class="o">+</span> <span class="n">ω_MB</span> <span class="n">x</span> <span class="p">(</span><span class="n">ω_MB</span> <span class="n">x</span> <span class="n">p_BoCo</span><span class="p">)</span>
</pre></div>
</div>
<p>Note: The coincident point acceleration can be calculated with a
Shift().</p>
<p>Note: The three cross products appearing in the previous calculation
of a_MCo can be reduced to one, possibly improving efficiency via</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ω_MB</span> <span class="n">x</span> <span class="p">(</span><span class="n">ω_MB</span> <span class="n">x</span> <span class="n">p_BoCo</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span> <span class="n">ω_MB</span> <span class="n">x</span> <span class="n">v_BCo</span> <span class="o">=</span> <span class="n">ω_MB</span> <span class="n">x</span> <span class="p">(</span><span class="n">v_MCo</span> <span class="o">-</span> <span class="n">v_MBo</span> <span class="o">+</span> <span class="n">v_BCo</span><span class="p">)</span>
</pre></div>
</div>
<p>To show this, we rearrange and substitute our expression for v_MCo.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">v_MCo</span> <span class="o">=</span> <span class="n">v_MBo</span> <span class="o">+</span> <span class="n">ω_MB</span> <span class="n">x</span> <span class="n">p_BoCo</span> <span class="o">+</span> <span class="n">v_BCo</span>        <span class="n">which</span> <span class="n">rearranges</span> <span class="n">to</span>
  <span class="n">ω_MB</span> <span class="n">x</span> <span class="n">p_BoCo</span> <span class="o">=</span> <span class="n">v_MCo</span> <span class="o">-</span> <span class="n">v_MBo</span> <span class="o">-</span> <span class="n">v_BCo</span><span class="o">.</span>             <span class="n">Substitution</span> <span class="n">produces</span>
  <span class="n">ω_MB</span> <span class="n">x</span> <span class="p">(</span><span class="n">ω_MB</span> <span class="n">x</span> <span class="n">p_BoCo</span><span class="p">)</span> <span class="o">=</span> <span class="n">ω_MB</span> <span class="n">x</span> <span class="p">(</span><span class="n">v_MCo</span> <span class="o">-</span> <span class="n">v_MBo</span> <span class="o">-</span> <span class="n">v_BCo</span><span class="p">)</span>           <span class="n">Hence</span><span class="p">,</span>
  <span class="n">ω_MB</span> <span class="n">x</span> <span class="p">(</span><span class="n">ω_MB</span> <span class="n">x</span> <span class="n">p_BoCo</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span> <span class="n">ω_MB</span> <span class="n">x</span> <span class="n">v_BCo</span> <span class="o">=</span> <span class="n">ω_MB</span> <span class="n">x</span> <span class="p">(</span><span class="n">v_MCo</span> <span class="o">-</span> <span class="n">v_MBo</span> <span class="o">+</span> <span class="n">v_BCo</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd].get_coeffs">
<code class="descname">get_coeffs</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[6, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd].get_coeffs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to the underlying storage.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd].Rotate">
<code class="descname">Rotate</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd], R_FE: pydrake.math.RotationMatrix_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd].Rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides a Python-only implementation of rotating / re-expressing a
spatial vector.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is done because defining <code class="docutils literal notranslate"><span class="pre">__rmatmul__</span></code> on this class does
not disambiguate against the definitions of
<code class="docutils literal notranslate"><span class="pre">RotationMatrix.__matmul__</span></code>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd].rotational">
<code class="descname">rotational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd].rotational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the rotational component of this spatial vector.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd].SetZero">
<code class="descname">SetZero</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd].SetZero" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets both the rotational and translational components of <code class="docutils literal notranslate"><span class="pre">this</span></code>
SpatialVector to zero.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd].Shift">
<code class="descname">Shift</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd], offset: numpy.ndarray[object[3, 1]], angular_velocity_of_this_frame: numpy.ndarray[object[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd].Shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Shifts a SpatialAcceleration from a frame B to a frame C, where both B
and C are fixed to the same frame or rigid body.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">offset</span></code>:</dt>
<dd>which is the position vector p_BoCo_E from Bo (frame B’s origin)
to Co (frame C’s origin), expressed in frame E. p_BoCo_E must have
the same expressed-in frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial acceleration,
where <code class="docutils literal notranslate"><span class="pre">this</span></code> is A_MB_E (frame B’s spatial acceleration measured
in M, expressed in E).</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">angular_velocity_of_this_frame</span></code>:</dt>
<dd>which is ω_MB_E, frame B’s angular velocity measured in frame M
and expressed in frame E.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">A_MC_E</span></code>:</dt>
<dd>which is frame C’s spatial acceleration measured in frame M,
expressed in frame E.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Shift() differs from ShiftInPlace() in that Shift() does not
modify <code class="docutils literal notranslate"><span class="pre">this</span></code> whereas ShiftInPlace() does modify <code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">ShiftInPlace() for more information and how A_MC_E is calculated.
Use ComposeWithMovingFrameAcceleration() if frame C is moving on
frame B.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd].ShiftWithZeroAngularVelocity">
<code class="descname">ShiftWithZeroAngularVelocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd], offset: numpy.ndarray[object[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd].ShiftWithZeroAngularVelocity" title="Permalink to this definition">¶</a></dt>
<dd><p>(Advanced) Given <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial acceleration A_MB of a frame B
measured in a frame M, shifts SpatialAcceleration from frame B to a
frame C (i.e., A_MB to A_MC), where both B and C are fixed to the same
frame or rigid body and where ω_MB = 0 (frame B’s angular velocity in
frame M is zero).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">offset</span></code>:</dt>
<dd>which is the position vector p_BoCo_E from Bo (frame B’s origin)
to Co (frame C’s origin), expressed in frame E. p_BoCo_E must have
the same expressed-in frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial acceleration,
where <code class="docutils literal notranslate"><span class="pre">this</span></code> is A_MB_E (frame B’s spatial acceleration measured
in M, expressed in E).</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">A_MC_E</span></code>:</dt>
<dd>which is frame C’s spatial acceleration measured in frame M,
expressed in frame E.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">ShiftInPlace() for more information and how A_MC_E is calculated.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">ShiftWithZeroAngularVelocity() speeds the Shift() computation when
ω_MB = 0, even if α_MB ≠ 0 (α_MB is stored in <code class="docutils literal notranslate"><span class="pre">this</span></code>).</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd].translational">
<code class="descname">translational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd].translational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the translational component of this spatial vector.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd].Zero">
<em class="property">static </em><code class="descname">Zero</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd].Zero" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory to create a <em>zero</em> spatial vector, i.e., a SpatialVector whose
rotational and translational components are both zero.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.math.SpatialAcceleration_[Expression]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.math.</code><code class="descname">SpatialAcceleration_[Expression]</code><a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_[Expression]" title="Permalink to this definition">¶</a></dt>
<dd><p>This class represents a <em>spatial acceleration</em> A and has 6 elements
with an angular (rotational) acceleration α (3-element vector) on top
of a translational (linear) acceleration 𝐚 (3-element vector). Spatial
acceleration represents the rotational and translational acceleration
of a frame B with respect to a <em>measured-in</em> frame M. This class
assumes that both the angular acceleration α and translational
acceleration 𝐚 are expressed in the same <em>expressed-in</em> frame E. This
class only stores 6 elements (namely α and 𝐚) and does not store the
underlying frames B, M, E. The user is responsible for explicitly
tracking the underlying frames with multibody_quantities “monogram
notation”. For example, A_MB_E denotes frame B’s spatial acceleration
measured in frame M, expressed in frame E and contains alpha_MB_E (B’s
angular acceleration measured in M, expressed in E) and a_MBo_E (Bo’s
translational acceleration measured in M, expressed in E), where Bo is
frame B’s origin point. For an multibody_frames_and_bodies “offset
frame” Bp, the monogram notation A_MBp_E denotes frame Bp’s spatial
acceleration measured in M, expressed in E. Details on spatial vectors
and monogram notation are in sections multibody_spatial_vectors and
multibody_quantities.</p>
<p>The typeset for A_MB is <span class="math notranslate nohighlight">\(\,{^MA^B}\)</span> and its definition is
<span class="math notranslate nohighlight">\(^MA^B = \frac{^Md}{dt}\,{^MV^B}\,\)</span>, where <span class="math notranslate nohighlight">\({^MV^B}\)</span> is
frame B’s spatial velocity in frame M and <span class="math notranslate nohighlight">\(\frac{^Md}{dt}\)</span>
denotes the time derivative taken in frame M. To differentiate a
vector, we need to specify in what frame the time derivative is taken,
see [Mitiguy 2022, §7.2] for an in-depth discussion. Time derivatives
in different frames are related by the “Transport Theorem”, which in
Drake is implemented in
drake::math::ConvertTimeDerivativeToOtherFrame(). In source code
(monogram) notation, we write A_MB = DtM(V_MB), where DtM() denotes
the time derivative in frame M. Details on vector differentiation is
in section Dt_multibody_quantities.</p>
<p>[Mitiguy 2022] Mitiguy, P., 2022. Advanced Dynamics &amp; Motion
Simulation.</p>
<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_[Expression].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_[Expression].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialAcceleration_[Expression]) -&gt; None</p>
<blockquote>
<div><p>Constructs to all NaNs.</p>
<dl class="docutils">
<dt>Note:</dt>
<dd><p class="first last">This is different from C++, which in Release builds may leave memory
uninitialized. In pydrake, the function call overhead already trumps
any overhead from NAN-initialization, so we err on the side of
safety.</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialAcceleration_[Expression], alpha: numpy.ndarray[object[3, 1]], a: numpy.ndarray[object[3, 1]]) -&gt; None</p>
</li>
</ol>
<p>Constructs a spatial acceleration A from an angular acceleration α
(alpha) and a translational acceleration 𝐚.</p>
<ol class="arabic simple" start="3">
<li>__init__(self: pydrake.multibody.math.SpatialAcceleration_[Expression], A: numpy.ndarray[object[6, 1]]) -&gt; None</li>
</ol>
<p>Constructs a spatial acceleration A from an Eigen expression that
represents a 6-element vector, i.e., a 3-element angular acceleration
α and a 3-element translational acceleration 𝐚. This constructor will
assert the size of A is six (6) either at compile-time for fixed sized
Eigen expressions or at run-time for dynamic sized Eigen expressions.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_[Expression].ComposeWithMovingFrameAcceleration">
<code class="descname">ComposeWithMovingFrameAcceleration</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialAcceleration_[Expression], position_of_moving_frame: numpy.ndarray[object[3, 1]], angular_velocity_of_this_frame: numpy.ndarray[object[3, 1]], velocity_of_moving_frame: pydrake.multibody.math.SpatialVelocity_[Expression], acceleration_of_moving_frame: pydrake.multibody.math.SpatialAcceleration_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialAcceleration_[Expression]<a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_[Expression].ComposeWithMovingFrameAcceleration" title="Permalink to this definition">¶</a></dt>
<dd><p>Compose <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial acceleration (measured in some frame M) with
the spatial acceleration of another frame to form the 𝐨𝐭𝐡𝐞𝐫 frame’s
spatial acceleration in frame M. Herein, <code class="docutils literal notranslate"><span class="pre">this</span></code> is the spatial
acceleration of a frame (designated B) in frame M and the 𝐨𝐭𝐡𝐞𝐫 frame
is designated C.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">position_of_moving_frame</span></code>:</dt>
<dd>which is the position vector p_BoCo_E (from frame B’s origin Bo to
frame C’s origin Co), expressed in frame E. p_BoCo_E must have the
same expressed-in frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code>, where <code class="docutils literal notranslate"><span class="pre">this</span></code> is A_MB_E
(frame B’s spatial acceleration measured in M, expressed in E).</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">angular_velocity_of_this_frame</span></code>:</dt>
<dd>which is ω_MB_E, frame B’s angular velocity measured in frame W
and expressed in frame E.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">velocity_of_moving_frame</span></code>:</dt>
<dd>which is V_BC_E, frame C’s spatial velocity measured in frame B,
expressed in frame E.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">acceleration_of_moving_frame</span></code>:</dt>
<dd>which is A_BC_E, frame C’s spatial acceleration measured in frame
B, expressed in frame E.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">A_MC_E</span></code>:</dt>
<dd>frame C’s spatial acceleration measured in frame M, expressed in
frame E.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">SpatialVelocity::ComposeWithMovingFrameVelocity(). Use Shift() if
frames B and C are both fixed to the same frame or body, i.e.,
velocity_of_moving_frame = 0 and acceleration_of_moving_frame = 0.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The returned spatial acceleration A_MC_E contains an angular
acceleration α_MC_E and translational acceleration a_MCo_E that
are calculated as:</p>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">α_MC_E</span>  <span class="o">=</span> <span class="n">α_MB_E</span> <span class="o">+</span> <span class="n">α_BC_E</span> <span class="o">+</span> <span class="n">ω_MB_E</span> <span class="n">x</span> <span class="n">ω_BC_E</span>
 <span class="n">a_MCo_E</span> <span class="o">=</span> <span class="n">a_BCo_E</span> <span class="o">+</span> <span class="n">α_MB_E</span> <span class="n">x</span> <span class="n">p_BoCo_E</span> <span class="o">+</span> <span class="n">ω_MB_E</span> <span class="n">x</span> <span class="p">(</span><span class="n">ω_MB_E</span> <span class="n">x</span> <span class="n">p_BoCo_E</span><span class="p">)</span>
         <span class="o">+</span> <span class="mi">2</span> <span class="n">ω_MB_E</span> <span class="n">x</span> <span class="n">v_BCo_E</span> <span class="o">+</span> <span class="n">a_BCo_E</span>
</pre></div>
</div>
<p>If frame C is rigidly fixed to frame B, A_BC_E = 0 and V_BC_E = 0 and
this method produces a Shift() operation (albeit inefficiently). The
previous equations show composing spatial acceleration is not simply
adding A_MB + A_BC and these equations differ significantly from their
spatial velocity counterparts. For example, angular velocities simply
add as</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ω_MC</span> <span class="o">=</span> <span class="n">ω_MB</span> <span class="o">+</span> <span class="n">ω_BC</span><span class="p">,</span>   <span class="n">but</span> <span class="mi">3</span><span class="n">D</span> <span class="n">angular</span> <span class="n">acceleration</span> <span class="ow">is</span> <span class="n">more</span> <span class="n">complicated</span> <span class="k">as</span>
  <span class="n">α_MC</span> <span class="o">=</span> <span class="n">α_MB</span> <span class="o">+</span> <span class="n">α_BC</span> <span class="o">+</span> <span class="n">ω_MB</span> <span class="n">x</span> <span class="n">ω_BC</span>
</pre></div>
</div>
<p>** Derivation **</p>
<ul class="simple">
<li>Rotational acceleration component *</li>
</ul>
<p>ω_MC (frame C’s angular velocity in frame M) can be calculated with
the angular velocity addition theorem as</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ω_MC</span> <span class="o">=</span> <span class="n">ω_MB</span> <span class="o">+</span> <span class="n">ω_BC</span>
</pre></div>
</div>
<p>α_MC (frame C’s angular acceleration measured in frame M) is defined
as the time-derivative in frame M of ω_MC, and can be calculated using
the “Transport Theorem” (Golden rule for vector differentation) which
converts the time-derivative of a vector in frame M to frame B, e.g.,
as DtM(ω_BC) = DtB(ω_BC) + ω_MB x ω_BC, as</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">α_MC</span> <span class="o">=</span> <span class="n">DtM</span><span class="p">(</span><span class="n">ω_MC</span><span class="p">)</span> <span class="o">=</span> <span class="n">DtM</span><span class="p">(</span><span class="n">ω_MB</span><span class="p">)</span> <span class="o">+</span> <span class="n">DtM</span><span class="p">(</span><span class="n">ω_BC</span><span class="p">)</span>
                   <span class="o">=</span>     <span class="n">α_MB</span>  <span class="o">+</span> <span class="n">DtB</span><span class="p">(</span><span class="n">ω_BC</span><span class="p">)</span> <span class="o">+</span> <span class="n">ω_MB</span> <span class="n">x</span> <span class="n">ω_BC</span>
                   <span class="o">=</span>     <span class="n">α_MB</span>  <span class="o">+</span>     <span class="n">α_BC</span>  <span class="o">+</span> <span class="n">ω_MB</span> <span class="n">x</span> <span class="n">ω_BC</span>   <span class="p">(</span><span class="n">End</span> <span class="n">of</span> <span class="n">proof</span><span class="p">)</span><span class="o">.</span>
</pre></div>
</div>
<ul class="simple">
<li>Translational acceleration component *</li>
</ul>
<p>v_MCo (frame C’s translational velocity in frame M) is calculated in
SpatialVelocity::ComposeWithMovingFrameVelocity) as</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">v_MCo</span> <span class="o">=</span> <span class="n">v_MBo</span> <span class="o">+</span> <span class="n">ω_MB</span> <span class="n">x</span> <span class="n">p_BoCo</span> <span class="o">+</span> <span class="n">v_BCo</span>
</pre></div>
</div>
<p>a_MCo (frame C’s translational acceleration measured in frame M) is
defined as the time-derivative in frame M of v_MCo, calculated as</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a_MCo</span> <span class="o">=</span> <span class="n">DtM</span><span class="p">(</span><span class="n">v_MCo</span><span class="p">)</span>                             <span class="n">Definition</span><span class="o">.</span>
       <span class="o">=</span> <span class="n">DtM</span><span class="p">(</span><span class="n">v_MBo</span> <span class="o">+</span> <span class="n">ω_MB</span> <span class="n">x</span> <span class="n">p_BoCo</span> <span class="o">+</span> <span class="n">v_BCo</span><span class="p">)</span>     <span class="n">Substitution</span><span class="o">.</span>
       <span class="o">=</span> <span class="n">DtM</span><span class="p">(</span><span class="n">v_MBo</span><span class="p">)</span> <span class="o">+</span> <span class="n">DtM</span><span class="p">(</span><span class="n">ω_MB</span><span class="p">)</span> <span class="n">x</span> <span class="n">p_BoCo</span> <span class="o">+</span> <span class="n">ω_MB</span> <span class="n">x</span> <span class="n">DtM</span><span class="p">(</span><span class="n">p_BoCo</span><span class="p">)</span> <span class="o">+</span> <span class="n">DtM</span><span class="p">(</span><span class="n">v_BCo</span><span class="p">)</span>
       <span class="o">=</span>     <span class="n">a_MBo</span>  <span class="o">+</span>     <span class="n">α_MB</span>  <span class="n">x</span> <span class="n">p_BoCo</span> <span class="o">+</span> <span class="n">ω_MB</span> <span class="n">x</span> <span class="n">DtM</span><span class="p">(</span><span class="n">p_BoCo</span><span class="p">)</span> <span class="o">+</span> <span class="n">DtM</span><span class="p">(</span><span class="n">v_BCo</span><span class="p">)</span>
</pre></div>
</div>
<p>The last two terms are modified using the “Transport Theorem” (Golden
rule for vector differentation) which converts time-derivatives of
vectors in frame M to frame B via DtM(vec) = DtB(vec) + ω_MB x vec.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">DtM</span><span class="p">(</span><span class="n">p_BoCo</span><span class="p">)</span> <span class="o">=</span> <span class="n">DtB</span><span class="p">(</span><span class="n">p_BoCo</span><span class="p">)</span> <span class="o">+</span> <span class="n">ω_MB</span> <span class="n">x</span> <span class="n">p_BoCo</span>
             <span class="o">=</span>     <span class="n">v_BCo</span>   <span class="o">+</span> <span class="n">ω_MB</span> <span class="n">x</span> <span class="n">p_BoCo</span>
 <span class="n">DtM</span><span class="p">(</span><span class="n">v_BCo</span><span class="p">)</span>  <span class="o">=</span> <span class="n">DtB</span><span class="p">(</span><span class="n">v_BCo</span><span class="p">)</span>  <span class="o">+</span> <span class="n">ω_MB</span> <span class="n">x</span> <span class="n">v_BCo</span>
             <span class="o">=</span>     <span class="n">a_BCo</span>   <span class="o">+</span> <span class="n">ω_MB</span> <span class="n">x</span> <span class="n">v_BCo</span>
</pre></div>
</div>
<p>Combining the last few equations proves the formula for a_MCo as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a_MCo</span> <span class="o">=</span> <span class="n">a_MBo</span> <span class="o">+</span> <span class="n">α_MB</span> <span class="n">x</span> <span class="n">p_BoCo</span> <span class="o">+</span> <span class="n">ω_MB</span> <span class="n">x</span> <span class="p">(</span><span class="n">ω_MB</span> <span class="n">x</span> <span class="n">p_BoCo</span><span class="p">)</span>
        <span class="o">+</span> <span class="mi">2</span> <span class="n">ω_MB</span> <span class="n">x</span> <span class="n">v_BCo</span> <span class="o">+</span> <span class="n">a_BCo</span>                           <span class="p">(</span><span class="n">End</span> <span class="n">of</span> <span class="n">proof</span><span class="p">)</span><span class="o">.</span>
</pre></div>
</div>
<p>Some terms in the previous equation have names, e.g.,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">centripetal</span> <span class="n">acceleration</span>   <span class="n">ω_MB</span> <span class="n">x</span> <span class="p">(</span><span class="n">ω_MB</span> <span class="n">x</span> <span class="n">p_BoCo</span><span class="p">)</span>
  <span class="n">Coriolis</span> <span class="n">acceleration</span>    <span class="mi">2</span> <span class="n">ω_MB</span> <span class="n">x</span> <span class="n">v_BCo</span>
  <span class="n">Coincident</span> <span class="n">point</span> <span class="n">acceleration</span><span class="p">,</span> <span class="n">i</span><span class="o">.</span><span class="n">e</span><span class="o">.</span><span class="p">,</span> <span class="n">acceleration</span> <span class="n">of</span> <span class="n">the</span> <span class="n">point</span> <span class="n">of</span> <span class="n">frame</span>
  <span class="n">B</span> <span class="n">coincident</span> <span class="k">with</span> <span class="n">Co</span>      <span class="n">a_MBo</span> <span class="o">+</span> <span class="n">α_MB</span> <span class="n">x</span> <span class="n">p_BoCo</span> <span class="o">+</span> <span class="n">ω_MB</span> <span class="n">x</span> <span class="p">(</span><span class="n">ω_MB</span> <span class="n">x</span> <span class="n">p_BoCo</span><span class="p">)</span>
</pre></div>
</div>
<p>Note: The coincident point acceleration can be calculated with a
Shift().</p>
<p>Note: The three cross products appearing in the previous calculation
of a_MCo can be reduced to one, possibly improving efficiency via</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ω_MB</span> <span class="n">x</span> <span class="p">(</span><span class="n">ω_MB</span> <span class="n">x</span> <span class="n">p_BoCo</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span> <span class="n">ω_MB</span> <span class="n">x</span> <span class="n">v_BCo</span> <span class="o">=</span> <span class="n">ω_MB</span> <span class="n">x</span> <span class="p">(</span><span class="n">v_MCo</span> <span class="o">-</span> <span class="n">v_MBo</span> <span class="o">+</span> <span class="n">v_BCo</span><span class="p">)</span>
</pre></div>
</div>
<p>To show this, we rearrange and substitute our expression for v_MCo.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">v_MCo</span> <span class="o">=</span> <span class="n">v_MBo</span> <span class="o">+</span> <span class="n">ω_MB</span> <span class="n">x</span> <span class="n">p_BoCo</span> <span class="o">+</span> <span class="n">v_BCo</span>        <span class="n">which</span> <span class="n">rearranges</span> <span class="n">to</span>
  <span class="n">ω_MB</span> <span class="n">x</span> <span class="n">p_BoCo</span> <span class="o">=</span> <span class="n">v_MCo</span> <span class="o">-</span> <span class="n">v_MBo</span> <span class="o">-</span> <span class="n">v_BCo</span><span class="o">.</span>             <span class="n">Substitution</span> <span class="n">produces</span>
  <span class="n">ω_MB</span> <span class="n">x</span> <span class="p">(</span><span class="n">ω_MB</span> <span class="n">x</span> <span class="n">p_BoCo</span><span class="p">)</span> <span class="o">=</span> <span class="n">ω_MB</span> <span class="n">x</span> <span class="p">(</span><span class="n">v_MCo</span> <span class="o">-</span> <span class="n">v_MBo</span> <span class="o">-</span> <span class="n">v_BCo</span><span class="p">)</span>           <span class="n">Hence</span><span class="p">,</span>
  <span class="n">ω_MB</span> <span class="n">x</span> <span class="p">(</span><span class="n">ω_MB</span> <span class="n">x</span> <span class="n">p_BoCo</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span> <span class="n">ω_MB</span> <span class="n">x</span> <span class="n">v_BCo</span> <span class="o">=</span> <span class="n">ω_MB</span> <span class="n">x</span> <span class="p">(</span><span class="n">v_MCo</span> <span class="o">-</span> <span class="n">v_MBo</span> <span class="o">+</span> <span class="n">v_BCo</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_[Expression].get_coeffs">
<code class="descname">get_coeffs</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialAcceleration_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[6, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_[Expression].get_coeffs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to the underlying storage.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_[Expression].Rotate">
<code class="descname">Rotate</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialAcceleration_[Expression], R_FE: pydrake.math.RotationMatrix_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialAcceleration_[Expression]<a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_[Expression].Rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides a Python-only implementation of rotating / re-expressing a
spatial vector.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is done because defining <code class="docutils literal notranslate"><span class="pre">__rmatmul__</span></code> on this class does
not disambiguate against the definitions of
<code class="docutils literal notranslate"><span class="pre">RotationMatrix.__matmul__</span></code>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_[Expression].rotational">
<code class="descname">rotational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialAcceleration_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_[Expression].rotational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the rotational component of this spatial vector.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_[Expression].SetZero">
<code class="descname">SetZero</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialAcceleration_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialAcceleration_[Expression]<a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_[Expression].SetZero" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets both the rotational and translational components of <code class="docutils literal notranslate"><span class="pre">this</span></code>
SpatialVector to zero.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_[Expression].Shift">
<code class="descname">Shift</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialAcceleration_[Expression], offset: numpy.ndarray[object[3, 1]], angular_velocity_of_this_frame: numpy.ndarray[object[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialAcceleration_[Expression]<a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_[Expression].Shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Shifts a SpatialAcceleration from a frame B to a frame C, where both B
and C are fixed to the same frame or rigid body.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">offset</span></code>:</dt>
<dd>which is the position vector p_BoCo_E from Bo (frame B’s origin)
to Co (frame C’s origin), expressed in frame E. p_BoCo_E must have
the same expressed-in frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial acceleration,
where <code class="docutils literal notranslate"><span class="pre">this</span></code> is A_MB_E (frame B’s spatial acceleration measured
in M, expressed in E).</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">angular_velocity_of_this_frame</span></code>:</dt>
<dd>which is ω_MB_E, frame B’s angular velocity measured in frame M
and expressed in frame E.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">A_MC_E</span></code>:</dt>
<dd>which is frame C’s spatial acceleration measured in frame M,
expressed in frame E.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Shift() differs from ShiftInPlace() in that Shift() does not
modify <code class="docutils literal notranslate"><span class="pre">this</span></code> whereas ShiftInPlace() does modify <code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">ShiftInPlace() for more information and how A_MC_E is calculated.
Use ComposeWithMovingFrameAcceleration() if frame C is moving on
frame B.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_[Expression].ShiftWithZeroAngularVelocity">
<code class="descname">ShiftWithZeroAngularVelocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialAcceleration_[Expression], offset: numpy.ndarray[object[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialAcceleration_[Expression]<a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_[Expression].ShiftWithZeroAngularVelocity" title="Permalink to this definition">¶</a></dt>
<dd><p>(Advanced) Given <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial acceleration A_MB of a frame B
measured in a frame M, shifts SpatialAcceleration from frame B to a
frame C (i.e., A_MB to A_MC), where both B and C are fixed to the same
frame or rigid body and where ω_MB = 0 (frame B’s angular velocity in
frame M is zero).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">offset</span></code>:</dt>
<dd>which is the position vector p_BoCo_E from Bo (frame B’s origin)
to Co (frame C’s origin), expressed in frame E. p_BoCo_E must have
the same expressed-in frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial acceleration,
where <code class="docutils literal notranslate"><span class="pre">this</span></code> is A_MB_E (frame B’s spatial acceleration measured
in M, expressed in E).</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">A_MC_E</span></code>:</dt>
<dd>which is frame C’s spatial acceleration measured in frame M,
expressed in frame E.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">ShiftInPlace() for more information and how A_MC_E is calculated.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">ShiftWithZeroAngularVelocity() speeds the Shift() computation when
ω_MB = 0, even if α_MB ≠ 0 (α_MB is stored in <code class="docutils literal notranslate"><span class="pre">this</span></code>).</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_[Expression].translational">
<code class="descname">translational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialAcceleration_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_[Expression].translational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the translational component of this spatial vector.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.math.SpatialAcceleration_[Expression].Zero">
<em class="property">static </em><code class="descname">Zero</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialAcceleration_[Expression]<a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_[Expression].Zero" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory to create a <em>zero</em> spatial vector, i.e., a SpatialVector whose
rotational and translational components are both zero.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.math.SpatialAcceleration_[float]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.math.</code><code class="descname">SpatialAcceleration_[float]</code><a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>This class represents a <em>spatial acceleration</em> A and has 6 elements
with an angular (rotational) acceleration α (3-element vector) on top
of a translational (linear) acceleration 𝐚 (3-element vector). Spatial
acceleration represents the rotational and translational acceleration
of a frame B with respect to a <em>measured-in</em> frame M. This class
assumes that both the angular acceleration α and translational
acceleration 𝐚 are expressed in the same <em>expressed-in</em> frame E. This
class only stores 6 elements (namely α and 𝐚) and does not store the
underlying frames B, M, E. The user is responsible for explicitly
tracking the underlying frames with multibody_quantities “monogram
notation”. For example, A_MB_E denotes frame B’s spatial acceleration
measured in frame M, expressed in frame E and contains alpha_MB_E (B’s
angular acceleration measured in M, expressed in E) and a_MBo_E (Bo’s
translational acceleration measured in M, expressed in E), where Bo is
frame B’s origin point. For an multibody_frames_and_bodies “offset
frame” Bp, the monogram notation A_MBp_E denotes frame Bp’s spatial
acceleration measured in M, expressed in E. Details on spatial vectors
and monogram notation are in sections multibody_spatial_vectors and
multibody_quantities.</p>
<p>The typeset for A_MB is <span class="math notranslate nohighlight">\(\,{^MA^B}\)</span> and its definition is
<span class="math notranslate nohighlight">\(^MA^B = \frac{^Md}{dt}\,{^MV^B}\,\)</span>, where <span class="math notranslate nohighlight">\({^MV^B}\)</span> is
frame B’s spatial velocity in frame M and <span class="math notranslate nohighlight">\(\frac{^Md}{dt}\)</span>
denotes the time derivative taken in frame M. To differentiate a
vector, we need to specify in what frame the time derivative is taken,
see [Mitiguy 2022, §7.2] for an in-depth discussion. Time derivatives
in different frames are related by the “Transport Theorem”, which in
Drake is implemented in
drake::math::ConvertTimeDerivativeToOtherFrame(). In source code
(monogram) notation, we write A_MB = DtM(V_MB), where DtM() denotes
the time derivative in frame M. Details on vector differentiation is
in section Dt_multibody_quantities.</p>
<p>[Mitiguy 2022] Mitiguy, P., 2022. Advanced Dynamics &amp; Motion
Simulation.</p>
<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialAcceleration_[float]) -&gt; None</p>
<blockquote>
<div><p>Constructs to all NaNs.</p>
<dl class="docutils">
<dt>Note:</dt>
<dd><p class="first last">This is different from C++, which in Release builds may leave memory
uninitialized. In pydrake, the function call overhead already trumps
any overhead from NAN-initialization, so we err on the side of
safety.</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialAcceleration_[float], alpha: numpy.ndarray[numpy.float64[3, 1]], a: numpy.ndarray[numpy.float64[3, 1]]) -&gt; None</p>
</li>
</ol>
<p>Constructs a spatial acceleration A from an angular acceleration α
(alpha) and a translational acceleration 𝐚.</p>
<ol class="arabic simple" start="3">
<li>__init__(self: pydrake.multibody.math.SpatialAcceleration_[float], A: numpy.ndarray[numpy.float64[6, 1]]) -&gt; None</li>
</ol>
<p>Constructs a spatial acceleration A from an Eigen expression that
represents a 6-element vector, i.e., a 3-element angular acceleration
α and a 3-element translational acceleration 𝐚. This constructor will
assert the size of A is six (6) either at compile-time for fixed sized
Eigen expressions or at run-time for dynamic sized Eigen expressions.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_[float].ComposeWithMovingFrameAcceleration">
<code class="descname">ComposeWithMovingFrameAcceleration</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialAcceleration_[float], position_of_moving_frame: numpy.ndarray[numpy.float64[3, 1]], angular_velocity_of_this_frame: numpy.ndarray[numpy.float64[3, 1]], velocity_of_moving_frame: pydrake.multibody.math.SpatialVelocity_[float], acceleration_of_moving_frame: pydrake.multibody.math.SpatialAcceleration_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialAcceleration_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_[float].ComposeWithMovingFrameAcceleration" title="Permalink to this definition">¶</a></dt>
<dd><p>Compose <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial acceleration (measured in some frame M) with
the spatial acceleration of another frame to form the 𝐨𝐭𝐡𝐞𝐫 frame’s
spatial acceleration in frame M. Herein, <code class="docutils literal notranslate"><span class="pre">this</span></code> is the spatial
acceleration of a frame (designated B) in frame M and the 𝐨𝐭𝐡𝐞𝐫 frame
is designated C.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">position_of_moving_frame</span></code>:</dt>
<dd>which is the position vector p_BoCo_E (from frame B’s origin Bo to
frame C’s origin Co), expressed in frame E. p_BoCo_E must have the
same expressed-in frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code>, where <code class="docutils literal notranslate"><span class="pre">this</span></code> is A_MB_E
(frame B’s spatial acceleration measured in M, expressed in E).</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">angular_velocity_of_this_frame</span></code>:</dt>
<dd>which is ω_MB_E, frame B’s angular velocity measured in frame W
and expressed in frame E.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">velocity_of_moving_frame</span></code>:</dt>
<dd>which is V_BC_E, frame C’s spatial velocity measured in frame B,
expressed in frame E.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">acceleration_of_moving_frame</span></code>:</dt>
<dd>which is A_BC_E, frame C’s spatial acceleration measured in frame
B, expressed in frame E.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">A_MC_E</span></code>:</dt>
<dd>frame C’s spatial acceleration measured in frame M, expressed in
frame E.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">SpatialVelocity::ComposeWithMovingFrameVelocity(). Use Shift() if
frames B and C are both fixed to the same frame or body, i.e.,
velocity_of_moving_frame = 0 and acceleration_of_moving_frame = 0.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The returned spatial acceleration A_MC_E contains an angular
acceleration α_MC_E and translational acceleration a_MCo_E that
are calculated as:</p>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">α_MC_E</span>  <span class="o">=</span> <span class="n">α_MB_E</span> <span class="o">+</span> <span class="n">α_BC_E</span> <span class="o">+</span> <span class="n">ω_MB_E</span> <span class="n">x</span> <span class="n">ω_BC_E</span>
 <span class="n">a_MCo_E</span> <span class="o">=</span> <span class="n">a_BCo_E</span> <span class="o">+</span> <span class="n">α_MB_E</span> <span class="n">x</span> <span class="n">p_BoCo_E</span> <span class="o">+</span> <span class="n">ω_MB_E</span> <span class="n">x</span> <span class="p">(</span><span class="n">ω_MB_E</span> <span class="n">x</span> <span class="n">p_BoCo_E</span><span class="p">)</span>
         <span class="o">+</span> <span class="mi">2</span> <span class="n">ω_MB_E</span> <span class="n">x</span> <span class="n">v_BCo_E</span> <span class="o">+</span> <span class="n">a_BCo_E</span>
</pre></div>
</div>
<p>If frame C is rigidly fixed to frame B, A_BC_E = 0 and V_BC_E = 0 and
this method produces a Shift() operation (albeit inefficiently). The
previous equations show composing spatial acceleration is not simply
adding A_MB + A_BC and these equations differ significantly from their
spatial velocity counterparts. For example, angular velocities simply
add as</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ω_MC</span> <span class="o">=</span> <span class="n">ω_MB</span> <span class="o">+</span> <span class="n">ω_BC</span><span class="p">,</span>   <span class="n">but</span> <span class="mi">3</span><span class="n">D</span> <span class="n">angular</span> <span class="n">acceleration</span> <span class="ow">is</span> <span class="n">more</span> <span class="n">complicated</span> <span class="k">as</span>
  <span class="n">α_MC</span> <span class="o">=</span> <span class="n">α_MB</span> <span class="o">+</span> <span class="n">α_BC</span> <span class="o">+</span> <span class="n">ω_MB</span> <span class="n">x</span> <span class="n">ω_BC</span>
</pre></div>
</div>
<p>** Derivation **</p>
<ul class="simple">
<li>Rotational acceleration component *</li>
</ul>
<p>ω_MC (frame C’s angular velocity in frame M) can be calculated with
the angular velocity addition theorem as</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ω_MC</span> <span class="o">=</span> <span class="n">ω_MB</span> <span class="o">+</span> <span class="n">ω_BC</span>
</pre></div>
</div>
<p>α_MC (frame C’s angular acceleration measured in frame M) is defined
as the time-derivative in frame M of ω_MC, and can be calculated using
the “Transport Theorem” (Golden rule for vector differentation) which
converts the time-derivative of a vector in frame M to frame B, e.g.,
as DtM(ω_BC) = DtB(ω_BC) + ω_MB x ω_BC, as</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">α_MC</span> <span class="o">=</span> <span class="n">DtM</span><span class="p">(</span><span class="n">ω_MC</span><span class="p">)</span> <span class="o">=</span> <span class="n">DtM</span><span class="p">(</span><span class="n">ω_MB</span><span class="p">)</span> <span class="o">+</span> <span class="n">DtM</span><span class="p">(</span><span class="n">ω_BC</span><span class="p">)</span>
                   <span class="o">=</span>     <span class="n">α_MB</span>  <span class="o">+</span> <span class="n">DtB</span><span class="p">(</span><span class="n">ω_BC</span><span class="p">)</span> <span class="o">+</span> <span class="n">ω_MB</span> <span class="n">x</span> <span class="n">ω_BC</span>
                   <span class="o">=</span>     <span class="n">α_MB</span>  <span class="o">+</span>     <span class="n">α_BC</span>  <span class="o">+</span> <span class="n">ω_MB</span> <span class="n">x</span> <span class="n">ω_BC</span>   <span class="p">(</span><span class="n">End</span> <span class="n">of</span> <span class="n">proof</span><span class="p">)</span><span class="o">.</span>
</pre></div>
</div>
<ul class="simple">
<li>Translational acceleration component *</li>
</ul>
<p>v_MCo (frame C’s translational velocity in frame M) is calculated in
SpatialVelocity::ComposeWithMovingFrameVelocity) as</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">v_MCo</span> <span class="o">=</span> <span class="n">v_MBo</span> <span class="o">+</span> <span class="n">ω_MB</span> <span class="n">x</span> <span class="n">p_BoCo</span> <span class="o">+</span> <span class="n">v_BCo</span>
</pre></div>
</div>
<p>a_MCo (frame C’s translational acceleration measured in frame M) is
defined as the time-derivative in frame M of v_MCo, calculated as</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a_MCo</span> <span class="o">=</span> <span class="n">DtM</span><span class="p">(</span><span class="n">v_MCo</span><span class="p">)</span>                             <span class="n">Definition</span><span class="o">.</span>
       <span class="o">=</span> <span class="n">DtM</span><span class="p">(</span><span class="n">v_MBo</span> <span class="o">+</span> <span class="n">ω_MB</span> <span class="n">x</span> <span class="n">p_BoCo</span> <span class="o">+</span> <span class="n">v_BCo</span><span class="p">)</span>     <span class="n">Substitution</span><span class="o">.</span>
       <span class="o">=</span> <span class="n">DtM</span><span class="p">(</span><span class="n">v_MBo</span><span class="p">)</span> <span class="o">+</span> <span class="n">DtM</span><span class="p">(</span><span class="n">ω_MB</span><span class="p">)</span> <span class="n">x</span> <span class="n">p_BoCo</span> <span class="o">+</span> <span class="n">ω_MB</span> <span class="n">x</span> <span class="n">DtM</span><span class="p">(</span><span class="n">p_BoCo</span><span class="p">)</span> <span class="o">+</span> <span class="n">DtM</span><span class="p">(</span><span class="n">v_BCo</span><span class="p">)</span>
       <span class="o">=</span>     <span class="n">a_MBo</span>  <span class="o">+</span>     <span class="n">α_MB</span>  <span class="n">x</span> <span class="n">p_BoCo</span> <span class="o">+</span> <span class="n">ω_MB</span> <span class="n">x</span> <span class="n">DtM</span><span class="p">(</span><span class="n">p_BoCo</span><span class="p">)</span> <span class="o">+</span> <span class="n">DtM</span><span class="p">(</span><span class="n">v_BCo</span><span class="p">)</span>
</pre></div>
</div>
<p>The last two terms are modified using the “Transport Theorem” (Golden
rule for vector differentation) which converts time-derivatives of
vectors in frame M to frame B via DtM(vec) = DtB(vec) + ω_MB x vec.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">DtM</span><span class="p">(</span><span class="n">p_BoCo</span><span class="p">)</span> <span class="o">=</span> <span class="n">DtB</span><span class="p">(</span><span class="n">p_BoCo</span><span class="p">)</span> <span class="o">+</span> <span class="n">ω_MB</span> <span class="n">x</span> <span class="n">p_BoCo</span>
             <span class="o">=</span>     <span class="n">v_BCo</span>   <span class="o">+</span> <span class="n">ω_MB</span> <span class="n">x</span> <span class="n">p_BoCo</span>
 <span class="n">DtM</span><span class="p">(</span><span class="n">v_BCo</span><span class="p">)</span>  <span class="o">=</span> <span class="n">DtB</span><span class="p">(</span><span class="n">v_BCo</span><span class="p">)</span>  <span class="o">+</span> <span class="n">ω_MB</span> <span class="n">x</span> <span class="n">v_BCo</span>
             <span class="o">=</span>     <span class="n">a_BCo</span>   <span class="o">+</span> <span class="n">ω_MB</span> <span class="n">x</span> <span class="n">v_BCo</span>
</pre></div>
</div>
<p>Combining the last few equations proves the formula for a_MCo as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a_MCo</span> <span class="o">=</span> <span class="n">a_MBo</span> <span class="o">+</span> <span class="n">α_MB</span> <span class="n">x</span> <span class="n">p_BoCo</span> <span class="o">+</span> <span class="n">ω_MB</span> <span class="n">x</span> <span class="p">(</span><span class="n">ω_MB</span> <span class="n">x</span> <span class="n">p_BoCo</span><span class="p">)</span>
        <span class="o">+</span> <span class="mi">2</span> <span class="n">ω_MB</span> <span class="n">x</span> <span class="n">v_BCo</span> <span class="o">+</span> <span class="n">a_BCo</span>                           <span class="p">(</span><span class="n">End</span> <span class="n">of</span> <span class="n">proof</span><span class="p">)</span><span class="o">.</span>
</pre></div>
</div>
<p>Some terms in the previous equation have names, e.g.,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">centripetal</span> <span class="n">acceleration</span>   <span class="n">ω_MB</span> <span class="n">x</span> <span class="p">(</span><span class="n">ω_MB</span> <span class="n">x</span> <span class="n">p_BoCo</span><span class="p">)</span>
  <span class="n">Coriolis</span> <span class="n">acceleration</span>    <span class="mi">2</span> <span class="n">ω_MB</span> <span class="n">x</span> <span class="n">v_BCo</span>
  <span class="n">Coincident</span> <span class="n">point</span> <span class="n">acceleration</span><span class="p">,</span> <span class="n">i</span><span class="o">.</span><span class="n">e</span><span class="o">.</span><span class="p">,</span> <span class="n">acceleration</span> <span class="n">of</span> <span class="n">the</span> <span class="n">point</span> <span class="n">of</span> <span class="n">frame</span>
  <span class="n">B</span> <span class="n">coincident</span> <span class="k">with</span> <span class="n">Co</span>      <span class="n">a_MBo</span> <span class="o">+</span> <span class="n">α_MB</span> <span class="n">x</span> <span class="n">p_BoCo</span> <span class="o">+</span> <span class="n">ω_MB</span> <span class="n">x</span> <span class="p">(</span><span class="n">ω_MB</span> <span class="n">x</span> <span class="n">p_BoCo</span><span class="p">)</span>
</pre></div>
</div>
<p>Note: The coincident point acceleration can be calculated with a
Shift().</p>
<p>Note: The three cross products appearing in the previous calculation
of a_MCo can be reduced to one, possibly improving efficiency via</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ω_MB</span> <span class="n">x</span> <span class="p">(</span><span class="n">ω_MB</span> <span class="n">x</span> <span class="n">p_BoCo</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span> <span class="n">ω_MB</span> <span class="n">x</span> <span class="n">v_BCo</span> <span class="o">=</span> <span class="n">ω_MB</span> <span class="n">x</span> <span class="p">(</span><span class="n">v_MCo</span> <span class="o">-</span> <span class="n">v_MBo</span> <span class="o">+</span> <span class="n">v_BCo</span><span class="p">)</span>
</pre></div>
</div>
<p>To show this, we rearrange and substitute our expression for v_MCo.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">v_MCo</span> <span class="o">=</span> <span class="n">v_MBo</span> <span class="o">+</span> <span class="n">ω_MB</span> <span class="n">x</span> <span class="n">p_BoCo</span> <span class="o">+</span> <span class="n">v_BCo</span>        <span class="n">which</span> <span class="n">rearranges</span> <span class="n">to</span>
  <span class="n">ω_MB</span> <span class="n">x</span> <span class="n">p_BoCo</span> <span class="o">=</span> <span class="n">v_MCo</span> <span class="o">-</span> <span class="n">v_MBo</span> <span class="o">-</span> <span class="n">v_BCo</span><span class="o">.</span>             <span class="n">Substitution</span> <span class="n">produces</span>
  <span class="n">ω_MB</span> <span class="n">x</span> <span class="p">(</span><span class="n">ω_MB</span> <span class="n">x</span> <span class="n">p_BoCo</span><span class="p">)</span> <span class="o">=</span> <span class="n">ω_MB</span> <span class="n">x</span> <span class="p">(</span><span class="n">v_MCo</span> <span class="o">-</span> <span class="n">v_MBo</span> <span class="o">-</span> <span class="n">v_BCo</span><span class="p">)</span>           <span class="n">Hence</span><span class="p">,</span>
  <span class="n">ω_MB</span> <span class="n">x</span> <span class="p">(</span><span class="n">ω_MB</span> <span class="n">x</span> <span class="n">p_BoCo</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span> <span class="n">ω_MB</span> <span class="n">x</span> <span class="n">v_BCo</span> <span class="o">=</span> <span class="n">ω_MB</span> <span class="n">x</span> <span class="p">(</span><span class="n">v_MCo</span> <span class="o">-</span> <span class="n">v_MBo</span> <span class="o">+</span> <span class="n">v_BCo</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_[float].get_coeffs">
<code class="descname">get_coeffs</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialAcceleration_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[6, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_[float].get_coeffs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to the underlying storage.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_[float].Rotate">
<code class="descname">Rotate</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialAcceleration_[float], R_FE: pydrake.math.RotationMatrix_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialAcceleration_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_[float].Rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides a Python-only implementation of rotating / re-expressing a
spatial vector.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is done because defining <code class="docutils literal notranslate"><span class="pre">__rmatmul__</span></code> on this class does
not disambiguate against the definitions of
<code class="docutils literal notranslate"><span class="pre">RotationMatrix.__matmul__</span></code>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_[float].rotational">
<code class="descname">rotational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialAcceleration_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_[float].rotational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the rotational component of this spatial vector.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_[float].SetZero">
<code class="descname">SetZero</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialAcceleration_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialAcceleration_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_[float].SetZero" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets both the rotational and translational components of <code class="docutils literal notranslate"><span class="pre">this</span></code>
SpatialVector to zero.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_[float].Shift">
<code class="descname">Shift</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialAcceleration_[float], offset: numpy.ndarray[numpy.float64[3, 1]], angular_velocity_of_this_frame: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialAcceleration_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_[float].Shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Shifts a SpatialAcceleration from a frame B to a frame C, where both B
and C are fixed to the same frame or rigid body.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">offset</span></code>:</dt>
<dd>which is the position vector p_BoCo_E from Bo (frame B’s origin)
to Co (frame C’s origin), expressed in frame E. p_BoCo_E must have
the same expressed-in frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial acceleration,
where <code class="docutils literal notranslate"><span class="pre">this</span></code> is A_MB_E (frame B’s spatial acceleration measured
in M, expressed in E).</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">angular_velocity_of_this_frame</span></code>:</dt>
<dd>which is ω_MB_E, frame B’s angular velocity measured in frame M
and expressed in frame E.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">A_MC_E</span></code>:</dt>
<dd>which is frame C’s spatial acceleration measured in frame M,
expressed in frame E.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Shift() differs from ShiftInPlace() in that Shift() does not
modify <code class="docutils literal notranslate"><span class="pre">this</span></code> whereas ShiftInPlace() does modify <code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">ShiftInPlace() for more information and how A_MC_E is calculated.
Use ComposeWithMovingFrameAcceleration() if frame C is moving on
frame B.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_[float].ShiftWithZeroAngularVelocity">
<code class="descname">ShiftWithZeroAngularVelocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialAcceleration_[float], offset: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialAcceleration_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_[float].ShiftWithZeroAngularVelocity" title="Permalink to this definition">¶</a></dt>
<dd><p>(Advanced) Given <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial acceleration A_MB of a frame B
measured in a frame M, shifts SpatialAcceleration from frame B to a
frame C (i.e., A_MB to A_MC), where both B and C are fixed to the same
frame or rigid body and where ω_MB = 0 (frame B’s angular velocity in
frame M is zero).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">offset</span></code>:</dt>
<dd>which is the position vector p_BoCo_E from Bo (frame B’s origin)
to Co (frame C’s origin), expressed in frame E. p_BoCo_E must have
the same expressed-in frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial acceleration,
where <code class="docutils literal notranslate"><span class="pre">this</span></code> is A_MB_E (frame B’s spatial acceleration measured
in M, expressed in E).</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">A_MC_E</span></code>:</dt>
<dd>which is frame C’s spatial acceleration measured in frame M,
expressed in frame E.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">ShiftInPlace() for more information and how A_MC_E is calculated.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">ShiftWithZeroAngularVelocity() speeds the Shift() computation when
ω_MB = 0, even if α_MB ≠ 0 (α_MB is stored in <code class="docutils literal notranslate"><span class="pre">this</span></code>).</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_[float].translational">
<code class="descname">translational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialAcceleration_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_[float].translational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the translational component of this spatial vector.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.math.SpatialAcceleration_[float].Zero">
<em class="property">static </em><code class="descname">Zero</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialAcceleration_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_[float].Zero" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory to create a <em>zero</em> spatial vector, i.e., a SpatialVector whose
rotational and translational components are both zero.</p>
</dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.math.SpatialForce">
<code class="descclassname">pydrake.multibody.math.</code><code class="descname">SpatialForce</code><a class="headerlink" href="#pydrake.multibody.math.SpatialForce" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pydrake.multibody.math.SpatialForce_[float]" title="pydrake.multibody.math.SpatialForce_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.math.SpatialForce_[float]</span></code></a></p>
</dd></dl>

<dl class="template">
<dt id="pydrake.multibody.math.SpatialForce_">
<em class="property">template </em><code class="descclassname">pydrake.multibody.math.</code><code class="descname">SpatialForce_</code><a class="headerlink" href="#pydrake.multibody.math.SpatialForce_" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.multibody.math.SpatialForce_[float]" title="pydrake.multibody.math.SpatialForce_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">SpatialForce_[float]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.math.SpatialForce_[AutoDiffXd]" title="pydrake.multibody.math.SpatialForce_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">SpatialForce_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.math.SpatialForce_[Expression]" title="pydrake.multibody.math.SpatialForce_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">SpatialForce_[Expression]</span></code></a></p>
<dl class="class">
<dt id="pydrake.multibody.math.SpatialForce_.SpatialForce_[float]">
<em class="property">class </em><code class="descname">SpatialForce_[float]</code><a class="headerlink" href="#pydrake.multibody.math.SpatialForce_.SpatialForce_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>This class represents a <em>spatial force</em> F (also called a <em>wrench</em>) and
has 6 elements with a torque 𝛕 (3-element vector) on top of a force 𝐟
(3-element vector). Frequently, a spatial force represents the
replacement of a set S of forces on a frame B with an equivalent set
consisting of a torque 𝛕 applied to frame B which is equal to the
moment of the set S about a point Bp of B together with a force 𝐟
applied to Bp, where 𝐟 is equal to set S’s resultant force. This class
assumes that both the torque 𝛕 and force 𝐟 have the same
<em>expressed-in</em> frame E. This class only stores 6 elements (namely 𝛕
and 𝐟) and does not store the underlying frame B, application point
Bp, or expressed-in frame E. The user is responsible for explicitly
tracking these underlying quantities with multibody_quantities
“monogram notation”. For example, F_B_E denotes a spatial force on
frame B with application point Bo (frame B’s origin), expressed in
frame E and contains tau_B_E (torque 𝛕 applied to frame B, expressed
in frame E) and f_Bo_E (force 𝐟 applied to Bo, expressed in frame E).</p>
<p>The monogram notation F_Bp has a typeset equivalent <span class="math notranslate nohighlight">\({F^{Bp}}\)</span>
which denotes the spatial force applied to point Bp of frame B. F_Bp
contains a torque tau_B (<span class="math notranslate nohighlight">\({\tau^B}\)</span>) applied to frame B and a
force f_Bp (<span class="math notranslate nohighlight">\({f^{Bp}}\)</span>) applied to point Bp of frame B. Details
on spatial vectors and monogram notation are in sections
multibody_spatial_vectors and multibody_quantities.</p>
<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_.SpatialForce_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.math.SpatialForce_.SpatialForce_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialForce_[float]) -&gt; None</p>
<blockquote>
<div><p>Constructs to all NaNs.</p>
<dl class="docutils">
<dt>Note:</dt>
<dd><p class="first last">This is different from C++, which in Release builds may leave memory
uninitialized. In pydrake, the function call overhead already trumps
any overhead from NAN-initialization, so we err on the side of
safety.</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialForce_[float], tau: numpy.ndarray[numpy.float64[3, 1]], f: numpy.ndarray[numpy.float64[3, 1]]) -&gt; None</p>
</li>
</ol>
<p>Constructs a spatial force F from a torque 𝛕 (tau) and a force 𝐟.</p>
<ol class="arabic simple" start="3">
<li>__init__(self: pydrake.multibody.math.SpatialForce_[float], F: numpy.ndarray[numpy.float64[6, 1]]) -&gt; None</li>
</ol>
<p>Constructs a spatial force F from an Eigen expression that represents
a 6-element vector, i.e., a 3-element torque 𝛕 and a 3-element force
𝐟. This constructor will assert the size of F is six (6) either at
compile-time for fixed sized Eigen expressions or at run-time for
dynamic sized Eigen expressions.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_.SpatialForce_[float].dot">
<code class="descname">dot</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialForce_[float], velocity: pydrake.multibody.math.SpatialVelocity_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.math.SpatialForce_.SpatialForce_[float].dot" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the power generated by a spatial force. For an arbitrary
frame B, calculates the dot-product of <code class="docutils literal notranslate"><span class="pre">this</span></code> = F_B_E (frame B’s
spatial force, expressed in frame E) with V_MB_E (frame B’s spatial
velocity measured in a frame M, expressed in a frame E).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">velocity</span></code>:</dt>
<dd>which is V_MB_E, frame B’s spatial velocity measured in frame M,
expressed in the same frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code> = F_B_E.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Power of spatial force F_B_E in frame M, i.e., F_B_E ⋅ V_MB_E.</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Just as equating force 𝐅 to mass * acceleration as 𝐅 = m𝐚 relies
on acceleration 𝐚 being measured in a world frame (also called an
inertial or Newtonian frame), equating power = dK/dt (where K is
kinetic energy) relies on K being measured in a world frame.
Hence, it is unusual to use this method unless frame M is the
world frame W.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Although the spatial vectors F_B_E and V_MB_E must have the same
expressed-in frame E, the returned scalar is independent of frame
E.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_.SpatialForce_[float].get_coeffs">
<code class="descname">get_coeffs</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialForce_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[6, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialForce_.SpatialForce_[float].get_coeffs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to the underlying storage.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_.SpatialForce_[float].Rotate">
<code class="descname">Rotate</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialForce_[float], R_FE: pydrake.math.RotationMatrix_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialForce_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialForce_.SpatialForce_[float].Rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides a Python-only implementation of rotating / re-expressing a
spatial vector.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is done because defining <code class="docutils literal notranslate"><span class="pre">__rmatmul__</span></code> on this class does
not disambiguate against the definitions of
<code class="docutils literal notranslate"><span class="pre">RotationMatrix.__matmul__</span></code>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_.SpatialForce_[float].rotational">
<code class="descname">rotational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialForce_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialForce_.SpatialForce_[float].rotational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the rotational component of this spatial vector.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_.SpatialForce_[float].SetZero">
<code class="descname">SetZero</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialForce_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialForce_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialForce_.SpatialForce_[float].SetZero" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets both the rotational and translational components of <code class="docutils literal notranslate"><span class="pre">this</span></code>
SpatialVector to zero.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_.SpatialForce_[float].Shift">
<code class="descname">Shift</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialForce_[float], offset: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialForce_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialForce_.SpatialForce_[float].Shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Shifts a SpatialForce from one point fixed on frame B to another point
fixed on frame B.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">offset</span></code>:</dt>
<dd>which is the position vector p_BpBq_E from point Bp (fixed on
frame B) to point Bq (fixed on frame B), expressed in frame E.
p_BpBq_E must have the same expressed-in frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code>
spatial force, where <code class="docutils literal notranslate"><span class="pre">this</span></code> is F_Bp_E (spatial force on Bp,
expressed in frame E).</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">F_Bq_E</span></code>:</dt>
<dd>which is the spatial force on Bq, expressed in frame E.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">Member function ShiftInPlace() to shift one spatial force
(modifying <code class="docutils literal notranslate"><span class="pre">this</span></code>) and static functions ShiftInPlace() and
Shift() to shift multiple spatial forces (with or without
modifying the input parameter spatial_forces).</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_.SpatialForce_[float].translational">
<code class="descname">translational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialForce_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialForce_.SpatialForce_[float].translational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the translational component of this spatial vector.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.math.SpatialForce_.SpatialForce_[float].Zero">
<em class="property">static </em><code class="descname">Zero</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialForce_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialForce_.SpatialForce_[float].Zero" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory to create a <em>zero</em> spatial vector, i.e., a SpatialVector whose
rotational and translational components are both zero.</p>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.math.SpatialForce_[AutoDiffXd]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.math.</code><code class="descname">SpatialForce_[AutoDiffXd]</code><a class="headerlink" href="#pydrake.multibody.math.SpatialForce_[AutoDiffXd]" title="Permalink to this definition">¶</a></dt>
<dd><p>This class represents a <em>spatial force</em> F (also called a <em>wrench</em>) and
has 6 elements with a torque 𝛕 (3-element vector) on top of a force 𝐟
(3-element vector). Frequently, a spatial force represents the
replacement of a set S of forces on a frame B with an equivalent set
consisting of a torque 𝛕 applied to frame B which is equal to the
moment of the set S about a point Bp of B together with a force 𝐟
applied to Bp, where 𝐟 is equal to set S’s resultant force. This class
assumes that both the torque 𝛕 and force 𝐟 have the same
<em>expressed-in</em> frame E. This class only stores 6 elements (namely 𝛕
and 𝐟) and does not store the underlying frame B, application point
Bp, or expressed-in frame E. The user is responsible for explicitly
tracking these underlying quantities with multibody_quantities
“monogram notation”. For example, F_B_E denotes a spatial force on
frame B with application point Bo (frame B’s origin), expressed in
frame E and contains tau_B_E (torque 𝛕 applied to frame B, expressed
in frame E) and f_Bo_E (force 𝐟 applied to Bo, expressed in frame E).</p>
<p>The monogram notation F_Bp has a typeset equivalent <span class="math notranslate nohighlight">\({F^{Bp}}\)</span>
which denotes the spatial force applied to point Bp of frame B. F_Bp
contains a torque tau_B (<span class="math notranslate nohighlight">\({\tau^B}\)</span>) applied to frame B and a
force f_Bp (<span class="math notranslate nohighlight">\({f^{Bp}}\)</span>) applied to point Bp of frame B. Details
on spatial vectors and monogram notation are in sections
multibody_spatial_vectors and multibody_quantities.</p>
<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_[AutoDiffXd].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.math.SpatialForce_[AutoDiffXd].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialForce_[AutoDiffXd]) -&gt; None</p>
<blockquote>
<div><p>Constructs to all NaNs.</p>
<dl class="docutils">
<dt>Note:</dt>
<dd><p class="first last">This is different from C++, which in Release builds may leave memory
uninitialized. In pydrake, the function call overhead already trumps
any overhead from NAN-initialization, so we err on the side of
safety.</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialForce_[AutoDiffXd], tau: numpy.ndarray[object[3, 1]], f: numpy.ndarray[object[3, 1]]) -&gt; None</p>
</li>
</ol>
<p>Constructs a spatial force F from a torque 𝛕 (tau) and a force 𝐟.</p>
<ol class="arabic simple" start="3">
<li>__init__(self: pydrake.multibody.math.SpatialForce_[AutoDiffXd], F: numpy.ndarray[object[6, 1]]) -&gt; None</li>
</ol>
<p>Constructs a spatial force F from an Eigen expression that represents
a 6-element vector, i.e., a 3-element torque 𝛕 and a 3-element force
𝐟. This constructor will assert the size of F is six (6) either at
compile-time for fixed sized Eigen expressions or at run-time for
dynamic sized Eigen expressions.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_[AutoDiffXd].dot">
<code class="descname">dot</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialForce_[AutoDiffXd], velocity: pydrake.multibody.math.SpatialVelocity_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.autodiffutils.AutoDiffXd<a class="headerlink" href="#pydrake.multibody.math.SpatialForce_[AutoDiffXd].dot" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the power generated by a spatial force. For an arbitrary
frame B, calculates the dot-product of <code class="docutils literal notranslate"><span class="pre">this</span></code> = F_B_E (frame B’s
spatial force, expressed in frame E) with V_MB_E (frame B’s spatial
velocity measured in a frame M, expressed in a frame E).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">velocity</span></code>:</dt>
<dd>which is V_MB_E, frame B’s spatial velocity measured in frame M,
expressed in the same frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code> = F_B_E.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Power of spatial force F_B_E in frame M, i.e., F_B_E ⋅ V_MB_E.</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Just as equating force 𝐅 to mass * acceleration as 𝐅 = m𝐚 relies
on acceleration 𝐚 being measured in a world frame (also called an
inertial or Newtonian frame), equating power = dK/dt (where K is
kinetic energy) relies on K being measured in a world frame.
Hence, it is unusual to use this method unless frame M is the
world frame W.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Although the spatial vectors F_B_E and V_MB_E must have the same
expressed-in frame E, the returned scalar is independent of frame
E.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_[AutoDiffXd].get_coeffs">
<code class="descname">get_coeffs</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialForce_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[6, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialForce_[AutoDiffXd].get_coeffs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to the underlying storage.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_[AutoDiffXd].Rotate">
<code class="descname">Rotate</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialForce_[AutoDiffXd], R_FE: pydrake.math.RotationMatrix_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialForce_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.math.SpatialForce_[AutoDiffXd].Rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides a Python-only implementation of rotating / re-expressing a
spatial vector.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is done because defining <code class="docutils literal notranslate"><span class="pre">__rmatmul__</span></code> on this class does
not disambiguate against the definitions of
<code class="docutils literal notranslate"><span class="pre">RotationMatrix.__matmul__</span></code>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_[AutoDiffXd].rotational">
<code class="descname">rotational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialForce_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialForce_[AutoDiffXd].rotational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the rotational component of this spatial vector.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_[AutoDiffXd].SetZero">
<code class="descname">SetZero</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialForce_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialForce_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.math.SpatialForce_[AutoDiffXd].SetZero" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets both the rotational and translational components of <code class="docutils literal notranslate"><span class="pre">this</span></code>
SpatialVector to zero.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_[AutoDiffXd].Shift">
<code class="descname">Shift</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialForce_[AutoDiffXd], offset: numpy.ndarray[object[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialForce_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.math.SpatialForce_[AutoDiffXd].Shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Shifts a SpatialForce from one point fixed on frame B to another point
fixed on frame B.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">offset</span></code>:</dt>
<dd>which is the position vector p_BpBq_E from point Bp (fixed on
frame B) to point Bq (fixed on frame B), expressed in frame E.
p_BpBq_E must have the same expressed-in frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code>
spatial force, where <code class="docutils literal notranslate"><span class="pre">this</span></code> is F_Bp_E (spatial force on Bp,
expressed in frame E).</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">F_Bq_E</span></code>:</dt>
<dd>which is the spatial force on Bq, expressed in frame E.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">Member function ShiftInPlace() to shift one spatial force
(modifying <code class="docutils literal notranslate"><span class="pre">this</span></code>) and static functions ShiftInPlace() and
Shift() to shift multiple spatial forces (with or without
modifying the input parameter spatial_forces).</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_[AutoDiffXd].translational">
<code class="descname">translational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialForce_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialForce_[AutoDiffXd].translational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the translational component of this spatial vector.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.math.SpatialForce_[AutoDiffXd].Zero">
<em class="property">static </em><code class="descname">Zero</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialForce_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.math.SpatialForce_[AutoDiffXd].Zero" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory to create a <em>zero</em> spatial vector, i.e., a SpatialVector whose
rotational and translational components are both zero.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.math.SpatialForce_[Expression]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.math.</code><code class="descname">SpatialForce_[Expression]</code><a class="headerlink" href="#pydrake.multibody.math.SpatialForce_[Expression]" title="Permalink to this definition">¶</a></dt>
<dd><p>This class represents a <em>spatial force</em> F (also called a <em>wrench</em>) and
has 6 elements with a torque 𝛕 (3-element vector) on top of a force 𝐟
(3-element vector). Frequently, a spatial force represents the
replacement of a set S of forces on a frame B with an equivalent set
consisting of a torque 𝛕 applied to frame B which is equal to the
moment of the set S about a point Bp of B together with a force 𝐟
applied to Bp, where 𝐟 is equal to set S’s resultant force. This class
assumes that both the torque 𝛕 and force 𝐟 have the same
<em>expressed-in</em> frame E. This class only stores 6 elements (namely 𝛕
and 𝐟) and does not store the underlying frame B, application point
Bp, or expressed-in frame E. The user is responsible for explicitly
tracking these underlying quantities with multibody_quantities
“monogram notation”. For example, F_B_E denotes a spatial force on
frame B with application point Bo (frame B’s origin), expressed in
frame E and contains tau_B_E (torque 𝛕 applied to frame B, expressed
in frame E) and f_Bo_E (force 𝐟 applied to Bo, expressed in frame E).</p>
<p>The monogram notation F_Bp has a typeset equivalent <span class="math notranslate nohighlight">\({F^{Bp}}\)</span>
which denotes the spatial force applied to point Bp of frame B. F_Bp
contains a torque tau_B (<span class="math notranslate nohighlight">\({\tau^B}\)</span>) applied to frame B and a
force f_Bp (<span class="math notranslate nohighlight">\({f^{Bp}}\)</span>) applied to point Bp of frame B. Details
on spatial vectors and monogram notation are in sections
multibody_spatial_vectors and multibody_quantities.</p>
<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_[Expression].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.math.SpatialForce_[Expression].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialForce_[Expression]) -&gt; None</p>
<blockquote>
<div><p>Constructs to all NaNs.</p>
<dl class="docutils">
<dt>Note:</dt>
<dd><p class="first last">This is different from C++, which in Release builds may leave memory
uninitialized. In pydrake, the function call overhead already trumps
any overhead from NAN-initialization, so we err on the side of
safety.</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialForce_[Expression], tau: numpy.ndarray[object[3, 1]], f: numpy.ndarray[object[3, 1]]) -&gt; None</p>
</li>
</ol>
<p>Constructs a spatial force F from a torque 𝛕 (tau) and a force 𝐟.</p>
<ol class="arabic simple" start="3">
<li>__init__(self: pydrake.multibody.math.SpatialForce_[Expression], F: numpy.ndarray[object[6, 1]]) -&gt; None</li>
</ol>
<p>Constructs a spatial force F from an Eigen expression that represents
a 6-element vector, i.e., a 3-element torque 𝛕 and a 3-element force
𝐟. This constructor will assert the size of F is six (6) either at
compile-time for fixed sized Eigen expressions or at run-time for
dynamic sized Eigen expressions.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_[Expression].dot">
<code class="descname">dot</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialForce_[Expression], velocity: pydrake.multibody.math.SpatialVelocity_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Expression<a class="headerlink" href="#pydrake.multibody.math.SpatialForce_[Expression].dot" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the power generated by a spatial force. For an arbitrary
frame B, calculates the dot-product of <code class="docutils literal notranslate"><span class="pre">this</span></code> = F_B_E (frame B’s
spatial force, expressed in frame E) with V_MB_E (frame B’s spatial
velocity measured in a frame M, expressed in a frame E).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">velocity</span></code>:</dt>
<dd>which is V_MB_E, frame B’s spatial velocity measured in frame M,
expressed in the same frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code> = F_B_E.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Power of spatial force F_B_E in frame M, i.e., F_B_E ⋅ V_MB_E.</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Just as equating force 𝐅 to mass * acceleration as 𝐅 = m𝐚 relies
on acceleration 𝐚 being measured in a world frame (also called an
inertial or Newtonian frame), equating power = dK/dt (where K is
kinetic energy) relies on K being measured in a world frame.
Hence, it is unusual to use this method unless frame M is the
world frame W.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Although the spatial vectors F_B_E and V_MB_E must have the same
expressed-in frame E, the returned scalar is independent of frame
E.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_[Expression].get_coeffs">
<code class="descname">get_coeffs</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialForce_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[6, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialForce_[Expression].get_coeffs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to the underlying storage.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_[Expression].Rotate">
<code class="descname">Rotate</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialForce_[Expression], R_FE: pydrake.math.RotationMatrix_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialForce_[Expression]<a class="headerlink" href="#pydrake.multibody.math.SpatialForce_[Expression].Rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides a Python-only implementation of rotating / re-expressing a
spatial vector.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is done because defining <code class="docutils literal notranslate"><span class="pre">__rmatmul__</span></code> on this class does
not disambiguate against the definitions of
<code class="docutils literal notranslate"><span class="pre">RotationMatrix.__matmul__</span></code>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_[Expression].rotational">
<code class="descname">rotational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialForce_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialForce_[Expression].rotational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the rotational component of this spatial vector.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_[Expression].SetZero">
<code class="descname">SetZero</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialForce_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialForce_[Expression]<a class="headerlink" href="#pydrake.multibody.math.SpatialForce_[Expression].SetZero" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets both the rotational and translational components of <code class="docutils literal notranslate"><span class="pre">this</span></code>
SpatialVector to zero.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_[Expression].Shift">
<code class="descname">Shift</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialForce_[Expression], offset: numpy.ndarray[object[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialForce_[Expression]<a class="headerlink" href="#pydrake.multibody.math.SpatialForce_[Expression].Shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Shifts a SpatialForce from one point fixed on frame B to another point
fixed on frame B.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">offset</span></code>:</dt>
<dd>which is the position vector p_BpBq_E from point Bp (fixed on
frame B) to point Bq (fixed on frame B), expressed in frame E.
p_BpBq_E must have the same expressed-in frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code>
spatial force, where <code class="docutils literal notranslate"><span class="pre">this</span></code> is F_Bp_E (spatial force on Bp,
expressed in frame E).</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">F_Bq_E</span></code>:</dt>
<dd>which is the spatial force on Bq, expressed in frame E.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">Member function ShiftInPlace() to shift one spatial force
(modifying <code class="docutils literal notranslate"><span class="pre">this</span></code>) and static functions ShiftInPlace() and
Shift() to shift multiple spatial forces (with or without
modifying the input parameter spatial_forces).</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_[Expression].translational">
<code class="descname">translational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialForce_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialForce_[Expression].translational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the translational component of this spatial vector.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.math.SpatialForce_[Expression].Zero">
<em class="property">static </em><code class="descname">Zero</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialForce_[Expression]<a class="headerlink" href="#pydrake.multibody.math.SpatialForce_[Expression].Zero" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory to create a <em>zero</em> spatial vector, i.e., a SpatialVector whose
rotational and translational components are both zero.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.math.SpatialForce_[float]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.math.</code><code class="descname">SpatialForce_[float]</code><a class="headerlink" href="#pydrake.multibody.math.SpatialForce_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>This class represents a <em>spatial force</em> F (also called a <em>wrench</em>) and
has 6 elements with a torque 𝛕 (3-element vector) on top of a force 𝐟
(3-element vector). Frequently, a spatial force represents the
replacement of a set S of forces on a frame B with an equivalent set
consisting of a torque 𝛕 applied to frame B which is equal to the
moment of the set S about a point Bp of B together with a force 𝐟
applied to Bp, where 𝐟 is equal to set S’s resultant force. This class
assumes that both the torque 𝛕 and force 𝐟 have the same
<em>expressed-in</em> frame E. This class only stores 6 elements (namely 𝛕
and 𝐟) and does not store the underlying frame B, application point
Bp, or expressed-in frame E. The user is responsible for explicitly
tracking these underlying quantities with multibody_quantities
“monogram notation”. For example, F_B_E denotes a spatial force on
frame B with application point Bo (frame B’s origin), expressed in
frame E and contains tau_B_E (torque 𝛕 applied to frame B, expressed
in frame E) and f_Bo_E (force 𝐟 applied to Bo, expressed in frame E).</p>
<p>The monogram notation F_Bp has a typeset equivalent <span class="math notranslate nohighlight">\({F^{Bp}}\)</span>
which denotes the spatial force applied to point Bp of frame B. F_Bp
contains a torque tau_B (<span class="math notranslate nohighlight">\({\tau^B}\)</span>) applied to frame B and a
force f_Bp (<span class="math notranslate nohighlight">\({f^{Bp}}\)</span>) applied to point Bp of frame B. Details
on spatial vectors and monogram notation are in sections
multibody_spatial_vectors and multibody_quantities.</p>
<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.math.SpatialForce_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialForce_[float]) -&gt; None</p>
<blockquote>
<div><p>Constructs to all NaNs.</p>
<dl class="docutils">
<dt>Note:</dt>
<dd><p class="first last">This is different from C++, which in Release builds may leave memory
uninitialized. In pydrake, the function call overhead already trumps
any overhead from NAN-initialization, so we err on the side of
safety.</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialForce_[float], tau: numpy.ndarray[numpy.float64[3, 1]], f: numpy.ndarray[numpy.float64[3, 1]]) -&gt; None</p>
</li>
</ol>
<p>Constructs a spatial force F from a torque 𝛕 (tau) and a force 𝐟.</p>
<ol class="arabic simple" start="3">
<li>__init__(self: pydrake.multibody.math.SpatialForce_[float], F: numpy.ndarray[numpy.float64[6, 1]]) -&gt; None</li>
</ol>
<p>Constructs a spatial force F from an Eigen expression that represents
a 6-element vector, i.e., a 3-element torque 𝛕 and a 3-element force
𝐟. This constructor will assert the size of F is six (6) either at
compile-time for fixed sized Eigen expressions or at run-time for
dynamic sized Eigen expressions.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_[float].dot">
<code class="descname">dot</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialForce_[float], velocity: pydrake.multibody.math.SpatialVelocity_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.math.SpatialForce_[float].dot" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the power generated by a spatial force. For an arbitrary
frame B, calculates the dot-product of <code class="docutils literal notranslate"><span class="pre">this</span></code> = F_B_E (frame B’s
spatial force, expressed in frame E) with V_MB_E (frame B’s spatial
velocity measured in a frame M, expressed in a frame E).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">velocity</span></code>:</dt>
<dd>which is V_MB_E, frame B’s spatial velocity measured in frame M,
expressed in the same frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code> = F_B_E.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Power of spatial force F_B_E in frame M, i.e., F_B_E ⋅ V_MB_E.</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Just as equating force 𝐅 to mass * acceleration as 𝐅 = m𝐚 relies
on acceleration 𝐚 being measured in a world frame (also called an
inertial or Newtonian frame), equating power = dK/dt (where K is
kinetic energy) relies on K being measured in a world frame.
Hence, it is unusual to use this method unless frame M is the
world frame W.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Although the spatial vectors F_B_E and V_MB_E must have the same
expressed-in frame E, the returned scalar is independent of frame
E.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_[float].get_coeffs">
<code class="descname">get_coeffs</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialForce_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[6, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialForce_[float].get_coeffs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to the underlying storage.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_[float].Rotate">
<code class="descname">Rotate</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialForce_[float], R_FE: pydrake.math.RotationMatrix_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialForce_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialForce_[float].Rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides a Python-only implementation of rotating / re-expressing a
spatial vector.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is done because defining <code class="docutils literal notranslate"><span class="pre">__rmatmul__</span></code> on this class does
not disambiguate against the definitions of
<code class="docutils literal notranslate"><span class="pre">RotationMatrix.__matmul__</span></code>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_[float].rotational">
<code class="descname">rotational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialForce_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialForce_[float].rotational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the rotational component of this spatial vector.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_[float].SetZero">
<code class="descname">SetZero</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialForce_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialForce_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialForce_[float].SetZero" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets both the rotational and translational components of <code class="docutils literal notranslate"><span class="pre">this</span></code>
SpatialVector to zero.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_[float].Shift">
<code class="descname">Shift</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialForce_[float], offset: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialForce_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialForce_[float].Shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Shifts a SpatialForce from one point fixed on frame B to another point
fixed on frame B.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">offset</span></code>:</dt>
<dd>which is the position vector p_BpBq_E from point Bp (fixed on
frame B) to point Bq (fixed on frame B), expressed in frame E.
p_BpBq_E must have the same expressed-in frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code>
spatial force, where <code class="docutils literal notranslate"><span class="pre">this</span></code> is F_Bp_E (spatial force on Bp,
expressed in frame E).</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">F_Bq_E</span></code>:</dt>
<dd>which is the spatial force on Bq, expressed in frame E.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">Member function ShiftInPlace() to shift one spatial force
(modifying <code class="docutils literal notranslate"><span class="pre">this</span></code>) and static functions ShiftInPlace() and
Shift() to shift multiple spatial forces (with or without
modifying the input parameter spatial_forces).</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_[float].translational">
<code class="descname">translational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialForce_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialForce_[float].translational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the translational component of this spatial vector.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.math.SpatialForce_[float].Zero">
<em class="property">static </em><code class="descname">Zero</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialForce_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialForce_[float].Zero" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory to create a <em>zero</em> spatial vector, i.e., a SpatialVector whose
rotational and translational components are both zero.</p>
</dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.math.SpatialMomentum">
<code class="descclassname">pydrake.multibody.math.</code><code class="descname">SpatialMomentum</code><a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pydrake.multibody.math.SpatialMomentum_[float]" title="pydrake.multibody.math.SpatialMomentum_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.math.SpatialMomentum_[float]</span></code></a></p>
</dd></dl>

<dl class="template">
<dt id="pydrake.multibody.math.SpatialMomentum_">
<em class="property">template </em><code class="descclassname">pydrake.multibody.math.</code><code class="descname">SpatialMomentum_</code><a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.multibody.math.SpatialMomentum_[float]" title="pydrake.multibody.math.SpatialMomentum_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">SpatialMomentum_[float]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.math.SpatialMomentum_[AutoDiffXd]" title="pydrake.multibody.math.SpatialMomentum_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">SpatialMomentum_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.math.SpatialMomentum_[Expression]" title="pydrake.multibody.math.SpatialMomentum_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">SpatialMomentum_[Expression]</span></code></a></p>
<dl class="class">
<dt id="pydrake.multibody.math.SpatialMomentum_.SpatialMomentum_[float]">
<em class="property">class </em><code class="descname">SpatialMomentum_[float]</code><a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_.SpatialMomentum_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>This class represents a <em>spatial momentum</em> L and has 6 elements with
an angular (rotational) momentum 𝐡 (3-element vector) on top of a
translational (linear) momentum 𝐥 (3-element vector). A spatial
momentum L stores the angular momentum 𝐡 and translational momentum 𝐥
of a system S about a point P, measured in a frame M, and expressed in
a frame E. The system S may be a particle, a rigid or deformable body,
or a set of particles and/or bodies. This class assumes that both the
angular momentum 𝐡 and translational momentum 𝐥 are expressed in the
same <em>expressed-in</em> frame E. This class only stores 6 elements (namely
𝐡 and 𝐥) and does not store the underlying system S, about-point P,
measured-in frame M, or expressed-in frame E. The user is responsible
for explicitly tracking the underlying system, about-point, and frames
with multibody_quantities “monogram notation”. For example, L_MSP_E
denotes a system S’s spatial momentum about point P, measured in frame
M, and expressed in frame E. L_MSP_E contains h_MSP_E (S’s angular
momentum about point P, measured in M, expressed in E) and l_MS_E (S’s
translational momentum measured in M, expressed in E). A body B’s
spatial momentum about point Bo (B’s origin), measured in frame M,
expressed in frame E has explicit monogram notation L_MBBo_E which can
be abbreviated L_MBo_E. Similarly L_MSScm_E is abbreviated L_MScm_E
(Scm is S’s center of mass). Details on spatial vectors and monogram
notation are in sections multibody_spatial_vectors and
multibody_quantities.</p>
<p>The typeset for L_MSP_E is <span class="math notranslate nohighlight">\([^ML^{S/P}]_E\)</span>. For a set S of
particles Qᵢ, L_MSP contains S’s angular momentum 𝐡 about-point P,
measured in frame M and S’s translational momentum 𝐥 measured in frame
M, defined as</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>h_MSP = ∑ h_MQᵢP = ∑ p_PQᵢ x l_MQᵢ  where l_MQᵢ = mᵢ v_MQᵢ.
  l_MS  = ∑ l_MQᵢ  = ∑ mᵢ v_MQᵢ
</pre></div>
</div>
<p>where mᵢ is the mass of particle Qᵢ, v_MQᵢ is Qᵢ’s translational
velocity measured in frame M, l_MQᵢ = mᵢ v_MQQᵢ is Qᵢ’s translational
momentum measured in frame M, h_MQᵢP is Qᵢ’s angular momentum about
point P measured in frame M, and p_PQᵢ is the position vector from
point P to Qᵢ. These definitions extend to a body (continuum of
particles) by using the density ρ(r) of the body at each material
location r as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>h_MSP = ∫p_PQ(r) x v_MQ(r) ρ(r) d³r
  l_MS  = ∫v_MQ(r) ρ(r) d³r
</pre></div>
</div>
<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_.SpatialMomentum_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_.SpatialMomentum_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialMomentum_[float]) -&gt; None</p>
<blockquote>
<div><p>Constructs to all NaNs.</p>
<dl class="docutils">
<dt>Note:</dt>
<dd><p class="first last">This is different from C++, which in Release builds may leave memory
uninitialized. In pydrake, the function call overhead already trumps
any overhead from NAN-initialization, so we err on the side of
safety.</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialMomentum_[float], h: numpy.ndarray[numpy.float64[3, 1]], l: numpy.ndarray[numpy.float64[3, 1]]) -&gt; None</p>
</li>
</ol>
<p>Constructs a spatial momentum L from an angular momentum 𝐡 and a
translational momentum 𝐥.</p>
<ol class="arabic simple" start="3">
<li>__init__(self: pydrake.multibody.math.SpatialMomentum_[float], L: numpy.ndarray[numpy.float64[6, 1]]) -&gt; None</li>
</ol>
<p>Constructs a spatial momentum L from an Eigen expression that
represents a 6-element vector, i.e., a 3-element angular momentum 𝐡
and a 3-element translational momentum 𝐥. This constructor will assert
the size of L is six (6) either at compile-time for fixed sized Eigen
expressions or at run-time for dynamic sized Eigen expressions.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_.SpatialMomentum_[float].dot">
<code class="descname">dot</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialMomentum_[float], velocity: pydrake.multibody.math.SpatialVelocity_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_.SpatialMomentum_[float].dot" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates twice (2x) a body B’s kinetic energy measured in a frame M.
For any frame (e.g., an multibody_frames_and_bodies “offset frame”) Bp
that is fixed to a rigid body B, calculates the dot-product of
<code class="docutils literal notranslate"><span class="pre">this</span></code> = L_MBp_E (body B’s spatial momentum measured in frame M,
about Bp’s origin, expressed in frame E) with V_MBp_E (frame Bp’s
spatial velocity measured in frame M, expressed in frame E).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">velocity</span></code>:</dt>
<dd>which is V_MBp_E, frame Bp’s spatial velocity measured in frame M,
and expressed in the same frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code> = L_MBp_E.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">2*K_MB, twice (2x) body B’s kinetic energy measured in frame M.</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In general, kinetic energy calculations are only useful when frame
M is a world frame (also called a Newtonian or inertial frame).
Hence, it is unusual to use this method unless frame M is the
world frame W.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Although the spatial vectors V_MBp_E and L_MBp_E must have the
same expressed-in frame E, the resulting scalar K_MB is
independent of frame E.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">As shown below, K_MB can be calculated from any frame Bp fixed on
B, including body B’s center of mass frame Bcm. This is due to how
spatial momentum and spatial velocity shift from Bcm to Bp. For
more information, see SpatialMomentum::Shift() and
SpatialVelocity::Shift().</p>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>K_MB = 1/2 (L_MBp · V_MBp) = 1/2 (L_MBcm · V_MBcm)
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_.SpatialMomentum_[float].get_coeffs">
<code class="descname">get_coeffs</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialMomentum_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[6, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_.SpatialMomentum_[float].get_coeffs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to the underlying storage.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_.SpatialMomentum_[float].Rotate">
<code class="descname">Rotate</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialMomentum_[float], R_FE: pydrake.math.RotationMatrix_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialMomentum_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_.SpatialMomentum_[float].Rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides a Python-only implementation of rotating / re-expressing a
spatial vector.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is done because defining <code class="docutils literal notranslate"><span class="pre">__rmatmul__</span></code> on this class does
not disambiguate against the definitions of
<code class="docutils literal notranslate"><span class="pre">RotationMatrix.__matmul__</span></code>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_.SpatialMomentum_[float].rotational">
<code class="descname">rotational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialMomentum_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_.SpatialMomentum_[float].rotational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the rotational component of this spatial vector.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_.SpatialMomentum_[float].SetZero">
<code class="descname">SetZero</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialMomentum_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialMomentum_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_.SpatialMomentum_[float].SetZero" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets both the rotational and translational components of <code class="docutils literal notranslate"><span class="pre">this</span></code>
SpatialVector to zero.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_.SpatialMomentum_[float].Shift">
<code class="descname">Shift</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialMomentum_[float], offset: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialMomentum_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_.SpatialMomentum_[float].Shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Shifts a SpatialMomentum from an about-point P to an about-point Q.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">offset</span></code>:</dt>
<dd>which is the position vector p_PQ_E from point P to point Q,
expressed in frame E. p_PQ_E must have the same expressed-in frame
E as <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial momentum, where <code class="docutils literal notranslate"><span class="pre">this</span></code> is L_MSP_E (system
S’s spatial momentum about P, measured in frame M, expressed in
frame E).</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">L_MSQ_E</span></code>:</dt>
<dd>which is system S’s spatial momentum about point Q, measured in
frame M, expressed in frame E.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Shift() differs from ShiftInPlace() in that Shift() does not
modify <code class="docutils literal notranslate"><span class="pre">this</span></code> whereas ShiftInPlace() does modify <code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">ShiftInPlace() for more information and how L_MSQ_E is calculated.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_.SpatialMomentum_[float].translational">
<code class="descname">translational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialMomentum_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_.SpatialMomentum_[float].translational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the translational component of this spatial vector.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.math.SpatialMomentum_.SpatialMomentum_[float].Zero">
<em class="property">static </em><code class="descname">Zero</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialMomentum_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_.SpatialMomentum_[float].Zero" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory to create a <em>zero</em> spatial vector, i.e., a SpatialVector whose
rotational and translational components are both zero.</p>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.math.SpatialMomentum_[AutoDiffXd]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.math.</code><code class="descname">SpatialMomentum_[AutoDiffXd]</code><a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_[AutoDiffXd]" title="Permalink to this definition">¶</a></dt>
<dd><p>This class represents a <em>spatial momentum</em> L and has 6 elements with
an angular (rotational) momentum 𝐡 (3-element vector) on top of a
translational (linear) momentum 𝐥 (3-element vector). A spatial
momentum L stores the angular momentum 𝐡 and translational momentum 𝐥
of a system S about a point P, measured in a frame M, and expressed in
a frame E. The system S may be a particle, a rigid or deformable body,
or a set of particles and/or bodies. This class assumes that both the
angular momentum 𝐡 and translational momentum 𝐥 are expressed in the
same <em>expressed-in</em> frame E. This class only stores 6 elements (namely
𝐡 and 𝐥) and does not store the underlying system S, about-point P,
measured-in frame M, or expressed-in frame E. The user is responsible
for explicitly tracking the underlying system, about-point, and frames
with multibody_quantities “monogram notation”. For example, L_MSP_E
denotes a system S’s spatial momentum about point P, measured in frame
M, and expressed in frame E. L_MSP_E contains h_MSP_E (S’s angular
momentum about point P, measured in M, expressed in E) and l_MS_E (S’s
translational momentum measured in M, expressed in E). A body B’s
spatial momentum about point Bo (B’s origin), measured in frame M,
expressed in frame E has explicit monogram notation L_MBBo_E which can
be abbreviated L_MBo_E. Similarly L_MSScm_E is abbreviated L_MScm_E
(Scm is S’s center of mass). Details on spatial vectors and monogram
notation are in sections multibody_spatial_vectors and
multibody_quantities.</p>
<p>The typeset for L_MSP_E is <span class="math notranslate nohighlight">\([^ML^{S/P}]_E\)</span>. For a set S of
particles Qᵢ, L_MSP contains S’s angular momentum 𝐡 about-point P,
measured in frame M and S’s translational momentum 𝐥 measured in frame
M, defined as</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>h_MSP = ∑ h_MQᵢP = ∑ p_PQᵢ x l_MQᵢ  where l_MQᵢ = mᵢ v_MQᵢ.
  l_MS  = ∑ l_MQᵢ  = ∑ mᵢ v_MQᵢ
</pre></div>
</div>
<p>where mᵢ is the mass of particle Qᵢ, v_MQᵢ is Qᵢ’s translational
velocity measured in frame M, l_MQᵢ = mᵢ v_MQQᵢ is Qᵢ’s translational
momentum measured in frame M, h_MQᵢP is Qᵢ’s angular momentum about
point P measured in frame M, and p_PQᵢ is the position vector from
point P to Qᵢ. These definitions extend to a body (continuum of
particles) by using the density ρ(r) of the body at each material
location r as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>h_MSP = ∫p_PQ(r) x v_MQ(r) ρ(r) d³r
  l_MS  = ∫v_MQ(r) ρ(r) d³r
</pre></div>
</div>
<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_[AutoDiffXd].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_[AutoDiffXd].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialMomentum_[AutoDiffXd]) -&gt; None</p>
<blockquote>
<div><p>Constructs to all NaNs.</p>
<dl class="docutils">
<dt>Note:</dt>
<dd><p class="first last">This is different from C++, which in Release builds may leave memory
uninitialized. In pydrake, the function call overhead already trumps
any overhead from NAN-initialization, so we err on the side of
safety.</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialMomentum_[AutoDiffXd], h: numpy.ndarray[object[3, 1]], l: numpy.ndarray[object[3, 1]]) -&gt; None</p>
</li>
</ol>
<p>Constructs a spatial momentum L from an angular momentum 𝐡 and a
translational momentum 𝐥.</p>
<ol class="arabic simple" start="3">
<li>__init__(self: pydrake.multibody.math.SpatialMomentum_[AutoDiffXd], L: numpy.ndarray[object[6, 1]]) -&gt; None</li>
</ol>
<p>Constructs a spatial momentum L from an Eigen expression that
represents a 6-element vector, i.e., a 3-element angular momentum 𝐡
and a 3-element translational momentum 𝐥. This constructor will assert
the size of L is six (6) either at compile-time for fixed sized Eigen
expressions or at run-time for dynamic sized Eigen expressions.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_[AutoDiffXd].dot">
<code class="descname">dot</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialMomentum_[AutoDiffXd], velocity: pydrake.multibody.math.SpatialVelocity_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.autodiffutils.AutoDiffXd<a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_[AutoDiffXd].dot" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates twice (2x) a body B’s kinetic energy measured in a frame M.
For any frame (e.g., an multibody_frames_and_bodies “offset frame”) Bp
that is fixed to a rigid body B, calculates the dot-product of
<code class="docutils literal notranslate"><span class="pre">this</span></code> = L_MBp_E (body B’s spatial momentum measured in frame M,
about Bp’s origin, expressed in frame E) with V_MBp_E (frame Bp’s
spatial velocity measured in frame M, expressed in frame E).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">velocity</span></code>:</dt>
<dd>which is V_MBp_E, frame Bp’s spatial velocity measured in frame M,
and expressed in the same frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code> = L_MBp_E.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">2*K_MB, twice (2x) body B’s kinetic energy measured in frame M.</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In general, kinetic energy calculations are only useful when frame
M is a world frame (also called a Newtonian or inertial frame).
Hence, it is unusual to use this method unless frame M is the
world frame W.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Although the spatial vectors V_MBp_E and L_MBp_E must have the
same expressed-in frame E, the resulting scalar K_MB is
independent of frame E.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">As shown below, K_MB can be calculated from any frame Bp fixed on
B, including body B’s center of mass frame Bcm. This is due to how
spatial momentum and spatial velocity shift from Bcm to Bp. For
more information, see SpatialMomentum::Shift() and
SpatialVelocity::Shift().</p>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>K_MB = 1/2 (L_MBp · V_MBp) = 1/2 (L_MBcm · V_MBcm)
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_[AutoDiffXd].get_coeffs">
<code class="descname">get_coeffs</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialMomentum_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[6, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_[AutoDiffXd].get_coeffs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to the underlying storage.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_[AutoDiffXd].Rotate">
<code class="descname">Rotate</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialMomentum_[AutoDiffXd], R_FE: pydrake.math.RotationMatrix_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialMomentum_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_[AutoDiffXd].Rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides a Python-only implementation of rotating / re-expressing a
spatial vector.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is done because defining <code class="docutils literal notranslate"><span class="pre">__rmatmul__</span></code> on this class does
not disambiguate against the definitions of
<code class="docutils literal notranslate"><span class="pre">RotationMatrix.__matmul__</span></code>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_[AutoDiffXd].rotational">
<code class="descname">rotational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialMomentum_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_[AutoDiffXd].rotational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the rotational component of this spatial vector.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_[AutoDiffXd].SetZero">
<code class="descname">SetZero</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialMomentum_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialMomentum_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_[AutoDiffXd].SetZero" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets both the rotational and translational components of <code class="docutils literal notranslate"><span class="pre">this</span></code>
SpatialVector to zero.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_[AutoDiffXd].Shift">
<code class="descname">Shift</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialMomentum_[AutoDiffXd], offset: numpy.ndarray[object[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialMomentum_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_[AutoDiffXd].Shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Shifts a SpatialMomentum from an about-point P to an about-point Q.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">offset</span></code>:</dt>
<dd>which is the position vector p_PQ_E from point P to point Q,
expressed in frame E. p_PQ_E must have the same expressed-in frame
E as <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial momentum, where <code class="docutils literal notranslate"><span class="pre">this</span></code> is L_MSP_E (system
S’s spatial momentum about P, measured in frame M, expressed in
frame E).</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">L_MSQ_E</span></code>:</dt>
<dd>which is system S’s spatial momentum about point Q, measured in
frame M, expressed in frame E.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Shift() differs from ShiftInPlace() in that Shift() does not
modify <code class="docutils literal notranslate"><span class="pre">this</span></code> whereas ShiftInPlace() does modify <code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">ShiftInPlace() for more information and how L_MSQ_E is calculated.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_[AutoDiffXd].translational">
<code class="descname">translational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialMomentum_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_[AutoDiffXd].translational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the translational component of this spatial vector.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.math.SpatialMomentum_[AutoDiffXd].Zero">
<em class="property">static </em><code class="descname">Zero</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialMomentum_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_[AutoDiffXd].Zero" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory to create a <em>zero</em> spatial vector, i.e., a SpatialVector whose
rotational and translational components are both zero.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.math.SpatialMomentum_[Expression]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.math.</code><code class="descname">SpatialMomentum_[Expression]</code><a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_[Expression]" title="Permalink to this definition">¶</a></dt>
<dd><p>This class represents a <em>spatial momentum</em> L and has 6 elements with
an angular (rotational) momentum 𝐡 (3-element vector) on top of a
translational (linear) momentum 𝐥 (3-element vector). A spatial
momentum L stores the angular momentum 𝐡 and translational momentum 𝐥
of a system S about a point P, measured in a frame M, and expressed in
a frame E. The system S may be a particle, a rigid or deformable body,
or a set of particles and/or bodies. This class assumes that both the
angular momentum 𝐡 and translational momentum 𝐥 are expressed in the
same <em>expressed-in</em> frame E. This class only stores 6 elements (namely
𝐡 and 𝐥) and does not store the underlying system S, about-point P,
measured-in frame M, or expressed-in frame E. The user is responsible
for explicitly tracking the underlying system, about-point, and frames
with multibody_quantities “monogram notation”. For example, L_MSP_E
denotes a system S’s spatial momentum about point P, measured in frame
M, and expressed in frame E. L_MSP_E contains h_MSP_E (S’s angular
momentum about point P, measured in M, expressed in E) and l_MS_E (S’s
translational momentum measured in M, expressed in E). A body B’s
spatial momentum about point Bo (B’s origin), measured in frame M,
expressed in frame E has explicit monogram notation L_MBBo_E which can
be abbreviated L_MBo_E. Similarly L_MSScm_E is abbreviated L_MScm_E
(Scm is S’s center of mass). Details on spatial vectors and monogram
notation are in sections multibody_spatial_vectors and
multibody_quantities.</p>
<p>The typeset for L_MSP_E is <span class="math notranslate nohighlight">\([^ML^{S/P}]_E\)</span>. For a set S of
particles Qᵢ, L_MSP contains S’s angular momentum 𝐡 about-point P,
measured in frame M and S’s translational momentum 𝐥 measured in frame
M, defined as</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>h_MSP = ∑ h_MQᵢP = ∑ p_PQᵢ x l_MQᵢ  where l_MQᵢ = mᵢ v_MQᵢ.
  l_MS  = ∑ l_MQᵢ  = ∑ mᵢ v_MQᵢ
</pre></div>
</div>
<p>where mᵢ is the mass of particle Qᵢ, v_MQᵢ is Qᵢ’s translational
velocity measured in frame M, l_MQᵢ = mᵢ v_MQQᵢ is Qᵢ’s translational
momentum measured in frame M, h_MQᵢP is Qᵢ’s angular momentum about
point P measured in frame M, and p_PQᵢ is the position vector from
point P to Qᵢ. These definitions extend to a body (continuum of
particles) by using the density ρ(r) of the body at each material
location r as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>h_MSP = ∫p_PQ(r) x v_MQ(r) ρ(r) d³r
  l_MS  = ∫v_MQ(r) ρ(r) d³r
</pre></div>
</div>
<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_[Expression].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_[Expression].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialMomentum_[Expression]) -&gt; None</p>
<blockquote>
<div><p>Constructs to all NaNs.</p>
<dl class="docutils">
<dt>Note:</dt>
<dd><p class="first last">This is different from C++, which in Release builds may leave memory
uninitialized. In pydrake, the function call overhead already trumps
any overhead from NAN-initialization, so we err on the side of
safety.</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialMomentum_[Expression], h: numpy.ndarray[object[3, 1]], l: numpy.ndarray[object[3, 1]]) -&gt; None</p>
</li>
</ol>
<p>Constructs a spatial momentum L from an angular momentum 𝐡 and a
translational momentum 𝐥.</p>
<ol class="arabic simple" start="3">
<li>__init__(self: pydrake.multibody.math.SpatialMomentum_[Expression], L: numpy.ndarray[object[6, 1]]) -&gt; None</li>
</ol>
<p>Constructs a spatial momentum L from an Eigen expression that
represents a 6-element vector, i.e., a 3-element angular momentum 𝐡
and a 3-element translational momentum 𝐥. This constructor will assert
the size of L is six (6) either at compile-time for fixed sized Eigen
expressions or at run-time for dynamic sized Eigen expressions.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_[Expression].dot">
<code class="descname">dot</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialMomentum_[Expression], velocity: pydrake.multibody.math.SpatialVelocity_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Expression<a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_[Expression].dot" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates twice (2x) a body B’s kinetic energy measured in a frame M.
For any frame (e.g., an multibody_frames_and_bodies “offset frame”) Bp
that is fixed to a rigid body B, calculates the dot-product of
<code class="docutils literal notranslate"><span class="pre">this</span></code> = L_MBp_E (body B’s spatial momentum measured in frame M,
about Bp’s origin, expressed in frame E) with V_MBp_E (frame Bp’s
spatial velocity measured in frame M, expressed in frame E).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">velocity</span></code>:</dt>
<dd>which is V_MBp_E, frame Bp’s spatial velocity measured in frame M,
and expressed in the same frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code> = L_MBp_E.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">2*K_MB, twice (2x) body B’s kinetic energy measured in frame M.</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In general, kinetic energy calculations are only useful when frame
M is a world frame (also called a Newtonian or inertial frame).
Hence, it is unusual to use this method unless frame M is the
world frame W.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Although the spatial vectors V_MBp_E and L_MBp_E must have the
same expressed-in frame E, the resulting scalar K_MB is
independent of frame E.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">As shown below, K_MB can be calculated from any frame Bp fixed on
B, including body B’s center of mass frame Bcm. This is due to how
spatial momentum and spatial velocity shift from Bcm to Bp. For
more information, see SpatialMomentum::Shift() and
SpatialVelocity::Shift().</p>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>K_MB = 1/2 (L_MBp · V_MBp) = 1/2 (L_MBcm · V_MBcm)
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_[Expression].get_coeffs">
<code class="descname">get_coeffs</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialMomentum_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[6, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_[Expression].get_coeffs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to the underlying storage.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_[Expression].Rotate">
<code class="descname">Rotate</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialMomentum_[Expression], R_FE: pydrake.math.RotationMatrix_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialMomentum_[Expression]<a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_[Expression].Rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides a Python-only implementation of rotating / re-expressing a
spatial vector.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is done because defining <code class="docutils literal notranslate"><span class="pre">__rmatmul__</span></code> on this class does
not disambiguate against the definitions of
<code class="docutils literal notranslate"><span class="pre">RotationMatrix.__matmul__</span></code>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_[Expression].rotational">
<code class="descname">rotational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialMomentum_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_[Expression].rotational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the rotational component of this spatial vector.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_[Expression].SetZero">
<code class="descname">SetZero</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialMomentum_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialMomentum_[Expression]<a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_[Expression].SetZero" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets both the rotational and translational components of <code class="docutils literal notranslate"><span class="pre">this</span></code>
SpatialVector to zero.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_[Expression].Shift">
<code class="descname">Shift</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialMomentum_[Expression], offset: numpy.ndarray[object[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialMomentum_[Expression]<a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_[Expression].Shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Shifts a SpatialMomentum from an about-point P to an about-point Q.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">offset</span></code>:</dt>
<dd>which is the position vector p_PQ_E from point P to point Q,
expressed in frame E. p_PQ_E must have the same expressed-in frame
E as <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial momentum, where <code class="docutils literal notranslate"><span class="pre">this</span></code> is L_MSP_E (system
S’s spatial momentum about P, measured in frame M, expressed in
frame E).</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">L_MSQ_E</span></code>:</dt>
<dd>which is system S’s spatial momentum about point Q, measured in
frame M, expressed in frame E.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Shift() differs from ShiftInPlace() in that Shift() does not
modify <code class="docutils literal notranslate"><span class="pre">this</span></code> whereas ShiftInPlace() does modify <code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">ShiftInPlace() for more information and how L_MSQ_E is calculated.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_[Expression].translational">
<code class="descname">translational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialMomentum_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_[Expression].translational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the translational component of this spatial vector.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.math.SpatialMomentum_[Expression].Zero">
<em class="property">static </em><code class="descname">Zero</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialMomentum_[Expression]<a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_[Expression].Zero" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory to create a <em>zero</em> spatial vector, i.e., a SpatialVector whose
rotational and translational components are both zero.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.math.SpatialMomentum_[float]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.math.</code><code class="descname">SpatialMomentum_[float]</code><a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>This class represents a <em>spatial momentum</em> L and has 6 elements with
an angular (rotational) momentum 𝐡 (3-element vector) on top of a
translational (linear) momentum 𝐥 (3-element vector). A spatial
momentum L stores the angular momentum 𝐡 and translational momentum 𝐥
of a system S about a point P, measured in a frame M, and expressed in
a frame E. The system S may be a particle, a rigid or deformable body,
or a set of particles and/or bodies. This class assumes that both the
angular momentum 𝐡 and translational momentum 𝐥 are expressed in the
same <em>expressed-in</em> frame E. This class only stores 6 elements (namely
𝐡 and 𝐥) and does not store the underlying system S, about-point P,
measured-in frame M, or expressed-in frame E. The user is responsible
for explicitly tracking the underlying system, about-point, and frames
with multibody_quantities “monogram notation”. For example, L_MSP_E
denotes a system S’s spatial momentum about point P, measured in frame
M, and expressed in frame E. L_MSP_E contains h_MSP_E (S’s angular
momentum about point P, measured in M, expressed in E) and l_MS_E (S’s
translational momentum measured in M, expressed in E). A body B’s
spatial momentum about point Bo (B’s origin), measured in frame M,
expressed in frame E has explicit monogram notation L_MBBo_E which can
be abbreviated L_MBo_E. Similarly L_MSScm_E is abbreviated L_MScm_E
(Scm is S’s center of mass). Details on spatial vectors and monogram
notation are in sections multibody_spatial_vectors and
multibody_quantities.</p>
<p>The typeset for L_MSP_E is <span class="math notranslate nohighlight">\([^ML^{S/P}]_E\)</span>. For a set S of
particles Qᵢ, L_MSP contains S’s angular momentum 𝐡 about-point P,
measured in frame M and S’s translational momentum 𝐥 measured in frame
M, defined as</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>h_MSP = ∑ h_MQᵢP = ∑ p_PQᵢ x l_MQᵢ  where l_MQᵢ = mᵢ v_MQᵢ.
  l_MS  = ∑ l_MQᵢ  = ∑ mᵢ v_MQᵢ
</pre></div>
</div>
<p>where mᵢ is the mass of particle Qᵢ, v_MQᵢ is Qᵢ’s translational
velocity measured in frame M, l_MQᵢ = mᵢ v_MQQᵢ is Qᵢ’s translational
momentum measured in frame M, h_MQᵢP is Qᵢ’s angular momentum about
point P measured in frame M, and p_PQᵢ is the position vector from
point P to Qᵢ. These definitions extend to a body (continuum of
particles) by using the density ρ(r) of the body at each material
location r as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>h_MSP = ∫p_PQ(r) x v_MQ(r) ρ(r) d³r
  l_MS  = ∫v_MQ(r) ρ(r) d³r
</pre></div>
</div>
<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialMomentum_[float]) -&gt; None</p>
<blockquote>
<div><p>Constructs to all NaNs.</p>
<dl class="docutils">
<dt>Note:</dt>
<dd><p class="first last">This is different from C++, which in Release builds may leave memory
uninitialized. In pydrake, the function call overhead already trumps
any overhead from NAN-initialization, so we err on the side of
safety.</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialMomentum_[float], h: numpy.ndarray[numpy.float64[3, 1]], l: numpy.ndarray[numpy.float64[3, 1]]) -&gt; None</p>
</li>
</ol>
<p>Constructs a spatial momentum L from an angular momentum 𝐡 and a
translational momentum 𝐥.</p>
<ol class="arabic simple" start="3">
<li>__init__(self: pydrake.multibody.math.SpatialMomentum_[float], L: numpy.ndarray[numpy.float64[6, 1]]) -&gt; None</li>
</ol>
<p>Constructs a spatial momentum L from an Eigen expression that
represents a 6-element vector, i.e., a 3-element angular momentum 𝐡
and a 3-element translational momentum 𝐥. This constructor will assert
the size of L is six (6) either at compile-time for fixed sized Eigen
expressions or at run-time for dynamic sized Eigen expressions.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_[float].dot">
<code class="descname">dot</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialMomentum_[float], velocity: pydrake.multibody.math.SpatialVelocity_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_[float].dot" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates twice (2x) a body B’s kinetic energy measured in a frame M.
For any frame (e.g., an multibody_frames_and_bodies “offset frame”) Bp
that is fixed to a rigid body B, calculates the dot-product of
<code class="docutils literal notranslate"><span class="pre">this</span></code> = L_MBp_E (body B’s spatial momentum measured in frame M,
about Bp’s origin, expressed in frame E) with V_MBp_E (frame Bp’s
spatial velocity measured in frame M, expressed in frame E).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">velocity</span></code>:</dt>
<dd>which is V_MBp_E, frame Bp’s spatial velocity measured in frame M,
and expressed in the same frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code> = L_MBp_E.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">2*K_MB, twice (2x) body B’s kinetic energy measured in frame M.</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In general, kinetic energy calculations are only useful when frame
M is a world frame (also called a Newtonian or inertial frame).
Hence, it is unusual to use this method unless frame M is the
world frame W.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Although the spatial vectors V_MBp_E and L_MBp_E must have the
same expressed-in frame E, the resulting scalar K_MB is
independent of frame E.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">As shown below, K_MB can be calculated from any frame Bp fixed on
B, including body B’s center of mass frame Bcm. This is due to how
spatial momentum and spatial velocity shift from Bcm to Bp. For
more information, see SpatialMomentum::Shift() and
SpatialVelocity::Shift().</p>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>K_MB = 1/2 (L_MBp · V_MBp) = 1/2 (L_MBcm · V_MBcm)
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_[float].get_coeffs">
<code class="descname">get_coeffs</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialMomentum_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[6, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_[float].get_coeffs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to the underlying storage.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_[float].Rotate">
<code class="descname">Rotate</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialMomentum_[float], R_FE: pydrake.math.RotationMatrix_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialMomentum_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_[float].Rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides a Python-only implementation of rotating / re-expressing a
spatial vector.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is done because defining <code class="docutils literal notranslate"><span class="pre">__rmatmul__</span></code> on this class does
not disambiguate against the definitions of
<code class="docutils literal notranslate"><span class="pre">RotationMatrix.__matmul__</span></code>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_[float].rotational">
<code class="descname">rotational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialMomentum_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_[float].rotational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the rotational component of this spatial vector.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_[float].SetZero">
<code class="descname">SetZero</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialMomentum_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialMomentum_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_[float].SetZero" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets both the rotational and translational components of <code class="docutils literal notranslate"><span class="pre">this</span></code>
SpatialVector to zero.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_[float].Shift">
<code class="descname">Shift</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialMomentum_[float], offset: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialMomentum_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_[float].Shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Shifts a SpatialMomentum from an about-point P to an about-point Q.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">offset</span></code>:</dt>
<dd>which is the position vector p_PQ_E from point P to point Q,
expressed in frame E. p_PQ_E must have the same expressed-in frame
E as <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial momentum, where <code class="docutils literal notranslate"><span class="pre">this</span></code> is L_MSP_E (system
S’s spatial momentum about P, measured in frame M, expressed in
frame E).</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">L_MSQ_E</span></code>:</dt>
<dd>which is system S’s spatial momentum about point Q, measured in
frame M, expressed in frame E.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Shift() differs from ShiftInPlace() in that Shift() does not
modify <code class="docutils literal notranslate"><span class="pre">this</span></code> whereas ShiftInPlace() does modify <code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">ShiftInPlace() for more information and how L_MSQ_E is calculated.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_[float].translational">
<code class="descname">translational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialMomentum_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_[float].translational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the translational component of this spatial vector.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.math.SpatialMomentum_[float].Zero">
<em class="property">static </em><code class="descname">Zero</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialMomentum_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_[float].Zero" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory to create a <em>zero</em> spatial vector, i.e., a SpatialVector whose
rotational and translational components are both zero.</p>
</dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.math.SpatialVelocity">
<code class="descclassname">pydrake.multibody.math.</code><code class="descname">SpatialVelocity</code><a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pydrake.multibody.math.SpatialVelocity_[float]" title="pydrake.multibody.math.SpatialVelocity_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.math.SpatialVelocity_[float]</span></code></a></p>
</dd></dl>

<dl class="template">
<dt id="pydrake.multibody.math.SpatialVelocity_">
<em class="property">template </em><code class="descclassname">pydrake.multibody.math.</code><code class="descname">SpatialVelocity_</code><a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.multibody.math.SpatialVelocity_[float]" title="pydrake.multibody.math.SpatialVelocity_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">SpatialVelocity_[float]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.math.SpatialVelocity_[AutoDiffXd]" title="pydrake.multibody.math.SpatialVelocity_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">SpatialVelocity_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.math.SpatialVelocity_[Expression]" title="pydrake.multibody.math.SpatialVelocity_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">SpatialVelocity_[Expression]</span></code></a></p>
<dl class="class">
<dt id="pydrake.multibody.math.SpatialVelocity_.SpatialVelocity_[float]">
<em class="property">class </em><code class="descname">SpatialVelocity_[float]</code><a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_.SpatialVelocity_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>This class represents a <em>spatial velocity</em> V (also called a <em>twist</em>)
and has 6 elements with an angular (rotational) velocity ω (3-element
vector) on top of a translational (linear) velocity v (3-element
vector). Spatial velocity represents the rotational and translational
motion of a frame B with respect to a <em>measured-in</em> frame M. This
class assumes that both the angular velocity ω and translational
velocity v are expressed in the same <em>expressed-in</em> frame E. This
class only stores 6 elements (namely ω and v) and does not store the
underlying frames B, M, E. The user is responsible for explicitly
tracking the underlying frames with multibody_quantities “monogram
notation”. For example, V_MB_E denotes frame B’s spatial velocity
measured in frame M, expressed in frame E and contains ω_MB_E (B’s
angular velocity measured in M, expressed in E) and v_MBo_E (Bo’s
translational velocity measured in M, expressed in E), where Bo is
frame B’s origin point. For an multibody_frames_and_bodies “offset
frame” Bp, the monogram notation V_MBp_E denotes the spatial velocity
of frame Bp measured in M, expressed in E. Details on spatial vectors
and monogram notation are in sections multibody_spatial_vectors and
multibody_quantities.</p>
<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_.SpatialVelocity_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_.SpatialVelocity_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialVelocity_[float]) -&gt; None</p>
<blockquote>
<div><p>Constructs to all NaNs.</p>
<dl class="docutils">
<dt>Note:</dt>
<dd><p class="first last">This is different from C++, which in Release builds may leave memory
uninitialized. In pydrake, the function call overhead already trumps
any overhead from NAN-initialization, so we err on the side of
safety.</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialVelocity_[float], w: numpy.ndarray[numpy.float64[3, 1]], v: numpy.ndarray[numpy.float64[3, 1]]) -&gt; None</p>
</li>
</ol>
<p>Constructs a spatial velocity V from an angular velocity ω and a
translational velocity v.</p>
<ol class="arabic simple" start="3">
<li>__init__(self: pydrake.multibody.math.SpatialVelocity_[float], V: numpy.ndarray[numpy.float64[6, 1]]) -&gt; None</li>
</ol>
<p>Constructs a spatial velocity V from an Eigen expression that
represents a 6-element vector, i.e., two 3-element vectors, namely an
angular velocity ω and a translational velocity v. This constructor
will assert the size of V is six (6) either at compile-time for fixed
sized Eigen expressions or at run-time for dynamic sized Eigen
expressions.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_.SpatialVelocity_[float].ComposeWithMovingFrameVelocity">
<code class="descname">ComposeWithMovingFrameVelocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialVelocity_[float], position_of_moving_frame: numpy.ndarray[numpy.float64[3, 1]], velocity_of_moving_frame: pydrake.multibody.math.SpatialVelocity_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialVelocity_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_.SpatialVelocity_[float].ComposeWithMovingFrameVelocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Compose <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial velocity (measured in some frame M) with the
spatial velocity of another frame to form the 𝐨𝐭𝐡𝐞𝐫 frame’s spatial
velocity measured in frame M. Herein, <code class="docutils literal notranslate"><span class="pre">this</span></code> is the spatial velocity
of a frame (designated B) in frame M and the 𝐨𝐭𝐡𝐞𝐫 frame is designated
C.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">position_of_moving_frame</span></code>:</dt>
<dd>which is the position vector p_BoCo_E (from frame B’s origin Bo to
frame C’s origin Co), expressed in a frame E. p_BoCo_E must have
the same expressed-in frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code>, where <code class="docutils literal notranslate"><span class="pre">this</span></code> is
V_MB_E (frame B’s spatial velocity measured in M, expressed in E).</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">velocity_of_moving_frame</span></code>:</dt>
<dd>which is V_BC_E, frame C’s spatial velocity measured in frame B,
expressed in frame E.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">V_MC_E</span></code>:</dt>
<dd>frame C’s spatial velocity measured in frame M, expressed in frame
E.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The returned spatial velocity V_MC_E contains an angular velocity
ω_MC_E and translational velocity v_MCo_E that are calculated as:</p>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ω_MC_E</span>  <span class="o">=</span> <span class="n">ω_MB_E</span> <span class="o">+</span> <span class="n">ω_BC_E</span>
 <span class="n">v_MCo_E</span> <span class="o">=</span> <span class="n">v_MBo_E</span> <span class="o">+</span> <span class="n">ω_MB_E</span> <span class="n">x</span> <span class="n">p_BoCo_E</span> <span class="o">+</span> <span class="n">v_BCo_E</span>
</pre></div>
</div>
<p>If frame C is rigidly fixed to frame B, V_BC_E = 0 and this method
produces a Shift() operation (albeit inefficiently). In other words,
use Shift() if velocity_of_moving_frame = 0.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">SpatialAcceleration::ComposeWithMovingFrameAcceleration().</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_.SpatialVelocity_[float].dot">
<code class="descname">dot</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_.SpatialVelocity_[float].dot" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>dot(self: pydrake.multibody.math.SpatialVelocity_[float], force: drake::multibody::SpatialForce&lt;double&gt;) -&gt; float</li>
</ol>
<p>Calculates the power generated by a spatial force. For an arbitrary
frame B, calculates the dot-product of <code class="docutils literal notranslate"><span class="pre">this</span></code> = V_MB_E (frame B’s
spatial velocity measured in a frame M, expressed in a frame E) with
F_B_E (frame B’s spatial force, expressed in frame E).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">force</span></code>:</dt>
<dd>which is F_B_E, frame B’s spatial force, expressed in the same
frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code> = V_MB_E.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Power of spatial force F_B_E in frame M, i.e., F_B_E ⋅ V_MB_E.</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Just as equating force 𝐅 to mass * acceleration as 𝐅 = m𝐚 relies
on acceleration 𝐚 being measured in a world frame (also called an
inertial or Newtonian frame), equating power = dK/dt (where K is
kinetic energy) relies on K being measured in a world frame.
Hence, it is unusual to use this method unless frame M is the
world frame W.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Although the spatial vectors F_B_E and V_MB_E must have the same
expressed-in frame E, the returned scalar is independent of frame
E.</p>
</div>
<ol class="arabic simple" start="2">
<li>dot(self: pydrake.multibody.math.SpatialVelocity_[float], momentum: drake::multibody::SpatialMomentum&lt;double&gt;) -&gt; float</li>
</ol>
<p>Calculates twice (2x) a body B’s kinetic energy measured in a frame M.
For any frame (e.g., an multibody_frames_and_bodies “offset frame”) Bp
that is fixed to a rigid body B, calculates the dot-product of
<code class="docutils literal notranslate"><span class="pre">this</span></code> = V_MBp_E (frame Bp’s spatial velocity measured in frame M,
expressed in frame E) with L_MBp_E (body B’s spatial momentum measured
in frame M, about Bp’s origin, expressed in frame E).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">momentum</span></code>:</dt>
<dd>which is L_MBp_E, body B’s spatial momentum measured in frame M,
about frame Bp’s origin, expressed in the same frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code>
= V_MBp_E.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">2*K_MB, twice (2x) body B’s kinetic energy measured in frame M.</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In general, kinetic energy calculations are only useful when frame
M is a world frame (also called a Newtonian or inertial frame).
Hence, it is unusual to use this method unless frame M is the
world frame W.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Although the spatial vectors V_MBp_E and L_MBp_E must have the
same expressed-in frame E, the resulting scalar K_MB is
independent of frame E.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">As shown below, K_MB can be calculated from any frame Bp fixed on
B, including body B’s center of mass frame Bcm. This is due to how
spatial momentum and spatial velocity shift from Bcm to Bp. For
more information, see SpatialMomentum::Shift() and
SpatialVelocity::Shift().</p>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>K_MB = 1/2 (L_MBp · V_MBp) = 1/2 (L_MBcm · V_MBcm)
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_.SpatialVelocity_[float].get_coeffs">
<code class="descname">get_coeffs</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialVelocity_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[6, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_.SpatialVelocity_[float].get_coeffs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to the underlying storage.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_.SpatialVelocity_[float].Rotate">
<code class="descname">Rotate</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialVelocity_[float], R_FE: pydrake.math.RotationMatrix_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialVelocity_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_.SpatialVelocity_[float].Rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides a Python-only implementation of rotating / re-expressing a
spatial vector.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is done because defining <code class="docutils literal notranslate"><span class="pre">__rmatmul__</span></code> on this class does
not disambiguate against the definitions of
<code class="docutils literal notranslate"><span class="pre">RotationMatrix.__matmul__</span></code>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_.SpatialVelocity_[float].rotational">
<code class="descname">rotational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialVelocity_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_.SpatialVelocity_[float].rotational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the rotational component of this spatial vector.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_.SpatialVelocity_[float].SetZero">
<code class="descname">SetZero</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialVelocity_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialVelocity_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_.SpatialVelocity_[float].SetZero" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets both the rotational and translational components of <code class="docutils literal notranslate"><span class="pre">this</span></code>
SpatialVector to zero.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_.SpatialVelocity_[float].Shift">
<code class="descname">Shift</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialVelocity_[float], offset: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialVelocity_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_.SpatialVelocity_[float].Shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Shifts a SpatialVelocity from a frame B to a frame C, where both B and
C are fixed to the same frame or rigid body.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">offset</span></code>:</dt>
<dd>which is the position vector p_BoCo_E from frame B’s origin to
frame C’s origin, expressed in frame E. p_BoCo_E must have the
same expressed-in frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial velocity (<code class="docutils literal notranslate"><span class="pre">this</span></code> =
V_MB_E).</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">V_MC_E</span></code>:</dt>
<dd>which is frame C’s spatial velocity measured in frame M, expressed
in frame E.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Shift() differs from ShiftInPlace() in that Shift() does not
modify <code class="docutils literal notranslate"><span class="pre">this</span></code> whereas ShiftInPlace() does modify <code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">ShiftInPlace() for more information and how V_MC_E is calculated.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_.SpatialVelocity_[float].translational">
<code class="descname">translational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialVelocity_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_.SpatialVelocity_[float].translational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the translational component of this spatial vector.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.math.SpatialVelocity_.SpatialVelocity_[float].Zero">
<em class="property">static </em><code class="descname">Zero</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialVelocity_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_.SpatialVelocity_[float].Zero" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory to create a <em>zero</em> spatial vector, i.e., a SpatialVector whose
rotational and translational components are both zero.</p>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.math.SpatialVelocity_[AutoDiffXd]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.math.</code><code class="descname">SpatialVelocity_[AutoDiffXd]</code><a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[AutoDiffXd]" title="Permalink to this definition">¶</a></dt>
<dd><p>This class represents a <em>spatial velocity</em> V (also called a <em>twist</em>)
and has 6 elements with an angular (rotational) velocity ω (3-element
vector) on top of a translational (linear) velocity v (3-element
vector). Spatial velocity represents the rotational and translational
motion of a frame B with respect to a <em>measured-in</em> frame M. This
class assumes that both the angular velocity ω and translational
velocity v are expressed in the same <em>expressed-in</em> frame E. This
class only stores 6 elements (namely ω and v) and does not store the
underlying frames B, M, E. The user is responsible for explicitly
tracking the underlying frames with multibody_quantities “monogram
notation”. For example, V_MB_E denotes frame B’s spatial velocity
measured in frame M, expressed in frame E and contains ω_MB_E (B’s
angular velocity measured in M, expressed in E) and v_MBo_E (Bo’s
translational velocity measured in M, expressed in E), where Bo is
frame B’s origin point. For an multibody_frames_and_bodies “offset
frame” Bp, the monogram notation V_MBp_E denotes the spatial velocity
of frame Bp measured in M, expressed in E. Details on spatial vectors
and monogram notation are in sections multibody_spatial_vectors and
multibody_quantities.</p>
<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_[AutoDiffXd].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[AutoDiffXd].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialVelocity_[AutoDiffXd]) -&gt; None</p>
<blockquote>
<div><p>Constructs to all NaNs.</p>
<dl class="docutils">
<dt>Note:</dt>
<dd><p class="first last">This is different from C++, which in Release builds may leave memory
uninitialized. In pydrake, the function call overhead already trumps
any overhead from NAN-initialization, so we err on the side of
safety.</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialVelocity_[AutoDiffXd], w: numpy.ndarray[object[3, 1]], v: numpy.ndarray[object[3, 1]]) -&gt; None</p>
</li>
</ol>
<p>Constructs a spatial velocity V from an angular velocity ω and a
translational velocity v.</p>
<ol class="arabic simple" start="3">
<li>__init__(self: pydrake.multibody.math.SpatialVelocity_[AutoDiffXd], V: numpy.ndarray[object[6, 1]]) -&gt; None</li>
</ol>
<p>Constructs a spatial velocity V from an Eigen expression that
represents a 6-element vector, i.e., two 3-element vectors, namely an
angular velocity ω and a translational velocity v. This constructor
will assert the size of V is six (6) either at compile-time for fixed
sized Eigen expressions or at run-time for dynamic sized Eigen
expressions.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_[AutoDiffXd].ComposeWithMovingFrameVelocity">
<code class="descname">ComposeWithMovingFrameVelocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialVelocity_[AutoDiffXd], position_of_moving_frame: numpy.ndarray[object[3, 1]], velocity_of_moving_frame: pydrake.multibody.math.SpatialVelocity_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialVelocity_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[AutoDiffXd].ComposeWithMovingFrameVelocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Compose <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial velocity (measured in some frame M) with the
spatial velocity of another frame to form the 𝐨𝐭𝐡𝐞𝐫 frame’s spatial
velocity measured in frame M. Herein, <code class="docutils literal notranslate"><span class="pre">this</span></code> is the spatial velocity
of a frame (designated B) in frame M and the 𝐨𝐭𝐡𝐞𝐫 frame is designated
C.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">position_of_moving_frame</span></code>:</dt>
<dd>which is the position vector p_BoCo_E (from frame B’s origin Bo to
frame C’s origin Co), expressed in a frame E. p_BoCo_E must have
the same expressed-in frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code>, where <code class="docutils literal notranslate"><span class="pre">this</span></code> is
V_MB_E (frame B’s spatial velocity measured in M, expressed in E).</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">velocity_of_moving_frame</span></code>:</dt>
<dd>which is V_BC_E, frame C’s spatial velocity measured in frame B,
expressed in frame E.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">V_MC_E</span></code>:</dt>
<dd>frame C’s spatial velocity measured in frame M, expressed in frame
E.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The returned spatial velocity V_MC_E contains an angular velocity
ω_MC_E and translational velocity v_MCo_E that are calculated as:</p>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ω_MC_E</span>  <span class="o">=</span> <span class="n">ω_MB_E</span> <span class="o">+</span> <span class="n">ω_BC_E</span>
 <span class="n">v_MCo_E</span> <span class="o">=</span> <span class="n">v_MBo_E</span> <span class="o">+</span> <span class="n">ω_MB_E</span> <span class="n">x</span> <span class="n">p_BoCo_E</span> <span class="o">+</span> <span class="n">v_BCo_E</span>
</pre></div>
</div>
<p>If frame C is rigidly fixed to frame B, V_BC_E = 0 and this method
produces a Shift() operation (albeit inefficiently). In other words,
use Shift() if velocity_of_moving_frame = 0.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">SpatialAcceleration::ComposeWithMovingFrameAcceleration().</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_[AutoDiffXd].dot">
<code class="descname">dot</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[AutoDiffXd].dot" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>dot(self: pydrake.multibody.math.SpatialVelocity_[AutoDiffXd], force: drake::multibody::SpatialForce&lt;Eigen::AutoDiffScalar&lt;Eigen::Matrix&lt;double, -1, 1, 0, -1, 1&gt; &gt; &gt;) -&gt; pydrake.autodiffutils.AutoDiffXd</li>
</ol>
<p>Calculates the power generated by a spatial force. For an arbitrary
frame B, calculates the dot-product of <code class="docutils literal notranslate"><span class="pre">this</span></code> = V_MB_E (frame B’s
spatial velocity measured in a frame M, expressed in a frame E) with
F_B_E (frame B’s spatial force, expressed in frame E).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">force</span></code>:</dt>
<dd>which is F_B_E, frame B’s spatial force, expressed in the same
frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code> = V_MB_E.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Power of spatial force F_B_E in frame M, i.e., F_B_E ⋅ V_MB_E.</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Just as equating force 𝐅 to mass * acceleration as 𝐅 = m𝐚 relies
on acceleration 𝐚 being measured in a world frame (also called an
inertial or Newtonian frame), equating power = dK/dt (where K is
kinetic energy) relies on K being measured in a world frame.
Hence, it is unusual to use this method unless frame M is the
world frame W.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Although the spatial vectors F_B_E and V_MB_E must have the same
expressed-in frame E, the returned scalar is independent of frame
E.</p>
</div>
<ol class="arabic simple" start="2">
<li>dot(self: pydrake.multibody.math.SpatialVelocity_[AutoDiffXd], momentum: drake::multibody::SpatialMomentum&lt;Eigen::AutoDiffScalar&lt;Eigen::Matrix&lt;double, -1, 1, 0, -1, 1&gt; &gt; &gt;) -&gt; pydrake.autodiffutils.AutoDiffXd</li>
</ol>
<p>Calculates twice (2x) a body B’s kinetic energy measured in a frame M.
For any frame (e.g., an multibody_frames_and_bodies “offset frame”) Bp
that is fixed to a rigid body B, calculates the dot-product of
<code class="docutils literal notranslate"><span class="pre">this</span></code> = V_MBp_E (frame Bp’s spatial velocity measured in frame M,
expressed in frame E) with L_MBp_E (body B’s spatial momentum measured
in frame M, about Bp’s origin, expressed in frame E).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">momentum</span></code>:</dt>
<dd>which is L_MBp_E, body B’s spatial momentum measured in frame M,
about frame Bp’s origin, expressed in the same frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code>
= V_MBp_E.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">2*K_MB, twice (2x) body B’s kinetic energy measured in frame M.</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In general, kinetic energy calculations are only useful when frame
M is a world frame (also called a Newtonian or inertial frame).
Hence, it is unusual to use this method unless frame M is the
world frame W.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Although the spatial vectors V_MBp_E and L_MBp_E must have the
same expressed-in frame E, the resulting scalar K_MB is
independent of frame E.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">As shown below, K_MB can be calculated from any frame Bp fixed on
B, including body B’s center of mass frame Bcm. This is due to how
spatial momentum and spatial velocity shift from Bcm to Bp. For
more information, see SpatialMomentum::Shift() and
SpatialVelocity::Shift().</p>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>K_MB = 1/2 (L_MBp · V_MBp) = 1/2 (L_MBcm · V_MBcm)
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_[AutoDiffXd].get_coeffs">
<code class="descname">get_coeffs</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialVelocity_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[6, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[AutoDiffXd].get_coeffs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to the underlying storage.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_[AutoDiffXd].Rotate">
<code class="descname">Rotate</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialVelocity_[AutoDiffXd], R_FE: pydrake.math.RotationMatrix_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialVelocity_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[AutoDiffXd].Rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides a Python-only implementation of rotating / re-expressing a
spatial vector.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is done because defining <code class="docutils literal notranslate"><span class="pre">__rmatmul__</span></code> on this class does
not disambiguate against the definitions of
<code class="docutils literal notranslate"><span class="pre">RotationMatrix.__matmul__</span></code>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_[AutoDiffXd].rotational">
<code class="descname">rotational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialVelocity_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[AutoDiffXd].rotational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the rotational component of this spatial vector.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_[AutoDiffXd].SetZero">
<code class="descname">SetZero</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialVelocity_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialVelocity_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[AutoDiffXd].SetZero" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets both the rotational and translational components of <code class="docutils literal notranslate"><span class="pre">this</span></code>
SpatialVector to zero.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_[AutoDiffXd].Shift">
<code class="descname">Shift</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialVelocity_[AutoDiffXd], offset: numpy.ndarray[object[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialVelocity_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[AutoDiffXd].Shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Shifts a SpatialVelocity from a frame B to a frame C, where both B and
C are fixed to the same frame or rigid body.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">offset</span></code>:</dt>
<dd>which is the position vector p_BoCo_E from frame B’s origin to
frame C’s origin, expressed in frame E. p_BoCo_E must have the
same expressed-in frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial velocity (<code class="docutils literal notranslate"><span class="pre">this</span></code> =
V_MB_E).</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">V_MC_E</span></code>:</dt>
<dd>which is frame C’s spatial velocity measured in frame M, expressed
in frame E.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Shift() differs from ShiftInPlace() in that Shift() does not
modify <code class="docutils literal notranslate"><span class="pre">this</span></code> whereas ShiftInPlace() does modify <code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">ShiftInPlace() for more information and how V_MC_E is calculated.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_[AutoDiffXd].translational">
<code class="descname">translational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialVelocity_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[AutoDiffXd].translational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the translational component of this spatial vector.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.math.SpatialVelocity_[AutoDiffXd].Zero">
<em class="property">static </em><code class="descname">Zero</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialVelocity_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[AutoDiffXd].Zero" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory to create a <em>zero</em> spatial vector, i.e., a SpatialVector whose
rotational and translational components are both zero.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.math.SpatialVelocity_[Expression]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.math.</code><code class="descname">SpatialVelocity_[Expression]</code><a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[Expression]" title="Permalink to this definition">¶</a></dt>
<dd><p>This class represents a <em>spatial velocity</em> V (also called a <em>twist</em>)
and has 6 elements with an angular (rotational) velocity ω (3-element
vector) on top of a translational (linear) velocity v (3-element
vector). Spatial velocity represents the rotational and translational
motion of a frame B with respect to a <em>measured-in</em> frame M. This
class assumes that both the angular velocity ω and translational
velocity v are expressed in the same <em>expressed-in</em> frame E. This
class only stores 6 elements (namely ω and v) and does not store the
underlying frames B, M, E. The user is responsible for explicitly
tracking the underlying frames with multibody_quantities “monogram
notation”. For example, V_MB_E denotes frame B’s spatial velocity
measured in frame M, expressed in frame E and contains ω_MB_E (B’s
angular velocity measured in M, expressed in E) and v_MBo_E (Bo’s
translational velocity measured in M, expressed in E), where Bo is
frame B’s origin point. For an multibody_frames_and_bodies “offset
frame” Bp, the monogram notation V_MBp_E denotes the spatial velocity
of frame Bp measured in M, expressed in E. Details on spatial vectors
and monogram notation are in sections multibody_spatial_vectors and
multibody_quantities.</p>
<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_[Expression].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[Expression].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialVelocity_[Expression]) -&gt; None</p>
<blockquote>
<div><p>Constructs to all NaNs.</p>
<dl class="docutils">
<dt>Note:</dt>
<dd><p class="first last">This is different from C++, which in Release builds may leave memory
uninitialized. In pydrake, the function call overhead already trumps
any overhead from NAN-initialization, so we err on the side of
safety.</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialVelocity_[Expression], w: numpy.ndarray[object[3, 1]], v: numpy.ndarray[object[3, 1]]) -&gt; None</p>
</li>
</ol>
<p>Constructs a spatial velocity V from an angular velocity ω and a
translational velocity v.</p>
<ol class="arabic simple" start="3">
<li>__init__(self: pydrake.multibody.math.SpatialVelocity_[Expression], V: numpy.ndarray[object[6, 1]]) -&gt; None</li>
</ol>
<p>Constructs a spatial velocity V from an Eigen expression that
represents a 6-element vector, i.e., two 3-element vectors, namely an
angular velocity ω and a translational velocity v. This constructor
will assert the size of V is six (6) either at compile-time for fixed
sized Eigen expressions or at run-time for dynamic sized Eigen
expressions.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_[Expression].ComposeWithMovingFrameVelocity">
<code class="descname">ComposeWithMovingFrameVelocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialVelocity_[Expression], position_of_moving_frame: numpy.ndarray[object[3, 1]], velocity_of_moving_frame: pydrake.multibody.math.SpatialVelocity_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialVelocity_[Expression]<a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[Expression].ComposeWithMovingFrameVelocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Compose <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial velocity (measured in some frame M) with the
spatial velocity of another frame to form the 𝐨𝐭𝐡𝐞𝐫 frame’s spatial
velocity measured in frame M. Herein, <code class="docutils literal notranslate"><span class="pre">this</span></code> is the spatial velocity
of a frame (designated B) in frame M and the 𝐨𝐭𝐡𝐞𝐫 frame is designated
C.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">position_of_moving_frame</span></code>:</dt>
<dd>which is the position vector p_BoCo_E (from frame B’s origin Bo to
frame C’s origin Co), expressed in a frame E. p_BoCo_E must have
the same expressed-in frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code>, where <code class="docutils literal notranslate"><span class="pre">this</span></code> is
V_MB_E (frame B’s spatial velocity measured in M, expressed in E).</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">velocity_of_moving_frame</span></code>:</dt>
<dd>which is V_BC_E, frame C’s spatial velocity measured in frame B,
expressed in frame E.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">V_MC_E</span></code>:</dt>
<dd>frame C’s spatial velocity measured in frame M, expressed in frame
E.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The returned spatial velocity V_MC_E contains an angular velocity
ω_MC_E and translational velocity v_MCo_E that are calculated as:</p>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ω_MC_E</span>  <span class="o">=</span> <span class="n">ω_MB_E</span> <span class="o">+</span> <span class="n">ω_BC_E</span>
 <span class="n">v_MCo_E</span> <span class="o">=</span> <span class="n">v_MBo_E</span> <span class="o">+</span> <span class="n">ω_MB_E</span> <span class="n">x</span> <span class="n">p_BoCo_E</span> <span class="o">+</span> <span class="n">v_BCo_E</span>
</pre></div>
</div>
<p>If frame C is rigidly fixed to frame B, V_BC_E = 0 and this method
produces a Shift() operation (albeit inefficiently). In other words,
use Shift() if velocity_of_moving_frame = 0.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">SpatialAcceleration::ComposeWithMovingFrameAcceleration().</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_[Expression].dot">
<code class="descname">dot</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[Expression].dot" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>dot(self: pydrake.multibody.math.SpatialVelocity_[Expression], force: drake::multibody::SpatialForce&lt;drake::symbolic::Expression&gt;) -&gt; pydrake.symbolic.Expression</li>
</ol>
<p>Calculates the power generated by a spatial force. For an arbitrary
frame B, calculates the dot-product of <code class="docutils literal notranslate"><span class="pre">this</span></code> = V_MB_E (frame B’s
spatial velocity measured in a frame M, expressed in a frame E) with
F_B_E (frame B’s spatial force, expressed in frame E).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">force</span></code>:</dt>
<dd>which is F_B_E, frame B’s spatial force, expressed in the same
frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code> = V_MB_E.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Power of spatial force F_B_E in frame M, i.e., F_B_E ⋅ V_MB_E.</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Just as equating force 𝐅 to mass * acceleration as 𝐅 = m𝐚 relies
on acceleration 𝐚 being measured in a world frame (also called an
inertial or Newtonian frame), equating power = dK/dt (where K is
kinetic energy) relies on K being measured in a world frame.
Hence, it is unusual to use this method unless frame M is the
world frame W.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Although the spatial vectors F_B_E and V_MB_E must have the same
expressed-in frame E, the returned scalar is independent of frame
E.</p>
</div>
<ol class="arabic simple" start="2">
<li>dot(self: pydrake.multibody.math.SpatialVelocity_[Expression], momentum: drake::multibody::SpatialMomentum&lt;drake::symbolic::Expression&gt;) -&gt; pydrake.symbolic.Expression</li>
</ol>
<p>Calculates twice (2x) a body B’s kinetic energy measured in a frame M.
For any frame (e.g., an multibody_frames_and_bodies “offset frame”) Bp
that is fixed to a rigid body B, calculates the dot-product of
<code class="docutils literal notranslate"><span class="pre">this</span></code> = V_MBp_E (frame Bp’s spatial velocity measured in frame M,
expressed in frame E) with L_MBp_E (body B’s spatial momentum measured
in frame M, about Bp’s origin, expressed in frame E).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">momentum</span></code>:</dt>
<dd>which is L_MBp_E, body B’s spatial momentum measured in frame M,
about frame Bp’s origin, expressed in the same frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code>
= V_MBp_E.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">2*K_MB, twice (2x) body B’s kinetic energy measured in frame M.</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In general, kinetic energy calculations are only useful when frame
M is a world frame (also called a Newtonian or inertial frame).
Hence, it is unusual to use this method unless frame M is the
world frame W.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Although the spatial vectors V_MBp_E and L_MBp_E must have the
same expressed-in frame E, the resulting scalar K_MB is
independent of frame E.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">As shown below, K_MB can be calculated from any frame Bp fixed on
B, including body B’s center of mass frame Bcm. This is due to how
spatial momentum and spatial velocity shift from Bcm to Bp. For
more information, see SpatialMomentum::Shift() and
SpatialVelocity::Shift().</p>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>K_MB = 1/2 (L_MBp · V_MBp) = 1/2 (L_MBcm · V_MBcm)
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_[Expression].get_coeffs">
<code class="descname">get_coeffs</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialVelocity_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[6, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[Expression].get_coeffs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to the underlying storage.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_[Expression].Rotate">
<code class="descname">Rotate</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialVelocity_[Expression], R_FE: pydrake.math.RotationMatrix_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialVelocity_[Expression]<a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[Expression].Rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides a Python-only implementation of rotating / re-expressing a
spatial vector.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is done because defining <code class="docutils literal notranslate"><span class="pre">__rmatmul__</span></code> on this class does
not disambiguate against the definitions of
<code class="docutils literal notranslate"><span class="pre">RotationMatrix.__matmul__</span></code>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_[Expression].rotational">
<code class="descname">rotational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialVelocity_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[Expression].rotational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the rotational component of this spatial vector.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_[Expression].SetZero">
<code class="descname">SetZero</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialVelocity_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialVelocity_[Expression]<a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[Expression].SetZero" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets both the rotational and translational components of <code class="docutils literal notranslate"><span class="pre">this</span></code>
SpatialVector to zero.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_[Expression].Shift">
<code class="descname">Shift</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialVelocity_[Expression], offset: numpy.ndarray[object[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialVelocity_[Expression]<a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[Expression].Shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Shifts a SpatialVelocity from a frame B to a frame C, where both B and
C are fixed to the same frame or rigid body.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">offset</span></code>:</dt>
<dd>which is the position vector p_BoCo_E from frame B’s origin to
frame C’s origin, expressed in frame E. p_BoCo_E must have the
same expressed-in frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial velocity (<code class="docutils literal notranslate"><span class="pre">this</span></code> =
V_MB_E).</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">V_MC_E</span></code>:</dt>
<dd>which is frame C’s spatial velocity measured in frame M, expressed
in frame E.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Shift() differs from ShiftInPlace() in that Shift() does not
modify <code class="docutils literal notranslate"><span class="pre">this</span></code> whereas ShiftInPlace() does modify <code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">ShiftInPlace() for more information and how V_MC_E is calculated.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_[Expression].translational">
<code class="descname">translational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialVelocity_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[Expression].translational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the translational component of this spatial vector.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.math.SpatialVelocity_[Expression].Zero">
<em class="property">static </em><code class="descname">Zero</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialVelocity_[Expression]<a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[Expression].Zero" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory to create a <em>zero</em> spatial vector, i.e., a SpatialVector whose
rotational and translational components are both zero.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.math.SpatialVelocity_[float]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.math.</code><code class="descname">SpatialVelocity_[float]</code><a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>This class represents a <em>spatial velocity</em> V (also called a <em>twist</em>)
and has 6 elements with an angular (rotational) velocity ω (3-element
vector) on top of a translational (linear) velocity v (3-element
vector). Spatial velocity represents the rotational and translational
motion of a frame B with respect to a <em>measured-in</em> frame M. This
class assumes that both the angular velocity ω and translational
velocity v are expressed in the same <em>expressed-in</em> frame E. This
class only stores 6 elements (namely ω and v) and does not store the
underlying frames B, M, E. The user is responsible for explicitly
tracking the underlying frames with multibody_quantities “monogram
notation”. For example, V_MB_E denotes frame B’s spatial velocity
measured in frame M, expressed in frame E and contains ω_MB_E (B’s
angular velocity measured in M, expressed in E) and v_MBo_E (Bo’s
translational velocity measured in M, expressed in E), where Bo is
frame B’s origin point. For an multibody_frames_and_bodies “offset
frame” Bp, the monogram notation V_MBp_E denotes the spatial velocity
of frame Bp measured in M, expressed in E. Details on spatial vectors
and monogram notation are in sections multibody_spatial_vectors and
multibody_quantities.</p>
<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialVelocity_[float]) -&gt; None</p>
<blockquote>
<div><p>Constructs to all NaNs.</p>
<dl class="docutils">
<dt>Note:</dt>
<dd><p class="first last">This is different from C++, which in Release builds may leave memory
uninitialized. In pydrake, the function call overhead already trumps
any overhead from NAN-initialization, so we err on the side of
safety.</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialVelocity_[float], w: numpy.ndarray[numpy.float64[3, 1]], v: numpy.ndarray[numpy.float64[3, 1]]) -&gt; None</p>
</li>
</ol>
<p>Constructs a spatial velocity V from an angular velocity ω and a
translational velocity v.</p>
<ol class="arabic simple" start="3">
<li>__init__(self: pydrake.multibody.math.SpatialVelocity_[float], V: numpy.ndarray[numpy.float64[6, 1]]) -&gt; None</li>
</ol>
<p>Constructs a spatial velocity V from an Eigen expression that
represents a 6-element vector, i.e., two 3-element vectors, namely an
angular velocity ω and a translational velocity v. This constructor
will assert the size of V is six (6) either at compile-time for fixed
sized Eigen expressions or at run-time for dynamic sized Eigen
expressions.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_[float].ComposeWithMovingFrameVelocity">
<code class="descname">ComposeWithMovingFrameVelocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialVelocity_[float], position_of_moving_frame: numpy.ndarray[numpy.float64[3, 1]], velocity_of_moving_frame: pydrake.multibody.math.SpatialVelocity_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialVelocity_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[float].ComposeWithMovingFrameVelocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Compose <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial velocity (measured in some frame M) with the
spatial velocity of another frame to form the 𝐨𝐭𝐡𝐞𝐫 frame’s spatial
velocity measured in frame M. Herein, <code class="docutils literal notranslate"><span class="pre">this</span></code> is the spatial velocity
of a frame (designated B) in frame M and the 𝐨𝐭𝐡𝐞𝐫 frame is designated
C.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">position_of_moving_frame</span></code>:</dt>
<dd>which is the position vector p_BoCo_E (from frame B’s origin Bo to
frame C’s origin Co), expressed in a frame E. p_BoCo_E must have
the same expressed-in frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code>, where <code class="docutils literal notranslate"><span class="pre">this</span></code> is
V_MB_E (frame B’s spatial velocity measured in M, expressed in E).</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">velocity_of_moving_frame</span></code>:</dt>
<dd>which is V_BC_E, frame C’s spatial velocity measured in frame B,
expressed in frame E.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">V_MC_E</span></code>:</dt>
<dd>frame C’s spatial velocity measured in frame M, expressed in frame
E.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The returned spatial velocity V_MC_E contains an angular velocity
ω_MC_E and translational velocity v_MCo_E that are calculated as:</p>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ω_MC_E</span>  <span class="o">=</span> <span class="n">ω_MB_E</span> <span class="o">+</span> <span class="n">ω_BC_E</span>
 <span class="n">v_MCo_E</span> <span class="o">=</span> <span class="n">v_MBo_E</span> <span class="o">+</span> <span class="n">ω_MB_E</span> <span class="n">x</span> <span class="n">p_BoCo_E</span> <span class="o">+</span> <span class="n">v_BCo_E</span>
</pre></div>
</div>
<p>If frame C is rigidly fixed to frame B, V_BC_E = 0 and this method
produces a Shift() operation (albeit inefficiently). In other words,
use Shift() if velocity_of_moving_frame = 0.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">SpatialAcceleration::ComposeWithMovingFrameAcceleration().</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_[float].dot">
<code class="descname">dot</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[float].dot" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>dot(self: pydrake.multibody.math.SpatialVelocity_[float], force: drake::multibody::SpatialForce&lt;double&gt;) -&gt; float</li>
</ol>
<p>Calculates the power generated by a spatial force. For an arbitrary
frame B, calculates the dot-product of <code class="docutils literal notranslate"><span class="pre">this</span></code> = V_MB_E (frame B’s
spatial velocity measured in a frame M, expressed in a frame E) with
F_B_E (frame B’s spatial force, expressed in frame E).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">force</span></code>:</dt>
<dd>which is F_B_E, frame B’s spatial force, expressed in the same
frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code> = V_MB_E.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Power of spatial force F_B_E in frame M, i.e., F_B_E ⋅ V_MB_E.</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Just as equating force 𝐅 to mass * acceleration as 𝐅 = m𝐚 relies
on acceleration 𝐚 being measured in a world frame (also called an
inertial or Newtonian frame), equating power = dK/dt (where K is
kinetic energy) relies on K being measured in a world frame.
Hence, it is unusual to use this method unless frame M is the
world frame W.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Although the spatial vectors F_B_E and V_MB_E must have the same
expressed-in frame E, the returned scalar is independent of frame
E.</p>
</div>
<ol class="arabic simple" start="2">
<li>dot(self: pydrake.multibody.math.SpatialVelocity_[float], momentum: drake::multibody::SpatialMomentum&lt;double&gt;) -&gt; float</li>
</ol>
<p>Calculates twice (2x) a body B’s kinetic energy measured in a frame M.
For any frame (e.g., an multibody_frames_and_bodies “offset frame”) Bp
that is fixed to a rigid body B, calculates the dot-product of
<code class="docutils literal notranslate"><span class="pre">this</span></code> = V_MBp_E (frame Bp’s spatial velocity measured in frame M,
expressed in frame E) with L_MBp_E (body B’s spatial momentum measured
in frame M, about Bp’s origin, expressed in frame E).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">momentum</span></code>:</dt>
<dd>which is L_MBp_E, body B’s spatial momentum measured in frame M,
about frame Bp’s origin, expressed in the same frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code>
= V_MBp_E.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">2*K_MB, twice (2x) body B’s kinetic energy measured in frame M.</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In general, kinetic energy calculations are only useful when frame
M is a world frame (also called a Newtonian or inertial frame).
Hence, it is unusual to use this method unless frame M is the
world frame W.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Although the spatial vectors V_MBp_E and L_MBp_E must have the
same expressed-in frame E, the resulting scalar K_MB is
independent of frame E.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">As shown below, K_MB can be calculated from any frame Bp fixed on
B, including body B’s center of mass frame Bcm. This is due to how
spatial momentum and spatial velocity shift from Bcm to Bp. For
more information, see SpatialMomentum::Shift() and
SpatialVelocity::Shift().</p>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>K_MB = 1/2 (L_MBp · V_MBp) = 1/2 (L_MBcm · V_MBcm)
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_[float].get_coeffs">
<code class="descname">get_coeffs</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialVelocity_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[6, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[float].get_coeffs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to the underlying storage.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_[float].Rotate">
<code class="descname">Rotate</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialVelocity_[float], R_FE: pydrake.math.RotationMatrix_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialVelocity_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[float].Rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides a Python-only implementation of rotating / re-expressing a
spatial vector.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is done because defining <code class="docutils literal notranslate"><span class="pre">__rmatmul__</span></code> on this class does
not disambiguate against the definitions of
<code class="docutils literal notranslate"><span class="pre">RotationMatrix.__matmul__</span></code>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_[float].rotational">
<code class="descname">rotational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialVelocity_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[float].rotational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the rotational component of this spatial vector.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_[float].SetZero">
<code class="descname">SetZero</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialVelocity_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialVelocity_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[float].SetZero" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets both the rotational and translational components of <code class="docutils literal notranslate"><span class="pre">this</span></code>
SpatialVector to zero.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_[float].Shift">
<code class="descname">Shift</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialVelocity_[float], offset: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialVelocity_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[float].Shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Shifts a SpatialVelocity from a frame B to a frame C, where both B and
C are fixed to the same frame or rigid body.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">offset</span></code>:</dt>
<dd>which is the position vector p_BoCo_E from frame B’s origin to
frame C’s origin, expressed in frame E. p_BoCo_E must have the
same expressed-in frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial velocity (<code class="docutils literal notranslate"><span class="pre">this</span></code> =
V_MB_E).</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">V_MC_E</span></code>:</dt>
<dd>which is frame C’s spatial velocity measured in frame M, expressed
in frame E.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Shift() differs from ShiftInPlace() in that Shift() does not
modify <code class="docutils literal notranslate"><span class="pre">this</span></code> whereas ShiftInPlace() does modify <code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">ShiftInPlace() for more information and how V_MC_E is calculated.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_[float].translational">
<code class="descname">translational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialVelocity_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[float].translational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the translational component of this spatial vector.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.math.SpatialVelocity_[float].Zero">
<em class="property">static </em><code class="descname">Zero</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialVelocity_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[float].Zero" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory to create a <em>zero</em> spatial vector, i.e., a SpatialVector whose
rotational and translational components are both zero.</p>
</dd></dl>

</dd></dl>

</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="pydrake.multibody.meshcat.html" class="btn btn-neutral float-right" title="pydrake.multibody.meshcat" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="pydrake.multibody.inverse_kinematics.html" class="btn btn-neutral float-left" title="pydrake.multibody.inverse_kinematics" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>

    </p>
  </div>
</footer>
<script>
  /* Enables clicking for the mobile "hamburger" (three-line) menu item. */
  const siteHeader = document.querySelector('.site-header')
  const mobileButton = document.querySelector('.menu-mobile-toggle')
  const body = document.querySelector('body')

  mobileButton.addEventListener('click', function(event) {
    siteHeader.classList.toggle('open');
    body.classList.toggle('overflow-hidden');
  })
</script>
<footer class="site-footer padding">
  <div class="contain">
    <a href="/" class="drake-logo">
      <img src="/images/drake-logo.svg">
    </a>
    <div class="footer-menu">
      <ul>
        <li>
          <a href="/doxygen_cxx/index.html" class="site-menu-item">C++</a>
        </li>
        <li>
          <a href="/pydrake/index.html" class="site-menu-item">Python</a>
        </li>
        <li class="github-link">
          <a href="https://github.com/RobotLocomotion/drake" class="site-menu-item">GitHub <img src="/third_party/images/GitHub-Mark-64px.png"></a>
        </li>
      </ul>
    </div>
  </div>


</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>