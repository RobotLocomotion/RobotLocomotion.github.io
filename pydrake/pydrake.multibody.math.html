

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>pydrake.multibody.math &mdash; pydrake  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/custom.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="pydrake.multibody.meshcat" href="pydrake.multibody.meshcat.html" />
    <link rel="prev" title="pydrake.multibody.inverse_kinematics" href="pydrake.multibody.inverse_kinematics.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> pydrake
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search pydrake only…" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
  <form id="ddg-search-form" class="wy_form" action="https://duckduckgo.com/" method="get">
    <input type="text" name="q" placeholder="Search all of Drake…" />
    <input type="hidden" name="sites" value="drake.mit.edu" />
  </form>
</div>


          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="pydrake.all.html">pydrake.all</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.autodiffutils.html">pydrake.autodiffutils</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.common.html">pydrake.common</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.examples.html">pydrake.examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.forwarddiff.html">pydrake.forwarddiff</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.geometry.html">pydrake.geometry</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.lcm.html">pydrake.lcm</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.manipulation.html">pydrake.manipulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.math.html">pydrake.math</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="pydrake.multibody.html">pydrake.multibody</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="pydrake.multibody.all.html">pydrake.multibody.all</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.multibody.benchmarks.html">pydrake.multibody.benchmarks</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.multibody.inverse_kinematics.html">pydrake.multibody.inverse_kinematics</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">pydrake.multibody.math</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.multibody.meshcat.html">pydrake.multibody.meshcat</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.multibody.optimization.html">pydrake.multibody.optimization</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.multibody.parsing.html">pydrake.multibody.parsing</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.multibody.plant.html">pydrake.multibody.plant</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.multibody.tree.html">pydrake.multibody.tree</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.perception.html">pydrake.perception</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.polynomial.html">pydrake.polynomial</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.solvers.html">pydrake.solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.symbolic.html">pydrake.symbolic</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.systems.html">pydrake.systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.trajectories.html">pydrake.trajectories</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.tutorials.html">pydrake.tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.visualization.html">pydrake.visualization</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">pydrake</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
          <li><a href="pydrake.multibody.html">pydrake.multibody</a> &raquo;</li>
        
      <li>pydrake.multibody.math</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="module-pydrake.multibody.math">
<span id="pydrake-multibody-math"></span><h1>pydrake.multibody.math<a class="headerlink" href="#module-pydrake.multibody.math" title="Permalink to this headline">¶</a></h1>
<p>Bindings for multibody math.</p>
<dl class="attribute">
<dt id="pydrake.multibody.math.SpatialAcceleration">
<code class="descclassname">pydrake.multibody.math.</code><code class="descname">SpatialAcceleration</code><a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pydrake.multibody.math.SpatialAcceleration_[float]" title="pydrake.multibody.math.SpatialAcceleration_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.math.SpatialAcceleration_[float]</span></code></a></p>
</dd></dl>

<dl class="template">
<dt id="pydrake.multibody.math.SpatialAcceleration_">
<em class="property">template </em><code class="descclassname">pydrake.multibody.math.</code><code class="descname">SpatialAcceleration_</code><a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.multibody.math.SpatialAcceleration_[float]" title="pydrake.multibody.math.SpatialAcceleration_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">SpatialAcceleration_[float]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd]" title="pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">SpatialAcceleration_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.math.SpatialAcceleration_[Expression]" title="pydrake.multibody.math.SpatialAcceleration_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">SpatialAcceleration_[Expression]</span></code></a></p>
<dl class="class">
<dt id="pydrake.multibody.math.SpatialAcceleration_.SpatialAcceleration_[float]">
<em class="property">class </em><code class="descname">SpatialAcceleration_[float]</code><a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_.SpatialAcceleration_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>This class is used to represent a <em>spatial acceleration</em> that combines
rotational (angular acceleration) and translational (linear
acceleration) components. While a SpatialVelocity <code class="docutils literal notranslate"><span class="pre">V_XY</span></code> represents
the motion of a “moving frame” Y measured with respect to a
“measured-in” frame X, the SpatialAcceleration <code class="docutils literal notranslate"><span class="pre">A_XY</span></code> represents the
rate of change of this spatial velocity <code class="docutils literal notranslate"><span class="pre">V_XY</span></code> in frame X. That is
<span class="math notranslate nohighlight">\(^XA^Y = \frac{^Xd}{dt}\,{^XV^Y}\)</span> where <span class="math notranslate nohighlight">\(\frac{^Xd}{dt}\)</span>
denotes the time derivative taken in frame X. That is, to compute an
acceleration we need to specify in what frame the time derivative is
taken, see [Mitiguy 2016, §6.1] for a more in depth discussion on
this. Time derivatives can be taken in different frames, and they
transform according to the “Transport Theorem”, which in Drake is
implemented in drake::math::ConvertTimeDerivativeToOtherFrame(). In
source code comments we write <code class="docutils literal notranslate"><span class="pre">A_XY</span> <span class="pre">=</span> <span class="pre">DtX(V_XY)</span></code>, where <code class="docutils literal notranslate"><span class="pre">DtX()</span></code> is
the operator that takes the time derivative in the X frame. By
convention, and unless otherwise stated, we assume that the frame in
which the time derivative is taken is the “measured-in” frame, i.e.
the time derivative used in <code class="docutils literal notranslate"><span class="pre">A_XY</span></code> is in frame X by default (i.e.
DtX()). To perform numerical computations, we need to specify an
“expressed-in” frame E (which may be distinct from either X or Y), so
that components can be expressed as real numbers. Only the vector
values are stored in a SpatialAcceleration object; the frames must be
understood from context and it is the responsibility of the user to
keep track of them. That is best accomplished through disciplined
notation. In source code we use monogram notation where capital A is
used to designate a spatial acceleration quantity. The same monogram
notation rules for SpatialVelocity are also used for
SpatialAcceleration. That is, the spatial acceleration of a frame Y
measured in X and expressed in E is denoted with <code class="docutils literal notranslate"><span class="pre">A_XY_E</span></code>. For a
more detailed introduction on spatial vectors and the monogram
notation please refer to section multibody_spatial_vectors.</p>
<p>[Mitiguy 2016] Mitiguy, P., 2016. Advanced Dynamics &amp; Motion
Simulation.</p>
<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_.SpatialAcceleration_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_.SpatialAcceleration_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialAcceleration_[float]) -&gt; None</p>
<blockquote>
<div><p>Constructs to all NaNs.</p>
<dl class="docutils">
<dt>Note:</dt>
<dd><p class="first last">This is different from C++, which in Release builds may leave memory
uninitialized. In pydrake, the function call overhead already trumps
any overhead from NAN-initialization, so we err on the side of
safety.</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialAcceleration_[float], alpha: numpy.ndarray[numpy.float64[3, 1]], a: numpy.ndarray[numpy.float64[3, 1]]) -&gt; None</p>
</li>
</ol>
<p>SpatialAcceleration constructor from an angular acceleration <code class="docutils literal notranslate"><span class="pre">alpha</span></code>
and a linear acceleration <code class="docutils literal notranslate"><span class="pre">a</span></code>.</p>
<ol class="arabic simple" start="3">
<li>__init__(self: pydrake.multibody.math.SpatialAcceleration_[float], A: numpy.ndarray[numpy.float64[6, 1]]) -&gt; None</li>
</ol>
<p>SpatialAcceleration constructor from an Eigen expression that
represents a six-dimensional vector. Under the hood, spatial
accelerations are 6-element quantities that are pairs of ordinary
3-vectors. Elements 0-2 constitute the angular acceleration component
while elements 3-5 constitute the translational acceleration. The
argument <code class="docutils literal notranslate"><span class="pre">A</span></code> in this constructor is the concatenation of the
rotational 3D component followed by the translational 3D component.
This constructor will assert the size of <code class="docutils literal notranslate"><span class="pre">A</span></code> is six (6) at
compile-time for fixed sized Eigen expressions and at run-time for
dynamic sized Eigen expressions.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_.SpatialAcceleration_[float].ComposeWithMovingFrameAcceleration">
<code class="descname">ComposeWithMovingFrameAcceleration</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialAcceleration_[float], p_PB_E: numpy.ndarray[numpy.float64[3, 1]], w_WP_E: numpy.ndarray[numpy.float64[3, 1]], V_PB_E: pydrake.multibody.math.SpatialVelocity_[float], A_PB_E: pydrake.multibody.math.SpatialAcceleration_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialAcceleration_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_.SpatialAcceleration_[float].ComposeWithMovingFrameAcceleration" title="Permalink to this definition">¶</a></dt>
<dd><p>This method composes <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial acceleration <code class="docutils literal notranslate"><span class="pre">A_WP</span></code> of a frame
P measured in a frame W, with that of a third frame B moving in P with
spatial acceleration <code class="docutils literal notranslate"><span class="pre">A_PB</span></code>. The result is the spatial acceleration
<code class="docutils literal notranslate"><span class="pre">A_WB</span></code> of frame B measured in W. At the instant in which the
accelerations are composed, frame B is located with its origin Bo at
<code class="docutils literal notranslate"><span class="pre">p_PB</span></code> from P’s origin Po.</p>
<p>This operation can be written in a more compact form in terms of the
rigid shift operator <code class="docutils literal notranslate"><span class="pre">Φᵀ(p_PB)</span></code> (see SpatialVelocity::Shift()) as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">A_WB</span> <span class="o">=</span> <span class="n">Φᵀ</span><span class="p">(</span><span class="n">p_PB</span><span class="p">)</span> <span class="n">A_WP</span> <span class="o">+</span> <span class="n">Ac_WB</span><span class="p">(</span><span class="n">w_WP</span><span class="p">,</span> <span class="n">V_PB</span><span class="p">)</span> <span class="o">+</span> <span class="n">A_PB_W</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">Φᵀ(p_PB)</span> <span class="pre">A_WP</span></code> denotes the application of the rigid shift
operation as in SpatialVelocity::Shift() and <code class="docutils literal notranslate"><span class="pre">Ac_WB(w_WP,</span> <span class="pre">V_PB)</span></code>
contains the centrifugal and Coriolis terms:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Ac_WB</span><span class="p">(</span><span class="n">w_WP</span><span class="p">,</span> <span class="n">V_PB</span><span class="p">)</span> <span class="o">=</span> <span class="o">|</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">w_PB_W</span>                          <span class="o">|</span>
                      <span class="o">|</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">p_PB_W</span> <span class="o">+</span> <span class="mi">2</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">v_PB_W</span> <span class="o">|</span>
                                  <span class="o">^^^</span>                <span class="o">^^^</span>
                              <span class="n">centrifugal</span>         <span class="n">Coriolis</span>
</pre></div>
</div>
<p>The equation above shows that composing spatial accelerations cannot
be simply accomplished by adding <code class="docutils literal notranslate"><span class="pre">A_WP</span></code> with <code class="docutils literal notranslate"><span class="pre">A_PB</span></code>. Moreover, we
see that, unlike with angular velocities, angular accelerations cannot
be added in order to compose them. That is <code class="docutils literal notranslate"><span class="pre">w_AC</span> <span class="pre">=</span> <span class="pre">w_AB</span> <span class="pre">+</span> <span class="pre">w_BC</span></code> but
<code class="docutils literal notranslate"><span class="pre">alpha_AC</span> <span class="pre">≠</span> <span class="pre">alpha_AB</span> <span class="pre">+</span> <span class="pre">alpha_BC</span></code> due to the cross term <code class="docutils literal notranslate"><span class="pre">w_AC</span> <span class="pre">x</span>
<span class="pre">w_BC</span></code>. See the derivation below for more details.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">SpatialVelocity::ComposeWithMovingFrameVelocity() for the
composition of SpatialVelocity quantities.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This method is the extension to the Shift() operator, which
computes the spatial acceleration frame P shifted to B as if frame
B moved rigidly with P, that is, for when <code class="docutils literal notranslate"><span class="pre">V_PB</span></code> and <code class="docutils literal notranslate"><span class="pre">A_PB</span></code>
are both zero. In other words the results from Shift() equal the
results from this method when <code class="docutils literal notranslate"><span class="pre">V_PB</span></code> and <code class="docutils literal notranslate"><span class="pre">A_PB</span></code> are both zero.</p>
</div>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_PB_E</span></code>:</dt>
<dd>Shift vector from P’s origin to B’s origin, expressed in frame E.
The “from” point <code class="docutils literal notranslate"><span class="pre">Po</span></code> must be the point whose acceleration is
currently represented in <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial acceleration, and E must
be the same expressed-in frame as for <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial
acceleration.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">w_WP_E</span></code>:</dt>
<dd>Angular velocity of frame P measured in frame W and expressed in
frame E.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">V_PB_E</span></code>:</dt>
<dd>The spatial velocity of a third frame B in motion with respect to
P, expressed in the same frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial acceleration.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">A_PB_E</span></code>:</dt>
<dd>The spatial acceleration of a third frame B in motion with respect
to P, expressed in the same frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial
acceleration.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">A_WB_E</span></code>:</dt>
<dd>The spatial acceleration of frame B in W, expressed in frame E.</dd>
</dl>
<p>** Derivation **</p>
<p>The spatial velocity of frame B in W can be obtained by composing
<code class="docutils literal notranslate"><span class="pre">V_WP</span></code> with <code class="docutils literal notranslate"><span class="pre">V_PB</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">V_WB</span> <span class="o">=</span> <span class="n">V_WPb</span> <span class="o">+</span> <span class="n">V_PB</span> <span class="o">=</span> <span class="n">Φᵀ</span><span class="p">(</span><span class="n">p_PB</span><span class="p">)</span> <span class="n">V_WP</span> <span class="o">+</span> <span class="n">V_PB</span>                        <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>This operation can be performed with the method
SpatialVelocity::ComposeWithMovingFrameVelocity().</p>
<ul class="simple">
<li>Translational acceleration component *</li>
</ul>
<p>The translational velocity <code class="docutils literal notranslate"><span class="pre">v_WB</span></code> of point B in W corresponds to the
translational component in Eq. (1):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">v_WB</span> <span class="o">=</span> <span class="n">v_WP</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">p_PB</span> <span class="o">+</span> <span class="n">v_PB</span>                                  <span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>Therefore, for the translational acceleration we have:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a_WB</span> <span class="o">=</span> <span class="n">DtW</span><span class="p">(</span><span class="n">v_WB</span><span class="p">)</span>
        <span class="o">=</span> <span class="n">DtW</span><span class="p">(</span><span class="n">v_WP</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">p_PB</span> <span class="o">+</span> <span class="n">v_PB</span><span class="p">)</span>
        <span class="o">=</span> <span class="n">DtW</span><span class="p">(</span><span class="n">v_WP</span><span class="p">)</span> <span class="o">+</span> <span class="n">DtW</span><span class="p">(</span><span class="n">w_WP</span> <span class="n">x</span> <span class="n">p_PB</span><span class="p">)</span> <span class="o">+</span> <span class="n">DtW</span><span class="p">(</span><span class="n">v_PB</span><span class="p">)</span>
        <span class="o">=</span> <span class="n">a_WP</span> <span class="o">+</span> <span class="n">DtW</span><span class="p">(</span><span class="n">w_WP</span><span class="p">)</span> <span class="n">x</span> <span class="n">p_PB</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">DtW</span><span class="p">(</span><span class="n">p_PB</span><span class="p">)</span> <span class="o">+</span> <span class="n">DtW</span><span class="p">(</span><span class="n">v_PB</span><span class="p">)</span>
        <span class="o">=</span> <span class="n">a_WP</span> <span class="o">+</span> <span class="n">alpha_WP</span> <span class="n">x</span> <span class="n">p_PB</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">DtW</span><span class="p">(</span><span class="n">p_PB</span><span class="p">)</span> <span class="o">+</span> <span class="n">DtW</span><span class="p">(</span><span class="n">v_PB</span><span class="p">)</span>     <span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>with <code class="docutils literal notranslate"><span class="pre">a_WP</span> <span class="pre">=</span> <span class="pre">DtW(v_WP)</span></code> and <code class="docutils literal notranslate"><span class="pre">alpha_WP</span> <span class="pre">=</span> <span class="pre">DtW(w_WP)</span></code> by definition.
The term DtW(p_PB) in Eq. (3) is obtained by converting the vector
time derivative from <code class="docutils literal notranslate"><span class="pre">DtW()</span></code> to <code class="docutils literal notranslate"><span class="pre">DtP()</span></code>, see
drake::math::ConvertTimeDerivativeToOtherFrame():</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">DtW</span><span class="p">(</span><span class="n">p_PB</span><span class="p">)</span> <span class="o">=</span> <span class="n">DtP</span><span class="p">(</span><span class="n">p_PB</span><span class="p">)</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">p_PB</span>
            <span class="o">=</span> <span class="n">v_PB</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">p_PB</span>                                    <span class="p">(</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
<p>since <code class="docutils literal notranslate"><span class="pre">v_PB</span> <span class="pre">=</span> <span class="pre">DtP(p_PB)</span></code> by definition. Similarly, the term
<code class="docutils literal notranslate"><span class="pre">DtW(v_PB)</span></code> in Eq. (3) is also obtained by converting the time
derivative from <code class="docutils literal notranslate"><span class="pre">DtW()</span></code> to <code class="docutils literal notranslate"><span class="pre">DtP()</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">DtW</span><span class="p">(</span><span class="n">v_PB</span><span class="p">)</span> <span class="o">=</span> <span class="n">DtP</span><span class="p">(</span><span class="n">v_PB</span><span class="p">)</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">v_PB</span>
            <span class="o">=</span> <span class="n">a_PB</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">v_PB</span>                                    <span class="p">(</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<p>with <code class="docutils literal notranslate"><span class="pre">a_PB</span> <span class="pre">=</span> <span class="pre">DtP(v_PB)</span></code> by definition. Using Eqs. (4) and (5) in Eq.
(3) yields for the translational acceleration:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a_WB</span> <span class="o">=</span> <span class="n">a_WP</span> <span class="o">+</span> <span class="n">alpha_WP</span> <span class="n">x</span> <span class="n">p_PB</span> <span class="o">+</span> <span class="n">a_PB</span> <span class="o">+</span> <span class="n">ac_WB</span>
  <span class="n">ac_WB</span> <span class="o">=</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="p">(</span><span class="n">v_PB</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">p_PB</span><span class="p">)</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">v_PB</span>                 <span class="p">(</span><span class="mi">6</span><span class="p">)</span>
</pre></div>
</div>
<p>where finally the term <code class="docutils literal notranslate"><span class="pre">ac_WB</span></code> can be written as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ac_WB</span> <span class="o">=</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">p_PB</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">v_PB</span>                      <span class="p">(</span><span class="mi">7</span><span class="p">)</span>
</pre></div>
</div>
<p>which includes the effect of angular acceleration of P in W <code class="docutils literal notranslate"><span class="pre">alpha_WP</span>
<span class="pre">x</span> <span class="pre">p_PB</span></code>, the centrifugal acceleration <code class="docutils literal notranslate"><span class="pre">w_WP</span> <span class="pre">x</span> <span class="pre">w_WP</span> <span class="pre">x</span> <span class="pre">p_PB</span></code>, the
Coriolis acceleration <code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">*</span> <span class="pre">w_WP</span> <span class="pre">x</span> <span class="pre">v_PB</span></code> due to the motion of B in P
and, the additional acceleration of B in P <code class="docutils literal notranslate"><span class="pre">a_PB</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Alternatively, we can write an efficient version of the
centrifugal term <code class="docutils literal notranslate"><span class="pre">ac_WB</span></code> in Eq. (6) for when the velocities of P
and B are available (e.g. from velocity kinematics). This is
accomplished by adding and subtracting v_WP within the
parenthesized term in Eq. (6) and grouping together v_WB = v_WPb +
v_PB = v_WP + w_WP x p_PB + v_PB:</p>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ac_WB</span> <span class="o">=</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="p">(</span><span class="n">v_WB</span> <span class="o">-</span> <span class="n">v_WP</span><span class="p">)</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">v_PB</span>
        <span class="o">=</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="p">(</span><span class="n">v_WB</span> <span class="o">-</span> <span class="n">v_WP</span> <span class="o">+</span> <span class="n">v_PB</span><span class="p">)</span>                               <span class="p">(</span><span class="mi">6</span><span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>which simplifies the expression from three cross products to one.</p>
<ul class="simple">
<li>Rotational acceleration component *</li>
</ul>
<p>The rotational velocity <code class="docutils literal notranslate"><span class="pre">w_WB</span></code> of frame B in W corresponds to the
rotational component in Eq. (1):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">w_WB</span> <span class="o">=</span> <span class="n">w_WP</span> <span class="o">+</span> <span class="n">w_PB</span>                                                <span class="p">(</span><span class="mi">8</span><span class="p">)</span>
</pre></div>
</div>
<p>Therefore, the rotational acceleration of B in W corresponds to:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">alpha_WB</span> <span class="o">=</span> <span class="n">DtW</span><span class="p">(</span><span class="n">w_WB</span><span class="p">)</span> <span class="o">=</span> <span class="n">DtW</span><span class="p">(</span><span class="n">w_WP</span><span class="p">)</span> <span class="o">+</span> <span class="n">DtW</span><span class="p">(</span><span class="n">w_PB</span><span class="p">)</span>
           <span class="o">=</span> <span class="n">alpha_WP</span> <span class="o">+</span> <span class="n">DtW</span><span class="p">(</span><span class="n">w_PB</span><span class="p">)</span>                                   <span class="p">(</span><span class="mi">9</span><span class="p">)</span>
</pre></div>
</div>
<p>where the last term in Eq. (9) can be converted to a time derivative
in P as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">DtW</span><span class="p">(</span><span class="n">w_PB</span><span class="p">)</span> <span class="o">=</span> <span class="n">DtP</span><span class="p">(</span><span class="n">w_PB</span><span class="p">)</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">w_PB</span> <span class="o">=</span> <span class="n">alpha_PB</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">w_PB</span>      <span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">alpha_PB</span> <span class="pre">=</span> <span class="pre">DtP(w_PB)</span></code> by definition. Thus, the final
expression for <code class="docutils literal notranslate"><span class="pre">alpha_WB</span></code> is obtained by using Eq. (10) into Eq.
(9):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">alpha_WB</span> <span class="o">=</span> <span class="n">alpha_WP</span> <span class="o">+</span> <span class="n">alpha_PB</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">w_PB</span>                      <span class="p">(</span><span class="mi">11</span><span class="p">)</span>
</pre></div>
</div>
<p>Equation (11) shows that angular accelerations cannot be simply added
as angular velocities can but there exists an additional term <code class="docutils literal notranslate"><span class="pre">w_WP</span> <span class="pre">x</span>
<span class="pre">w_PB</span></code>.</p>
<ul class="simple">
<li>The spatial acceleration *</li>
</ul>
<p>The rotational and translational components of the spatial
acceleration are given by Eqs. (11) and (6) respectively:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">A_WB</span><span class="o">.</span><span class="n">rotational</span><span class="p">()</span> <span class="o">=</span> <span class="n">alpha_WB</span>
                    <span class="o">=</span> <span class="p">{</span><span class="n">alpha_WP</span><span class="p">}</span> <span class="o">+</span> <span class="n">alpha_PB</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">w_PB</span>           <span class="p">(</span><span class="mi">12</span><span class="p">)</span>
  <span class="n">A_WB</span><span class="o">.</span><span class="n">translational</span><span class="p">()</span> <span class="o">=</span> <span class="n">a_WB</span>
                       <span class="o">=</span> <span class="p">{</span><span class="n">a_WP</span> <span class="o">+</span> <span class="n">alpha_WP</span> <span class="n">x</span> <span class="n">p_PB</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">p_PB</span><span class="p">}</span>
                       <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">v_PB</span> <span class="o">+</span> <span class="n">a_PB</span>                     <span class="p">(</span><span class="mi">13</span><span class="p">)</span>
</pre></div>
</div>
<p>where we have placed within curly brackets <code class="docutils literal notranslate"><span class="pre">{}</span></code> all the terms that
also appear in the Shift() operation, which is equivalent to this
method when <code class="docutils literal notranslate"><span class="pre">V_PB</span></code> and <code class="docutils literal notranslate"><span class="pre">A_PB</span></code> are both zero. In the equations
above <code class="docutils literal notranslate"><span class="pre">alpha_WP</span> <span class="pre">=</span> <span class="pre">A_WP.rotational()</span></code> and <code class="docutils literal notranslate"><span class="pre">a_WP</span> <span class="pre">=</span>
<span class="pre">A_WP.translational()</span></code>. The above expression can be written in a more
compact form in terms of the rigid shift operator <code class="docutils literal notranslate"><span class="pre">Φᵀ(p_PB)</span></code> (see
SpatialVelocity::Shift()) as presented in the main body of this
documentation:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">A_WB</span> <span class="o">=</span> <span class="n">Φᵀ</span><span class="p">(</span><span class="n">p_PB</span><span class="p">)</span><span class="n">A_WP</span> <span class="o">+</span> <span class="n">Ac_WB</span><span class="p">(</span><span class="n">w_WP</span><span class="p">,</span> <span class="n">V_PB</span><span class="p">)</span> <span class="o">+</span> <span class="n">A_PB_W</span>                  <span class="p">(</span><span class="mi">14</span><span class="p">)</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">Ac_WB(w_WP,</span> <span class="pre">V_PB)</span></code> contains the centrifugal and Coriolis
terms:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Ac_WB</span><span class="p">(</span><span class="n">w_WP</span><span class="p">,</span> <span class="n">V_PB</span><span class="p">)</span> <span class="o">=</span> <span class="o">|</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">w_PB_W</span>                          <span class="o">|</span>
                      <span class="o">|</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">p_PB_W</span> <span class="o">+</span> <span class="mi">2</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">v_PB_W</span> <span class="o">|</span>
                                  <span class="o">^^^</span>                <span class="o">^^^</span>
                              <span class="n">centrifugal</span>         <span class="n">Coriolis</span>
</pre></div>
</div>
<p>As usual, for computation, all quantities above must be expressed in a
common frame E; we add an <code class="docutils literal notranslate"><span class="pre">_E</span></code> suffix to each symbol to indicate
that.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_.SpatialAcceleration_[float].get_coeffs">
<code class="descname">get_coeffs</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialAcceleration_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[6, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_.SpatialAcceleration_[float].get_coeffs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to the underlying storage.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_.SpatialAcceleration_[float].Rotate">
<code class="descname">Rotate</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialAcceleration_[float], R_FE: pydrake.math.RotationMatrix_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialAcceleration_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_.SpatialAcceleration_[float].Rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides a Python-only implementation of rotating / re-expressing a
spatial vector.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is done because defining <code class="docutils literal notranslate"><span class="pre">__rmatmul__</span></code> on this class does
not disambiguate against the definitions of
<code class="docutils literal notranslate"><span class="pre">RotationMatrix.__matmul__</span></code>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_.SpatialAcceleration_[float].rotational">
<code class="descname">rotational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialAcceleration_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_.SpatialAcceleration_[float].rotational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the rotational component of this spatial vector.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_.SpatialAcceleration_[float].SetZero">
<code class="descname">SetZero</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialAcceleration_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialAcceleration_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_.SpatialAcceleration_[float].SetZero" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets both rotational and translational components of <code class="docutils literal notranslate"><span class="pre">this</span></code>
SpatialVector to zero.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_.SpatialAcceleration_[float].Shift">
<code class="descname">Shift</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_.SpatialAcceleration_[float].Shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>Shift(self: pydrake.multibody.math.SpatialAcceleration_[float], p_PoQ_E: numpy.ndarray[numpy.float64[3, 1]], w_WP_E: numpy.ndarray[numpy.float64[3, 1]]) -&gt; pydrake.multibody.math.SpatialAcceleration_[float]</li>
</ol>
<p>Shifts <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial acceleration <code class="docutils literal notranslate"><span class="pre">A_WP</span></code> of a frame P into the
spatial acceleration <code class="docutils literal notranslate"><span class="pre">A_WPq</span></code> of a frame <code class="docutils literal notranslate"><span class="pre">Pq</span></code> which is an offset
frame rigidly aligned with P, but with its origin shifted to a point Q
by an offset p_PoQ. Frame <code class="docutils literal notranslate"><span class="pre">Pq</span></code> is instantaneously moving together
with frame P as if rigidly attached to it. As an example of
application, this operation can be used to compute <code class="docutils literal notranslate"><span class="pre">A_WPq</span></code> where P
is a frame on a rigid body and Q is another point on that same body.
Therefore P and <code class="docutils literal notranslate"><span class="pre">Pq</span></code> move together with the spatial velocity
<code class="docutils literal notranslate"><span class="pre">V_PPq</span></code> being zero at all times. This is an alternate signature for
shifting a spatial acceleration that does not change the original
object. See ShiftInPlace() for more information and a description of
the arguments.</p>
<ol class="arabic simple" start="2">
<li>Shift(self: pydrake.multibody.math.SpatialAcceleration_[float], p_PoQ_E: numpy.ndarray[numpy.float64[3, 1]]) -&gt; pydrake.multibody.math.SpatialAcceleration_[float]</li>
</ol>
<p>(Advanced) Given <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial acceleration <code class="docutils literal notranslate"><span class="pre">A_WP</span></code> of a frame P
in a second frame W, this operation is only valid when the angular
velocity <code class="docutils literal notranslate"><span class="pre">w_WP</span></code> of P in W is zero. Refer to Shift(const Vector3&lt;T&gt;&amp;,
const Vector3&lt;T&gt;&amp;) for the full version that includes velocity terms.
This method can be used to avoid unnecessary computation when shifting
<code class="docutils literal notranslate"><span class="pre">this</span></code> spatial acceleration of a frame P into the spatial
acceleration of the shifted frame <code class="docutils literal notranslate"><span class="pre">Pq</span></code>. The shift position vector is
given by <code class="docutils literal notranslate"><span class="pre">p_PoQ_E</span></code>, expresssed in the same frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code>
spatial` acceleration. Mathematically, this returns <code class="docutils literal notranslate"><span class="pre">A_WPq</span> <span class="pre">=</span>
<span class="pre">Φᵀ(p_PoQ)A_WP</span></code>, where <code class="docutils literal notranslate"><span class="pre">Φ(p_PoQ)</span></code> is the rigid shift operator, see
SpatialVelocity::Shift().</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_.SpatialAcceleration_[float].translational">
<code class="descname">translational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialAcceleration_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_.SpatialAcceleration_[float].translational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the translational component of this spatial vector.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.math.SpatialAcceleration_.SpatialAcceleration_[float].Zero">
<em class="property">static </em><code class="descname">Zero</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialAcceleration_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_.SpatialAcceleration_[float].Zero" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory to create a <em>zero</em> SpatialVector, i.e. rotational and
translational components are both zero.</p>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.math.</code><code class="descname">SpatialAcceleration_[AutoDiffXd]</code><a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd]" title="Permalink to this definition">¶</a></dt>
<dd><p>This class is used to represent a <em>spatial acceleration</em> that combines
rotational (angular acceleration) and translational (linear
acceleration) components. While a SpatialVelocity <code class="docutils literal notranslate"><span class="pre">V_XY</span></code> represents
the motion of a “moving frame” Y measured with respect to a
“measured-in” frame X, the SpatialAcceleration <code class="docutils literal notranslate"><span class="pre">A_XY</span></code> represents the
rate of change of this spatial velocity <code class="docutils literal notranslate"><span class="pre">V_XY</span></code> in frame X. That is
<span class="math notranslate nohighlight">\(^XA^Y = \frac{^Xd}{dt}\,{^XV^Y}\)</span> where <span class="math notranslate nohighlight">\(\frac{^Xd}{dt}\)</span>
denotes the time derivative taken in frame X. That is, to compute an
acceleration we need to specify in what frame the time derivative is
taken, see [Mitiguy 2016, §6.1] for a more in depth discussion on
this. Time derivatives can be taken in different frames, and they
transform according to the “Transport Theorem”, which in Drake is
implemented in drake::math::ConvertTimeDerivativeToOtherFrame(). In
source code comments we write <code class="docutils literal notranslate"><span class="pre">A_XY</span> <span class="pre">=</span> <span class="pre">DtX(V_XY)</span></code>, where <code class="docutils literal notranslate"><span class="pre">DtX()</span></code> is
the operator that takes the time derivative in the X frame. By
convention, and unless otherwise stated, we assume that the frame in
which the time derivative is taken is the “measured-in” frame, i.e.
the time derivative used in <code class="docutils literal notranslate"><span class="pre">A_XY</span></code> is in frame X by default (i.e.
DtX()). To perform numerical computations, we need to specify an
“expressed-in” frame E (which may be distinct from either X or Y), so
that components can be expressed as real numbers. Only the vector
values are stored in a SpatialAcceleration object; the frames must be
understood from context and it is the responsibility of the user to
keep track of them. That is best accomplished through disciplined
notation. In source code we use monogram notation where capital A is
used to designate a spatial acceleration quantity. The same monogram
notation rules for SpatialVelocity are also used for
SpatialAcceleration. That is, the spatial acceleration of a frame Y
measured in X and expressed in E is denoted with <code class="docutils literal notranslate"><span class="pre">A_XY_E</span></code>. For a
more detailed introduction on spatial vectors and the monogram
notation please refer to section multibody_spatial_vectors.</p>
<p>[Mitiguy 2016] Mitiguy, P., 2016. Advanced Dynamics &amp; Motion
Simulation.</p>
<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd]) -&gt; None</p>
<blockquote>
<div><p>Constructs to all NaNs.</p>
<dl class="docutils">
<dt>Note:</dt>
<dd><p class="first last">This is different from C++, which in Release builds may leave memory
uninitialized. In pydrake, the function call overhead already trumps
any overhead from NAN-initialization, so we err on the side of
safety.</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd], alpha: numpy.ndarray[object[3, 1]], a: numpy.ndarray[object[3, 1]]) -&gt; None</p>
</li>
</ol>
<p>SpatialAcceleration constructor from an angular acceleration <code class="docutils literal notranslate"><span class="pre">alpha</span></code>
and a linear acceleration <code class="docutils literal notranslate"><span class="pre">a</span></code>.</p>
<ol class="arabic simple" start="3">
<li>__init__(self: pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd], A: numpy.ndarray[object[6, 1]]) -&gt; None</li>
</ol>
<p>SpatialAcceleration constructor from an Eigen expression that
represents a six-dimensional vector. Under the hood, spatial
accelerations are 6-element quantities that are pairs of ordinary
3-vectors. Elements 0-2 constitute the angular acceleration component
while elements 3-5 constitute the translational acceleration. The
argument <code class="docutils literal notranslate"><span class="pre">A</span></code> in this constructor is the concatenation of the
rotational 3D component followed by the translational 3D component.
This constructor will assert the size of <code class="docutils literal notranslate"><span class="pre">A</span></code> is six (6) at
compile-time for fixed sized Eigen expressions and at run-time for
dynamic sized Eigen expressions.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd].ComposeWithMovingFrameAcceleration">
<code class="descname">ComposeWithMovingFrameAcceleration</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd], p_PB_E: numpy.ndarray[object[3, 1]], w_WP_E: numpy.ndarray[object[3, 1]], V_PB_E: pydrake.multibody.math.SpatialVelocity_[AutoDiffXd], A_PB_E: pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd].ComposeWithMovingFrameAcceleration" title="Permalink to this definition">¶</a></dt>
<dd><p>This method composes <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial acceleration <code class="docutils literal notranslate"><span class="pre">A_WP</span></code> of a frame
P measured in a frame W, with that of a third frame B moving in P with
spatial acceleration <code class="docutils literal notranslate"><span class="pre">A_PB</span></code>. The result is the spatial acceleration
<code class="docutils literal notranslate"><span class="pre">A_WB</span></code> of frame B measured in W. At the instant in which the
accelerations are composed, frame B is located with its origin Bo at
<code class="docutils literal notranslate"><span class="pre">p_PB</span></code> from P’s origin Po.</p>
<p>This operation can be written in a more compact form in terms of the
rigid shift operator <code class="docutils literal notranslate"><span class="pre">Φᵀ(p_PB)</span></code> (see SpatialVelocity::Shift()) as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">A_WB</span> <span class="o">=</span> <span class="n">Φᵀ</span><span class="p">(</span><span class="n">p_PB</span><span class="p">)</span> <span class="n">A_WP</span> <span class="o">+</span> <span class="n">Ac_WB</span><span class="p">(</span><span class="n">w_WP</span><span class="p">,</span> <span class="n">V_PB</span><span class="p">)</span> <span class="o">+</span> <span class="n">A_PB_W</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">Φᵀ(p_PB)</span> <span class="pre">A_WP</span></code> denotes the application of the rigid shift
operation as in SpatialVelocity::Shift() and <code class="docutils literal notranslate"><span class="pre">Ac_WB(w_WP,</span> <span class="pre">V_PB)</span></code>
contains the centrifugal and Coriolis terms:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Ac_WB</span><span class="p">(</span><span class="n">w_WP</span><span class="p">,</span> <span class="n">V_PB</span><span class="p">)</span> <span class="o">=</span> <span class="o">|</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">w_PB_W</span>                          <span class="o">|</span>
                      <span class="o">|</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">p_PB_W</span> <span class="o">+</span> <span class="mi">2</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">v_PB_W</span> <span class="o">|</span>
                                  <span class="o">^^^</span>                <span class="o">^^^</span>
                              <span class="n">centrifugal</span>         <span class="n">Coriolis</span>
</pre></div>
</div>
<p>The equation above shows that composing spatial accelerations cannot
be simply accomplished by adding <code class="docutils literal notranslate"><span class="pre">A_WP</span></code> with <code class="docutils literal notranslate"><span class="pre">A_PB</span></code>. Moreover, we
see that, unlike with angular velocities, angular accelerations cannot
be added in order to compose them. That is <code class="docutils literal notranslate"><span class="pre">w_AC</span> <span class="pre">=</span> <span class="pre">w_AB</span> <span class="pre">+</span> <span class="pre">w_BC</span></code> but
<code class="docutils literal notranslate"><span class="pre">alpha_AC</span> <span class="pre">≠</span> <span class="pre">alpha_AB</span> <span class="pre">+</span> <span class="pre">alpha_BC</span></code> due to the cross term <code class="docutils literal notranslate"><span class="pre">w_AC</span> <span class="pre">x</span>
<span class="pre">w_BC</span></code>. See the derivation below for more details.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">SpatialVelocity::ComposeWithMovingFrameVelocity() for the
composition of SpatialVelocity quantities.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This method is the extension to the Shift() operator, which
computes the spatial acceleration frame P shifted to B as if frame
B moved rigidly with P, that is, for when <code class="docutils literal notranslate"><span class="pre">V_PB</span></code> and <code class="docutils literal notranslate"><span class="pre">A_PB</span></code>
are both zero. In other words the results from Shift() equal the
results from this method when <code class="docutils literal notranslate"><span class="pre">V_PB</span></code> and <code class="docutils literal notranslate"><span class="pre">A_PB</span></code> are both zero.</p>
</div>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_PB_E</span></code>:</dt>
<dd>Shift vector from P’s origin to B’s origin, expressed in frame E.
The “from” point <code class="docutils literal notranslate"><span class="pre">Po</span></code> must be the point whose acceleration is
currently represented in <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial acceleration, and E must
be the same expressed-in frame as for <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial
acceleration.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">w_WP_E</span></code>:</dt>
<dd>Angular velocity of frame P measured in frame W and expressed in
frame E.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">V_PB_E</span></code>:</dt>
<dd>The spatial velocity of a third frame B in motion with respect to
P, expressed in the same frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial acceleration.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">A_PB_E</span></code>:</dt>
<dd>The spatial acceleration of a third frame B in motion with respect
to P, expressed in the same frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial
acceleration.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">A_WB_E</span></code>:</dt>
<dd>The spatial acceleration of frame B in W, expressed in frame E.</dd>
</dl>
<p>** Derivation **</p>
<p>The spatial velocity of frame B in W can be obtained by composing
<code class="docutils literal notranslate"><span class="pre">V_WP</span></code> with <code class="docutils literal notranslate"><span class="pre">V_PB</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">V_WB</span> <span class="o">=</span> <span class="n">V_WPb</span> <span class="o">+</span> <span class="n">V_PB</span> <span class="o">=</span> <span class="n">Φᵀ</span><span class="p">(</span><span class="n">p_PB</span><span class="p">)</span> <span class="n">V_WP</span> <span class="o">+</span> <span class="n">V_PB</span>                        <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>This operation can be performed with the method
SpatialVelocity::ComposeWithMovingFrameVelocity().</p>
<ul class="simple">
<li>Translational acceleration component *</li>
</ul>
<p>The translational velocity <code class="docutils literal notranslate"><span class="pre">v_WB</span></code> of point B in W corresponds to the
translational component in Eq. (1):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">v_WB</span> <span class="o">=</span> <span class="n">v_WP</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">p_PB</span> <span class="o">+</span> <span class="n">v_PB</span>                                  <span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>Therefore, for the translational acceleration we have:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a_WB</span> <span class="o">=</span> <span class="n">DtW</span><span class="p">(</span><span class="n">v_WB</span><span class="p">)</span>
        <span class="o">=</span> <span class="n">DtW</span><span class="p">(</span><span class="n">v_WP</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">p_PB</span> <span class="o">+</span> <span class="n">v_PB</span><span class="p">)</span>
        <span class="o">=</span> <span class="n">DtW</span><span class="p">(</span><span class="n">v_WP</span><span class="p">)</span> <span class="o">+</span> <span class="n">DtW</span><span class="p">(</span><span class="n">w_WP</span> <span class="n">x</span> <span class="n">p_PB</span><span class="p">)</span> <span class="o">+</span> <span class="n">DtW</span><span class="p">(</span><span class="n">v_PB</span><span class="p">)</span>
        <span class="o">=</span> <span class="n">a_WP</span> <span class="o">+</span> <span class="n">DtW</span><span class="p">(</span><span class="n">w_WP</span><span class="p">)</span> <span class="n">x</span> <span class="n">p_PB</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">DtW</span><span class="p">(</span><span class="n">p_PB</span><span class="p">)</span> <span class="o">+</span> <span class="n">DtW</span><span class="p">(</span><span class="n">v_PB</span><span class="p">)</span>
        <span class="o">=</span> <span class="n">a_WP</span> <span class="o">+</span> <span class="n">alpha_WP</span> <span class="n">x</span> <span class="n">p_PB</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">DtW</span><span class="p">(</span><span class="n">p_PB</span><span class="p">)</span> <span class="o">+</span> <span class="n">DtW</span><span class="p">(</span><span class="n">v_PB</span><span class="p">)</span>     <span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>with <code class="docutils literal notranslate"><span class="pre">a_WP</span> <span class="pre">=</span> <span class="pre">DtW(v_WP)</span></code> and <code class="docutils literal notranslate"><span class="pre">alpha_WP</span> <span class="pre">=</span> <span class="pre">DtW(w_WP)</span></code> by definition.
The term DtW(p_PB) in Eq. (3) is obtained by converting the vector
time derivative from <code class="docutils literal notranslate"><span class="pre">DtW()</span></code> to <code class="docutils literal notranslate"><span class="pre">DtP()</span></code>, see
drake::math::ConvertTimeDerivativeToOtherFrame():</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">DtW</span><span class="p">(</span><span class="n">p_PB</span><span class="p">)</span> <span class="o">=</span> <span class="n">DtP</span><span class="p">(</span><span class="n">p_PB</span><span class="p">)</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">p_PB</span>
            <span class="o">=</span> <span class="n">v_PB</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">p_PB</span>                                    <span class="p">(</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
<p>since <code class="docutils literal notranslate"><span class="pre">v_PB</span> <span class="pre">=</span> <span class="pre">DtP(p_PB)</span></code> by definition. Similarly, the term
<code class="docutils literal notranslate"><span class="pre">DtW(v_PB)</span></code> in Eq. (3) is also obtained by converting the time
derivative from <code class="docutils literal notranslate"><span class="pre">DtW()</span></code> to <code class="docutils literal notranslate"><span class="pre">DtP()</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">DtW</span><span class="p">(</span><span class="n">v_PB</span><span class="p">)</span> <span class="o">=</span> <span class="n">DtP</span><span class="p">(</span><span class="n">v_PB</span><span class="p">)</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">v_PB</span>
            <span class="o">=</span> <span class="n">a_PB</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">v_PB</span>                                    <span class="p">(</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<p>with <code class="docutils literal notranslate"><span class="pre">a_PB</span> <span class="pre">=</span> <span class="pre">DtP(v_PB)</span></code> by definition. Using Eqs. (4) and (5) in Eq.
(3) yields for the translational acceleration:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a_WB</span> <span class="o">=</span> <span class="n">a_WP</span> <span class="o">+</span> <span class="n">alpha_WP</span> <span class="n">x</span> <span class="n">p_PB</span> <span class="o">+</span> <span class="n">a_PB</span> <span class="o">+</span> <span class="n">ac_WB</span>
  <span class="n">ac_WB</span> <span class="o">=</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="p">(</span><span class="n">v_PB</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">p_PB</span><span class="p">)</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">v_PB</span>                 <span class="p">(</span><span class="mi">6</span><span class="p">)</span>
</pre></div>
</div>
<p>where finally the term <code class="docutils literal notranslate"><span class="pre">ac_WB</span></code> can be written as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ac_WB</span> <span class="o">=</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">p_PB</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">v_PB</span>                      <span class="p">(</span><span class="mi">7</span><span class="p">)</span>
</pre></div>
</div>
<p>which includes the effect of angular acceleration of P in W <code class="docutils literal notranslate"><span class="pre">alpha_WP</span>
<span class="pre">x</span> <span class="pre">p_PB</span></code>, the centrifugal acceleration <code class="docutils literal notranslate"><span class="pre">w_WP</span> <span class="pre">x</span> <span class="pre">w_WP</span> <span class="pre">x</span> <span class="pre">p_PB</span></code>, the
Coriolis acceleration <code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">*</span> <span class="pre">w_WP</span> <span class="pre">x</span> <span class="pre">v_PB</span></code> due to the motion of B in P
and, the additional acceleration of B in P <code class="docutils literal notranslate"><span class="pre">a_PB</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Alternatively, we can write an efficient version of the
centrifugal term <code class="docutils literal notranslate"><span class="pre">ac_WB</span></code> in Eq. (6) for when the velocities of P
and B are available (e.g. from velocity kinematics). This is
accomplished by adding and subtracting v_WP within the
parenthesized term in Eq. (6) and grouping together v_WB = v_WPb +
v_PB = v_WP + w_WP x p_PB + v_PB:</p>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ac_WB</span> <span class="o">=</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="p">(</span><span class="n">v_WB</span> <span class="o">-</span> <span class="n">v_WP</span><span class="p">)</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">v_PB</span>
        <span class="o">=</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="p">(</span><span class="n">v_WB</span> <span class="o">-</span> <span class="n">v_WP</span> <span class="o">+</span> <span class="n">v_PB</span><span class="p">)</span>                               <span class="p">(</span><span class="mi">6</span><span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>which simplifies the expression from three cross products to one.</p>
<ul class="simple">
<li>Rotational acceleration component *</li>
</ul>
<p>The rotational velocity <code class="docutils literal notranslate"><span class="pre">w_WB</span></code> of frame B in W corresponds to the
rotational component in Eq. (1):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">w_WB</span> <span class="o">=</span> <span class="n">w_WP</span> <span class="o">+</span> <span class="n">w_PB</span>                                                <span class="p">(</span><span class="mi">8</span><span class="p">)</span>
</pre></div>
</div>
<p>Therefore, the rotational acceleration of B in W corresponds to:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">alpha_WB</span> <span class="o">=</span> <span class="n">DtW</span><span class="p">(</span><span class="n">w_WB</span><span class="p">)</span> <span class="o">=</span> <span class="n">DtW</span><span class="p">(</span><span class="n">w_WP</span><span class="p">)</span> <span class="o">+</span> <span class="n">DtW</span><span class="p">(</span><span class="n">w_PB</span><span class="p">)</span>
           <span class="o">=</span> <span class="n">alpha_WP</span> <span class="o">+</span> <span class="n">DtW</span><span class="p">(</span><span class="n">w_PB</span><span class="p">)</span>                                   <span class="p">(</span><span class="mi">9</span><span class="p">)</span>
</pre></div>
</div>
<p>where the last term in Eq. (9) can be converted to a time derivative
in P as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">DtW</span><span class="p">(</span><span class="n">w_PB</span><span class="p">)</span> <span class="o">=</span> <span class="n">DtP</span><span class="p">(</span><span class="n">w_PB</span><span class="p">)</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">w_PB</span> <span class="o">=</span> <span class="n">alpha_PB</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">w_PB</span>      <span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">alpha_PB</span> <span class="pre">=</span> <span class="pre">DtP(w_PB)</span></code> by definition. Thus, the final
expression for <code class="docutils literal notranslate"><span class="pre">alpha_WB</span></code> is obtained by using Eq. (10) into Eq.
(9):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">alpha_WB</span> <span class="o">=</span> <span class="n">alpha_WP</span> <span class="o">+</span> <span class="n">alpha_PB</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">w_PB</span>                      <span class="p">(</span><span class="mi">11</span><span class="p">)</span>
</pre></div>
</div>
<p>Equation (11) shows that angular accelerations cannot be simply added
as angular velocities can but there exists an additional term <code class="docutils literal notranslate"><span class="pre">w_WP</span> <span class="pre">x</span>
<span class="pre">w_PB</span></code>.</p>
<ul class="simple">
<li>The spatial acceleration *</li>
</ul>
<p>The rotational and translational components of the spatial
acceleration are given by Eqs. (11) and (6) respectively:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">A_WB</span><span class="o">.</span><span class="n">rotational</span><span class="p">()</span> <span class="o">=</span> <span class="n">alpha_WB</span>
                    <span class="o">=</span> <span class="p">{</span><span class="n">alpha_WP</span><span class="p">}</span> <span class="o">+</span> <span class="n">alpha_PB</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">w_PB</span>           <span class="p">(</span><span class="mi">12</span><span class="p">)</span>
  <span class="n">A_WB</span><span class="o">.</span><span class="n">translational</span><span class="p">()</span> <span class="o">=</span> <span class="n">a_WB</span>
                       <span class="o">=</span> <span class="p">{</span><span class="n">a_WP</span> <span class="o">+</span> <span class="n">alpha_WP</span> <span class="n">x</span> <span class="n">p_PB</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">p_PB</span><span class="p">}</span>
                       <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">v_PB</span> <span class="o">+</span> <span class="n">a_PB</span>                     <span class="p">(</span><span class="mi">13</span><span class="p">)</span>
</pre></div>
</div>
<p>where we have placed within curly brackets <code class="docutils literal notranslate"><span class="pre">{}</span></code> all the terms that
also appear in the Shift() operation, which is equivalent to this
method when <code class="docutils literal notranslate"><span class="pre">V_PB</span></code> and <code class="docutils literal notranslate"><span class="pre">A_PB</span></code> are both zero. In the equations
above <code class="docutils literal notranslate"><span class="pre">alpha_WP</span> <span class="pre">=</span> <span class="pre">A_WP.rotational()</span></code> and <code class="docutils literal notranslate"><span class="pre">a_WP</span> <span class="pre">=</span>
<span class="pre">A_WP.translational()</span></code>. The above expression can be written in a more
compact form in terms of the rigid shift operator <code class="docutils literal notranslate"><span class="pre">Φᵀ(p_PB)</span></code> (see
SpatialVelocity::Shift()) as presented in the main body of this
documentation:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">A_WB</span> <span class="o">=</span> <span class="n">Φᵀ</span><span class="p">(</span><span class="n">p_PB</span><span class="p">)</span><span class="n">A_WP</span> <span class="o">+</span> <span class="n">Ac_WB</span><span class="p">(</span><span class="n">w_WP</span><span class="p">,</span> <span class="n">V_PB</span><span class="p">)</span> <span class="o">+</span> <span class="n">A_PB_W</span>                  <span class="p">(</span><span class="mi">14</span><span class="p">)</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">Ac_WB(w_WP,</span> <span class="pre">V_PB)</span></code> contains the centrifugal and Coriolis
terms:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Ac_WB</span><span class="p">(</span><span class="n">w_WP</span><span class="p">,</span> <span class="n">V_PB</span><span class="p">)</span> <span class="o">=</span> <span class="o">|</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">w_PB_W</span>                          <span class="o">|</span>
                      <span class="o">|</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">p_PB_W</span> <span class="o">+</span> <span class="mi">2</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">v_PB_W</span> <span class="o">|</span>
                                  <span class="o">^^^</span>                <span class="o">^^^</span>
                              <span class="n">centrifugal</span>         <span class="n">Coriolis</span>
</pre></div>
</div>
<p>As usual, for computation, all quantities above must be expressed in a
common frame E; we add an <code class="docutils literal notranslate"><span class="pre">_E</span></code> suffix to each symbol to indicate
that.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd].get_coeffs">
<code class="descname">get_coeffs</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[6, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd].get_coeffs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to the underlying storage.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd].Rotate">
<code class="descname">Rotate</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd], R_FE: pydrake.math.RotationMatrix_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd].Rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides a Python-only implementation of rotating / re-expressing a
spatial vector.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is done because defining <code class="docutils literal notranslate"><span class="pre">__rmatmul__</span></code> on this class does
not disambiguate against the definitions of
<code class="docutils literal notranslate"><span class="pre">RotationMatrix.__matmul__</span></code>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd].rotational">
<code class="descname">rotational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd].rotational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the rotational component of this spatial vector.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd].SetZero">
<code class="descname">SetZero</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd].SetZero" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets both rotational and translational components of <code class="docutils literal notranslate"><span class="pre">this</span></code>
SpatialVector to zero.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd].Shift">
<code class="descname">Shift</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd].Shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>Shift(self: pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd], p_PoQ_E: numpy.ndarray[object[3, 1]], w_WP_E: numpy.ndarray[object[3, 1]]) -&gt; pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd]</li>
</ol>
<p>Shifts <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial acceleration <code class="docutils literal notranslate"><span class="pre">A_WP</span></code> of a frame P into the
spatial acceleration <code class="docutils literal notranslate"><span class="pre">A_WPq</span></code> of a frame <code class="docutils literal notranslate"><span class="pre">Pq</span></code> which is an offset
frame rigidly aligned with P, but with its origin shifted to a point Q
by an offset p_PoQ. Frame <code class="docutils literal notranslate"><span class="pre">Pq</span></code> is instantaneously moving together
with frame P as if rigidly attached to it. As an example of
application, this operation can be used to compute <code class="docutils literal notranslate"><span class="pre">A_WPq</span></code> where P
is a frame on a rigid body and Q is another point on that same body.
Therefore P and <code class="docutils literal notranslate"><span class="pre">Pq</span></code> move together with the spatial velocity
<code class="docutils literal notranslate"><span class="pre">V_PPq</span></code> being zero at all times. This is an alternate signature for
shifting a spatial acceleration that does not change the original
object. See ShiftInPlace() for more information and a description of
the arguments.</p>
<ol class="arabic simple" start="2">
<li>Shift(self: pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd], p_PoQ_E: numpy.ndarray[object[3, 1]]) -&gt; pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd]</li>
</ol>
<p>(Advanced) Given <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial acceleration <code class="docutils literal notranslate"><span class="pre">A_WP</span></code> of a frame P
in a second frame W, this operation is only valid when the angular
velocity <code class="docutils literal notranslate"><span class="pre">w_WP</span></code> of P in W is zero. Refer to Shift(const Vector3&lt;T&gt;&amp;,
const Vector3&lt;T&gt;&amp;) for the full version that includes velocity terms.
This method can be used to avoid unnecessary computation when shifting
<code class="docutils literal notranslate"><span class="pre">this</span></code> spatial acceleration of a frame P into the spatial
acceleration of the shifted frame <code class="docutils literal notranslate"><span class="pre">Pq</span></code>. The shift position vector is
given by <code class="docutils literal notranslate"><span class="pre">p_PoQ_E</span></code>, expresssed in the same frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code>
spatial` acceleration. Mathematically, this returns <code class="docutils literal notranslate"><span class="pre">A_WPq</span> <span class="pre">=</span>
<span class="pre">Φᵀ(p_PoQ)A_WP</span></code>, where <code class="docutils literal notranslate"><span class="pre">Φ(p_PoQ)</span></code> is the rigid shift operator, see
SpatialVelocity::Shift().</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd].translational">
<code class="descname">translational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd].translational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the translational component of this spatial vector.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd].Zero">
<em class="property">static </em><code class="descname">Zero</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd].Zero" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory to create a <em>zero</em> SpatialVector, i.e. rotational and
translational components are both zero.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.math.SpatialAcceleration_[Expression]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.math.</code><code class="descname">SpatialAcceleration_[Expression]</code><a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_[Expression]" title="Permalink to this definition">¶</a></dt>
<dd><p>This class is used to represent a <em>spatial acceleration</em> that combines
rotational (angular acceleration) and translational (linear
acceleration) components. While a SpatialVelocity <code class="docutils literal notranslate"><span class="pre">V_XY</span></code> represents
the motion of a “moving frame” Y measured with respect to a
“measured-in” frame X, the SpatialAcceleration <code class="docutils literal notranslate"><span class="pre">A_XY</span></code> represents the
rate of change of this spatial velocity <code class="docutils literal notranslate"><span class="pre">V_XY</span></code> in frame X. That is
<span class="math notranslate nohighlight">\(^XA^Y = \frac{^Xd}{dt}\,{^XV^Y}\)</span> where <span class="math notranslate nohighlight">\(\frac{^Xd}{dt}\)</span>
denotes the time derivative taken in frame X. That is, to compute an
acceleration we need to specify in what frame the time derivative is
taken, see [Mitiguy 2016, §6.1] for a more in depth discussion on
this. Time derivatives can be taken in different frames, and they
transform according to the “Transport Theorem”, which in Drake is
implemented in drake::math::ConvertTimeDerivativeToOtherFrame(). In
source code comments we write <code class="docutils literal notranslate"><span class="pre">A_XY</span> <span class="pre">=</span> <span class="pre">DtX(V_XY)</span></code>, where <code class="docutils literal notranslate"><span class="pre">DtX()</span></code> is
the operator that takes the time derivative in the X frame. By
convention, and unless otherwise stated, we assume that the frame in
which the time derivative is taken is the “measured-in” frame, i.e.
the time derivative used in <code class="docutils literal notranslate"><span class="pre">A_XY</span></code> is in frame X by default (i.e.
DtX()). To perform numerical computations, we need to specify an
“expressed-in” frame E (which may be distinct from either X or Y), so
that components can be expressed as real numbers. Only the vector
values are stored in a SpatialAcceleration object; the frames must be
understood from context and it is the responsibility of the user to
keep track of them. That is best accomplished through disciplined
notation. In source code we use monogram notation where capital A is
used to designate a spatial acceleration quantity. The same monogram
notation rules for SpatialVelocity are also used for
SpatialAcceleration. That is, the spatial acceleration of a frame Y
measured in X and expressed in E is denoted with <code class="docutils literal notranslate"><span class="pre">A_XY_E</span></code>. For a
more detailed introduction on spatial vectors and the monogram
notation please refer to section multibody_spatial_vectors.</p>
<p>[Mitiguy 2016] Mitiguy, P., 2016. Advanced Dynamics &amp; Motion
Simulation.</p>
<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_[Expression].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_[Expression].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialAcceleration_[Expression]) -&gt; None</p>
<blockquote>
<div><p>Constructs to all NaNs.</p>
<dl class="docutils">
<dt>Note:</dt>
<dd><p class="first last">This is different from C++, which in Release builds may leave memory
uninitialized. In pydrake, the function call overhead already trumps
any overhead from NAN-initialization, so we err on the side of
safety.</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialAcceleration_[Expression], alpha: numpy.ndarray[object[3, 1]], a: numpy.ndarray[object[3, 1]]) -&gt; None</p>
</li>
</ol>
<p>SpatialAcceleration constructor from an angular acceleration <code class="docutils literal notranslate"><span class="pre">alpha</span></code>
and a linear acceleration <code class="docutils literal notranslate"><span class="pre">a</span></code>.</p>
<ol class="arabic simple" start="3">
<li>__init__(self: pydrake.multibody.math.SpatialAcceleration_[Expression], A: numpy.ndarray[object[6, 1]]) -&gt; None</li>
</ol>
<p>SpatialAcceleration constructor from an Eigen expression that
represents a six-dimensional vector. Under the hood, spatial
accelerations are 6-element quantities that are pairs of ordinary
3-vectors. Elements 0-2 constitute the angular acceleration component
while elements 3-5 constitute the translational acceleration. The
argument <code class="docutils literal notranslate"><span class="pre">A</span></code> in this constructor is the concatenation of the
rotational 3D component followed by the translational 3D component.
This constructor will assert the size of <code class="docutils literal notranslate"><span class="pre">A</span></code> is six (6) at
compile-time for fixed sized Eigen expressions and at run-time for
dynamic sized Eigen expressions.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_[Expression].ComposeWithMovingFrameAcceleration">
<code class="descname">ComposeWithMovingFrameAcceleration</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialAcceleration_[Expression], p_PB_E: numpy.ndarray[object[3, 1]], w_WP_E: numpy.ndarray[object[3, 1]], V_PB_E: pydrake.multibody.math.SpatialVelocity_[Expression], A_PB_E: pydrake.multibody.math.SpatialAcceleration_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialAcceleration_[Expression]<a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_[Expression].ComposeWithMovingFrameAcceleration" title="Permalink to this definition">¶</a></dt>
<dd><p>This method composes <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial acceleration <code class="docutils literal notranslate"><span class="pre">A_WP</span></code> of a frame
P measured in a frame W, with that of a third frame B moving in P with
spatial acceleration <code class="docutils literal notranslate"><span class="pre">A_PB</span></code>. The result is the spatial acceleration
<code class="docutils literal notranslate"><span class="pre">A_WB</span></code> of frame B measured in W. At the instant in which the
accelerations are composed, frame B is located with its origin Bo at
<code class="docutils literal notranslate"><span class="pre">p_PB</span></code> from P’s origin Po.</p>
<p>This operation can be written in a more compact form in terms of the
rigid shift operator <code class="docutils literal notranslate"><span class="pre">Φᵀ(p_PB)</span></code> (see SpatialVelocity::Shift()) as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">A_WB</span> <span class="o">=</span> <span class="n">Φᵀ</span><span class="p">(</span><span class="n">p_PB</span><span class="p">)</span> <span class="n">A_WP</span> <span class="o">+</span> <span class="n">Ac_WB</span><span class="p">(</span><span class="n">w_WP</span><span class="p">,</span> <span class="n">V_PB</span><span class="p">)</span> <span class="o">+</span> <span class="n">A_PB_W</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">Φᵀ(p_PB)</span> <span class="pre">A_WP</span></code> denotes the application of the rigid shift
operation as in SpatialVelocity::Shift() and <code class="docutils literal notranslate"><span class="pre">Ac_WB(w_WP,</span> <span class="pre">V_PB)</span></code>
contains the centrifugal and Coriolis terms:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Ac_WB</span><span class="p">(</span><span class="n">w_WP</span><span class="p">,</span> <span class="n">V_PB</span><span class="p">)</span> <span class="o">=</span> <span class="o">|</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">w_PB_W</span>                          <span class="o">|</span>
                      <span class="o">|</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">p_PB_W</span> <span class="o">+</span> <span class="mi">2</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">v_PB_W</span> <span class="o">|</span>
                                  <span class="o">^^^</span>                <span class="o">^^^</span>
                              <span class="n">centrifugal</span>         <span class="n">Coriolis</span>
</pre></div>
</div>
<p>The equation above shows that composing spatial accelerations cannot
be simply accomplished by adding <code class="docutils literal notranslate"><span class="pre">A_WP</span></code> with <code class="docutils literal notranslate"><span class="pre">A_PB</span></code>. Moreover, we
see that, unlike with angular velocities, angular accelerations cannot
be added in order to compose them. That is <code class="docutils literal notranslate"><span class="pre">w_AC</span> <span class="pre">=</span> <span class="pre">w_AB</span> <span class="pre">+</span> <span class="pre">w_BC</span></code> but
<code class="docutils literal notranslate"><span class="pre">alpha_AC</span> <span class="pre">≠</span> <span class="pre">alpha_AB</span> <span class="pre">+</span> <span class="pre">alpha_BC</span></code> due to the cross term <code class="docutils literal notranslate"><span class="pre">w_AC</span> <span class="pre">x</span>
<span class="pre">w_BC</span></code>. See the derivation below for more details.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">SpatialVelocity::ComposeWithMovingFrameVelocity() for the
composition of SpatialVelocity quantities.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This method is the extension to the Shift() operator, which
computes the spatial acceleration frame P shifted to B as if frame
B moved rigidly with P, that is, for when <code class="docutils literal notranslate"><span class="pre">V_PB</span></code> and <code class="docutils literal notranslate"><span class="pre">A_PB</span></code>
are both zero. In other words the results from Shift() equal the
results from this method when <code class="docutils literal notranslate"><span class="pre">V_PB</span></code> and <code class="docutils literal notranslate"><span class="pre">A_PB</span></code> are both zero.</p>
</div>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_PB_E</span></code>:</dt>
<dd>Shift vector from P’s origin to B’s origin, expressed in frame E.
The “from” point <code class="docutils literal notranslate"><span class="pre">Po</span></code> must be the point whose acceleration is
currently represented in <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial acceleration, and E must
be the same expressed-in frame as for <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial
acceleration.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">w_WP_E</span></code>:</dt>
<dd>Angular velocity of frame P measured in frame W and expressed in
frame E.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">V_PB_E</span></code>:</dt>
<dd>The spatial velocity of a third frame B in motion with respect to
P, expressed in the same frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial acceleration.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">A_PB_E</span></code>:</dt>
<dd>The spatial acceleration of a third frame B in motion with respect
to P, expressed in the same frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial
acceleration.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">A_WB_E</span></code>:</dt>
<dd>The spatial acceleration of frame B in W, expressed in frame E.</dd>
</dl>
<p>** Derivation **</p>
<p>The spatial velocity of frame B in W can be obtained by composing
<code class="docutils literal notranslate"><span class="pre">V_WP</span></code> with <code class="docutils literal notranslate"><span class="pre">V_PB</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">V_WB</span> <span class="o">=</span> <span class="n">V_WPb</span> <span class="o">+</span> <span class="n">V_PB</span> <span class="o">=</span> <span class="n">Φᵀ</span><span class="p">(</span><span class="n">p_PB</span><span class="p">)</span> <span class="n">V_WP</span> <span class="o">+</span> <span class="n">V_PB</span>                        <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>This operation can be performed with the method
SpatialVelocity::ComposeWithMovingFrameVelocity().</p>
<ul class="simple">
<li>Translational acceleration component *</li>
</ul>
<p>The translational velocity <code class="docutils literal notranslate"><span class="pre">v_WB</span></code> of point B in W corresponds to the
translational component in Eq. (1):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">v_WB</span> <span class="o">=</span> <span class="n">v_WP</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">p_PB</span> <span class="o">+</span> <span class="n">v_PB</span>                                  <span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>Therefore, for the translational acceleration we have:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a_WB</span> <span class="o">=</span> <span class="n">DtW</span><span class="p">(</span><span class="n">v_WB</span><span class="p">)</span>
        <span class="o">=</span> <span class="n">DtW</span><span class="p">(</span><span class="n">v_WP</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">p_PB</span> <span class="o">+</span> <span class="n">v_PB</span><span class="p">)</span>
        <span class="o">=</span> <span class="n">DtW</span><span class="p">(</span><span class="n">v_WP</span><span class="p">)</span> <span class="o">+</span> <span class="n">DtW</span><span class="p">(</span><span class="n">w_WP</span> <span class="n">x</span> <span class="n">p_PB</span><span class="p">)</span> <span class="o">+</span> <span class="n">DtW</span><span class="p">(</span><span class="n">v_PB</span><span class="p">)</span>
        <span class="o">=</span> <span class="n">a_WP</span> <span class="o">+</span> <span class="n">DtW</span><span class="p">(</span><span class="n">w_WP</span><span class="p">)</span> <span class="n">x</span> <span class="n">p_PB</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">DtW</span><span class="p">(</span><span class="n">p_PB</span><span class="p">)</span> <span class="o">+</span> <span class="n">DtW</span><span class="p">(</span><span class="n">v_PB</span><span class="p">)</span>
        <span class="o">=</span> <span class="n">a_WP</span> <span class="o">+</span> <span class="n">alpha_WP</span> <span class="n">x</span> <span class="n">p_PB</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">DtW</span><span class="p">(</span><span class="n">p_PB</span><span class="p">)</span> <span class="o">+</span> <span class="n">DtW</span><span class="p">(</span><span class="n">v_PB</span><span class="p">)</span>     <span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>with <code class="docutils literal notranslate"><span class="pre">a_WP</span> <span class="pre">=</span> <span class="pre">DtW(v_WP)</span></code> and <code class="docutils literal notranslate"><span class="pre">alpha_WP</span> <span class="pre">=</span> <span class="pre">DtW(w_WP)</span></code> by definition.
The term DtW(p_PB) in Eq. (3) is obtained by converting the vector
time derivative from <code class="docutils literal notranslate"><span class="pre">DtW()</span></code> to <code class="docutils literal notranslate"><span class="pre">DtP()</span></code>, see
drake::math::ConvertTimeDerivativeToOtherFrame():</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">DtW</span><span class="p">(</span><span class="n">p_PB</span><span class="p">)</span> <span class="o">=</span> <span class="n">DtP</span><span class="p">(</span><span class="n">p_PB</span><span class="p">)</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">p_PB</span>
            <span class="o">=</span> <span class="n">v_PB</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">p_PB</span>                                    <span class="p">(</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
<p>since <code class="docutils literal notranslate"><span class="pre">v_PB</span> <span class="pre">=</span> <span class="pre">DtP(p_PB)</span></code> by definition. Similarly, the term
<code class="docutils literal notranslate"><span class="pre">DtW(v_PB)</span></code> in Eq. (3) is also obtained by converting the time
derivative from <code class="docutils literal notranslate"><span class="pre">DtW()</span></code> to <code class="docutils literal notranslate"><span class="pre">DtP()</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">DtW</span><span class="p">(</span><span class="n">v_PB</span><span class="p">)</span> <span class="o">=</span> <span class="n">DtP</span><span class="p">(</span><span class="n">v_PB</span><span class="p">)</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">v_PB</span>
            <span class="o">=</span> <span class="n">a_PB</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">v_PB</span>                                    <span class="p">(</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<p>with <code class="docutils literal notranslate"><span class="pre">a_PB</span> <span class="pre">=</span> <span class="pre">DtP(v_PB)</span></code> by definition. Using Eqs. (4) and (5) in Eq.
(3) yields for the translational acceleration:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a_WB</span> <span class="o">=</span> <span class="n">a_WP</span> <span class="o">+</span> <span class="n">alpha_WP</span> <span class="n">x</span> <span class="n">p_PB</span> <span class="o">+</span> <span class="n">a_PB</span> <span class="o">+</span> <span class="n">ac_WB</span>
  <span class="n">ac_WB</span> <span class="o">=</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="p">(</span><span class="n">v_PB</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">p_PB</span><span class="p">)</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">v_PB</span>                 <span class="p">(</span><span class="mi">6</span><span class="p">)</span>
</pre></div>
</div>
<p>where finally the term <code class="docutils literal notranslate"><span class="pre">ac_WB</span></code> can be written as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ac_WB</span> <span class="o">=</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">p_PB</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">v_PB</span>                      <span class="p">(</span><span class="mi">7</span><span class="p">)</span>
</pre></div>
</div>
<p>which includes the effect of angular acceleration of P in W <code class="docutils literal notranslate"><span class="pre">alpha_WP</span>
<span class="pre">x</span> <span class="pre">p_PB</span></code>, the centrifugal acceleration <code class="docutils literal notranslate"><span class="pre">w_WP</span> <span class="pre">x</span> <span class="pre">w_WP</span> <span class="pre">x</span> <span class="pre">p_PB</span></code>, the
Coriolis acceleration <code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">*</span> <span class="pre">w_WP</span> <span class="pre">x</span> <span class="pre">v_PB</span></code> due to the motion of B in P
and, the additional acceleration of B in P <code class="docutils literal notranslate"><span class="pre">a_PB</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Alternatively, we can write an efficient version of the
centrifugal term <code class="docutils literal notranslate"><span class="pre">ac_WB</span></code> in Eq. (6) for when the velocities of P
and B are available (e.g. from velocity kinematics). This is
accomplished by adding and subtracting v_WP within the
parenthesized term in Eq. (6) and grouping together v_WB = v_WPb +
v_PB = v_WP + w_WP x p_PB + v_PB:</p>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ac_WB</span> <span class="o">=</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="p">(</span><span class="n">v_WB</span> <span class="o">-</span> <span class="n">v_WP</span><span class="p">)</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">v_PB</span>
        <span class="o">=</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="p">(</span><span class="n">v_WB</span> <span class="o">-</span> <span class="n">v_WP</span> <span class="o">+</span> <span class="n">v_PB</span><span class="p">)</span>                               <span class="p">(</span><span class="mi">6</span><span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>which simplifies the expression from three cross products to one.</p>
<ul class="simple">
<li>Rotational acceleration component *</li>
</ul>
<p>The rotational velocity <code class="docutils literal notranslate"><span class="pre">w_WB</span></code> of frame B in W corresponds to the
rotational component in Eq. (1):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">w_WB</span> <span class="o">=</span> <span class="n">w_WP</span> <span class="o">+</span> <span class="n">w_PB</span>                                                <span class="p">(</span><span class="mi">8</span><span class="p">)</span>
</pre></div>
</div>
<p>Therefore, the rotational acceleration of B in W corresponds to:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">alpha_WB</span> <span class="o">=</span> <span class="n">DtW</span><span class="p">(</span><span class="n">w_WB</span><span class="p">)</span> <span class="o">=</span> <span class="n">DtW</span><span class="p">(</span><span class="n">w_WP</span><span class="p">)</span> <span class="o">+</span> <span class="n">DtW</span><span class="p">(</span><span class="n">w_PB</span><span class="p">)</span>
           <span class="o">=</span> <span class="n">alpha_WP</span> <span class="o">+</span> <span class="n">DtW</span><span class="p">(</span><span class="n">w_PB</span><span class="p">)</span>                                   <span class="p">(</span><span class="mi">9</span><span class="p">)</span>
</pre></div>
</div>
<p>where the last term in Eq. (9) can be converted to a time derivative
in P as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">DtW</span><span class="p">(</span><span class="n">w_PB</span><span class="p">)</span> <span class="o">=</span> <span class="n">DtP</span><span class="p">(</span><span class="n">w_PB</span><span class="p">)</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">w_PB</span> <span class="o">=</span> <span class="n">alpha_PB</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">w_PB</span>      <span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">alpha_PB</span> <span class="pre">=</span> <span class="pre">DtP(w_PB)</span></code> by definition. Thus, the final
expression for <code class="docutils literal notranslate"><span class="pre">alpha_WB</span></code> is obtained by using Eq. (10) into Eq.
(9):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">alpha_WB</span> <span class="o">=</span> <span class="n">alpha_WP</span> <span class="o">+</span> <span class="n">alpha_PB</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">w_PB</span>                      <span class="p">(</span><span class="mi">11</span><span class="p">)</span>
</pre></div>
</div>
<p>Equation (11) shows that angular accelerations cannot be simply added
as angular velocities can but there exists an additional term <code class="docutils literal notranslate"><span class="pre">w_WP</span> <span class="pre">x</span>
<span class="pre">w_PB</span></code>.</p>
<ul class="simple">
<li>The spatial acceleration *</li>
</ul>
<p>The rotational and translational components of the spatial
acceleration are given by Eqs. (11) and (6) respectively:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">A_WB</span><span class="o">.</span><span class="n">rotational</span><span class="p">()</span> <span class="o">=</span> <span class="n">alpha_WB</span>
                    <span class="o">=</span> <span class="p">{</span><span class="n">alpha_WP</span><span class="p">}</span> <span class="o">+</span> <span class="n">alpha_PB</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">w_PB</span>           <span class="p">(</span><span class="mi">12</span><span class="p">)</span>
  <span class="n">A_WB</span><span class="o">.</span><span class="n">translational</span><span class="p">()</span> <span class="o">=</span> <span class="n">a_WB</span>
                       <span class="o">=</span> <span class="p">{</span><span class="n">a_WP</span> <span class="o">+</span> <span class="n">alpha_WP</span> <span class="n">x</span> <span class="n">p_PB</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">p_PB</span><span class="p">}</span>
                       <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">v_PB</span> <span class="o">+</span> <span class="n">a_PB</span>                     <span class="p">(</span><span class="mi">13</span><span class="p">)</span>
</pre></div>
</div>
<p>where we have placed within curly brackets <code class="docutils literal notranslate"><span class="pre">{}</span></code> all the terms that
also appear in the Shift() operation, which is equivalent to this
method when <code class="docutils literal notranslate"><span class="pre">V_PB</span></code> and <code class="docutils literal notranslate"><span class="pre">A_PB</span></code> are both zero. In the equations
above <code class="docutils literal notranslate"><span class="pre">alpha_WP</span> <span class="pre">=</span> <span class="pre">A_WP.rotational()</span></code> and <code class="docutils literal notranslate"><span class="pre">a_WP</span> <span class="pre">=</span>
<span class="pre">A_WP.translational()</span></code>. The above expression can be written in a more
compact form in terms of the rigid shift operator <code class="docutils literal notranslate"><span class="pre">Φᵀ(p_PB)</span></code> (see
SpatialVelocity::Shift()) as presented in the main body of this
documentation:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">A_WB</span> <span class="o">=</span> <span class="n">Φᵀ</span><span class="p">(</span><span class="n">p_PB</span><span class="p">)</span><span class="n">A_WP</span> <span class="o">+</span> <span class="n">Ac_WB</span><span class="p">(</span><span class="n">w_WP</span><span class="p">,</span> <span class="n">V_PB</span><span class="p">)</span> <span class="o">+</span> <span class="n">A_PB_W</span>                  <span class="p">(</span><span class="mi">14</span><span class="p">)</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">Ac_WB(w_WP,</span> <span class="pre">V_PB)</span></code> contains the centrifugal and Coriolis
terms:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Ac_WB</span><span class="p">(</span><span class="n">w_WP</span><span class="p">,</span> <span class="n">V_PB</span><span class="p">)</span> <span class="o">=</span> <span class="o">|</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">w_PB_W</span>                          <span class="o">|</span>
                      <span class="o">|</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">p_PB_W</span> <span class="o">+</span> <span class="mi">2</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">v_PB_W</span> <span class="o">|</span>
                                  <span class="o">^^^</span>                <span class="o">^^^</span>
                              <span class="n">centrifugal</span>         <span class="n">Coriolis</span>
</pre></div>
</div>
<p>As usual, for computation, all quantities above must be expressed in a
common frame E; we add an <code class="docutils literal notranslate"><span class="pre">_E</span></code> suffix to each symbol to indicate
that.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_[Expression].get_coeffs">
<code class="descname">get_coeffs</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialAcceleration_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[6, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_[Expression].get_coeffs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to the underlying storage.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_[Expression].Rotate">
<code class="descname">Rotate</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialAcceleration_[Expression], R_FE: pydrake.math.RotationMatrix_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialAcceleration_[Expression]<a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_[Expression].Rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides a Python-only implementation of rotating / re-expressing a
spatial vector.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is done because defining <code class="docutils literal notranslate"><span class="pre">__rmatmul__</span></code> on this class does
not disambiguate against the definitions of
<code class="docutils literal notranslate"><span class="pre">RotationMatrix.__matmul__</span></code>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_[Expression].rotational">
<code class="descname">rotational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialAcceleration_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_[Expression].rotational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the rotational component of this spatial vector.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_[Expression].SetZero">
<code class="descname">SetZero</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialAcceleration_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialAcceleration_[Expression]<a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_[Expression].SetZero" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets both rotational and translational components of <code class="docutils literal notranslate"><span class="pre">this</span></code>
SpatialVector to zero.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_[Expression].Shift">
<code class="descname">Shift</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_[Expression].Shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>Shift(self: pydrake.multibody.math.SpatialAcceleration_[Expression], p_PoQ_E: numpy.ndarray[object[3, 1]], w_WP_E: numpy.ndarray[object[3, 1]]) -&gt; pydrake.multibody.math.SpatialAcceleration_[Expression]</li>
</ol>
<p>Shifts <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial acceleration <code class="docutils literal notranslate"><span class="pre">A_WP</span></code> of a frame P into the
spatial acceleration <code class="docutils literal notranslate"><span class="pre">A_WPq</span></code> of a frame <code class="docutils literal notranslate"><span class="pre">Pq</span></code> which is an offset
frame rigidly aligned with P, but with its origin shifted to a point Q
by an offset p_PoQ. Frame <code class="docutils literal notranslate"><span class="pre">Pq</span></code> is instantaneously moving together
with frame P as if rigidly attached to it. As an example of
application, this operation can be used to compute <code class="docutils literal notranslate"><span class="pre">A_WPq</span></code> where P
is a frame on a rigid body and Q is another point on that same body.
Therefore P and <code class="docutils literal notranslate"><span class="pre">Pq</span></code> move together with the spatial velocity
<code class="docutils literal notranslate"><span class="pre">V_PPq</span></code> being zero at all times. This is an alternate signature for
shifting a spatial acceleration that does not change the original
object. See ShiftInPlace() for more information and a description of
the arguments.</p>
<ol class="arabic simple" start="2">
<li>Shift(self: pydrake.multibody.math.SpatialAcceleration_[Expression], p_PoQ_E: numpy.ndarray[object[3, 1]]) -&gt; pydrake.multibody.math.SpatialAcceleration_[Expression]</li>
</ol>
<p>(Advanced) Given <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial acceleration <code class="docutils literal notranslate"><span class="pre">A_WP</span></code> of a frame P
in a second frame W, this operation is only valid when the angular
velocity <code class="docutils literal notranslate"><span class="pre">w_WP</span></code> of P in W is zero. Refer to Shift(const Vector3&lt;T&gt;&amp;,
const Vector3&lt;T&gt;&amp;) for the full version that includes velocity terms.
This method can be used to avoid unnecessary computation when shifting
<code class="docutils literal notranslate"><span class="pre">this</span></code> spatial acceleration of a frame P into the spatial
acceleration of the shifted frame <code class="docutils literal notranslate"><span class="pre">Pq</span></code>. The shift position vector is
given by <code class="docutils literal notranslate"><span class="pre">p_PoQ_E</span></code>, expresssed in the same frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code>
spatial` acceleration. Mathematically, this returns <code class="docutils literal notranslate"><span class="pre">A_WPq</span> <span class="pre">=</span>
<span class="pre">Φᵀ(p_PoQ)A_WP</span></code>, where <code class="docutils literal notranslate"><span class="pre">Φ(p_PoQ)</span></code> is the rigid shift operator, see
SpatialVelocity::Shift().</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_[Expression].translational">
<code class="descname">translational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialAcceleration_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_[Expression].translational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the translational component of this spatial vector.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.math.SpatialAcceleration_[Expression].Zero">
<em class="property">static </em><code class="descname">Zero</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialAcceleration_[Expression]<a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_[Expression].Zero" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory to create a <em>zero</em> SpatialVector, i.e. rotational and
translational components are both zero.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.math.SpatialAcceleration_[float]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.math.</code><code class="descname">SpatialAcceleration_[float]</code><a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>This class is used to represent a <em>spatial acceleration</em> that combines
rotational (angular acceleration) and translational (linear
acceleration) components. While a SpatialVelocity <code class="docutils literal notranslate"><span class="pre">V_XY</span></code> represents
the motion of a “moving frame” Y measured with respect to a
“measured-in” frame X, the SpatialAcceleration <code class="docutils literal notranslate"><span class="pre">A_XY</span></code> represents the
rate of change of this spatial velocity <code class="docutils literal notranslate"><span class="pre">V_XY</span></code> in frame X. That is
<span class="math notranslate nohighlight">\(^XA^Y = \frac{^Xd}{dt}\,{^XV^Y}\)</span> where <span class="math notranslate nohighlight">\(\frac{^Xd}{dt}\)</span>
denotes the time derivative taken in frame X. That is, to compute an
acceleration we need to specify in what frame the time derivative is
taken, see [Mitiguy 2016, §6.1] for a more in depth discussion on
this. Time derivatives can be taken in different frames, and they
transform according to the “Transport Theorem”, which in Drake is
implemented in drake::math::ConvertTimeDerivativeToOtherFrame(). In
source code comments we write <code class="docutils literal notranslate"><span class="pre">A_XY</span> <span class="pre">=</span> <span class="pre">DtX(V_XY)</span></code>, where <code class="docutils literal notranslate"><span class="pre">DtX()</span></code> is
the operator that takes the time derivative in the X frame. By
convention, and unless otherwise stated, we assume that the frame in
which the time derivative is taken is the “measured-in” frame, i.e.
the time derivative used in <code class="docutils literal notranslate"><span class="pre">A_XY</span></code> is in frame X by default (i.e.
DtX()). To perform numerical computations, we need to specify an
“expressed-in” frame E (which may be distinct from either X or Y), so
that components can be expressed as real numbers. Only the vector
values are stored in a SpatialAcceleration object; the frames must be
understood from context and it is the responsibility of the user to
keep track of them. That is best accomplished through disciplined
notation. In source code we use monogram notation where capital A is
used to designate a spatial acceleration quantity. The same monogram
notation rules for SpatialVelocity are also used for
SpatialAcceleration. That is, the spatial acceleration of a frame Y
measured in X and expressed in E is denoted with <code class="docutils literal notranslate"><span class="pre">A_XY_E</span></code>. For a
more detailed introduction on spatial vectors and the monogram
notation please refer to section multibody_spatial_vectors.</p>
<p>[Mitiguy 2016] Mitiguy, P., 2016. Advanced Dynamics &amp; Motion
Simulation.</p>
<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialAcceleration_[float]) -&gt; None</p>
<blockquote>
<div><p>Constructs to all NaNs.</p>
<dl class="docutils">
<dt>Note:</dt>
<dd><p class="first last">This is different from C++, which in Release builds may leave memory
uninitialized. In pydrake, the function call overhead already trumps
any overhead from NAN-initialization, so we err on the side of
safety.</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialAcceleration_[float], alpha: numpy.ndarray[numpy.float64[3, 1]], a: numpy.ndarray[numpy.float64[3, 1]]) -&gt; None</p>
</li>
</ol>
<p>SpatialAcceleration constructor from an angular acceleration <code class="docutils literal notranslate"><span class="pre">alpha</span></code>
and a linear acceleration <code class="docutils literal notranslate"><span class="pre">a</span></code>.</p>
<ol class="arabic simple" start="3">
<li>__init__(self: pydrake.multibody.math.SpatialAcceleration_[float], A: numpy.ndarray[numpy.float64[6, 1]]) -&gt; None</li>
</ol>
<p>SpatialAcceleration constructor from an Eigen expression that
represents a six-dimensional vector. Under the hood, spatial
accelerations are 6-element quantities that are pairs of ordinary
3-vectors. Elements 0-2 constitute the angular acceleration component
while elements 3-5 constitute the translational acceleration. The
argument <code class="docutils literal notranslate"><span class="pre">A</span></code> in this constructor is the concatenation of the
rotational 3D component followed by the translational 3D component.
This constructor will assert the size of <code class="docutils literal notranslate"><span class="pre">A</span></code> is six (6) at
compile-time for fixed sized Eigen expressions and at run-time for
dynamic sized Eigen expressions.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_[float].ComposeWithMovingFrameAcceleration">
<code class="descname">ComposeWithMovingFrameAcceleration</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialAcceleration_[float], p_PB_E: numpy.ndarray[numpy.float64[3, 1]], w_WP_E: numpy.ndarray[numpy.float64[3, 1]], V_PB_E: pydrake.multibody.math.SpatialVelocity_[float], A_PB_E: pydrake.multibody.math.SpatialAcceleration_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialAcceleration_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_[float].ComposeWithMovingFrameAcceleration" title="Permalink to this definition">¶</a></dt>
<dd><p>This method composes <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial acceleration <code class="docutils literal notranslate"><span class="pre">A_WP</span></code> of a frame
P measured in a frame W, with that of a third frame B moving in P with
spatial acceleration <code class="docutils literal notranslate"><span class="pre">A_PB</span></code>. The result is the spatial acceleration
<code class="docutils literal notranslate"><span class="pre">A_WB</span></code> of frame B measured in W. At the instant in which the
accelerations are composed, frame B is located with its origin Bo at
<code class="docutils literal notranslate"><span class="pre">p_PB</span></code> from P’s origin Po.</p>
<p>This operation can be written in a more compact form in terms of the
rigid shift operator <code class="docutils literal notranslate"><span class="pre">Φᵀ(p_PB)</span></code> (see SpatialVelocity::Shift()) as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">A_WB</span> <span class="o">=</span> <span class="n">Φᵀ</span><span class="p">(</span><span class="n">p_PB</span><span class="p">)</span> <span class="n">A_WP</span> <span class="o">+</span> <span class="n">Ac_WB</span><span class="p">(</span><span class="n">w_WP</span><span class="p">,</span> <span class="n">V_PB</span><span class="p">)</span> <span class="o">+</span> <span class="n">A_PB_W</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">Φᵀ(p_PB)</span> <span class="pre">A_WP</span></code> denotes the application of the rigid shift
operation as in SpatialVelocity::Shift() and <code class="docutils literal notranslate"><span class="pre">Ac_WB(w_WP,</span> <span class="pre">V_PB)</span></code>
contains the centrifugal and Coriolis terms:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Ac_WB</span><span class="p">(</span><span class="n">w_WP</span><span class="p">,</span> <span class="n">V_PB</span><span class="p">)</span> <span class="o">=</span> <span class="o">|</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">w_PB_W</span>                          <span class="o">|</span>
                      <span class="o">|</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">p_PB_W</span> <span class="o">+</span> <span class="mi">2</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">v_PB_W</span> <span class="o">|</span>
                                  <span class="o">^^^</span>                <span class="o">^^^</span>
                              <span class="n">centrifugal</span>         <span class="n">Coriolis</span>
</pre></div>
</div>
<p>The equation above shows that composing spatial accelerations cannot
be simply accomplished by adding <code class="docutils literal notranslate"><span class="pre">A_WP</span></code> with <code class="docutils literal notranslate"><span class="pre">A_PB</span></code>. Moreover, we
see that, unlike with angular velocities, angular accelerations cannot
be added in order to compose them. That is <code class="docutils literal notranslate"><span class="pre">w_AC</span> <span class="pre">=</span> <span class="pre">w_AB</span> <span class="pre">+</span> <span class="pre">w_BC</span></code> but
<code class="docutils literal notranslate"><span class="pre">alpha_AC</span> <span class="pre">≠</span> <span class="pre">alpha_AB</span> <span class="pre">+</span> <span class="pre">alpha_BC</span></code> due to the cross term <code class="docutils literal notranslate"><span class="pre">w_AC</span> <span class="pre">x</span>
<span class="pre">w_BC</span></code>. See the derivation below for more details.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">SpatialVelocity::ComposeWithMovingFrameVelocity() for the
composition of SpatialVelocity quantities.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This method is the extension to the Shift() operator, which
computes the spatial acceleration frame P shifted to B as if frame
B moved rigidly with P, that is, for when <code class="docutils literal notranslate"><span class="pre">V_PB</span></code> and <code class="docutils literal notranslate"><span class="pre">A_PB</span></code>
are both zero. In other words the results from Shift() equal the
results from this method when <code class="docutils literal notranslate"><span class="pre">V_PB</span></code> and <code class="docutils literal notranslate"><span class="pre">A_PB</span></code> are both zero.</p>
</div>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_PB_E</span></code>:</dt>
<dd>Shift vector from P’s origin to B’s origin, expressed in frame E.
The “from” point <code class="docutils literal notranslate"><span class="pre">Po</span></code> must be the point whose acceleration is
currently represented in <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial acceleration, and E must
be the same expressed-in frame as for <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial
acceleration.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">w_WP_E</span></code>:</dt>
<dd>Angular velocity of frame P measured in frame W and expressed in
frame E.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">V_PB_E</span></code>:</dt>
<dd>The spatial velocity of a third frame B in motion with respect to
P, expressed in the same frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial acceleration.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">A_PB_E</span></code>:</dt>
<dd>The spatial acceleration of a third frame B in motion with respect
to P, expressed in the same frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial
acceleration.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">A_WB_E</span></code>:</dt>
<dd>The spatial acceleration of frame B in W, expressed in frame E.</dd>
</dl>
<p>** Derivation **</p>
<p>The spatial velocity of frame B in W can be obtained by composing
<code class="docutils literal notranslate"><span class="pre">V_WP</span></code> with <code class="docutils literal notranslate"><span class="pre">V_PB</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">V_WB</span> <span class="o">=</span> <span class="n">V_WPb</span> <span class="o">+</span> <span class="n">V_PB</span> <span class="o">=</span> <span class="n">Φᵀ</span><span class="p">(</span><span class="n">p_PB</span><span class="p">)</span> <span class="n">V_WP</span> <span class="o">+</span> <span class="n">V_PB</span>                        <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>This operation can be performed with the method
SpatialVelocity::ComposeWithMovingFrameVelocity().</p>
<ul class="simple">
<li>Translational acceleration component *</li>
</ul>
<p>The translational velocity <code class="docutils literal notranslate"><span class="pre">v_WB</span></code> of point B in W corresponds to the
translational component in Eq. (1):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">v_WB</span> <span class="o">=</span> <span class="n">v_WP</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">p_PB</span> <span class="o">+</span> <span class="n">v_PB</span>                                  <span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>Therefore, for the translational acceleration we have:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a_WB</span> <span class="o">=</span> <span class="n">DtW</span><span class="p">(</span><span class="n">v_WB</span><span class="p">)</span>
        <span class="o">=</span> <span class="n">DtW</span><span class="p">(</span><span class="n">v_WP</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">p_PB</span> <span class="o">+</span> <span class="n">v_PB</span><span class="p">)</span>
        <span class="o">=</span> <span class="n">DtW</span><span class="p">(</span><span class="n">v_WP</span><span class="p">)</span> <span class="o">+</span> <span class="n">DtW</span><span class="p">(</span><span class="n">w_WP</span> <span class="n">x</span> <span class="n">p_PB</span><span class="p">)</span> <span class="o">+</span> <span class="n">DtW</span><span class="p">(</span><span class="n">v_PB</span><span class="p">)</span>
        <span class="o">=</span> <span class="n">a_WP</span> <span class="o">+</span> <span class="n">DtW</span><span class="p">(</span><span class="n">w_WP</span><span class="p">)</span> <span class="n">x</span> <span class="n">p_PB</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">DtW</span><span class="p">(</span><span class="n">p_PB</span><span class="p">)</span> <span class="o">+</span> <span class="n">DtW</span><span class="p">(</span><span class="n">v_PB</span><span class="p">)</span>
        <span class="o">=</span> <span class="n">a_WP</span> <span class="o">+</span> <span class="n">alpha_WP</span> <span class="n">x</span> <span class="n">p_PB</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">DtW</span><span class="p">(</span><span class="n">p_PB</span><span class="p">)</span> <span class="o">+</span> <span class="n">DtW</span><span class="p">(</span><span class="n">v_PB</span><span class="p">)</span>     <span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>with <code class="docutils literal notranslate"><span class="pre">a_WP</span> <span class="pre">=</span> <span class="pre">DtW(v_WP)</span></code> and <code class="docutils literal notranslate"><span class="pre">alpha_WP</span> <span class="pre">=</span> <span class="pre">DtW(w_WP)</span></code> by definition.
The term DtW(p_PB) in Eq. (3) is obtained by converting the vector
time derivative from <code class="docutils literal notranslate"><span class="pre">DtW()</span></code> to <code class="docutils literal notranslate"><span class="pre">DtP()</span></code>, see
drake::math::ConvertTimeDerivativeToOtherFrame():</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">DtW</span><span class="p">(</span><span class="n">p_PB</span><span class="p">)</span> <span class="o">=</span> <span class="n">DtP</span><span class="p">(</span><span class="n">p_PB</span><span class="p">)</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">p_PB</span>
            <span class="o">=</span> <span class="n">v_PB</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">p_PB</span>                                    <span class="p">(</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
<p>since <code class="docutils literal notranslate"><span class="pre">v_PB</span> <span class="pre">=</span> <span class="pre">DtP(p_PB)</span></code> by definition. Similarly, the term
<code class="docutils literal notranslate"><span class="pre">DtW(v_PB)</span></code> in Eq. (3) is also obtained by converting the time
derivative from <code class="docutils literal notranslate"><span class="pre">DtW()</span></code> to <code class="docutils literal notranslate"><span class="pre">DtP()</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">DtW</span><span class="p">(</span><span class="n">v_PB</span><span class="p">)</span> <span class="o">=</span> <span class="n">DtP</span><span class="p">(</span><span class="n">v_PB</span><span class="p">)</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">v_PB</span>
            <span class="o">=</span> <span class="n">a_PB</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">v_PB</span>                                    <span class="p">(</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<p>with <code class="docutils literal notranslate"><span class="pre">a_PB</span> <span class="pre">=</span> <span class="pre">DtP(v_PB)</span></code> by definition. Using Eqs. (4) and (5) in Eq.
(3) yields for the translational acceleration:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a_WB</span> <span class="o">=</span> <span class="n">a_WP</span> <span class="o">+</span> <span class="n">alpha_WP</span> <span class="n">x</span> <span class="n">p_PB</span> <span class="o">+</span> <span class="n">a_PB</span> <span class="o">+</span> <span class="n">ac_WB</span>
  <span class="n">ac_WB</span> <span class="o">=</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="p">(</span><span class="n">v_PB</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">p_PB</span><span class="p">)</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">v_PB</span>                 <span class="p">(</span><span class="mi">6</span><span class="p">)</span>
</pre></div>
</div>
<p>where finally the term <code class="docutils literal notranslate"><span class="pre">ac_WB</span></code> can be written as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ac_WB</span> <span class="o">=</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">p_PB</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">v_PB</span>                      <span class="p">(</span><span class="mi">7</span><span class="p">)</span>
</pre></div>
</div>
<p>which includes the effect of angular acceleration of P in W <code class="docutils literal notranslate"><span class="pre">alpha_WP</span>
<span class="pre">x</span> <span class="pre">p_PB</span></code>, the centrifugal acceleration <code class="docutils literal notranslate"><span class="pre">w_WP</span> <span class="pre">x</span> <span class="pre">w_WP</span> <span class="pre">x</span> <span class="pre">p_PB</span></code>, the
Coriolis acceleration <code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">*</span> <span class="pre">w_WP</span> <span class="pre">x</span> <span class="pre">v_PB</span></code> due to the motion of B in P
and, the additional acceleration of B in P <code class="docutils literal notranslate"><span class="pre">a_PB</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Alternatively, we can write an efficient version of the
centrifugal term <code class="docutils literal notranslate"><span class="pre">ac_WB</span></code> in Eq. (6) for when the velocities of P
and B are available (e.g. from velocity kinematics). This is
accomplished by adding and subtracting v_WP within the
parenthesized term in Eq. (6) and grouping together v_WB = v_WPb +
v_PB = v_WP + w_WP x p_PB + v_PB:</p>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ac_WB</span> <span class="o">=</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="p">(</span><span class="n">v_WB</span> <span class="o">-</span> <span class="n">v_WP</span><span class="p">)</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">v_PB</span>
        <span class="o">=</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="p">(</span><span class="n">v_WB</span> <span class="o">-</span> <span class="n">v_WP</span> <span class="o">+</span> <span class="n">v_PB</span><span class="p">)</span>                               <span class="p">(</span><span class="mi">6</span><span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>which simplifies the expression from three cross products to one.</p>
<ul class="simple">
<li>Rotational acceleration component *</li>
</ul>
<p>The rotational velocity <code class="docutils literal notranslate"><span class="pre">w_WB</span></code> of frame B in W corresponds to the
rotational component in Eq. (1):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">w_WB</span> <span class="o">=</span> <span class="n">w_WP</span> <span class="o">+</span> <span class="n">w_PB</span>                                                <span class="p">(</span><span class="mi">8</span><span class="p">)</span>
</pre></div>
</div>
<p>Therefore, the rotational acceleration of B in W corresponds to:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">alpha_WB</span> <span class="o">=</span> <span class="n">DtW</span><span class="p">(</span><span class="n">w_WB</span><span class="p">)</span> <span class="o">=</span> <span class="n">DtW</span><span class="p">(</span><span class="n">w_WP</span><span class="p">)</span> <span class="o">+</span> <span class="n">DtW</span><span class="p">(</span><span class="n">w_PB</span><span class="p">)</span>
           <span class="o">=</span> <span class="n">alpha_WP</span> <span class="o">+</span> <span class="n">DtW</span><span class="p">(</span><span class="n">w_PB</span><span class="p">)</span>                                   <span class="p">(</span><span class="mi">9</span><span class="p">)</span>
</pre></div>
</div>
<p>where the last term in Eq. (9) can be converted to a time derivative
in P as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">DtW</span><span class="p">(</span><span class="n">w_PB</span><span class="p">)</span> <span class="o">=</span> <span class="n">DtP</span><span class="p">(</span><span class="n">w_PB</span><span class="p">)</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">w_PB</span> <span class="o">=</span> <span class="n">alpha_PB</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">w_PB</span>      <span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">alpha_PB</span> <span class="pre">=</span> <span class="pre">DtP(w_PB)</span></code> by definition. Thus, the final
expression for <code class="docutils literal notranslate"><span class="pre">alpha_WB</span></code> is obtained by using Eq. (10) into Eq.
(9):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">alpha_WB</span> <span class="o">=</span> <span class="n">alpha_WP</span> <span class="o">+</span> <span class="n">alpha_PB</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">w_PB</span>                      <span class="p">(</span><span class="mi">11</span><span class="p">)</span>
</pre></div>
</div>
<p>Equation (11) shows that angular accelerations cannot be simply added
as angular velocities can but there exists an additional term <code class="docutils literal notranslate"><span class="pre">w_WP</span> <span class="pre">x</span>
<span class="pre">w_PB</span></code>.</p>
<ul class="simple">
<li>The spatial acceleration *</li>
</ul>
<p>The rotational and translational components of the spatial
acceleration are given by Eqs. (11) and (6) respectively:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">A_WB</span><span class="o">.</span><span class="n">rotational</span><span class="p">()</span> <span class="o">=</span> <span class="n">alpha_WB</span>
                    <span class="o">=</span> <span class="p">{</span><span class="n">alpha_WP</span><span class="p">}</span> <span class="o">+</span> <span class="n">alpha_PB</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">w_PB</span>           <span class="p">(</span><span class="mi">12</span><span class="p">)</span>
  <span class="n">A_WB</span><span class="o">.</span><span class="n">translational</span><span class="p">()</span> <span class="o">=</span> <span class="n">a_WB</span>
                       <span class="o">=</span> <span class="p">{</span><span class="n">a_WP</span> <span class="o">+</span> <span class="n">alpha_WP</span> <span class="n">x</span> <span class="n">p_PB</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">p_PB</span><span class="p">}</span>
                       <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">v_PB</span> <span class="o">+</span> <span class="n">a_PB</span>                     <span class="p">(</span><span class="mi">13</span><span class="p">)</span>
</pre></div>
</div>
<p>where we have placed within curly brackets <code class="docutils literal notranslate"><span class="pre">{}</span></code> all the terms that
also appear in the Shift() operation, which is equivalent to this
method when <code class="docutils literal notranslate"><span class="pre">V_PB</span></code> and <code class="docutils literal notranslate"><span class="pre">A_PB</span></code> are both zero. In the equations
above <code class="docutils literal notranslate"><span class="pre">alpha_WP</span> <span class="pre">=</span> <span class="pre">A_WP.rotational()</span></code> and <code class="docutils literal notranslate"><span class="pre">a_WP</span> <span class="pre">=</span>
<span class="pre">A_WP.translational()</span></code>. The above expression can be written in a more
compact form in terms of the rigid shift operator <code class="docutils literal notranslate"><span class="pre">Φᵀ(p_PB)</span></code> (see
SpatialVelocity::Shift()) as presented in the main body of this
documentation:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">A_WB</span> <span class="o">=</span> <span class="n">Φᵀ</span><span class="p">(</span><span class="n">p_PB</span><span class="p">)</span><span class="n">A_WP</span> <span class="o">+</span> <span class="n">Ac_WB</span><span class="p">(</span><span class="n">w_WP</span><span class="p">,</span> <span class="n">V_PB</span><span class="p">)</span> <span class="o">+</span> <span class="n">A_PB_W</span>                  <span class="p">(</span><span class="mi">14</span><span class="p">)</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">Ac_WB(w_WP,</span> <span class="pre">V_PB)</span></code> contains the centrifugal and Coriolis
terms:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Ac_WB</span><span class="p">(</span><span class="n">w_WP</span><span class="p">,</span> <span class="n">V_PB</span><span class="p">)</span> <span class="o">=</span> <span class="o">|</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">w_PB_W</span>                          <span class="o">|</span>
                      <span class="o">|</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">p_PB_W</span> <span class="o">+</span> <span class="mi">2</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">v_PB_W</span> <span class="o">|</span>
                                  <span class="o">^^^</span>                <span class="o">^^^</span>
                              <span class="n">centrifugal</span>         <span class="n">Coriolis</span>
</pre></div>
</div>
<p>As usual, for computation, all quantities above must be expressed in a
common frame E; we add an <code class="docutils literal notranslate"><span class="pre">_E</span></code> suffix to each symbol to indicate
that.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_[float].get_coeffs">
<code class="descname">get_coeffs</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialAcceleration_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[6, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_[float].get_coeffs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to the underlying storage.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_[float].Rotate">
<code class="descname">Rotate</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialAcceleration_[float], R_FE: pydrake.math.RotationMatrix_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialAcceleration_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_[float].Rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides a Python-only implementation of rotating / re-expressing a
spatial vector.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is done because defining <code class="docutils literal notranslate"><span class="pre">__rmatmul__</span></code> on this class does
not disambiguate against the definitions of
<code class="docutils literal notranslate"><span class="pre">RotationMatrix.__matmul__</span></code>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_[float].rotational">
<code class="descname">rotational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialAcceleration_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_[float].rotational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the rotational component of this spatial vector.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_[float].SetZero">
<code class="descname">SetZero</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialAcceleration_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialAcceleration_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_[float].SetZero" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets both rotational and translational components of <code class="docutils literal notranslate"><span class="pre">this</span></code>
SpatialVector to zero.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_[float].Shift">
<code class="descname">Shift</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_[float].Shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>Shift(self: pydrake.multibody.math.SpatialAcceleration_[float], p_PoQ_E: numpy.ndarray[numpy.float64[3, 1]], w_WP_E: numpy.ndarray[numpy.float64[3, 1]]) -&gt; pydrake.multibody.math.SpatialAcceleration_[float]</li>
</ol>
<p>Shifts <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial acceleration <code class="docutils literal notranslate"><span class="pre">A_WP</span></code> of a frame P into the
spatial acceleration <code class="docutils literal notranslate"><span class="pre">A_WPq</span></code> of a frame <code class="docutils literal notranslate"><span class="pre">Pq</span></code> which is an offset
frame rigidly aligned with P, but with its origin shifted to a point Q
by an offset p_PoQ. Frame <code class="docutils literal notranslate"><span class="pre">Pq</span></code> is instantaneously moving together
with frame P as if rigidly attached to it. As an example of
application, this operation can be used to compute <code class="docutils literal notranslate"><span class="pre">A_WPq</span></code> where P
is a frame on a rigid body and Q is another point on that same body.
Therefore P and <code class="docutils literal notranslate"><span class="pre">Pq</span></code> move together with the spatial velocity
<code class="docutils literal notranslate"><span class="pre">V_PPq</span></code> being zero at all times. This is an alternate signature for
shifting a spatial acceleration that does not change the original
object. See ShiftInPlace() for more information and a description of
the arguments.</p>
<ol class="arabic simple" start="2">
<li>Shift(self: pydrake.multibody.math.SpatialAcceleration_[float], p_PoQ_E: numpy.ndarray[numpy.float64[3, 1]]) -&gt; pydrake.multibody.math.SpatialAcceleration_[float]</li>
</ol>
<p>(Advanced) Given <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial acceleration <code class="docutils literal notranslate"><span class="pre">A_WP</span></code> of a frame P
in a second frame W, this operation is only valid when the angular
velocity <code class="docutils literal notranslate"><span class="pre">w_WP</span></code> of P in W is zero. Refer to Shift(const Vector3&lt;T&gt;&amp;,
const Vector3&lt;T&gt;&amp;) for the full version that includes velocity terms.
This method can be used to avoid unnecessary computation when shifting
<code class="docutils literal notranslate"><span class="pre">this</span></code> spatial acceleration of a frame P into the spatial
acceleration of the shifted frame <code class="docutils literal notranslate"><span class="pre">Pq</span></code>. The shift position vector is
given by <code class="docutils literal notranslate"><span class="pre">p_PoQ_E</span></code>, expresssed in the same frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code>
spatial` acceleration. Mathematically, this returns <code class="docutils literal notranslate"><span class="pre">A_WPq</span> <span class="pre">=</span>
<span class="pre">Φᵀ(p_PoQ)A_WP</span></code>, where <code class="docutils literal notranslate"><span class="pre">Φ(p_PoQ)</span></code> is the rigid shift operator, see
SpatialVelocity::Shift().</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_[float].translational">
<code class="descname">translational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialAcceleration_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_[float].translational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the translational component of this spatial vector.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.math.SpatialAcceleration_[float].Zero">
<em class="property">static </em><code class="descname">Zero</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialAcceleration_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_[float].Zero" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory to create a <em>zero</em> SpatialVector, i.e. rotational and
translational components are both zero.</p>
</dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.math.SpatialForce">
<code class="descclassname">pydrake.multibody.math.</code><code class="descname">SpatialForce</code><a class="headerlink" href="#pydrake.multibody.math.SpatialForce" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pydrake.multibody.math.SpatialForce_[float]" title="pydrake.multibody.math.SpatialForce_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.math.SpatialForce_[float]</span></code></a></p>
</dd></dl>

<dl class="template">
<dt id="pydrake.multibody.math.SpatialForce_">
<em class="property">template </em><code class="descclassname">pydrake.multibody.math.</code><code class="descname">SpatialForce_</code><a class="headerlink" href="#pydrake.multibody.math.SpatialForce_" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.multibody.math.SpatialForce_[float]" title="pydrake.multibody.math.SpatialForce_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">SpatialForce_[float]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.math.SpatialForce_[AutoDiffXd]" title="pydrake.multibody.math.SpatialForce_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">SpatialForce_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.math.SpatialForce_[Expression]" title="pydrake.multibody.math.SpatialForce_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">SpatialForce_[Expression]</span></code></a></p>
<dl class="class">
<dt id="pydrake.multibody.math.SpatialForce_.SpatialForce_[float]">
<em class="property">class </em><code class="descname">SpatialForce_[float]</code><a class="headerlink" href="#pydrake.multibody.math.SpatialForce_.SpatialForce_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>This class is used to represent a <em>spatial force</em> (also called a
<em>wrench</em>) that combines both rotational (torque) and translational
force components. Spatial forces are 6-element quantities that are
pairs of ordinary 3-vectors. Elements 0-2 are the torque component
while elements 3-5 are the force component. Both vectors must be
expressed in the same frame, and the translational force is applied to
a particular point of a body, but neither the frame nor the point are
stored with a SpatialForce object; they must be understood from
context. It is the responsibility of the user to keep track of the
application point and the expressed-in frame. That is best
accomplished through disciplined notation. In source code we use
monogram notation where capital F is used to designate a spatial force
quantity. We write a point P fixed to body (or frame) B as <span class="math notranslate nohighlight">\(B_P\)</span>
which appears in code and comments as <code class="docutils literal notranslate"><span class="pre">Bp</span></code>. Then we write a
particular spatial force as <code class="docutils literal notranslate"><span class="pre">F_Bp_E</span></code> where the <code class="docutils literal notranslate"><span class="pre">_E</span></code> suffix
indicates that the expressed-in frame is E. This symbol represents a
torque applied to body B, and a force applied to point P on B, with
both vectors expressed in E. Very often the application point will be
the body origin <code class="docutils literal notranslate"><span class="pre">Bo</span></code>; if no point is shown the origin is understood,
so <code class="docutils literal notranslate"><span class="pre">F_B_E</span></code> means <code class="docutils literal notranslate"><span class="pre">F_Bo_E</span></code>. For a more detailed introduction on
spatial vectors and the monogram notation please refer to section
multibody_spatial_vectors.</p>
<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_.SpatialForce_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.math.SpatialForce_.SpatialForce_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialForce_[float]) -&gt; None</p>
<blockquote>
<div><p>Constructs to all NaNs.</p>
<dl class="docutils">
<dt>Note:</dt>
<dd><p class="first last">This is different from C++, which in Release builds may leave memory
uninitialized. In pydrake, the function call overhead already trumps
any overhead from NAN-initialization, so we err on the side of
safety.</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialForce_[float], tau: numpy.ndarray[numpy.float64[3, 1]], f: numpy.ndarray[numpy.float64[3, 1]]) -&gt; None</p>
</li>
</ol>
<p>SpatialForce constructor from a torque <code class="docutils literal notranslate"><span class="pre">tau</span></code> and a force <code class="docutils literal notranslate"><span class="pre">f</span></code>.</p>
<ol class="arabic simple" start="3">
<li>__init__(self: pydrake.multibody.math.SpatialForce_[float], F: numpy.ndarray[numpy.float64[6, 1]]) -&gt; None</li>
</ol>
<p>SpatialForce constructor from an Eigen expression that represents a
six-dimensional vector. This constructor will assert the size of F is
six (6) at compile-time for fixed sized Eigen expressions and at
run-time for dynamic sized Eigen expressions.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_.SpatialForce_[float].dot">
<code class="descname">dot</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.math.SpatialForce_.SpatialForce_[float].dot" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>dot(self: pydrake.multibody.math.SpatialForce_[float], velocity: pydrake.multibody.math.SpatialVelocity_[float]) -&gt; float</li>
</ol>
<p>Calculates the power generated by a spatial force. For an arbitrary
frame B, calculates the dot-product of <code class="docutils literal notranslate"><span class="pre">this</span></code> = F_B_E (frame B’s
spatial force, expressed in frame E) with V_MB_E (frame B’s spatial
velocity measured in a frame M, expressed in a frame E).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">velocity</span></code>:</dt>
<dd>which is V_MB_E, frame B’s spatial velocity measured in frame M,
expressed in the same frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code> = F_B_E.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Power of spatial force F_B_E in frame M, i.e., F_B_E ⋅ V_MB_E.</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Just as equating force 𝐅 to mass * acceleration as 𝐅 = m𝐚 relies
on acceleration 𝐚 being measured in a world frame (also called an
inertial or Newtonian frame), equating power = dK/dt (where K is
kinetic energy) relies on K being measured in a world frame.
Hence, it is unusual to use this method unless frame M is the
world frame W.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Although the spatial vectors F_B_E and V_MB_E must have the same
expressed-in frame E, the returned scalar is independent of frame
E.</p>
</div>
<ol class="arabic simple" start="2">
<li>dot(self: pydrake.multibody.math.SpatialForce_[float], V_IBp_E: pydrake.multibody.math.SpatialVelocity_[float]) -&gt; float</li>
</ol>
<p>dot(V_IBp_E) is deprecated, and will be removed on or around2022-06-01. Please use dot(velocity) instead.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_.SpatialForce_[float].get_coeffs">
<code class="descname">get_coeffs</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialForce_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[6, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialForce_.SpatialForce_[float].get_coeffs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to the underlying storage.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_.SpatialForce_[float].Rotate">
<code class="descname">Rotate</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialForce_[float], R_FE: pydrake.math.RotationMatrix_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialForce_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialForce_.SpatialForce_[float].Rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides a Python-only implementation of rotating / re-expressing a
spatial vector.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is done because defining <code class="docutils literal notranslate"><span class="pre">__rmatmul__</span></code> on this class does
not disambiguate against the definitions of
<code class="docutils literal notranslate"><span class="pre">RotationMatrix.__matmul__</span></code>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_.SpatialForce_[float].rotational">
<code class="descname">rotational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialForce_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialForce_.SpatialForce_[float].rotational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the rotational component of this spatial vector.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_.SpatialForce_[float].SetZero">
<code class="descname">SetZero</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialForce_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialForce_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialForce_.SpatialForce_[float].SetZero" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets both rotational and translational components of <code class="docutils literal notranslate"><span class="pre">this</span></code>
SpatialVector to zero.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_.SpatialForce_[float].Shift">
<code class="descname">Shift</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialForce_[float], p_BpBq_E: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialForce_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialForce_.SpatialForce_[float].Shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Shift of a SpatialForce from one application point to another. This is
an alternate signature for shifting a spatial force’s application
point that does not change the original object. See ShiftInPlace() for
more information.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BpBq_E</span></code>:</dt>
<dd>Shift vector from point P of body B to point Q of B, expressed in
frame E. The “from” point <code class="docutils literal notranslate"><span class="pre">Bp</span></code> must be the current application
point of <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial force, and E must be the same
expressed-in frame as for this spatial force.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">F_Bq_E</span></code>:</dt>
<dd>The equivalent shifted spatial force, now applied at point Q
rather than P.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">ShiftInPlace() to compute the shifted spatial force in-place
modifying the original object.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_.SpatialForce_[float].translational">
<code class="descname">translational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialForce_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialForce_.SpatialForce_[float].translational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the translational component of this spatial vector.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.math.SpatialForce_.SpatialForce_[float].Zero">
<em class="property">static </em><code class="descname">Zero</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialForce_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialForce_.SpatialForce_[float].Zero" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory to create a <em>zero</em> SpatialVector, i.e. rotational and
translational components are both zero.</p>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.math.SpatialForce_[AutoDiffXd]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.math.</code><code class="descname">SpatialForce_[AutoDiffXd]</code><a class="headerlink" href="#pydrake.multibody.math.SpatialForce_[AutoDiffXd]" title="Permalink to this definition">¶</a></dt>
<dd><p>This class is used to represent a <em>spatial force</em> (also called a
<em>wrench</em>) that combines both rotational (torque) and translational
force components. Spatial forces are 6-element quantities that are
pairs of ordinary 3-vectors. Elements 0-2 are the torque component
while elements 3-5 are the force component. Both vectors must be
expressed in the same frame, and the translational force is applied to
a particular point of a body, but neither the frame nor the point are
stored with a SpatialForce object; they must be understood from
context. It is the responsibility of the user to keep track of the
application point and the expressed-in frame. That is best
accomplished through disciplined notation. In source code we use
monogram notation where capital F is used to designate a spatial force
quantity. We write a point P fixed to body (or frame) B as <span class="math notranslate nohighlight">\(B_P\)</span>
which appears in code and comments as <code class="docutils literal notranslate"><span class="pre">Bp</span></code>. Then we write a
particular spatial force as <code class="docutils literal notranslate"><span class="pre">F_Bp_E</span></code> where the <code class="docutils literal notranslate"><span class="pre">_E</span></code> suffix
indicates that the expressed-in frame is E. This symbol represents a
torque applied to body B, and a force applied to point P on B, with
both vectors expressed in E. Very often the application point will be
the body origin <code class="docutils literal notranslate"><span class="pre">Bo</span></code>; if no point is shown the origin is understood,
so <code class="docutils literal notranslate"><span class="pre">F_B_E</span></code> means <code class="docutils literal notranslate"><span class="pre">F_Bo_E</span></code>. For a more detailed introduction on
spatial vectors and the monogram notation please refer to section
multibody_spatial_vectors.</p>
<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_[AutoDiffXd].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.math.SpatialForce_[AutoDiffXd].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialForce_[AutoDiffXd]) -&gt; None</p>
<blockquote>
<div><p>Constructs to all NaNs.</p>
<dl class="docutils">
<dt>Note:</dt>
<dd><p class="first last">This is different from C++, which in Release builds may leave memory
uninitialized. In pydrake, the function call overhead already trumps
any overhead from NAN-initialization, so we err on the side of
safety.</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialForce_[AutoDiffXd], tau: numpy.ndarray[object[3, 1]], f: numpy.ndarray[object[3, 1]]) -&gt; None</p>
</li>
</ol>
<p>SpatialForce constructor from a torque <code class="docutils literal notranslate"><span class="pre">tau</span></code> and a force <code class="docutils literal notranslate"><span class="pre">f</span></code>.</p>
<ol class="arabic simple" start="3">
<li>__init__(self: pydrake.multibody.math.SpatialForce_[AutoDiffXd], F: numpy.ndarray[object[6, 1]]) -&gt; None</li>
</ol>
<p>SpatialForce constructor from an Eigen expression that represents a
six-dimensional vector. This constructor will assert the size of F is
six (6) at compile-time for fixed sized Eigen expressions and at
run-time for dynamic sized Eigen expressions.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_[AutoDiffXd].dot">
<code class="descname">dot</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.math.SpatialForce_[AutoDiffXd].dot" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>dot(self: pydrake.multibody.math.SpatialForce_[AutoDiffXd], velocity: pydrake.multibody.math.SpatialVelocity_[AutoDiffXd]) -&gt; pydrake.autodiffutils.AutoDiffXd</li>
</ol>
<p>Calculates the power generated by a spatial force. For an arbitrary
frame B, calculates the dot-product of <code class="docutils literal notranslate"><span class="pre">this</span></code> = F_B_E (frame B’s
spatial force, expressed in frame E) with V_MB_E (frame B’s spatial
velocity measured in a frame M, expressed in a frame E).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">velocity</span></code>:</dt>
<dd>which is V_MB_E, frame B’s spatial velocity measured in frame M,
expressed in the same frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code> = F_B_E.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Power of spatial force F_B_E in frame M, i.e., F_B_E ⋅ V_MB_E.</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Just as equating force 𝐅 to mass * acceleration as 𝐅 = m𝐚 relies
on acceleration 𝐚 being measured in a world frame (also called an
inertial or Newtonian frame), equating power = dK/dt (where K is
kinetic energy) relies on K being measured in a world frame.
Hence, it is unusual to use this method unless frame M is the
world frame W.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Although the spatial vectors F_B_E and V_MB_E must have the same
expressed-in frame E, the returned scalar is independent of frame
E.</p>
</div>
<ol class="arabic simple" start="2">
<li>dot(self: pydrake.multibody.math.SpatialForce_[AutoDiffXd], V_IBp_E: pydrake.multibody.math.SpatialVelocity_[AutoDiffXd]) -&gt; pydrake.autodiffutils.AutoDiffXd</li>
</ol>
<p>dot(V_IBp_E) is deprecated, and will be removed on or around2022-06-01. Please use dot(velocity) instead.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_[AutoDiffXd].get_coeffs">
<code class="descname">get_coeffs</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialForce_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[6, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialForce_[AutoDiffXd].get_coeffs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to the underlying storage.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_[AutoDiffXd].Rotate">
<code class="descname">Rotate</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialForce_[AutoDiffXd], R_FE: pydrake.math.RotationMatrix_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialForce_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.math.SpatialForce_[AutoDiffXd].Rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides a Python-only implementation of rotating / re-expressing a
spatial vector.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is done because defining <code class="docutils literal notranslate"><span class="pre">__rmatmul__</span></code> on this class does
not disambiguate against the definitions of
<code class="docutils literal notranslate"><span class="pre">RotationMatrix.__matmul__</span></code>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_[AutoDiffXd].rotational">
<code class="descname">rotational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialForce_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialForce_[AutoDiffXd].rotational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the rotational component of this spatial vector.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_[AutoDiffXd].SetZero">
<code class="descname">SetZero</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialForce_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialForce_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.math.SpatialForce_[AutoDiffXd].SetZero" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets both rotational and translational components of <code class="docutils literal notranslate"><span class="pre">this</span></code>
SpatialVector to zero.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_[AutoDiffXd].Shift">
<code class="descname">Shift</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialForce_[AutoDiffXd], p_BpBq_E: numpy.ndarray[object[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialForce_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.math.SpatialForce_[AutoDiffXd].Shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Shift of a SpatialForce from one application point to another. This is
an alternate signature for shifting a spatial force’s application
point that does not change the original object. See ShiftInPlace() for
more information.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BpBq_E</span></code>:</dt>
<dd>Shift vector from point P of body B to point Q of B, expressed in
frame E. The “from” point <code class="docutils literal notranslate"><span class="pre">Bp</span></code> must be the current application
point of <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial force, and E must be the same
expressed-in frame as for this spatial force.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">F_Bq_E</span></code>:</dt>
<dd>The equivalent shifted spatial force, now applied at point Q
rather than P.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">ShiftInPlace() to compute the shifted spatial force in-place
modifying the original object.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_[AutoDiffXd].translational">
<code class="descname">translational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialForce_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialForce_[AutoDiffXd].translational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the translational component of this spatial vector.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.math.SpatialForce_[AutoDiffXd].Zero">
<em class="property">static </em><code class="descname">Zero</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialForce_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.math.SpatialForce_[AutoDiffXd].Zero" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory to create a <em>zero</em> SpatialVector, i.e. rotational and
translational components are both zero.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.math.SpatialForce_[Expression]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.math.</code><code class="descname">SpatialForce_[Expression]</code><a class="headerlink" href="#pydrake.multibody.math.SpatialForce_[Expression]" title="Permalink to this definition">¶</a></dt>
<dd><p>This class is used to represent a <em>spatial force</em> (also called a
<em>wrench</em>) that combines both rotational (torque) and translational
force components. Spatial forces are 6-element quantities that are
pairs of ordinary 3-vectors. Elements 0-2 are the torque component
while elements 3-5 are the force component. Both vectors must be
expressed in the same frame, and the translational force is applied to
a particular point of a body, but neither the frame nor the point are
stored with a SpatialForce object; they must be understood from
context. It is the responsibility of the user to keep track of the
application point and the expressed-in frame. That is best
accomplished through disciplined notation. In source code we use
monogram notation where capital F is used to designate a spatial force
quantity. We write a point P fixed to body (or frame) B as <span class="math notranslate nohighlight">\(B_P\)</span>
which appears in code and comments as <code class="docutils literal notranslate"><span class="pre">Bp</span></code>. Then we write a
particular spatial force as <code class="docutils literal notranslate"><span class="pre">F_Bp_E</span></code> where the <code class="docutils literal notranslate"><span class="pre">_E</span></code> suffix
indicates that the expressed-in frame is E. This symbol represents a
torque applied to body B, and a force applied to point P on B, with
both vectors expressed in E. Very often the application point will be
the body origin <code class="docutils literal notranslate"><span class="pre">Bo</span></code>; if no point is shown the origin is understood,
so <code class="docutils literal notranslate"><span class="pre">F_B_E</span></code> means <code class="docutils literal notranslate"><span class="pre">F_Bo_E</span></code>. For a more detailed introduction on
spatial vectors and the monogram notation please refer to section
multibody_spatial_vectors.</p>
<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_[Expression].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.math.SpatialForce_[Expression].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialForce_[Expression]) -&gt; None</p>
<blockquote>
<div><p>Constructs to all NaNs.</p>
<dl class="docutils">
<dt>Note:</dt>
<dd><p class="first last">This is different from C++, which in Release builds may leave memory
uninitialized. In pydrake, the function call overhead already trumps
any overhead from NAN-initialization, so we err on the side of
safety.</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialForce_[Expression], tau: numpy.ndarray[object[3, 1]], f: numpy.ndarray[object[3, 1]]) -&gt; None</p>
</li>
</ol>
<p>SpatialForce constructor from a torque <code class="docutils literal notranslate"><span class="pre">tau</span></code> and a force <code class="docutils literal notranslate"><span class="pre">f</span></code>.</p>
<ol class="arabic simple" start="3">
<li>__init__(self: pydrake.multibody.math.SpatialForce_[Expression], F: numpy.ndarray[object[6, 1]]) -&gt; None</li>
</ol>
<p>SpatialForce constructor from an Eigen expression that represents a
six-dimensional vector. This constructor will assert the size of F is
six (6) at compile-time for fixed sized Eigen expressions and at
run-time for dynamic sized Eigen expressions.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_[Expression].dot">
<code class="descname">dot</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.math.SpatialForce_[Expression].dot" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>dot(self: pydrake.multibody.math.SpatialForce_[Expression], velocity: pydrake.multibody.math.SpatialVelocity_[Expression]) -&gt; pydrake.symbolic.Expression</li>
</ol>
<p>Calculates the power generated by a spatial force. For an arbitrary
frame B, calculates the dot-product of <code class="docutils literal notranslate"><span class="pre">this</span></code> = F_B_E (frame B’s
spatial force, expressed in frame E) with V_MB_E (frame B’s spatial
velocity measured in a frame M, expressed in a frame E).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">velocity</span></code>:</dt>
<dd>which is V_MB_E, frame B’s spatial velocity measured in frame M,
expressed in the same frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code> = F_B_E.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Power of spatial force F_B_E in frame M, i.e., F_B_E ⋅ V_MB_E.</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Just as equating force 𝐅 to mass * acceleration as 𝐅 = m𝐚 relies
on acceleration 𝐚 being measured in a world frame (also called an
inertial or Newtonian frame), equating power = dK/dt (where K is
kinetic energy) relies on K being measured in a world frame.
Hence, it is unusual to use this method unless frame M is the
world frame W.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Although the spatial vectors F_B_E and V_MB_E must have the same
expressed-in frame E, the returned scalar is independent of frame
E.</p>
</div>
<ol class="arabic simple" start="2">
<li>dot(self: pydrake.multibody.math.SpatialForce_[Expression], V_IBp_E: pydrake.multibody.math.SpatialVelocity_[Expression]) -&gt; pydrake.symbolic.Expression</li>
</ol>
<p>dot(V_IBp_E) is deprecated, and will be removed on or around2022-06-01. Please use dot(velocity) instead.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_[Expression].get_coeffs">
<code class="descname">get_coeffs</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialForce_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[6, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialForce_[Expression].get_coeffs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to the underlying storage.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_[Expression].Rotate">
<code class="descname">Rotate</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialForce_[Expression], R_FE: pydrake.math.RotationMatrix_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialForce_[Expression]<a class="headerlink" href="#pydrake.multibody.math.SpatialForce_[Expression].Rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides a Python-only implementation of rotating / re-expressing a
spatial vector.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is done because defining <code class="docutils literal notranslate"><span class="pre">__rmatmul__</span></code> on this class does
not disambiguate against the definitions of
<code class="docutils literal notranslate"><span class="pre">RotationMatrix.__matmul__</span></code>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_[Expression].rotational">
<code class="descname">rotational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialForce_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialForce_[Expression].rotational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the rotational component of this spatial vector.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_[Expression].SetZero">
<code class="descname">SetZero</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialForce_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialForce_[Expression]<a class="headerlink" href="#pydrake.multibody.math.SpatialForce_[Expression].SetZero" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets both rotational and translational components of <code class="docutils literal notranslate"><span class="pre">this</span></code>
SpatialVector to zero.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_[Expression].Shift">
<code class="descname">Shift</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialForce_[Expression], p_BpBq_E: numpy.ndarray[object[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialForce_[Expression]<a class="headerlink" href="#pydrake.multibody.math.SpatialForce_[Expression].Shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Shift of a SpatialForce from one application point to another. This is
an alternate signature for shifting a spatial force’s application
point that does not change the original object. See ShiftInPlace() for
more information.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BpBq_E</span></code>:</dt>
<dd>Shift vector from point P of body B to point Q of B, expressed in
frame E. The “from” point <code class="docutils literal notranslate"><span class="pre">Bp</span></code> must be the current application
point of <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial force, and E must be the same
expressed-in frame as for this spatial force.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">F_Bq_E</span></code>:</dt>
<dd>The equivalent shifted spatial force, now applied at point Q
rather than P.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">ShiftInPlace() to compute the shifted spatial force in-place
modifying the original object.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_[Expression].translational">
<code class="descname">translational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialForce_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialForce_[Expression].translational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the translational component of this spatial vector.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.math.SpatialForce_[Expression].Zero">
<em class="property">static </em><code class="descname">Zero</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialForce_[Expression]<a class="headerlink" href="#pydrake.multibody.math.SpatialForce_[Expression].Zero" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory to create a <em>zero</em> SpatialVector, i.e. rotational and
translational components are both zero.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.math.SpatialForce_[float]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.math.</code><code class="descname">SpatialForce_[float]</code><a class="headerlink" href="#pydrake.multibody.math.SpatialForce_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>This class is used to represent a <em>spatial force</em> (also called a
<em>wrench</em>) that combines both rotational (torque) and translational
force components. Spatial forces are 6-element quantities that are
pairs of ordinary 3-vectors. Elements 0-2 are the torque component
while elements 3-5 are the force component. Both vectors must be
expressed in the same frame, and the translational force is applied to
a particular point of a body, but neither the frame nor the point are
stored with a SpatialForce object; they must be understood from
context. It is the responsibility of the user to keep track of the
application point and the expressed-in frame. That is best
accomplished through disciplined notation. In source code we use
monogram notation where capital F is used to designate a spatial force
quantity. We write a point P fixed to body (or frame) B as <span class="math notranslate nohighlight">\(B_P\)</span>
which appears in code and comments as <code class="docutils literal notranslate"><span class="pre">Bp</span></code>. Then we write a
particular spatial force as <code class="docutils literal notranslate"><span class="pre">F_Bp_E</span></code> where the <code class="docutils literal notranslate"><span class="pre">_E</span></code> suffix
indicates that the expressed-in frame is E. This symbol represents a
torque applied to body B, and a force applied to point P on B, with
both vectors expressed in E. Very often the application point will be
the body origin <code class="docutils literal notranslate"><span class="pre">Bo</span></code>; if no point is shown the origin is understood,
so <code class="docutils literal notranslate"><span class="pre">F_B_E</span></code> means <code class="docutils literal notranslate"><span class="pre">F_Bo_E</span></code>. For a more detailed introduction on
spatial vectors and the monogram notation please refer to section
multibody_spatial_vectors.</p>
<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.math.SpatialForce_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialForce_[float]) -&gt; None</p>
<blockquote>
<div><p>Constructs to all NaNs.</p>
<dl class="docutils">
<dt>Note:</dt>
<dd><p class="first last">This is different from C++, which in Release builds may leave memory
uninitialized. In pydrake, the function call overhead already trumps
any overhead from NAN-initialization, so we err on the side of
safety.</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialForce_[float], tau: numpy.ndarray[numpy.float64[3, 1]], f: numpy.ndarray[numpy.float64[3, 1]]) -&gt; None</p>
</li>
</ol>
<p>SpatialForce constructor from a torque <code class="docutils literal notranslate"><span class="pre">tau</span></code> and a force <code class="docutils literal notranslate"><span class="pre">f</span></code>.</p>
<ol class="arabic simple" start="3">
<li>__init__(self: pydrake.multibody.math.SpatialForce_[float], F: numpy.ndarray[numpy.float64[6, 1]]) -&gt; None</li>
</ol>
<p>SpatialForce constructor from an Eigen expression that represents a
six-dimensional vector. This constructor will assert the size of F is
six (6) at compile-time for fixed sized Eigen expressions and at
run-time for dynamic sized Eigen expressions.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_[float].dot">
<code class="descname">dot</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.math.SpatialForce_[float].dot" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>dot(self: pydrake.multibody.math.SpatialForce_[float], velocity: pydrake.multibody.math.SpatialVelocity_[float]) -&gt; float</li>
</ol>
<p>Calculates the power generated by a spatial force. For an arbitrary
frame B, calculates the dot-product of <code class="docutils literal notranslate"><span class="pre">this</span></code> = F_B_E (frame B’s
spatial force, expressed in frame E) with V_MB_E (frame B’s spatial
velocity measured in a frame M, expressed in a frame E).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">velocity</span></code>:</dt>
<dd>which is V_MB_E, frame B’s spatial velocity measured in frame M,
expressed in the same frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code> = F_B_E.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Power of spatial force F_B_E in frame M, i.e., F_B_E ⋅ V_MB_E.</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Just as equating force 𝐅 to mass * acceleration as 𝐅 = m𝐚 relies
on acceleration 𝐚 being measured in a world frame (also called an
inertial or Newtonian frame), equating power = dK/dt (where K is
kinetic energy) relies on K being measured in a world frame.
Hence, it is unusual to use this method unless frame M is the
world frame W.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Although the spatial vectors F_B_E and V_MB_E must have the same
expressed-in frame E, the returned scalar is independent of frame
E.</p>
</div>
<ol class="arabic simple" start="2">
<li>dot(self: pydrake.multibody.math.SpatialForce_[float], V_IBp_E: pydrake.multibody.math.SpatialVelocity_[float]) -&gt; float</li>
</ol>
<p>dot(V_IBp_E) is deprecated, and will be removed on or around2022-06-01. Please use dot(velocity) instead.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_[float].get_coeffs">
<code class="descname">get_coeffs</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialForce_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[6, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialForce_[float].get_coeffs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to the underlying storage.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_[float].Rotate">
<code class="descname">Rotate</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialForce_[float], R_FE: pydrake.math.RotationMatrix_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialForce_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialForce_[float].Rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides a Python-only implementation of rotating / re-expressing a
spatial vector.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is done because defining <code class="docutils literal notranslate"><span class="pre">__rmatmul__</span></code> on this class does
not disambiguate against the definitions of
<code class="docutils literal notranslate"><span class="pre">RotationMatrix.__matmul__</span></code>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_[float].rotational">
<code class="descname">rotational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialForce_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialForce_[float].rotational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the rotational component of this spatial vector.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_[float].SetZero">
<code class="descname">SetZero</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialForce_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialForce_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialForce_[float].SetZero" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets both rotational and translational components of <code class="docutils literal notranslate"><span class="pre">this</span></code>
SpatialVector to zero.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_[float].Shift">
<code class="descname">Shift</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialForce_[float], p_BpBq_E: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialForce_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialForce_[float].Shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Shift of a SpatialForce from one application point to another. This is
an alternate signature for shifting a spatial force’s application
point that does not change the original object. See ShiftInPlace() for
more information.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BpBq_E</span></code>:</dt>
<dd>Shift vector from point P of body B to point Q of B, expressed in
frame E. The “from” point <code class="docutils literal notranslate"><span class="pre">Bp</span></code> must be the current application
point of <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial force, and E must be the same
expressed-in frame as for this spatial force.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">F_Bq_E</span></code>:</dt>
<dd>The equivalent shifted spatial force, now applied at point Q
rather than P.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">ShiftInPlace() to compute the shifted spatial force in-place
modifying the original object.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_[float].translational">
<code class="descname">translational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialForce_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialForce_[float].translational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the translational component of this spatial vector.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.math.SpatialForce_[float].Zero">
<em class="property">static </em><code class="descname">Zero</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialForce_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialForce_[float].Zero" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory to create a <em>zero</em> SpatialVector, i.e. rotational and
translational components are both zero.</p>
</dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.math.SpatialMomentum">
<code class="descclassname">pydrake.multibody.math.</code><code class="descname">SpatialMomentum</code><a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pydrake.multibody.math.SpatialMomentum_[float]" title="pydrake.multibody.math.SpatialMomentum_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.math.SpatialMomentum_[float]</span></code></a></p>
</dd></dl>

<dl class="template">
<dt id="pydrake.multibody.math.SpatialMomentum_">
<em class="property">template </em><code class="descclassname">pydrake.multibody.math.</code><code class="descname">SpatialMomentum_</code><a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.multibody.math.SpatialMomentum_[float]" title="pydrake.multibody.math.SpatialMomentum_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">SpatialMomentum_[float]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.math.SpatialMomentum_[AutoDiffXd]" title="pydrake.multibody.math.SpatialMomentum_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">SpatialMomentum_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.math.SpatialMomentum_[Expression]" title="pydrake.multibody.math.SpatialMomentum_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">SpatialMomentum_[Expression]</span></code></a></p>
<dl class="class">
<dt id="pydrake.multibody.math.SpatialMomentum_.SpatialMomentum_[float]">
<em class="property">class </em><code class="descname">SpatialMomentum_[float]</code><a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_.SpatialMomentum_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>This class is used to represent the <em>spatial momentum</em> of a particle,
system of particles or body (whether rigid or soft.) The linear
momentum <code class="docutils literal notranslate"><span class="pre">l_NS</span></code> of a system of particles S in a reference frame N is
defined by:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>l_NS = ∑l_NQi = ∑mᵢv_NQi
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">mᵢ</span></code> and <code class="docutils literal notranslate"><span class="pre">v_NQi</span></code> are the mass and linear velocity (in frame
N) of the i-th particle in the system, respectively. Their product
<code class="docutils literal notranslate"><span class="pre">l_NQi</span> <span class="pre">=</span> <span class="pre">mᵢv_NQi</span></code> is the linear momentum of the i-th particle in the
N reference frame. The angular momentum <code class="docutils literal notranslate"><span class="pre">h_NSp</span></code> of a system of
particles S in a reference frame N about an arbitrary point P is
defined by:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>h_NSp = ∑ p_PQi x l_NQi
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">p_PQi</span></code> is the position vector from point P to the i-th
particle position <code class="docutils literal notranslate"><span class="pre">Qi</span></code>. The definitions above extend to a continuum
of particles as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>h_NSp = ∫p_PQ(r) x v_NQ(r) ρ(r)d³r
  l_NS = ∫v_NQ(r) ρ(r)d³r
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">ρ(r)</span></code> is the density of the body at each material location
<code class="docutils literal notranslate"><span class="pre">r</span></code>. In particular, the continuum version above also applies to
rigid bodies.</p>
<p>Spatial momenta are elements of F⁶ (see [Featherstone 2008]) that
combine both rotational (angular momentum) and translational (linear
momentum) components. Spatial momenta are 6-element quantities that
are pairs of ordinary 3-vectors. Elements 0-2 are the angular momentum
component while elements 3-5 are the linear momentum component. As
with any other spatial vector, both vector components must be
expressed in the same frame.</p>
<p>Neither the expressed-in frame nor the about-point are stored with a
SpatialMomentum object; they must be understood from context. It is
the responsibility of the user to keep track of the about-point and
the expressed-in frame. That is best accomplished through disciplined
notation. In source code we use monogram notation where L designates a
spatial momentum quantity. The spatial momentum of a system S in a
frame N about an arbitrary point P, expressed in a frame E is typeset
as <span class="math notranslate nohighlight">\([^NL^{S/P}]_E\)</span>, which appears in code as <code class="docutils literal notranslate"><span class="pre">L_NSP_E</span></code>. The
spatial momentum of a body B in a frame N about the body origin Bo is
explicitly typeset as L_NBBo_E, but we abbreviate it as L_NBo_E.
Similarly, the spatial momentum of a system S in a frame N about Scm
(the system center of mass), expressed in a frame E is explicitly
typeset as L_NSScm_E, but we abbreviate it as L_NScm_E. For a more
detailed introduction on spatial vectors and the monogram notation
please refer to section multibody_spatial_vectors.</p>
<ul class="simple">
<li><dl class="first docutils">
<dt>[Featherstone 2008] Featherstone, R., 2008. Rigid body dynamics</dt>
<dd>algorithms. Springer.</dd>
</dl>
</li>
</ul>
<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_.SpatialMomentum_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_.SpatialMomentum_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialMomentum_[float]) -&gt; None</p>
<blockquote>
<div><p>Constructs to all NaNs.</p>
<dl class="docutils">
<dt>Note:</dt>
<dd><p class="first last">This is different from C++, which in Release builds may leave memory
uninitialized. In pydrake, the function call overhead already trumps
any overhead from NAN-initialization, so we err on the side of
safety.</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialMomentum_[float], h: numpy.ndarray[numpy.float64[3, 1]], l: numpy.ndarray[numpy.float64[3, 1]]) -&gt; None</p>
</li>
</ol>
<p>SpatialMomentum constructor from an angular momentum h and a linear
momentum l.</p>
<ol class="arabic simple" start="3">
<li>__init__(self: pydrake.multibody.math.SpatialMomentum_[float], L: numpy.ndarray[numpy.float64[6, 1]]) -&gt; None</li>
</ol>
<p>SpatialMomentum constructor from an Eigen expression that represents a
six-dimensional vector. This constructor will assert the size of L is
six (6) at compile-time for fixed sized Eigen expressions and at
run-time for dynamic sized Eigen expressions.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_.SpatialMomentum_[float].dot">
<code class="descname">dot</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_.SpatialMomentum_[float].dot" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>dot(self: pydrake.multibody.math.SpatialMomentum_[float], velocity: pydrake.multibody.math.SpatialVelocity_[float]) -&gt; float</li>
</ol>
<p>Calculates twice (2x) a body B’s kinetic energy measured in a frame M.
For any frame (e.g., an multibody_frames_and_bodies “offset frame”) Bp
that is fixed to a rigid body B, calculates the dot-product of
<code class="docutils literal notranslate"><span class="pre">this</span></code> = L_MBp_E (body B’s spatial momentum measured in frame M,
about Bp’s origin, expressed in frame E) with V_MBp_E (frame Bp’s
spatial velocity measured in frame M, expressed in frame E).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">velocity</span></code>:</dt>
<dd>which is V_MBp_E, frame Bp’s spatial velocity measured in frame M,
and expressed in the same frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code> = L_MBp_E.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">2*K_MB, twice (2x) body B’s kinetic energy measured in frame M.</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In general, kinetic energy calculations are only useful when frame
M is a world frame (also called a Newtonian or inertial frame).
Hence, it is unusual to use this method unless frame M is the
world frame W.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Although the spatial vectors V_MBp_E and L_MBp_E must have the
same expressed-in frame E, the resulting scalar K_MB is
independent of frame E.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">As shown below, K_MB can be calculated from any frame Bp fixed on
B, including body B’s center of mass frame Bcm. This is due to how
spatial momentum and spatial velocity shift from Bcm to Bp. For
more information, see SpatialMomentum::Shift() and
SpatialVelocity::Shift().</p>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>K_MB = 1/2 (L_MBp · V_MBp) = 1/2 (L_MBcm · V_MBcm)
</pre></div>
</div>
<ol class="arabic simple" start="2">
<li>dot(self: pydrake.multibody.math.SpatialMomentum_[float], V_IBp_E: pydrake.multibody.math.SpatialVelocity_[float]) -&gt; float</li>
</ol>
<p>dot(V_IBp_E) is deprecated, and will be removed on or around 2022-06-01. Please use dot(velocity) instead.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_.SpatialMomentum_[float].get_coeffs">
<code class="descname">get_coeffs</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialMomentum_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[6, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_.SpatialMomentum_[float].get_coeffs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to the underlying storage.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_.SpatialMomentum_[float].Rotate">
<code class="descname">Rotate</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialMomentum_[float], R_FE: pydrake.math.RotationMatrix_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialMomentum_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_.SpatialMomentum_[float].Rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides a Python-only implementation of rotating / re-expressing a
spatial vector.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is done because defining <code class="docutils literal notranslate"><span class="pre">__rmatmul__</span></code> on this class does
not disambiguate against the definitions of
<code class="docutils literal notranslate"><span class="pre">RotationMatrix.__matmul__</span></code>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_.SpatialMomentum_[float].rotational">
<code class="descname">rotational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialMomentum_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_.SpatialMomentum_[float].rotational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the rotational component of this spatial vector.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_.SpatialMomentum_[float].SetZero">
<code class="descname">SetZero</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialMomentum_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialMomentum_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_.SpatialMomentum_[float].SetZero" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets both rotational and translational components of <code class="docutils literal notranslate"><span class="pre">this</span></code>
SpatialVector to zero.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_.SpatialMomentum_[float].Shift">
<code class="descname">Shift</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialMomentum_[float], p_BpBq_E: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialMomentum_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_.SpatialMomentum_[float].Shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Shift of a SpatialMomentum from one application point to another. This
is an alternate signature for shifting a spatial momentum’s
about-point that does not change the original object. See
ShiftInPlace() for more information.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_PQ_E</span></code>:</dt>
<dd>Shift vector from point P to point Q.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">L_NSq_E</span></code>:</dt>
<dd>The equivalent shifted spatial momentum, now applied at point Q
rather than P.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">ShiftInPlace() to compute the shifted spatial momentum in-place
modifying the original object.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_.SpatialMomentum_[float].translational">
<code class="descname">translational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialMomentum_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_.SpatialMomentum_[float].translational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the translational component of this spatial vector.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.math.SpatialMomentum_.SpatialMomentum_[float].Zero">
<em class="property">static </em><code class="descname">Zero</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialMomentum_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_.SpatialMomentum_[float].Zero" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory to create a <em>zero</em> SpatialVector, i.e. rotational and
translational components are both zero.</p>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.math.SpatialMomentum_[AutoDiffXd]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.math.</code><code class="descname">SpatialMomentum_[AutoDiffXd]</code><a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_[AutoDiffXd]" title="Permalink to this definition">¶</a></dt>
<dd><p>This class is used to represent the <em>spatial momentum</em> of a particle,
system of particles or body (whether rigid or soft.) The linear
momentum <code class="docutils literal notranslate"><span class="pre">l_NS</span></code> of a system of particles S in a reference frame N is
defined by:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>l_NS = ∑l_NQi = ∑mᵢv_NQi
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">mᵢ</span></code> and <code class="docutils literal notranslate"><span class="pre">v_NQi</span></code> are the mass and linear velocity (in frame
N) of the i-th particle in the system, respectively. Their product
<code class="docutils literal notranslate"><span class="pre">l_NQi</span> <span class="pre">=</span> <span class="pre">mᵢv_NQi</span></code> is the linear momentum of the i-th particle in the
N reference frame. The angular momentum <code class="docutils literal notranslate"><span class="pre">h_NSp</span></code> of a system of
particles S in a reference frame N about an arbitrary point P is
defined by:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>h_NSp = ∑ p_PQi x l_NQi
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">p_PQi</span></code> is the position vector from point P to the i-th
particle position <code class="docutils literal notranslate"><span class="pre">Qi</span></code>. The definitions above extend to a continuum
of particles as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>h_NSp = ∫p_PQ(r) x v_NQ(r) ρ(r)d³r
  l_NS = ∫v_NQ(r) ρ(r)d³r
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">ρ(r)</span></code> is the density of the body at each material location
<code class="docutils literal notranslate"><span class="pre">r</span></code>. In particular, the continuum version above also applies to
rigid bodies.</p>
<p>Spatial momenta are elements of F⁶ (see [Featherstone 2008]) that
combine both rotational (angular momentum) and translational (linear
momentum) components. Spatial momenta are 6-element quantities that
are pairs of ordinary 3-vectors. Elements 0-2 are the angular momentum
component while elements 3-5 are the linear momentum component. As
with any other spatial vector, both vector components must be
expressed in the same frame.</p>
<p>Neither the expressed-in frame nor the about-point are stored with a
SpatialMomentum object; they must be understood from context. It is
the responsibility of the user to keep track of the about-point and
the expressed-in frame. That is best accomplished through disciplined
notation. In source code we use monogram notation where L designates a
spatial momentum quantity. The spatial momentum of a system S in a
frame N about an arbitrary point P, expressed in a frame E is typeset
as <span class="math notranslate nohighlight">\([^NL^{S/P}]_E\)</span>, which appears in code as <code class="docutils literal notranslate"><span class="pre">L_NSP_E</span></code>. The
spatial momentum of a body B in a frame N about the body origin Bo is
explicitly typeset as L_NBBo_E, but we abbreviate it as L_NBo_E.
Similarly, the spatial momentum of a system S in a frame N about Scm
(the system center of mass), expressed in a frame E is explicitly
typeset as L_NSScm_E, but we abbreviate it as L_NScm_E. For a more
detailed introduction on spatial vectors and the monogram notation
please refer to section multibody_spatial_vectors.</p>
<ul class="simple">
<li><dl class="first docutils">
<dt>[Featherstone 2008] Featherstone, R., 2008. Rigid body dynamics</dt>
<dd>algorithms. Springer.</dd>
</dl>
</li>
</ul>
<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_[AutoDiffXd].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_[AutoDiffXd].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialMomentum_[AutoDiffXd]) -&gt; None</p>
<blockquote>
<div><p>Constructs to all NaNs.</p>
<dl class="docutils">
<dt>Note:</dt>
<dd><p class="first last">This is different from C++, which in Release builds may leave memory
uninitialized. In pydrake, the function call overhead already trumps
any overhead from NAN-initialization, so we err on the side of
safety.</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialMomentum_[AutoDiffXd], h: numpy.ndarray[object[3, 1]], l: numpy.ndarray[object[3, 1]]) -&gt; None</p>
</li>
</ol>
<p>SpatialMomentum constructor from an angular momentum h and a linear
momentum l.</p>
<ol class="arabic simple" start="3">
<li>__init__(self: pydrake.multibody.math.SpatialMomentum_[AutoDiffXd], L: numpy.ndarray[object[6, 1]]) -&gt; None</li>
</ol>
<p>SpatialMomentum constructor from an Eigen expression that represents a
six-dimensional vector. This constructor will assert the size of L is
six (6) at compile-time for fixed sized Eigen expressions and at
run-time for dynamic sized Eigen expressions.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_[AutoDiffXd].dot">
<code class="descname">dot</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_[AutoDiffXd].dot" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>dot(self: pydrake.multibody.math.SpatialMomentum_[AutoDiffXd], velocity: pydrake.multibody.math.SpatialVelocity_[AutoDiffXd]) -&gt; pydrake.autodiffutils.AutoDiffXd</li>
</ol>
<p>Calculates twice (2x) a body B’s kinetic energy measured in a frame M.
For any frame (e.g., an multibody_frames_and_bodies “offset frame”) Bp
that is fixed to a rigid body B, calculates the dot-product of
<code class="docutils literal notranslate"><span class="pre">this</span></code> = L_MBp_E (body B’s spatial momentum measured in frame M,
about Bp’s origin, expressed in frame E) with V_MBp_E (frame Bp’s
spatial velocity measured in frame M, expressed in frame E).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">velocity</span></code>:</dt>
<dd>which is V_MBp_E, frame Bp’s spatial velocity measured in frame M,
and expressed in the same frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code> = L_MBp_E.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">2*K_MB, twice (2x) body B’s kinetic energy measured in frame M.</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In general, kinetic energy calculations are only useful when frame
M is a world frame (also called a Newtonian or inertial frame).
Hence, it is unusual to use this method unless frame M is the
world frame W.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Although the spatial vectors V_MBp_E and L_MBp_E must have the
same expressed-in frame E, the resulting scalar K_MB is
independent of frame E.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">As shown below, K_MB can be calculated from any frame Bp fixed on
B, including body B’s center of mass frame Bcm. This is due to how
spatial momentum and spatial velocity shift from Bcm to Bp. For
more information, see SpatialMomentum::Shift() and
SpatialVelocity::Shift().</p>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>K_MB = 1/2 (L_MBp · V_MBp) = 1/2 (L_MBcm · V_MBcm)
</pre></div>
</div>
<ol class="arabic simple" start="2">
<li>dot(self: pydrake.multibody.math.SpatialMomentum_[AutoDiffXd], V_IBp_E: pydrake.multibody.math.SpatialVelocity_[AutoDiffXd]) -&gt; pydrake.autodiffutils.AutoDiffXd</li>
</ol>
<p>dot(V_IBp_E) is deprecated, and will be removed on or around 2022-06-01. Please use dot(velocity) instead.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_[AutoDiffXd].get_coeffs">
<code class="descname">get_coeffs</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialMomentum_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[6, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_[AutoDiffXd].get_coeffs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to the underlying storage.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_[AutoDiffXd].Rotate">
<code class="descname">Rotate</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialMomentum_[AutoDiffXd], R_FE: pydrake.math.RotationMatrix_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialMomentum_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_[AutoDiffXd].Rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides a Python-only implementation of rotating / re-expressing a
spatial vector.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is done because defining <code class="docutils literal notranslate"><span class="pre">__rmatmul__</span></code> on this class does
not disambiguate against the definitions of
<code class="docutils literal notranslate"><span class="pre">RotationMatrix.__matmul__</span></code>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_[AutoDiffXd].rotational">
<code class="descname">rotational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialMomentum_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_[AutoDiffXd].rotational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the rotational component of this spatial vector.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_[AutoDiffXd].SetZero">
<code class="descname">SetZero</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialMomentum_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialMomentum_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_[AutoDiffXd].SetZero" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets both rotational and translational components of <code class="docutils literal notranslate"><span class="pre">this</span></code>
SpatialVector to zero.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_[AutoDiffXd].Shift">
<code class="descname">Shift</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialMomentum_[AutoDiffXd], p_BpBq_E: numpy.ndarray[object[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialMomentum_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_[AutoDiffXd].Shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Shift of a SpatialMomentum from one application point to another. This
is an alternate signature for shifting a spatial momentum’s
about-point that does not change the original object. See
ShiftInPlace() for more information.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_PQ_E</span></code>:</dt>
<dd>Shift vector from point P to point Q.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">L_NSq_E</span></code>:</dt>
<dd>The equivalent shifted spatial momentum, now applied at point Q
rather than P.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">ShiftInPlace() to compute the shifted spatial momentum in-place
modifying the original object.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_[AutoDiffXd].translational">
<code class="descname">translational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialMomentum_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_[AutoDiffXd].translational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the translational component of this spatial vector.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.math.SpatialMomentum_[AutoDiffXd].Zero">
<em class="property">static </em><code class="descname">Zero</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialMomentum_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_[AutoDiffXd].Zero" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory to create a <em>zero</em> SpatialVector, i.e. rotational and
translational components are both zero.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.math.SpatialMomentum_[Expression]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.math.</code><code class="descname">SpatialMomentum_[Expression]</code><a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_[Expression]" title="Permalink to this definition">¶</a></dt>
<dd><p>This class is used to represent the <em>spatial momentum</em> of a particle,
system of particles or body (whether rigid or soft.) The linear
momentum <code class="docutils literal notranslate"><span class="pre">l_NS</span></code> of a system of particles S in a reference frame N is
defined by:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>l_NS = ∑l_NQi = ∑mᵢv_NQi
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">mᵢ</span></code> and <code class="docutils literal notranslate"><span class="pre">v_NQi</span></code> are the mass and linear velocity (in frame
N) of the i-th particle in the system, respectively. Their product
<code class="docutils literal notranslate"><span class="pre">l_NQi</span> <span class="pre">=</span> <span class="pre">mᵢv_NQi</span></code> is the linear momentum of the i-th particle in the
N reference frame. The angular momentum <code class="docutils literal notranslate"><span class="pre">h_NSp</span></code> of a system of
particles S in a reference frame N about an arbitrary point P is
defined by:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>h_NSp = ∑ p_PQi x l_NQi
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">p_PQi</span></code> is the position vector from point P to the i-th
particle position <code class="docutils literal notranslate"><span class="pre">Qi</span></code>. The definitions above extend to a continuum
of particles as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>h_NSp = ∫p_PQ(r) x v_NQ(r) ρ(r)d³r
  l_NS = ∫v_NQ(r) ρ(r)d³r
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">ρ(r)</span></code> is the density of the body at each material location
<code class="docutils literal notranslate"><span class="pre">r</span></code>. In particular, the continuum version above also applies to
rigid bodies.</p>
<p>Spatial momenta are elements of F⁶ (see [Featherstone 2008]) that
combine both rotational (angular momentum) and translational (linear
momentum) components. Spatial momenta are 6-element quantities that
are pairs of ordinary 3-vectors. Elements 0-2 are the angular momentum
component while elements 3-5 are the linear momentum component. As
with any other spatial vector, both vector components must be
expressed in the same frame.</p>
<p>Neither the expressed-in frame nor the about-point are stored with a
SpatialMomentum object; they must be understood from context. It is
the responsibility of the user to keep track of the about-point and
the expressed-in frame. That is best accomplished through disciplined
notation. In source code we use monogram notation where L designates a
spatial momentum quantity. The spatial momentum of a system S in a
frame N about an arbitrary point P, expressed in a frame E is typeset
as <span class="math notranslate nohighlight">\([^NL^{S/P}]_E\)</span>, which appears in code as <code class="docutils literal notranslate"><span class="pre">L_NSP_E</span></code>. The
spatial momentum of a body B in a frame N about the body origin Bo is
explicitly typeset as L_NBBo_E, but we abbreviate it as L_NBo_E.
Similarly, the spatial momentum of a system S in a frame N about Scm
(the system center of mass), expressed in a frame E is explicitly
typeset as L_NSScm_E, but we abbreviate it as L_NScm_E. For a more
detailed introduction on spatial vectors and the monogram notation
please refer to section multibody_spatial_vectors.</p>
<ul class="simple">
<li><dl class="first docutils">
<dt>[Featherstone 2008] Featherstone, R., 2008. Rigid body dynamics</dt>
<dd>algorithms. Springer.</dd>
</dl>
</li>
</ul>
<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_[Expression].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_[Expression].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialMomentum_[Expression]) -&gt; None</p>
<blockquote>
<div><p>Constructs to all NaNs.</p>
<dl class="docutils">
<dt>Note:</dt>
<dd><p class="first last">This is different from C++, which in Release builds may leave memory
uninitialized. In pydrake, the function call overhead already trumps
any overhead from NAN-initialization, so we err on the side of
safety.</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialMomentum_[Expression], h: numpy.ndarray[object[3, 1]], l: numpy.ndarray[object[3, 1]]) -&gt; None</p>
</li>
</ol>
<p>SpatialMomentum constructor from an angular momentum h and a linear
momentum l.</p>
<ol class="arabic simple" start="3">
<li>__init__(self: pydrake.multibody.math.SpatialMomentum_[Expression], L: numpy.ndarray[object[6, 1]]) -&gt; None</li>
</ol>
<p>SpatialMomentum constructor from an Eigen expression that represents a
six-dimensional vector. This constructor will assert the size of L is
six (6) at compile-time for fixed sized Eigen expressions and at
run-time for dynamic sized Eigen expressions.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_[Expression].dot">
<code class="descname">dot</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_[Expression].dot" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>dot(self: pydrake.multibody.math.SpatialMomentum_[Expression], velocity: pydrake.multibody.math.SpatialVelocity_[Expression]) -&gt; pydrake.symbolic.Expression</li>
</ol>
<p>Calculates twice (2x) a body B’s kinetic energy measured in a frame M.
For any frame (e.g., an multibody_frames_and_bodies “offset frame”) Bp
that is fixed to a rigid body B, calculates the dot-product of
<code class="docutils literal notranslate"><span class="pre">this</span></code> = L_MBp_E (body B’s spatial momentum measured in frame M,
about Bp’s origin, expressed in frame E) with V_MBp_E (frame Bp’s
spatial velocity measured in frame M, expressed in frame E).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">velocity</span></code>:</dt>
<dd>which is V_MBp_E, frame Bp’s spatial velocity measured in frame M,
and expressed in the same frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code> = L_MBp_E.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">2*K_MB, twice (2x) body B’s kinetic energy measured in frame M.</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In general, kinetic energy calculations are only useful when frame
M is a world frame (also called a Newtonian or inertial frame).
Hence, it is unusual to use this method unless frame M is the
world frame W.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Although the spatial vectors V_MBp_E and L_MBp_E must have the
same expressed-in frame E, the resulting scalar K_MB is
independent of frame E.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">As shown below, K_MB can be calculated from any frame Bp fixed on
B, including body B’s center of mass frame Bcm. This is due to how
spatial momentum and spatial velocity shift from Bcm to Bp. For
more information, see SpatialMomentum::Shift() and
SpatialVelocity::Shift().</p>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>K_MB = 1/2 (L_MBp · V_MBp) = 1/2 (L_MBcm · V_MBcm)
</pre></div>
</div>
<ol class="arabic simple" start="2">
<li>dot(self: pydrake.multibody.math.SpatialMomentum_[Expression], V_IBp_E: pydrake.multibody.math.SpatialVelocity_[Expression]) -&gt; pydrake.symbolic.Expression</li>
</ol>
<p>dot(V_IBp_E) is deprecated, and will be removed on or around 2022-06-01. Please use dot(velocity) instead.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_[Expression].get_coeffs">
<code class="descname">get_coeffs</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialMomentum_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[6, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_[Expression].get_coeffs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to the underlying storage.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_[Expression].Rotate">
<code class="descname">Rotate</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialMomentum_[Expression], R_FE: pydrake.math.RotationMatrix_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialMomentum_[Expression]<a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_[Expression].Rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides a Python-only implementation of rotating / re-expressing a
spatial vector.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is done because defining <code class="docutils literal notranslate"><span class="pre">__rmatmul__</span></code> on this class does
not disambiguate against the definitions of
<code class="docutils literal notranslate"><span class="pre">RotationMatrix.__matmul__</span></code>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_[Expression].rotational">
<code class="descname">rotational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialMomentum_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_[Expression].rotational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the rotational component of this spatial vector.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_[Expression].SetZero">
<code class="descname">SetZero</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialMomentum_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialMomentum_[Expression]<a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_[Expression].SetZero" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets both rotational and translational components of <code class="docutils literal notranslate"><span class="pre">this</span></code>
SpatialVector to zero.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_[Expression].Shift">
<code class="descname">Shift</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialMomentum_[Expression], p_BpBq_E: numpy.ndarray[object[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialMomentum_[Expression]<a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_[Expression].Shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Shift of a SpatialMomentum from one application point to another. This
is an alternate signature for shifting a spatial momentum’s
about-point that does not change the original object. See
ShiftInPlace() for more information.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_PQ_E</span></code>:</dt>
<dd>Shift vector from point P to point Q.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">L_NSq_E</span></code>:</dt>
<dd>The equivalent shifted spatial momentum, now applied at point Q
rather than P.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">ShiftInPlace() to compute the shifted spatial momentum in-place
modifying the original object.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_[Expression].translational">
<code class="descname">translational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialMomentum_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_[Expression].translational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the translational component of this spatial vector.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.math.SpatialMomentum_[Expression].Zero">
<em class="property">static </em><code class="descname">Zero</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialMomentum_[Expression]<a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_[Expression].Zero" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory to create a <em>zero</em> SpatialVector, i.e. rotational and
translational components are both zero.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.math.SpatialMomentum_[float]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.math.</code><code class="descname">SpatialMomentum_[float]</code><a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>This class is used to represent the <em>spatial momentum</em> of a particle,
system of particles or body (whether rigid or soft.) The linear
momentum <code class="docutils literal notranslate"><span class="pre">l_NS</span></code> of a system of particles S in a reference frame N is
defined by:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>l_NS = ∑l_NQi = ∑mᵢv_NQi
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">mᵢ</span></code> and <code class="docutils literal notranslate"><span class="pre">v_NQi</span></code> are the mass and linear velocity (in frame
N) of the i-th particle in the system, respectively. Their product
<code class="docutils literal notranslate"><span class="pre">l_NQi</span> <span class="pre">=</span> <span class="pre">mᵢv_NQi</span></code> is the linear momentum of the i-th particle in the
N reference frame. The angular momentum <code class="docutils literal notranslate"><span class="pre">h_NSp</span></code> of a system of
particles S in a reference frame N about an arbitrary point P is
defined by:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>h_NSp = ∑ p_PQi x l_NQi
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">p_PQi</span></code> is the position vector from point P to the i-th
particle position <code class="docutils literal notranslate"><span class="pre">Qi</span></code>. The definitions above extend to a continuum
of particles as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>h_NSp = ∫p_PQ(r) x v_NQ(r) ρ(r)d³r
  l_NS = ∫v_NQ(r) ρ(r)d³r
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">ρ(r)</span></code> is the density of the body at each material location
<code class="docutils literal notranslate"><span class="pre">r</span></code>. In particular, the continuum version above also applies to
rigid bodies.</p>
<p>Spatial momenta are elements of F⁶ (see [Featherstone 2008]) that
combine both rotational (angular momentum) and translational (linear
momentum) components. Spatial momenta are 6-element quantities that
are pairs of ordinary 3-vectors. Elements 0-2 are the angular momentum
component while elements 3-5 are the linear momentum component. As
with any other spatial vector, both vector components must be
expressed in the same frame.</p>
<p>Neither the expressed-in frame nor the about-point are stored with a
SpatialMomentum object; they must be understood from context. It is
the responsibility of the user to keep track of the about-point and
the expressed-in frame. That is best accomplished through disciplined
notation. In source code we use monogram notation where L designates a
spatial momentum quantity. The spatial momentum of a system S in a
frame N about an arbitrary point P, expressed in a frame E is typeset
as <span class="math notranslate nohighlight">\([^NL^{S/P}]_E\)</span>, which appears in code as <code class="docutils literal notranslate"><span class="pre">L_NSP_E</span></code>. The
spatial momentum of a body B in a frame N about the body origin Bo is
explicitly typeset as L_NBBo_E, but we abbreviate it as L_NBo_E.
Similarly, the spatial momentum of a system S in a frame N about Scm
(the system center of mass), expressed in a frame E is explicitly
typeset as L_NSScm_E, but we abbreviate it as L_NScm_E. For a more
detailed introduction on spatial vectors and the monogram notation
please refer to section multibody_spatial_vectors.</p>
<ul class="simple">
<li><dl class="first docutils">
<dt>[Featherstone 2008] Featherstone, R., 2008. Rigid body dynamics</dt>
<dd>algorithms. Springer.</dd>
</dl>
</li>
</ul>
<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialMomentum_[float]) -&gt; None</p>
<blockquote>
<div><p>Constructs to all NaNs.</p>
<dl class="docutils">
<dt>Note:</dt>
<dd><p class="first last">This is different from C++, which in Release builds may leave memory
uninitialized. In pydrake, the function call overhead already trumps
any overhead from NAN-initialization, so we err on the side of
safety.</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialMomentum_[float], h: numpy.ndarray[numpy.float64[3, 1]], l: numpy.ndarray[numpy.float64[3, 1]]) -&gt; None</p>
</li>
</ol>
<p>SpatialMomentum constructor from an angular momentum h and a linear
momentum l.</p>
<ol class="arabic simple" start="3">
<li>__init__(self: pydrake.multibody.math.SpatialMomentum_[float], L: numpy.ndarray[numpy.float64[6, 1]]) -&gt; None</li>
</ol>
<p>SpatialMomentum constructor from an Eigen expression that represents a
six-dimensional vector. This constructor will assert the size of L is
six (6) at compile-time for fixed sized Eigen expressions and at
run-time for dynamic sized Eigen expressions.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_[float].dot">
<code class="descname">dot</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_[float].dot" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>dot(self: pydrake.multibody.math.SpatialMomentum_[float], velocity: pydrake.multibody.math.SpatialVelocity_[float]) -&gt; float</li>
</ol>
<p>Calculates twice (2x) a body B’s kinetic energy measured in a frame M.
For any frame (e.g., an multibody_frames_and_bodies “offset frame”) Bp
that is fixed to a rigid body B, calculates the dot-product of
<code class="docutils literal notranslate"><span class="pre">this</span></code> = L_MBp_E (body B’s spatial momentum measured in frame M,
about Bp’s origin, expressed in frame E) with V_MBp_E (frame Bp’s
spatial velocity measured in frame M, expressed in frame E).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">velocity</span></code>:</dt>
<dd>which is V_MBp_E, frame Bp’s spatial velocity measured in frame M,
and expressed in the same frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code> = L_MBp_E.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">2*K_MB, twice (2x) body B’s kinetic energy measured in frame M.</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In general, kinetic energy calculations are only useful when frame
M is a world frame (also called a Newtonian or inertial frame).
Hence, it is unusual to use this method unless frame M is the
world frame W.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Although the spatial vectors V_MBp_E and L_MBp_E must have the
same expressed-in frame E, the resulting scalar K_MB is
independent of frame E.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">As shown below, K_MB can be calculated from any frame Bp fixed on
B, including body B’s center of mass frame Bcm. This is due to how
spatial momentum and spatial velocity shift from Bcm to Bp. For
more information, see SpatialMomentum::Shift() and
SpatialVelocity::Shift().</p>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>K_MB = 1/2 (L_MBp · V_MBp) = 1/2 (L_MBcm · V_MBcm)
</pre></div>
</div>
<ol class="arabic simple" start="2">
<li>dot(self: pydrake.multibody.math.SpatialMomentum_[float], V_IBp_E: pydrake.multibody.math.SpatialVelocity_[float]) -&gt; float</li>
</ol>
<p>dot(V_IBp_E) is deprecated, and will be removed on or around 2022-06-01. Please use dot(velocity) instead.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_[float].get_coeffs">
<code class="descname">get_coeffs</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialMomentum_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[6, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_[float].get_coeffs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to the underlying storage.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_[float].Rotate">
<code class="descname">Rotate</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialMomentum_[float], R_FE: pydrake.math.RotationMatrix_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialMomentum_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_[float].Rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides a Python-only implementation of rotating / re-expressing a
spatial vector.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is done because defining <code class="docutils literal notranslate"><span class="pre">__rmatmul__</span></code> on this class does
not disambiguate against the definitions of
<code class="docutils literal notranslate"><span class="pre">RotationMatrix.__matmul__</span></code>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_[float].rotational">
<code class="descname">rotational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialMomentum_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_[float].rotational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the rotational component of this spatial vector.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_[float].SetZero">
<code class="descname">SetZero</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialMomentum_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialMomentum_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_[float].SetZero" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets both rotational and translational components of <code class="docutils literal notranslate"><span class="pre">this</span></code>
SpatialVector to zero.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_[float].Shift">
<code class="descname">Shift</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialMomentum_[float], p_BpBq_E: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialMomentum_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_[float].Shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Shift of a SpatialMomentum from one application point to another. This
is an alternate signature for shifting a spatial momentum’s
about-point that does not change the original object. See
ShiftInPlace() for more information.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_PQ_E</span></code>:</dt>
<dd>Shift vector from point P to point Q.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">L_NSq_E</span></code>:</dt>
<dd>The equivalent shifted spatial momentum, now applied at point Q
rather than P.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">ShiftInPlace() to compute the shifted spatial momentum in-place
modifying the original object.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_[float].translational">
<code class="descname">translational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialMomentum_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_[float].translational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the translational component of this spatial vector.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.math.SpatialMomentum_[float].Zero">
<em class="property">static </em><code class="descname">Zero</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialMomentum_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_[float].Zero" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory to create a <em>zero</em> SpatialVector, i.e. rotational and
translational components are both zero.</p>
</dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.math.SpatialVelocity">
<code class="descclassname">pydrake.multibody.math.</code><code class="descname">SpatialVelocity</code><a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pydrake.multibody.math.SpatialVelocity_[float]" title="pydrake.multibody.math.SpatialVelocity_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.math.SpatialVelocity_[float]</span></code></a></p>
</dd></dl>

<dl class="template">
<dt id="pydrake.multibody.math.SpatialVelocity_">
<em class="property">template </em><code class="descclassname">pydrake.multibody.math.</code><code class="descname">SpatialVelocity_</code><a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.multibody.math.SpatialVelocity_[float]" title="pydrake.multibody.math.SpatialVelocity_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">SpatialVelocity_[float]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.math.SpatialVelocity_[AutoDiffXd]" title="pydrake.multibody.math.SpatialVelocity_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">SpatialVelocity_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.math.SpatialVelocity_[Expression]" title="pydrake.multibody.math.SpatialVelocity_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">SpatialVelocity_[Expression]</span></code></a></p>
<dl class="class">
<dt id="pydrake.multibody.math.SpatialVelocity_.SpatialVelocity_[float]">
<em class="property">class </em><code class="descname">SpatialVelocity_[float]</code><a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_.SpatialVelocity_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>This class represents a <em>spatial velocity</em> (also called a <em>twist</em>) and
has 6 elements with an angular (rotational) velocity ω (3-element
vector) on top of a translational (linear) velocity v (3-element
vector). Spatial velocity represents the rotational and translational
motion of a frame B with respect to a <em>measured-in</em> frame M. This
class assumes that both the angular velocity ω and translational
velocity v are expressed in the same <em>expressed-in</em> frame E. This
class only stores 6 elements (namely ω and v) and does not store the
underlying frames B, M, E. The user is responsible for explicitly
tracking the underlying frames with multibody_quantities “monogram
notation”. For example, V_MB_E denotes frame B’s spatial velocity
measured in frame M, expressed in frame E and contains ω_MB_E (B’s
angular velocity measured in M, expressed in E) and v_MBo_E (Bo’s
translational velocity measured in M, expressed in E), where Bo is
frame B’s origin point. For an multibody_frames_and_bodies “offset
frame” Bp, the monogram notation V_MBp_E denotes the spatial velocity
of frame Bp measured in M, expressed in E. Details on spatial vectors
and monogram notation are in section multibody_spatial_vectors.</p>
<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_.SpatialVelocity_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_.SpatialVelocity_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialVelocity_[float]) -&gt; None</p>
<blockquote>
<div><p>Constructs to all NaNs.</p>
<dl class="docutils">
<dt>Note:</dt>
<dd><p class="first last">This is different from C++, which in Release builds may leave memory
uninitialized. In pydrake, the function call overhead already trumps
any overhead from NAN-initialization, so we err on the side of
safety.</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialVelocity_[float], w: numpy.ndarray[numpy.float64[3, 1]], v: numpy.ndarray[numpy.float64[3, 1]]) -&gt; None</p>
</li>
</ol>
<p>Constructs a spatial velocity from an angular velocity <code class="docutils literal notranslate"><span class="pre">ω</span></code> and a
translational velocity <code class="docutils literal notranslate"><span class="pre">v</span></code>.</p>
<ol class="arabic simple" start="3">
<li>__init__(self: pydrake.multibody.math.SpatialVelocity_[float], V: numpy.ndarray[numpy.float64[6, 1]]) -&gt; None</li>
</ol>
<p>Constructs a spatial velocity from an Eigen expression that represents
a 6-element vector, i.e., two 3-element vectors, namely an angular
velocity ω and a translational velocity v. This constructor will
assert the size of V is six (6) either at compile-time for fixed sized
Eigen expressions or at run-time for dynamic sized Eigen expressions.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_.SpatialVelocity_[float].ComposeWithMovingFrameVelocity">
<code class="descname">ComposeWithMovingFrameVelocity</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_.SpatialVelocity_[float].ComposeWithMovingFrameVelocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>ComposeWithMovingFrameVelocity(self: pydrake.multibody.math.SpatialVelocity_[float], position_of_moving_frame: numpy.ndarray[numpy.float64[3, 1]], velocity_of_moving_frame: pydrake.multibody.math.SpatialVelocity_[float]) -&gt; pydrake.multibody.math.SpatialVelocity_[float]</li>
</ol>
<p>Given a frame C’s velocity relative to a frame B, and frame B’s
velocity measured in a frame M, returns C’s velocity in M.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">position_of_moving_frame</span></code>:</dt>
<dd>which is the position vector p_BoCo_E (from frame B’s origin Bo to
frame C’s origin Co), expressed in frame E. p_BoCo_E must have the
same expressed-in frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code> = V_MB_E.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">velocity_of_moving_frame</span></code>:</dt>
<dd>which is V_BC_E, frame C’s spatial velocity measured in frame B,
expressed in the same frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code> = V_MB_E.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">V_MC_E</span></code>:</dt>
<dd>frame C’s spatial velocity measured in frame M, expressed in frame
E.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The returned spatial velocity V_MC_E contains an angular velocity
ω_MC_E and translational velocity v_MCo_E that are calculated as:</p>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ω_MC_E</span>  <span class="o">=</span> <span class="n">ω_MB_E</span> <span class="o">+</span> <span class="n">ω_BC_E</span>
 <span class="n">v_MCo_E</span> <span class="o">=</span> <span class="n">v_MBo_E</span> <span class="o">+</span> <span class="n">ω_MB_E</span> <span class="n">x</span> <span class="n">p_BoCo_E</span> <span class="o">+</span> <span class="n">v_BCo_E</span>
</pre></div>
</div>
<p>If frame C is rigidly fixed to frame B, V_BC_E = 0 and this method
produces a Shift() operation (albeit inefficiently).</p>
<ol class="arabic simple" start="2">
<li>ComposeWithMovingFrameVelocity(self: pydrake.multibody.math.SpatialVelocity_[float], p_PoBo_E: numpy.ndarray[numpy.float64[3, 1]], V_PB_E: pydrake.multibody.math.SpatialVelocity_[float]) -&gt; pydrake.multibody.math.SpatialVelocity_[float]</li>
</ol>
<p>ComposeWithMovingFrameVelocity(p_PoBo_E, V_PB_E) is deprecated, and will be removed on or around 2022-06-01. Please instead use ComposeWithMovingFrameVelocity(position_of_moving_frame, velocity_of_moving_frame).</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_.SpatialVelocity_[float].dot">
<code class="descname">dot</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_.SpatialVelocity_[float].dot" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>dot(self: pydrake.multibody.math.SpatialVelocity_[float], force: drake::multibody::SpatialForce&lt;double&gt;) -&gt; float</li>
</ol>
<p>Calculates the power generated by a spatial force. For an arbitrary
frame B, calculates the dot-product of <code class="docutils literal notranslate"><span class="pre">this</span></code> = V_MB_E (frame B’s
spatial velocity measured in a frame M, expressed in a frame E) with
F_B_E (frame B’s spatial force, expressed in frame E).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">force</span></code>:</dt>
<dd>which is F_B_E, frame B’s spatial force, expressed in the same
frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code> = V_MB_E.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Power of spatial force F_B_E in frame M, i.e., F_B_E ⋅ V_MB_E.</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Just as equating force 𝐅 to mass * acceleration as 𝐅 = m𝐚 relies
on acceleration 𝐚 being measured in a world frame (also called an
inertial or Newtonian frame), equating power = dK/dt (where K is
kinetic energy) relies on K being measured in a world frame.
Hence, it is unusual to use this method unless frame M is the
world frame W.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Although the spatial vectors F_B_E and V_MB_E must have the same
expressed-in frame E, the returned scalar is independent of frame
E.</p>
</div>
<ol class="arabic simple" start="2">
<li>dot(self: pydrake.multibody.math.SpatialVelocity_[float], F_Bp_E: drake::multibody::SpatialForce&lt;double&gt;) -&gt; float</li>
</ol>
<p>dot(F_Bp_E) is deprecated, and will be removed on or around 2022-06-01. Please instead use dot(force).</p>
<ol class="arabic simple" start="3">
<li>dot(self: pydrake.multibody.math.SpatialVelocity_[float], momentum: drake::multibody::SpatialMomentum&lt;double&gt;) -&gt; float</li>
</ol>
<p>Calculates twice (2x) a body B’s kinetic energy measured in a frame M.
For any frame (e.g., an multibody_frames_and_bodies “offset frame”) Bp
that is fixed to a rigid body B, calculates the dot-product of
<code class="docutils literal notranslate"><span class="pre">this</span></code> = V_MBp_E (frame Bp’s spatial velocity measured in frame M,
expressed in frame E) with L_MBp_E (body B’s spatial momentum measured
in frame M, about Bp’s origin, expressed in frame E).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">momentum</span></code>:</dt>
<dd>which is L_MBp_E, body B’s spatial momentum measured in frame M,
about frame Bp’s origin, expressed in the same frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code>
= V_MBp_E.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">2*K_MB, twice (2x) body B’s kinetic energy measured in frame M.</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In general, kinetic energy calculations are only useful when frame
M is a world frame (also called a Newtonian or inertial frame).
Hence, it is unusual to use this method unless frame M is the
world frame W.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Although the spatial vectors V_MBp_E and L_MBp_E must have the
same expressed-in frame E, the resulting scalar K_MB is
independent of frame E.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">As shown below, K_MB can be calculated from any frame Bp fixed on
B, including body B’s center of mass frame Bcm. This is due to how
spatial momentum and spatial velocity shift from Bcm to Bp. For
more information, see SpatialMomentum::Shift() and
SpatialVelocity::Shift().</p>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>K_MB = 1/2 (L_MBp · V_MBp) = 1/2 (L_MBcm · V_MBcm)
</pre></div>
</div>
<ol class="arabic simple" start="4">
<li>dot(self: pydrake.multibody.math.SpatialVelocity_[float], L_WBp_E: drake::multibody::SpatialMomentum&lt;double&gt;) -&gt; float</li>
</ol>
<p>dot(L_WBp_E) is deprecated, and will be removed on or around 2022-06-01. Please instead use dot(momentum).</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_.SpatialVelocity_[float].get_coeffs">
<code class="descname">get_coeffs</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialVelocity_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[6, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_.SpatialVelocity_[float].get_coeffs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to the underlying storage.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_.SpatialVelocity_[float].Rotate">
<code class="descname">Rotate</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialVelocity_[float], R_FE: pydrake.math.RotationMatrix_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialVelocity_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_.SpatialVelocity_[float].Rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides a Python-only implementation of rotating / re-expressing a
spatial vector.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is done because defining <code class="docutils literal notranslate"><span class="pre">__rmatmul__</span></code> on this class does
not disambiguate against the definitions of
<code class="docutils literal notranslate"><span class="pre">RotationMatrix.__matmul__</span></code>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_.SpatialVelocity_[float].rotational">
<code class="descname">rotational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialVelocity_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_.SpatialVelocity_[float].rotational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the rotational component of this spatial vector.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_.SpatialVelocity_[float].SetZero">
<code class="descname">SetZero</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialVelocity_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialVelocity_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_.SpatialVelocity_[float].SetZero" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets both rotational and translational components of <code class="docutils literal notranslate"><span class="pre">this</span></code>
SpatialVector to zero.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_.SpatialVelocity_[float].Shift">
<code class="descname">Shift</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_.SpatialVelocity_[float].Shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>Shift(self: pydrake.multibody.math.SpatialVelocity_[float], offset: numpy.ndarray[numpy.float64[3, 1]]) -&gt; pydrake.multibody.math.SpatialVelocity_[float]</li>
</ol>
<p>Shifts a SpatialVelocity from a frame B to a frame C, where both B and
C are fixed to the same frame or rigid body. This method differs from
ShiftInPlace() in that this method does not modify <code class="docutils literal notranslate"><span class="pre">this</span></code> whereas
ShiftInPlace() does modify <code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">offset</span></code>:</dt>
<dd>which is the position vector p_BoCo_E from frame B’s origin to
frame C’s origin, expressed in frame E. p_BoCo_E must have the
same expressed-in frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial velocity (<code class="docutils literal notranslate"><span class="pre">this</span></code> =
V_MB_E).</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">V_MC_E</span></code>:</dt>
<dd>which is frame C’s spatial velocity measured in frame M, expressed
in frame E.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">ShiftInPlace() for more information and how V_MC_E is calculated.</p>
</div>
<ol class="arabic simple" start="2">
<li>Shift(self: pydrake.multibody.math.SpatialVelocity_[float], p_BpBq_E: numpy.ndarray[numpy.float64[3, 1]]) -&gt; pydrake.multibody.math.SpatialVelocity_[float]</li>
</ol>
<p>Shift(p_BqBq_E) is deprecated, and will be removed on or around 2022-06-01. Please instead use Shift(offset).</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_.SpatialVelocity_[float].translational">
<code class="descname">translational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialVelocity_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_.SpatialVelocity_[float].translational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the translational component of this spatial vector.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.math.SpatialVelocity_.SpatialVelocity_[float].Zero">
<em class="property">static </em><code class="descname">Zero</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialVelocity_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_.SpatialVelocity_[float].Zero" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory to create a <em>zero</em> SpatialVector, i.e. rotational and
translational components are both zero.</p>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.math.SpatialVelocity_[AutoDiffXd]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.math.</code><code class="descname">SpatialVelocity_[AutoDiffXd]</code><a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[AutoDiffXd]" title="Permalink to this definition">¶</a></dt>
<dd><p>This class represents a <em>spatial velocity</em> (also called a <em>twist</em>) and
has 6 elements with an angular (rotational) velocity ω (3-element
vector) on top of a translational (linear) velocity v (3-element
vector). Spatial velocity represents the rotational and translational
motion of a frame B with respect to a <em>measured-in</em> frame M. This
class assumes that both the angular velocity ω and translational
velocity v are expressed in the same <em>expressed-in</em> frame E. This
class only stores 6 elements (namely ω and v) and does not store the
underlying frames B, M, E. The user is responsible for explicitly
tracking the underlying frames with multibody_quantities “monogram
notation”. For example, V_MB_E denotes frame B’s spatial velocity
measured in frame M, expressed in frame E and contains ω_MB_E (B’s
angular velocity measured in M, expressed in E) and v_MBo_E (Bo’s
translational velocity measured in M, expressed in E), where Bo is
frame B’s origin point. For an multibody_frames_and_bodies “offset
frame” Bp, the monogram notation V_MBp_E denotes the spatial velocity
of frame Bp measured in M, expressed in E. Details on spatial vectors
and monogram notation are in section multibody_spatial_vectors.</p>
<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_[AutoDiffXd].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[AutoDiffXd].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialVelocity_[AutoDiffXd]) -&gt; None</p>
<blockquote>
<div><p>Constructs to all NaNs.</p>
<dl class="docutils">
<dt>Note:</dt>
<dd><p class="first last">This is different from C++, which in Release builds may leave memory
uninitialized. In pydrake, the function call overhead already trumps
any overhead from NAN-initialization, so we err on the side of
safety.</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialVelocity_[AutoDiffXd], w: numpy.ndarray[object[3, 1]], v: numpy.ndarray[object[3, 1]]) -&gt; None</p>
</li>
</ol>
<p>Constructs a spatial velocity from an angular velocity <code class="docutils literal notranslate"><span class="pre">ω</span></code> and a
translational velocity <code class="docutils literal notranslate"><span class="pre">v</span></code>.</p>
<ol class="arabic simple" start="3">
<li>__init__(self: pydrake.multibody.math.SpatialVelocity_[AutoDiffXd], V: numpy.ndarray[object[6, 1]]) -&gt; None</li>
</ol>
<p>Constructs a spatial velocity from an Eigen expression that represents
a 6-element vector, i.e., two 3-element vectors, namely an angular
velocity ω and a translational velocity v. This constructor will
assert the size of V is six (6) either at compile-time for fixed sized
Eigen expressions or at run-time for dynamic sized Eigen expressions.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_[AutoDiffXd].ComposeWithMovingFrameVelocity">
<code class="descname">ComposeWithMovingFrameVelocity</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[AutoDiffXd].ComposeWithMovingFrameVelocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>ComposeWithMovingFrameVelocity(self: pydrake.multibody.math.SpatialVelocity_[AutoDiffXd], position_of_moving_frame: numpy.ndarray[object[3, 1]], velocity_of_moving_frame: pydrake.multibody.math.SpatialVelocity_[AutoDiffXd]) -&gt; pydrake.multibody.math.SpatialVelocity_[AutoDiffXd]</li>
</ol>
<p>Given a frame C’s velocity relative to a frame B, and frame B’s
velocity measured in a frame M, returns C’s velocity in M.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">position_of_moving_frame</span></code>:</dt>
<dd>which is the position vector p_BoCo_E (from frame B’s origin Bo to
frame C’s origin Co), expressed in frame E. p_BoCo_E must have the
same expressed-in frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code> = V_MB_E.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">velocity_of_moving_frame</span></code>:</dt>
<dd>which is V_BC_E, frame C’s spatial velocity measured in frame B,
expressed in the same frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code> = V_MB_E.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">V_MC_E</span></code>:</dt>
<dd>frame C’s spatial velocity measured in frame M, expressed in frame
E.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The returned spatial velocity V_MC_E contains an angular velocity
ω_MC_E and translational velocity v_MCo_E that are calculated as:</p>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ω_MC_E</span>  <span class="o">=</span> <span class="n">ω_MB_E</span> <span class="o">+</span> <span class="n">ω_BC_E</span>
 <span class="n">v_MCo_E</span> <span class="o">=</span> <span class="n">v_MBo_E</span> <span class="o">+</span> <span class="n">ω_MB_E</span> <span class="n">x</span> <span class="n">p_BoCo_E</span> <span class="o">+</span> <span class="n">v_BCo_E</span>
</pre></div>
</div>
<p>If frame C is rigidly fixed to frame B, V_BC_E = 0 and this method
produces a Shift() operation (albeit inefficiently).</p>
<ol class="arabic simple" start="2">
<li>ComposeWithMovingFrameVelocity(self: pydrake.multibody.math.SpatialVelocity_[AutoDiffXd], p_PoBo_E: numpy.ndarray[object[3, 1]], V_PB_E: pydrake.multibody.math.SpatialVelocity_[AutoDiffXd]) -&gt; pydrake.multibody.math.SpatialVelocity_[AutoDiffXd]</li>
</ol>
<p>ComposeWithMovingFrameVelocity(p_PoBo_E, V_PB_E) is deprecated, and will be removed on or around 2022-06-01. Please instead use ComposeWithMovingFrameVelocity(position_of_moving_frame, velocity_of_moving_frame).</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_[AutoDiffXd].dot">
<code class="descname">dot</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[AutoDiffXd].dot" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>dot(self: pydrake.multibody.math.SpatialVelocity_[AutoDiffXd], force: drake::multibody::SpatialForce&lt;Eigen::AutoDiffScalar&lt;Eigen::Matrix&lt;double, -1, 1, 0, -1, 1&gt; &gt; &gt;) -&gt; pydrake.autodiffutils.AutoDiffXd</li>
</ol>
<p>Calculates the power generated by a spatial force. For an arbitrary
frame B, calculates the dot-product of <code class="docutils literal notranslate"><span class="pre">this</span></code> = V_MB_E (frame B’s
spatial velocity measured in a frame M, expressed in a frame E) with
F_B_E (frame B’s spatial force, expressed in frame E).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">force</span></code>:</dt>
<dd>which is F_B_E, frame B’s spatial force, expressed in the same
frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code> = V_MB_E.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Power of spatial force F_B_E in frame M, i.e., F_B_E ⋅ V_MB_E.</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Just as equating force 𝐅 to mass * acceleration as 𝐅 = m𝐚 relies
on acceleration 𝐚 being measured in a world frame (also called an
inertial or Newtonian frame), equating power = dK/dt (where K is
kinetic energy) relies on K being measured in a world frame.
Hence, it is unusual to use this method unless frame M is the
world frame W.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Although the spatial vectors F_B_E and V_MB_E must have the same
expressed-in frame E, the returned scalar is independent of frame
E.</p>
</div>
<ol class="arabic simple" start="2">
<li>dot(self: pydrake.multibody.math.SpatialVelocity_[AutoDiffXd], F_Bp_E: drake::multibody::SpatialForce&lt;Eigen::AutoDiffScalar&lt;Eigen::Matrix&lt;double, -1, 1, 0, -1, 1&gt; &gt; &gt;) -&gt; pydrake.autodiffutils.AutoDiffXd</li>
</ol>
<p>dot(F_Bp_E) is deprecated, and will be removed on or around 2022-06-01. Please instead use dot(force).</p>
<ol class="arabic simple" start="3">
<li>dot(self: pydrake.multibody.math.SpatialVelocity_[AutoDiffXd], momentum: drake::multibody::SpatialMomentum&lt;Eigen::AutoDiffScalar&lt;Eigen::Matrix&lt;double, -1, 1, 0, -1, 1&gt; &gt; &gt;) -&gt; pydrake.autodiffutils.AutoDiffXd</li>
</ol>
<p>Calculates twice (2x) a body B’s kinetic energy measured in a frame M.
For any frame (e.g., an multibody_frames_and_bodies “offset frame”) Bp
that is fixed to a rigid body B, calculates the dot-product of
<code class="docutils literal notranslate"><span class="pre">this</span></code> = V_MBp_E (frame Bp’s spatial velocity measured in frame M,
expressed in frame E) with L_MBp_E (body B’s spatial momentum measured
in frame M, about Bp’s origin, expressed in frame E).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">momentum</span></code>:</dt>
<dd>which is L_MBp_E, body B’s spatial momentum measured in frame M,
about frame Bp’s origin, expressed in the same frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code>
= V_MBp_E.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">2*K_MB, twice (2x) body B’s kinetic energy measured in frame M.</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In general, kinetic energy calculations are only useful when frame
M is a world frame (also called a Newtonian or inertial frame).
Hence, it is unusual to use this method unless frame M is the
world frame W.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Although the spatial vectors V_MBp_E and L_MBp_E must have the
same expressed-in frame E, the resulting scalar K_MB is
independent of frame E.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">As shown below, K_MB can be calculated from any frame Bp fixed on
B, including body B’s center of mass frame Bcm. This is due to how
spatial momentum and spatial velocity shift from Bcm to Bp. For
more information, see SpatialMomentum::Shift() and
SpatialVelocity::Shift().</p>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>K_MB = 1/2 (L_MBp · V_MBp) = 1/2 (L_MBcm · V_MBcm)
</pre></div>
</div>
<ol class="arabic simple" start="4">
<li>dot(self: pydrake.multibody.math.SpatialVelocity_[AutoDiffXd], L_WBp_E: drake::multibody::SpatialMomentum&lt;Eigen::AutoDiffScalar&lt;Eigen::Matrix&lt;double, -1, 1, 0, -1, 1&gt; &gt; &gt;) -&gt; pydrake.autodiffutils.AutoDiffXd</li>
</ol>
<p>dot(L_WBp_E) is deprecated, and will be removed on or around 2022-06-01. Please instead use dot(momentum).</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_[AutoDiffXd].get_coeffs">
<code class="descname">get_coeffs</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialVelocity_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[6, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[AutoDiffXd].get_coeffs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to the underlying storage.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_[AutoDiffXd].Rotate">
<code class="descname">Rotate</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialVelocity_[AutoDiffXd], R_FE: pydrake.math.RotationMatrix_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialVelocity_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[AutoDiffXd].Rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides a Python-only implementation of rotating / re-expressing a
spatial vector.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is done because defining <code class="docutils literal notranslate"><span class="pre">__rmatmul__</span></code> on this class does
not disambiguate against the definitions of
<code class="docutils literal notranslate"><span class="pre">RotationMatrix.__matmul__</span></code>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_[AutoDiffXd].rotational">
<code class="descname">rotational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialVelocity_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[AutoDiffXd].rotational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the rotational component of this spatial vector.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_[AutoDiffXd].SetZero">
<code class="descname">SetZero</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialVelocity_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialVelocity_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[AutoDiffXd].SetZero" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets both rotational and translational components of <code class="docutils literal notranslate"><span class="pre">this</span></code>
SpatialVector to zero.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_[AutoDiffXd].Shift">
<code class="descname">Shift</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[AutoDiffXd].Shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>Shift(self: pydrake.multibody.math.SpatialVelocity_[AutoDiffXd], offset: numpy.ndarray[object[3, 1]]) -&gt; pydrake.multibody.math.SpatialVelocity_[AutoDiffXd]</li>
</ol>
<p>Shifts a SpatialVelocity from a frame B to a frame C, where both B and
C are fixed to the same frame or rigid body. This method differs from
ShiftInPlace() in that this method does not modify <code class="docutils literal notranslate"><span class="pre">this</span></code> whereas
ShiftInPlace() does modify <code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">offset</span></code>:</dt>
<dd>which is the position vector p_BoCo_E from frame B’s origin to
frame C’s origin, expressed in frame E. p_BoCo_E must have the
same expressed-in frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial velocity (<code class="docutils literal notranslate"><span class="pre">this</span></code> =
V_MB_E).</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">V_MC_E</span></code>:</dt>
<dd>which is frame C’s spatial velocity measured in frame M, expressed
in frame E.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">ShiftInPlace() for more information and how V_MC_E is calculated.</p>
</div>
<ol class="arabic simple" start="2">
<li>Shift(self: pydrake.multibody.math.SpatialVelocity_[AutoDiffXd], p_BpBq_E: numpy.ndarray[object[3, 1]]) -&gt; pydrake.multibody.math.SpatialVelocity_[AutoDiffXd]</li>
</ol>
<p>Shift(p_BqBq_E) is deprecated, and will be removed on or around 2022-06-01. Please instead use Shift(offset).</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_[AutoDiffXd].translational">
<code class="descname">translational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialVelocity_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[AutoDiffXd].translational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the translational component of this spatial vector.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.math.SpatialVelocity_[AutoDiffXd].Zero">
<em class="property">static </em><code class="descname">Zero</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialVelocity_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[AutoDiffXd].Zero" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory to create a <em>zero</em> SpatialVector, i.e. rotational and
translational components are both zero.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.math.SpatialVelocity_[Expression]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.math.</code><code class="descname">SpatialVelocity_[Expression]</code><a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[Expression]" title="Permalink to this definition">¶</a></dt>
<dd><p>This class represents a <em>spatial velocity</em> (also called a <em>twist</em>) and
has 6 elements with an angular (rotational) velocity ω (3-element
vector) on top of a translational (linear) velocity v (3-element
vector). Spatial velocity represents the rotational and translational
motion of a frame B with respect to a <em>measured-in</em> frame M. This
class assumes that both the angular velocity ω and translational
velocity v are expressed in the same <em>expressed-in</em> frame E. This
class only stores 6 elements (namely ω and v) and does not store the
underlying frames B, M, E. The user is responsible for explicitly
tracking the underlying frames with multibody_quantities “monogram
notation”. For example, V_MB_E denotes frame B’s spatial velocity
measured in frame M, expressed in frame E and contains ω_MB_E (B’s
angular velocity measured in M, expressed in E) and v_MBo_E (Bo’s
translational velocity measured in M, expressed in E), where Bo is
frame B’s origin point. For an multibody_frames_and_bodies “offset
frame” Bp, the monogram notation V_MBp_E denotes the spatial velocity
of frame Bp measured in M, expressed in E. Details on spatial vectors
and monogram notation are in section multibody_spatial_vectors.</p>
<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_[Expression].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[Expression].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialVelocity_[Expression]) -&gt; None</p>
<blockquote>
<div><p>Constructs to all NaNs.</p>
<dl class="docutils">
<dt>Note:</dt>
<dd><p class="first last">This is different from C++, which in Release builds may leave memory
uninitialized. In pydrake, the function call overhead already trumps
any overhead from NAN-initialization, so we err on the side of
safety.</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialVelocity_[Expression], w: numpy.ndarray[object[3, 1]], v: numpy.ndarray[object[3, 1]]) -&gt; None</p>
</li>
</ol>
<p>Constructs a spatial velocity from an angular velocity <code class="docutils literal notranslate"><span class="pre">ω</span></code> and a
translational velocity <code class="docutils literal notranslate"><span class="pre">v</span></code>.</p>
<ol class="arabic simple" start="3">
<li>__init__(self: pydrake.multibody.math.SpatialVelocity_[Expression], V: numpy.ndarray[object[6, 1]]) -&gt; None</li>
</ol>
<p>Constructs a spatial velocity from an Eigen expression that represents
a 6-element vector, i.e., two 3-element vectors, namely an angular
velocity ω and a translational velocity v. This constructor will
assert the size of V is six (6) either at compile-time for fixed sized
Eigen expressions or at run-time for dynamic sized Eigen expressions.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_[Expression].ComposeWithMovingFrameVelocity">
<code class="descname">ComposeWithMovingFrameVelocity</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[Expression].ComposeWithMovingFrameVelocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>ComposeWithMovingFrameVelocity(self: pydrake.multibody.math.SpatialVelocity_[Expression], position_of_moving_frame: numpy.ndarray[object[3, 1]], velocity_of_moving_frame: pydrake.multibody.math.SpatialVelocity_[Expression]) -&gt; pydrake.multibody.math.SpatialVelocity_[Expression]</li>
</ol>
<p>Given a frame C’s velocity relative to a frame B, and frame B’s
velocity measured in a frame M, returns C’s velocity in M.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">position_of_moving_frame</span></code>:</dt>
<dd>which is the position vector p_BoCo_E (from frame B’s origin Bo to
frame C’s origin Co), expressed in frame E. p_BoCo_E must have the
same expressed-in frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code> = V_MB_E.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">velocity_of_moving_frame</span></code>:</dt>
<dd>which is V_BC_E, frame C’s spatial velocity measured in frame B,
expressed in the same frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code> = V_MB_E.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">V_MC_E</span></code>:</dt>
<dd>frame C’s spatial velocity measured in frame M, expressed in frame
E.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The returned spatial velocity V_MC_E contains an angular velocity
ω_MC_E and translational velocity v_MCo_E that are calculated as:</p>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ω_MC_E</span>  <span class="o">=</span> <span class="n">ω_MB_E</span> <span class="o">+</span> <span class="n">ω_BC_E</span>
 <span class="n">v_MCo_E</span> <span class="o">=</span> <span class="n">v_MBo_E</span> <span class="o">+</span> <span class="n">ω_MB_E</span> <span class="n">x</span> <span class="n">p_BoCo_E</span> <span class="o">+</span> <span class="n">v_BCo_E</span>
</pre></div>
</div>
<p>If frame C is rigidly fixed to frame B, V_BC_E = 0 and this method
produces a Shift() operation (albeit inefficiently).</p>
<ol class="arabic simple" start="2">
<li>ComposeWithMovingFrameVelocity(self: pydrake.multibody.math.SpatialVelocity_[Expression], p_PoBo_E: numpy.ndarray[object[3, 1]], V_PB_E: pydrake.multibody.math.SpatialVelocity_[Expression]) -&gt; pydrake.multibody.math.SpatialVelocity_[Expression]</li>
</ol>
<p>ComposeWithMovingFrameVelocity(p_PoBo_E, V_PB_E) is deprecated, and will be removed on or around 2022-06-01. Please instead use ComposeWithMovingFrameVelocity(position_of_moving_frame, velocity_of_moving_frame).</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_[Expression].dot">
<code class="descname">dot</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[Expression].dot" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>dot(self: pydrake.multibody.math.SpatialVelocity_[Expression], force: drake::multibody::SpatialForce&lt;drake::symbolic::Expression&gt;) -&gt; pydrake.symbolic.Expression</li>
</ol>
<p>Calculates the power generated by a spatial force. For an arbitrary
frame B, calculates the dot-product of <code class="docutils literal notranslate"><span class="pre">this</span></code> = V_MB_E (frame B’s
spatial velocity measured in a frame M, expressed in a frame E) with
F_B_E (frame B’s spatial force, expressed in frame E).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">force</span></code>:</dt>
<dd>which is F_B_E, frame B’s spatial force, expressed in the same
frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code> = V_MB_E.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Power of spatial force F_B_E in frame M, i.e., F_B_E ⋅ V_MB_E.</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Just as equating force 𝐅 to mass * acceleration as 𝐅 = m𝐚 relies
on acceleration 𝐚 being measured in a world frame (also called an
inertial or Newtonian frame), equating power = dK/dt (where K is
kinetic energy) relies on K being measured in a world frame.
Hence, it is unusual to use this method unless frame M is the
world frame W.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Although the spatial vectors F_B_E and V_MB_E must have the same
expressed-in frame E, the returned scalar is independent of frame
E.</p>
</div>
<ol class="arabic simple" start="2">
<li>dot(self: pydrake.multibody.math.SpatialVelocity_[Expression], F_Bp_E: drake::multibody::SpatialForce&lt;drake::symbolic::Expression&gt;) -&gt; pydrake.symbolic.Expression</li>
</ol>
<p>dot(F_Bp_E) is deprecated, and will be removed on or around 2022-06-01. Please instead use dot(force).</p>
<ol class="arabic simple" start="3">
<li>dot(self: pydrake.multibody.math.SpatialVelocity_[Expression], momentum: drake::multibody::SpatialMomentum&lt;drake::symbolic::Expression&gt;) -&gt; pydrake.symbolic.Expression</li>
</ol>
<p>Calculates twice (2x) a body B’s kinetic energy measured in a frame M.
For any frame (e.g., an multibody_frames_and_bodies “offset frame”) Bp
that is fixed to a rigid body B, calculates the dot-product of
<code class="docutils literal notranslate"><span class="pre">this</span></code> = V_MBp_E (frame Bp’s spatial velocity measured in frame M,
expressed in frame E) with L_MBp_E (body B’s spatial momentum measured
in frame M, about Bp’s origin, expressed in frame E).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">momentum</span></code>:</dt>
<dd>which is L_MBp_E, body B’s spatial momentum measured in frame M,
about frame Bp’s origin, expressed in the same frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code>
= V_MBp_E.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">2*K_MB, twice (2x) body B’s kinetic energy measured in frame M.</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In general, kinetic energy calculations are only useful when frame
M is a world frame (also called a Newtonian or inertial frame).
Hence, it is unusual to use this method unless frame M is the
world frame W.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Although the spatial vectors V_MBp_E and L_MBp_E must have the
same expressed-in frame E, the resulting scalar K_MB is
independent of frame E.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">As shown below, K_MB can be calculated from any frame Bp fixed on
B, including body B’s center of mass frame Bcm. This is due to how
spatial momentum and spatial velocity shift from Bcm to Bp. For
more information, see SpatialMomentum::Shift() and
SpatialVelocity::Shift().</p>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>K_MB = 1/2 (L_MBp · V_MBp) = 1/2 (L_MBcm · V_MBcm)
</pre></div>
</div>
<ol class="arabic simple" start="4">
<li>dot(self: pydrake.multibody.math.SpatialVelocity_[Expression], L_WBp_E: drake::multibody::SpatialMomentum&lt;drake::symbolic::Expression&gt;) -&gt; pydrake.symbolic.Expression</li>
</ol>
<p>dot(L_WBp_E) is deprecated, and will be removed on or around 2022-06-01. Please instead use dot(momentum).</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_[Expression].get_coeffs">
<code class="descname">get_coeffs</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialVelocity_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[6, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[Expression].get_coeffs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to the underlying storage.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_[Expression].Rotate">
<code class="descname">Rotate</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialVelocity_[Expression], R_FE: pydrake.math.RotationMatrix_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialVelocity_[Expression]<a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[Expression].Rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides a Python-only implementation of rotating / re-expressing a
spatial vector.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is done because defining <code class="docutils literal notranslate"><span class="pre">__rmatmul__</span></code> on this class does
not disambiguate against the definitions of
<code class="docutils literal notranslate"><span class="pre">RotationMatrix.__matmul__</span></code>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_[Expression].rotational">
<code class="descname">rotational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialVelocity_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[Expression].rotational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the rotational component of this spatial vector.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_[Expression].SetZero">
<code class="descname">SetZero</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialVelocity_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialVelocity_[Expression]<a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[Expression].SetZero" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets both rotational and translational components of <code class="docutils literal notranslate"><span class="pre">this</span></code>
SpatialVector to zero.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_[Expression].Shift">
<code class="descname">Shift</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[Expression].Shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>Shift(self: pydrake.multibody.math.SpatialVelocity_[Expression], offset: numpy.ndarray[object[3, 1]]) -&gt; pydrake.multibody.math.SpatialVelocity_[Expression]</li>
</ol>
<p>Shifts a SpatialVelocity from a frame B to a frame C, where both B and
C are fixed to the same frame or rigid body. This method differs from
ShiftInPlace() in that this method does not modify <code class="docutils literal notranslate"><span class="pre">this</span></code> whereas
ShiftInPlace() does modify <code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">offset</span></code>:</dt>
<dd>which is the position vector p_BoCo_E from frame B’s origin to
frame C’s origin, expressed in frame E. p_BoCo_E must have the
same expressed-in frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial velocity (<code class="docutils literal notranslate"><span class="pre">this</span></code> =
V_MB_E).</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">V_MC_E</span></code>:</dt>
<dd>which is frame C’s spatial velocity measured in frame M, expressed
in frame E.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">ShiftInPlace() for more information and how V_MC_E is calculated.</p>
</div>
<ol class="arabic simple" start="2">
<li>Shift(self: pydrake.multibody.math.SpatialVelocity_[Expression], p_BpBq_E: numpy.ndarray[object[3, 1]]) -&gt; pydrake.multibody.math.SpatialVelocity_[Expression]</li>
</ol>
<p>Shift(p_BqBq_E) is deprecated, and will be removed on or around 2022-06-01. Please instead use Shift(offset).</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_[Expression].translational">
<code class="descname">translational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialVelocity_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[Expression].translational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the translational component of this spatial vector.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.math.SpatialVelocity_[Expression].Zero">
<em class="property">static </em><code class="descname">Zero</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialVelocity_[Expression]<a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[Expression].Zero" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory to create a <em>zero</em> SpatialVector, i.e. rotational and
translational components are both zero.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.math.SpatialVelocity_[float]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.math.</code><code class="descname">SpatialVelocity_[float]</code><a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>This class represents a <em>spatial velocity</em> (also called a <em>twist</em>) and
has 6 elements with an angular (rotational) velocity ω (3-element
vector) on top of a translational (linear) velocity v (3-element
vector). Spatial velocity represents the rotational and translational
motion of a frame B with respect to a <em>measured-in</em> frame M. This
class assumes that both the angular velocity ω and translational
velocity v are expressed in the same <em>expressed-in</em> frame E. This
class only stores 6 elements (namely ω and v) and does not store the
underlying frames B, M, E. The user is responsible for explicitly
tracking the underlying frames with multibody_quantities “monogram
notation”. For example, V_MB_E denotes frame B’s spatial velocity
measured in frame M, expressed in frame E and contains ω_MB_E (B’s
angular velocity measured in M, expressed in E) and v_MBo_E (Bo’s
translational velocity measured in M, expressed in E), where Bo is
frame B’s origin point. For an multibody_frames_and_bodies “offset
frame” Bp, the monogram notation V_MBp_E denotes the spatial velocity
of frame Bp measured in M, expressed in E. Details on spatial vectors
and monogram notation are in section multibody_spatial_vectors.</p>
<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialVelocity_[float]) -&gt; None</p>
<blockquote>
<div><p>Constructs to all NaNs.</p>
<dl class="docutils">
<dt>Note:</dt>
<dd><p class="first last">This is different from C++, which in Release builds may leave memory
uninitialized. In pydrake, the function call overhead already trumps
any overhead from NAN-initialization, so we err on the side of
safety.</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialVelocity_[float], w: numpy.ndarray[numpy.float64[3, 1]], v: numpy.ndarray[numpy.float64[3, 1]]) -&gt; None</p>
</li>
</ol>
<p>Constructs a spatial velocity from an angular velocity <code class="docutils literal notranslate"><span class="pre">ω</span></code> and a
translational velocity <code class="docutils literal notranslate"><span class="pre">v</span></code>.</p>
<ol class="arabic simple" start="3">
<li>__init__(self: pydrake.multibody.math.SpatialVelocity_[float], V: numpy.ndarray[numpy.float64[6, 1]]) -&gt; None</li>
</ol>
<p>Constructs a spatial velocity from an Eigen expression that represents
a 6-element vector, i.e., two 3-element vectors, namely an angular
velocity ω and a translational velocity v. This constructor will
assert the size of V is six (6) either at compile-time for fixed sized
Eigen expressions or at run-time for dynamic sized Eigen expressions.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_[float].ComposeWithMovingFrameVelocity">
<code class="descname">ComposeWithMovingFrameVelocity</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[float].ComposeWithMovingFrameVelocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>ComposeWithMovingFrameVelocity(self: pydrake.multibody.math.SpatialVelocity_[float], position_of_moving_frame: numpy.ndarray[numpy.float64[3, 1]], velocity_of_moving_frame: pydrake.multibody.math.SpatialVelocity_[float]) -&gt; pydrake.multibody.math.SpatialVelocity_[float]</li>
</ol>
<p>Given a frame C’s velocity relative to a frame B, and frame B’s
velocity measured in a frame M, returns C’s velocity in M.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">position_of_moving_frame</span></code>:</dt>
<dd>which is the position vector p_BoCo_E (from frame B’s origin Bo to
frame C’s origin Co), expressed in frame E. p_BoCo_E must have the
same expressed-in frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code> = V_MB_E.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">velocity_of_moving_frame</span></code>:</dt>
<dd>which is V_BC_E, frame C’s spatial velocity measured in frame B,
expressed in the same frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code> = V_MB_E.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">V_MC_E</span></code>:</dt>
<dd>frame C’s spatial velocity measured in frame M, expressed in frame
E.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The returned spatial velocity V_MC_E contains an angular velocity
ω_MC_E and translational velocity v_MCo_E that are calculated as:</p>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ω_MC_E</span>  <span class="o">=</span> <span class="n">ω_MB_E</span> <span class="o">+</span> <span class="n">ω_BC_E</span>
 <span class="n">v_MCo_E</span> <span class="o">=</span> <span class="n">v_MBo_E</span> <span class="o">+</span> <span class="n">ω_MB_E</span> <span class="n">x</span> <span class="n">p_BoCo_E</span> <span class="o">+</span> <span class="n">v_BCo_E</span>
</pre></div>
</div>
<p>If frame C is rigidly fixed to frame B, V_BC_E = 0 and this method
produces a Shift() operation (albeit inefficiently).</p>
<ol class="arabic simple" start="2">
<li>ComposeWithMovingFrameVelocity(self: pydrake.multibody.math.SpatialVelocity_[float], p_PoBo_E: numpy.ndarray[numpy.float64[3, 1]], V_PB_E: pydrake.multibody.math.SpatialVelocity_[float]) -&gt; pydrake.multibody.math.SpatialVelocity_[float]</li>
</ol>
<p>ComposeWithMovingFrameVelocity(p_PoBo_E, V_PB_E) is deprecated, and will be removed on or around 2022-06-01. Please instead use ComposeWithMovingFrameVelocity(position_of_moving_frame, velocity_of_moving_frame).</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_[float].dot">
<code class="descname">dot</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[float].dot" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>dot(self: pydrake.multibody.math.SpatialVelocity_[float], force: drake::multibody::SpatialForce&lt;double&gt;) -&gt; float</li>
</ol>
<p>Calculates the power generated by a spatial force. For an arbitrary
frame B, calculates the dot-product of <code class="docutils literal notranslate"><span class="pre">this</span></code> = V_MB_E (frame B’s
spatial velocity measured in a frame M, expressed in a frame E) with
F_B_E (frame B’s spatial force, expressed in frame E).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">force</span></code>:</dt>
<dd>which is F_B_E, frame B’s spatial force, expressed in the same
frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code> = V_MB_E.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Power of spatial force F_B_E in frame M, i.e., F_B_E ⋅ V_MB_E.</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Just as equating force 𝐅 to mass * acceleration as 𝐅 = m𝐚 relies
on acceleration 𝐚 being measured in a world frame (also called an
inertial or Newtonian frame), equating power = dK/dt (where K is
kinetic energy) relies on K being measured in a world frame.
Hence, it is unusual to use this method unless frame M is the
world frame W.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Although the spatial vectors F_B_E and V_MB_E must have the same
expressed-in frame E, the returned scalar is independent of frame
E.</p>
</div>
<ol class="arabic simple" start="2">
<li>dot(self: pydrake.multibody.math.SpatialVelocity_[float], F_Bp_E: drake::multibody::SpatialForce&lt;double&gt;) -&gt; float</li>
</ol>
<p>dot(F_Bp_E) is deprecated, and will be removed on or around 2022-06-01. Please instead use dot(force).</p>
<ol class="arabic simple" start="3">
<li>dot(self: pydrake.multibody.math.SpatialVelocity_[float], momentum: drake::multibody::SpatialMomentum&lt;double&gt;) -&gt; float</li>
</ol>
<p>Calculates twice (2x) a body B’s kinetic energy measured in a frame M.
For any frame (e.g., an multibody_frames_and_bodies “offset frame”) Bp
that is fixed to a rigid body B, calculates the dot-product of
<code class="docutils literal notranslate"><span class="pre">this</span></code> = V_MBp_E (frame Bp’s spatial velocity measured in frame M,
expressed in frame E) with L_MBp_E (body B’s spatial momentum measured
in frame M, about Bp’s origin, expressed in frame E).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">momentum</span></code>:</dt>
<dd>which is L_MBp_E, body B’s spatial momentum measured in frame M,
about frame Bp’s origin, expressed in the same frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code>
= V_MBp_E.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">2*K_MB, twice (2x) body B’s kinetic energy measured in frame M.</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In general, kinetic energy calculations are only useful when frame
M is a world frame (also called a Newtonian or inertial frame).
Hence, it is unusual to use this method unless frame M is the
world frame W.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Although the spatial vectors V_MBp_E and L_MBp_E must have the
same expressed-in frame E, the resulting scalar K_MB is
independent of frame E.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">As shown below, K_MB can be calculated from any frame Bp fixed on
B, including body B’s center of mass frame Bcm. This is due to how
spatial momentum and spatial velocity shift from Bcm to Bp. For
more information, see SpatialMomentum::Shift() and
SpatialVelocity::Shift().</p>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>K_MB = 1/2 (L_MBp · V_MBp) = 1/2 (L_MBcm · V_MBcm)
</pre></div>
</div>
<ol class="arabic simple" start="4">
<li>dot(self: pydrake.multibody.math.SpatialVelocity_[float], L_WBp_E: drake::multibody::SpatialMomentum&lt;double&gt;) -&gt; float</li>
</ol>
<p>dot(L_WBp_E) is deprecated, and will be removed on or around 2022-06-01. Please instead use dot(momentum).</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_[float].get_coeffs">
<code class="descname">get_coeffs</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialVelocity_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[6, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[float].get_coeffs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to the underlying storage.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_[float].Rotate">
<code class="descname">Rotate</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialVelocity_[float], R_FE: pydrake.math.RotationMatrix_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialVelocity_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[float].Rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides a Python-only implementation of rotating / re-expressing a
spatial vector.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is done because defining <code class="docutils literal notranslate"><span class="pre">__rmatmul__</span></code> on this class does
not disambiguate against the definitions of
<code class="docutils literal notranslate"><span class="pre">RotationMatrix.__matmul__</span></code>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_[float].rotational">
<code class="descname">rotational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialVelocity_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[float].rotational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the rotational component of this spatial vector.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_[float].SetZero">
<code class="descname">SetZero</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialVelocity_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialVelocity_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[float].SetZero" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets both rotational and translational components of <code class="docutils literal notranslate"><span class="pre">this</span></code>
SpatialVector to zero.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_[float].Shift">
<code class="descname">Shift</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[float].Shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>Shift(self: pydrake.multibody.math.SpatialVelocity_[float], offset: numpy.ndarray[numpy.float64[3, 1]]) -&gt; pydrake.multibody.math.SpatialVelocity_[float]</li>
</ol>
<p>Shifts a SpatialVelocity from a frame B to a frame C, where both B and
C are fixed to the same frame or rigid body. This method differs from
ShiftInPlace() in that this method does not modify <code class="docutils literal notranslate"><span class="pre">this</span></code> whereas
ShiftInPlace() does modify <code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">offset</span></code>:</dt>
<dd>which is the position vector p_BoCo_E from frame B’s origin to
frame C’s origin, expressed in frame E. p_BoCo_E must have the
same expressed-in frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial velocity (<code class="docutils literal notranslate"><span class="pre">this</span></code> =
V_MB_E).</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">V_MC_E</span></code>:</dt>
<dd>which is frame C’s spatial velocity measured in frame M, expressed
in frame E.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">ShiftInPlace() for more information and how V_MC_E is calculated.</p>
</div>
<ol class="arabic simple" start="2">
<li>Shift(self: pydrake.multibody.math.SpatialVelocity_[float], p_BpBq_E: numpy.ndarray[numpy.float64[3, 1]]) -&gt; pydrake.multibody.math.SpatialVelocity_[float]</li>
</ol>
<p>Shift(p_BqBq_E) is deprecated, and will be removed on or around 2022-06-01. Please instead use Shift(offset).</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_[float].translational">
<code class="descname">translational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialVelocity_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[float].translational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the translational component of this spatial vector.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.math.SpatialVelocity_[float].Zero">
<em class="property">static </em><code class="descname">Zero</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialVelocity_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[float].Zero" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory to create a <em>zero</em> SpatialVector, i.e. rotational and
translational components are both zero.</p>
</dd></dl>

</dd></dl>

</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="pydrake.multibody.meshcat.html" class="btn btn-neutral float-right" title="pydrake.multibody.meshcat" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="pydrake.multibody.inverse_kinematics.html" class="btn btn-neutral float-left" title="pydrake.multibody.inverse_kinematics" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>