

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>pydrake.symbolic &mdash; pydrake  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/custom.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="pydrake.systems" href="pydrake.systems.html" />
    <link rel="prev" title="pydrake.solvers.snopt" href="pydrake.solvers.snopt.html" /> 
</head>

<body class="wy-body-for-nav">

  
<header class="site-header">
  <div class="site-header-inner contain">
    <a class="drake-logo" href="/"><img src="/images/drake-logo-white.svg"></a>
    <div class="menu-mobile-toggle">
      <span></span>
    </div>
    <nav class="site-menu">
      <ul>
        <li class="site-menu-item site-menu-item-main">
          <a class="site-menu-item" href="/">Home</a>
        </li>
        <li class="site-menu-item site-menu-item-main">
          <a class="site-menu-item" href="/installation.html">Installation</a>
        </li>
        <li class="site-menu-item site-menu-item-main">
          <a class="site-menu-item" href="/gallery.html">Gallery</a>
        </li>
        <li class="site-menu-item site-menu-item-main">API Documentation
          <div class="sub">
            <a class="site-menu-item" href="https://drake.mit.edu/doxygen_cxx/index.html">C++</a> <a class="site-menu-item" href="https://drake.mit.edu/pydrake/index.html">Python</a>
          </div>
        </li>
        <li class="site-menu-item site-menu-item-main">Resources
          <div class="sub">
            <a class="site-menu-item" href="/getting_help.html">Getting Help</a> <a class="site-menu-item" href="https://github.com/RobotLocomotion/drake/tree/master/tutorials">Tutorials</a> <a class="site-menu-item" href="/python_bindings.html">Python Bindings</a> <a class="site-menu-item" href="/developers.html">For Developers</a> <a class="site-menu-item" href="/credits.html">Credits</a>
          </div>
        </li>
        <li class="github-link">
          <a class="site-menu-item" href="https://github.com/RobotLocomotion/drake">GitHub <img src="/third_party/images/GitHub-Mark-Light-64px.png"></a>
        </li>
      </ul>
    </nav>
  </div>
</header>

  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> pydrake
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search pydrake only…" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
  <form id="ddg-search-form" class="wy_form" action="https://duckduckgo.com/" method="get">
    <input type="text" name="q" placeholder="Search all of Drake…" />
    <input type="hidden" name="sites" value="drake.mit.edu" />
  </form>
</div>


          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="pydrake.all.html">pydrake.all</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.autodiffutils.html">pydrake.autodiffutils</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.common.html">pydrake.common</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.examples.html">pydrake.examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.forwarddiff.html">pydrake.forwarddiff</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.geometry.html">pydrake.geometry</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.lcm.html">pydrake.lcm</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.manipulation.html">pydrake.manipulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.math.html">pydrake.math</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.multibody.html">pydrake.multibody</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.perception.html">pydrake.perception</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.polynomial.html">pydrake.polynomial</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.solvers.html">pydrake.solvers</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">pydrake.symbolic</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.systems.html">pydrake.systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.trajectories.html">pydrake.trajectories</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.tutorials.html">pydrake.tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.visualization.html">pydrake.visualization</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">pydrake</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>pydrake.symbolic</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="module-pydrake.symbolic">
<span id="pydrake-symbolic"></span><h1>pydrake.symbolic<a class="headerlink" href="#module-pydrake.symbolic" title="Permalink to this headline">¶</a></h1>
<p>Symbolic variable, variables, monomial, expression, polynomial, and formula</p>
<dl class="function">
<dt id="pydrake.symbolic.abs">
<code class="descclassname">pydrake.symbolic.</code><code class="descname">abs</code><span class="sig-paren">(</span><em>arg0: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Expression<a class="headerlink" href="#pydrake.symbolic.abs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pydrake.symbolic.acos">
<code class="descclassname">pydrake.symbolic.</code><code class="descname">acos</code><span class="sig-paren">(</span><em>arg0: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Expression<a class="headerlink" href="#pydrake.symbolic.acos" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pydrake.symbolic.arccos">
<code class="descclassname">pydrake.symbolic.</code><code class="descname">arccos</code><span class="sig-paren">(</span><em>arg0: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Expression<a class="headerlink" href="#pydrake.symbolic.arccos" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pydrake.symbolic.arcsin">
<code class="descclassname">pydrake.symbolic.</code><code class="descname">arcsin</code><span class="sig-paren">(</span><em>arg0: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Expression<a class="headerlink" href="#pydrake.symbolic.arcsin" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pydrake.symbolic.arctan">
<code class="descclassname">pydrake.symbolic.</code><code class="descname">arctan</code><span class="sig-paren">(</span><em>arg0: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Expression<a class="headerlink" href="#pydrake.symbolic.arctan" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pydrake.symbolic.arctan2">
<code class="descclassname">pydrake.symbolic.</code><code class="descname">arctan2</code><span class="sig-paren">(</span><em>arg0: pydrake.symbolic.Expression</em>, <em>arg1: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Expression<a class="headerlink" href="#pydrake.symbolic.arctan2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pydrake.symbolic.asin">
<code class="descclassname">pydrake.symbolic.</code><code class="descname">asin</code><span class="sig-paren">(</span><em>arg0: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Expression<a class="headerlink" href="#pydrake.symbolic.asin" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pydrake.symbolic.atan">
<code class="descclassname">pydrake.symbolic.</code><code class="descname">atan</code><span class="sig-paren">(</span><em>arg0: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Expression<a class="headerlink" href="#pydrake.symbolic.atan" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pydrake.symbolic.atan2">
<code class="descclassname">pydrake.symbolic.</code><code class="descname">atan2</code><span class="sig-paren">(</span><em>arg0: pydrake.symbolic.Expression</em>, <em>arg1: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Expression<a class="headerlink" href="#pydrake.symbolic.atan2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pydrake.symbolic.ceil">
<code class="descclassname">pydrake.symbolic.</code><code class="descname">ceil</code><span class="sig-paren">(</span><em>arg0: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Expression<a class="headerlink" href="#pydrake.symbolic.ceil" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pydrake.symbolic.cos">
<code class="descclassname">pydrake.symbolic.</code><code class="descname">cos</code><span class="sig-paren">(</span><em>arg0: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Expression<a class="headerlink" href="#pydrake.symbolic.cos" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pydrake.symbolic.cosh">
<code class="descclassname">pydrake.symbolic.</code><code class="descname">cosh</code><span class="sig-paren">(</span><em>arg0: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Expression<a class="headerlink" href="#pydrake.symbolic.cosh" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pydrake.symbolic.DecomposeAffineExpression">
<code class="descclassname">pydrake.symbolic.</code><code class="descname">DecomposeAffineExpression</code><span class="sig-paren">(</span><em>e: pydrake.symbolic.Expression, map_var_to_index: Dict[int, int]</em><span class="sig-paren">)</span> &#x2192; Tuple[numpy.ndarray[numpy.float64[1, n]], float]<a class="headerlink" href="#pydrake.symbolic.DecomposeAffineExpression" title="Permalink to this definition">¶</a></dt>
<dd><p>Decomposes an affine combination <code class="docutils literal notranslate"><span class="pre">e</span></code> = c0 + c1 * v1 + … cn * vn
into the following:</p>
<p>constant term : c0 coefficient vector : [c1, …, cn] variable vector
: [v1, …, vn]</p>
<p>Then, it extracts the coefficient and the constant term. A map from
variable ID to int, <code class="docutils literal notranslate"><span class="pre">map_var_to_index</span></code>, is used to decide a
variable’s index in a linear combination.</p>
<p>Precondition:
1. <code class="docutils literal notranslate"><span class="pre">coeffs</span></code> is a row vector of double, whose length matches with the size of
<code class="docutils literal notranslate"><span class="pre">map_var_to_index</span></code>.
2. e.is_polynomial() is true.
3. e is an affine expression.
4. all values in <code class="docutils literal notranslate"><span class="pre">map_var_to_index</span></code> should be in the range [0,
map_var_to_index.size())</p>
<blockquote>
<div>$Parameter <code class="docutils literal notranslate"><span class="pre">e</span></code>:</div></blockquote>
<p>The symbolic affine expression</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">map_var_to_index</span></code>:</dt>
<dd>A mapping from variable ID to variable index, such that
map_var_to_index[vi.get_ID()] = i.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">coeffs</span></code>:</dt>
<dd>A row vector. coeffs(i) = ci.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">constant_term</span></code>:</dt>
<dd>c0 in the equation above.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">num_variable. Number of variables in the expression. 2 * x(0) + 3
has 1 variable, 2 * x(0) + 3 * x(1) - 2 * x(0) has 1 variable.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pydrake.symbolic.DecomposeAffineExpressions">
<code class="descclassname">pydrake.symbolic.</code><code class="descname">DecomposeAffineExpressions</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.symbolic.DecomposeAffineExpressions" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>DecomposeAffineExpressions(expressions: numpy.ndarray[object[m, 1]], vars: numpy.ndarray[object[m, 1]]) -&gt; Tuple[numpy.ndarray[numpy.float64[m, n]], numpy.ndarray[numpy.float64[m, 1]]]</li>
</ol>
<p>Decomposes <code class="docutils literal notranslate"><span class="pre">expressions</span></code> into <code class="docutils literal notranslate"><span class="pre">M</span></code> * <code class="docutils literal notranslate"><span class="pre">vars</span></code> + <code class="docutils literal notranslate"><span class="pre">v</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal notranslate"><span class="pre">expressions</span></code> is not affine in <code class="docutils literal notranslate"><span class="pre">vars</span></code>.</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Precondition:</dt>
<dd>M.rows() == expressions.rows() &amp;&amp; M.cols() == vars.rows().</dd>
<dt>Precondition:</dt>
<dd>v.rows() == expressions.rows().</dd>
</dl>
<ol class="arabic simple" start="2">
<li>DecomposeAffineExpressions(v: numpy.ndarray[object[m, 1]]) -&gt; Tuple[numpy.ndarray[numpy.float64[m, n]], numpy.ndarray[numpy.float64[m, 1]], numpy.ndarray[object[m, 1]]]</li>
</ol>
<p>Given a vector of affine expressions v, decompose it to <span class="math notranslate nohighlight">\(v = A
vars + b\)</span></p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">v</span></code>:</dt>
<dd>A vector of affine expressions</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">A</span></code>:</dt>
<dd>The matrix containing the linear coefficients.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">b</span></code>:</dt>
<dd>The vector containing all the constant terms.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">vars</span></code>:</dt>
<dd>All variables.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pydrake.symbolic.DecomposeLinearExpressions">
<code class="descclassname">pydrake.symbolic.</code><code class="descname">DecomposeLinearExpressions</code><span class="sig-paren">(</span><em>expressions: numpy.ndarray[object[m, 1]], vars: numpy.ndarray[object[m, 1]]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, n]]<a class="headerlink" href="#pydrake.symbolic.DecomposeLinearExpressions" title="Permalink to this definition">¶</a></dt>
<dd><p>Decomposes <code class="docutils literal notranslate"><span class="pre">expressions</span></code> into <code class="docutils literal notranslate"><span class="pre">M</span></code> * <code class="docutils literal notranslate"><span class="pre">vars</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal notranslate"><span class="pre">expressions</span></code> is not linear in <code class="docutils literal notranslate"><span class="pre">vars</span></code>.</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Precondition:</dt>
<dd>M.rows() == expressions.rows() &amp;&amp; M.cols() == vars.rows().</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pydrake.symbolic.DecomposeLumpedParameters">
<code class="descclassname">pydrake.symbolic.</code><code class="descname">DecomposeLumpedParameters</code><span class="sig-paren">(</span><em>f: numpy.ndarray[object[m, 1]], parameters: numpy.ndarray[object[m, 1]]</em><span class="sig-paren">)</span> &#x2192; Tuple[numpy.ndarray[object[m, n]], numpy.ndarray[object[m, 1]], numpy.ndarray[object[m, 1]]]<a class="headerlink" href="#pydrake.symbolic.DecomposeLumpedParameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a vector of Expressions <code class="docutils literal notranslate"><span class="pre">f</span></code> and a list of <code class="docutils literal notranslate"><span class="pre">parameters</span></code> we
define all additional variables in <code class="docutils literal notranslate"><span class="pre">f</span></code> to be a vector of
“non-parameter variables”, n. This method returns a factorization of
<code class="docutils literal notranslate"><span class="pre">f</span></code> into an equivalent “data matrix”, W, which depends only on the
non-parameter variables, and a “lumped parameter vector”, α, which
depends only on <code class="docutils literal notranslate"><span class="pre">parameters:</span></code> f = W(n)*α(parameters) + w0(n).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The current implementation makes some simple attempts to minimize
the number of lumped parameters, but more simplification could be
implemented relatively easily. Optimal simplification, however,
involves the complexity of comparing two arbitrary Expressions
(see Expression::EqualTo for more details).</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first simple">
<li>RuntimeError if <code class="docutils literal notranslate"><span class="pre">f</span></code> is not decomposable in this way (cells</li>
<li>containing <code class="docutils literal notranslate"><span class="pre">parameters</span></code> may only be added or multiplied with</li>
<li>cells containing non-parameter variables).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">W(n), α(parameters), and w0(n).</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pydrake.symbolic.DecomposeQuadraticPolynomial">
<code class="descclassname">pydrake.symbolic.</code><code class="descname">DecomposeQuadraticPolynomial</code><span class="sig-paren">(</span><em>poly: pydrake.symbolic.Polynomial, map_var_to_index: Dict[int, int]</em><span class="sig-paren">)</span> &#x2192; Tuple[numpy.ndarray[numpy.float64[m, n]], numpy.ndarray[numpy.float64[m, 1]], float]<a class="headerlink" href="#pydrake.symbolic.DecomposeQuadraticPolynomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a quadratic polynomial <code class="docutils literal notranslate"><span class="pre">poly</span></code>, decomposes it into the form 0.5
* x’ Q * x + b’ * x + c</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">poly</span></code>:</dt>
<dd>Quadratic polynomial to decompose.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">map_var_to_index</span></code>:</dt>
<dd>maps variables in <code class="docutils literal notranslate"><span class="pre">poly.GetVariables()</span></code> to the index in the
vector <code class="docutils literal notranslate"><span class="pre">x</span></code>.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">Q</span></code>:</dt>
<dd>[out] The Hessian of the quadratic expression.</dd>
<dt>Precondition:</dt>
<dd>The size of Q should be <code class="docutils literal notranslate"><span class="pre">num_variables</span> <span class="pre">x</span> <span class="pre">num_variables</span></code>. Q is a
symmetric matrix.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">b</span></code>:</dt>
<dd>[out] The linear term of the quadratic expression.</dd>
<dt>Precondition:</dt>
<dd>The size of <code class="docutils literal notranslate"><span class="pre">b</span></code> should be <code class="docutils literal notranslate"><span class="pre">num_variables</span></code>.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">c</span></code>:</dt>
<dd>[out] The constant term of the quadratic expression.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pydrake.symbolic.Evaluate">
<code class="descclassname">pydrake.symbolic.</code><code class="descname">Evaluate</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.symbolic.Evaluate" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>Evaluate(m: numpy.ndarray[object[m, n]], env: Dict[pydrake.symbolic.Variable, float] = {}, generator: pydrake.common._module_py.RandomGenerator = None) -&gt; numpy.ndarray[numpy.float64[m, n]]</li>
</ol>
<p>Evaluates a symbolic matrix <code class="docutils literal notranslate"><span class="pre">m</span></code> using <code class="docutils literal notranslate"><span class="pre">env</span></code> and
<code class="docutils literal notranslate"><span class="pre">random_generator</span></code>.</p>
<p>If there is a random variable in <code class="docutils literal notranslate"><span class="pre">m</span></code> which is unassigned in <code class="docutils literal notranslate"><span class="pre">env</span></code>,
this function uses <code class="docutils literal notranslate"><span class="pre">random_generator</span></code> to sample a value and use the
value to substitute all occurrences of the random variable in <code class="docutils literal notranslate"><span class="pre">m</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">a matrix of double whose size is the size of <code class="docutils literal notranslate"><span class="pre">m</span></code>.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first">RuntimeError if NaN is detected during evaluation.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if <code class="docutils literal notranslate"><span class="pre">m</span></code> includes unassigned random variables but</li>
<li><code class="docutils literal notranslate"><span class="pre">random_generator</span></code> is <code class="docutils literal notranslate"><span class="pre">nullptr</span></code>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>Evaluate(m: numpy.ndarray[object[m, n]], env: Dict[pydrake.symbolic.Variable, float]) -&gt; numpy.ndarray[numpy.float64[m, n]]</li>
</ol>
<p>Evaluates a matrix <code class="docutils literal notranslate"><span class="pre">m</span></code> of symbolic polynomials using <code class="docutils literal notranslate"><span class="pre">env</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a matrix of double whose size is the size of <code class="docutils literal notranslate"><span class="pre">m</span></code>.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if NaN is detected during evaluation.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pydrake.symbolic.EvenDegreeMonomialBasis">
<code class="descclassname">pydrake.symbolic.</code><code class="descname">EvenDegreeMonomialBasis</code><span class="sig-paren">(</span><em>vars: pydrake.symbolic.Variables</em>, <em>degree: int</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, 1]]<a class="headerlink" href="#pydrake.symbolic.EvenDegreeMonomialBasis" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns all even degree monomials up to a given degree under the
graded reverse lexicographic order. A monomial has an even degree if
its total degree is even. So xy is an even degree monomial (degree 2)
while x²y is not (degree 3). Note that graded reverse lexicographic
order uses the total order among Variable which is based on a
variable’s unique ID. For example, for a given variable ordering x &gt; y
&gt; z, <code class="docutils literal notranslate"><span class="pre">EvenDegreeMonomialBasis({x,</span> <span class="pre">y,</span> <span class="pre">z},</span> <span class="pre">2)</span></code> returns a column vector
<code class="docutils literal notranslate"><span class="pre">[x²,</span> <span class="pre">xy,</span> <span class="pre">y²,</span> <span class="pre">xz,</span> <span class="pre">yz,</span> <span class="pre">z²,</span> <span class="pre">1]</span></code>.</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd><code class="docutils literal notranslate"><span class="pre">vars</span></code> is a non-empty set.</dd>
<dt>Precondition:</dt>
<dd><code class="docutils literal notranslate"><span class="pre">degree</span></code> is a non-negative integer.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pydrake.symbolic.exp">
<code class="descclassname">pydrake.symbolic.</code><code class="descname">exp</code><span class="sig-paren">(</span><em>arg0: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Expression<a class="headerlink" href="#pydrake.symbolic.exp" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="pydrake.symbolic.Expression">
<em class="property">class </em><code class="descclassname">pydrake.symbolic.</code><code class="descname">Expression</code><a class="headerlink" href="#pydrake.symbolic.Expression" title="Permalink to this definition">¶</a></dt>
<dd><p>Represents a symbolic form of an expression.</p>
<p>Its syntax tree is as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">E</span> <span class="p">:</span><span class="o">=</span> <span class="n">Var</span> <span class="o">|</span> <span class="n">Constant</span> <span class="o">|</span> <span class="n">E</span> <span class="o">+</span> <span class="o">...</span> <span class="o">+</span> <span class="n">E</span> <span class="o">|</span> <span class="n">E</span> <span class="o">*</span> <span class="o">...</span> <span class="o">*</span> <span class="n">E</span> <span class="o">|</span> <span class="n">E</span> <span class="o">/</span> <span class="n">E</span> <span class="o">|</span> <span class="n">log</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
<span class="o">|</span> <span class="nb">abs</span><span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="o">|</span> <span class="n">exp</span><span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="o">|</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="o">|</span> <span class="nb">pow</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">E</span><span class="p">)</span> <span class="o">|</span> <span class="n">sin</span><span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="o">|</span> <span class="n">cos</span><span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="o">|</span> <span class="n">tan</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
<span class="o">|</span> <span class="n">asin</span><span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="o">|</span> <span class="n">acos</span><span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="o">|</span> <span class="n">atan</span><span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="o">|</span> <span class="n">atan2</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">E</span><span class="p">)</span> <span class="o">|</span> <span class="n">sinh</span><span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="o">|</span> <span class="n">cosh</span><span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="o">|</span> <span class="n">tanh</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
<span class="o">|</span> <span class="nb">min</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">E</span><span class="p">)</span> <span class="o">|</span> <span class="nb">max</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">E</span><span class="p">)</span> <span class="o">|</span> <span class="n">ceil</span><span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="o">|</span> <span class="n">floor</span><span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="o">|</span> <span class="n">if_then_else</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">E</span><span class="p">)</span>
<span class="o">|</span> <span class="n">NaN</span> <span class="o">|</span> <span class="n">uninterpreted_function</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="p">{</span><span class="n">v_1</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">v_n</span><span class="p">})</span>
</pre></div>
</div>
<p>In the implementation, Expression directly stores Constant values
inline, but in all other cases stores a shared pointer to a const
ExpressionCell class that is a super-class of different kinds of
symbolic expressions (i.e., ExpressionAdd, ExpressionMul,
ExpressionLog, ExpressionSin), which makes it efficient to copy, move,
and assign to an Expression.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">-E is represented as -1 * E internally.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">A subtraction E1 - E2 is represented as E1 + (-1 * E2) internally.</p>
</div>
<p>The following simple simplifications are implemented:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">E</span> <span class="o">+</span> <span class="mi">0</span>             <span class="o">-&gt;</span>  <span class="n">E</span>
<span class="mi">0</span> <span class="o">+</span> <span class="n">E</span>             <span class="o">-&gt;</span>  <span class="n">E</span>
<span class="n">E</span> <span class="o">-</span> <span class="mi">0</span>             <span class="o">-&gt;</span>  <span class="n">E</span>
<span class="n">E</span> <span class="o">-</span> <span class="n">E</span>             <span class="o">-&gt;</span>  <span class="mi">0</span>
<span class="n">E</span> <span class="o">*</span> <span class="mi">1</span>             <span class="o">-&gt;</span>  <span class="n">E</span>
<span class="mi">1</span> <span class="o">*</span> <span class="n">E</span>             <span class="o">-&gt;</span>  <span class="n">E</span>
<span class="n">E</span> <span class="o">*</span> <span class="mi">0</span>             <span class="o">-&gt;</span>  <span class="mi">0</span>
<span class="mi">0</span> <span class="o">*</span> <span class="n">E</span>             <span class="o">-&gt;</span>  <span class="mi">0</span>
<span class="n">E</span> <span class="o">/</span> <span class="mi">1</span>             <span class="o">-&gt;</span>  <span class="n">E</span>
<span class="n">E</span> <span class="o">/</span> <span class="n">E</span>             <span class="o">-&gt;</span>  <span class="mi">1</span>
<span class="nb">pow</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>         <span class="o">-&gt;</span>  <span class="mi">1</span>
<span class="nb">pow</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>         <span class="o">-&gt;</span>  <span class="n">E</span>
<span class="n">E</span> <span class="o">*</span> <span class="n">E</span>             <span class="o">-&gt;</span>  <span class="n">E</span><span class="o">^</span><span class="mi">2</span> <span class="p">(</span><span class="o">=</span> <span class="nb">pow</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="n">sqrt</span><span class="p">(</span><span class="n">E</span> <span class="o">*</span> <span class="n">E</span><span class="p">)</span>       <span class="o">-&gt;</span>  <span class="o">|</span><span class="n">E</span><span class="o">|</span> <span class="p">(</span><span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">E</span><span class="p">))</span>
<span class="n">sqrt</span><span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="o">*</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">E</span>
</pre></div>
</div>
<p>Constant folding is implemented:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">E</span><span class="p">(</span><span class="n">c1</span><span class="p">)</span> <span class="o">+</span> <span class="n">E</span><span class="p">(</span><span class="n">c2</span><span class="p">)</span>  <span class="o">-&gt;</span>  <span class="n">E</span><span class="p">(</span><span class="n">c1</span> <span class="o">+</span> <span class="n">c2</span><span class="p">)</span>    <span class="o">//</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span> <span class="n">are</span> <span class="n">constants</span>
<span class="n">E</span><span class="p">(</span><span class="n">c1</span><span class="p">)</span> <span class="o">-</span> <span class="n">E</span><span class="p">(</span><span class="n">c2</span><span class="p">)</span>  <span class="o">-&gt;</span>  <span class="n">E</span><span class="p">(</span><span class="n">c1</span> <span class="o">-</span> <span class="n">c2</span><span class="p">)</span>
<span class="n">E</span><span class="p">(</span><span class="n">c1</span><span class="p">)</span> <span class="o">*</span> <span class="n">E</span><span class="p">(</span><span class="n">c2</span><span class="p">)</span>  <span class="o">-&gt;</span>  <span class="n">E</span><span class="p">(</span><span class="n">c1</span> <span class="o">*</span> <span class="n">c2</span><span class="p">)</span>
<span class="n">E</span><span class="p">(</span><span class="n">c1</span><span class="p">)</span> <span class="o">/</span> <span class="n">E</span><span class="p">(</span><span class="n">c2</span><span class="p">)</span>  <span class="o">-&gt;</span>  <span class="n">E</span><span class="p">(</span><span class="n">c1</span> <span class="o">/</span> <span class="n">c2</span><span class="p">)</span>
<span class="n">f</span><span class="p">(</span><span class="n">E</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>        <span class="o">-&gt;</span>  <span class="n">E</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>       <span class="o">//</span> <span class="n">c</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">constant</span><span class="p">,</span> <span class="n">f</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">math</span> <span class="n">function</span>
</pre></div>
</div>
<p>For the math functions which are only defined over a restricted domain
(namely, log, sqrt, pow, asin, acos), we check the domain of
argument(s), and throw ValueError exception if a function is not
well-defined for a given argument(s).</p>
<p>Relational operators over expressions (==, !=, &lt;, &gt;, &lt;=, &gt;=) return
symbolic::Formula instead of bool. Those operations are declared in
formula.h file. To check structural equality between two expressions a
separate function, Expression::EqualTo, is provided.</p>
<p>Regarding the arithmetic of an Expression when operating on NaNs, we
have the following rules: 1. NaN values are extremely rare during
typical computations. Because they are difficult to handle
symbolically, we will round that up to “must never occur”. We allow
the user to form ExpressionNaN cells in a symbolic tree. For example,
the user can initialize an Expression to NaN and then overwrite it
later. However, evaluating a tree that has NaN in its evaluated
sub-trees is an error (see rule (3) below). 2. It’s still valid for
code to check <code class="docutils literal notranslate"><span class="pre">isnan</span></code> in order to fail-fast. So we provide
isnan(const Expression&amp;) for the common case of non-NaN value
returning False. This way, code can fail-fast with double yet still
compile with Expression. 3. If there are expressions that embed
separate cases (<code class="docutils literal notranslate"><span class="pre">if_then_else</span></code>), some of the sub-expressions may be
not used in evaluation when they are in the not-taken case (for NaN
reasons or any other reason). Bad values within those not-taken
branches does not cause exceptions. 4. The isnan check is different
than if_then_else. In the latter, the ExpressionNaN is within a dead
sub-expression branch. In the former, it appears in an evaluated
trunk. That goes against rule (1) where a NaN anywhere in a
computation (other than dead code) is an error.</p>
<p>note for Drake developers: under the hood of Expression, we have an
internal::BoxedCell helper class that uses NaN for pointer tagging;
that’s a distinct concept from the Expression::NaN() rules enumerated
just above.</p>
<p>symbolic::Expression can be used as a scalar type of Eigen types.</p>
<dl class="method">
<dt id="pydrake.symbolic.Expression.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.symbolic.Expression.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.symbolic.Expression) -&gt; None</li>
</ol>
<p>Default constructor. It constructs Zero().</p>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.symbolic.Expression, constant: float) -&gt; None</li>
</ol>
<p>Constructs a constant.</p>
<ol class="arabic simple" start="3">
<li>__init__(self: pydrake.symbolic.Expression, var: pydrake.symbolic.Variable) -&gt; None</li>
</ol>
<p>Constructs an expression from <code class="docutils literal notranslate"><span class="pre">var</span></code>.</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd><code class="docutils literal notranslate"><span class="pre">var</span></code> is neither a dummy nor a BOOLEAN variable.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Expression.abs">
<code class="descname">abs</code><span class="sig-paren">(</span><em>self: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Expression<a class="headerlink" href="#pydrake.symbolic.Expression.abs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Expression.acos">
<code class="descname">acos</code><span class="sig-paren">(</span><em>self: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Expression<a class="headerlink" href="#pydrake.symbolic.Expression.acos" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Expression.arccos">
<code class="descname">arccos</code><span class="sig-paren">(</span><em>self: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Expression<a class="headerlink" href="#pydrake.symbolic.Expression.arccos" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Expression.arcsin">
<code class="descname">arcsin</code><span class="sig-paren">(</span><em>self: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Expression<a class="headerlink" href="#pydrake.symbolic.Expression.arcsin" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Expression.arctan">
<code class="descname">arctan</code><span class="sig-paren">(</span><em>self: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Expression<a class="headerlink" href="#pydrake.symbolic.Expression.arctan" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Expression.arctan2">
<code class="descname">arctan2</code><span class="sig-paren">(</span><em>self: pydrake.symbolic.Expression</em>, <em>arg0: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Expression<a class="headerlink" href="#pydrake.symbolic.Expression.arctan2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Expression.asin">
<code class="descname">asin</code><span class="sig-paren">(</span><em>self: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Expression<a class="headerlink" href="#pydrake.symbolic.Expression.asin" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Expression.atan">
<code class="descname">atan</code><span class="sig-paren">(</span><em>self: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Expression<a class="headerlink" href="#pydrake.symbolic.Expression.atan" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Expression.atan2">
<code class="descname">atan2</code><span class="sig-paren">(</span><em>self: pydrake.symbolic.Expression</em>, <em>arg0: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Expression<a class="headerlink" href="#pydrake.symbolic.Expression.atan2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Expression.ceil">
<code class="descname">ceil</code><span class="sig-paren">(</span><em>self: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Expression<a class="headerlink" href="#pydrake.symbolic.Expression.ceil" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Expression.cos">
<code class="descname">cos</code><span class="sig-paren">(</span><em>self: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Expression<a class="headerlink" href="#pydrake.symbolic.Expression.cos" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Expression.cosh">
<code class="descname">cosh</code><span class="sig-paren">(</span><em>self: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Expression<a class="headerlink" href="#pydrake.symbolic.Expression.cosh" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Expression.Differentiate">
<code class="descname">Differentiate</code><span class="sig-paren">(</span><em>self: pydrake.symbolic.Expression</em>, <em>x: pydrake.symbolic.Variable</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Expression<a class="headerlink" href="#pydrake.symbolic.Expression.Differentiate" title="Permalink to this definition">¶</a></dt>
<dd><p>Differentiates this symbolic expression with respect to the variable
<code class="docutils literal notranslate"><span class="pre">var</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if it is not differentiable.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Expression.EqualTo">
<code class="descname">EqualTo</code><span class="sig-paren">(</span><em>self: pydrake.symbolic.Expression</em>, <em>arg0: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.symbolic.Expression.EqualTo" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks structural equality.</p>
<p>Two expressions e1 and e2 are structurally equal when they have the
same internal AST(abstract-syntax tree) representation. Please note
that we can have two computationally (or extensionally) equivalent
expressions which are not structurally equal. For example, consider:</p>
<p>e1 = 2 * (x + y) e2 = 2x + 2y</p>
<p>Obviously, we know that e1 and e2 are evaluated to the same value for
all assignments to x and y. However, e1 and e2 are not structurally
equal by the definition. Note that e1 is a multiplication expression
(is_multiplication(e1) is true) while e2 is an addition expression
(is_addition(e2) is true).</p>
<p>One main reason we use structural equality in EqualTo is due to
Richardson’s Theorem. It states that checking ∀x. E(x) = F(x) is
undecidable when we allow sin, asin, log, exp in E and F. Read
<a class="reference external" href="https://en.wikipedia.org/wiki/Richardson%27s_theorem">https://en.wikipedia.org/wiki/Richardson%27s_theorem</a> for details.</p>
<p>Note that for polynomial cases, you can use Expand method and check if
two polynomial expressions p1 and p2 are computationally equal. To do
so, you check the following:</p>
<p>p1.Expand().EqualTo(p2.Expand())</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Expression.Evaluate">
<code class="descname">Evaluate</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.symbolic.Expression.Evaluate" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>Evaluate(self: pydrake.symbolic.Expression, env: Dict[pydrake.symbolic.Variable, float] = {}, generator: pydrake.common._module_py.RandomGenerator = None) -&gt; float</li>
</ol>
<p>Evaluates using a given environment (by default, an empty environment)
and a random number generator. If there is a random variable in this
expression which is unassigned in <code class="docutils literal notranslate"><span class="pre">env</span></code>, this method uses
<code class="docutils literal notranslate"><span class="pre">random_generator</span></code> to sample a value and use the value to substitute
all occurrences of the variable in this expression.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first simple">
<li>RuntimeError if there exists a non-random variable in this</li>
<li>expression whose assignment is not provided by <code class="docutils literal notranslate"><span class="pre">env</span></code>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first simple">
<li>RuntimeError if an unassigned random variable is detected while</li>
<li><code class="docutils literal notranslate"><span class="pre">random_generator</span></code> is <code class="docutils literal notranslate"><span class="pre">nullptr</span></code>.</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last">RuntimeError if NaN is detected during evaluation.</p>
</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>Evaluate(self: pydrake.symbolic.Expression, generator: pydrake.common._module_py.RandomGenerator) -&gt; float</li>
</ol>
<p>Evaluates using an empty environment and a random number generator. It
uses <code class="docutils literal notranslate"><span class="pre">random_generator</span></code> to sample values for the random variables in
this expression.</p>
<p>See the above overload for the exceptions that it might throw.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Expression.EvaluatePartial">
<code class="descname">EvaluatePartial</code><span class="sig-paren">(</span><em>self: pydrake.symbolic.Expression, env: Dict[pydrake.symbolic.Variable, float]</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Expression<a class="headerlink" href="#pydrake.symbolic.Expression.EvaluatePartial" title="Permalink to this definition">¶</a></dt>
<dd><p>Partially evaluates this expression using an environment <code class="docutils literal notranslate"><span class="pre">env</span></code>.
Internally, this method promotes <code class="docutils literal notranslate"><span class="pre">env</span></code> into a substitution (Variable
→ Expression) and call Evaluate::Substitute with it.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if NaN is detected during evaluation.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Expression.exp">
<code class="descname">exp</code><span class="sig-paren">(</span><em>self: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Expression<a class="headerlink" href="#pydrake.symbolic.Expression.exp" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Expression.Expand">
<code class="descname">Expand</code><span class="sig-paren">(</span><em>self: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Expression<a class="headerlink" href="#pydrake.symbolic.Expression.Expand" title="Permalink to this definition">¶</a></dt>
<dd><p>Expands out products and positive integer powers in expression. For
example, <code class="docutils literal notranslate"><span class="pre">(x</span> <span class="pre">+</span> <span class="pre">1)</span> <span class="pre">*</span> <span class="pre">(x</span> <span class="pre">-</span> <span class="pre">1)</span></code> is expanded to <code class="docutils literal notranslate"><span class="pre">x^2</span> <span class="pre">-</span> <span class="pre">1</span></code> and <code class="docutils literal notranslate"><span class="pre">(x</span> <span class="pre">+</span>
<span class="pre">y)^2</span></code> is expanded to <code class="docutils literal notranslate"><span class="pre">x^2</span> <span class="pre">+</span> <span class="pre">2xy</span> <span class="pre">+</span> <span class="pre">y^2</span></code>. Note that Expand applies
recursively to sub-expressions. For instance, <code class="docutils literal notranslate"><span class="pre">sin(2</span> <span class="pre">*</span> <span class="pre">(x</span> <span class="pre">+</span> <span class="pre">y))</span></code> is
expanded to <code class="docutils literal notranslate"><span class="pre">sin(2x</span> <span class="pre">+</span> <span class="pre">2y)</span></code>. It also simplifies “division by
constant” cases. See “drake/common/test/symbolic_expansion_test.cc” to
find the examples.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if NaN is detected during expansion.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Expression.floor">
<code class="descname">floor</code><span class="sig-paren">(</span><em>self: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Expression<a class="headerlink" href="#pydrake.symbolic.Expression.floor" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Expression.get_kind">
<code class="descname">get_kind</code><span class="sig-paren">(</span><em>self: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.ExpressionKind<a class="headerlink" href="#pydrake.symbolic.Expression.get_kind" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns expression kind.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Expression.GetVariables">
<code class="descname">GetVariables</code><span class="sig-paren">(</span><em>self: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Variables<a class="headerlink" href="#pydrake.symbolic.Expression.GetVariables" title="Permalink to this definition">¶</a></dt>
<dd><p>Collects variables in expression.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Expression.inv">
<code class="descname">inv</code><span class="sig-paren">(</span><em>self: numpy.ndarray[object[m, n]]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, n]]<a class="headerlink" href="#pydrake.symbolic.Expression.inv" title="Permalink to this definition">¶</a></dt>
<dd><p>Symbolic matrix inverse</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Expression.is_polynomial">
<code class="descname">is_polynomial</code><span class="sig-paren">(</span><em>self: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.symbolic.Expression.is_polynomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks if this symbolic expression is convertible to Polynomial.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Expression.Jacobian">
<code class="descname">Jacobian</code><span class="sig-paren">(</span><em>self: pydrake.symbolic.Expression, vars: numpy.ndarray[object[m, 1]]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[1, n]]<a class="headerlink" href="#pydrake.symbolic.Expression.Jacobian" title="Permalink to this definition">¶</a></dt>
<dd><p>Let <code class="docutils literal notranslate"><span class="pre">f</span></code> be this Expression, computes a row vector of derivatives,
<code class="docutils literal notranslate"><span class="pre">[∂f/∂vars(0),</span> <span class="pre">...</span> <span class="pre">,</span> <span class="pre">∂f/∂vars(n-1)]</span></code> with respect to the variables
<code class="docutils literal notranslate"><span class="pre">vars</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Expression.log">
<code class="descname">log</code><span class="sig-paren">(</span><em>self: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Expression<a class="headerlink" href="#pydrake.symbolic.Expression.log" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Expression.max">
<code class="descname">max</code><span class="sig-paren">(</span><em>self: pydrake.symbolic.Expression</em>, <em>arg0: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Expression<a class="headerlink" href="#pydrake.symbolic.Expression.max" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Expression.min">
<code class="descname">min</code><span class="sig-paren">(</span><em>self: pydrake.symbolic.Expression</em>, <em>arg0: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Expression<a class="headerlink" href="#pydrake.symbolic.Expression.min" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Expression.pow">
<code class="descname">pow</code><span class="sig-paren">(</span><em>self: pydrake.symbolic.Expression</em>, <em>arg0: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Expression<a class="headerlink" href="#pydrake.symbolic.Expression.pow" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Expression.sin">
<code class="descname">sin</code><span class="sig-paren">(</span><em>self: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Expression<a class="headerlink" href="#pydrake.symbolic.Expression.sin" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Expression.sinh">
<code class="descname">sinh</code><span class="sig-paren">(</span><em>self: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Expression<a class="headerlink" href="#pydrake.symbolic.Expression.sinh" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Expression.sqrt">
<code class="descname">sqrt</code><span class="sig-paren">(</span><em>self: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Expression<a class="headerlink" href="#pydrake.symbolic.Expression.sqrt" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Expression.Substitute">
<code class="descname">Substitute</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.symbolic.Expression.Substitute" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>Substitute(self: pydrake.symbolic.Expression, var: pydrake.symbolic.Variable, e: pydrake.symbolic.Expression) -&gt; pydrake.symbolic.Expression</li>
</ol>
<p>Returns a copy of this expression replacing all occurrences of <code class="docutils literal notranslate"><span class="pre">var</span></code>
with <code class="docutils literal notranslate"><span class="pre">e</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if NaN is detected during substitution.</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>Substitute(self: pydrake.symbolic.Expression, s: Dict[pydrake.symbolic.Variable, pydrake.symbolic.Expression]) -&gt; pydrake.symbolic.Expression</li>
</ol>
<p>Returns a copy of this expression replacing all occurrences of the
variables in <code class="docutils literal notranslate"><span class="pre">s</span></code> with corresponding expressions in <code class="docutils literal notranslate"><span class="pre">s</span></code>. Note that
the substitutions occur simultaneously. For example, (x /
y).Substitute({{x, y}, {y, x}}) gets (y / x).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if NaN is detected during substitution.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Expression.tan">
<code class="descname">tan</code><span class="sig-paren">(</span><em>self: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Expression<a class="headerlink" href="#pydrake.symbolic.Expression.tan" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Expression.tanh">
<code class="descname">tanh</code><span class="sig-paren">(</span><em>self: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Expression<a class="headerlink" href="#pydrake.symbolic.Expression.tanh" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Expression.to_string">
<code class="descname">to_string</code><span class="sig-paren">(</span><em>self: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#pydrake.symbolic.Expression.to_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns string representation of Expression.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Expression.Unapply">
<code class="descname">Unapply</code><span class="sig-paren">(</span><em>self: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; object<a class="headerlink" href="#pydrake.symbolic.Expression.Unapply" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an expression, returns a tuple (ctor, args) that would re-create an
equivalent expression when called as ctor(<a href="#id1"><span class="problematic" id="id2">*</span></a>args).  This is a useful way to
unpack the contents of a compound expression, e.g., to obtain the terms of
an addition.  In many cases (all arithmetic operators, trig functions,
max, min, sqrt, etc.), the returned args will all be either Expressions or
floats; in other cases (e.g., if_then_else) some args will other types
(e.g., a Formula).  To check the form (i.e., kind) of an expression, use
e.get_kind(); do not try to infer it from the returned ctor’s identity.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.symbolic.ExpressionKind">
<em class="property">class </em><code class="descclassname">pydrake.symbolic.</code><code class="descname">ExpressionKind</code><a class="headerlink" href="#pydrake.symbolic.ExpressionKind" title="Permalink to this definition">¶</a></dt>
<dd><p>Kinds of symbolic expressions. The constants here are carefully chosen
to support nanboxing. For all elements except Constant, the bit
pattern must have have 0x7FF0 bits set but must not be exactly 0x7FF0
nor 0xFFF0 (reserved for ±infinity). Refer to the details in
boxed_cell.h for more information.</p>
<p>Members:</p>
<blockquote>
<div><p>Constant : constant (double)</p>
<p>Var : variable</p>
<p>Add : addition (+)</p>
<p>Mul : multiplication (*)</p>
<p>Div : division (/)</p>
<p>Log : logarithms</p>
<p>Abs : absolute value function</p>
<p>Exp : exponentiation</p>
<p>Sqrt : square root</p>
<p>Pow : power function</p>
<p>Sin : sine</p>
<p>Cos : cosine</p>
<p>Tan : tangent</p>
<p>Asin : arcsine</p>
<p>Acos : arccosine</p>
<p>Atan : arctangent</p>
<p>Atan2 : arctangent2 (atan2(y,x) = atan(y/x))</p>
<p>Sinh : hyperbolic sine</p>
<p>Cosh : hyperbolic cosine</p>
<p>Tanh : hyperbolic tangent</p>
<p>Min : min</p>
<p>Max : max</p>
<p>Ceil : ceil</p>
<p>Floor : floor</p>
<p>IfThenElse : if then else</p>
<p>NaN : NaN</p>
<p>UninterpretedFunction : Uninterpreted function</p>
</div></blockquote>
<dl class="method">
<dt id="pydrake.symbolic.ExpressionKind.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.symbolic.ExpressionKind</em>, <em>value: int</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.symbolic.ExpressionKind.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.symbolic.ExpressionKind.Abs">
<code class="descname">Abs</code><em class="property"> = &lt;ExpressionKind.Abs: 32758&gt;</em><a class="headerlink" href="#pydrake.symbolic.ExpressionKind.Abs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.symbolic.ExpressionKind.Acos">
<code class="descname">Acos</code><em class="property"> = &lt;ExpressionKind.Acos: 32766&gt;</em><a class="headerlink" href="#pydrake.symbolic.ExpressionKind.Acos" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.symbolic.ExpressionKind.Add">
<code class="descname">Add</code><em class="property"> = &lt;ExpressionKind.Add: 32754&gt;</em><a class="headerlink" href="#pydrake.symbolic.ExpressionKind.Add" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.symbolic.ExpressionKind.Asin">
<code class="descname">Asin</code><em class="property"> = &lt;ExpressionKind.Asin: 32765&gt;</em><a class="headerlink" href="#pydrake.symbolic.ExpressionKind.Asin" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.symbolic.ExpressionKind.Atan">
<code class="descname">Atan</code><em class="property"> = &lt;ExpressionKind.Atan: 32767&gt;</em><a class="headerlink" href="#pydrake.symbolic.ExpressionKind.Atan" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.symbolic.ExpressionKind.Atan2">
<code class="descname">Atan2</code><em class="property"> = &lt;ExpressionKind.Atan2: 65521&gt;</em><a class="headerlink" href="#pydrake.symbolic.ExpressionKind.Atan2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.symbolic.ExpressionKind.Ceil">
<code class="descname">Ceil</code><em class="property"> = &lt;ExpressionKind.Ceil: 65527&gt;</em><a class="headerlink" href="#pydrake.symbolic.ExpressionKind.Ceil" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.symbolic.ExpressionKind.Constant">
<code class="descname">Constant</code><em class="property"> = &lt;ExpressionKind.Constant: 0&gt;</em><a class="headerlink" href="#pydrake.symbolic.ExpressionKind.Constant" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.symbolic.ExpressionKind.Cos">
<code class="descname">Cos</code><em class="property"> = &lt;ExpressionKind.Cos: 32763&gt;</em><a class="headerlink" href="#pydrake.symbolic.ExpressionKind.Cos" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.symbolic.ExpressionKind.Cosh">
<code class="descname">Cosh</code><em class="property"> = &lt;ExpressionKind.Cosh: 65523&gt;</em><a class="headerlink" href="#pydrake.symbolic.ExpressionKind.Cosh" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.symbolic.ExpressionKind.Div">
<code class="descname">Div</code><em class="property"> = &lt;ExpressionKind.Div: 32756&gt;</em><a class="headerlink" href="#pydrake.symbolic.ExpressionKind.Div" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.symbolic.ExpressionKind.Exp">
<code class="descname">Exp</code><em class="property"> = &lt;ExpressionKind.Exp: 32759&gt;</em><a class="headerlink" href="#pydrake.symbolic.ExpressionKind.Exp" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.symbolic.ExpressionKind.Floor">
<code class="descname">Floor</code><em class="property"> = &lt;ExpressionKind.Floor: 65528&gt;</em><a class="headerlink" href="#pydrake.symbolic.ExpressionKind.Floor" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.symbolic.ExpressionKind.IfThenElse">
<code class="descname">IfThenElse</code><em class="property"> = &lt;ExpressionKind.IfThenElse: 65529&gt;</em><a class="headerlink" href="#pydrake.symbolic.ExpressionKind.IfThenElse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.symbolic.ExpressionKind.Log">
<code class="descname">Log</code><em class="property"> = &lt;ExpressionKind.Log: 32757&gt;</em><a class="headerlink" href="#pydrake.symbolic.ExpressionKind.Log" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.symbolic.ExpressionKind.Max">
<code class="descname">Max</code><em class="property"> = &lt;ExpressionKind.Max: 65526&gt;</em><a class="headerlink" href="#pydrake.symbolic.ExpressionKind.Max" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.symbolic.ExpressionKind.Min">
<code class="descname">Min</code><em class="property"> = &lt;ExpressionKind.Min: 65525&gt;</em><a class="headerlink" href="#pydrake.symbolic.ExpressionKind.Min" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.symbolic.ExpressionKind.Mul">
<code class="descname">Mul</code><em class="property"> = &lt;ExpressionKind.Mul: 32755&gt;</em><a class="headerlink" href="#pydrake.symbolic.ExpressionKind.Mul" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.symbolic.ExpressionKind.name">
<code class="descname">name</code><a class="headerlink" href="#pydrake.symbolic.ExpressionKind.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.symbolic.ExpressionKind.NaN">
<code class="descname">NaN</code><em class="property"> = &lt;ExpressionKind.NaN: 65530&gt;</em><a class="headerlink" href="#pydrake.symbolic.ExpressionKind.NaN" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.symbolic.ExpressionKind.Pow">
<code class="descname">Pow</code><em class="property"> = &lt;ExpressionKind.Pow: 32761&gt;</em><a class="headerlink" href="#pydrake.symbolic.ExpressionKind.Pow" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.symbolic.ExpressionKind.Sin">
<code class="descname">Sin</code><em class="property"> = &lt;ExpressionKind.Sin: 32762&gt;</em><a class="headerlink" href="#pydrake.symbolic.ExpressionKind.Sin" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.symbolic.ExpressionKind.Sinh">
<code class="descname">Sinh</code><em class="property"> = &lt;ExpressionKind.Sinh: 65522&gt;</em><a class="headerlink" href="#pydrake.symbolic.ExpressionKind.Sinh" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.symbolic.ExpressionKind.Sqrt">
<code class="descname">Sqrt</code><em class="property"> = &lt;ExpressionKind.Sqrt: 32760&gt;</em><a class="headerlink" href="#pydrake.symbolic.ExpressionKind.Sqrt" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.symbolic.ExpressionKind.Tan">
<code class="descname">Tan</code><em class="property"> = &lt;ExpressionKind.Tan: 32764&gt;</em><a class="headerlink" href="#pydrake.symbolic.ExpressionKind.Tan" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.symbolic.ExpressionKind.Tanh">
<code class="descname">Tanh</code><em class="property"> = &lt;ExpressionKind.Tanh: 65524&gt;</em><a class="headerlink" href="#pydrake.symbolic.ExpressionKind.Tanh" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.symbolic.ExpressionKind.UninterpretedFunction">
<code class="descname">UninterpretedFunction</code><em class="property"> = &lt;ExpressionKind.UninterpretedFunction: 65531&gt;</em><a class="headerlink" href="#pydrake.symbolic.ExpressionKind.UninterpretedFunction" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.symbolic.ExpressionKind.value">
<code class="descname">value</code><a class="headerlink" href="#pydrake.symbolic.ExpressionKind.value" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.symbolic.ExpressionKind.Var">
<code class="descname">Var</code><em class="property"> = &lt;ExpressionKind.Var: 32753&gt;</em><a class="headerlink" href="#pydrake.symbolic.ExpressionKind.Var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="pydrake.symbolic.ExtractVariablesFromExpression">
<code class="descclassname">pydrake.symbolic.</code><code class="descname">ExtractVariablesFromExpression</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.symbolic.ExtractVariablesFromExpression" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>ExtractVariablesFromExpression(e: pydrake.symbolic.Expression) -&gt; Tuple[numpy.ndarray[object[m, 1]], Dict[int, int]]</li>
</ol>
<p>Given an expression <code class="docutils literal notranslate"><span class="pre">e</span></code>, extracts all variables inside <code class="docutils literal notranslate"><span class="pre">e</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">e</span></code>:</dt>
<dd>A symbolic expression.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">pair</span></code>:</dt>
<dd>pair.first is the variables in <code class="docutils literal notranslate"><span class="pre">e</span></code>. pair.second is the mapping
from the variable ID to the index in pair.first, such that
pair.second[pair.first(i).get_id()] = i</dd>
</dl>
<ol class="arabic simple" start="2">
<li>ExtractVariablesFromExpression(expressions: numpy.ndarray[object[m, 1]]) -&gt; Tuple[numpy.ndarray[object[m, 1]], Dict[int, int]]</li>
</ol>
<p>Overloads ExtractVariablesFromExpression but with a vector of
expressions.</p>
</dd></dl>

<dl class="function">
<dt id="pydrake.symbolic.floor">
<code class="descclassname">pydrake.symbolic.</code><code class="descname">floor</code><span class="sig-paren">(</span><em>arg0: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Expression<a class="headerlink" href="#pydrake.symbolic.floor" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pydrake.symbolic.forall">
<code class="descclassname">pydrake.symbolic.</code><code class="descname">forall</code><span class="sig-paren">(</span><em>vars: pydrake.symbolic.Variables</em>, <em>f: pydrake.symbolic.Formula</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Formula<a class="headerlink" href="#pydrake.symbolic.forall" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a formula <code class="docutils literal notranslate"><span class="pre">f</span></code>, universally quantified by variables <code class="docutils literal notranslate"><span class="pre">vars</span></code>.</p>
</dd></dl>

<dl class="class">
<dt id="pydrake.symbolic.Formula">
<em class="property">class </em><code class="descclassname">pydrake.symbolic.</code><code class="descname">Formula</code><a class="headerlink" href="#pydrake.symbolic.Formula" title="Permalink to this definition">¶</a></dt>
<dd><p>Represents a symbolic form of a first-order logic formula.</p>
<p>It has the following grammar:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>F := ⊥ | ⊤ | Var | E = E | E ≠ E | E &gt; E | E ≥ E | E &lt; E | E ≤ E
| E ∧ ... ∧ E | E ∨ ... ∨ E | ¬F | ∀ x₁, ..., xn. F
</pre></div>
</div>
<p>In the implementation, Formula is a simple wrapper including a shared
pointer to FormulaCell class which is a super-class of different kinds
of symbolic formulas (i.e. FormulaAnd, FormulaOr, FormulaEq). Note
that it includes a shared pointer, not a unique pointer, to allow
sharing sub-expressions.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The sharing of sub-expressions is not yet implemented.</p>
</div>
<p>The following simple simplifications are implemented:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>E1 = E2        -&gt;  True    (if E1 and E2 are structurally equal)
E1 ≠ E2        -&gt;  False   (if E1 and E2 are structurally equal)
E1 &gt; E2        -&gt;  False   (if E1 and E2 are structurally equal)
E1 ≥ E2        -&gt;  True    (if E1 and E2 are structurally equal)
E1 &lt; E2        -&gt;  False   (if E1 and E2 are structurally equal)
E1 ≤ E2        -&gt;  True    (if E1 and E2 are structurally equal)
F1 ∧ F2        -&gt;  False   (if either F1 or F2 is False)
F1 ∨ F2        -&gt;  True    (if either F1 or F2 is True)
¬(¬(F))        -&gt;  F
</pre></div>
</div>
<p>We flatten nested conjunctions (or disjunctions) at the construction.
A conjunction (resp. disjunction) takes a set of conjuncts (resp.
disjuncts). Note that any duplicated conjunct/disjunct is removed. For
example, both of <code class="docutils literal notranslate"><span class="pre">f1</span> <span class="pre">&amp;&amp;</span> <span class="pre">(f2</span> <span class="pre">&amp;&amp;</span> <span class="pre">f1)</span></code> and <code class="docutils literal notranslate"><span class="pre">(f1</span> <span class="pre">&amp;&amp;</span> <span class="pre">f2)</span> <span class="pre">&amp;&amp;</span> <span class="pre">f1</span></code> are
flattened to <code class="docutils literal notranslate"><span class="pre">f1</span> <span class="pre">&amp;&amp;</span> <span class="pre">f2</span> <span class="pre">&amp;&amp;</span> <span class="pre">f1</span></code> and simplified into <code class="docutils literal notranslate"><span class="pre">f1</span> <span class="pre">&amp;&amp;</span> <span class="pre">f2</span></code>. As a
result, the two are identified as the same formula.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Formula class has an explicit conversion operator to bool. It
evaluates a symbolic formula under an empty environment. If a
symbolic formula includes variables, the conversion operator
throws an exception. This operator is only intended for
third-party code doing things like <code class="docutils literal notranslate"><span class="pre">(imag(SymbolicExpression(0))</span>
<span class="pre">==</span> <span class="pre">SymbolicExpression(0))</span> <span class="pre">{</span> <span class="pre">...</span> <span class="pre">};</span></code> that we found in Eigen3
codebase. In general, a user of this class should explicitly call
<code class="docutils literal notranslate"><span class="pre">Evaluate</span></code> from within Drake for readability.</p>
</div>
<dl class="method">
<dt id="pydrake.symbolic.Formula.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.symbolic.Formula.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.symbolic.Formula) -&gt; None</li>
</ol>
<p>Default constructor. It constructs Zero().</p>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.symbolic.Formula, var: pydrake.symbolic.Variable) -&gt; None</li>
</ol>
<p>Constructs an expression from <code class="docutils literal notranslate"><span class="pre">var</span></code>.</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd><code class="docutils literal notranslate"><span class="pre">var</span></code> is neither a dummy nor a BOOLEAN variable.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Formula.EqualTo">
<code class="descname">EqualTo</code><span class="sig-paren">(</span><em>self: pydrake.symbolic.Formula</em>, <em>arg0: pydrake.symbolic.Formula</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.symbolic.Formula.EqualTo" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks structural equality.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Formula.Evaluate">
<code class="descname">Evaluate</code><span class="sig-paren">(</span><em>self: pydrake.symbolic.Formula</em>, <em>env: Dict[pydrake.symbolic.Variable</em>, <em>float] = {}</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.symbolic.Formula.Evaluate" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluates using a given environment (by default, an empty environment)
and a random number generator. If there is a random variable in this
formula which is unassigned in <code class="docutils literal notranslate"><span class="pre">env</span></code>, it uses <code class="docutils literal notranslate"><span class="pre">random_generator</span></code>
to sample a value and use it to substitute all occurrences of the
random variable in this formula.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first simple">
<li>RuntimeError if a variable <code class="docutils literal notranslate"><span class="pre">v</span></code> is needed for an evaluation but</li>
<li>not provided by <code class="docutils literal notranslate"><span class="pre">env</span></code>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if an unassigned random variable is detected while</li>
<li><code class="docutils literal notranslate"><span class="pre">random_generator</span></code> is <code class="docutils literal notranslate"><span class="pre">nullptr</span></code>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.symbolic.Formula.False">
<em class="property">static </em><code class="descname">False</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Formula<a class="headerlink" href="#pydrake.symbolic.Formula.False" title="Permalink to this definition">¶</a></dt>
<dd><p>Symbolic formula representing false.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.symbolic.Formula.False_">
<em class="property">static </em><code class="descname">False_</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Formula<a class="headerlink" href="#pydrake.symbolic.Formula.False_" title="Permalink to this definition">¶</a></dt>
<dd><p>Symbolic formula representing false.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Formula.get_kind">
<code class="descname">get_kind</code><span class="sig-paren">(</span><em>self: pydrake.symbolic.Formula</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.FormulaKind<a class="headerlink" href="#pydrake.symbolic.Formula.get_kind" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Formula.GetFreeVariables">
<code class="descname">GetFreeVariables</code><span class="sig-paren">(</span><em>self: pydrake.symbolic.Formula</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Variables<a class="headerlink" href="#pydrake.symbolic.Formula.GetFreeVariables" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets free variables (unquantified variables).</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Formula.Substitute">
<code class="descname">Substitute</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.symbolic.Formula.Substitute" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>Substitute(self: pydrake.symbolic.Formula, var: pydrake.symbolic.Variable, e: pydrake.symbolic.Expression) -&gt; pydrake.symbolic.Formula</li>
</ol>
<p>Returns a copy of this formula replacing all occurrences of <code class="docutils literal notranslate"><span class="pre">var</span></code>
with <code class="docutils literal notranslate"><span class="pre">e</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if NaN is detected during substitution.</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>Substitute(self: pydrake.symbolic.Formula, var: pydrake.symbolic.Variable, e: pydrake.symbolic.Variable) -&gt; pydrake.symbolic.Formula</li>
</ol>
<p>Returns a copy of this formula replacing all occurrences of <code class="docutils literal notranslate"><span class="pre">var</span></code>
with <code class="docutils literal notranslate"><span class="pre">e</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if NaN is detected during substitution.</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="3">
<li>Substitute(self: pydrake.symbolic.Formula, var: pydrake.symbolic.Variable, e: float) -&gt; pydrake.symbolic.Formula</li>
</ol>
<p>Returns a copy of this formula replacing all occurrences of <code class="docutils literal notranslate"><span class="pre">var</span></code>
with <code class="docutils literal notranslate"><span class="pre">e</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if NaN is detected during substitution.</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="4">
<li>Substitute(self: pydrake.symbolic.Formula, s: Dict[pydrake.symbolic.Variable, pydrake.symbolic.Expression]) -&gt; pydrake.symbolic.Formula</li>
</ol>
<p>Returns a copy of this formula replacing all occurrences of the
variables in <code class="docutils literal notranslate"><span class="pre">s</span></code> with corresponding expressions in <code class="docutils literal notranslate"><span class="pre">s</span></code>. Note that
the substitutions occur simultaneously. For example, (x / y &gt;
0).Substitute({{x, y}, {y, x}}) gets (y / x &gt; 0).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if NaN is detected during substitution.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Formula.to_string">
<code class="descname">to_string</code><span class="sig-paren">(</span><em>self: pydrake.symbolic.Formula</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#pydrake.symbolic.Formula.to_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns string representation of Formula.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.symbolic.Formula.True">
<em class="property">static </em><code class="descname">True</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Formula<a class="headerlink" href="#pydrake.symbolic.Formula.True" title="Permalink to this definition">¶</a></dt>
<dd><p>Symbolic formula representing true.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.symbolic.Formula.True_">
<em class="property">static </em><code class="descname">True_</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Formula<a class="headerlink" href="#pydrake.symbolic.Formula.True_" title="Permalink to this definition">¶</a></dt>
<dd><p>Symbolic formula representing true.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Formula.Unapply">
<code class="descname">Unapply</code><span class="sig-paren">(</span><em>self: pydrake.symbolic.Formula</em><span class="sig-paren">)</span> &#x2192; object<a class="headerlink" href="#pydrake.symbolic.Formula.Unapply" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a formula, returns a tuple (ctor, args) that would re-create an
equivalent formula when called as ctor(<a href="#id3"><span class="problematic" id="id4">*</span></a>args).  This is a useful way to
unpack the contents of a compound formula, e.g., to obtain the terms of
a comparison.  For relational formulae (==, &lt;, &gt;, etc.) the returned args
will both be of type Expression.  For compound formulae (and, or, not) the
returned args will be of type Formula.  To check the form (i.e., kind) of
a formula, use f.get_kind(); do not try to infer it from he returned
ctor’s identity.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.symbolic.FormulaKind">
<em class="property">class </em><code class="descclassname">pydrake.symbolic.</code><code class="descname">FormulaKind</code><a class="headerlink" href="#pydrake.symbolic.FormulaKind" title="Permalink to this definition">¶</a></dt>
<dd><p>Kinds of symbolic formulas.</p>
<p>Members:</p>
<blockquote>
<div><p>False : ⊥</p>
<p>True : ⊤</p>
<p>Var : Boolean Variable</p>
<p>Eq : =</p>
<p>Neq : !=</p>
<p>Gt : &gt;</p>
<p>Geq : &gt;=</p>
<p>Lt : &lt;</p>
<p>Leq : &lt;=</p>
<p>And : Conjunction (∧)</p>
<p>Or : Disjunction (∨)</p>
<p>Not : Negation (¬)</p>
<p>Forall : Universal quantification (∀)</p>
<p>Isnan : NaN check predicate</p>
<p>PositiveSemidefinite : Positive semidefinite matrix</p>
</div></blockquote>
<dl class="method">
<dt id="pydrake.symbolic.FormulaKind.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.symbolic.FormulaKind</em>, <em>value: int</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.symbolic.FormulaKind.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.symbolic.FormulaKind.And">
<code class="descname">And</code><em class="property"> = &lt;FormulaKind.And: 9&gt;</em><a class="headerlink" href="#pydrake.symbolic.FormulaKind.And" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.symbolic.FormulaKind.Eq">
<code class="descname">Eq</code><em class="property"> = &lt;FormulaKind.Eq: 3&gt;</em><a class="headerlink" href="#pydrake.symbolic.FormulaKind.Eq" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.symbolic.FormulaKind.False">
<code class="descname">False</code><em class="property"> = &lt;FormulaKind.False: 0&gt;</em><a class="headerlink" href="#pydrake.symbolic.FormulaKind.False" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.symbolic.FormulaKind.Forall">
<code class="descname">Forall</code><em class="property"> = &lt;FormulaKind.Forall: 12&gt;</em><a class="headerlink" href="#pydrake.symbolic.FormulaKind.Forall" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.symbolic.FormulaKind.Geq">
<code class="descname">Geq</code><em class="property"> = &lt;FormulaKind.Geq: 6&gt;</em><a class="headerlink" href="#pydrake.symbolic.FormulaKind.Geq" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.symbolic.FormulaKind.Gt">
<code class="descname">Gt</code><em class="property"> = &lt;FormulaKind.Gt: 5&gt;</em><a class="headerlink" href="#pydrake.symbolic.FormulaKind.Gt" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.symbolic.FormulaKind.Isnan">
<code class="descname">Isnan</code><em class="property"> = &lt;FormulaKind.Isnan: 13&gt;</em><a class="headerlink" href="#pydrake.symbolic.FormulaKind.Isnan" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.symbolic.FormulaKind.Leq">
<code class="descname">Leq</code><em class="property"> = &lt;FormulaKind.Leq: 8&gt;</em><a class="headerlink" href="#pydrake.symbolic.FormulaKind.Leq" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.symbolic.FormulaKind.Lt">
<code class="descname">Lt</code><em class="property"> = &lt;FormulaKind.Lt: 7&gt;</em><a class="headerlink" href="#pydrake.symbolic.FormulaKind.Lt" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.symbolic.FormulaKind.name">
<code class="descname">name</code><a class="headerlink" href="#pydrake.symbolic.FormulaKind.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.symbolic.FormulaKind.Neq">
<code class="descname">Neq</code><em class="property"> = &lt;FormulaKind.Neq: 4&gt;</em><a class="headerlink" href="#pydrake.symbolic.FormulaKind.Neq" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.symbolic.FormulaKind.Not">
<code class="descname">Not</code><em class="property"> = &lt;FormulaKind.Not: 11&gt;</em><a class="headerlink" href="#pydrake.symbolic.FormulaKind.Not" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.symbolic.FormulaKind.Or">
<code class="descname">Or</code><em class="property"> = &lt;FormulaKind.Or: 10&gt;</em><a class="headerlink" href="#pydrake.symbolic.FormulaKind.Or" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.symbolic.FormulaKind.PositiveSemidefinite">
<code class="descname">PositiveSemidefinite</code><em class="property"> = &lt;FormulaKind.PositiveSemidefinite: 14&gt;</em><a class="headerlink" href="#pydrake.symbolic.FormulaKind.PositiveSemidefinite" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.symbolic.FormulaKind.True">
<code class="descname">True</code><em class="property"> = &lt;FormulaKind.True: 1&gt;</em><a class="headerlink" href="#pydrake.symbolic.FormulaKind.True" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.symbolic.FormulaKind.value">
<code class="descname">value</code><a class="headerlink" href="#pydrake.symbolic.FormulaKind.value" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.symbolic.FormulaKind.Var">
<code class="descname">Var</code><em class="property"> = &lt;FormulaKind.Var: 2&gt;</em><a class="headerlink" href="#pydrake.symbolic.FormulaKind.Var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="pydrake.symbolic.GetVariableVector">
<code class="descclassname">pydrake.symbolic.</code><code class="descname">GetVariableVector</code><span class="sig-paren">(</span><em>expressions: numpy.ndarray[object[m, 1]]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, 1]]<a class="headerlink" href="#pydrake.symbolic.GetVariableVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs a vector of variables from the vector of variable
expressions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if there is an expression in <code class="docutils literal notranslate"><span class="pre">vec</span></code> which is not a</li>
<li><code class="xref py py-exc docutils literal notranslate"><span class="pre">variable.</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pydrake.symbolic.if_then_else">
<code class="descclassname">pydrake.symbolic.</code><code class="descname">if_then_else</code><span class="sig-paren">(</span><em>f_cond: drake::symbolic::Formula</em>, <em>e_then: pydrake.symbolic.Expression</em>, <em>e_else: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Expression<a class="headerlink" href="#pydrake.symbolic.if_then_else" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs if-then-else expression.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">if_then_else</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="n">expr_then</span><span class="p">,</span> <span class="n">expr_else</span><span class="p">)</span>
</pre></div>
</div>
<p>The value returned by the above if-then-else expression is
<code class="docutils literal notranslate"><span class="pre">expr_then</span></code> if <code class="docutils literal notranslate"><span class="pre">cond</span></code> is evaluated to true. Otherwise, it returns
<code class="docutils literal notranslate"><span class="pre">expr_else</span></code>.</p>
<p>The semantics is similar to the C++’s conditional expression
constructed by its ternary operator, &#64;c ?:. However, there is a key
difference between the C++’s conditional expression and our
<code class="docutils literal notranslate"><span class="pre">if_then_else</span></code> expression in a way the arguments are evaluated
during the construction.</p>
<ul class="simple">
<li>In case of the C++’s conditional expression, `` cond ? expr_then :</li>
</ul>
<p>expr_else``, the then expression <code class="docutils literal notranslate"><span class="pre">expr_then</span></code> (respectively, the else
expression <code class="docutils literal notranslate"><span class="pre">expr_else)</span></code> is <strong>only</strong> evaluated when the conditional
expression <code class="docutils literal notranslate"><span class="pre">cond</span></code> is evaluated to <strong>true</strong> (respectively, when <code class="docutils literal notranslate"><span class="pre">cond</span></code> is
evaluated to <strong>false)</strong>.</p>
<ul class="simple">
<li>In case of the symbolic expression, <a href="#id5"><span class="problematic" id="id6">``</span></a>if_then_else(cond, expr_then,</li>
</ul>
<p>expr_else)``, however, <strong>both</strong> arguments <code class="docutils literal notranslate"><span class="pre">expr_then</span></code> and <code class="docutils literal notranslate"><span class="pre">expr_else</span></code>
are evaluated first and then passed to the <code class="docutils literal notranslate"><span class="pre">if_then_else</span></code> function.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This function returns an <strong>expression</strong> and it is different from
the C++’s if-then-else <strong>statement</strong>.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">While it is still possible to define `` min, max, abs`` math
functions using <code class="docutils literal notranslate"><span class="pre">if_then_else</span></code> expression, it is highly
<strong>recommended</strong> to use the provided native definitions for them
because it allows solvers to detect specific math functions and to
have a room for special optimizations.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">More information about the C++’s conditional expression and
ternary operator is available at
<a class="reference external" href="http://en.cppreference.com/w/cpp/language/operator_other#Conditional_operator">http://en.cppreference.com/w/cpp/language/operator_other#Conditional_operator</a>.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="pydrake.symbolic.intersect">
<code class="descclassname">pydrake.symbolic.</code><code class="descname">intersect</code><span class="sig-paren">(</span><em>vars1: pydrake.symbolic.Variables</em>, <em>vars2: pydrake.symbolic.Variables</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Variables<a class="headerlink" href="#pydrake.symbolic.intersect" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the intersection of <code class="docutils literal notranslate"><span class="pre">vars1</span></code> and <code class="docutils literal notranslate"><span class="pre">vars2</span></code>.</p>
<p>This function has a time complexity of <code class="docutils literal notranslate"><span class="pre">O(N₁</span> <span class="pre">+</span> <span class="pre">N₂)</span></code> where <code class="docutils literal notranslate"><span class="pre">N₁</span></code> and
<code class="docutils literal notranslate"><span class="pre">N₂</span></code> are the size of <code class="docutils literal notranslate"><span class="pre">vars1</span></code> and <code class="docutils literal notranslate"><span class="pre">vars2</span></code> respectively.</p>
</dd></dl>

<dl class="function">
<dt id="pydrake.symbolic.inv">
<code class="descclassname">pydrake.symbolic.</code><code class="descname">inv</code><span class="sig-paren">(</span><em>arg0: numpy.ndarray[object[m, n]]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, n]]<a class="headerlink" href="#pydrake.symbolic.inv" title="Permalink to this definition">¶</a></dt>
<dd><p>Symbolic matrix inverse</p>
</dd></dl>

<dl class="function">
<dt id="pydrake.symbolic.IsAffine">
<code class="descclassname">pydrake.symbolic.</code><code class="descname">IsAffine</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.symbolic.IsAffine" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>IsAffine(m: numpy.ndarray[object[m, n], flags.f_contiguous], vars: pydrake.symbolic.Variables) -&gt; bool</li>
</ol>
<p>Checks if every element in <code class="docutils literal notranslate"><span class="pre">m</span></code> is affine in <code class="docutils literal notranslate"><span class="pre">vars</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If <code class="docutils literal notranslate"><span class="pre">m</span></code> is an empty matrix, it returns true.</p>
</div>
<ol class="arabic simple" start="2">
<li>IsAffine(m: numpy.ndarray[object[m, n], flags.f_contiguous]) -&gt; bool</li>
</ol>
<p>Checks if every element in <code class="docutils literal notranslate"><span class="pre">m</span></code> is affine.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If <code class="docutils literal notranslate"><span class="pre">m</span></code> is an empty matrix, it returns true.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="pydrake.symbolic.isnan">
<code class="descclassname">pydrake.symbolic.</code><code class="descname">isnan</code><span class="sig-paren">(</span><em>e: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Formula<a class="headerlink" href="#pydrake.symbolic.isnan" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a Formula for the predicate isnan(e) to the given expression.
This serves as the argument-dependent lookup related to
std::isnan(double).</p>
<p>When this formula is evaluated, there are two possible outcomes: -
Returns false if the e.Evaluate() is not NaN. - Throws RuntimeError if
NaN is detected during evaluation. Note that the evaluation of
<code class="docutils literal notranslate"><span class="pre">isnan(e)</span></code> never returns true.</p>
</dd></dl>

<dl class="function">
<dt id="pydrake.symbolic.Jacobian">
<code class="descclassname">pydrake.symbolic.</code><code class="descname">Jacobian</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.symbolic.Jacobian" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>Jacobian(f: numpy.ndarray[object[m, 1]], vars: numpy.ndarray[object[m, 1]]) -&gt; numpy.ndarray[object[m, n]]</li>
</ol>
<p>Computes the Jacobian matrix J of the vector function <code class="docutils literal notranslate"><span class="pre">f</span></code> with
respect to <code class="docutils literal notranslate"><span class="pre">vars</span></code>. J(i,j) contains ∂f(i)/∂vars(j).</p>
<p>For example, Jacobian([x * cos(y), x * sin(y), x^2], {x, y}) returns
the following 3x2 matrix:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">=</span> <span class="o">|</span><span class="n">cos</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>   <span class="o">-</span><span class="n">x</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">|</span>
   <span class="o">|</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>    <span class="n">x</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">|</span>
   <span class="o">|</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x</span>             <span class="mi">0</span><span class="o">|</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Precondition:</dt>
<dd>{<code class="docutils literal notranslate"><span class="pre">vars</span></code> is non-empty}.</dd>
</dl>
<ol class="arabic simple" start="2">
<li>Jacobian(f: numpy.ndarray[object[m, 1]], vars: numpy.ndarray[object[m, 1]]) -&gt; numpy.ndarray[object[m, n]]</li>
</ol>
<p>Computes the Jacobian matrix J of the vector function <code class="docutils literal notranslate"><span class="pre">f</span></code> with
respect to <code class="docutils literal notranslate"><span class="pre">vars</span></code>. J(i,j) contains ∂f(i)/∂vars(j).</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd>{<code class="docutils literal notranslate"><span class="pre">vars</span></code> is non-empty}.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pydrake.symbolic.log">
<code class="descclassname">pydrake.symbolic.</code><code class="descname">log</code><span class="sig-paren">(</span><em>arg0: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Expression<a class="headerlink" href="#pydrake.symbolic.log" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pydrake.symbolic.logical_and">
<code class="descclassname">pydrake.symbolic.</code><code class="descname">logical_and</code><span class="sig-paren">(</span><em>*formulas</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.symbolic.logical_and" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pydrake.symbolic.logical_not">
<code class="descclassname">pydrake.symbolic.</code><code class="descname">logical_not</code><span class="sig-paren">(</span><em>arg0: pydrake.symbolic.Formula</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Formula<a class="headerlink" href="#pydrake.symbolic.logical_not" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pydrake.symbolic.logical_or">
<code class="descclassname">pydrake.symbolic.</code><code class="descname">logical_or</code><span class="sig-paren">(</span><em>*formulas</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.symbolic.logical_or" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pydrake.symbolic.MakeMatrixBinaryVariable">
<code class="descclassname">pydrake.symbolic.</code><code class="descname">MakeMatrixBinaryVariable</code><span class="sig-paren">(</span><em>rows: int</em>, <em>cols: int</em>, <em>name: str</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, n]]<a class="headerlink" href="#pydrake.symbolic.MakeMatrixBinaryVariable" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a dynamically-sized Eigen matrix of symbolic binary variables.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">rows</span></code>:</dt>
<dd>The number of rows in the new matrix.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">cols</span></code>:</dt>
<dd>The number of cols in the new matrix.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">name</span></code>:</dt>
<dd>The common prefix for variables. The (i, j)-th element will be
named as <code class="docutils literal notranslate"><span class="pre">name(i,</span> <span class="pre">j)</span></code>.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pydrake.symbolic.MakeMatrixBooleanVariable">
<code class="descclassname">pydrake.symbolic.</code><code class="descname">MakeMatrixBooleanVariable</code><span class="sig-paren">(</span><em>rows: int</em>, <em>cols: int</em>, <em>name: str</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, n]]<a class="headerlink" href="#pydrake.symbolic.MakeMatrixBooleanVariable" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a dynamically-sized Eigen matrix of symbolic Boolean
variables.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">rows</span></code>:</dt>
<dd>The number of rows in the new matrix.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">cols</span></code>:</dt>
<dd>The number of cols in the new matrix.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">name</span></code>:</dt>
<dd>The common prefix for variables. The (i, j)-th element will be
named as <code class="docutils literal notranslate"><span class="pre">name(i,</span> <span class="pre">j)</span></code>.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pydrake.symbolic.MakeMatrixContinuousVariable">
<code class="descclassname">pydrake.symbolic.</code><code class="descname">MakeMatrixContinuousVariable</code><span class="sig-paren">(</span><em>rows: int</em>, <em>cols: int</em>, <em>name: str</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, n]]<a class="headerlink" href="#pydrake.symbolic.MakeMatrixContinuousVariable" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a dynamically-sized Eigen matrix of symbolic continuous
variables.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">rows</span></code>:</dt>
<dd>The number of rows in the new matrix.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">cols</span></code>:</dt>
<dd>The number of cols in the new matrix.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">name</span></code>:</dt>
<dd>The common prefix for variables. The (i, j)-th element will be
named as <code class="docutils literal notranslate"><span class="pre">name(i,</span> <span class="pre">j)</span></code>.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pydrake.symbolic.MakeMatrixVariable">
<code class="descclassname">pydrake.symbolic.</code><code class="descname">MakeMatrixVariable</code><span class="sig-paren">(</span><em>rows: int</em>, <em>cols: int</em>, <em>name: str</em>, <em>type: pydrake.symbolic.Variable.Type = &lt;Type.CONTINUOUS: 0&gt;</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, n]]<a class="headerlink" href="#pydrake.symbolic.MakeMatrixVariable" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a dynamically-sized Eigen matrix of symbolic variables.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">rows</span></code>:</dt>
<dd>The number of rows in the new matrix.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">cols</span></code>:</dt>
<dd>The number of cols in the new matrix.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">name</span></code>:</dt>
<dd>The common prefix for variables. The (i, j)-th element will be
named as <code class="docutils literal notranslate"><span class="pre">name(i,</span> <span class="pre">j)</span></code>.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">type</span></code>:</dt>
<dd>The type of variables in the matrix.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pydrake.symbolic.MakeVectorBinaryVariable">
<code class="descclassname">pydrake.symbolic.</code><code class="descname">MakeVectorBinaryVariable</code><span class="sig-paren">(</span><em>rows: int</em>, <em>name: str</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, 1]]<a class="headerlink" href="#pydrake.symbolic.MakeVectorBinaryVariable" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a dynamically-sized Eigen vector of symbolic binary variables.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">rows</span></code>:</dt>
<dd>The size of vector.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">name</span></code>:</dt>
<dd>The common prefix for variables. The i-th element will be named as
<code class="docutils literal notranslate"><span class="pre">name(i)</span></code>.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pydrake.symbolic.MakeVectorBooleanVariable">
<code class="descclassname">pydrake.symbolic.</code><code class="descname">MakeVectorBooleanVariable</code><span class="sig-paren">(</span><em>rows: int</em>, <em>name: str</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, 1]]<a class="headerlink" href="#pydrake.symbolic.MakeVectorBooleanVariable" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a dynamically-sized Eigen vector of symbolic Boolean
variables.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">rows</span></code>:</dt>
<dd>The size of vector.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">name</span></code>:</dt>
<dd>The common prefix for variables. The i-th element will be named as
<code class="docutils literal notranslate"><span class="pre">name(i)</span></code>.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pydrake.symbolic.MakeVectorContinuousVariable">
<code class="descclassname">pydrake.symbolic.</code><code class="descname">MakeVectorContinuousVariable</code><span class="sig-paren">(</span><em>rows: int</em>, <em>name: str</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, 1]]<a class="headerlink" href="#pydrake.symbolic.MakeVectorContinuousVariable" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a dynamically-sized Eigen vector of symbolic continuous
variables.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">rows</span></code>:</dt>
<dd>The size of vector.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">name</span></code>:</dt>
<dd>The common prefix for variables. The i-th element will be named as
<code class="docutils literal notranslate"><span class="pre">name(i)</span></code>.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pydrake.symbolic.MakeVectorVariable">
<code class="descclassname">pydrake.symbolic.</code><code class="descname">MakeVectorVariable</code><span class="sig-paren">(</span><em>rows: int</em>, <em>name: str</em>, <em>type: pydrake.symbolic.Variable.Type = &lt;Type.CONTINUOUS: 0&gt;</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, 1]]<a class="headerlink" href="#pydrake.symbolic.MakeVectorVariable" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a dynamically-sized Eigen vector of symbolic variables.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">rows</span></code>:</dt>
<dd>The size of vector.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">name</span></code>:</dt>
<dd>The common prefix for variables. The i-th element will be named as
<code class="docutils literal notranslate"><span class="pre">name(i)</span></code>.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">type</span></code>:</dt>
<dd>The type of variables in the vector.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pydrake.symbolic.max">
<code class="descclassname">pydrake.symbolic.</code><code class="descname">max</code><span class="sig-paren">(</span><em>arg0: pydrake.symbolic.Expression</em>, <em>arg1: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Expression<a class="headerlink" href="#pydrake.symbolic.max" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pydrake.symbolic.min">
<code class="descclassname">pydrake.symbolic.</code><code class="descname">min</code><span class="sig-paren">(</span><em>arg0: pydrake.symbolic.Expression</em>, <em>arg1: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Expression<a class="headerlink" href="#pydrake.symbolic.min" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="pydrake.symbolic.Monomial">
<em class="property">class </em><code class="descclassname">pydrake.symbolic.</code><code class="descname">Monomial</code><a class="headerlink" href="#pydrake.symbolic.Monomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Represents a monomial, a product of powers of variables with
non-negative integer exponents. Note that it does not include the
coefficient part of a monomial.</p>
<dl class="method">
<dt id="pydrake.symbolic.Monomial.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.symbolic.Monomial.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.symbolic.Monomial) -&gt; None</li>
</ol>
<p>Constructs a monomial equal to 1. Namely the total degree is zero.</p>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.symbolic.Monomial, var: pydrake.symbolic.Variable) -&gt; None</li>
</ol>
<p>Constructs a Monomial from <code class="docutils literal notranslate"><span class="pre">var</span></code>.</p>
<ol class="arabic simple" start="3">
<li>__init__(self: pydrake.symbolic.Monomial, var: pydrake.symbolic.Variable, exponent: int) -&gt; None</li>
</ol>
<p>Constructs a Monomial from <code class="docutils literal notranslate"><span class="pre">var</span></code> and <code class="docutils literal notranslate"><span class="pre">exponent</span></code>.</p>
<ol class="arabic simple" start="4">
<li>__init__(self: pydrake.symbolic.Monomial, powers: Dict[pydrake.symbolic.Variable, int]) -&gt; None</li>
</ol>
<p>Constructs a Monomial from <code class="docutils literal notranslate"><span class="pre">powers</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal notranslate"><span class="pre">powers</span></code> includes a negative exponent.</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="5">
<li>__init__(self: pydrake.symbolic.Monomial, vars: numpy.ndarray[object[m, 1]], exponents: numpy.ndarray[numpy.int32[m, 1]]) -&gt; None</li>
</ol>
<p>Constructs a Monomial from a vector of variables <code class="docutils literal notranslate"><span class="pre">vars</span></code> and their
corresponding integer exponents <code class="docutils literal notranslate"><span class="pre">exponents</span></code>. For example,
<code class="docutils literal notranslate"><span class="pre">Monomial([x,</span> <span class="pre">y,</span> <span class="pre">z],</span> <span class="pre">[2,</span> <span class="pre">0,</span> <span class="pre">1])</span></code> constructs a Monomial <code class="docutils literal notranslate"><span class="pre">x²z</span></code>.</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd>The size of <code class="docutils literal notranslate"><span class="pre">vars</span></code> should be the same as the size of
<code class="docutils literal notranslate"><span class="pre">exponents</span></code>.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal notranslate"><span class="pre">exponents</span></code> includes a negative integer.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Monomial.degree">
<code class="descname">degree</code><span class="sig-paren">(</span><em>self: pydrake.symbolic.Monomial</em>, <em>v: pydrake.symbolic.Variable</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.symbolic.Monomial.degree" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the degree of this Monomial in a variable <code class="docutils literal notranslate"><span class="pre">v</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Monomial.EqualTo">
<code class="descname">EqualTo</code><span class="sig-paren">(</span><em>self: pydrake.symbolic.Monomial</em>, <em>arg0: pydrake.symbolic.Monomial</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.symbolic.Monomial.EqualTo" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Monomial.Evaluate">
<code class="descname">Evaluate</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.symbolic.Monomial.Evaluate" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>Evaluate(self: pydrake.symbolic.Monomial, env: Dict[pydrake.symbolic.Variable, float]) -&gt; float</li>
</ol>
<p>Evaluates under a given environment <code class="docutils literal notranslate"><span class="pre">env</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if there is a variable in this monomial whose</li>
<li>assignment is not provided by <code class="docutils literal notranslate"><span class="pre">env</span></code>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>Evaluate(self: pydrake.symbolic.Monomial, vars: numpy.ndarray[object[m, 1]], vars_values: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous]) -&gt; numpy.ndarray[numpy.float64[m, 1]]</li>
</ol>
<p>Evaluates the monomial for a batch of data. We return monomial_vals
such that monomial_vals(j) is obtained by substituting <code class="docutils literal notranslate"><span class="pre">vars(i)</span></code>
with <code class="docutils literal notranslate"><span class="pre">vars_values(i,</span> <span class="pre">j)</span></code>, note that vars_values.rows() ==
vars.rows() and vars_values.cols() == monomial_vals.rows().</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">vars</span></code>:</dt>
<dd>The variables whose value will be substituted. <code class="docutils literal notranslate"><span class="pre">vars</span></code> must
contain all variables in this-&gt;GetVariables(). Also <code class="docutils literal notranslate"><span class="pre">vars</span></code>
cannot contain any duplicate variables, namely vars(i) != vars(j)
if i != j.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">vars_values</span></code>:</dt>
<dd>The i’th column of <code class="docutils literal notranslate"><span class="pre">vars_values</span></code> is the i’th data for <code class="docutils literal notranslate"><span class="pre">vars</span></code>.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>an exception if <code class="docutils literal notranslate"><span class="pre">vars</span></code> doesn’t contain all the variables in</li>
<li><code class="xref py py-exc docutils literal notranslate"><span class="pre">this-&gt;GetVariables.</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Monomial.EvaluatePartial">
<code class="descname">EvaluatePartial</code><span class="sig-paren">(</span><em>self: pydrake.symbolic.Monomial, env: Dict[pydrake.symbolic.Variable, float]</em><span class="sig-paren">)</span> &#x2192; Tuple[float, pydrake.symbolic.Monomial]<a class="headerlink" href="#pydrake.symbolic.Monomial.EvaluatePartial" title="Permalink to this definition">¶</a></dt>
<dd><p>Partially evaluates using a given environment <code class="docutils literal notranslate"><span class="pre">env</span></code>. The evaluation
result is of type pair&lt;double, Monomial&gt;. The first component (:
double) represents the coefficient part while the second component
represents the remaining parts of the Monomial which was not
evaluated.</p>
<p>Example 1. Evaluate with a fully-specified environment
(x³*y²).EvaluatePartial({{x, 2}, {y, 3}}) = (2³ * 3² = 8 * 9 = 72,
Monomial{} = 1).</p>
<p>Example 2. Evaluate with a partial environment
(x³*y²).EvaluatePartial({{x, 2}}) = (2³ = 8, y²).</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Monomial.get_powers">
<code class="descname">get_powers</code><span class="sig-paren">(</span><em>self: pydrake.symbolic.Monomial</em><span class="sig-paren">)</span> &#x2192; Dict[pydrake.symbolic.Variable, int]<a class="headerlink" href="#pydrake.symbolic.Monomial.get_powers" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the internal representation of Monomial, the map from a base
(Variable) to its exponent (int).</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Monomial.GetVariables">
<code class="descname">GetVariables</code><span class="sig-paren">(</span><em>self: pydrake.symbolic.Monomial</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Variables<a class="headerlink" href="#pydrake.symbolic.Monomial.GetVariables" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the set of variables in this monomial.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Monomial.pow_in_place">
<code class="descname">pow_in_place</code><span class="sig-paren">(</span><em>self: pydrake.symbolic.Monomial</em>, <em>p: int</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Monomial<a class="headerlink" href="#pydrake.symbolic.Monomial.pow_in_place" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns this monomial raised to <code class="docutils literal notranslate"><span class="pre">p</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal notranslate"><span class="pre">p</span></code> is negative.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Monomial.ToExpression">
<code class="descname">ToExpression</code><span class="sig-paren">(</span><em>self: pydrake.symbolic.Monomial</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Expression<a class="headerlink" href="#pydrake.symbolic.Monomial.ToExpression" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a symbolic expression representing this monomial.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Monomial.total_degree">
<code class="descname">total_degree</code><span class="sig-paren">(</span><em>self: pydrake.symbolic.Monomial</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.symbolic.Monomial.total_degree" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the total degree of this Monomial.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pydrake.symbolic.MonomialBasis">
<code class="descclassname">pydrake.symbolic.</code><code class="descname">MonomialBasis</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.symbolic.MonomialBasis" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>MonomialBasis(vars: numpy.ndarray[object[m, 1]], degree: int) -&gt; numpy.ndarray[object[m, 1]]</li>
</ol>
<p>Returns all monomials up to a given degree under the graded reverse
lexicographic order. Note that graded reverse lexicographic order uses
the total order among Variable which is based on a variable’s unique
ID. For example, for a given variable ordering x &gt; y &gt; z,
<code class="docutils literal notranslate"><span class="pre">MonomialBasis({x,</span> <span class="pre">y,</span> <span class="pre">z},</span> <span class="pre">2)</span></code> returns a column vector <code class="docutils literal notranslate"><span class="pre">[x^2,</span> <span class="pre">xy,</span>
<span class="pre">y^2,</span> <span class="pre">xz,</span> <span class="pre">yz,</span> <span class="pre">z^2,</span> <span class="pre">x,</span> <span class="pre">y,</span> <span class="pre">z,</span> <span class="pre">1]</span></code>.</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd><code class="docutils literal notranslate"><span class="pre">vars</span></code> is a non-empty set.</dd>
<dt>Precondition:</dt>
<dd><code class="docutils literal notranslate"><span class="pre">degree</span></code> is a non-negative integer.</dd>
</dl>
<ol class="arabic simple" start="2">
<li>MonomialBasis(vars: pydrake.symbolic.Variables, degree: int) -&gt; numpy.ndarray[object[m, 1]]</li>
</ol>
<p>Returns all monomials up to a given degree under the graded reverse
lexicographic order. Note that graded reverse lexicographic order uses
the total order among Variable which is based on a variable’s unique
ID. For example, for a given variable ordering x &gt; y &gt; z,
<code class="docutils literal notranslate"><span class="pre">MonomialBasis({x,</span> <span class="pre">y,</span> <span class="pre">z},</span> <span class="pre">2)</span></code> returns a column vector <code class="docutils literal notranslate"><span class="pre">[x^2,</span> <span class="pre">xy,</span>
<span class="pre">y^2,</span> <span class="pre">xz,</span> <span class="pre">yz,</span> <span class="pre">z^2,</span> <span class="pre">x,</span> <span class="pre">y,</span> <span class="pre">z,</span> <span class="pre">1]</span></code>.</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd><code class="docutils literal notranslate"><span class="pre">vars</span></code> is a non-empty set.</dd>
<dt>Precondition:</dt>
<dd><code class="docutils literal notranslate"><span class="pre">degree</span></code> is a non-negative integer.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pydrake.symbolic.OddDegreeMonomialBasis">
<code class="descclassname">pydrake.symbolic.</code><code class="descname">OddDegreeMonomialBasis</code><span class="sig-paren">(</span><em>vars: pydrake.symbolic.Variables</em>, <em>degree: int</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, 1]]<a class="headerlink" href="#pydrake.symbolic.OddDegreeMonomialBasis" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns all odd degree monomials up to a given degree under the graded
reverse lexicographic order. A monomial has an odd degree if its total
degree is odd. So x²y is an odd degree monomial (degree 3) while xy is
not (degree 2). Note that graded reverse lexicographic order uses the
total order among Variable which is based on a variable’s unique ID.
For example, for a given variable ordering x &gt; y &gt; z,
<code class="docutils literal notranslate"><span class="pre">OddDegreeMonomialBasis({x,</span> <span class="pre">y,</span> <span class="pre">z},</span> <span class="pre">3)</span></code> returns a column vector
<code class="docutils literal notranslate"><span class="pre">[x³,</span> <span class="pre">x²y,</span> <span class="pre">xy²,</span> <span class="pre">y³,</span> <span class="pre">x²z,</span> <span class="pre">xyz,</span> <span class="pre">y²z,</span> <span class="pre">xz²,</span> <span class="pre">yz²,</span> <span class="pre">z³,</span> <span class="pre">x,</span> <span class="pre">y,</span> <span class="pre">z]</span></code></p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd><code class="docutils literal notranslate"><span class="pre">vars</span></code> is a non-empty set.</dd>
<dt>Precondition:</dt>
<dd><code class="docutils literal notranslate"><span class="pre">degree</span></code> is a non-negative integer.</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="pydrake.symbolic.Polynomial">
<em class="property">class </em><code class="descclassname">pydrake.symbolic.</code><code class="descname">Polynomial</code><a class="headerlink" href="#pydrake.symbolic.Polynomial" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="pydrake.symbolic.Polynomial.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.symbolic.Polynomial.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.symbolic.Polynomial) -&gt; None</li>
</ol>
<p>Constructs a zero polynomial.</p>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.symbolic.Polynomial, map: Dict[pydrake.symbolic.Monomial, pydrake.symbolic.Expression]) -&gt; None</li>
</ol>
<p>Constructs a polynomial from a map, Monomial → Expression.</p>
<ol class="arabic simple" start="3">
<li>__init__(self: pydrake.symbolic.Polynomial, m: pydrake.symbolic.Monomial) -&gt; None</li>
</ol>
<p>Constructs a polynomial from a monomial <code class="docutils literal notranslate"><span class="pre">m</span></code>. Note that all variables
in <code class="docutils literal notranslate"><span class="pre">m</span></code> are considered as indeterminates.</p>
<ol class="arabic simple" start="4">
<li>__init__(self: pydrake.symbolic.Polynomial, e: pydrake.symbolic.Expression) -&gt; None</li>
</ol>
<p>Constructs a polynomial from an expression <code class="docutils literal notranslate"><span class="pre">e</span></code>. Note that all
variables in <code class="docutils literal notranslate"><span class="pre">e</span></code> are considered as indeterminates.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal notranslate"><span class="pre">e</span></code> is not a polynomial.</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="5">
<li>__init__(self: pydrake.symbolic.Polynomial, e: pydrake.symbolic.Expression, indeterminates: pydrake.symbolic.Variables) -&gt; None</li>
</ol>
<p>Constructs a polynomial from an expression <code class="docutils literal notranslate"><span class="pre">e</span></code> by decomposing it
with respect to <code class="docutils literal notranslate"><span class="pre">indeterminates</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">It collects the intersection of the variables appeared in <code class="docutils literal notranslate"><span class="pre">e</span></code>
and the provided <code class="docutils literal notranslate"><span class="pre">indeterminates</span></code>.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal notranslate"><span class="pre">e</span></code> is not a polynomial in <code class="docutils literal notranslate"><span class="pre">indeterminates</span></code>.</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="6">
<li>__init__(self: pydrake.symbolic.Polynomial, e: pydrake.symbolic.Expression, indeterminates: numpy.ndarray[object[m, 1]]) -&gt; None</li>
</ol>
<p>Constructs a polynomial from an expression <code class="docutils literal notranslate"><span class="pre">e</span></code> by decomposing it
with respect to <code class="docutils literal notranslate"><span class="pre">indeterminates</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">It collects the intersection of the variables appeared in <code class="docutils literal notranslate"><span class="pre">e</span></code>
and the provided <code class="docutils literal notranslate"><span class="pre">indeterminates</span></code>.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal notranslate"><span class="pre">e</span></code> is not a polynomial in <code class="docutils literal notranslate"><span class="pre">indeterminates</span></code>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Polynomial.AddProduct">
<code class="descname">AddProduct</code><span class="sig-paren">(</span><em>self: pydrake.symbolic.Polynomial</em>, <em>coeff: pydrake.symbolic.Expression</em>, <em>m: pydrake.symbolic.Monomial</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Polynomial<a class="headerlink" href="#pydrake.symbolic.Polynomial.AddProduct" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds <code class="docutils literal notranslate"><span class="pre">coeff</span></code> * <code class="docutils literal notranslate"><span class="pre">m</span></code> to this polynomial.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Polynomial.CoefficientsAlmostEqual">
<code class="descname">CoefficientsAlmostEqual</code><span class="sig-paren">(</span><em>self: pydrake.symbolic.Polynomial</em>, <em>p: pydrake.symbolic.Polynomial</em>, <em>tolerance: float</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.symbolic.Polynomial.CoefficientsAlmostEqual" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true if this polynomial and <code class="docutils literal notranslate"><span class="pre">p</span></code> are almost equal (the
difference in the corresponding coefficients are all less than
<code class="docutils literal notranslate"><span class="pre">tolerance)</span></code>, after expanding the coefficients.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Polynomial.decision_variables">
<code class="descname">decision_variables</code><span class="sig-paren">(</span><em>self: pydrake.symbolic.Polynomial</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Variables<a class="headerlink" href="#pydrake.symbolic.Polynomial.decision_variables" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the decision variables of this polynomial.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Polynomial.Degree">
<code class="descname">Degree</code><span class="sig-paren">(</span><em>self: pydrake.symbolic.Polynomial</em>, <em>v: pydrake.symbolic.Variable</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.symbolic.Polynomial.Degree" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the highest degree of this polynomial in a variable <code class="docutils literal notranslate"><span class="pre">v</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Polynomial.Differentiate">
<code class="descname">Differentiate</code><span class="sig-paren">(</span><em>self: pydrake.symbolic.Polynomial</em>, <em>x: pydrake.symbolic.Variable</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Polynomial<a class="headerlink" href="#pydrake.symbolic.Polynomial.Differentiate" title="Permalink to this definition">¶</a></dt>
<dd><p>Differentiates this polynomial with respect to the variable <code class="docutils literal notranslate"><span class="pre">x</span></code>.
Note that a variable <code class="docutils literal notranslate"><span class="pre">x</span></code> can be either a decision variable or an
indeterminate.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Polynomial.EqualTo">
<code class="descname">EqualTo</code><span class="sig-paren">(</span><em>self: pydrake.symbolic.Polynomial</em>, <em>arg0: pydrake.symbolic.Polynomial</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.symbolic.Polynomial.EqualTo" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true if this polynomial and <code class="docutils literal notranslate"><span class="pre">p</span></code> are structurally equal.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Polynomial.EqualToAfterExpansion">
<code class="descname">EqualToAfterExpansion</code><span class="sig-paren">(</span><em>self: pydrake.symbolic.Polynomial</em>, <em>arg0: pydrake.symbolic.Polynomial</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.symbolic.Polynomial.EqualToAfterExpansion" title="Permalink to this definition">¶</a></dt>
<dd><p>(Deprecated.)</p>
<dl class="docutils">
<dt>Deprecated:</dt>
<dd>Use this-&gt;Expand().EqualTo(p.Expand()) instead of
EqualToAfterExpansion() This will be removed from Drake on or
after 2022-09-01.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Polynomial.Evaluate">
<code class="descname">Evaluate</code><span class="sig-paren">(</span><em>self: pydrake.symbolic.Polynomial, env: Dict[pydrake.symbolic.Variable, float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.symbolic.Polynomial.Evaluate" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluates this polynomial under a given environment <code class="docutils literal notranslate"><span class="pre">env</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if there is a variable in this polynomial whose</li>
<li>assignment is not provided by <code class="docutils literal notranslate"><span class="pre">env</span></code>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Polynomial.EvaluateIndeterminates">
<code class="descname">EvaluateIndeterminates</code><span class="sig-paren">(</span><em>self: pydrake.symbolic.Polynomial, indeterminates: numpy.ndarray[object[m, 1]], indeterminates_values: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.symbolic.Polynomial.EvaluateIndeterminates" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluates the polynomial at a batch of indeterminates values.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">indeterminates</span></code>:</dt>
<dd>Must include all this-&gt;indeterminates()</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">indeterminates_values</span></code>:</dt>
<dd>Each column of <code class="docutils literal notranslate"><span class="pre">indeterminates_values</span></code> stores one specific value
of <code class="docutils literal notranslate"><span class="pre">indeterminates</span></code>. indeterminates_values.rows() ==
indeterminates.rows().</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">polynomial_values polynomial_values(j) is obtained by substituting
indeterminates(i) in this polynomial with indeterminates_values(i,
j) for all i.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if any coefficient in this polynomial is not a</li>
<li><code class="xref py py-exc docutils literal notranslate"><span class="pre">constant.</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Polynomial.EvaluatePartial">
<code class="descname">EvaluatePartial</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.symbolic.Polynomial.EvaluatePartial" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>EvaluatePartial(self: pydrake.symbolic.Polynomial, env: Dict[pydrake.symbolic.Variable, float]) -&gt; pydrake.symbolic.Polynomial</li>
</ol>
<p>Partially evaluates this polynomial using an environment <code class="docutils literal notranslate"><span class="pre">env</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if NaN is detected during evaluation.</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>EvaluatePartial(self: pydrake.symbolic.Polynomial, var: pydrake.symbolic.Variable, c: float) -&gt; pydrake.symbolic.Polynomial</li>
</ol>
<p>Partially evaluates this polynomial by substituting <code class="docutils literal notranslate"><span class="pre">var</span></code> with
<code class="docutils literal notranslate"><span class="pre">c</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if NaN is detected at any point during evaluation.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Polynomial.EvaluateWithAffineCoefficients">
<code class="descname">EvaluateWithAffineCoefficients</code><span class="sig-paren">(</span><em>self: pydrake.symbolic.Polynomial, indeterminates: numpy.ndarray[object[m, 1]], indeterminates_values: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous]</em><span class="sig-paren">)</span> &#x2192; Tuple[numpy.ndarray[numpy.float64[m, n]], numpy.ndarray[object[m, 1]], numpy.ndarray[numpy.float64[m, 1]]]<a class="headerlink" href="#pydrake.symbolic.Polynomial.EvaluateWithAffineCoefficients" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluates the polynomial at a batch of indeterminate values. For a
polynomial whose coefficients are affine expressions of decision
variables, we evaluate this polynomial on a batch of indeterminate
values, and return the matrix representation of the evaluated affine
expressions. For example if p(x) = (a+1)x² + b*x where a, b are
decision variables, if we evaluate this polynomial on x = 1 and x = 2,
then p(x) = a+b+1 and 4a+2b+4 respectively. We return the evaluation
result as A * decision_variables + b, where A.row(i) *
decision_variables + b(i) is the evaluation of the polynomial on
indeterminates_values.col(i).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">indeterminates</span></code>:</dt>
<dd>Must include all this-&gt;indeterminates()</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">indeterminates_values</span></code>:</dt>
<dd>A matrix representing a batch of values. Each column of
<code class="docutils literal notranslate"><span class="pre">indeterminates_values</span></code> stores one specific value of
<code class="docutils literal notranslate"><span class="pre">indeterminates</span></code>, where indeterminates_values.rows() ==
indeterminates.rows().</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">A</span></code>:</dt>
<dd>The coefficient of the evaluation results.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">decision_variables</span></code>:</dt>
<dd>The decision variables in the evaluation results.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">b</span></code>:</dt>
<dd>The constant terms in the evaluation results.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the coefficients of this polynomial is not an</li>
<li>affine expression of its decision variables. For example, the</li>
<li>polynomial (2+sin(a)) * x² + 1 (where <code class="docutils literal notranslate"><span class="pre">a</span></code> is a decision variable</li>
<li>and <code class="docutils literal notranslate"><span class="pre">x</span></code> is a indeterminate) doesn’t have affine expression as</li>
<li>its coefficient 2+sin(a).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Polynomial.Expand">
<code class="descname">Expand</code><span class="sig-paren">(</span><em>self: pydrake.symbolic.Polynomial</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Polynomial<a class="headerlink" href="#pydrake.symbolic.Polynomial.Expand" title="Permalink to this definition">¶</a></dt>
<dd><p>Expands each coefficient expression and returns the expanded
polynomial. If any coefficient is equal to 0 after expansion, then
remove that term from the returned polynomial.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Polynomial.indeterminates">
<code class="descname">indeterminates</code><span class="sig-paren">(</span><em>self: pydrake.symbolic.Polynomial</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Variables<a class="headerlink" href="#pydrake.symbolic.Polynomial.indeterminates" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the indeterminates of this polynomial.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Polynomial.Integrate">
<code class="descname">Integrate</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.symbolic.Polynomial.Integrate" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>Integrate(self: pydrake.symbolic.Polynomial, x: pydrake.symbolic.Variable) -&gt; pydrake.symbolic.Polynomial</li>
</ol>
<p>Integrates this polynomial with respect to an indeterminate <code class="docutils literal notranslate"><span class="pre">x</span></code>.
Integration with respect to decision variables is not supported yet.
If <code class="docutils literal notranslate"><span class="pre">x</span></code> is not an indeterminate nor decision variable, then it will
be added to the list of indeterminates.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal notranslate"><span class="pre">x</span></code> is a decision variable.</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>Integrate(self: pydrake.symbolic.Polynomial, x: pydrake.symbolic.Variable, a: float, b: float) -&gt; pydrake.symbolic.Polynomial</li>
</ol>
<p>Computes the definite integrate of this polynomial with respect to the
indeterminate <code class="docutils literal notranslate"><span class="pre">x</span></code> over the domain [a, b]. Integration with respect
to decision variables is not supported yet.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal notranslate"><span class="pre">x</span></code> is a decision variable.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Polynomial.IsEven">
<code class="descname">IsEven</code><span class="sig-paren">(</span><em>self: pydrake.symbolic.Polynomial</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.symbolic.Polynomial.IsEven" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true if the polynomial is even, namely p(x) = p(-x). Meaning
that the coefficient for all odd-degree monomials are 0. Returns false
otherwise. Note that this is different from the p.TotalDegree() being
an even number.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Polynomial.IsOdd">
<code class="descname">IsOdd</code><span class="sig-paren">(</span><em>self: pydrake.symbolic.Polynomial</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.symbolic.Polynomial.IsOdd" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true if the polynomial is odd, namely p(x) = -p(-x). Meaning
that the coefficient for all even-degree monomials are 0. Returns
false otherwise. Note that this is different from the p.TotalDegree()
being an odd number.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Polynomial.Jacobian">
<code class="descname">Jacobian</code><span class="sig-paren">(</span><em>self: pydrake.symbolic.Polynomial, vars: numpy.ndarray[object[m, 1]]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[1, n]]<a class="headerlink" href="#pydrake.symbolic.Polynomial.Jacobian" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the Jacobian matrix J of the polynomial with respect to
<code class="docutils literal notranslate"><span class="pre">vars</span></code>. J(0,i) contains ∂f/∂vars(i).</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Polynomial.monomial_to_coefficient_map">
<code class="descname">monomial_to_coefficient_map</code><span class="sig-paren">(</span><em>self: pydrake.symbolic.Polynomial</em><span class="sig-paren">)</span> &#x2192; Dict[pydrake.symbolic.Monomial, pydrake.symbolic.Expression]<a class="headerlink" href="#pydrake.symbolic.Polynomial.monomial_to_coefficient_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the mapping from a Monomial to its corresponding coefficient
of this polynomial. We maintain the invariance that for ancy
[monomial, coeff] pair in monomial_to_coefficient_map(),
symbolic:is_zero(coeff) is false.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Polynomial.RemoveTermsWithSmallCoefficients">
<code class="descname">RemoveTermsWithSmallCoefficients</code><span class="sig-paren">(</span><em>self: pydrake.symbolic.Polynomial</em>, <em>coefficient_tol: float</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Polynomial<a class="headerlink" href="#pydrake.symbolic.Polynomial.RemoveTermsWithSmallCoefficients" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes the terms whose absolute value of the coefficients are smaller
than or equal to <code class="docutils literal notranslate"><span class="pre">coefficient_tol</span></code> For example, if the polynomial is
2x² + 3xy + 10⁻⁴x - 10⁻⁵, then after calling
RemoveTermsWithSmallCoefficients(1e-3), the returned polynomial
becomes 2x² + 3xy.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">coefficient_tol</span></code>:</dt>
<dd>A positive scalar.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">polynomial_cleaned</span></code>:</dt>
<dd>A polynomial whose terms with small coefficients are removed.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Polynomial.SetIndeterminates">
<code class="descname">SetIndeterminates</code><span class="sig-paren">(</span><em>self: pydrake.symbolic.Polynomial</em>, <em>new_indeterminates: pydrake.symbolic.Variables</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.symbolic.Polynomial.SetIndeterminates" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the indeterminates to <code class="docutils literal notranslate"><span class="pre">new_indeterminates</span></code>.</p>
<p>Changing the indeterminates would change
<code class="docutils literal notranslate"><span class="pre">monomial_to_coefficient_map()</span></code>, and also potentially the degree of
the polynomial. Here is an example.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">p</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">quadratic</span> <span class="n">polynomial</span> <span class="k">with</span> <span class="n">x</span> <span class="n">being</span> <span class="n">the</span> <span class="n">indeterminates</span><span class="o">.</span>
<span class="n">symbolic</span><span class="p">::</span><span class="n">Polynomial</span> <span class="n">p</span><span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">c</span><span class="p">,</span> <span class="p">{</span><span class="n">x</span><span class="p">});</span>
<span class="o">//</span> <span class="n">p</span><span class="o">.</span><span class="n">monomial_to_coefficient_map</span><span class="p">()</span> <span class="n">contains</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="n">c</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">b</span><span class="p">,</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="p">:</span><span class="n">a</span><span class="p">}</span><span class="o">.</span>
<span class="n">std</span><span class="p">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="o">.</span><span class="n">TotalDegree</span><span class="p">();</span> <span class="o">//</span> <span class="n">prints</span> <span class="mf">2.</span>
<span class="o">//</span> <span class="n">Now</span> <span class="nb">set</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="n">to</span> <span class="n">the</span> <span class="n">indeterminates</span><span class="o">.</span> <span class="n">p</span> <span class="n">becomes</span> <span class="n">a</span> <span class="n">linear</span>
<span class="o">//</span> <span class="n">polynomial</span> <span class="n">of</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span>
<span class="n">p</span><span class="o">.</span><span class="n">SetIndeterminates</span><span class="p">({</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">});</span>
<span class="o">//</span> <span class="n">p</span><span class="o">.</span><span class="n">monomial_to_coefficient_map</span><span class="p">()</span> <span class="n">now</span> <span class="ow">is</span> <span class="p">{</span><span class="n">a</span><span class="p">:</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">x</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span><span class="o">.</span>
<span class="n">std</span><span class="p">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="o">.</span><span class="n">TotalDegree</span><span class="p">();</span> <span class="o">//</span> <span class="n">prints</span> <span class="mf">1.</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Polynomial.ToExpression">
<code class="descname">ToExpression</code><span class="sig-paren">(</span><em>self: pydrake.symbolic.Polynomial</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Expression<a class="headerlink" href="#pydrake.symbolic.Polynomial.ToExpression" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an equivalent symbolic expression of this polynomial.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Polynomial.TotalDegree">
<code class="descname">TotalDegree</code><span class="sig-paren">(</span><em>self: pydrake.symbolic.Polynomial</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.symbolic.Polynomial.TotalDegree" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the total degree of this polynomial.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pydrake.symbolic.positive_semidefinite">
<code class="descclassname">pydrake.symbolic.</code><code class="descname">positive_semidefinite</code><span class="sig-paren">(</span><em>m: numpy.ndarray[object[m, n], flags.f_contiguous]</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Formula<a class="headerlink" href="#pydrake.symbolic.positive_semidefinite" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a symbolic formula constraining <code class="docutils literal notranslate"><span class="pre">m</span></code> to be a
positive-semidefinite matrix. By definition, a symmetric matrix <code class="docutils literal notranslate"><span class="pre">m</span></code>
is positive-semidefinte if xᵀ m x ≥ 0 for all vector x ∈ ℝⁿ.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal notranslate"><span class="pre">m</span></code> is not symmetric.</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This method checks if <code class="docutils literal notranslate"><span class="pre">m</span></code> is symmetric, which can be costly. If
you want to avoid it, please consider using
<code class="docutils literal notranslate"><span class="pre">positive_semidefinite(m.triangularView&lt;Eigen::Lower&gt;())</span></code> or
<code class="docutils literal notranslate"><span class="pre">positive_semidefinite(m.triangularView&lt;Eigen::Upper&gt;())</span></code>
instead of <code class="docutils literal notranslate"><span class="pre">positive_semidefinite(m)</span></code>.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="pydrake.symbolic.pow">
<code class="descclassname">pydrake.symbolic.</code><code class="descname">pow</code><span class="sig-paren">(</span><em>arg0: pydrake.symbolic.Expression</em>, <em>arg1: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Expression<a class="headerlink" href="#pydrake.symbolic.pow" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="pydrake.symbolic.RationalFunction">
<em class="property">class </em><code class="descclassname">pydrake.symbolic.</code><code class="descname">RationalFunction</code><a class="headerlink" href="#pydrake.symbolic.RationalFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>Represents symbolic rational function. A function f(x) is a rational
function, if f(x) = p(x) / q(x), where both p(x) and q(x) are
polynomials of x. Note that rational functions are closed under (+, -,
x, /). One application of rational function is in polynomial
optimization, where we represent (or approximate) functions using
rational functions, and then convert the constraint f(x) = h(x) (where
h(x) is a polynomial) to a polynomial constraint p(x) - q(x) * h(x) =
0, or convert the inequality constraint f(x) &gt;= h(x) as p(x) - q(x) *
h(x) &gt;= 0 if we know q(x) &gt; 0.</p>
<p>This class represents a special subset of the symbolic::Expression.
While a symbolic::Expression can represent a rational function,
extracting the numerator and denominator, generally, is quite
difficult; for instance, from p1(x) / q1(x) + p2(x) / q2(x) + … +
pn(x) / qn(x). This class’s explicit structure facilitates this
decomposition.</p>
<dl class="method">
<dt id="pydrake.symbolic.RationalFunction.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.symbolic.RationalFunction.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.symbolic.RationalFunction) -&gt; None</li>
</ol>
<p>Constructs a zero rational function 0 / 1.</p>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.symbolic.RationalFunction, numerator: pydrake.symbolic.Polynomial, denominator: pydrake.symbolic.Polynomial) -&gt; None</li>
</ol>
<p>Constructs the rational function: numerator / denominator.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">numerator</span></code>:</dt>
<dd>The numerator of the fraction.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">denominator</span></code>:</dt>
<dd>The denominator of the fraction.</dd>
<dt>Precondition:</dt>
<dd>denominator is not equal to zero.</dd>
<dt>Precondition:</dt>
<dd>None of the indeterminates in the numerator can be decision
variables in the denominator; similarly none of the indeterminates
in the denominator can be decision variables in the numerator.</dd>
</dl>
<ol class="arabic simple" start="3">
<li>__init__(self: pydrake.symbolic.RationalFunction, p: pydrake.symbolic.Polynomial) -&gt; None</li>
</ol>
<p>Constructs the rational function: p / 1. Note that we use 1 as the
denominator.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p</span></code>:</dt>
<dd>The numerator of the rational function.</dd>
</dl>
<ol class="arabic simple" start="4">
<li>__init__(self: pydrake.symbolic.RationalFunction, m: pydrake.symbolic.Monomial) -&gt; None</li>
</ol>
<p>Constructs the rational function: m / 1 for any type which can be cast
to a monomial</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">m</span></code>:</dt>
<dd>The numerator of the rational function.</dd>
</dl>
<ol class="arabic simple" start="5">
<li>__init__(self: pydrake.symbolic.RationalFunction, c: float) -&gt; None</li>
</ol>
<p>Constructs the rational function: c / 1. Note that we use 1 as the
denominator.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">c</span></code>:</dt>
<dd>The numerator of the rational function.</dd>
</dl>
<ol class="arabic simple" start="6">
<li>__init__(self: pydrake.symbolic.RationalFunction) -&gt; None</li>
</ol>
<p>Constructs a zero rational function 0 / 1.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.RationalFunction.denominator">
<code class="descname">denominator</code><span class="sig-paren">(</span><em>self: pydrake.symbolic.RationalFunction</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Polynomial<a class="headerlink" href="#pydrake.symbolic.RationalFunction.denominator" title="Permalink to this definition">¶</a></dt>
<dd><p>Getter for the denominator.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.RationalFunction.EqualTo">
<code class="descname">EqualTo</code><span class="sig-paren">(</span><em>self: pydrake.symbolic.RationalFunction</em>, <em>f: pydrake.symbolic.RationalFunction</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.symbolic.RationalFunction.EqualTo" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true if this rational function and f are structurally equal.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.RationalFunction.Evaluate">
<code class="descname">Evaluate</code><span class="sig-paren">(</span><em>self: pydrake.symbolic.RationalFunction, env: Dict[pydrake.symbolic.Variable, float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.symbolic.RationalFunction.Evaluate" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluates this rational function under a given environment <code class="docutils literal notranslate"><span class="pre">env</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if there is a variable in this rational function</li>
<li>whose assignment is not provided by <code class="docutils literal notranslate"><span class="pre">env</span></code>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.RationalFunction.numerator">
<code class="descname">numerator</code><span class="sig-paren">(</span><em>self: pydrake.symbolic.RationalFunction</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Polynomial<a class="headerlink" href="#pydrake.symbolic.RationalFunction.numerator" title="Permalink to this definition">¶</a></dt>
<dd><p>Getter for the numerator.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.RationalFunction.SetIndeterminates">
<code class="descname">SetIndeterminates</code><span class="sig-paren">(</span><em>self: pydrake.symbolic.RationalFunction</em>, <em>new_indeterminates: pydrake.symbolic.Variables</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.symbolic.RationalFunction.SetIndeterminates" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the indeterminates of the numerator and denominator polynomials</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.RationalFunction.ToExpression">
<code class="descname">ToExpression</code><span class="sig-paren">(</span><em>self: pydrake.symbolic.RationalFunction</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Expression<a class="headerlink" href="#pydrake.symbolic.RationalFunction.ToExpression" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an equivalent symbolic expression of this rational function.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pydrake.symbolic.ReplaceBilinearTerms">
<code class="descclassname">pydrake.symbolic.</code><code class="descname">ReplaceBilinearTerms</code><span class="sig-paren">(</span><em>e: pydrake.symbolic.Expression, x: numpy.ndarray[object[m, 1]], y: numpy.ndarray[object[m, 1]], W: numpy.ndarray[object[m, n], flags.f_contiguous]</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Expression<a class="headerlink" href="#pydrake.symbolic.ReplaceBilinearTerms" title="Permalink to this definition">¶</a></dt>
<dd><p>Replaces all the bilinear product terms in the expression <code class="docutils literal notranslate"><span class="pre">e</span></code>, with
the corresponding terms in <code class="docutils literal notranslate"><span class="pre">W</span></code>, where <code class="docutils literal notranslate"><span class="pre">W</span></code> represents the matrix x
* yᵀ, such that after replacement, <code class="docutils literal notranslate"><span class="pre">e</span></code> does not have bilinear terms
involving <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code>. For example, if e = x(0)*y(0) + 2 *
x(0)*y(1) + x(1) * y(1) + 3 * x(1), <code class="docutils literal notranslate"><span class="pre">e</span></code> has bilinear terms
x(0)*y(0), x(0) * y(1) and x(2) * y(1), if we call
ReplaceBilinearTerms(e, x, y, W) where W(i, j) represent the term x(i)
* y(j), then this function returns W(0, 0) + 2 * W(0, 1) + W(1, 1) + 3
* x(1).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">e</span></code>:</dt>
<dd>An expression potentially contains bilinear products between x and
y.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">x</span></code>:</dt>
<dd>The bilinear product between <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> will be replaced by
the corresponding term in <code class="docutils literal notranslate"><span class="pre">W</span></code>.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal notranslate"><span class="pre">x</span></code> contains duplicate entries.</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">y</span></code>:</dt>
<dd>The bilinear product between <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> will be replaced by
the corresponding term in <a href="#id7"><span class="problematic" id="id8">``</span></a>W.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <cite>y`</cite> contains duplicate entries.</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">W</span></code>:</dt>
<dd>Bilinear product term x(i) * y(j) will be replaced by W(i, j). If
W(i,j) is not a single variable, but an expression, then this
expression cannot contain a variable in either x or y.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError, if W(i, j) is not a single variable, and also</li>
<li>contains a variable in x or y.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Precondition:</dt>
<dd>W.rows() == x.rows() and W.cols() == y.rows().</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The symbolic expression after replacing x(i) * y(j) with W(i, j).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pydrake.symbolic.sin">
<code class="descclassname">pydrake.symbolic.</code><code class="descname">sin</code><span class="sig-paren">(</span><em>arg0: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Expression<a class="headerlink" href="#pydrake.symbolic.sin" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="pydrake.symbolic.SinCos">
<em class="property">class </em><code class="descclassname">pydrake.symbolic.</code><code class="descname">SinCos</code><a class="headerlink" href="#pydrake.symbolic.SinCos" title="Permalink to this definition">¶</a></dt>
<dd><p>Represents a pair of Variables corresponding to sin(q) and cos(q).</p>
<dl class="method">
<dt id="pydrake.symbolic.SinCos.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.symbolic.SinCos</em>, <em>s: pydrake.symbolic.Variable</em>, <em>c: pydrake.symbolic.Variable</em>, <em>type: pydrake.symbolic.SinCosSubstitutionType = &lt;SinCosSubstitutionType.kAngle: 0&gt;</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.symbolic.SinCos.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.symbolic.SinCos.c">
<code class="descname">c</code><a class="headerlink" href="#pydrake.symbolic.SinCos.c" title="Permalink to this definition">¶</a></dt>
<dd><p>cos variable.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.symbolic.SinCos.s">
<code class="descname">s</code><a class="headerlink" href="#pydrake.symbolic.SinCos.s" title="Permalink to this definition">¶</a></dt>
<dd><p>sin variable.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.symbolic.SinCos.type">
<code class="descname">type</code><a class="headerlink" href="#pydrake.symbolic.SinCos.type" title="Permalink to this definition">¶</a></dt>
<dd><p>Allows a user to specify non-default substitutions, such as using
half-angle formulas.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.symbolic.SinCosSubstitutionType">
<em class="property">class </em><code class="descclassname">pydrake.symbolic.</code><code class="descname">SinCosSubstitutionType</code><a class="headerlink" href="#pydrake.symbolic.SinCosSubstitutionType" title="Permalink to this definition">¶</a></dt>
<dd><p>Members:</p>
<blockquote>
<div><p>kAngle : Substitutes s &lt;=&gt; sin(q), c &lt;=&gt; cos(q).</p>
<p>kHalfAnglePreferSin : Substitutes s &lt;=&gt; sin(q/2), c &lt;=&gt; cos(q/2), and prefers sin when the</p>
</div></blockquote>
<p>choice is ambiguous; e.g. cos(q) =&gt; 1 - 2s².</p>
<blockquote>
<div>kHalfAnglePreferCos : Subsitutes s &lt;=&gt; sin(q/2), c &lt;=&gt; cos(q/2), and prefers cos when the</div></blockquote>
<p>choice is ambiguous; e.g. cos(q) =&gt; 2c² - 1.</p>
<dl class="method">
<dt id="pydrake.symbolic.SinCosSubstitutionType.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.symbolic.SinCosSubstitutionType</em>, <em>value: int</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.symbolic.SinCosSubstitutionType.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.symbolic.SinCosSubstitutionType.kAngle">
<code class="descname">kAngle</code><em class="property"> = &lt;SinCosSubstitutionType.kAngle: 0&gt;</em><a class="headerlink" href="#pydrake.symbolic.SinCosSubstitutionType.kAngle" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.symbolic.SinCosSubstitutionType.kHalfAnglePreferCos">
<code class="descname">kHalfAnglePreferCos</code><em class="property"> = &lt;SinCosSubstitutionType.kHalfAnglePreferCos: 2&gt;</em><a class="headerlink" href="#pydrake.symbolic.SinCosSubstitutionType.kHalfAnglePreferCos" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.symbolic.SinCosSubstitutionType.kHalfAnglePreferSin">
<code class="descname">kHalfAnglePreferSin</code><em class="property"> = &lt;SinCosSubstitutionType.kHalfAnglePreferSin: 1&gt;</em><a class="headerlink" href="#pydrake.symbolic.SinCosSubstitutionType.kHalfAnglePreferSin" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.symbolic.SinCosSubstitutionType.name">
<code class="descname">name</code><a class="headerlink" href="#pydrake.symbolic.SinCosSubstitutionType.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.symbolic.SinCosSubstitutionType.value">
<code class="descname">value</code><a class="headerlink" href="#pydrake.symbolic.SinCosSubstitutionType.value" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="pydrake.symbolic.sinh">
<code class="descclassname">pydrake.symbolic.</code><code class="descname">sinh</code><span class="sig-paren">(</span><em>arg0: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Expression<a class="headerlink" href="#pydrake.symbolic.sinh" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pydrake.symbolic.sqrt">
<code class="descclassname">pydrake.symbolic.</code><code class="descname">sqrt</code><span class="sig-paren">(</span><em>arg0: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Expression<a class="headerlink" href="#pydrake.symbolic.sqrt" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pydrake.symbolic.Substitute">
<code class="descclassname">pydrake.symbolic.</code><code class="descname">Substitute</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.symbolic.Substitute" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>Substitute(m: numpy.ndarray[object[m, n]], subst: Dict[pydrake.symbolic.Variable, pydrake.symbolic.Expression]) -&gt; numpy.ndarray[object[m, n]]</li>
</ol>
<p>Substitutes a symbolic matrix <code class="docutils literal notranslate"><span class="pre">m</span></code> using a given substitution
<code class="docutils literal notranslate"><span class="pre">subst</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a matrix of symbolic expressions whose size is the size of <code class="docutils literal notranslate"><span class="pre">m</span></code>.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if NaN is detected during substitution.</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>Substitute(m: numpy.ndarray[object[m, n]], var: pydrake.symbolic.Variable, e: pydrake.symbolic.Expression) -&gt; numpy.ndarray[object[m, n]]</li>
</ol>
<p>Substitutes <code class="docutils literal notranslate"><span class="pre">var</span></code> with <code class="docutils literal notranslate"><span class="pre">e</span></code> in a symbolic matrix <code class="docutils literal notranslate"><span class="pre">m</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a matrix of symbolic expressions whose size is the size of <code class="docutils literal notranslate"><span class="pre">m</span></code>.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if NaN is detected during substitution.</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="3">
<li>Substitute(e: pydrake.symbolic.Expression, subs: Dict[pydrake.symbolic.Variable, pydrake.symbolic.SinCos]) -&gt; pydrake.symbolic.Expression</li>
</ol>
<p>Given a substitution map q =&gt; {s, c}, substitutes instances of sin(q)
and cos(q) in <code class="docutils literal notranslate"><span class="pre">e</span></code> with <code class="docutils literal notranslate"><span class="pre">s</span></code> and <code class="docutils literal notranslate"><span class="pre">c</span></code>, with partial support for
trigonometric expansions. For instance,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Variable</span> <span class="n">x</span><span class="p">{</span><span class="s2">&quot;x&quot;</span><span class="p">},</span> <span class="n">y</span><span class="p">{</span><span class="s2">&quot;y&quot;</span><span class="p">};</span>
<span class="n">Variable</span> <span class="n">sx</span><span class="p">{</span><span class="s2">&quot;sx&quot;</span><span class="p">},</span> <span class="n">cx</span><span class="p">{</span><span class="s2">&quot;cx&quot;</span><span class="p">},</span> <span class="n">sy</span><span class="p">{</span><span class="s2">&quot;sy&quot;</span><span class="p">},</span> <span class="n">cy</span><span class="p">{</span><span class="s2">&quot;cy&quot;</span><span class="p">};</span>
<span class="n">SinCosSubstitution</span> <span class="n">subs</span><span class="p">;</span>
<span class="n">subs</span><span class="o">.</span><span class="n">emplace</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">SinCos</span><span class="p">(</span><span class="n">sx</span><span class="p">,</span> <span class="n">cx</span><span class="p">));</span>
<span class="n">subs</span><span class="o">.</span><span class="n">emplace</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">SinCos</span><span class="p">(</span><span class="n">sy</span><span class="p">,</span> <span class="n">cy</span><span class="p">));</span>
<span class="n">Expression</span> <span class="n">e</span> <span class="o">=</span> <span class="n">Substitute</span><span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">),</span> <span class="n">subs</span><span class="p">);</span>
</pre></div>
</div>
<p>will result in the expression <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">*</span> <span class="pre">(sx*cy</span> <span class="pre">+</span> <span class="pre">cx*sy)</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">half_angle</span></code>:</dt>
<dd>If true, then the same workflow replaces instances of sin(q/2) and
cos(q/2) in <code class="docutils literal notranslate"><span class="pre">e</span></code> will be replaced with <code class="docutils literal notranslate"><span class="pre">s</span></code>, and <code class="docutils literal notranslate"><span class="pre">c</span></code>.</dd>
<dt><em>Default:</em> false.</dt>
<dd>The half-angle representation is more natural in many analysis
computations for robots, for instance:
<a class="reference external" href="https://underactuated.csail.mit.edu/lyapunov.html#trig_quadratic">https://underactuated.csail.mit.edu/lyapunov.html#trig_quadratic</a></dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if a trigonometric function is not a trigonometric</li>
<li>polynomial in <code class="docutils literal notranslate"><span class="pre">q</span></code> or if the <code class="docutils literal notranslate"><span class="pre">e</span></code> requires a trigonometric</li>
<li>expansion that not supported yet.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="4">
<li>Substitute(m: numpy.ndarray[object[m, n]], subs: Dict[pydrake.symbolic.Variable, pydrake.symbolic.SinCos]) -&gt; numpy.ndarray[object[m, n]]</li>
</ol>
<p>Matrix version of sin/cos substitution.</p>
</dd></dl>

<dl class="function">
<dt id="pydrake.symbolic.SubstituteStereographicProjection">
<code class="descclassname">pydrake.symbolic.</code><code class="descname">SubstituteStereographicProjection</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.symbolic.SubstituteStereographicProjection" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>SubstituteStereographicProjection(e: drake::symbolic::Polynomial, sin_cos: List[pydrake.symbolic.SinCos], t: numpy.ndarray[object[m, 1]]) -&gt; drake::symbolic::RationalFunction</li>
</ol>
<p>Substitutes the variables representing sine and cosine functions with
their stereographic projection. If e is a multilinear polynomial of
cosθ and sinθ, and no cosθᵢ and sinθᵢ appear in the same monomial,
then we replace cosθᵢ with (1-tᵢ²)/(1+tᵢ²), and sinθᵢ with
2tᵢ/(1+tᵢ²), and get a rational polynomial of t. If the input
expression doesn’t contain the sine and cosine functions, then the
returned rational has denominator being 1.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">e</span></code>:</dt>
<dd>The symbolic polynomial to be substituted. Note that e has to be a
multilinear polynomial of variables in <code class="docutils literal notranslate"><span class="pre">sin_cos</span></code>, namely
e.indeterminates() is a subset of all the variables in
<code class="docutils literal notranslate"><span class="pre">sin_cos</span></code>, and no sin_cos[i].s and sin_cos[i].c appear in the
same monomial. Namely that e can be sin_cos[0].s * sin_cos[1].c +
1 or t[0]*sin_cos[0].s * sin_cos[1].c + 1 (note t can also appear
in e), but cannot be sin_cos[0].s * sin_cos[0].c (where
sin_cos[0].s and sin_cos[0].c appear in the same monomial) or
pow(sin_cos[0].s, 2) (where the degree or sin_cos[0].s is larger
than 1).</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">sin_cos</span></code>:</dt>
<dd>sin_cos(i) is the pair of variables (sᵢ, cᵢ), (where sᵢ=sinθᵢ,
cᵢ=cosθᵢ) as documented above.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">t</span></code>:</dt>
<dd>New variables to express cos and sin as rationals of t. tᵢ =
tan(θᵢ/2).</dd>
<dt>Precondition:</dt>
<dd>t.rows() == sin_cos.size()</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">e_rational The rational polynomial of e after replacement. The
indeterminates of the polynomials are <code class="docutils literal notranslate"><span class="pre">t</span></code>. Example</td>
</tr>
</tbody>
</table>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SinCos</span><span class="o">&gt;</span> <span class="n">sin_cos</span><span class="p">;</span>
<span class="n">sin_cos</span><span class="o">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">symbolic</span><span class="p">::</span><span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;s0&quot;</span><span class="p">),</span> <span class="n">symbolic</span><span class="p">::</span><span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;c0&quot;</span><span class="p">));</span>
<span class="n">sin_cos</span><span class="o">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">symbolic</span><span class="p">::</span><span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;s1&quot;</span><span class="p">),</span> <span class="n">symbolic</span><span class="p">::</span><span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;c1&quot;</span><span class="p">));</span>
<span class="n">Vector2</span><span class="o">&lt;</span><span class="n">symbolic</span><span class="p">::</span><span class="n">Variable</span><span class="o">&gt;</span> <span class="n">t</span><span class="p">(</span><span class="n">symbolic</span><span class="p">::</span><span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;t0&quot;</span><span class="p">),</span>
                              <span class="n">symbolic</span><span class="p">::</span><span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;t1&quot;</span><span class="p">));</span>
<span class="n">const</span> <span class="n">auto</span> <span class="n">e_rational</span> <span class="o">=</span>
<span class="n">SubstituteStereographicProjection</span><span class="p">(</span><span class="n">t</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="n">sin_cos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">s</span><span class="o">*</span><span class="n">sin_cos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">c</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                                  <span class="n">sin_cos</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>
<span class="o">//</span> <span class="n">e_rational</span> <span class="n">should</span> <span class="n">be</span>
<span class="o">//</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">t0</span><span class="o">*</span><span class="n">t0</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">t1</span><span class="o">*</span><span class="n">t1</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">t0</span><span class="o">*</span><span class="n">t0</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">t1</span><span class="o">*</span><span class="n">t1</span><span class="p">))</span>
<span class="o">//</span> <span class="o">--------------------------------------------</span>
<span class="o">//</span>        <span class="p">((</span><span class="mi">1</span><span class="o">+</span><span class="n">t0</span><span class="o">*</span><span class="n">t0</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">t1</span><span class="o">*</span><span class="n">t1</span><span class="p">))</span>
</pre></div>
</div>
<ol class="arabic simple" start="2">
<li>SubstituteStereographicProjection(e: pydrake.symbolic.Expression, subs: Dict[pydrake.symbolic.Variable, pydrake.symbolic.Variable]) -&gt; drake::symbolic::RationalFunction</li>
</ol>
<p>Substitutes sine and cosine function with their stereographic
projection. If e is a multilinear polynomial of cosθ and sinθ, and no
cosθᵢ and sinθᵢ appear in the same monomial, then we replace cosθᵢ
with (1-tᵢ²)/(1+tᵢ²), and sinθᵢ with 2tᵢ/(1+tᵢ²), and get a rational
polynomial of t. If the input expression doesn’t contain the sine and
cosine functions, then the returned rational has denominator being 1.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">e</span></code>:</dt>
<dd>The symbolic expression to be substituted. Note that e has to be a
multilinear polynomial of cosθ and sinθ, and no cosθᵢ and sinθᵢ
appear in the same monomial. Namely that e can be cosθ₁sinθ₂ +
sinθ₂ or t₁cosθ₁sinθ₂ + sinθ₂ (note that t can also appear in e),
but cannot be sinθ₁cosθ₁ (where sinθ₁ and cosθ₁ appear in the same
monomial) or sin²θ₁ (where the degree or sinθ₁ is larger than 1).</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">subs</span></code>:</dt>
<dd>Correspond each θᵢ to tᵢ, we will replace cosθᵢ with
(1-tᵢ²)/(1+tᵢ²), and sinθᵢ with 2tᵢ/(1+tᵢ²)</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">e_rational The rational polynomial after replacing cosθᵢ with
(1-tᵢ²)/(1+tᵢ²), and sinθᵢ with 2tᵢ/(1+tᵢ²). The indeterminates of
the rational polynomials are t.</td>
</tr>
</tbody>
</table>
<p>Example</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>const symbolic::Variable theta1(&quot;theta1&quot;);
const symbolic::Variable theta2(&quot;theta1&quot;);
const symbolic::Variable t1{&quot;t1&quot;);
const symbolic::Variable t2{&quot;t2&quot;);
const auto e_rational = SubstituteStereographicProjection(t1 *
    sin(theta1)*cos(theta2) + 1, {{theta1, t1}, {theta2, t2}});
// The result of e_rational is
// (2t₁²(1−t₂²) + (1+t₁²)(1+t₂²)) / ((1+t₁²)(1+t₂²))
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pydrake.symbolic.tan">
<code class="descclassname">pydrake.symbolic.</code><code class="descname">tan</code><span class="sig-paren">(</span><em>arg0: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Expression<a class="headerlink" href="#pydrake.symbolic.tan" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pydrake.symbolic.tanh">
<code class="descclassname">pydrake.symbolic.</code><code class="descname">tanh</code><span class="sig-paren">(</span><em>arg0: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Expression<a class="headerlink" href="#pydrake.symbolic.tanh" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pydrake.symbolic.TaylorExpand">
<code class="descclassname">pydrake.symbolic.</code><code class="descname">TaylorExpand</code><span class="sig-paren">(</span><em>f: drake::symbolic::Expression, a: Dict[pydrake.symbolic.Variable, float], order: int</em><span class="sig-paren">)</span> &#x2192; drake::symbolic::Expression<a class="headerlink" href="#pydrake.symbolic.TaylorExpand" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the Taylor series expansion of <code class="docutils literal notranslate"><span class="pre">f</span></code> around <code class="docutils literal notranslate"><span class="pre">a</span></code> of order
<code class="docutils literal notranslate"><span class="pre">order</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">f</span></code>:</dt>
<dd>Symbolic expression to approximate using Taylor series expansion.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">a</span></code>:</dt>
<dd>Symbolic environment which specifies the point of approximation.
If a partial environment is provided, the unspecified variables
are treated as symbolic variables (e.g. decision variable).</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">order</span></code>:</dt>
<dd>Positive integer which specifies the maximum order of the
resulting polynomial approximating <code class="docutils literal notranslate"><span class="pre">f</span></code> around <code class="docutils literal notranslate"><span class="pre">a</span></code>.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pydrake.symbolic.ToLatex">
<code class="descclassname">pydrake.symbolic.</code><code class="descname">ToLatex</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.symbolic.ToLatex" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>ToLatex(e: pydrake.symbolic.Expression, precision: int = 3) -&gt; str</li>
</ol>
<p>Generates a LaTeX string representation of <code class="docutils literal notranslate"><span class="pre">e</span></code> with floating point
coefficients displayed using <code class="docutils literal notranslate"><span class="pre">precision</span></code>.</p>
<ol class="arabic simple" start="2">
<li>ToLatex(f: pydrake.symbolic.Formula, precision: int = 3) -&gt; str</li>
</ol>
<p>Generates a LaTeX string representation of <code class="docutils literal notranslate"><span class="pre">f</span></code> with floating point
coefficients displayed using <code class="docutils literal notranslate"><span class="pre">precision</span></code>.</p>
<ol class="arabic simple" start="3">
<li>ToLatex(M: numpy.ndarray[object[m, n]], precision: int = 3) -&gt; str</li>
</ol>
<p>Generates a LaTeX string representation of <code class="docutils literal notranslate"><span class="pre">M</span></code> with floating point
coefficients displayed using <code class="docutils literal notranslate"><span class="pre">precision</span></code>.</p>
<ol class="arabic simple" start="4">
<li>ToLatex(M: numpy.ndarray[numpy.float64[m, n]], precision: int = 3) -&gt; str</li>
</ol>
<p>Generates a LaTeX string representation of <code class="docutils literal notranslate"><span class="pre">M</span></code> with floating point
coefficients displayed using <code class="docutils literal notranslate"><span class="pre">precision</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="pydrake.symbolic.uninterpreted_function">
<code class="descclassname">pydrake.symbolic.</code><code class="descname">uninterpreted_function</code><span class="sig-paren">(</span><em>name: str, arguments: List[pydrake.symbolic.Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Expression<a class="headerlink" href="#pydrake.symbolic.uninterpreted_function" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs an uninterpreted-function expression with <code class="docutils literal notranslate"><span class="pre">name</span></code> and
<code class="docutils literal notranslate"><span class="pre">arguments</span></code>. An uninterpreted function is an opaque function that
has no other property than its name and a list of its arguments. This
is useful to applications where it is good enough to provide abstract
information of a function without exposing full details. Declaring
sparsity of a system is a typical example.</p>
</dd></dl>

<dl class="class">
<dt id="pydrake.symbolic.Variable">
<em class="property">class </em><code class="descclassname">pydrake.symbolic.</code><code class="descname">Variable</code><a class="headerlink" href="#pydrake.symbolic.Variable" title="Permalink to this definition">¶</a></dt>
<dd><p>Represents a symbolic variable.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Expression::Evaluate and Formula::Evaluate methods take a symbolic
environment (Variable → double) and a random number generator.
When an expression or a formula includes random variables,
<code class="docutils literal notranslate"><span class="pre">Evaluate</span></code> methods use the random number generator to draw a
number for a random variable from the given distribution. Then
this numeric value is used to substitute all the occurrences of
the corresponding random variable in an expression or a formula.</p>
</div>
<dl class="method">
<dt id="pydrake.symbolic.Variable.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.symbolic.Variable</em>, <em>name: str</em>, <em>type: pydrake.symbolic.Variable.Type = &lt;Type.CONTINUOUS: 0&gt;</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.symbolic.Variable.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs a variable with a string. If not specified, it has
CONTINUOUS type by default.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Variable.abs">
<code class="descname">abs</code><span class="sig-paren">(</span><em>self: drake::symbolic::Expression</em><span class="sig-paren">)</span> &#x2192; drake::symbolic::Expression<a class="headerlink" href="#pydrake.symbolic.Variable.abs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Variable.acos">
<code class="descname">acos</code><span class="sig-paren">(</span><em>self: drake::symbolic::Expression</em><span class="sig-paren">)</span> &#x2192; drake::symbolic::Expression<a class="headerlink" href="#pydrake.symbolic.Variable.acos" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Variable.arccos">
<code class="descname">arccos</code><span class="sig-paren">(</span><em>self: drake::symbolic::Expression</em><span class="sig-paren">)</span> &#x2192; drake::symbolic::Expression<a class="headerlink" href="#pydrake.symbolic.Variable.arccos" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Variable.arcsin">
<code class="descname">arcsin</code><span class="sig-paren">(</span><em>self: drake::symbolic::Expression</em><span class="sig-paren">)</span> &#x2192; drake::symbolic::Expression<a class="headerlink" href="#pydrake.symbolic.Variable.arcsin" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Variable.arctan">
<code class="descname">arctan</code><span class="sig-paren">(</span><em>self: drake::symbolic::Expression</em><span class="sig-paren">)</span> &#x2192; drake::symbolic::Expression<a class="headerlink" href="#pydrake.symbolic.Variable.arctan" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Variable.arctan2">
<code class="descname">arctan2</code><span class="sig-paren">(</span><em>self: drake::symbolic::Expression</em>, <em>arg0: drake::symbolic::Expression</em><span class="sig-paren">)</span> &#x2192; drake::symbolic::Expression<a class="headerlink" href="#pydrake.symbolic.Variable.arctan2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Variable.asin">
<code class="descname">asin</code><span class="sig-paren">(</span><em>self: drake::symbolic::Expression</em><span class="sig-paren">)</span> &#x2192; drake::symbolic::Expression<a class="headerlink" href="#pydrake.symbolic.Variable.asin" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Variable.atan">
<code class="descname">atan</code><span class="sig-paren">(</span><em>self: drake::symbolic::Expression</em><span class="sig-paren">)</span> &#x2192; drake::symbolic::Expression<a class="headerlink" href="#pydrake.symbolic.Variable.atan" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Variable.atan2">
<code class="descname">atan2</code><span class="sig-paren">(</span><em>self: drake::symbolic::Expression</em>, <em>arg0: drake::symbolic::Expression</em><span class="sig-paren">)</span> &#x2192; drake::symbolic::Expression<a class="headerlink" href="#pydrake.symbolic.Variable.atan2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Variable.ceil">
<code class="descname">ceil</code><span class="sig-paren">(</span><em>self: drake::symbolic::Expression</em><span class="sig-paren">)</span> &#x2192; drake::symbolic::Expression<a class="headerlink" href="#pydrake.symbolic.Variable.ceil" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Variable.cos">
<code class="descname">cos</code><span class="sig-paren">(</span><em>self: drake::symbolic::Expression</em><span class="sig-paren">)</span> &#x2192; drake::symbolic::Expression<a class="headerlink" href="#pydrake.symbolic.Variable.cos" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Variable.cosh">
<code class="descname">cosh</code><span class="sig-paren">(</span><em>self: drake::symbolic::Expression</em><span class="sig-paren">)</span> &#x2192; drake::symbolic::Expression<a class="headerlink" href="#pydrake.symbolic.Variable.cosh" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Variable.EqualTo">
<code class="descname">EqualTo</code><span class="sig-paren">(</span><em>self: pydrake.symbolic.Variable</em>, <em>arg0: pydrake.symbolic.Variable</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.symbolic.Variable.EqualTo" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks the equality of two variables based on their ID values.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Variable.exp">
<code class="descname">exp</code><span class="sig-paren">(</span><em>self: drake::symbolic::Expression</em><span class="sig-paren">)</span> &#x2192; drake::symbolic::Expression<a class="headerlink" href="#pydrake.symbolic.Variable.exp" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Variable.floor">
<code class="descname">floor</code><span class="sig-paren">(</span><em>self: drake::symbolic::Expression</em><span class="sig-paren">)</span> &#x2192; drake::symbolic::Expression<a class="headerlink" href="#pydrake.symbolic.Variable.floor" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Variable.get_id">
<code class="descname">get_id</code><span class="sig-paren">(</span><em>self: pydrake.symbolic.Variable</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.symbolic.Variable.get_id" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Variable.get_name">
<code class="descname">get_name</code><span class="sig-paren">(</span><em>self: pydrake.symbolic.Variable</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#pydrake.symbolic.Variable.get_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Variable.get_type">
<code class="descname">get_type</code><span class="sig-paren">(</span><em>self: pydrake.symbolic.Variable</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Variable.Type<a class="headerlink" href="#pydrake.symbolic.Variable.get_type" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Variable.inv">
<code class="descname">inv</code><span class="sig-paren">(</span><em>self: numpy.ndarray[object[m, n]]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, n]]<a class="headerlink" href="#pydrake.symbolic.Variable.inv" title="Permalink to this definition">¶</a></dt>
<dd><p>Symbolic matrix inverse</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Variable.is_dummy">
<code class="descname">is_dummy</code><span class="sig-paren">(</span><em>self: pydrake.symbolic.Variable</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.symbolic.Variable.is_dummy" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks if this is a dummy variable (ID = 0) which is created by the
default constructor.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Variable.log">
<code class="descname">log</code><span class="sig-paren">(</span><em>self: drake::symbolic::Expression</em><span class="sig-paren">)</span> &#x2192; drake::symbolic::Expression<a class="headerlink" href="#pydrake.symbolic.Variable.log" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Variable.max">
<code class="descname">max</code><span class="sig-paren">(</span><em>self: drake::symbolic::Expression</em>, <em>arg0: drake::symbolic::Expression</em><span class="sig-paren">)</span> &#x2192; drake::symbolic::Expression<a class="headerlink" href="#pydrake.symbolic.Variable.max" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Variable.min">
<code class="descname">min</code><span class="sig-paren">(</span><em>self: drake::symbolic::Expression</em>, <em>arg0: drake::symbolic::Expression</em><span class="sig-paren">)</span> &#x2192; drake::symbolic::Expression<a class="headerlink" href="#pydrake.symbolic.Variable.min" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Variable.pow">
<code class="descname">pow</code><span class="sig-paren">(</span><em>self: pydrake.symbolic.Variable</em>, <em>arg0: drake::symbolic::Expression</em><span class="sig-paren">)</span> &#x2192; drake::symbolic::Expression<a class="headerlink" href="#pydrake.symbolic.Variable.pow" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Variable.sin">
<code class="descname">sin</code><span class="sig-paren">(</span><em>self: drake::symbolic::Expression</em><span class="sig-paren">)</span> &#x2192; drake::symbolic::Expression<a class="headerlink" href="#pydrake.symbolic.Variable.sin" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Variable.sinh">
<code class="descname">sinh</code><span class="sig-paren">(</span><em>self: drake::symbolic::Expression</em><span class="sig-paren">)</span> &#x2192; drake::symbolic::Expression<a class="headerlink" href="#pydrake.symbolic.Variable.sinh" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Variable.sqrt">
<code class="descname">sqrt</code><span class="sig-paren">(</span><em>self: drake::symbolic::Expression</em><span class="sig-paren">)</span> &#x2192; drake::symbolic::Expression<a class="headerlink" href="#pydrake.symbolic.Variable.sqrt" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Variable.tan">
<code class="descname">tan</code><span class="sig-paren">(</span><em>self: drake::symbolic::Expression</em><span class="sig-paren">)</span> &#x2192; drake::symbolic::Expression<a class="headerlink" href="#pydrake.symbolic.Variable.tan" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Variable.tanh">
<code class="descname">tanh</code><span class="sig-paren">(</span><em>self: drake::symbolic::Expression</em><span class="sig-paren">)</span> &#x2192; drake::symbolic::Expression<a class="headerlink" href="#pydrake.symbolic.Variable.tanh" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="pydrake.symbolic.Variable.Type">
<em class="property">class </em><code class="descname">Type</code><a class="headerlink" href="#pydrake.symbolic.Variable.Type" title="Permalink to this definition">¶</a></dt>
<dd><p>Members:</p>
<blockquote>
<div><p>CONTINUOUS : A CONTINUOUS variable takes a <code class="docutils literal notranslate"><span class="pre">double</span></code> value.</p>
<p>INTEGER : An INTEGER variable takes an <code class="docutils literal notranslate"><span class="pre">int</span></code> value.</p>
<p>BINARY : A BINARY variable takes an integer value from {0, 1}.</p>
<p>BOOLEAN : A BOOLEAN variable takes a <code class="docutils literal notranslate"><span class="pre">bool</span></code> value.</p>
<p>RANDOM_UNIFORM : A random variable whose value will be drawn from uniform real</p>
</div></blockquote>
<p>distributed ∈ [0,1).</p>
<blockquote>
<div>RANDOM_GAUSSIAN : A random variable whose value will be drawn from mean-zero,</div></blockquote>
<p>unit-variance normal.</p>
<blockquote>
<div>RANDOM_EXPONENTIAL : A random variable whose value will be drawn from exponential</div></blockquote>
<p>distribution with λ=1.</p>
<dl class="method">
<dt id="pydrake.symbolic.Variable.Type.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.symbolic.Variable.Type</em>, <em>value: int</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.symbolic.Variable.Type.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.symbolic.Variable.Type.BINARY">
<code class="descname">BINARY</code><em class="property"> = &lt;Type.BINARY: 2&gt;</em><a class="headerlink" href="#pydrake.symbolic.Variable.Type.BINARY" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.symbolic.Variable.Type.BOOLEAN">
<code class="descname">BOOLEAN</code><em class="property"> = &lt;Type.BOOLEAN: 3&gt;</em><a class="headerlink" href="#pydrake.symbolic.Variable.Type.BOOLEAN" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.symbolic.Variable.Type.CONTINUOUS">
<code class="descname">CONTINUOUS</code><em class="property"> = &lt;Type.CONTINUOUS: 0&gt;</em><a class="headerlink" href="#pydrake.symbolic.Variable.Type.CONTINUOUS" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.symbolic.Variable.Type.INTEGER">
<code class="descname">INTEGER</code><em class="property"> = &lt;Type.INTEGER: 1&gt;</em><a class="headerlink" href="#pydrake.symbolic.Variable.Type.INTEGER" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.symbolic.Variable.Type.name">
<code class="descname">name</code><a class="headerlink" href="#pydrake.symbolic.Variable.Type.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.symbolic.Variable.Type.RANDOM_EXPONENTIAL">
<code class="descname">RANDOM_EXPONENTIAL</code><em class="property"> = &lt;Type.RANDOM_EXPONENTIAL: 6&gt;</em><a class="headerlink" href="#pydrake.symbolic.Variable.Type.RANDOM_EXPONENTIAL" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.symbolic.Variable.Type.RANDOM_GAUSSIAN">
<code class="descname">RANDOM_GAUSSIAN</code><em class="property"> = &lt;Type.RANDOM_GAUSSIAN: 5&gt;</em><a class="headerlink" href="#pydrake.symbolic.Variable.Type.RANDOM_GAUSSIAN" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.symbolic.Variable.Type.RANDOM_UNIFORM">
<code class="descname">RANDOM_UNIFORM</code><em class="property"> = &lt;Type.RANDOM_UNIFORM: 4&gt;</em><a class="headerlink" href="#pydrake.symbolic.Variable.Type.RANDOM_UNIFORM" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.symbolic.Variable.Type.value">
<code class="descname">value</code><a class="headerlink" href="#pydrake.symbolic.Variable.Type.value" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.symbolic.Variables">
<em class="property">class </em><code class="descclassname">pydrake.symbolic.</code><code class="descname">Variables</code><a class="headerlink" href="#pydrake.symbolic.Variables" title="Permalink to this definition">¶</a></dt>
<dd><p>Represents a set of variables.</p>
<p>This class is based on std::set&lt;Variable&gt;. The intent is to add things
that we need including set-union (Variables::insert, operator+,
operator+=), set-minus (Variables::erase, operator-, operator-=), and
subset/superset checking functions (Variables::IsSubsetOf,
Variables::IsSupersetOf, Variables::IsStrictSubsetOf,
Variables::IsStrictSupersetOf).</p>
<dl class="method">
<dt id="pydrake.symbolic.Variables.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.symbolic.Variables.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.symbolic.Variables) -&gt; None</li>
</ol>
<p>Default constructor.</p>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.symbolic.Variables, arg0: numpy.ndarray[object[m, 1]]) -&gt; None</li>
</ol>
<p>Constructs from an Eigen vector of variables.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Variables.empty">
<code class="descname">empty</code><span class="sig-paren">(</span><em>self: pydrake.symbolic.Variables</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.symbolic.Variables.empty" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks if this set is empty or not.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Variables.EqualTo">
<code class="descname">EqualTo</code><span class="sig-paren">(</span><em>self: pydrake.symbolic.Variables</em>, <em>arg0: pydrake.symbolic.Variables</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.symbolic.Variables.EqualTo" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Variables.erase">
<code class="descname">erase</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.symbolic.Variables.erase" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>erase(self: pydrake.symbolic.Variables, key: pydrake.symbolic.Variable) -&gt; int</li>
</ol>
<p>Erases <code class="docutils literal notranslate"><span class="pre">key</span></code> from a set. Return number of erased elements (0 or 1).</p>
<ol class="arabic simple" start="2">
<li>erase(self: pydrake.symbolic.Variables, vars: pydrake.symbolic.Variables) -&gt; int</li>
</ol>
<p>Erases variables in <code class="docutils literal notranslate"><span class="pre">vars</span></code> from a set. Return number of erased
elements ([0, vars.size()]).</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Variables.include">
<code class="descname">include</code><span class="sig-paren">(</span><em>self: pydrake.symbolic.Variables</em>, <em>key: pydrake.symbolic.Variable</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.symbolic.Variables.include" title="Permalink to this definition">¶</a></dt>
<dd><p>Return true if <code class="docutils literal notranslate"><span class="pre">key</span></code> is included in the Variables.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Variables.insert">
<code class="descname">insert</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.symbolic.Variables.insert" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>insert(self: pydrake.symbolic.Variables, var: pydrake.symbolic.Variable) -&gt; None</li>
</ol>
<p>Inserts a variable <code class="docutils literal notranslate"><span class="pre">var</span></code> into a set.</p>
<ol class="arabic simple" start="2">
<li>insert(self: pydrake.symbolic.Variables, vars: pydrake.symbolic.Variables) -&gt; None</li>
</ol>
<p>Inserts variables in <code class="docutils literal notranslate"><span class="pre">vars</span></code> into a set.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Variables.IsStrictSubsetOf">
<code class="descname">IsStrictSubsetOf</code><span class="sig-paren">(</span><em>self: pydrake.symbolic.Variables</em>, <em>vars: pydrake.symbolic.Variables</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.symbolic.Variables.IsStrictSubsetOf" title="Permalink to this definition">¶</a></dt>
<dd><p>Return true if <code class="docutils literal notranslate"><span class="pre">vars</span></code> is a strict subset of the Variables.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Variables.IsStrictSupersetOf">
<code class="descname">IsStrictSupersetOf</code><span class="sig-paren">(</span><em>self: pydrake.symbolic.Variables</em>, <em>vars: pydrake.symbolic.Variables</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.symbolic.Variables.IsStrictSupersetOf" title="Permalink to this definition">¶</a></dt>
<dd><p>Return true if <code class="docutils literal notranslate"><span class="pre">vars</span></code> is a strict superset of the Variables.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Variables.IsSubsetOf">
<code class="descname">IsSubsetOf</code><span class="sig-paren">(</span><em>self: pydrake.symbolic.Variables</em>, <em>vars: pydrake.symbolic.Variables</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.symbolic.Variables.IsSubsetOf" title="Permalink to this definition">¶</a></dt>
<dd><p>Return true if <code class="docutils literal notranslate"><span class="pre">vars</span></code> is a subset of the Variables.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Variables.IsSupersetOf">
<code class="descname">IsSupersetOf</code><span class="sig-paren">(</span><em>self: pydrake.symbolic.Variables</em>, <em>vars: pydrake.symbolic.Variables</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.symbolic.Variables.IsSupersetOf" title="Permalink to this definition">¶</a></dt>
<dd><p>Return true if <code class="docutils literal notranslate"><span class="pre">vars</span></code> is a superset of the Variables.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Variables.size">
<code class="descname">size</code><span class="sig-paren">(</span><em>self: pydrake.symbolic.Variables</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.symbolic.Variables.size" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of elements.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.symbolic.Variables.to_string">
<code class="descname">to_string</code><span class="sig-paren">(</span><em>self: pydrake.symbolic.Variables</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#pydrake.symbolic.Variables.to_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns string representation of Variables.</p>
</dd></dl>

</dd></dl>

</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="pydrake.systems.html" class="btn btn-neutral float-right" title="pydrake.systems" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="pydrake.solvers.snopt.html" class="btn btn-neutral float-left" title="pydrake.solvers.snopt" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>

    </p>
  </div>
</footer>
<script>
  /* Enables clicking for the mobile "hamburger" (three-line) menu item. */
  const siteHeader = document.querySelector('.site-header')
  const mobileButton = document.querySelector('.menu-mobile-toggle')
  const body = document.querySelector('body')

  mobileButton.addEventListener('click', function(event) {
    siteHeader.classList.toggle('open');
    body.classList.toggle('overflow-hidden');
  })
</script>
<footer class="site-footer padding">
  <div class="contain">
    <a href="/" class="drake-logo">
      <img src="/images/drake-logo.svg">
    </a>
    <div class="footer-menu">
      <ul>
        <li>
          <a href="/doxygen_cxx/index.html" class="site-menu-item">C++</a>
        </li>
        <li>
          <a href="/pydrake/index.html" class="site-menu-item">Python</a>
        </li>
        <li class="github-link">
          <a href="https://github.com/RobotLocomotion/drake" class="site-menu-item">GitHub <img src="/third_party/images/GitHub-Mark-64px.png"></a>
        </li>
      </ul>
    </div>
  </div>


</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>