<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>pydrake.systems.framework &mdash; pydrake  documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=86f27845" />
      <link rel="stylesheet" type="text/css" href="_static/css/custom.css?v=6b576c25" />

  
  
        <script src="_static/jquery.js?v=8dae8fb0"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="_static/documentation_options.js?v=7f41d439"></script>
        <script src="_static/doctools.js?v=888ff710"></script>
        <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="pydrake.systems.lcm" href="pydrake.systems.lcm.html" />
    <link rel="prev" title="pydrake.systems.estimators" href="pydrake.systems.estimators.html" /> 
</head>

<body class="wy-body-for-nav">
<header class="site-header">
  <div class="site-header-inner contain">
    <a class="drake-logo" href="/"><img src="/images/drake-logo-white.svg"></a>
    <div class="menu-mobile-toggle">
      <span></span>
    </div>
    <nav class="site-menu">
      <ul>
        <li class="site-menu-item site-menu-item-main">
          <a class="site-menu-item" href="/">Home</a>
        </li>
        <li class="site-menu-item site-menu-item-main">
          <a class="site-menu-item" href="/installation.html">Installation</a>
        </li>
        <li class="site-menu-item site-menu-item-main">
          <a class="site-menu-item" href="/gallery.html">Gallery</a>
        </li>
        <li class="site-menu-item site-menu-item-main">API Documentation
          <div class="sub">
            <a class="site-menu-item" href="/doxygen_cxx/index.html">C++</a> <a class="site-menu-item" href="/pydrake/index.html">Python</a>
          </div>
        </li>
        <li class="site-menu-item site-menu-item-main">Resources
          <div class="sub">
            <a class="site-menu-item" href="/getting_help.html">Getting Help</a> <a class="site-menu-item" href="https://deepnote.com/workspace/Drake-0b3b2c53-a7ad-441b-80f8-bf8350752305/project/Tutorials-2b4fc509-aef2-417d-a40d-6071dfed9199/%2Findex.ipynb">Tutorials</a> <a class="site-menu-item" href="/python_bindings.html">Python Bindings</a> <a class="site-menu-item" href="/developers.html">For Developers</a> <a class="site-menu-item" href="/credits.html">Credits</a>
          </div>
        </li>
        <li class="github-link">
          <a class="site-menu-item" href="https://github.com/RobotLocomotion/drake">GitHub <img src="/third_party/images/GitHub-Mark-Light-64px.png"></a>
        </li>
      </ul>
    </nav>
  </div>
</header>

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            pydrake
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search pydrake only…" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
  <form id="search_form" class="wy_form" action="https://google.com/search" method="get">
    <input type="text" name="q" placeholder="Search all of Drake…" />
    <input type="hidden" name="q" value="site:drake.mit.edu OR site:underactuated.csail.mit.edu OR site:manipulation.csail.mit.edu" />
  </form>
</div>

        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="pydrake.all.html">pydrake.all</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.autodiffutils.html">pydrake.autodiffutils</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.common.html">pydrake.common</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.examples.html">pydrake.examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.forwarddiff.html">pydrake.forwarddiff</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.geometry.html">pydrake.geometry</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.gym.html">pydrake.gym</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.lcm.html">pydrake.lcm</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.manipulation.html">pydrake.manipulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.math.html">pydrake.math</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.multibody.html">pydrake.multibody</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.perception.html">pydrake.perception</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.planning.html">pydrake.planning</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.polynomial.html">pydrake.polynomial</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.solvers.html">pydrake.solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.symbolic.html">pydrake.symbolic</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="pydrake.systems.html">pydrake.systems</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="pydrake.systems.all.html">pydrake.systems.all</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.systems.analysis.html">pydrake.systems.analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.systems.controllers.html">pydrake.systems.controllers</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.systems.drawing.html">pydrake.systems.drawing</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.systems.estimators.html">pydrake.systems.estimators</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">pydrake.systems.framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.systems.lcm.html">pydrake.systems.lcm</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.systems.perception.html">pydrake.systems.perception</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.systems.planar_scenegraph_visualizer.html">pydrake.systems.planar_scenegraph_visualizer</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.systems.primitives.html">pydrake.systems.primitives</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.systems.pyplot_visualizer.html">pydrake.systems.pyplot_visualizer</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.systems.rendering.html">pydrake.systems.rendering</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.systems.scalar_conversion.html">pydrake.systems.scalar_conversion</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.systems.sensors.html">pydrake.systems.sensors</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.trajectories.html">pydrake.trajectories</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.tutorials.html">pydrake.tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.visualization.html">pydrake.visualization</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">pydrake</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="pydrake.systems.html">pydrake.systems</a></li>
      <li class="breadcrumb-item active">pydrake.systems.framework</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="module-pydrake.systems.framework">
<span id="pydrake-systems-framework"></span><h1>pydrake.systems.framework<a class="headerlink" href="#module-pydrake.systems.framework" title="Link to this heading"></a></h1>
<p>Bindings for the core Systems framework.</p>
<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AbstractParameterIndex</span></span></dt>
<dd><dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AbstractParameterIndex.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.systems.framework.AbstractParameterIndex) -&gt; None</p></li>
</ol>
<p>Default constructor; the result is an <em>invalid</em> index. This only
exists to serve applications which require a default constructor.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.systems.framework.AbstractParameterIndex, arg0: int) -&gt; None</p></li>
</ol>
<p>Construction from a non-negative <code class="docutils literal notranslate"><span class="pre">int</span></code> value. The value must lie in
the range of [0, 2³¹). Constructor only promises to test validity in
Debug build.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AbstractParameterIndex.is_valid(self:</span> <span class="pre">pydrake.systems.framework.AbstractParameterIndex)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Reports if the index is valid–the only operation on an invalid index
that doesn’t throw an exception in Debug builds.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AbstractStateIndex</span></span></dt>
<dd><dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AbstractStateIndex.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.systems.framework.AbstractStateIndex) -&gt; None</p></li>
</ol>
<p>Default constructor; the result is an <em>invalid</em> index. This only
exists to serve applications which require a default constructor.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.systems.framework.AbstractStateIndex, arg0: int) -&gt; None</p></li>
</ol>
<p>Construction from a non-negative <code class="docutils literal notranslate"><span class="pre">int</span></code> value. The value must lie in
the range of [0, 2³¹). Constructor only promises to test validity in
Debug build.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AbstractStateIndex.is_valid(self:</span> <span class="pre">pydrake.systems.framework.AbstractStateIndex)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Reports if the index is valid–the only operation on an invalid index
that doesn’t throw an exception in Debug builds.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AbstractValues</span></span></dt>
<dd><p>AbstractValues is a container for non-numerical state and parameters.
It may or may not own the underlying data, and therefore is suitable
for both leaf Systems and diagrams.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AbstractValues.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.systems.framework.AbstractValues) -&gt; None</p></li>
</ol>
<p>Constructs an empty AbstractValues.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.systems.framework.AbstractValues, data: list[pydrake.common.value.AbstractValue]) -&gt; None</p></li>
</ol>
<p>Constructs an AbstractValues that does not own the underlying data.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AbstractValues.Clone(self:</span> <span class="pre">pydrake.systems.framework.AbstractValues)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.AbstractValues</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AbstractValues.get_mutable_value(self:</span> <span class="pre">pydrake.systems.framework.AbstractValues,</span> <span class="pre">index:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.common.value.AbstractValue</span></span></dt>
<dd><p>Returns the element of AbstractValues at the given <code class="docutils literal notranslate"><span class="pre">index</span></code>, or
aborts if the index is out-of-bounds.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AbstractValues.get_value(self:</span> <span class="pre">pydrake.systems.framework.AbstractValues,</span> <span class="pre">index:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.common.value.AbstractValue</span></span></dt>
<dd><p>Returns the element of AbstractValues at the given <code class="docutils literal notranslate"><span class="pre">index</span></code>, or
aborts if the index is out-of-bounds.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AbstractValues.SetFrom(self:</span> <span class="pre">pydrake.systems.framework.AbstractValues,</span> <span class="pre">arg0:</span> <span class="pre">pydrake.systems.framework.AbstractValues)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Copies all of the AbstractValues in <code class="docutils literal notranslate"><span class="pre">other</span></code> into this. Asserts if
the two are not equal in size.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if any</strong><strong> of </strong><strong>the elements are</strong><strong> of </strong><strong>incompatible type.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AbstractValues.size(self:</span> <span class="pre">pydrake.systems.framework.AbstractValues)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the number of elements of AbstractValues.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BasicVector</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.VectorBase</span></code></p>
<p>BasicVector is a semantics-free wrapper around an Eigen vector that
satisfies VectorBase. Once constructed, its size is fixed.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">BasicVector_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BasicVector.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.systems.framework.BasicVector, data: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</p></li>
</ol>
<p>Constructs a BasicVector with the specified <code class="docutils literal notranslate"><span class="pre">vec</span></code> data.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.systems.framework.BasicVector, size: int) -&gt; None</p></li>
</ol>
<p>Initializes with the given <code class="docutils literal notranslate"><span class="pre">size</span></code> using the drake::dummy_value&lt;T&gt;,
which is NaN when T = double.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BasicVector.Clone(self:</span> <span class="pre">pydrake.systems.framework.BasicVector)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.BasicVector</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BasicVector.get_mutable_value(self:</span> <span class="pre">pydrake.systems.framework.BasicVector)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1],</span> <span class="pre">flags.writeable]</span></span></dt>
<dd><p>Returns the entire vector as a mutable Eigen::VectorBlock, which
allows mutation of the values, but does not allow <code class="docutils literal notranslate"><span class="pre">resize()</span></code> to be
invoked on the returned object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BasicVector.get_value(self:</span> <span class="pre">pydrake.systems.framework.BasicVector)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>(Don’t use this in new code) Returns the entire vector as a const
Eigen::VectorBlock. Prefer <code class="docutils literal notranslate"><span class="pre">value()</span></code> which returns direct access to
the underlying VectorX rather than wrapping it in a VectorBlock.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BasicVector.set_value(self:</span> <span class="pre">pydrake.systems.framework.BasicVector,</span> <span class="pre">arg0:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the vector to the given value. After a.set_value(b.get_value()),
a must be identical to b.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if the new value has different dimensions.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BasicVector.value(self:</span> <span class="pre">pydrake.systems.framework.BasicVector)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns a const reference to the contained <code class="docutils literal notranslate"><span class="pre">VectorX&lt;T&gt;</span></code>. This is the
preferred method for examining a BasicVector’s value.</p>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BasicVector_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">BasicVector_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">BasicVector_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">BasicVector_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BasicVector_[AutoDiffXd]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.VectorBase_[AutoDiffXd]</span></code></p>
<p>BasicVector is a semantics-free wrapper around an Eigen vector that
satisfies VectorBase. Once constructed, its size is fixed.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BasicVector_[AutoDiffXd].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.systems.framework.BasicVector_[AutoDiffXd], data: numpy.ndarray[object[m, 1]]) -&gt; None</p></li>
</ol>
<p>Constructs a BasicVector with the specified <code class="docutils literal notranslate"><span class="pre">vec</span></code> data.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.systems.framework.BasicVector_[AutoDiffXd], size: int) -&gt; None</p></li>
</ol>
<p>Initializes with the given <code class="docutils literal notranslate"><span class="pre">size</span></code> using the drake::dummy_value&lt;T&gt;,
which is NaN when T = double.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BasicVector_[AutoDiffXd].Clone(self:</span> <span class="pre">pydrake.systems.framework.BasicVector_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.BasicVector_[AutoDiffXd]</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BasicVector_[AutoDiffXd].get_mutable_value(self:</span> <span class="pre">pydrake.systems.framework.BasicVector_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1],</span> <span class="pre">flags.writeable]</span></span></dt>
<dd><p>Returns the entire vector as a mutable Eigen::VectorBlock, which
allows mutation of the values, but does not allow <code class="docutils literal notranslate"><span class="pre">resize()</span></code> to be
invoked on the returned object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BasicVector_[AutoDiffXd].get_value(self:</span> <span class="pre">pydrake.systems.framework.BasicVector_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>(Don’t use this in new code) Returns the entire vector as a const
Eigen::VectorBlock. Prefer <code class="docutils literal notranslate"><span class="pre">value()</span></code> which returns direct access to
the underlying VectorX rather than wrapping it in a VectorBlock.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BasicVector_[AutoDiffXd].set_value(self:</span> <span class="pre">pydrake.systems.framework.BasicVector_[AutoDiffXd],</span> <span class="pre">arg0:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the vector to the given value. After a.set_value(b.get_value()),
a must be identical to b.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if the new value has different dimensions.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BasicVector_[AutoDiffXd].value(self:</span> <span class="pre">pydrake.systems.framework.BasicVector_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns a const reference to the contained <code class="docutils literal notranslate"><span class="pre">VectorX&lt;T&gt;</span></code>. This is the
preferred method for examining a BasicVector’s value.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BasicVector_[Expression]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.VectorBase_[Expression]</span></code></p>
<p>BasicVector is a semantics-free wrapper around an Eigen vector that
satisfies VectorBase. Once constructed, its size is fixed.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BasicVector_[Expression].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.systems.framework.BasicVector_[Expression], data: numpy.ndarray[object[m, 1]]) -&gt; None</p></li>
</ol>
<p>Constructs a BasicVector with the specified <code class="docutils literal notranslate"><span class="pre">vec</span></code> data.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.systems.framework.BasicVector_[Expression], size: int) -&gt; None</p></li>
</ol>
<p>Initializes with the given <code class="docutils literal notranslate"><span class="pre">size</span></code> using the drake::dummy_value&lt;T&gt;,
which is NaN when T = double.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BasicVector_[Expression].Clone(self:</span> <span class="pre">pydrake.systems.framework.BasicVector_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.BasicVector_[Expression]</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BasicVector_[Expression].get_mutable_value(self:</span> <span class="pre">pydrake.systems.framework.BasicVector_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1],</span> <span class="pre">flags.writeable]</span></span></dt>
<dd><p>Returns the entire vector as a mutable Eigen::VectorBlock, which
allows mutation of the values, but does not allow <code class="docutils literal notranslate"><span class="pre">resize()</span></code> to be
invoked on the returned object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BasicVector_[Expression].get_value(self:</span> <span class="pre">pydrake.systems.framework.BasicVector_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>(Don’t use this in new code) Returns the entire vector as a const
Eigen::VectorBlock. Prefer <code class="docutils literal notranslate"><span class="pre">value()</span></code> which returns direct access to
the underlying VectorX rather than wrapping it in a VectorBlock.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BasicVector_[Expression].set_value(self:</span> <span class="pre">pydrake.systems.framework.BasicVector_[Expression],</span> <span class="pre">arg0:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the vector to the given value. After a.set_value(b.get_value()),
a must be identical to b.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if the new value has different dimensions.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BasicVector_[Expression].value(self:</span> <span class="pre">pydrake.systems.framework.BasicVector_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns a const reference to the contained <code class="docutils literal notranslate"><span class="pre">VectorX&lt;T&gt;</span></code>. This is the
preferred method for examining a BasicVector’s value.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BusValue</span></span></dt>
<dd><p>BusValue is a value type used on input ports and output ports to group
labeled signals into a single port. Each signal is referred to by a
unique name and stored using an AbstractValue.</p>
<p>In some cases the signal names are used only for human-readable
logging or debugging, so can be anything. In other cases, the systems
using the signals will require the signals to use specific names per
some convention (e.g., for a BusSelector the signal names must match
the output port names).</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>BusCreator, BusSelector</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BusValue.__init__(self:</span> <span class="pre">pydrake.systems.framework.BusValue)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructs an empty BusValue.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BusValue.Clear(self:</span> <span class="pre">pydrake.systems.framework.BusValue)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Removes all signals from this. Invalidates all iterators.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BusValue.Find(self:</span> <span class="pre">pydrake.systems.framework.BusValue,</span> <span class="pre">name:</span> <span class="pre">str)</span> <span class="pre">-&gt;</span> <span class="pre">object</span></span></dt>
<dd><p>Gets one signal value. Returns nullptr if not found. Does not
invalidate any iterators, but the return value is invalidated by a
call to any non-const method on this.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BusValue.Set(self:</span> <span class="pre">pydrake.systems.framework.BusValue,</span> <span class="pre">name:</span> <span class="pre">str,</span> <span class="pre">value:</span> <span class="pre">pydrake.common.value.AbstractValue)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets one signal value. Invalidates all iterators. The <code class="docutils literal notranslate"><span class="pre">name</span></code> can be
any string without restriction, although we encourage valid UTF-8.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Within a group of BusValue objects that are expected to
inter-operate (i.e., to be copied or assigned to each other), the
type of the <code class="docutils literal notranslate"><span class="pre">value</span></code> for a given <code class="docutils literal notranslate"><span class="pre">name</span></code> is expected to be
consistent (i.e., homogenous) across the entire group of objects.
After setting a <code class="docutils literal notranslate"><span class="pre">name</span></code> to some value the first time, every
subsequent call to Set on the same BusValue object for that same
<code class="docutils literal notranslate"><span class="pre">name</span></code> must provide a value of the same type, even if the object
has since been cleared or copied onto another object. The only way
to reset the hysteresis for the “presumed type” of a name is to
construct a new BusValue object. Failure to keep the types
consistent may result in an exception at runtime. However, we
might relax this restriction in the future, so don’t count on it
for error handling.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CacheEntry</span></span></dt>
<dd><p>A CacheEntry belongs to a System and represents the properties of one
of that System’s cached computations. CacheEntry objects are assigned
CacheIndex values in the order they are declared; these are unique
within a single System and can be used for quick access to both the
CacheEntry and the corresponding CacheEntryValue in the System’s
Context.</p>
<p>CacheEntry objects are allocated automatically for known System
computations like output ports and time derivatives, and may also be
allocated by user code for other cached computations.</p>
<p>A cache entry’s value is always stored as an AbstractValue, which can
hold a concrete value of any copyable type. However, once a value has
been allocated using a particular concrete type, the type cannot be
changed.</p>
<p>CacheEntry objects support four important operations: - Allocate()
returns an object that can hold the cached value. - Calc()
unconditionally computes the cached value. - Eval() returns a
reference to the cached value, first updating with Calc() if it was
out of date. - GetKnownUpToDate() returns a reference to the current
value that you are certain must already be up to date.</p>
<p>The allocation and calculation functions must be provided at the time
a cache entry is declared. That is typically done in a System
constructor, in a manner very similar to the declaration of output
ports.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CacheEntry.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CacheEntry.cache_index(self:</span> <span class="pre">pydrake.systems.framework.CacheEntry)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.CacheIndex</span></span></dt>
<dd><p>Returns the CacheIndex used to locate this CacheEntry within the
containing System.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CacheEntry.description(self:</span> <span class="pre">pydrake.systems.framework.CacheEntry)</span> <span class="pre">-&gt;</span> <span class="pre">str</span></span></dt>
<dd><p>Return the human-readable description for this CacheEntry.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CacheEntry.disable_caching(self:</span> <span class="pre">pydrake.systems.framework.CacheEntry,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.ContextBase)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>(Debugging) Disables caching for this cache entry in the given
<code class="docutils literal notranslate"><span class="pre">context</span></code>. Eval() will recompute the cached value every time it is
invoked, regardless of the state of the out_of_date flag. That should
have no effect on any computed results, other than speed. See class
documentation for ideas as to what might be wrong if you see a change.
Note that the <code class="docutils literal notranslate"><span class="pre">context</span></code> is <code class="docutils literal notranslate"><span class="pre">const</span></code> here; cache entry values are
mutable.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CacheEntry.disable_caching_by_default(self:</span> <span class="pre">pydrake.systems.framework.CacheEntry)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>(Debugging) Marks this cache entry so that the corresponding
CacheEntryValue object in any allocated Context is created with its
<code class="docutils literal notranslate"><span class="pre">disabled</span></code> flag initially set. This can be useful for debugging when
you have observed a difference between cached and non-cached behavior
that can’t be diagnosed with the runtime disable_caching() method.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>disable_caching()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CacheEntry.enable_caching(self:</span> <span class="pre">pydrake.systems.framework.CacheEntry,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.ContextBase)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>(Debugging) Enables caching for this cache entry in the given
<code class="docutils literal notranslate"><span class="pre">context</span></code> if it was previously disabled.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CacheEntry.Eval(self:</span> <span class="pre">pydrake.systems.framework.CacheEntry,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.ContextBase)</span> <span class="pre">-&gt;</span> <span class="pre">object</span></span></dt>
<dd><p>Returns a reference to the up-to-date value of this cache entry
contained in the given Context. This is the preferred way to obtain a
cached value. If the value is not already up to date with respect to
its prerequisites, or if caching is disabled for this entry, then this
entry’s Calc() method is used first to update the value before the
reference is returned. The Calc() method may be arbitrarily expensive,
but this method is constant time and <em>very</em> fast if the value is
already up to date. If you are certain the value should be up to date
already, you may use the GetKnownUpToDate() method instead.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">context</span></code> is a subcontext that is compatible with the subsystem
that owns this cache entry.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if the value doesn't actually have type V.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CacheEntry.EvalAbstract(self:</span> <span class="pre">pydrake.systems.framework.CacheEntry,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.ContextBase)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.common.value.AbstractValue</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CacheEntry.get_cache_entry_value(self:</span> <span class="pre">pydrake.systems.framework.CacheEntry,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.ContextBase)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.CacheEntryValue</span></span></dt>
<dd><p>(Advanced) Returns a const reference to the CacheEntryValue object
that corresponds to this CacheEntry, from the supplied Context. The
returned object contains the current value and tracks whether it is up
to date with respect to its prerequisites. If you just need the value,
use the Eval() method rather than this one. This method is constant
time and <em>very</em> fast in all circumstances.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CacheEntry.get_mutable_cache_entry_value(self:</span> <span class="pre">pydrake.systems.framework.CacheEntry,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.ContextBase)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.CacheEntryValue</span></span></dt>
<dd><p>(Advanced) Returns a mutable reference to the CacheEntryValue object
that corresponds to this CacheEntry, from the supplied Context. Note
that <code class="docutils literal notranslate"><span class="pre">context</span></code> is const; cache values are mutable. Don’t call this
method unless you know what you’re doing. This method is constant time
and <em>very</em> fast in all circumstances.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CacheEntry.has_default_prerequisites(self:</span> <span class="pre">pydrake.systems.framework.CacheEntry)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>(Advanced) Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if this cache entry was created without
specifying any prerequisites. This can be useful in determining
whether the apparent dependencies should be believed, or whether they
may just be due to some user’s ignorance.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently we can’t distinguish between “no prerequisites given”
(in which case we default to <code class="docutils literal notranslate"><span class="pre">all_sources_ticket()</span></code>) and
“prerequisite specified as <code class="docutils literal notranslate"><span class="pre">all_sources_ticket()`&quot;.</span> <span class="pre">Either</span> <span class="pre">of</span>
<span class="pre">those</span> <span class="pre">cases</span> <span class="pre">makes</span> <span class="pre">this</span> <span class="pre">method</span> <span class="pre">return</span> <span class="pre">`true</span></code> now, but we intend to
change so that <em>explicit</em> specification of
<code class="docutils literal notranslate"><span class="pre">all_sources_ticket()</span></code> will be considered non-default. So don’t
depend on the current behavior.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CacheEntry.is_cache_entry_disabled(self:</span> <span class="pre">pydrake.systems.framework.CacheEntry,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.ContextBase)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>(Debugging) Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if caching has been disabled for this
cache entry in the given <code class="docutils literal notranslate"><span class="pre">context</span></code>. That means Eval() will
recalculate even if the entry is marked up to date.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CacheEntry.is_disabled_by_default(self:</span> <span class="pre">pydrake.systems.framework.CacheEntry)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>(Debugging) Returns the current value of this flag. It is <code class="docutils literal notranslate"><span class="pre">False</span></code>
unless a call to <code class="docutils literal notranslate"><span class="pre">disable_caching_by_default()</span></code> has previously been
made.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CacheEntry.is_out_of_date(self:</span> <span class="pre">pydrake.systems.framework.CacheEntry,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.ContextBase)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if the current value of this cache entry is out of
date with respect to its prerequisites. If this returns <code class="docutils literal notranslate"><span class="pre">False</span></code> then
the Eval() method will not perform any computation when invoked,
unless caching has been disabled for this entry. If this returns
<code class="docutils literal notranslate"><span class="pre">True</span></code> the GetKnownUpToDate() methods will fail if invoked.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CacheEntry.prerequisites(self:</span> <span class="pre">pydrake.systems.framework.CacheEntry)</span> <span class="pre">-&gt;</span> <span class="pre">set[pydrake.systems.framework.DependencyTicket]</span></span></dt>
<dd><p>Returns a reference to the set of prerequisites needed by this cache
entry’s Calc() function. These are all within the same subsystem that
owns this CacheEntry.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CacheEntry.ticket(self:</span> <span class="pre">pydrake.systems.framework.CacheEntry)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.DependencyTicket</span></span></dt>
<dd><p>Returns the DependencyTicket used to register dependencies on the
value of this CacheEntry. This can also be used to locate the
DependencyTracker that manages dependencies at runtime for the
associated CacheEntryValue in a Context.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CacheEntryValue</span></span></dt>
<dd><p>(Advanced) This is the representation in the Context for the value of
one of a System’s CacheEntry objects. Most users will not use this
class directly – System and CacheEntry provide the most common APIs,
and Context provides additional useful methods.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>System, CacheEntry, Context for user-facing APIs.</p>
</div>
<p>A CacheEntryValue consists of a single type-erased value, a serial
number, an <code class="docutils literal notranslate"><span class="pre">out_of_date</span></code> flag, and a DependencyTracker ticket.
Details: - “Out of date” means that some prerequisite of this cache
entry’s computation has been changed in the current Context since the
stored value was last computed, and thus must be recomputed prior to
use. On the other hand, if the entry is <em>not</em> out of date, then it is
“up to date” meaning that if you were to recompute it using the
current Context values you would get the identical result (so don’t
bother!). - The “serial number” is an integer that is incremented
whenever the value is modified, or made available for mutable access.
You can use it to recognize that you are looking at the same value as
you saw at some earlier time. It is also useful for performance
studies since it is a count of how many times this value was
recomputed. Note that marking the value “out of date” is <em>not</em> a
modification; that does not change the serial number. The serial
number is maintained internally and cannot be user-modified. - The
DependencyTicket (“ticket”) stored here identifies the
DependencyTracker (“tracker”) associated with this cache entry. The
tracker maintains lists of all upstream prerequisites and downstream
dependents of the value stored here, and also has a pointer to this
CacheEntryValue that it uses for invalidation. Upstream modifications
cause the tracker to set the <code class="docutils literal notranslate"><span class="pre">out_of_date</span></code> flag here, and mark all
downstream dependents out of date also. The tracker lives in the same
subcontext that owns the Cache that owns this CacheEntryValue.</p>
<p>We sometimes use the terms “invalid” and “invalidate” as synonyms for
“out of date” and “mark out of date”.</p>
<p>For debugging purposes, caching may be disabled for an entire Context
or for particular cache entry values. This is independent of the
<code class="docutils literal notranslate"><span class="pre">out_of_date</span></code> flag described above, which is still expected to be
operational when caching is disabled. However, when caching is
disabled the Eval() methods will recompute the contained value even if
it is not marked out of date. That should have no effect other than to
slow computation; if results change, something is wrong. There could
be a problem with the specification of dependencies, a bug in user
code such as improper retention of a stale reference, or a bug in the
caching system.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CacheEntryValue.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CacheEntryValue.GetMutableValueOrThrow(self:</span> <span class="pre">pydrake.systems.framework.CacheEntryValue)</span> <span class="pre">-&gt;</span> <span class="pre">object</span></span></dt>
<dd><p>(Advanced) Convenience method that returns a mutable reference to the
contained value downcast to its known concrete type. Throws an
exception if the contained value does not have the indicated concrete
type. Note that you must call mark_up_to_date() after modifying the
value through the returned reference. See
GetMutableAbstractValueOrThrow() above for more information.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if there is no value</strong><strong>, or </strong><strong>if the value is already up</strong> – </p></li>
<li><p><strong>to date</strong><strong>, of </strong><strong>it doesn't actually have type V.</strong> – </p></li>
<li><p><strong>RuntimeError if the cache is frozen.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>SetValueOrThrow(), set_value(), mark_up_to_date()</p>
</div>
<dl class="simple">
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">V</span></code>:</dt><dd><p>The known actual value type.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CacheEntryValue.GetValueOrThrow(self:</span> <span class="pre">pydrake.systems.framework.CacheEntryValue)</span> <span class="pre">-&gt;</span> <span class="pre">object</span></span></dt>
<dd><p>Returns a const reference to the contained value of known type V. It
is an error to call this if there is no stored value, or the value is
out of date, or the value doesn’t actually have type V.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if there is no stored value</strong><strong>, or </strong><strong>if it is out</strong><strong> of </strong><strong>date</strong><strong>,</strong> – </p></li>
<li><p><strong>or it doesn't actually have type V.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>get_value()</p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CacheIndex</span></span></dt>
<dd><dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CacheIndex.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.systems.framework.CacheIndex) -&gt; None</p></li>
</ol>
<p>Default constructor; the result is an <em>invalid</em> index. This only
exists to serve applications which require a default constructor.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.systems.framework.CacheIndex, arg0: int) -&gt; None</p></li>
</ol>
<p>Construction from a non-negative <code class="docutils literal notranslate"><span class="pre">int</span></code> value. The value must lie in
the range of [0, 2³¹). Constructor only promises to test validity in
Debug build.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CacheIndex.is_valid(self:</span> <span class="pre">pydrake.systems.framework.CacheIndex)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Reports if the index is valid–the only operation on an invalid index
that doesn’t throw an exception in Debug builds.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.ContextBase</span></code></p>
<p>Context is an abstract class template that represents all the typed
values that are used in a System’s computations: time, numeric-valued
input ports, numerical state, and numerical parameters. There are also
type-erased abstract state variables, abstract-valued input ports,
abstract parameters, and a double accuracy setting. The framework
provides two concrete subclasses of Context: LeafContext (for leaf
Systems) and DiagramContext (for composite System Diagrams). Users are
forbidden to extend DiagramContext and are discouraged from
subclassing LeafContext.</p>
<p>A Context is designed to be used only with the System that created it.
Data encapsulated with State and Parameter objects can be copied
between contexts for compatible systems with some restrictions. For
details, see system_compatibility.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">Context_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context.Clone(self:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.Context</span></span></dt>
<dd><p>Returns a deep copy of this Context.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if this is not the root context.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context.get_abstract_parameter(self:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">index:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.common.value.AbstractValue</span></span></dt>
<dd><p>Returns a const reference to the vector-valued parameter at <code class="docutils literal notranslate"><span class="pre">index</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">index</span></code> must identify an existing parameter.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context.get_abstract_state(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>get_abstract_state(self: pydrake.systems.framework.Context) -&gt; pydrake.systems.framework.AbstractValues</p></li>
</ol>
<p>Returns a const reference to the abstract component of the state,
which may be of size zero.</p>
<ol class="arabic simple" start="2">
<li><p>get_abstract_state(self: pydrake.systems.framework.Context, index: int) -&gt; pydrake.common.value.AbstractValue</p></li>
</ol>
<p>Returns a const reference to the abstract component of the state at
<code class="docutils literal notranslate"><span class="pre">index</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">index</span></code> must identify an existing element.</p>
</dd>
<dt>Precondition:</dt><dd><p>the abstract state’s type must match the template argument.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context.get_accuracy(self:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">Optional[float]</span></span></dt>
<dd><p>Returns the accuracy setting (if any). Note that the return type is
<code class="docutils literal notranslate"><span class="pre">optional&lt;double&gt;</span></code> rather than the double value itself.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>SetAccuracy() for details.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context.get_continuous_state(self:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.ContinuousState</span></span></dt>
<dd><p>Returns a const reference to the continuous component of the state,
which may be of size zero.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context.get_continuous_state_vector(self:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.VectorBase</span></span></dt>
<dd><p>Returns a reference to the continuous state vector, devoid of
second-order structure. The vector may be of size zero.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context.get_discrete_state(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>get_discrete_state(self: pydrake.systems.framework.Context) -&gt; pydrake.systems.framework.DiscreteValues</p></li>
</ol>
<p>Returns a reference to the entire discrete state, which may consist of
multiple discrete state vectors (groups).</p>
<ol class="arabic simple" start="2">
<li><p>get_discrete_state(self: pydrake.systems.framework.Context, arg0: int) -&gt; pydrake.systems.framework.BasicVector</p></li>
</ol>
<p>Returns a const reference to group (vector) <code class="docutils literal notranslate"><span class="pre">index</span></code> of the discrete
state.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">index</span></code> must identify an existing group.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context.get_discrete_state_vector(self:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.BasicVector</span></span></dt>
<dd><p>Returns a reference to the <em>only</em> discrete state vector. The vector
may be of size zero.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>There is only one discrete state group.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context.get_mutable_abstract_parameter(self:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">index:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.common.value.AbstractValue</span></span></dt>
<dd><p>Returns a mutable reference to element <code class="docutils literal notranslate"><span class="pre">index</span></code> of the
abstract-valued parameters. Sends out of date notifications for all
computations dependent on this parameter.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">index</span></code> must identify an existing abstract parameter.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently notifies dependents of <em>all</em> abstract parameters.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context.get_mutable_abstract_state(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>get_mutable_abstract_state(self: pydrake.systems.framework.Context) -&gt; pydrake.systems.framework.AbstractValues</p></li>
</ol>
<p>Returns a mutable reference to the abstract component of the state,
which may be of size zero. Sends out of date notifications for all
abstract-state-dependent computations.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>You <em>must not</em> use the returned reference to modify the size,
number, or types of abstract state variables.</p>
</div>
<ol class="arabic simple" start="2">
<li><p>get_mutable_abstract_state(self: pydrake.systems.framework.Context, index: int) -&gt; pydrake.common.value.AbstractValue</p></li>
</ol>
<p>Returns a mutable reference to element <code class="docutils literal notranslate"><span class="pre">index</span></code> of the abstract
state. Sends out of date notifications for all computations that
depend on this abstract state variable.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">index</span></code> must identify an existing element.</p>
</dd>
<dt>Precondition:</dt><dd><p>the abstract state’s type must match the template argument.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently notifies dependents of <em>any</em> abstract state variable.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context.get_mutable_continuous_state(self:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.ContinuousState</span></span></dt>
<dd><p>Returns a mutable reference to the continuous component of the state,
which may be of size zero. Sends out of date notifications for all
continuous-state-dependent computations.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context.get_mutable_continuous_state_vector(self:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.VectorBase</span></span></dt>
<dd><p>Returns a mutable reference to the continuous state vector, devoid of
second-order structure. The vector may be of size zero. Sends out of
date notifications for all continuous-state-dependent computations.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context.get_mutable_discrete_state(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>get_mutable_discrete_state(self: pydrake.systems.framework.Context) -&gt; pydrake.systems.framework.DiscreteValues</p></li>
</ol>
<p>Returns a mutable reference to the discrete component of the state,
which may be of size zero. Sends out of date notifications for all
discrete-state-dependent computations.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>You <em>must not</em> use the returned reference to modify the size or
number of discrete state variables.</p>
</div>
<ol class="arabic simple" start="2">
<li><p>get_mutable_discrete_state(self: pydrake.systems.framework.Context, arg0: int) -&gt; pydrake.systems.framework.BasicVector</p></li>
</ol>
<p>Returns a mutable reference to group (vector) <code class="docutils literal notranslate"><span class="pre">index</span></code> of the
discrete state. Sends out of date notifications for all computations
that depend on this discrete state group.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">index</span></code> must identify an existing group.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently notifies dependents of <em>all</em> groups.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context.get_mutable_discrete_state_vector(self:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.BasicVector</span></span></dt>
<dd><p>Returns a mutable reference to the <em>only</em> discrete state vector. Sends
out of date notifications for all discrete-state-dependent
computations.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>get_discrete_state_vector().</p>
</div>
<dl class="simple">
<dt>Precondition:</dt><dd><p>There is only one discrete state group.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context.get_mutable_numeric_parameter(self:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">index:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.BasicVector</span></span></dt>
<dd><p>Returns a mutable reference to element <code class="docutils literal notranslate"><span class="pre">index</span></code> of the vector-valued
(numeric) parameters. Sends out of date notifications for all
computations dependent on this parameter.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">index</span></code> must identify an existing numeric parameter.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently notifies dependents of <em>all</em> numeric parameters.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context.get_mutable_parameters(self:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.Parameters</span></span></dt>
<dd><p>Returns a mutable reference to this Context’s parameters. Sends out of
date notifications for all parameter-dependent computations. If you
don’t mean to change all the parameters, use the indexed methods to
modify only some of the parameters so that fewer computations are
invalidated and fewer notifications need be sent.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>You <em>must not</em> use the returned reference to modify the size,
number, or types of parameters.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context.get_mutable_state(self:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.State</span></span></dt>
<dd><p>Returns a mutable reference to the whole State, potentially
invalidating <em>all</em> state-dependent computations so requiring out of
date notifications to be made for all such computations. If you don’t
mean to change the whole state, use more focused methods to modify
only a portion of the state. See class documentation for more
information.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>You <em>must not</em> use the returned reference to modify the size,
number, or types of state variables.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context.get_numeric_parameter(self:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">index:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.BasicVector</span></span></dt>
<dd><p>Returns a const reference to the vector-valued parameter at <code class="docutils literal notranslate"><span class="pre">index</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">index</span></code> must identify an existing parameter.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context.get_parameters(self:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.Parameters</span></span></dt>
<dd><p>Returns a const reference to this Context’s parameters.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context.get_state(self:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.State</span></span></dt>
<dd><p>Returns a const reference to the whole State.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context.get_time(self:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns the current time in seconds.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>SetTime()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context.has_only_continuous_state(self:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns true if the Context has continuous state, but no discrete or
abstract state.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context.has_only_discrete_state(self:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns true if the Context has discrete state, but no continuous or
abstract state.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context.is_stateless(self:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns true if the Context has no state.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context.num_abstract_parameters(self:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the number of abstract-valued parameters.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context.num_abstract_states(self:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the number of elements in the abstract state.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context.num_continuous_states(self:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the number of continuous state variables <code class="docutils literal notranslate"><span class="pre">xc</span> <span class="pre">=</span> <span class="pre">{q,</span> <span class="pre">v,</span> <span class="pre">z}</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context.num_discrete_state_groups(self:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the number of vectors (groups) in the discrete state.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context.num_numeric_parameter_groups(self:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the number of vector-valued parameters.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context.num_total_states(self:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the total dimension of all of the basic vector states (as if
they were muxed).</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if the system contains any abstract state.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context.SetAbstractState(self:</span> <span class="pre">object,</span> <span class="pre">index:</span> <span class="pre">int,</span> <span class="pre">value:</span> <span class="pre">object)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the value of the abstract state variable selected by <code class="docutils literal notranslate"><span class="pre">index</span></code>.
Sends out of date notifications for all computations that depend on
that abstract state variable. The template type will be inferred and
need not be specified explicitly.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">index</span></code> must identify an existing abstract state variable.</p>
</dd>
<dt>Precondition:</dt><dd><p>the abstract state’s type must match the template argument.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently notifies dependents of <em>any</em> abstract state variable.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context.SetAccuracy(self:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">accuracy:</span> <span class="pre">Optional[float])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Records the user’s requested accuracy, which is a unit-less quantity
designed for use with simulation and other numerical studies. Since
accuracy is unit-less, algorithms and systems are free to interpret
this quantity as they wish. The intention is that more computational
work is acceptable as the accuracy setting is tightened (set closer to
zero). If no accuracy is requested, computations are free to choose
suitable defaults, or to refuse to proceed without an explicit
accuracy setting. The accuracy of a complete simulation or other
numerical study depends on the accuracy of <em>all</em> contributing
computations, so it is important that each computation is done in
accordance with the requested accuracy. Some examples of where this is
needed: - Error-controlled numerical integrators use the accuracy
setting to decide what step sizes to take. - The Simulator employs a
numerical integrator, but also uses accuracy to decide how precisely
to isolate witness function zero crossings. - Iterative calculations
reported as results or cached internally depend on accuracy to decide
how strictly to converge the results. Examples of these are:
constraint projection, calculation of distances between smooth shapes,
and deformation calculations for soft contact.</p>
<p>The common thread among these examples is that they all share the same
Context, so by keeping accuracy here it can be used effectively to
control all accuracy-dependent computations.</p>
<p>Any accuracy-dependent computation in this Context and its subcontexts
may be invalidated by a change to the accuracy setting, so out of date
notifications are sent to all such computations (at least if the
accuracy setting has actually changed). Accuracy must have the same
value in every subcontext within the same context tree so may only be
modified at the root context of a tree.</p>
<p>Requested accuracy is stored in the Context for two reasons: - It
permits all computations performed over a System to see the <em>same</em>
accuracy request since accuracy is stored in one shared place, and -
it allows us to notify accuracy-dependent cached results that they are
out of date when the accuracy setting changes.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if this is not the root context.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context.SetContinuousState(self:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">arg0:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the continuous state to <code class="docutils literal notranslate"><span class="pre">xc</span></code>, including q, v, and z partitions.
The supplied vector must be the same size as the existing continuous
state. Sends out of date notifications for all
continuous-state-dependent computations.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context.SetDiscreteState(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>SetDiscreteState(self: pydrake.systems.framework.Context, xd: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</p></li>
</ol>
<p>Sets the discrete state to <code class="docutils literal notranslate"><span class="pre">xd</span></code>, assuming there is just one discrete
state group. The supplied vector must be the same size as the existing
discrete state. Sends out of date notifications for all
discrete-state-dependent computations. Use the other signature for
this method if you have multiple discrete state groups.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>There is exactly one discrete state group.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>SetDiscreteState(self: pydrake.systems.framework.Context, group_index: int, xd: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</p></li>
</ol>
<p>Sets the discrete state group indicated by <code class="docutils literal notranslate"><span class="pre">group_index</span></code> to <code class="docutils literal notranslate"><span class="pre">xd</span></code>.
The supplied vector <code class="docutils literal notranslate"><span class="pre">xd</span></code> must be the same size as the existing
discrete state group. Sends out of date notifications for all
computations that depend on this discrete state group.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">group_index</span></code> identifies an existing group.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently notifies dependents of <em>all</em> groups.</p>
</div>
<ol class="arabic simple" start="3">
<li><p>SetDiscreteState(self: pydrake.systems.framework.Context, xd: pydrake.systems.framework.DiscreteValues) -&gt; None</p></li>
</ol>
<p>Sets all the discrete state variables in this Context from a
compatible DiscreteValues object.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError unless the number</strong><strong> of </strong><strong>groups and size</strong><strong> of </strong><strong>each group of</strong> – </p></li>
<li><p><strong>xd` matches those in this Context</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context.SetStateAndParametersFrom(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>SetStateAndParametersFrom(self: pydrake.systems.framework.Context, source: pydrake.systems.framework.Context) -&gt; None</p></li>
</ol>
<p>Copies all state and parameters in <code class="docutils literal notranslate"><span class="pre">source</span></code>, where numerical values
are of type <code class="docutils literal notranslate"><span class="pre">U</span></code>, to <code class="docutils literal notranslate"><span class="pre">this</span></code> context. Time and accuracy are
unchanged in <code class="docutils literal notranslate"><span class="pre">this</span></code> context, which means that this method can be
called on a subcontext. Sends out of date notifications for all
dependent computations in <code class="docutils literal notranslate"><span class="pre">this</span></code> context.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently does not copy fixed input port values from <code class="docutils literal notranslate"><span class="pre">source</span></code>.
See System::FixInputPortsFrom() if you want to copy those.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>SetTimeStateAndParametersFrom() if you want to copy time and
accuracy along with state and parameters to a root context.</p>
</div>
<ol class="arabic simple" start="2">
<li><p>SetStateAndParametersFrom(self: pydrake.systems.framework.Context, source: pydrake.systems.framework.Context_[AutoDiffXd]) -&gt; None</p></li>
</ol>
<p>Copies all state and parameters in <code class="docutils literal notranslate"><span class="pre">source</span></code>, where numerical values
are of type <code class="docutils literal notranslate"><span class="pre">U</span></code>, to <code class="docutils literal notranslate"><span class="pre">this</span></code> context. Time and accuracy are
unchanged in <code class="docutils literal notranslate"><span class="pre">this</span></code> context, which means that this method can be
called on a subcontext. Sends out of date notifications for all
dependent computations in <code class="docutils literal notranslate"><span class="pre">this</span></code> context.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently does not copy fixed input port values from <code class="docutils literal notranslate"><span class="pre">source</span></code>.
See System::FixInputPortsFrom() if you want to copy those.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>SetTimeStateAndParametersFrom() if you want to copy time and
accuracy along with state and parameters to a root context.</p>
</div>
<ol class="arabic simple" start="3">
<li><p>SetStateAndParametersFrom(self: pydrake.systems.framework.Context, source: pydrake.systems.framework.Context_[Expression]) -&gt; None</p></li>
</ol>
<p>Copies all state and parameters in <code class="docutils literal notranslate"><span class="pre">source</span></code>, where numerical values
are of type <code class="docutils literal notranslate"><span class="pre">U</span></code>, to <code class="docutils literal notranslate"><span class="pre">this</span></code> context. Time and accuracy are
unchanged in <code class="docutils literal notranslate"><span class="pre">this</span></code> context, which means that this method can be
called on a subcontext. Sends out of date notifications for all
dependent computations in <code class="docutils literal notranslate"><span class="pre">this</span></code> context.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently does not copy fixed input port values from <code class="docutils literal notranslate"><span class="pre">source</span></code>.
See System::FixInputPortsFrom() if you want to copy those.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>SetTimeStateAndParametersFrom() if you want to copy time and
accuracy along with state and parameters to a root context.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context.SetTime(self:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">time_sec:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the current time in seconds. Sends out of date notifications for
all time-dependent computations (at least if the time has actually
changed). Time must have the same value in every subcontext within the
same Diagram context tree so may only be modified at the root context
of the tree.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if this is not the root context.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context.SetTimeAndContinuousState(self:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">arg0:</span> <span class="pre">float,</span> <span class="pre">arg1:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets time to <code class="docutils literal notranslate"><span class="pre">time_sec</span></code> and continuous state to <code class="docutils literal notranslate"><span class="pre">xc</span></code>. Performs a
single notification sweep to avoid duplicate notifications for
computations that depend on both time and state.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if this is not the root context.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context.SetTimeStateAndParametersFrom(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>SetTimeStateAndParametersFrom(self: pydrake.systems.framework.Context, source: pydrake.systems.framework.Context) -&gt; None</p></li>
</ol>
<p>Copies time, accuracy, all state and all parameters in <code class="docutils literal notranslate"><span class="pre">source</span></code>,
where numerical values are of type <code class="docutils literal notranslate"><span class="pre">U</span></code>, to <code class="docutils literal notranslate"><span class="pre">this</span></code> context. This
method can only be called on root contexts because time and accuracy
are copied. Sends out of date notifications for all dependent
computations in this context.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if this is not the root context.</strong> – </p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently does not copy fixed input port values from <code class="docutils literal notranslate"><span class="pre">source</span></code>.
See System::FixInputPortsFrom() if you want to copy those.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>SetStateAndParametersFrom() if you want to copy state and
parameters to a non-root context.</p>
</div>
<ol class="arabic simple" start="2">
<li><p>SetTimeStateAndParametersFrom(self: pydrake.systems.framework.Context, source: pydrake.systems.framework.Context_[AutoDiffXd]) -&gt; None</p></li>
</ol>
<p>Copies time, accuracy, all state and all parameters in <code class="docutils literal notranslate"><span class="pre">source</span></code>,
where numerical values are of type <code class="docutils literal notranslate"><span class="pre">U</span></code>, to <code class="docutils literal notranslate"><span class="pre">this</span></code> context. This
method can only be called on root contexts because time and accuracy
are copied. Sends out of date notifications for all dependent
computations in this context.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if this is not the root context.</strong> – </p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently does not copy fixed input port values from <code class="docutils literal notranslate"><span class="pre">source</span></code>.
See System::FixInputPortsFrom() if you want to copy those.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>SetStateAndParametersFrom() if you want to copy state and
parameters to a non-root context.</p>
</div>
<ol class="arabic simple" start="3">
<li><p>SetTimeStateAndParametersFrom(self: pydrake.systems.framework.Context, source: pydrake.systems.framework.Context_[Expression]) -&gt; None</p></li>
</ol>
<p>Copies time, accuracy, all state and all parameters in <code class="docutils literal notranslate"><span class="pre">source</span></code>,
where numerical values are of type <code class="docutils literal notranslate"><span class="pre">U</span></code>, to <code class="docutils literal notranslate"><span class="pre">this</span></code> context. This
method can only be called on root contexts because time and accuracy
are copied. Sends out of date notifications for all dependent
computations in this context.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if this is not the root context.</strong> – </p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently does not copy fixed input port values from <code class="docutils literal notranslate"><span class="pre">source</span></code>.
See System::FixInputPortsFrom() if you want to copy those.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>SetStateAndParametersFrom() if you want to copy state and
parameters to a non-root context.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">Context_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Context_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Context_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context_[AutoDiffXd]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.ContextBase</span></code></p>
<p>Context is an abstract class template that represents all the typed
values that are used in a System’s computations: time, numeric-valued
input ports, numerical state, and numerical parameters. There are also
type-erased abstract state variables, abstract-valued input ports,
abstract parameters, and a double accuracy setting. The framework
provides two concrete subclasses of Context: LeafContext (for leaf
Systems) and DiagramContext (for composite System Diagrams). Users are
forbidden to extend DiagramContext and are discouraged from
subclassing LeafContext.</p>
<p>A Context is designed to be used only with the System that created it.
Data encapsulated with State and Parameter objects can be copied
between contexts for compatible systems with some restrictions. For
details, see system_compatibility.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context_[AutoDiffXd].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context_[AutoDiffXd].Clone(self:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd]</span></span></dt>
<dd><p>Returns a deep copy of this Context.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if this is not the root context.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context_[AutoDiffXd].get_abstract_parameter(self:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd],</span> <span class="pre">index:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.common.value.AbstractValue</span></span></dt>
<dd><p>Returns a const reference to the vector-valued parameter at <code class="docutils literal notranslate"><span class="pre">index</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">index</span></code> must identify an existing parameter.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context_[AutoDiffXd].get_abstract_state(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>get_abstract_state(self: pydrake.systems.framework.Context_[AutoDiffXd]) -&gt; pydrake.systems.framework.AbstractValues</p></li>
</ol>
<p>Returns a const reference to the abstract component of the state,
which may be of size zero.</p>
<ol class="arabic simple" start="2">
<li><p>get_abstract_state(self: pydrake.systems.framework.Context_[AutoDiffXd], index: int) -&gt; pydrake.common.value.AbstractValue</p></li>
</ol>
<p>Returns a const reference to the abstract component of the state at
<code class="docutils literal notranslate"><span class="pre">index</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">index</span></code> must identify an existing element.</p>
</dd>
<dt>Precondition:</dt><dd><p>the abstract state’s type must match the template argument.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context_[AutoDiffXd].get_accuracy(self:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">Optional[float]</span></span></dt>
<dd><p>Returns the accuracy setting (if any). Note that the return type is
<code class="docutils literal notranslate"><span class="pre">optional&lt;double&gt;</span></code> rather than the double value itself.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>SetAccuracy() for details.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context_[AutoDiffXd].get_continuous_state(self:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.ContinuousState_[AutoDiffXd]</span></span></dt>
<dd><p>Returns a const reference to the continuous component of the state,
which may be of size zero.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context_[AutoDiffXd].get_continuous_state_vector(self:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.VectorBase_[AutoDiffXd]</span></span></dt>
<dd><p>Returns a reference to the continuous state vector, devoid of
second-order structure. The vector may be of size zero.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context_[AutoDiffXd].get_discrete_state(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>get_discrete_state(self: pydrake.systems.framework.Context_[AutoDiffXd]) -&gt; pydrake.systems.framework.DiscreteValues_[AutoDiffXd]</p></li>
</ol>
<p>Returns a reference to the entire discrete state, which may consist of
multiple discrete state vectors (groups).</p>
<ol class="arabic simple" start="2">
<li><p>get_discrete_state(self: pydrake.systems.framework.Context_[AutoDiffXd], arg0: int) -&gt; pydrake.systems.framework.BasicVector_[AutoDiffXd]</p></li>
</ol>
<p>Returns a const reference to group (vector) <code class="docutils literal notranslate"><span class="pre">index</span></code> of the discrete
state.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">index</span></code> must identify an existing group.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context_[AutoDiffXd].get_discrete_state_vector(self:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.BasicVector_[AutoDiffXd]</span></span></dt>
<dd><p>Returns a reference to the <em>only</em> discrete state vector. The vector
may be of size zero.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>There is only one discrete state group.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context_[AutoDiffXd].get_mutable_abstract_parameter(self:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd],</span> <span class="pre">index:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.common.value.AbstractValue</span></span></dt>
<dd><p>Returns a mutable reference to element <code class="docutils literal notranslate"><span class="pre">index</span></code> of the
abstract-valued parameters. Sends out of date notifications for all
computations dependent on this parameter.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">index</span></code> must identify an existing abstract parameter.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently notifies dependents of <em>all</em> abstract parameters.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context_[AutoDiffXd].get_mutable_abstract_state(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>get_mutable_abstract_state(self: pydrake.systems.framework.Context_[AutoDiffXd]) -&gt; pydrake.systems.framework.AbstractValues</p></li>
</ol>
<p>Returns a mutable reference to the abstract component of the state,
which may be of size zero. Sends out of date notifications for all
abstract-state-dependent computations.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>You <em>must not</em> use the returned reference to modify the size,
number, or types of abstract state variables.</p>
</div>
<ol class="arabic simple" start="2">
<li><p>get_mutable_abstract_state(self: pydrake.systems.framework.Context_[AutoDiffXd], index: int) -&gt; pydrake.common.value.AbstractValue</p></li>
</ol>
<p>Returns a mutable reference to element <code class="docutils literal notranslate"><span class="pre">index</span></code> of the abstract
state. Sends out of date notifications for all computations that
depend on this abstract state variable.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">index</span></code> must identify an existing element.</p>
</dd>
<dt>Precondition:</dt><dd><p>the abstract state’s type must match the template argument.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently notifies dependents of <em>any</em> abstract state variable.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context_[AutoDiffXd].get_mutable_continuous_state(self:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.ContinuousState_[AutoDiffXd]</span></span></dt>
<dd><p>Returns a mutable reference to the continuous component of the state,
which may be of size zero. Sends out of date notifications for all
continuous-state-dependent computations.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context_[AutoDiffXd].get_mutable_continuous_state_vector(self:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.VectorBase_[AutoDiffXd]</span></span></dt>
<dd><p>Returns a mutable reference to the continuous state vector, devoid of
second-order structure. The vector may be of size zero. Sends out of
date notifications for all continuous-state-dependent computations.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context_[AutoDiffXd].get_mutable_discrete_state(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>get_mutable_discrete_state(self: pydrake.systems.framework.Context_[AutoDiffXd]) -&gt; pydrake.systems.framework.DiscreteValues_[AutoDiffXd]</p></li>
</ol>
<p>Returns a mutable reference to the discrete component of the state,
which may be of size zero. Sends out of date notifications for all
discrete-state-dependent computations.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>You <em>must not</em> use the returned reference to modify the size or
number of discrete state variables.</p>
</div>
<ol class="arabic simple" start="2">
<li><p>get_mutable_discrete_state(self: pydrake.systems.framework.Context_[AutoDiffXd], arg0: int) -&gt; pydrake.systems.framework.BasicVector_[AutoDiffXd]</p></li>
</ol>
<p>Returns a mutable reference to group (vector) <code class="docutils literal notranslate"><span class="pre">index</span></code> of the
discrete state. Sends out of date notifications for all computations
that depend on this discrete state group.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">index</span></code> must identify an existing group.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently notifies dependents of <em>all</em> groups.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context_[AutoDiffXd].get_mutable_discrete_state_vector(self:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.BasicVector_[AutoDiffXd]</span></span></dt>
<dd><p>Returns a mutable reference to the <em>only</em> discrete state vector. Sends
out of date notifications for all discrete-state-dependent
computations.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>get_discrete_state_vector().</p>
</div>
<dl class="simple">
<dt>Precondition:</dt><dd><p>There is only one discrete state group.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context_[AutoDiffXd].get_mutable_numeric_parameter(self:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd],</span> <span class="pre">index:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.BasicVector_[AutoDiffXd]</span></span></dt>
<dd><p>Returns a mutable reference to element <code class="docutils literal notranslate"><span class="pre">index</span></code> of the vector-valued
(numeric) parameters. Sends out of date notifications for all
computations dependent on this parameter.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">index</span></code> must identify an existing numeric parameter.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently notifies dependents of <em>all</em> numeric parameters.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context_[AutoDiffXd].get_mutable_parameters(self:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.Parameters_[AutoDiffXd]</span></span></dt>
<dd><p>Returns a mutable reference to this Context’s parameters. Sends out of
date notifications for all parameter-dependent computations. If you
don’t mean to change all the parameters, use the indexed methods to
modify only some of the parameters so that fewer computations are
invalidated and fewer notifications need be sent.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>You <em>must not</em> use the returned reference to modify the size,
number, or types of parameters.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context_[AutoDiffXd].get_mutable_state(self:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.State_[AutoDiffXd]</span></span></dt>
<dd><p>Returns a mutable reference to the whole State, potentially
invalidating <em>all</em> state-dependent computations so requiring out of
date notifications to be made for all such computations. If you don’t
mean to change the whole state, use more focused methods to modify
only a portion of the state. See class documentation for more
information.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>You <em>must not</em> use the returned reference to modify the size,
number, or types of state variables.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context_[AutoDiffXd].get_numeric_parameter(self:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd],</span> <span class="pre">index:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.BasicVector_[AutoDiffXd]</span></span></dt>
<dd><p>Returns a const reference to the vector-valued parameter at <code class="docutils literal notranslate"><span class="pre">index</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">index</span></code> must identify an existing parameter.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context_[AutoDiffXd].get_parameters(self:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.Parameters_[AutoDiffXd]</span></span></dt>
<dd><p>Returns a const reference to this Context’s parameters.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context_[AutoDiffXd].get_state(self:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.State_[AutoDiffXd]</span></span></dt>
<dd><p>Returns a const reference to the whole State.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context_[AutoDiffXd].get_time(self:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd</span></span></dt>
<dd><p>Returns the current time in seconds.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>SetTime()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context_[AutoDiffXd].has_only_continuous_state(self:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns true if the Context has continuous state, but no discrete or
abstract state.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context_[AutoDiffXd].has_only_discrete_state(self:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns true if the Context has discrete state, but no continuous or
abstract state.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context_[AutoDiffXd].is_stateless(self:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns true if the Context has no state.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context_[AutoDiffXd].num_abstract_parameters(self:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the number of abstract-valued parameters.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context_[AutoDiffXd].num_abstract_states(self:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the number of elements in the abstract state.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context_[AutoDiffXd].num_continuous_states(self:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the number of continuous state variables <code class="docutils literal notranslate"><span class="pre">xc</span> <span class="pre">=</span> <span class="pre">{q,</span> <span class="pre">v,</span> <span class="pre">z}</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context_[AutoDiffXd].num_discrete_state_groups(self:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the number of vectors (groups) in the discrete state.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context_[AutoDiffXd].num_numeric_parameter_groups(self:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the number of vector-valued parameters.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context_[AutoDiffXd].num_total_states(self:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the total dimension of all of the basic vector states (as if
they were muxed).</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if the system contains any abstract state.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context_[AutoDiffXd].SetAbstractState(self:</span> <span class="pre">object,</span> <span class="pre">index:</span> <span class="pre">int,</span> <span class="pre">value:</span> <span class="pre">object)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the value of the abstract state variable selected by <code class="docutils literal notranslate"><span class="pre">index</span></code>.
Sends out of date notifications for all computations that depend on
that abstract state variable. The template type will be inferred and
need not be specified explicitly.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">index</span></code> must identify an existing abstract state variable.</p>
</dd>
<dt>Precondition:</dt><dd><p>the abstract state’s type must match the template argument.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently notifies dependents of <em>any</em> abstract state variable.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context_[AutoDiffXd].SetAccuracy(self:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd],</span> <span class="pre">accuracy:</span> <span class="pre">Optional[float])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Records the user’s requested accuracy, which is a unit-less quantity
designed for use with simulation and other numerical studies. Since
accuracy is unit-less, algorithms and systems are free to interpret
this quantity as they wish. The intention is that more computational
work is acceptable as the accuracy setting is tightened (set closer to
zero). If no accuracy is requested, computations are free to choose
suitable defaults, or to refuse to proceed without an explicit
accuracy setting. The accuracy of a complete simulation or other
numerical study depends on the accuracy of <em>all</em> contributing
computations, so it is important that each computation is done in
accordance with the requested accuracy. Some examples of where this is
needed: - Error-controlled numerical integrators use the accuracy
setting to decide what step sizes to take. - The Simulator employs a
numerical integrator, but also uses accuracy to decide how precisely
to isolate witness function zero crossings. - Iterative calculations
reported as results or cached internally depend on accuracy to decide
how strictly to converge the results. Examples of these are:
constraint projection, calculation of distances between smooth shapes,
and deformation calculations for soft contact.</p>
<p>The common thread among these examples is that they all share the same
Context, so by keeping accuracy here it can be used effectively to
control all accuracy-dependent computations.</p>
<p>Any accuracy-dependent computation in this Context and its subcontexts
may be invalidated by a change to the accuracy setting, so out of date
notifications are sent to all such computations (at least if the
accuracy setting has actually changed). Accuracy must have the same
value in every subcontext within the same context tree so may only be
modified at the root context of a tree.</p>
<p>Requested accuracy is stored in the Context for two reasons: - It
permits all computations performed over a System to see the <em>same</em>
accuracy request since accuracy is stored in one shared place, and -
it allows us to notify accuracy-dependent cached results that they are
out of date when the accuracy setting changes.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if this is not the root context.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context_[AutoDiffXd].SetContinuousState(self:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd],</span> <span class="pre">arg0:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the continuous state to <code class="docutils literal notranslate"><span class="pre">xc</span></code>, including q, v, and z partitions.
The supplied vector must be the same size as the existing continuous
state. Sends out of date notifications for all
continuous-state-dependent computations.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context_[AutoDiffXd].SetDiscreteState(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>SetDiscreteState(self: pydrake.systems.framework.Context_[AutoDiffXd], xd: numpy.ndarray[object[m, 1]]) -&gt; None</p></li>
</ol>
<p>Sets the discrete state to <code class="docutils literal notranslate"><span class="pre">xd</span></code>, assuming there is just one discrete
state group. The supplied vector must be the same size as the existing
discrete state. Sends out of date notifications for all
discrete-state-dependent computations. Use the other signature for
this method if you have multiple discrete state groups.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>There is exactly one discrete state group.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>SetDiscreteState(self: pydrake.systems.framework.Context_[AutoDiffXd], group_index: int, xd: numpy.ndarray[object[m, 1]]) -&gt; None</p></li>
</ol>
<p>Sets the discrete state group indicated by <code class="docutils literal notranslate"><span class="pre">group_index</span></code> to <code class="docutils literal notranslate"><span class="pre">xd</span></code>.
The supplied vector <code class="docutils literal notranslate"><span class="pre">xd</span></code> must be the same size as the existing
discrete state group. Sends out of date notifications for all
computations that depend on this discrete state group.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">group_index</span></code> identifies an existing group.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently notifies dependents of <em>all</em> groups.</p>
</div>
<ol class="arabic simple" start="3">
<li><p>SetDiscreteState(self: pydrake.systems.framework.Context_[AutoDiffXd], xd: pydrake.systems.framework.DiscreteValues_[AutoDiffXd]) -&gt; None</p></li>
</ol>
<p>Sets all the discrete state variables in this Context from a
compatible DiscreteValues object.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError unless the number</strong><strong> of </strong><strong>groups and size</strong><strong> of </strong><strong>each group of</strong> – </p></li>
<li><p><strong>xd` matches those in this Context</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context_[AutoDiffXd].SetStateAndParametersFrom(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>SetStateAndParametersFrom(self: pydrake.systems.framework.Context_[AutoDiffXd], source: pydrake.systems.framework.Context) -&gt; None</p></li>
</ol>
<p>Copies all state and parameters in <code class="docutils literal notranslate"><span class="pre">source</span></code>, where numerical values
are of type <code class="docutils literal notranslate"><span class="pre">U</span></code>, to <code class="docutils literal notranslate"><span class="pre">this</span></code> context. Time and accuracy are
unchanged in <code class="docutils literal notranslate"><span class="pre">this</span></code> context, which means that this method can be
called on a subcontext. Sends out of date notifications for all
dependent computations in <code class="docutils literal notranslate"><span class="pre">this</span></code> context.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently does not copy fixed input port values from <code class="docutils literal notranslate"><span class="pre">source</span></code>.
See System::FixInputPortsFrom() if you want to copy those.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>SetTimeStateAndParametersFrom() if you want to copy time and
accuracy along with state and parameters to a root context.</p>
</div>
<ol class="arabic simple" start="2">
<li><p>SetStateAndParametersFrom(self: pydrake.systems.framework.Context_[AutoDiffXd], source: pydrake.systems.framework.Context_[AutoDiffXd]) -&gt; None</p></li>
</ol>
<p>Copies all state and parameters in <code class="docutils literal notranslate"><span class="pre">source</span></code>, where numerical values
are of type <code class="docutils literal notranslate"><span class="pre">U</span></code>, to <code class="docutils literal notranslate"><span class="pre">this</span></code> context. Time and accuracy are
unchanged in <code class="docutils literal notranslate"><span class="pre">this</span></code> context, which means that this method can be
called on a subcontext. Sends out of date notifications for all
dependent computations in <code class="docutils literal notranslate"><span class="pre">this</span></code> context.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently does not copy fixed input port values from <code class="docutils literal notranslate"><span class="pre">source</span></code>.
See System::FixInputPortsFrom() if you want to copy those.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>SetTimeStateAndParametersFrom() if you want to copy time and
accuracy along with state and parameters to a root context.</p>
</div>
<ol class="arabic simple" start="3">
<li><p>SetStateAndParametersFrom(self: pydrake.systems.framework.Context_[AutoDiffXd], source: pydrake.systems.framework.Context_[Expression]) -&gt; None</p></li>
</ol>
<p>Copies all state and parameters in <code class="docutils literal notranslate"><span class="pre">source</span></code>, where numerical values
are of type <code class="docutils literal notranslate"><span class="pre">U</span></code>, to <code class="docutils literal notranslate"><span class="pre">this</span></code> context. Time and accuracy are
unchanged in <code class="docutils literal notranslate"><span class="pre">this</span></code> context, which means that this method can be
called on a subcontext. Sends out of date notifications for all
dependent computations in <code class="docutils literal notranslate"><span class="pre">this</span></code> context.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently does not copy fixed input port values from <code class="docutils literal notranslate"><span class="pre">source</span></code>.
See System::FixInputPortsFrom() if you want to copy those.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>SetTimeStateAndParametersFrom() if you want to copy time and
accuracy along with state and parameters to a root context.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context_[AutoDiffXd].SetTime(self:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd],</span> <span class="pre">time_sec:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the current time in seconds. Sends out of date notifications for
all time-dependent computations (at least if the time has actually
changed). Time must have the same value in every subcontext within the
same Diagram context tree so may only be modified at the root context
of the tree.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if this is not the root context.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context_[AutoDiffXd].SetTimeAndContinuousState(self:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd],</span> <span class="pre">arg0:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd,</span> <span class="pre">arg1:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets time to <code class="docutils literal notranslate"><span class="pre">time_sec</span></code> and continuous state to <code class="docutils literal notranslate"><span class="pre">xc</span></code>. Performs a
single notification sweep to avoid duplicate notifications for
computations that depend on both time and state.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if this is not the root context.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context_[AutoDiffXd].SetTimeStateAndParametersFrom(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>SetTimeStateAndParametersFrom(self: pydrake.systems.framework.Context_[AutoDiffXd], source: pydrake.systems.framework.Context) -&gt; None</p></li>
</ol>
<p>Copies time, accuracy, all state and all parameters in <code class="docutils literal notranslate"><span class="pre">source</span></code>,
where numerical values are of type <code class="docutils literal notranslate"><span class="pre">U</span></code>, to <code class="docutils literal notranslate"><span class="pre">this</span></code> context. This
method can only be called on root contexts because time and accuracy
are copied. Sends out of date notifications for all dependent
computations in this context.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if this is not the root context.</strong> – </p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently does not copy fixed input port values from <code class="docutils literal notranslate"><span class="pre">source</span></code>.
See System::FixInputPortsFrom() if you want to copy those.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>SetStateAndParametersFrom() if you want to copy state and
parameters to a non-root context.</p>
</div>
<ol class="arabic simple" start="2">
<li><p>SetTimeStateAndParametersFrom(self: pydrake.systems.framework.Context_[AutoDiffXd], source: pydrake.systems.framework.Context_[AutoDiffXd]) -&gt; None</p></li>
</ol>
<p>Copies time, accuracy, all state and all parameters in <code class="docutils literal notranslate"><span class="pre">source</span></code>,
where numerical values are of type <code class="docutils literal notranslate"><span class="pre">U</span></code>, to <code class="docutils literal notranslate"><span class="pre">this</span></code> context. This
method can only be called on root contexts because time and accuracy
are copied. Sends out of date notifications for all dependent
computations in this context.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if this is not the root context.</strong> – </p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently does not copy fixed input port values from <code class="docutils literal notranslate"><span class="pre">source</span></code>.
See System::FixInputPortsFrom() if you want to copy those.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>SetStateAndParametersFrom() if you want to copy state and
parameters to a non-root context.</p>
</div>
<ol class="arabic simple" start="3">
<li><p>SetTimeStateAndParametersFrom(self: pydrake.systems.framework.Context_[AutoDiffXd], source: pydrake.systems.framework.Context_[Expression]) -&gt; None</p></li>
</ol>
<p>Copies time, accuracy, all state and all parameters in <code class="docutils literal notranslate"><span class="pre">source</span></code>,
where numerical values are of type <code class="docutils literal notranslate"><span class="pre">U</span></code>, to <code class="docutils literal notranslate"><span class="pre">this</span></code> context. This
method can only be called on root contexts because time and accuracy
are copied. Sends out of date notifications for all dependent
computations in this context.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if this is not the root context.</strong> – </p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently does not copy fixed input port values from <code class="docutils literal notranslate"><span class="pre">source</span></code>.
See System::FixInputPortsFrom() if you want to copy those.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>SetStateAndParametersFrom() if you want to copy state and
parameters to a non-root context.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context_[Expression]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.ContextBase</span></code></p>
<p>Context is an abstract class template that represents all the typed
values that are used in a System’s computations: time, numeric-valued
input ports, numerical state, and numerical parameters. There are also
type-erased abstract state variables, abstract-valued input ports,
abstract parameters, and a double accuracy setting. The framework
provides two concrete subclasses of Context: LeafContext (for leaf
Systems) and DiagramContext (for composite System Diagrams). Users are
forbidden to extend DiagramContext and are discouraged from
subclassing LeafContext.</p>
<p>A Context is designed to be used only with the System that created it.
Data encapsulated with State and Parameter objects can be copied
between contexts for compatible systems with some restrictions. For
details, see system_compatibility.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context_[Expression].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context_[Expression].Clone(self:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.Context_[Expression]</span></span></dt>
<dd><p>Returns a deep copy of this Context.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if this is not the root context.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context_[Expression].get_abstract_parameter(self:</span> <span class="pre">pydrake.systems.framework.Context_[Expression],</span> <span class="pre">index:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.common.value.AbstractValue</span></span></dt>
<dd><p>Returns a const reference to the vector-valued parameter at <code class="docutils literal notranslate"><span class="pre">index</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">index</span></code> must identify an existing parameter.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context_[Expression].get_abstract_state(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>get_abstract_state(self: pydrake.systems.framework.Context_[Expression]) -&gt; pydrake.systems.framework.AbstractValues</p></li>
</ol>
<p>Returns a const reference to the abstract component of the state,
which may be of size zero.</p>
<ol class="arabic simple" start="2">
<li><p>get_abstract_state(self: pydrake.systems.framework.Context_[Expression], index: int) -&gt; pydrake.common.value.AbstractValue</p></li>
</ol>
<p>Returns a const reference to the abstract component of the state at
<code class="docutils literal notranslate"><span class="pre">index</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">index</span></code> must identify an existing element.</p>
</dd>
<dt>Precondition:</dt><dd><p>the abstract state’s type must match the template argument.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context_[Expression].get_accuracy(self:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">Optional[float]</span></span></dt>
<dd><p>Returns the accuracy setting (if any). Note that the return type is
<code class="docutils literal notranslate"><span class="pre">optional&lt;double&gt;</span></code> rather than the double value itself.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>SetAccuracy() for details.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context_[Expression].get_continuous_state(self:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.ContinuousState_[Expression]</span></span></dt>
<dd><p>Returns a const reference to the continuous component of the state,
which may be of size zero.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context_[Expression].get_continuous_state_vector(self:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.VectorBase_[Expression]</span></span></dt>
<dd><p>Returns a reference to the continuous state vector, devoid of
second-order structure. The vector may be of size zero.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context_[Expression].get_discrete_state(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>get_discrete_state(self: pydrake.systems.framework.Context_[Expression]) -&gt; pydrake.systems.framework.DiscreteValues_[Expression]</p></li>
</ol>
<p>Returns a reference to the entire discrete state, which may consist of
multiple discrete state vectors (groups).</p>
<ol class="arabic simple" start="2">
<li><p>get_discrete_state(self: pydrake.systems.framework.Context_[Expression], arg0: int) -&gt; pydrake.systems.framework.BasicVector_[Expression]</p></li>
</ol>
<p>Returns a const reference to group (vector) <code class="docutils literal notranslate"><span class="pre">index</span></code> of the discrete
state.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">index</span></code> must identify an existing group.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context_[Expression].get_discrete_state_vector(self:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.BasicVector_[Expression]</span></span></dt>
<dd><p>Returns a reference to the <em>only</em> discrete state vector. The vector
may be of size zero.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>There is only one discrete state group.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context_[Expression].get_mutable_abstract_parameter(self:</span> <span class="pre">pydrake.systems.framework.Context_[Expression],</span> <span class="pre">index:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.common.value.AbstractValue</span></span></dt>
<dd><p>Returns a mutable reference to element <code class="docutils literal notranslate"><span class="pre">index</span></code> of the
abstract-valued parameters. Sends out of date notifications for all
computations dependent on this parameter.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">index</span></code> must identify an existing abstract parameter.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently notifies dependents of <em>all</em> abstract parameters.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context_[Expression].get_mutable_abstract_state(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>get_mutable_abstract_state(self: pydrake.systems.framework.Context_[Expression]) -&gt; pydrake.systems.framework.AbstractValues</p></li>
</ol>
<p>Returns a mutable reference to the abstract component of the state,
which may be of size zero. Sends out of date notifications for all
abstract-state-dependent computations.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>You <em>must not</em> use the returned reference to modify the size,
number, or types of abstract state variables.</p>
</div>
<ol class="arabic simple" start="2">
<li><p>get_mutable_abstract_state(self: pydrake.systems.framework.Context_[Expression], index: int) -&gt; pydrake.common.value.AbstractValue</p></li>
</ol>
<p>Returns a mutable reference to element <code class="docutils literal notranslate"><span class="pre">index</span></code> of the abstract
state. Sends out of date notifications for all computations that
depend on this abstract state variable.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">index</span></code> must identify an existing element.</p>
</dd>
<dt>Precondition:</dt><dd><p>the abstract state’s type must match the template argument.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently notifies dependents of <em>any</em> abstract state variable.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context_[Expression].get_mutable_continuous_state(self:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.ContinuousState_[Expression]</span></span></dt>
<dd><p>Returns a mutable reference to the continuous component of the state,
which may be of size zero. Sends out of date notifications for all
continuous-state-dependent computations.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context_[Expression].get_mutable_continuous_state_vector(self:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.VectorBase_[Expression]</span></span></dt>
<dd><p>Returns a mutable reference to the continuous state vector, devoid of
second-order structure. The vector may be of size zero. Sends out of
date notifications for all continuous-state-dependent computations.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context_[Expression].get_mutable_discrete_state(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>get_mutable_discrete_state(self: pydrake.systems.framework.Context_[Expression]) -&gt; pydrake.systems.framework.DiscreteValues_[Expression]</p></li>
</ol>
<p>Returns a mutable reference to the discrete component of the state,
which may be of size zero. Sends out of date notifications for all
discrete-state-dependent computations.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>You <em>must not</em> use the returned reference to modify the size or
number of discrete state variables.</p>
</div>
<ol class="arabic simple" start="2">
<li><p>get_mutable_discrete_state(self: pydrake.systems.framework.Context_[Expression], arg0: int) -&gt; pydrake.systems.framework.BasicVector_[Expression]</p></li>
</ol>
<p>Returns a mutable reference to group (vector) <code class="docutils literal notranslate"><span class="pre">index</span></code> of the
discrete state. Sends out of date notifications for all computations
that depend on this discrete state group.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">index</span></code> must identify an existing group.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently notifies dependents of <em>all</em> groups.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context_[Expression].get_mutable_discrete_state_vector(self:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.BasicVector_[Expression]</span></span></dt>
<dd><p>Returns a mutable reference to the <em>only</em> discrete state vector. Sends
out of date notifications for all discrete-state-dependent
computations.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>get_discrete_state_vector().</p>
</div>
<dl class="simple">
<dt>Precondition:</dt><dd><p>There is only one discrete state group.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context_[Expression].get_mutable_numeric_parameter(self:</span> <span class="pre">pydrake.systems.framework.Context_[Expression],</span> <span class="pre">index:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.BasicVector_[Expression]</span></span></dt>
<dd><p>Returns a mutable reference to element <code class="docutils literal notranslate"><span class="pre">index</span></code> of the vector-valued
(numeric) parameters. Sends out of date notifications for all
computations dependent on this parameter.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">index</span></code> must identify an existing numeric parameter.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently notifies dependents of <em>all</em> numeric parameters.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context_[Expression].get_mutable_parameters(self:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.Parameters_[Expression]</span></span></dt>
<dd><p>Returns a mutable reference to this Context’s parameters. Sends out of
date notifications for all parameter-dependent computations. If you
don’t mean to change all the parameters, use the indexed methods to
modify only some of the parameters so that fewer computations are
invalidated and fewer notifications need be sent.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>You <em>must not</em> use the returned reference to modify the size,
number, or types of parameters.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context_[Expression].get_mutable_state(self:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.State_[Expression]</span></span></dt>
<dd><p>Returns a mutable reference to the whole State, potentially
invalidating <em>all</em> state-dependent computations so requiring out of
date notifications to be made for all such computations. If you don’t
mean to change the whole state, use more focused methods to modify
only a portion of the state. See class documentation for more
information.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>You <em>must not</em> use the returned reference to modify the size,
number, or types of state variables.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context_[Expression].get_numeric_parameter(self:</span> <span class="pre">pydrake.systems.framework.Context_[Expression],</span> <span class="pre">index:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.BasicVector_[Expression]</span></span></dt>
<dd><p>Returns a const reference to the vector-valued parameter at <code class="docutils literal notranslate"><span class="pre">index</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">index</span></code> must identify an existing parameter.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context_[Expression].get_parameters(self:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.Parameters_[Expression]</span></span></dt>
<dd><p>Returns a const reference to this Context’s parameters.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context_[Expression].get_state(self:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.State_[Expression]</span></span></dt>
<dd><p>Returns a const reference to the whole State.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context_[Expression].get_time(self:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.symbolic.Expression</span></span></dt>
<dd><p>Returns the current time in seconds.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>SetTime()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context_[Expression].has_only_continuous_state(self:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns true if the Context has continuous state, but no discrete or
abstract state.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context_[Expression].has_only_discrete_state(self:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns true if the Context has discrete state, but no continuous or
abstract state.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context_[Expression].is_stateless(self:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns true if the Context has no state.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context_[Expression].num_abstract_parameters(self:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the number of abstract-valued parameters.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context_[Expression].num_abstract_states(self:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the number of elements in the abstract state.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context_[Expression].num_continuous_states(self:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the number of continuous state variables <code class="docutils literal notranslate"><span class="pre">xc</span> <span class="pre">=</span> <span class="pre">{q,</span> <span class="pre">v,</span> <span class="pre">z}</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context_[Expression].num_discrete_state_groups(self:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the number of vectors (groups) in the discrete state.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context_[Expression].num_numeric_parameter_groups(self:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the number of vector-valued parameters.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context_[Expression].num_total_states(self:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the total dimension of all of the basic vector states (as if
they were muxed).</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if the system contains any abstract state.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context_[Expression].SetAbstractState(self:</span> <span class="pre">object,</span> <span class="pre">index:</span> <span class="pre">int,</span> <span class="pre">value:</span> <span class="pre">object)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the value of the abstract state variable selected by <code class="docutils literal notranslate"><span class="pre">index</span></code>.
Sends out of date notifications for all computations that depend on
that abstract state variable. The template type will be inferred and
need not be specified explicitly.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">index</span></code> must identify an existing abstract state variable.</p>
</dd>
<dt>Precondition:</dt><dd><p>the abstract state’s type must match the template argument.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently notifies dependents of <em>any</em> abstract state variable.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context_[Expression].SetAccuracy(self:</span> <span class="pre">pydrake.systems.framework.Context_[Expression],</span> <span class="pre">accuracy:</span> <span class="pre">Optional[float])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Records the user’s requested accuracy, which is a unit-less quantity
designed for use with simulation and other numerical studies. Since
accuracy is unit-less, algorithms and systems are free to interpret
this quantity as they wish. The intention is that more computational
work is acceptable as the accuracy setting is tightened (set closer to
zero). If no accuracy is requested, computations are free to choose
suitable defaults, or to refuse to proceed without an explicit
accuracy setting. The accuracy of a complete simulation or other
numerical study depends on the accuracy of <em>all</em> contributing
computations, so it is important that each computation is done in
accordance with the requested accuracy. Some examples of where this is
needed: - Error-controlled numerical integrators use the accuracy
setting to decide what step sizes to take. - The Simulator employs a
numerical integrator, but also uses accuracy to decide how precisely
to isolate witness function zero crossings. - Iterative calculations
reported as results or cached internally depend on accuracy to decide
how strictly to converge the results. Examples of these are:
constraint projection, calculation of distances between smooth shapes,
and deformation calculations for soft contact.</p>
<p>The common thread among these examples is that they all share the same
Context, so by keeping accuracy here it can be used effectively to
control all accuracy-dependent computations.</p>
<p>Any accuracy-dependent computation in this Context and its subcontexts
may be invalidated by a change to the accuracy setting, so out of date
notifications are sent to all such computations (at least if the
accuracy setting has actually changed). Accuracy must have the same
value in every subcontext within the same context tree so may only be
modified at the root context of a tree.</p>
<p>Requested accuracy is stored in the Context for two reasons: - It
permits all computations performed over a System to see the <em>same</em>
accuracy request since accuracy is stored in one shared place, and -
it allows us to notify accuracy-dependent cached results that they are
out of date when the accuracy setting changes.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if this is not the root context.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context_[Expression].SetContinuousState(self:</span> <span class="pre">pydrake.systems.framework.Context_[Expression],</span> <span class="pre">arg0:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the continuous state to <code class="docutils literal notranslate"><span class="pre">xc</span></code>, including q, v, and z partitions.
The supplied vector must be the same size as the existing continuous
state. Sends out of date notifications for all
continuous-state-dependent computations.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context_[Expression].SetDiscreteState(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>SetDiscreteState(self: pydrake.systems.framework.Context_[Expression], xd: numpy.ndarray[object[m, 1]]) -&gt; None</p></li>
</ol>
<p>Sets the discrete state to <code class="docutils literal notranslate"><span class="pre">xd</span></code>, assuming there is just one discrete
state group. The supplied vector must be the same size as the existing
discrete state. Sends out of date notifications for all
discrete-state-dependent computations. Use the other signature for
this method if you have multiple discrete state groups.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>There is exactly one discrete state group.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>SetDiscreteState(self: pydrake.systems.framework.Context_[Expression], group_index: int, xd: numpy.ndarray[object[m, 1]]) -&gt; None</p></li>
</ol>
<p>Sets the discrete state group indicated by <code class="docutils literal notranslate"><span class="pre">group_index</span></code> to <code class="docutils literal notranslate"><span class="pre">xd</span></code>.
The supplied vector <code class="docutils literal notranslate"><span class="pre">xd</span></code> must be the same size as the existing
discrete state group. Sends out of date notifications for all
computations that depend on this discrete state group.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">group_index</span></code> identifies an existing group.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently notifies dependents of <em>all</em> groups.</p>
</div>
<ol class="arabic simple" start="3">
<li><p>SetDiscreteState(self: pydrake.systems.framework.Context_[Expression], xd: pydrake.systems.framework.DiscreteValues_[Expression]) -&gt; None</p></li>
</ol>
<p>Sets all the discrete state variables in this Context from a
compatible DiscreteValues object.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError unless the number</strong><strong> of </strong><strong>groups and size</strong><strong> of </strong><strong>each group of</strong> – </p></li>
<li><p><strong>xd` matches those in this Context</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context_[Expression].SetStateAndParametersFrom(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>SetStateAndParametersFrom(self: pydrake.systems.framework.Context_[Expression], source: pydrake.systems.framework.Context) -&gt; None</p></li>
</ol>
<p>Copies all state and parameters in <code class="docutils literal notranslate"><span class="pre">source</span></code>, where numerical values
are of type <code class="docutils literal notranslate"><span class="pre">U</span></code>, to <code class="docutils literal notranslate"><span class="pre">this</span></code> context. Time and accuracy are
unchanged in <code class="docutils literal notranslate"><span class="pre">this</span></code> context, which means that this method can be
called on a subcontext. Sends out of date notifications for all
dependent computations in <code class="docutils literal notranslate"><span class="pre">this</span></code> context.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently does not copy fixed input port values from <code class="docutils literal notranslate"><span class="pre">source</span></code>.
See System::FixInputPortsFrom() if you want to copy those.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>SetTimeStateAndParametersFrom() if you want to copy time and
accuracy along with state and parameters to a root context.</p>
</div>
<ol class="arabic simple" start="2">
<li><p>SetStateAndParametersFrom(self: pydrake.systems.framework.Context_[Expression], source: pydrake.systems.framework.Context_[AutoDiffXd]) -&gt; None</p></li>
</ol>
<p>Copies all state and parameters in <code class="docutils literal notranslate"><span class="pre">source</span></code>, where numerical values
are of type <code class="docutils literal notranslate"><span class="pre">U</span></code>, to <code class="docutils literal notranslate"><span class="pre">this</span></code> context. Time and accuracy are
unchanged in <code class="docutils literal notranslate"><span class="pre">this</span></code> context, which means that this method can be
called on a subcontext. Sends out of date notifications for all
dependent computations in <code class="docutils literal notranslate"><span class="pre">this</span></code> context.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently does not copy fixed input port values from <code class="docutils literal notranslate"><span class="pre">source</span></code>.
See System::FixInputPortsFrom() if you want to copy those.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>SetTimeStateAndParametersFrom() if you want to copy time and
accuracy along with state and parameters to a root context.</p>
</div>
<ol class="arabic simple" start="3">
<li><p>SetStateAndParametersFrom(self: pydrake.systems.framework.Context_[Expression], source: pydrake.systems.framework.Context_[Expression]) -&gt; None</p></li>
</ol>
<p>Copies all state and parameters in <code class="docutils literal notranslate"><span class="pre">source</span></code>, where numerical values
are of type <code class="docutils literal notranslate"><span class="pre">U</span></code>, to <code class="docutils literal notranslate"><span class="pre">this</span></code> context. Time and accuracy are
unchanged in <code class="docutils literal notranslate"><span class="pre">this</span></code> context, which means that this method can be
called on a subcontext. Sends out of date notifications for all
dependent computations in <code class="docutils literal notranslate"><span class="pre">this</span></code> context.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently does not copy fixed input port values from <code class="docutils literal notranslate"><span class="pre">source</span></code>.
See System::FixInputPortsFrom() if you want to copy those.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>SetTimeStateAndParametersFrom() if you want to copy time and
accuracy along with state and parameters to a root context.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context_[Expression].SetTime(self:</span> <span class="pre">pydrake.systems.framework.Context_[Expression],</span> <span class="pre">time_sec:</span> <span class="pre">pydrake.symbolic.Expression)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the current time in seconds. Sends out of date notifications for
all time-dependent computations (at least if the time has actually
changed). Time must have the same value in every subcontext within the
same Diagram context tree so may only be modified at the root context
of the tree.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if this is not the root context.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context_[Expression].SetTimeAndContinuousState(self:</span> <span class="pre">pydrake.systems.framework.Context_[Expression],</span> <span class="pre">arg0:</span> <span class="pre">pydrake.symbolic.Expression,</span> <span class="pre">arg1:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets time to <code class="docutils literal notranslate"><span class="pre">time_sec</span></code> and continuous state to <code class="docutils literal notranslate"><span class="pre">xc</span></code>. Performs a
single notification sweep to avoid duplicate notifications for
computations that depend on both time and state.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if this is not the root context.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Context_[Expression].SetTimeStateAndParametersFrom(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>SetTimeStateAndParametersFrom(self: pydrake.systems.framework.Context_[Expression], source: pydrake.systems.framework.Context) -&gt; None</p></li>
</ol>
<p>Copies time, accuracy, all state and all parameters in <code class="docutils literal notranslate"><span class="pre">source</span></code>,
where numerical values are of type <code class="docutils literal notranslate"><span class="pre">U</span></code>, to <code class="docutils literal notranslate"><span class="pre">this</span></code> context. This
method can only be called on root contexts because time and accuracy
are copied. Sends out of date notifications for all dependent
computations in this context.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if this is not the root context.</strong> – </p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently does not copy fixed input port values from <code class="docutils literal notranslate"><span class="pre">source</span></code>.
See System::FixInputPortsFrom() if you want to copy those.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>SetStateAndParametersFrom() if you want to copy state and
parameters to a non-root context.</p>
</div>
<ol class="arabic simple" start="2">
<li><p>SetTimeStateAndParametersFrom(self: pydrake.systems.framework.Context_[Expression], source: pydrake.systems.framework.Context_[AutoDiffXd]) -&gt; None</p></li>
</ol>
<p>Copies time, accuracy, all state and all parameters in <code class="docutils literal notranslate"><span class="pre">source</span></code>,
where numerical values are of type <code class="docutils literal notranslate"><span class="pre">U</span></code>, to <code class="docutils literal notranslate"><span class="pre">this</span></code> context. This
method can only be called on root contexts because time and accuracy
are copied. Sends out of date notifications for all dependent
computations in this context.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if this is not the root context.</strong> – </p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently does not copy fixed input port values from <code class="docutils literal notranslate"><span class="pre">source</span></code>.
See System::FixInputPortsFrom() if you want to copy those.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>SetStateAndParametersFrom() if you want to copy state and
parameters to a non-root context.</p>
</div>
<ol class="arabic simple" start="3">
<li><p>SetTimeStateAndParametersFrom(self: pydrake.systems.framework.Context_[Expression], source: pydrake.systems.framework.Context_[Expression]) -&gt; None</p></li>
</ol>
<p>Copies time, accuracy, all state and all parameters in <code class="docutils literal notranslate"><span class="pre">source</span></code>,
where numerical values are of type <code class="docutils literal notranslate"><span class="pre">U</span></code>, to <code class="docutils literal notranslate"><span class="pre">this</span></code> context. This
method can only be called on root contexts because time and accuracy
are copied. Sends out of date notifications for all dependent
computations in this context.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if this is not the root context.</strong> – </p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently does not copy fixed input port values from <code class="docutils literal notranslate"><span class="pre">source</span></code>.
See System::FixInputPortsFrom() if you want to copy those.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>SetStateAndParametersFrom() if you want to copy state and
parameters to a non-root context.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ContextBase</span></span></dt>
<dd><p>Provides non-templatized Context functionality shared by the
templatized derived classes. That includes caching, dependency
tracking, and management of local values for fixed input ports.</p>
<p>Terminology: in general a Drake System is a tree structure composed of
“subsystems”, which are themselves System objects. The corresponding
Context is a parallel tree structure composed of “subcontexts”, which
are themselves Context objects. There is a one-to-one correspondence
between subsystems and subcontexts. Within a given System (Context),
its child subsystems (subcontexts) are indexed using a SubsystemIndex;
there is no separate SubcontextIndex since the numbering must be
identical.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ContextBase.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ContextBase.DisableCaching(self:</span> <span class="pre">pydrake.systems.framework.ContextBase)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>(Debugging) Disables caching recursively for this context and all its
subcontexts. Caching is enabled by default. Disabling forces every
<code class="docutils literal notranslate"><span class="pre">Eval()</span></code> method to perform a full calculation rather than returning
the cached one. Results should be identical with or without caching,
except for performance. If they are not, there is likely a problem
with (a) the specified dependencies for some calculation, or (b) a
misuse of references into cached values that hides modifications from
the caching system, or (c) a bug in the caching system. The
<code class="docutils literal notranslate"><span class="pre">is_disabled</span></code> flags are independent of the <code class="docutils literal notranslate"><span class="pre">out_of_date</span></code> flags,
which continue to be maintained even when caching is disabled (though
they are ignored). Caching can be re-enabled using EnableCaching().</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ContextBase.EnableCaching(self:</span> <span class="pre">pydrake.systems.framework.ContextBase)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>(Debugging) Re-enables caching recursively for this context and all
its subcontexts. Caching is enabled by default but may have been
disabled via a call to DisableCaching(). The <code class="docutils literal notranslate"><span class="pre">is_disabled</span></code> flags are
independent of the <code class="docutils literal notranslate"><span class="pre">out_of_date</span></code> flags, which continue to be
maintained even when caching is disabled (though they are ignored).
Hence re-enabling the cache with this method may result in some
entries being already considered up to date. See
SetAllCacheEntriesOutOfDate() if you want to ensure that caching
restarts with everything out of date. You might want to do that, for
example, for repeatability or because you modified something in the
debugger and want to make sure it gets used.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ContextBase.FreezeCache(self:</span> <span class="pre">pydrake.systems.framework.ContextBase)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>(Advanced) Freezes the cache at its current contents, preventing any
further cache updates. When frozen, accessing an out-of-date cache
entry causes an exception to be throw. This is applied recursively to
this Context and all its subcontexts, but <em>not</em> to its parent or
siblings so it is most useful when called on the root Context. If the
cache was already frozen this method does nothing but waste a little
time.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ContextBase.is_cache_frozen(self:</span> <span class="pre">pydrake.systems.framework.ContextBase)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>(Advanced) Reports whether this Context’s cache is currently frozen.
This checks only locally; it is possible that parent, child, or
sibling subcontext caches are in a different state than this one.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ContextBase.num_input_ports(self:</span> <span class="pre">pydrake.systems.framework.ContextBase)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the number of input ports in this context.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ContextBase.num_output_ports(self:</span> <span class="pre">pydrake.systems.framework.ContextBase)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the number of output ports represented in this context.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ContextBase.SetAllCacheEntriesOutOfDate(self:</span> <span class="pre">pydrake.systems.framework.ContextBase)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>(Debugging) Marks all cache entries out of date, recursively for this
context and all its subcontexts. This forces the next <code class="docutils literal notranslate"><span class="pre">Eval()</span></code>
request for each cache entry to perform a full calculation rather than
returning the cached one. After that first recalculation, normal
caching behavior resumes (assuming the cache is not disabled). Results
should be identical whether this is called or not, since the caching
system should be maintaining this flag correctly. If they are not, see
the documentation for SetIsCacheDisabled() for suggestions.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ContextBase.UnfreezeCache(self:</span> <span class="pre">pydrake.systems.framework.ContextBase)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>(Advanced) Unfreezes the cache if it was previously frozen. This is
applied recursively to this Context and all its subcontexts, but <em>not</em>
to its parent or siblings. If the cache was not frozen, this does
nothing but waste a little time.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ContinuousState</span></span></dt>
<dd><p>%ContinuousState is a view of, and optionally a container for, all the
continuous state variables <code class="docutils literal notranslate"><span class="pre">xc</span></code> of a Drake System. Continuous state
variables are those whose values are defined by differential
equations, so we expect there to be a well-defined time derivative
<code class="docutils literal notranslate"><span class="pre">xcdot</span></code> ≜ <code class="docutils literal notranslate"><span class="pre">d/dt</span> <span class="pre">xc</span></code>.</p>
<p>The contents of <code class="docutils literal notranslate"><span class="pre">xc</span></code> are conceptually partitioned into three groups:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">q</span></code> is generalized position</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">v</span></code> is generalized velocity</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">z</span></code> is other continuous state</p></li>
</ul>
<p>For a Drake LeafSystem these partitions are stored contiguously in
memory in this sequence: xc=[q v z]. But because a Drake System may be
a Diagram composed from subsystems, each with its own continuous state
variables (“substates”), the composite continuous state will not
generally be stored in contiguous memory. In that case the most we can
say is that xc={q,v,z}, that is, it consists of all the q’s, v’s, and
z’s, in some order.</p>
<p>Nevertheless, this ContinuousState class provides a vector view of the
data that groups together all the q partitions, v partitions, and z
partitions. For example, if there are three subsystems (possibly
Diagrams) whose continuous state variables are respectively
xc₁={q₁,v₁,z₁}, xc₂={q₂,v₂,z₂}, and xc₃={q₃,v₃,z₃} the composite xc
includes all the partitions in an undefined order. However, composite
q, v, and z appear ordered as q=[q₁ q₂ q₃], v=[v₁ v₂ v₃], z=[z₁ z₂
z₃]. Note that the element ordering of the composite xc is <em>not</em> a
concatenation of the composite subgroups. Do not index elements of the
full state xc unless you know it is the continuous state of a
LeafSystem (a LeafSystem looking at its own Context can depend on
that).</p>
<p>Any of the groups may be empty. However, groups q and v must be either
both present or both empty, because the time derivative <code class="docutils literal notranslate"><span class="pre">qdot</span></code> of
the second-order state variables <code class="docutils literal notranslate"><span class="pre">q</span></code> must be computable using a
linear mapping <code class="docutils literal notranslate"><span class="pre">qdot=N(q)*v</span></code>.</p>
<p>The time derivative <code class="docutils literal notranslate"><span class="pre">xcdot</span></code> has the identical substructure to
<code class="docutils literal notranslate"><span class="pre">xc</span></code>, with the partitions interpreted as <code class="docutils literal notranslate"><span class="pre">qdot</span></code>, <cite>vdot</cite>, and
<code class="docutils literal notranslate"><span class="pre">zdot</span></code>. We use identical ContinuousState objects for both.</p>
<p><em>Memory ownership</em></p>
<p>When a ContinuousState represents the state of a LeafSystem, it always
owns the memory that is used for the state variables and is
responsible for destruction. For a Diagram, ContinuousState can
instead be a <em>view</em> of the underlying LeafSystem substates, so that
modifying the Diagram’s continuous state affects the LeafSystems
appropriately. In that case, the memory is owned by the underlying
LeafSystems. However, when a ContinuousState object of any structure
is cloned, the resulting object <em>always</em> owns all its underlying
memory, which is initialized with a copy of the original state
variable values but is otherwise independent. The cloned object
retains the structure and ordering of the elements and does not
guarantee contiguous storage.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DiagramContinuousState for more information.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">ContinuousState_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ContinuousState.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.systems.framework.ContinuousState) -&gt; None</p></li>
</ol>
<p>Constructs a zero-length ContinuousState.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.systems.framework.ContinuousState, state: pydrake.systems.framework.BasicVector) -&gt; None</p></li>
</ol>
<p>Constructs a ContinuousState for a system that does not have
second-order structure. The <code class="docutils literal notranslate"><span class="pre">q</span></code> and <code class="docutils literal notranslate"><span class="pre">v</span></code> partitions are empty; all
of the state <code class="docutils literal notranslate"><span class="pre">xc</span></code> is miscellaneous continuous state <code class="docutils literal notranslate"><span class="pre">z</span></code>.</p>
<ol class="arabic simple" start="3">
<li><p>__init__(self: pydrake.systems.framework.ContinuousState, state: pydrake.systems.framework.BasicVector, num_q: int, num_v: int, num_z: int) -&gt; None</p></li>
</ol>
<p>Constructs a ContinuousState that exposes second-order structure.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">state</span></code>:</dt><dd><p>The source xc of continuous state information.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">num_q</span></code>:</dt><dd><p>The number of position variables q.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">num_v</span></code>:</dt><dd><p>The number of velocity variables v.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">num_z</span></code>:</dt><dd><p>The number of other continuous variables z.</p>
</dd>
</dl>
<p>We require that <code class="docutils literal notranslate"><span class="pre">num_q</span> <span class="pre">≥</span> <span class="pre">num_v</span></code> and that the sum of the partition
sizes adds up to the size of <code class="docutils literal notranslate"><span class="pre">state</span></code>.</p>
<ol class="arabic simple" start="4">
<li><p>__init__(self: pydrake.systems.framework.ContinuousState, state: pydrake.systems.framework.VectorBase) -&gt; None</p></li>
</ol>
<p>Constructs a ContinuousState for a system that does not have
second-order structure. The <code class="docutils literal notranslate"><span class="pre">q</span></code> and <code class="docutils literal notranslate"><span class="pre">v</span></code> partitions are empty; all
of the state <code class="docutils literal notranslate"><span class="pre">xc</span></code> is miscellaneous continuous state <code class="docutils literal notranslate"><span class="pre">z</span></code>.</p>
<ol class="arabic simple" start="5">
<li><p>__init__(self: pydrake.systems.framework.ContinuousState, state: pydrake.systems.framework.VectorBase, num_q: int, num_v: int, num_z: int) -&gt; None</p></li>
</ol>
<p>Constructs a ContinuousState that exposes second-order structure.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">state</span></code>:</dt><dd><p>The source xc of continuous state information.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">num_q</span></code>:</dt><dd><p>The number of position variables q.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">num_v</span></code>:</dt><dd><p>The number of velocity variables v.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">num_z</span></code>:</dt><dd><p>The number of other continuous variables z.</p>
</dd>
</dl>
<p>We require that <code class="docutils literal notranslate"><span class="pre">num_q</span> <span class="pre">≥</span> <span class="pre">num_v</span></code> and that the sum of the partition
sizes adds up to the size of <code class="docutils literal notranslate"><span class="pre">state</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ContinuousState.Clone(self:</span> <span class="pre">pydrake.systems.framework.ContinuousState)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.ContinuousState</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ContinuousState.CopyToVector(self:</span> <span class="pre">pydrake.systems.framework.ContinuousState)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns a copy of the entire continuous state vector into an Eigen
vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ContinuousState.get_generalized_position(self:</span> <span class="pre">pydrake.systems.framework.ContinuousState)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.VectorBase</span></span></dt>
<dd><p>Returns a const reference to the subset of the state vector that is
generalized position <code class="docutils literal notranslate"><span class="pre">q</span></code>. May be zero length.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ContinuousState.get_generalized_velocity(self:</span> <span class="pre">pydrake.systems.framework.ContinuousState)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.VectorBase</span></span></dt>
<dd><p>Returns a const reference to the subset of the continuous state vector
that is generalized velocity <code class="docutils literal notranslate"><span class="pre">v</span></code>. May be zero length.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ContinuousState.get_misc_continuous_state(self:</span> <span class="pre">pydrake.systems.framework.ContinuousState)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.VectorBase</span></span></dt>
<dd><p>Returns a const reference to the subset of the continuous state vector
that is other continuous state <code class="docutils literal notranslate"><span class="pre">z</span></code>. May be zero length.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ContinuousState.get_mutable_generalized_position(self:</span> <span class="pre">pydrake.systems.framework.ContinuousState)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.VectorBase</span></span></dt>
<dd><p>Returns a mutable reference to the subset of the state vector that is
generalized position <code class="docutils literal notranslate"><span class="pre">q</span></code>. May be zero length.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ContinuousState.get_mutable_generalized_velocity(self:</span> <span class="pre">pydrake.systems.framework.ContinuousState)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.VectorBase</span></span></dt>
<dd><p>Returns a mutable reference to the subset of the continuous state
vector that is generalized velocity <code class="docutils literal notranslate"><span class="pre">v</span></code>. May be zero length.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ContinuousState.get_mutable_misc_continuous_state(self:</span> <span class="pre">pydrake.systems.framework.ContinuousState)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.VectorBase</span></span></dt>
<dd><p>Returns a mutable reference to the subset of the continuous state
vector that is other continuous state <code class="docutils literal notranslate"><span class="pre">z</span></code>. May be zero length.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ContinuousState.get_mutable_vector(self:</span> <span class="pre">pydrake.systems.framework.ContinuousState)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.VectorBase</span></span></dt>
<dd><p>Returns a mutable reference to the entire continuous state vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ContinuousState.get_vector(self:</span> <span class="pre">pydrake.systems.framework.ContinuousState)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.VectorBase</span></span></dt>
<dd><p>Returns a reference to the entire continuous state vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ContinuousState.num_q(self:</span> <span class="pre">pydrake.systems.framework.ContinuousState)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the number of generalized positions q in this state vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ContinuousState.num_v(self:</span> <span class="pre">pydrake.systems.framework.ContinuousState)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the number of generalized velocities v in this state vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ContinuousState.num_z(self:</span> <span class="pre">pydrake.systems.framework.ContinuousState)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the number of miscellaneous continuous state variables z in
this state vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ContinuousState.SetFrom(self:</span> <span class="pre">pydrake.systems.framework.ContinuousState,</span> <span class="pre">arg0:</span> <span class="pre">pydrake.systems.framework.ContinuousState)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Copies the values from <code class="docutils literal notranslate"><span class="pre">other</span></code> into <code class="docutils literal notranslate"><span class="pre">this</span></code>, converting the scalar
type as necessary.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ContinuousState.SetFromVector(self:</span> <span class="pre">pydrake.systems.framework.ContinuousState,</span> <span class="pre">value:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the entire continuous state vector from an Eigen expression.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ContinuousState.size(self:</span> <span class="pre">pydrake.systems.framework.ContinuousState)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the size of the entire continuous state vector, which is
necessarily <code class="docutils literal notranslate"><span class="pre">num_q</span> <span class="pre">+</span> <span class="pre">num_v</span> <span class="pre">+</span> <span class="pre">num_z</span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ContinuousState_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">ContinuousState_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ContinuousState_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ContinuousState_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ContinuousState_[AutoDiffXd]</span></span></dt>
<dd><p>%ContinuousState is a view of, and optionally a container for, all the
continuous state variables <code class="docutils literal notranslate"><span class="pre">xc</span></code> of a Drake System. Continuous state
variables are those whose values are defined by differential
equations, so we expect there to be a well-defined time derivative
<code class="docutils literal notranslate"><span class="pre">xcdot</span></code> ≜ <code class="docutils literal notranslate"><span class="pre">d/dt</span> <span class="pre">xc</span></code>.</p>
<p>The contents of <code class="docutils literal notranslate"><span class="pre">xc</span></code> are conceptually partitioned into three groups:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">q</span></code> is generalized position</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">v</span></code> is generalized velocity</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">z</span></code> is other continuous state</p></li>
</ul>
<p>For a Drake LeafSystem these partitions are stored contiguously in
memory in this sequence: xc=[q v z]. But because a Drake System may be
a Diagram composed from subsystems, each with its own continuous state
variables (“substates”), the composite continuous state will not
generally be stored in contiguous memory. In that case the most we can
say is that xc={q,v,z}, that is, it consists of all the q’s, v’s, and
z’s, in some order.</p>
<p>Nevertheless, this ContinuousState class provides a vector view of the
data that groups together all the q partitions, v partitions, and z
partitions. For example, if there are three subsystems (possibly
Diagrams) whose continuous state variables are respectively
xc₁={q₁,v₁,z₁}, xc₂={q₂,v₂,z₂}, and xc₃={q₃,v₃,z₃} the composite xc
includes all the partitions in an undefined order. However, composite
q, v, and z appear ordered as q=[q₁ q₂ q₃], v=[v₁ v₂ v₃], z=[z₁ z₂
z₃]. Note that the element ordering of the composite xc is <em>not</em> a
concatenation of the composite subgroups. Do not index elements of the
full state xc unless you know it is the continuous state of a
LeafSystem (a LeafSystem looking at its own Context can depend on
that).</p>
<p>Any of the groups may be empty. However, groups q and v must be either
both present or both empty, because the time derivative <code class="docutils literal notranslate"><span class="pre">qdot</span></code> of
the second-order state variables <code class="docutils literal notranslate"><span class="pre">q</span></code> must be computable using a
linear mapping <code class="docutils literal notranslate"><span class="pre">qdot=N(q)*v</span></code>.</p>
<p>The time derivative <code class="docutils literal notranslate"><span class="pre">xcdot</span></code> has the identical substructure to
<code class="docutils literal notranslate"><span class="pre">xc</span></code>, with the partitions interpreted as <code class="docutils literal notranslate"><span class="pre">qdot</span></code>, <cite>vdot</cite>, and
<code class="docutils literal notranslate"><span class="pre">zdot</span></code>. We use identical ContinuousState objects for both.</p>
<p><em>Memory ownership</em></p>
<p>When a ContinuousState represents the state of a LeafSystem, it always
owns the memory that is used for the state variables and is
responsible for destruction. For a Diagram, ContinuousState can
instead be a <em>view</em> of the underlying LeafSystem substates, so that
modifying the Diagram’s continuous state affects the LeafSystems
appropriately. In that case, the memory is owned by the underlying
LeafSystems. However, when a ContinuousState object of any structure
is cloned, the resulting object <em>always</em> owns all its underlying
memory, which is initialized with a copy of the original state
variable values but is otherwise independent. The cloned object
retains the structure and ordering of the elements and does not
guarantee contiguous storage.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DiagramContinuousState for more information.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ContinuousState_[AutoDiffXd].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.systems.framework.ContinuousState_[AutoDiffXd]) -&gt; None</p></li>
</ol>
<p>Constructs a zero-length ContinuousState.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.systems.framework.ContinuousState_[AutoDiffXd], state: pydrake.systems.framework.BasicVector_[AutoDiffXd]) -&gt; None</p></li>
</ol>
<p>Constructs a ContinuousState for a system that does not have
second-order structure. The <code class="docutils literal notranslate"><span class="pre">q</span></code> and <code class="docutils literal notranslate"><span class="pre">v</span></code> partitions are empty; all
of the state <code class="docutils literal notranslate"><span class="pre">xc</span></code> is miscellaneous continuous state <code class="docutils literal notranslate"><span class="pre">z</span></code>.</p>
<ol class="arabic simple" start="3">
<li><p>__init__(self: pydrake.systems.framework.ContinuousState_[AutoDiffXd], state: pydrake.systems.framework.BasicVector_[AutoDiffXd], num_q: int, num_v: int, num_z: int) -&gt; None</p></li>
</ol>
<p>Constructs a ContinuousState that exposes second-order structure.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">state</span></code>:</dt><dd><p>The source xc of continuous state information.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">num_q</span></code>:</dt><dd><p>The number of position variables q.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">num_v</span></code>:</dt><dd><p>The number of velocity variables v.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">num_z</span></code>:</dt><dd><p>The number of other continuous variables z.</p>
</dd>
</dl>
<p>We require that <code class="docutils literal notranslate"><span class="pre">num_q</span> <span class="pre">≥</span> <span class="pre">num_v</span></code> and that the sum of the partition
sizes adds up to the size of <code class="docutils literal notranslate"><span class="pre">state</span></code>.</p>
<ol class="arabic simple" start="4">
<li><p>__init__(self: pydrake.systems.framework.ContinuousState_[AutoDiffXd], state: pydrake.systems.framework.VectorBase_[AutoDiffXd]) -&gt; None</p></li>
</ol>
<p>Constructs a ContinuousState for a system that does not have
second-order structure. The <code class="docutils literal notranslate"><span class="pre">q</span></code> and <code class="docutils literal notranslate"><span class="pre">v</span></code> partitions are empty; all
of the state <code class="docutils literal notranslate"><span class="pre">xc</span></code> is miscellaneous continuous state <code class="docutils literal notranslate"><span class="pre">z</span></code>.</p>
<ol class="arabic simple" start="5">
<li><p>__init__(self: pydrake.systems.framework.ContinuousState_[AutoDiffXd], state: pydrake.systems.framework.VectorBase_[AutoDiffXd], num_q: int, num_v: int, num_z: int) -&gt; None</p></li>
</ol>
<p>Constructs a ContinuousState that exposes second-order structure.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">state</span></code>:</dt><dd><p>The source xc of continuous state information.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">num_q</span></code>:</dt><dd><p>The number of position variables q.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">num_v</span></code>:</dt><dd><p>The number of velocity variables v.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">num_z</span></code>:</dt><dd><p>The number of other continuous variables z.</p>
</dd>
</dl>
<p>We require that <code class="docutils literal notranslate"><span class="pre">num_q</span> <span class="pre">≥</span> <span class="pre">num_v</span></code> and that the sum of the partition
sizes adds up to the size of <code class="docutils literal notranslate"><span class="pre">state</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ContinuousState_[AutoDiffXd].Clone(self:</span> <span class="pre">pydrake.systems.framework.ContinuousState_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.ContinuousState_[AutoDiffXd]</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ContinuousState_[AutoDiffXd].CopyToVector(self:</span> <span class="pre">pydrake.systems.framework.ContinuousState_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns a copy of the entire continuous state vector into an Eigen
vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ContinuousState_[AutoDiffXd].get_generalized_position(self:</span> <span class="pre">pydrake.systems.framework.ContinuousState_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.VectorBase_[AutoDiffXd]</span></span></dt>
<dd><p>Returns a const reference to the subset of the state vector that is
generalized position <code class="docutils literal notranslate"><span class="pre">q</span></code>. May be zero length.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ContinuousState_[AutoDiffXd].get_generalized_velocity(self:</span> <span class="pre">pydrake.systems.framework.ContinuousState_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.VectorBase_[AutoDiffXd]</span></span></dt>
<dd><p>Returns a const reference to the subset of the continuous state vector
that is generalized velocity <code class="docutils literal notranslate"><span class="pre">v</span></code>. May be zero length.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ContinuousState_[AutoDiffXd].get_misc_continuous_state(self:</span> <span class="pre">pydrake.systems.framework.ContinuousState_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.VectorBase_[AutoDiffXd]</span></span></dt>
<dd><p>Returns a const reference to the subset of the continuous state vector
that is other continuous state <code class="docutils literal notranslate"><span class="pre">z</span></code>. May be zero length.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ContinuousState_[AutoDiffXd].get_mutable_generalized_position(self:</span> <span class="pre">pydrake.systems.framework.ContinuousState_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.VectorBase_[AutoDiffXd]</span></span></dt>
<dd><p>Returns a mutable reference to the subset of the state vector that is
generalized position <code class="docutils literal notranslate"><span class="pre">q</span></code>. May be zero length.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ContinuousState_[AutoDiffXd].get_mutable_generalized_velocity(self:</span> <span class="pre">pydrake.systems.framework.ContinuousState_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.VectorBase_[AutoDiffXd]</span></span></dt>
<dd><p>Returns a mutable reference to the subset of the continuous state
vector that is generalized velocity <code class="docutils literal notranslate"><span class="pre">v</span></code>. May be zero length.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ContinuousState_[AutoDiffXd].get_mutable_misc_continuous_state(self:</span> <span class="pre">pydrake.systems.framework.ContinuousState_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.VectorBase_[AutoDiffXd]</span></span></dt>
<dd><p>Returns a mutable reference to the subset of the continuous state
vector that is other continuous state <code class="docutils literal notranslate"><span class="pre">z</span></code>. May be zero length.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ContinuousState_[AutoDiffXd].get_mutable_vector(self:</span> <span class="pre">pydrake.systems.framework.ContinuousState_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.VectorBase_[AutoDiffXd]</span></span></dt>
<dd><p>Returns a mutable reference to the entire continuous state vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ContinuousState_[AutoDiffXd].get_vector(self:</span> <span class="pre">pydrake.systems.framework.ContinuousState_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.VectorBase_[AutoDiffXd]</span></span></dt>
<dd><p>Returns a reference to the entire continuous state vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ContinuousState_[AutoDiffXd].num_q(self:</span> <span class="pre">pydrake.systems.framework.ContinuousState_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the number of generalized positions q in this state vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ContinuousState_[AutoDiffXd].num_v(self:</span> <span class="pre">pydrake.systems.framework.ContinuousState_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the number of generalized velocities v in this state vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ContinuousState_[AutoDiffXd].num_z(self:</span> <span class="pre">pydrake.systems.framework.ContinuousState_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the number of miscellaneous continuous state variables z in
this state vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ContinuousState_[AutoDiffXd].SetFrom(self:</span> <span class="pre">pydrake.systems.framework.ContinuousState_[AutoDiffXd],</span> <span class="pre">arg0:</span> <span class="pre">pydrake.systems.framework.ContinuousState)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Copies the values from <code class="docutils literal notranslate"><span class="pre">other</span></code> into <code class="docutils literal notranslate"><span class="pre">this</span></code>, converting the scalar
type as necessary.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ContinuousState_[AutoDiffXd].SetFromVector(self:</span> <span class="pre">pydrake.systems.framework.ContinuousState_[AutoDiffXd],</span> <span class="pre">value:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the entire continuous state vector from an Eigen expression.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ContinuousState_[AutoDiffXd].size(self:</span> <span class="pre">pydrake.systems.framework.ContinuousState_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the size of the entire continuous state vector, which is
necessarily <code class="docutils literal notranslate"><span class="pre">num_q</span> <span class="pre">+</span> <span class="pre">num_v</span> <span class="pre">+</span> <span class="pre">num_z</span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ContinuousState_[Expression]</span></span></dt>
<dd><p>%ContinuousState is a view of, and optionally a container for, all the
continuous state variables <code class="docutils literal notranslate"><span class="pre">xc</span></code> of a Drake System. Continuous state
variables are those whose values are defined by differential
equations, so we expect there to be a well-defined time derivative
<code class="docutils literal notranslate"><span class="pre">xcdot</span></code> ≜ <code class="docutils literal notranslate"><span class="pre">d/dt</span> <span class="pre">xc</span></code>.</p>
<p>The contents of <code class="docutils literal notranslate"><span class="pre">xc</span></code> are conceptually partitioned into three groups:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">q</span></code> is generalized position</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">v</span></code> is generalized velocity</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">z</span></code> is other continuous state</p></li>
</ul>
<p>For a Drake LeafSystem these partitions are stored contiguously in
memory in this sequence: xc=[q v z]. But because a Drake System may be
a Diagram composed from subsystems, each with its own continuous state
variables (“substates”), the composite continuous state will not
generally be stored in contiguous memory. In that case the most we can
say is that xc={q,v,z}, that is, it consists of all the q’s, v’s, and
z’s, in some order.</p>
<p>Nevertheless, this ContinuousState class provides a vector view of the
data that groups together all the q partitions, v partitions, and z
partitions. For example, if there are three subsystems (possibly
Diagrams) whose continuous state variables are respectively
xc₁={q₁,v₁,z₁}, xc₂={q₂,v₂,z₂}, and xc₃={q₃,v₃,z₃} the composite xc
includes all the partitions in an undefined order. However, composite
q, v, and z appear ordered as q=[q₁ q₂ q₃], v=[v₁ v₂ v₃], z=[z₁ z₂
z₃]. Note that the element ordering of the composite xc is <em>not</em> a
concatenation of the composite subgroups. Do not index elements of the
full state xc unless you know it is the continuous state of a
LeafSystem (a LeafSystem looking at its own Context can depend on
that).</p>
<p>Any of the groups may be empty. However, groups q and v must be either
both present or both empty, because the time derivative <code class="docutils literal notranslate"><span class="pre">qdot</span></code> of
the second-order state variables <code class="docutils literal notranslate"><span class="pre">q</span></code> must be computable using a
linear mapping <code class="docutils literal notranslate"><span class="pre">qdot=N(q)*v</span></code>.</p>
<p>The time derivative <code class="docutils literal notranslate"><span class="pre">xcdot</span></code> has the identical substructure to
<code class="docutils literal notranslate"><span class="pre">xc</span></code>, with the partitions interpreted as <code class="docutils literal notranslate"><span class="pre">qdot</span></code>, <cite>vdot</cite>, and
<code class="docutils literal notranslate"><span class="pre">zdot</span></code>. We use identical ContinuousState objects for both.</p>
<p><em>Memory ownership</em></p>
<p>When a ContinuousState represents the state of a LeafSystem, it always
owns the memory that is used for the state variables and is
responsible for destruction. For a Diagram, ContinuousState can
instead be a <em>view</em> of the underlying LeafSystem substates, so that
modifying the Diagram’s continuous state affects the LeafSystems
appropriately. In that case, the memory is owned by the underlying
LeafSystems. However, when a ContinuousState object of any structure
is cloned, the resulting object <em>always</em> owns all its underlying
memory, which is initialized with a copy of the original state
variable values but is otherwise independent. The cloned object
retains the structure and ordering of the elements and does not
guarantee contiguous storage.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DiagramContinuousState for more information.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ContinuousState_[Expression].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.systems.framework.ContinuousState_[Expression]) -&gt; None</p></li>
</ol>
<p>Constructs a zero-length ContinuousState.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.systems.framework.ContinuousState_[Expression], state: pydrake.systems.framework.BasicVector_[Expression]) -&gt; None</p></li>
</ol>
<p>Constructs a ContinuousState for a system that does not have
second-order structure. The <code class="docutils literal notranslate"><span class="pre">q</span></code> and <code class="docutils literal notranslate"><span class="pre">v</span></code> partitions are empty; all
of the state <code class="docutils literal notranslate"><span class="pre">xc</span></code> is miscellaneous continuous state <code class="docutils literal notranslate"><span class="pre">z</span></code>.</p>
<ol class="arabic simple" start="3">
<li><p>__init__(self: pydrake.systems.framework.ContinuousState_[Expression], state: pydrake.systems.framework.BasicVector_[Expression], num_q: int, num_v: int, num_z: int) -&gt; None</p></li>
</ol>
<p>Constructs a ContinuousState that exposes second-order structure.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">state</span></code>:</dt><dd><p>The source xc of continuous state information.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">num_q</span></code>:</dt><dd><p>The number of position variables q.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">num_v</span></code>:</dt><dd><p>The number of velocity variables v.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">num_z</span></code>:</dt><dd><p>The number of other continuous variables z.</p>
</dd>
</dl>
<p>We require that <code class="docutils literal notranslate"><span class="pre">num_q</span> <span class="pre">≥</span> <span class="pre">num_v</span></code> and that the sum of the partition
sizes adds up to the size of <code class="docutils literal notranslate"><span class="pre">state</span></code>.</p>
<ol class="arabic simple" start="4">
<li><p>__init__(self: pydrake.systems.framework.ContinuousState_[Expression], state: pydrake.systems.framework.VectorBase_[Expression]) -&gt; None</p></li>
</ol>
<p>Constructs a ContinuousState for a system that does not have
second-order structure. The <code class="docutils literal notranslate"><span class="pre">q</span></code> and <code class="docutils literal notranslate"><span class="pre">v</span></code> partitions are empty; all
of the state <code class="docutils literal notranslate"><span class="pre">xc</span></code> is miscellaneous continuous state <code class="docutils literal notranslate"><span class="pre">z</span></code>.</p>
<ol class="arabic simple" start="5">
<li><p>__init__(self: pydrake.systems.framework.ContinuousState_[Expression], state: pydrake.systems.framework.VectorBase_[Expression], num_q: int, num_v: int, num_z: int) -&gt; None</p></li>
</ol>
<p>Constructs a ContinuousState that exposes second-order structure.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">state</span></code>:</dt><dd><p>The source xc of continuous state information.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">num_q</span></code>:</dt><dd><p>The number of position variables q.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">num_v</span></code>:</dt><dd><p>The number of velocity variables v.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">num_z</span></code>:</dt><dd><p>The number of other continuous variables z.</p>
</dd>
</dl>
<p>We require that <code class="docutils literal notranslate"><span class="pre">num_q</span> <span class="pre">≥</span> <span class="pre">num_v</span></code> and that the sum of the partition
sizes adds up to the size of <code class="docutils literal notranslate"><span class="pre">state</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ContinuousState_[Expression].Clone(self:</span> <span class="pre">pydrake.systems.framework.ContinuousState_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.ContinuousState_[Expression]</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ContinuousState_[Expression].CopyToVector(self:</span> <span class="pre">pydrake.systems.framework.ContinuousState_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns a copy of the entire continuous state vector into an Eigen
vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ContinuousState_[Expression].get_generalized_position(self:</span> <span class="pre">pydrake.systems.framework.ContinuousState_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.VectorBase_[Expression]</span></span></dt>
<dd><p>Returns a const reference to the subset of the state vector that is
generalized position <code class="docutils literal notranslate"><span class="pre">q</span></code>. May be zero length.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ContinuousState_[Expression].get_generalized_velocity(self:</span> <span class="pre">pydrake.systems.framework.ContinuousState_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.VectorBase_[Expression]</span></span></dt>
<dd><p>Returns a const reference to the subset of the continuous state vector
that is generalized velocity <code class="docutils literal notranslate"><span class="pre">v</span></code>. May be zero length.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ContinuousState_[Expression].get_misc_continuous_state(self:</span> <span class="pre">pydrake.systems.framework.ContinuousState_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.VectorBase_[Expression]</span></span></dt>
<dd><p>Returns a const reference to the subset of the continuous state vector
that is other continuous state <code class="docutils literal notranslate"><span class="pre">z</span></code>. May be zero length.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ContinuousState_[Expression].get_mutable_generalized_position(self:</span> <span class="pre">pydrake.systems.framework.ContinuousState_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.VectorBase_[Expression]</span></span></dt>
<dd><p>Returns a mutable reference to the subset of the state vector that is
generalized position <code class="docutils literal notranslate"><span class="pre">q</span></code>. May be zero length.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ContinuousState_[Expression].get_mutable_generalized_velocity(self:</span> <span class="pre">pydrake.systems.framework.ContinuousState_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.VectorBase_[Expression]</span></span></dt>
<dd><p>Returns a mutable reference to the subset of the continuous state
vector that is generalized velocity <code class="docutils literal notranslate"><span class="pre">v</span></code>. May be zero length.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ContinuousState_[Expression].get_mutable_misc_continuous_state(self:</span> <span class="pre">pydrake.systems.framework.ContinuousState_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.VectorBase_[Expression]</span></span></dt>
<dd><p>Returns a mutable reference to the subset of the continuous state
vector that is other continuous state <code class="docutils literal notranslate"><span class="pre">z</span></code>. May be zero length.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ContinuousState_[Expression].get_mutable_vector(self:</span> <span class="pre">pydrake.systems.framework.ContinuousState_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.VectorBase_[Expression]</span></span></dt>
<dd><p>Returns a mutable reference to the entire continuous state vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ContinuousState_[Expression].get_vector(self:</span> <span class="pre">pydrake.systems.framework.ContinuousState_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.VectorBase_[Expression]</span></span></dt>
<dd><p>Returns a reference to the entire continuous state vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ContinuousState_[Expression].num_q(self:</span> <span class="pre">pydrake.systems.framework.ContinuousState_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the number of generalized positions q in this state vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ContinuousState_[Expression].num_v(self:</span> <span class="pre">pydrake.systems.framework.ContinuousState_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the number of generalized velocities v in this state vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ContinuousState_[Expression].num_z(self:</span> <span class="pre">pydrake.systems.framework.ContinuousState_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the number of miscellaneous continuous state variables z in
this state vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ContinuousState_[Expression].SetFrom(self:</span> <span class="pre">pydrake.systems.framework.ContinuousState_[Expression],</span> <span class="pre">arg0:</span> <span class="pre">pydrake.systems.framework.ContinuousState)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Copies the values from <code class="docutils literal notranslate"><span class="pre">other</span></code> into <code class="docutils literal notranslate"><span class="pre">this</span></code>, converting the scalar
type as necessary.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ContinuousState_[Expression].SetFromVector(self:</span> <span class="pre">pydrake.systems.framework.ContinuousState_[Expression],</span> <span class="pre">value:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the entire continuous state vector from an Eigen expression.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ContinuousState_[Expression].size(self:</span> <span class="pre">pydrake.systems.framework.ContinuousState_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the size of the entire continuous state vector, which is
necessarily <code class="docutils literal notranslate"><span class="pre">num_q</span> <span class="pre">+</span> <span class="pre">num_v</span> <span class="pre">+</span> <span class="pre">num_z</span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ContinuousStateIndex</span></span></dt>
<dd><dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ContinuousStateIndex.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.systems.framework.ContinuousStateIndex) -&gt; None</p></li>
</ol>
<p>Default constructor; the result is an <em>invalid</em> index. This only
exists to serve applications which require a default constructor.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.systems.framework.ContinuousStateIndex, arg0: int) -&gt; None</p></li>
</ol>
<p>Construction from a non-negative <code class="docutils literal notranslate"><span class="pre">int</span></code> value. The value must lie in
the range of [0, 2³¹). Constructor only promises to test validity in
Debug build.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ContinuousStateIndex.is_valid(self:</span> <span class="pre">pydrake.systems.framework.ContinuousStateIndex)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Reports if the index is valid–the only operation on an invalid index
that doesn’t throw an exception in Debug builds.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DependencyTicket</span></span></dt>
<dd><dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DependencyTicket.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.systems.framework.DependencyTicket) -&gt; None</p></li>
</ol>
<p>Default constructor; the result is an <em>invalid</em> index. This only
exists to serve applications which require a default constructor.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.systems.framework.DependencyTicket, arg0: int) -&gt; None</p></li>
</ol>
<p>Construction from a non-negative <code class="docutils literal notranslate"><span class="pre">int</span></code> value. The value must lie in
the range of [0, 2³¹). Constructor only promises to test validity in
Debug build.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DependencyTicket.is_valid(self:</span> <span class="pre">pydrake.systems.framework.DependencyTicket)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Reports if the index is valid–the only operation on an invalid index
that doesn’t throw an exception in Debug builds.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Diagram</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.System</span></code></p>
<p>Diagram is a System composed of one or more constituent Systems,
arranged in a directed graph where the vertices are the constituent
Systems themselves, and the edges connect the output of one
constituent System to the input of another. To construct a Diagram,
use a DiagramBuilder.</p>
<p>Each System in the Diagram must have a unique, non-empty name.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">Diagram_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Diagram.__init__(self:</span> <span class="pre">pydrake.systems.framework.Diagram)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructs an uninitialized Diagram. Subclasses that use this
constructor are obligated to call DiagramBuilder::BuildInto(this).
Provides scalar- type conversion support only if every contained
subsystem provides the same support.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Diagram.connection_map(self:</span> <span class="pre">pydrake.systems.framework.Diagram)</span> <span class="pre">-&gt;</span> <span class="pre">dict</span></span></dt>
<dd><p>Returns a reference to the map of connections between Systems.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Diagram.get_output_port_locator(self:</span> <span class="pre">pydrake.systems.framework.Diagram,</span> <span class="pre">port_index:</span> <span class="pre">pydrake.systems.framework.OutputPortIndex)</span> <span class="pre">-&gt;</span> <span class="pre">tuple</span></span></dt>
<dd><p>Returns the “locator” for the subsystem output port that was exported
as the <code class="docutils literal notranslate"><span class="pre">port_index</span></code> output port for the Diagram.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Diagram.GetInputPortLocators(self:</span> <span class="pre">pydrake.systems.framework.Diagram,</span> <span class="pre">port_index:</span> <span class="pre">pydrake.systems.framework.InputPortIndex)</span> <span class="pre">-&gt;</span> <span class="pre">list</span></span></dt>
<dd><p>Returns the collection of “locators” for the subsystem input ports
that were exported or connected to the <code class="docutils literal notranslate"><span class="pre">port_index</span></code> input port for
the Diagram.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Diagram.GetMutableSubsystemState(self:</span> <span class="pre">pydrake.systems.framework.Diagram,</span> <span class="pre">arg0:</span> <span class="pre">pydrake.systems.framework.System,</span> <span class="pre">arg1:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.State</span></span></dt>
<dd><p>Retrieves the state for a particular subsystem from the context for
the entire diagram. Invalidates all entries in that subsystem’s cache
that depend on State. Aborts if <code class="docutils literal notranslate"><span class="pre">subsystem</span></code> is not actually a
subsystem of this diagram.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Diagram.GetSubsystemByName(self:</span> <span class="pre">pydrake.systems.framework.Diagram,</span> <span class="pre">name:</span> <span class="pre">str)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.System</span></span></dt>
<dd><p>Retrieves a const reference to the subsystem with name <code class="docutils literal notranslate"><span class="pre">name</span></code>
returned by get_name().</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if a match cannot be found.</strong> – </p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>GetDowncastSubsystemByName()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>System&lt;T&gt;::get_name()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Diagram.GetSystems(self:</span> <span class="pre">pydrake.systems.framework.Diagram)</span> <span class="pre">-&gt;</span> <span class="pre">list[pydrake.systems.framework.System]</span></span></dt>
<dd><p>Returns the list of contained Systems.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Diagram.HasSubsystemNamed(self:</span> <span class="pre">pydrake.systems.framework.Diagram,</span> <span class="pre">name:</span> <span class="pre">str)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns true iff this contains a subsystem with the given name.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>GetSubsystemByName()</p>
</div>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Diagram_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">Diagram_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Diagram_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Diagram_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Diagram_[AutoDiffXd]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.System_[AutoDiffXd]</span></code></p>
<p>Diagram is a System composed of one or more constituent Systems,
arranged in a directed graph where the vertices are the constituent
Systems themselves, and the edges connect the output of one
constituent System to the input of another. To construct a Diagram,
use a DiagramBuilder.</p>
<p>Each System in the Diagram must have a unique, non-empty name.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Diagram_[AutoDiffXd].__init__(self:</span> <span class="pre">pydrake.systems.framework.Diagram_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructs an uninitialized Diagram. Subclasses that use this
constructor are obligated to call DiagramBuilder::BuildInto(this).
Provides scalar- type conversion support only if every contained
subsystem provides the same support.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Diagram_[AutoDiffXd].connection_map(self:</span> <span class="pre">pydrake.systems.framework.Diagram_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">dict</span></span></dt>
<dd><p>Returns a reference to the map of connections between Systems.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Diagram_[AutoDiffXd].get_output_port_locator(self:</span> <span class="pre">pydrake.systems.framework.Diagram_[AutoDiffXd],</span> <span class="pre">port_index:</span> <span class="pre">pydrake.systems.framework.OutputPortIndex)</span> <span class="pre">-&gt;</span> <span class="pre">tuple</span></span></dt>
<dd><p>Returns the “locator” for the subsystem output port that was exported
as the <code class="docutils literal notranslate"><span class="pre">port_index</span></code> output port for the Diagram.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Diagram_[AutoDiffXd].GetInputPortLocators(self:</span> <span class="pre">pydrake.systems.framework.Diagram_[AutoDiffXd],</span> <span class="pre">port_index:</span> <span class="pre">pydrake.systems.framework.InputPortIndex)</span> <span class="pre">-&gt;</span> <span class="pre">list</span></span></dt>
<dd><p>Returns the collection of “locators” for the subsystem input ports
that were exported or connected to the <code class="docutils literal notranslate"><span class="pre">port_index</span></code> input port for
the Diagram.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Diagram_[AutoDiffXd].GetMutableSubsystemState(self:</span> <span class="pre">pydrake.systems.framework.Diagram_[AutoDiffXd],</span> <span class="pre">arg0:</span> <span class="pre">pydrake.systems.framework.System_[AutoDiffXd],</span> <span class="pre">arg1:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.State_[AutoDiffXd]</span></span></dt>
<dd><p>Retrieves the state for a particular subsystem from the context for
the entire diagram. Invalidates all entries in that subsystem’s cache
that depend on State. Aborts if <code class="docutils literal notranslate"><span class="pre">subsystem</span></code> is not actually a
subsystem of this diagram.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Diagram_[AutoDiffXd].GetSubsystemByName(self:</span> <span class="pre">pydrake.systems.framework.Diagram_[AutoDiffXd],</span> <span class="pre">name:</span> <span class="pre">str)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.System_[AutoDiffXd]</span></span></dt>
<dd><p>Retrieves a const reference to the subsystem with name <code class="docutils literal notranslate"><span class="pre">name</span></code>
returned by get_name().</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if a match cannot be found.</strong> – </p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>GetDowncastSubsystemByName()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>System&lt;T&gt;::get_name()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Diagram_[AutoDiffXd].GetSystems(self:</span> <span class="pre">pydrake.systems.framework.Diagram_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">list[pydrake.systems.framework.System_[AutoDiffXd]]</span></span></dt>
<dd><p>Returns the list of contained Systems.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Diagram_[AutoDiffXd].HasSubsystemNamed(self:</span> <span class="pre">pydrake.systems.framework.Diagram_[AutoDiffXd],</span> <span class="pre">name:</span> <span class="pre">str)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns true iff this contains a subsystem with the given name.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>GetSubsystemByName()</p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Diagram_[Expression]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.System_[Expression]</span></code></p>
<p>Diagram is a System composed of one or more constituent Systems,
arranged in a directed graph where the vertices are the constituent
Systems themselves, and the edges connect the output of one
constituent System to the input of another. To construct a Diagram,
use a DiagramBuilder.</p>
<p>Each System in the Diagram must have a unique, non-empty name.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Diagram_[Expression].__init__(self:</span> <span class="pre">pydrake.systems.framework.Diagram_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructs an uninitialized Diagram. Subclasses that use this
constructor are obligated to call DiagramBuilder::BuildInto(this).
Provides scalar- type conversion support only if every contained
subsystem provides the same support.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Diagram_[Expression].connection_map(self:</span> <span class="pre">pydrake.systems.framework.Diagram_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">dict</span></span></dt>
<dd><p>Returns a reference to the map of connections between Systems.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Diagram_[Expression].get_output_port_locator(self:</span> <span class="pre">pydrake.systems.framework.Diagram_[Expression],</span> <span class="pre">port_index:</span> <span class="pre">pydrake.systems.framework.OutputPortIndex)</span> <span class="pre">-&gt;</span> <span class="pre">tuple</span></span></dt>
<dd><p>Returns the “locator” for the subsystem output port that was exported
as the <code class="docutils literal notranslate"><span class="pre">port_index</span></code> output port for the Diagram.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Diagram_[Expression].GetInputPortLocators(self:</span> <span class="pre">pydrake.systems.framework.Diagram_[Expression],</span> <span class="pre">port_index:</span> <span class="pre">pydrake.systems.framework.InputPortIndex)</span> <span class="pre">-&gt;</span> <span class="pre">list</span></span></dt>
<dd><p>Returns the collection of “locators” for the subsystem input ports
that were exported or connected to the <code class="docutils literal notranslate"><span class="pre">port_index</span></code> input port for
the Diagram.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Diagram_[Expression].GetMutableSubsystemState(self:</span> <span class="pre">pydrake.systems.framework.Diagram_[Expression],</span> <span class="pre">arg0:</span> <span class="pre">pydrake.systems.framework.System_[Expression],</span> <span class="pre">arg1:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.State_[Expression]</span></span></dt>
<dd><p>Retrieves the state for a particular subsystem from the context for
the entire diagram. Invalidates all entries in that subsystem’s cache
that depend on State. Aborts if <code class="docutils literal notranslate"><span class="pre">subsystem</span></code> is not actually a
subsystem of this diagram.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Diagram_[Expression].GetSubsystemByName(self:</span> <span class="pre">pydrake.systems.framework.Diagram_[Expression],</span> <span class="pre">name:</span> <span class="pre">str)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.System_[Expression]</span></span></dt>
<dd><p>Retrieves a const reference to the subsystem with name <code class="docutils literal notranslate"><span class="pre">name</span></code>
returned by get_name().</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if a match cannot be found.</strong> – </p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>GetDowncastSubsystemByName()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>System&lt;T&gt;::get_name()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Diagram_[Expression].GetSystems(self:</span> <span class="pre">pydrake.systems.framework.Diagram_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">list[pydrake.systems.framework.System_[Expression]]</span></span></dt>
<dd><p>Returns the list of contained Systems.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Diagram_[Expression].HasSubsystemNamed(self:</span> <span class="pre">pydrake.systems.framework.Diagram_[Expression],</span> <span class="pre">name:</span> <span class="pre">str)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns true iff this contains a subsystem with the given name.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>GetSubsystemByName()</p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiagramBuilder</span></span></dt>
<dd><p>DiagramBuilder is a factory class for Diagram.</p>
<p>It is single use: after calling Build or BuildInto, DiagramBuilder
gives up ownership of the constituent systems, and should therefore be
discarded; all member functions will throw an exception after this
point.</p>
<p>When a Diagram (or DiagramBuilder) that owns systems is destroyed, the
systems will be destroyed in the reverse of the order they were added.</p>
<p>A system must be added to the DiagramBuilder with AddSystem or
AddNamedSystem before it can be wired up in any way. Every system must
have a unique, non-empty name.</p>
<section id="building-large-diagrams">
<h2>Building large Diagrams<a class="headerlink" href="#building-large-diagrams" title="Link to this heading"></a></h2>
<p>When building large Diagrams with many added systems and input-output
port connections, the runtime performance of DiagramBuilder::Build()
might become relevant.</p>
<p>As part of its correctness checks, the DiagramBuilder::Build()
function performs a graph search of the diagram’s dependencies. In the
graph, the nodes are the child systems that have been added to the
diagram, and the edges are the diagram connections from one child’s
output port to another child’s input port(s). The builder must confirm
that the graph is acyclic; a cycle would imply an infinite loop in an
output calculation function. With a large graph, this check can be
computationally expensive. To speed it up, ensure that your output
ports do not gratuitously depend on irrelevant input ports.</p>
<p>The dependencies are supplied via the <code class="docutils literal notranslate"><span class="pre">prerequisites_of_calc</span></code>
argument to DeclareOutputPort family of functions. If the default
value is used (i.e., when no prerequisites are provided), the default
is to assume the output port value is dependent on all possible
sources.</p>
<p>Refer to the DeclareLeafOutputPort_feedthrough “Direct feedthrough”
documentation for additional details and examples. In particular, the
SystemBase::all_sources_except_input_ports_ticket() is a convenient
shortcut for outputs that do not depend on any inputs.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">DiagramBuilder_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiagramBuilder.__init__(self:</span> <span class="pre">pydrake.systems.framework.DiagramBuilder)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiagramBuilder.AddNamedSystem(self:</span> <span class="pre">pydrake.systems.framework.DiagramBuilder,</span> <span class="pre">name:</span> <span class="pre">str,</span> <span class="pre">system:</span> <span class="pre">pydrake.systems.framework.System)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.System</span></span></dt>
<dd><p>Takes ownership of <code class="docutils literal notranslate"><span class="pre">system</span></code>, sets its name to <code class="docutils literal notranslate"><span class="pre">name</span></code>, and adds it
to the builder. Returns a bare pointer to the System, which will
remain valid for the lifetime of the Diagram built by this builder.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>a System may only be added to at most one DiagramBuilder. Multiple
Diagram instances cannot share the same System.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiagramBuilder.AddSystem(self:</span> <span class="pre">pydrake.systems.framework.DiagramBuilder,</span> <span class="pre">system:</span> <span class="pre">pydrake.systems.framework.System)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.System</span></span></dt>
<dd><p>Takes ownership of <code class="docutils literal notranslate"><span class="pre">system</span></code> and adds it to the builder. Returns a
bare pointer to the System, which will remain valid for the lifetime
of the Diagram built by this builder.</p>
<p>If the system’s name is unset, sets it to
System::GetMemoryObjectName() as a default in order to have unique
names within the diagram.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>a System may only be added to at most one DiagramBuilder. Multiple
Diagram instances cannot share the same System.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiagramBuilder.already_built(self:</span> <span class="pre">pydrake.systems.framework.DiagramBuilder)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns true iff Build() or BuildInto() has been called on this
Builder, in which case it’s an error to call any member function other
than the the destructor.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiagramBuilder.Build(self:</span> <span class="pre">pydrake.systems.framework.DiagramBuilder)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.Diagram</span></span></dt>
<dd><p>Builds the Diagram that has been described by the calls to Connect,
ExportInput, and ExportOutput.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if the graph is not buildable.</strong> – </p>
</dd>
</dl>
<p>See DiagramBuilder_feedthrough “Building large Diagrams” for tips on
improving runtime performance of this function.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiagramBuilder.BuildInto(self:</span> <span class="pre">pydrake.systems.framework.DiagramBuilder,</span> <span class="pre">target:</span> <span class="pre">pydrake.systems.framework.Diagram)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Configures <code class="docutils literal notranslate"><span class="pre">target</span></code> to have the topology that has been described by
the calls to Connect, ExportInput, and ExportOutput.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if the graph is not buildable.</strong> – </p>
</dd>
</dl>
<p>Only Diagram subclasses should call this method. The target must not
already be initialized.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiagramBuilder.Connect(self:</span> <span class="pre">pydrake.systems.framework.DiagramBuilder,</span> <span class="pre">arg0:</span> <span class="pre">pydrake.systems.framework.OutputPort,</span> <span class="pre">arg1:</span> <span class="pre">pydrake.systems.framework.InputPort)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Declares that input port <code class="docutils literal notranslate"><span class="pre">dest</span></code> is connected to output port <code class="docutils literal notranslate"><span class="pre">src</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The connection created between <code class="docutils literal notranslate"><span class="pre">src</span></code> and <code class="docutils literal notranslate"><span class="pre">dest</span></code> via a call to
this method can be effectively overridden by any subsequent call
to InputPort::FixValue(). That is, calling InputPort::FixValue()
on an already connected input port causes the resultant
FixedInputPortValue to override any other value present on that
port.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiagramBuilder.ConnectInput(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>ConnectInput(self: pydrake.systems.framework.DiagramBuilder, diagram_port_name: str, input: pydrake.systems.framework.InputPort) -&gt; None</p></li>
</ol>
<p>Connects an input to the entire Diagram, indicated by
<code class="docutils literal notranslate"><span class="pre">diagram_port_name</span></code>, to the given <code class="docutils literal notranslate"><span class="pre">input</span></code> port of a constituent
system.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>The Diagram input indicated by <code class="docutils literal notranslate"><span class="pre">diagram_port_name</span></code> must have
been previously built via ExportInput().</p>
</dd>
<dt>Postcondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">input</span></code> is connected to the indicated Diagram input port.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>ConnectInput(self: pydrake.systems.framework.DiagramBuilder, diagram_port_index: pydrake.systems.framework.InputPortIndex, input: pydrake.systems.framework.InputPort) -&gt; None</p></li>
</ol>
<p>Connects an input to the entire Diagram, indicated by
<code class="docutils literal notranslate"><span class="pre">diagram_port_index</span></code>, to the given <code class="docutils literal notranslate"><span class="pre">input</span></code> port of a constituent
system.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>The Diagram input indicated by <code class="docutils literal notranslate"><span class="pre">diagram_port_index</span></code> must have
been previously built via ExportInput().</p>
</dd>
<dt>Postcondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">input</span></code> is connected to the indicated Diagram input port.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiagramBuilder.connection_map(self:</span> <span class="pre">pydrake.systems.framework.DiagramBuilder)</span> <span class="pre">-&gt;</span> <span class="pre">dict</span></span></dt>
<dd><p>(Advanced) Returns a reference to the map of connections between
Systems. The reference becomes invalid upon any call to Build or
BuildInto.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiagramBuilder.ConnectToSame(self:</span> <span class="pre">pydrake.systems.framework.DiagramBuilder,</span> <span class="pre">exemplar:</span> <span class="pre">pydrake.systems.framework.InputPort,</span> <span class="pre">dest:</span> <span class="pre">pydrake.systems.framework.InputPort)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Connects <code class="docutils literal notranslate"><span class="pre">dest</span></code> to the same source as <code class="docutils literal notranslate"><span class="pre">exemplar</span></code> is connected to.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">exemplar</span></code> was connected to an output port, then <code class="docutils literal notranslate"><span class="pre">dest</span></code> is
connected to that same output. Or, if <code class="docutils literal notranslate"><span class="pre">exemplar</span></code> was exported as an
input of this diagram, then <code class="docutils literal notranslate"><span class="pre">dest</span></code> will be connected to that same
diagram input. Or, if <code class="docutils literal notranslate"><span class="pre">exemplar</span></code> was neither connected or exported,
then this function is a no-op.</p>
<p>Both <code class="docutils literal notranslate"><span class="pre">exemplar</span></code> and <code class="docutils literal notranslate"><span class="pre">dest</span></code> must be ports of constituent systems
that have already been added to this diagram.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>True iff any connection or was made; or false when a no-op.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiagramBuilder.Disconnect(self:</span> <span class="pre">pydrake.systems.framework.DiagramBuilder,</span> <span class="pre">source:</span> <span class="pre">pydrake.systems.framework.OutputPort,</span> <span class="pre">dest:</span> <span class="pre">pydrake.systems.framework.InputPort)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Undoes a Connect() by disconnecting the given subsystem ports.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>connection_map()</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if the ports were not already connected.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiagramBuilder.empty(self:</span> <span class="pre">pydrake.systems.framework.DiagramBuilder)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns whether any Systems have been added yet.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiagramBuilder.ExportInput(self:</span> <span class="pre">pydrake.systems.framework.DiagramBuilder,</span> <span class="pre">input:</span> <span class="pre">pydrake.systems.framework.InputPort,</span> <span class="pre">name:</span> <span class="pre">Union[str,</span> <span class="pre">pydrake.systems.framework.UseDefaultName]</span> <span class="pre">=</span> <span class="pre">kUseDefaultName)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.InputPortIndex</span></span></dt>
<dd><p>Declares that the given <code class="docutils literal notranslate"><span class="pre">input</span></code> port of a constituent system is
connected to a new input to the entire Diagram. <code class="docutils literal notranslate"><span class="pre">name</span></code> is an
optional name for the new input port; if it is unspecified, then a
default name will be provided.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>If supplied at all, <code class="docutils literal notranslate"><span class="pre">name</span></code> must not be empty.</p>
</dd>
<dt>Precondition:</dt><dd><p>A port indicated by the resolution of <code class="docutils literal notranslate"><span class="pre">name</span></code> must not exist.</p>
</dd>
<dt>Postcondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">input</span></code> is connected to the new exported input port.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The index of the exported input port of the entire diagram.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiagramBuilder.ExportOutput(self:</span> <span class="pre">pydrake.systems.framework.DiagramBuilder,</span> <span class="pre">output:</span> <span class="pre">pydrake.systems.framework.OutputPort,</span> <span class="pre">name:</span> <span class="pre">Union[str,</span> <span class="pre">pydrake.systems.framework.UseDefaultName]</span> <span class="pre">=</span> <span class="pre">kUseDefaultName)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.OutputPortIndex</span></span></dt>
<dd><p>Declares that the given <code class="docutils literal notranslate"><span class="pre">output</span></code> port of a constituent system is an
output of the entire diagram. <code class="docutils literal notranslate"><span class="pre">name</span></code> is an optional name for the
output port; if it is unspecified, then a default name will be
provided.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>If supplied at all, <code class="docutils literal notranslate"><span class="pre">name</span></code> must not be empty.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The index of the exported output port of the entire diagram.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiagramBuilder.GetMutableSubsystemByName(self:</span> <span class="pre">pydrake.systems.framework.DiagramBuilder,</span> <span class="pre">name:</span> <span class="pre">str)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.System</span></span></dt>
<dd><p>Retrieves a mutable reference to the subsystem with name <code class="docutils literal notranslate"><span class="pre">name</span></code>
returned by get_name().</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if a unique match cannot be found.</strong> – </p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>System&lt;T&gt;::get_name()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>GetSubsystemByName()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>GetMutableDowncastSubsystemByName()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiagramBuilder.GetMutableSystems(self:</span> <span class="pre">pydrake.systems.framework.DiagramBuilder)</span> <span class="pre">-&gt;</span> <span class="pre">list[pydrake.systems.framework.System]</span></span></dt>
<dd><p>Returns the list of contained Systems.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>GetMutableSubsystemByName()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>GetSystems()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiagramBuilder.GetSubsystemByName(self:</span> <span class="pre">pydrake.systems.framework.DiagramBuilder,</span> <span class="pre">name:</span> <span class="pre">str)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.System</span></span></dt>
<dd><p>Retrieves a const reference to the subsystem with name <code class="docutils literal notranslate"><span class="pre">name</span></code>
returned by get_name().</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if a unique match cannot be found.</strong> – </p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>System&lt;T&gt;::get_name()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>GetMutableSubsystemByName()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>GetDowncastSubsystemByName()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiagramBuilder.GetSystems(self:</span> <span class="pre">pydrake.systems.framework.DiagramBuilder)</span> <span class="pre">-&gt;</span> <span class="pre">list[pydrake.systems.framework.System]</span></span></dt>
<dd><p>Returns the list of contained Systems.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>GetSubsystemByName()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>GetMutableSystems()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiagramBuilder.HasSubsystemNamed(self:</span> <span class="pre">pydrake.systems.framework.DiagramBuilder,</span> <span class="pre">name:</span> <span class="pre">str)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns true iff this contains a subsystem with the given name.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>GetSubsystemByName()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiagramBuilder.IsConnectedOrExported(self:</span> <span class="pre">pydrake.systems.framework.DiagramBuilder,</span> <span class="pre">port:</span> <span class="pre">pydrake.systems.framework.InputPort)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns true iff the given input <code class="docutils literal notranslate"><span class="pre">port</span></code> of a constituent system is
either connected to another constituent system or exported as a
diagram input.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiagramBuilder.num_input_ports(self:</span> <span class="pre">pydrake.systems.framework.DiagramBuilder)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the current number of diagram input ports. The count may
change as more ports are exported.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiagramBuilder.num_output_ports(self:</span> <span class="pre">pydrake.systems.framework.DiagramBuilder)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the current number of diagram output outputs. The count may
change as more ports are exported.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiagramBuilder.RemoveSystem(self:</span> <span class="pre">pydrake.systems.framework.DiagramBuilder,</span> <span class="pre">system:</span> <span class="pre">pydrake.systems.framework.System)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Removes the given system from this builder and disconnects any
connections or exported ports associated with it.</p>
<p>Note that un-exporting this system’s ports might have a ripple effect
on other exported port index assignments. The relative order will
remain intact, but any “holes” created by this removal will be filled
in by decrementing the indices of all higher-numbered ports that
remain.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Because a DiagramBuilder owns the objects it contains, the system
will be deleted.</p>
</div>
</dd></dl>

</section>
</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiagramBuilder_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">DiagramBuilder_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">DiagramBuilder_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">DiagramBuilder_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiagramBuilder_[AutoDiffXd]</span></span></dt>
<dd><p>DiagramBuilder is a factory class for Diagram.</p>
<p>It is single use: after calling Build or BuildInto, DiagramBuilder
gives up ownership of the constituent systems, and should therefore be
discarded; all member functions will throw an exception after this
point.</p>
<p>When a Diagram (or DiagramBuilder) that owns systems is destroyed, the
systems will be destroyed in the reverse of the order they were added.</p>
<p>A system must be added to the DiagramBuilder with AddSystem or
AddNamedSystem before it can be wired up in any way. Every system must
have a unique, non-empty name.</p>
<section id="id1">
<h2>Building large Diagrams<a class="headerlink" href="#id1" title="Link to this heading"></a></h2>
<p>When building large Diagrams with many added systems and input-output
port connections, the runtime performance of DiagramBuilder::Build()
might become relevant.</p>
<p>As part of its correctness checks, the DiagramBuilder::Build()
function performs a graph search of the diagram’s dependencies. In the
graph, the nodes are the child systems that have been added to the
diagram, and the edges are the diagram connections from one child’s
output port to another child’s input port(s). The builder must confirm
that the graph is acyclic; a cycle would imply an infinite loop in an
output calculation function. With a large graph, this check can be
computationally expensive. To speed it up, ensure that your output
ports do not gratuitously depend on irrelevant input ports.</p>
<p>The dependencies are supplied via the <code class="docutils literal notranslate"><span class="pre">prerequisites_of_calc</span></code>
argument to DeclareOutputPort family of functions. If the default
value is used (i.e., when no prerequisites are provided), the default
is to assume the output port value is dependent on all possible
sources.</p>
<p>Refer to the DeclareLeafOutputPort_feedthrough “Direct feedthrough”
documentation for additional details and examples. In particular, the
SystemBase::all_sources_except_input_ports_ticket() is a convenient
shortcut for outputs that do not depend on any inputs.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiagramBuilder_[AutoDiffXd].__init__(self:</span> <span class="pre">pydrake.systems.framework.DiagramBuilder_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiagramBuilder_[AutoDiffXd].AddNamedSystem(self:</span> <span class="pre">pydrake.systems.framework.DiagramBuilder_[AutoDiffXd],</span> <span class="pre">name:</span> <span class="pre">str,</span> <span class="pre">system:</span> <span class="pre">pydrake.systems.framework.System_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.System_[AutoDiffXd]</span></span></dt>
<dd><p>Takes ownership of <code class="docutils literal notranslate"><span class="pre">system</span></code>, sets its name to <code class="docutils literal notranslate"><span class="pre">name</span></code>, and adds it
to the builder. Returns a bare pointer to the System, which will
remain valid for the lifetime of the Diagram built by this builder.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>a System may only be added to at most one DiagramBuilder. Multiple
Diagram instances cannot share the same System.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiagramBuilder_[AutoDiffXd].AddSystem(self:</span> <span class="pre">pydrake.systems.framework.DiagramBuilder_[AutoDiffXd],</span> <span class="pre">system:</span> <span class="pre">pydrake.systems.framework.System_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.System_[AutoDiffXd]</span></span></dt>
<dd><p>Takes ownership of <code class="docutils literal notranslate"><span class="pre">system</span></code> and adds it to the builder. Returns a
bare pointer to the System, which will remain valid for the lifetime
of the Diagram built by this builder.</p>
<p>If the system’s name is unset, sets it to
System::GetMemoryObjectName() as a default in order to have unique
names within the diagram.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>a System may only be added to at most one DiagramBuilder. Multiple
Diagram instances cannot share the same System.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiagramBuilder_[AutoDiffXd].already_built(self:</span> <span class="pre">pydrake.systems.framework.DiagramBuilder_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns true iff Build() or BuildInto() has been called on this
Builder, in which case it’s an error to call any member function other
than the the destructor.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiagramBuilder_[AutoDiffXd].Build(self:</span> <span class="pre">pydrake.systems.framework.DiagramBuilder_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.Diagram_[AutoDiffXd]</span></span></dt>
<dd><p>Builds the Diagram that has been described by the calls to Connect,
ExportInput, and ExportOutput.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if the graph is not buildable.</strong> – </p>
</dd>
</dl>
<p>See DiagramBuilder_feedthrough “Building large Diagrams” for tips on
improving runtime performance of this function.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiagramBuilder_[AutoDiffXd].BuildInto(self:</span> <span class="pre">pydrake.systems.framework.DiagramBuilder_[AutoDiffXd],</span> <span class="pre">target:</span> <span class="pre">pydrake.systems.framework.Diagram_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Configures <code class="docutils literal notranslate"><span class="pre">target</span></code> to have the topology that has been described by
the calls to Connect, ExportInput, and ExportOutput.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if the graph is not buildable.</strong> – </p>
</dd>
</dl>
<p>Only Diagram subclasses should call this method. The target must not
already be initialized.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiagramBuilder_[AutoDiffXd].Connect(self:</span> <span class="pre">pydrake.systems.framework.DiagramBuilder_[AutoDiffXd],</span> <span class="pre">arg0:</span> <span class="pre">pydrake.systems.framework.OutputPort_[AutoDiffXd],</span> <span class="pre">arg1:</span> <span class="pre">pydrake.systems.framework.InputPort_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Declares that input port <code class="docutils literal notranslate"><span class="pre">dest</span></code> is connected to output port <code class="docutils literal notranslate"><span class="pre">src</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The connection created between <code class="docutils literal notranslate"><span class="pre">src</span></code> and <code class="docutils literal notranslate"><span class="pre">dest</span></code> via a call to
this method can be effectively overridden by any subsequent call
to InputPort::FixValue(). That is, calling InputPort::FixValue()
on an already connected input port causes the resultant
FixedInputPortValue to override any other value present on that
port.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiagramBuilder_[AutoDiffXd].ConnectInput(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>ConnectInput(self: pydrake.systems.framework.DiagramBuilder_[AutoDiffXd], diagram_port_name: str, input: pydrake.systems.framework.InputPort_[AutoDiffXd]) -&gt; None</p></li>
</ol>
<p>Connects an input to the entire Diagram, indicated by
<code class="docutils literal notranslate"><span class="pre">diagram_port_name</span></code>, to the given <code class="docutils literal notranslate"><span class="pre">input</span></code> port of a constituent
system.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>The Diagram input indicated by <code class="docutils literal notranslate"><span class="pre">diagram_port_name</span></code> must have
been previously built via ExportInput().</p>
</dd>
<dt>Postcondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">input</span></code> is connected to the indicated Diagram input port.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>ConnectInput(self: pydrake.systems.framework.DiagramBuilder_[AutoDiffXd], diagram_port_index: pydrake.systems.framework.InputPortIndex, input: pydrake.systems.framework.InputPort_[AutoDiffXd]) -&gt; None</p></li>
</ol>
<p>Connects an input to the entire Diagram, indicated by
<code class="docutils literal notranslate"><span class="pre">diagram_port_index</span></code>, to the given <code class="docutils literal notranslate"><span class="pre">input</span></code> port of a constituent
system.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>The Diagram input indicated by <code class="docutils literal notranslate"><span class="pre">diagram_port_index</span></code> must have
been previously built via ExportInput().</p>
</dd>
<dt>Postcondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">input</span></code> is connected to the indicated Diagram input port.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiagramBuilder_[AutoDiffXd].connection_map(self:</span> <span class="pre">pydrake.systems.framework.DiagramBuilder_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">dict</span></span></dt>
<dd><p>(Advanced) Returns a reference to the map of connections between
Systems. The reference becomes invalid upon any call to Build or
BuildInto.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiagramBuilder_[AutoDiffXd].ConnectToSame(self:</span> <span class="pre">pydrake.systems.framework.DiagramBuilder_[AutoDiffXd],</span> <span class="pre">exemplar:</span> <span class="pre">pydrake.systems.framework.InputPort_[AutoDiffXd],</span> <span class="pre">dest:</span> <span class="pre">pydrake.systems.framework.InputPort_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Connects <code class="docutils literal notranslate"><span class="pre">dest</span></code> to the same source as <code class="docutils literal notranslate"><span class="pre">exemplar</span></code> is connected to.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">exemplar</span></code> was connected to an output port, then <code class="docutils literal notranslate"><span class="pre">dest</span></code> is
connected to that same output. Or, if <code class="docutils literal notranslate"><span class="pre">exemplar</span></code> was exported as an
input of this diagram, then <code class="docutils literal notranslate"><span class="pre">dest</span></code> will be connected to that same
diagram input. Or, if <code class="docutils literal notranslate"><span class="pre">exemplar</span></code> was neither connected or exported,
then this function is a no-op.</p>
<p>Both <code class="docutils literal notranslate"><span class="pre">exemplar</span></code> and <code class="docutils literal notranslate"><span class="pre">dest</span></code> must be ports of constituent systems
that have already been added to this diagram.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>True iff any connection or was made; or false when a no-op.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiagramBuilder_[AutoDiffXd].Disconnect(self:</span> <span class="pre">pydrake.systems.framework.DiagramBuilder_[AutoDiffXd],</span> <span class="pre">source:</span> <span class="pre">pydrake.systems.framework.OutputPort_[AutoDiffXd],</span> <span class="pre">dest:</span> <span class="pre">pydrake.systems.framework.InputPort_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Undoes a Connect() by disconnecting the given subsystem ports.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>connection_map()</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if the ports were not already connected.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiagramBuilder_[AutoDiffXd].empty(self:</span> <span class="pre">pydrake.systems.framework.DiagramBuilder_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns whether any Systems have been added yet.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiagramBuilder_[AutoDiffXd].ExportInput(self:</span> <span class="pre">pydrake.systems.framework.DiagramBuilder_[AutoDiffXd],</span> <span class="pre">input:</span> <span class="pre">pydrake.systems.framework.InputPort_[AutoDiffXd],</span> <span class="pre">name:</span> <span class="pre">Union[str,</span> <span class="pre">pydrake.systems.framework.UseDefaultName]</span> <span class="pre">=</span> <span class="pre">kUseDefaultName)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.InputPortIndex</span></span></dt>
<dd><p>Declares that the given <code class="docutils literal notranslate"><span class="pre">input</span></code> port of a constituent system is
connected to a new input to the entire Diagram. <code class="docutils literal notranslate"><span class="pre">name</span></code> is an
optional name for the new input port; if it is unspecified, then a
default name will be provided.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>If supplied at all, <code class="docutils literal notranslate"><span class="pre">name</span></code> must not be empty.</p>
</dd>
<dt>Precondition:</dt><dd><p>A port indicated by the resolution of <code class="docutils literal notranslate"><span class="pre">name</span></code> must not exist.</p>
</dd>
<dt>Postcondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">input</span></code> is connected to the new exported input port.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The index of the exported input port of the entire diagram.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiagramBuilder_[AutoDiffXd].ExportOutput(self:</span> <span class="pre">pydrake.systems.framework.DiagramBuilder_[AutoDiffXd],</span> <span class="pre">output:</span> <span class="pre">pydrake.systems.framework.OutputPort_[AutoDiffXd],</span> <span class="pre">name:</span> <span class="pre">Union[str,</span> <span class="pre">pydrake.systems.framework.UseDefaultName]</span> <span class="pre">=</span> <span class="pre">kUseDefaultName)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.OutputPortIndex</span></span></dt>
<dd><p>Declares that the given <code class="docutils literal notranslate"><span class="pre">output</span></code> port of a constituent system is an
output of the entire diagram. <code class="docutils literal notranslate"><span class="pre">name</span></code> is an optional name for the
output port; if it is unspecified, then a default name will be
provided.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>If supplied at all, <code class="docutils literal notranslate"><span class="pre">name</span></code> must not be empty.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The index of the exported output port of the entire diagram.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiagramBuilder_[AutoDiffXd].GetMutableSubsystemByName(self:</span> <span class="pre">pydrake.systems.framework.DiagramBuilder_[AutoDiffXd],</span> <span class="pre">name:</span> <span class="pre">str)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.System_[AutoDiffXd]</span></span></dt>
<dd><p>Retrieves a mutable reference to the subsystem with name <code class="docutils literal notranslate"><span class="pre">name</span></code>
returned by get_name().</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if a unique match cannot be found.</strong> – </p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>System&lt;T&gt;::get_name()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>GetSubsystemByName()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>GetMutableDowncastSubsystemByName()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiagramBuilder_[AutoDiffXd].GetMutableSystems(self:</span> <span class="pre">pydrake.systems.framework.DiagramBuilder_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">list[pydrake.systems.framework.System_[AutoDiffXd]]</span></span></dt>
<dd><p>Returns the list of contained Systems.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>GetMutableSubsystemByName()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>GetSystems()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiagramBuilder_[AutoDiffXd].GetSubsystemByName(self:</span> <span class="pre">pydrake.systems.framework.DiagramBuilder_[AutoDiffXd],</span> <span class="pre">name:</span> <span class="pre">str)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.System_[AutoDiffXd]</span></span></dt>
<dd><p>Retrieves a const reference to the subsystem with name <code class="docutils literal notranslate"><span class="pre">name</span></code>
returned by get_name().</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if a unique match cannot be found.</strong> – </p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>System&lt;T&gt;::get_name()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>GetMutableSubsystemByName()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>GetDowncastSubsystemByName()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiagramBuilder_[AutoDiffXd].GetSystems(self:</span> <span class="pre">pydrake.systems.framework.DiagramBuilder_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">list[pydrake.systems.framework.System_[AutoDiffXd]]</span></span></dt>
<dd><p>Returns the list of contained Systems.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>GetSubsystemByName()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>GetMutableSystems()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiagramBuilder_[AutoDiffXd].HasSubsystemNamed(self:</span> <span class="pre">pydrake.systems.framework.DiagramBuilder_[AutoDiffXd],</span> <span class="pre">name:</span> <span class="pre">str)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns true iff this contains a subsystem with the given name.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>GetSubsystemByName()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiagramBuilder_[AutoDiffXd].IsConnectedOrExported(self:</span> <span class="pre">pydrake.systems.framework.DiagramBuilder_[AutoDiffXd],</span> <span class="pre">port:</span> <span class="pre">pydrake.systems.framework.InputPort_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns true iff the given input <code class="docutils literal notranslate"><span class="pre">port</span></code> of a constituent system is
either connected to another constituent system or exported as a
diagram input.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiagramBuilder_[AutoDiffXd].num_input_ports(self:</span> <span class="pre">pydrake.systems.framework.DiagramBuilder_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the current number of diagram input ports. The count may
change as more ports are exported.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiagramBuilder_[AutoDiffXd].num_output_ports(self:</span> <span class="pre">pydrake.systems.framework.DiagramBuilder_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the current number of diagram output outputs. The count may
change as more ports are exported.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiagramBuilder_[AutoDiffXd].RemoveSystem(self:</span> <span class="pre">pydrake.systems.framework.DiagramBuilder_[AutoDiffXd],</span> <span class="pre">system:</span> <span class="pre">pydrake.systems.framework.System_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Removes the given system from this builder and disconnects any
connections or exported ports associated with it.</p>
<p>Note that un-exporting this system’s ports might have a ripple effect
on other exported port index assignments. The relative order will
remain intact, but any “holes” created by this removal will be filled
in by decrementing the indices of all higher-numbered ports that
remain.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Because a DiagramBuilder owns the objects it contains, the system
will be deleted.</p>
</div>
</dd></dl>

</section>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiagramBuilder_[Expression]</span></span></dt>
<dd><p>DiagramBuilder is a factory class for Diagram.</p>
<p>It is single use: after calling Build or BuildInto, DiagramBuilder
gives up ownership of the constituent systems, and should therefore be
discarded; all member functions will throw an exception after this
point.</p>
<p>When a Diagram (or DiagramBuilder) that owns systems is destroyed, the
systems will be destroyed in the reverse of the order they were added.</p>
<p>A system must be added to the DiagramBuilder with AddSystem or
AddNamedSystem before it can be wired up in any way. Every system must
have a unique, non-empty name.</p>
<section id="id2">
<h2>Building large Diagrams<a class="headerlink" href="#id2" title="Link to this heading"></a></h2>
<p>When building large Diagrams with many added systems and input-output
port connections, the runtime performance of DiagramBuilder::Build()
might become relevant.</p>
<p>As part of its correctness checks, the DiagramBuilder::Build()
function performs a graph search of the diagram’s dependencies. In the
graph, the nodes are the child systems that have been added to the
diagram, and the edges are the diagram connections from one child’s
output port to another child’s input port(s). The builder must confirm
that the graph is acyclic; a cycle would imply an infinite loop in an
output calculation function. With a large graph, this check can be
computationally expensive. To speed it up, ensure that your output
ports do not gratuitously depend on irrelevant input ports.</p>
<p>The dependencies are supplied via the <code class="docutils literal notranslate"><span class="pre">prerequisites_of_calc</span></code>
argument to DeclareOutputPort family of functions. If the default
value is used (i.e., when no prerequisites are provided), the default
is to assume the output port value is dependent on all possible
sources.</p>
<p>Refer to the DeclareLeafOutputPort_feedthrough “Direct feedthrough”
documentation for additional details and examples. In particular, the
SystemBase::all_sources_except_input_ports_ticket() is a convenient
shortcut for outputs that do not depend on any inputs.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiagramBuilder_[Expression].__init__(self:</span> <span class="pre">pydrake.systems.framework.DiagramBuilder_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiagramBuilder_[Expression].AddNamedSystem(self:</span> <span class="pre">pydrake.systems.framework.DiagramBuilder_[Expression],</span> <span class="pre">name:</span> <span class="pre">str,</span> <span class="pre">system:</span> <span class="pre">pydrake.systems.framework.System_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.System_[Expression]</span></span></dt>
<dd><p>Takes ownership of <code class="docutils literal notranslate"><span class="pre">system</span></code>, sets its name to <code class="docutils literal notranslate"><span class="pre">name</span></code>, and adds it
to the builder. Returns a bare pointer to the System, which will
remain valid for the lifetime of the Diagram built by this builder.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>a System may only be added to at most one DiagramBuilder. Multiple
Diagram instances cannot share the same System.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiagramBuilder_[Expression].AddSystem(self:</span> <span class="pre">pydrake.systems.framework.DiagramBuilder_[Expression],</span> <span class="pre">system:</span> <span class="pre">pydrake.systems.framework.System_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.System_[Expression]</span></span></dt>
<dd><p>Takes ownership of <code class="docutils literal notranslate"><span class="pre">system</span></code> and adds it to the builder. Returns a
bare pointer to the System, which will remain valid for the lifetime
of the Diagram built by this builder.</p>
<p>If the system’s name is unset, sets it to
System::GetMemoryObjectName() as a default in order to have unique
names within the diagram.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>a System may only be added to at most one DiagramBuilder. Multiple
Diagram instances cannot share the same System.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiagramBuilder_[Expression].already_built(self:</span> <span class="pre">pydrake.systems.framework.DiagramBuilder_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns true iff Build() or BuildInto() has been called on this
Builder, in which case it’s an error to call any member function other
than the the destructor.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiagramBuilder_[Expression].Build(self:</span> <span class="pre">pydrake.systems.framework.DiagramBuilder_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.Diagram_[Expression]</span></span></dt>
<dd><p>Builds the Diagram that has been described by the calls to Connect,
ExportInput, and ExportOutput.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if the graph is not buildable.</strong> – </p>
</dd>
</dl>
<p>See DiagramBuilder_feedthrough “Building large Diagrams” for tips on
improving runtime performance of this function.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiagramBuilder_[Expression].BuildInto(self:</span> <span class="pre">pydrake.systems.framework.DiagramBuilder_[Expression],</span> <span class="pre">target:</span> <span class="pre">pydrake.systems.framework.Diagram_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Configures <code class="docutils literal notranslate"><span class="pre">target</span></code> to have the topology that has been described by
the calls to Connect, ExportInput, and ExportOutput.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if the graph is not buildable.</strong> – </p>
</dd>
</dl>
<p>Only Diagram subclasses should call this method. The target must not
already be initialized.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiagramBuilder_[Expression].Connect(self:</span> <span class="pre">pydrake.systems.framework.DiagramBuilder_[Expression],</span> <span class="pre">arg0:</span> <span class="pre">pydrake.systems.framework.OutputPort_[Expression],</span> <span class="pre">arg1:</span> <span class="pre">pydrake.systems.framework.InputPort_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Declares that input port <code class="docutils literal notranslate"><span class="pre">dest</span></code> is connected to output port <code class="docutils literal notranslate"><span class="pre">src</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The connection created between <code class="docutils literal notranslate"><span class="pre">src</span></code> and <code class="docutils literal notranslate"><span class="pre">dest</span></code> via a call to
this method can be effectively overridden by any subsequent call
to InputPort::FixValue(). That is, calling InputPort::FixValue()
on an already connected input port causes the resultant
FixedInputPortValue to override any other value present on that
port.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiagramBuilder_[Expression].ConnectInput(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>ConnectInput(self: pydrake.systems.framework.DiagramBuilder_[Expression], diagram_port_name: str, input: pydrake.systems.framework.InputPort_[Expression]) -&gt; None</p></li>
</ol>
<p>Connects an input to the entire Diagram, indicated by
<code class="docutils literal notranslate"><span class="pre">diagram_port_name</span></code>, to the given <code class="docutils literal notranslate"><span class="pre">input</span></code> port of a constituent
system.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>The Diagram input indicated by <code class="docutils literal notranslate"><span class="pre">diagram_port_name</span></code> must have
been previously built via ExportInput().</p>
</dd>
<dt>Postcondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">input</span></code> is connected to the indicated Diagram input port.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>ConnectInput(self: pydrake.systems.framework.DiagramBuilder_[Expression], diagram_port_index: pydrake.systems.framework.InputPortIndex, input: pydrake.systems.framework.InputPort_[Expression]) -&gt; None</p></li>
</ol>
<p>Connects an input to the entire Diagram, indicated by
<code class="docutils literal notranslate"><span class="pre">diagram_port_index</span></code>, to the given <code class="docutils literal notranslate"><span class="pre">input</span></code> port of a constituent
system.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>The Diagram input indicated by <code class="docutils literal notranslate"><span class="pre">diagram_port_index</span></code> must have
been previously built via ExportInput().</p>
</dd>
<dt>Postcondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">input</span></code> is connected to the indicated Diagram input port.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiagramBuilder_[Expression].connection_map(self:</span> <span class="pre">pydrake.systems.framework.DiagramBuilder_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">dict</span></span></dt>
<dd><p>(Advanced) Returns a reference to the map of connections between
Systems. The reference becomes invalid upon any call to Build or
BuildInto.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiagramBuilder_[Expression].ConnectToSame(self:</span> <span class="pre">pydrake.systems.framework.DiagramBuilder_[Expression],</span> <span class="pre">exemplar:</span> <span class="pre">pydrake.systems.framework.InputPort_[Expression],</span> <span class="pre">dest:</span> <span class="pre">pydrake.systems.framework.InputPort_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Connects <code class="docutils literal notranslate"><span class="pre">dest</span></code> to the same source as <code class="docutils literal notranslate"><span class="pre">exemplar</span></code> is connected to.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">exemplar</span></code> was connected to an output port, then <code class="docutils literal notranslate"><span class="pre">dest</span></code> is
connected to that same output. Or, if <code class="docutils literal notranslate"><span class="pre">exemplar</span></code> was exported as an
input of this diagram, then <code class="docutils literal notranslate"><span class="pre">dest</span></code> will be connected to that same
diagram input. Or, if <code class="docutils literal notranslate"><span class="pre">exemplar</span></code> was neither connected or exported,
then this function is a no-op.</p>
<p>Both <code class="docutils literal notranslate"><span class="pre">exemplar</span></code> and <code class="docutils literal notranslate"><span class="pre">dest</span></code> must be ports of constituent systems
that have already been added to this diagram.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>True iff any connection or was made; or false when a no-op.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiagramBuilder_[Expression].Disconnect(self:</span> <span class="pre">pydrake.systems.framework.DiagramBuilder_[Expression],</span> <span class="pre">source:</span> <span class="pre">pydrake.systems.framework.OutputPort_[Expression],</span> <span class="pre">dest:</span> <span class="pre">pydrake.systems.framework.InputPort_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Undoes a Connect() by disconnecting the given subsystem ports.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>connection_map()</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if the ports were not already connected.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiagramBuilder_[Expression].empty(self:</span> <span class="pre">pydrake.systems.framework.DiagramBuilder_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns whether any Systems have been added yet.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiagramBuilder_[Expression].ExportInput(self:</span> <span class="pre">pydrake.systems.framework.DiagramBuilder_[Expression],</span> <span class="pre">input:</span> <span class="pre">pydrake.systems.framework.InputPort_[Expression],</span> <span class="pre">name:</span> <span class="pre">Union[str,</span> <span class="pre">pydrake.systems.framework.UseDefaultName]</span> <span class="pre">=</span> <span class="pre">kUseDefaultName)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.InputPortIndex</span></span></dt>
<dd><p>Declares that the given <code class="docutils literal notranslate"><span class="pre">input</span></code> port of a constituent system is
connected to a new input to the entire Diagram. <code class="docutils literal notranslate"><span class="pre">name</span></code> is an
optional name for the new input port; if it is unspecified, then a
default name will be provided.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>If supplied at all, <code class="docutils literal notranslate"><span class="pre">name</span></code> must not be empty.</p>
</dd>
<dt>Precondition:</dt><dd><p>A port indicated by the resolution of <code class="docutils literal notranslate"><span class="pre">name</span></code> must not exist.</p>
</dd>
<dt>Postcondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">input</span></code> is connected to the new exported input port.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The index of the exported input port of the entire diagram.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiagramBuilder_[Expression].ExportOutput(self:</span> <span class="pre">pydrake.systems.framework.DiagramBuilder_[Expression],</span> <span class="pre">output:</span> <span class="pre">pydrake.systems.framework.OutputPort_[Expression],</span> <span class="pre">name:</span> <span class="pre">Union[str,</span> <span class="pre">pydrake.systems.framework.UseDefaultName]</span> <span class="pre">=</span> <span class="pre">kUseDefaultName)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.OutputPortIndex</span></span></dt>
<dd><p>Declares that the given <code class="docutils literal notranslate"><span class="pre">output</span></code> port of a constituent system is an
output of the entire diagram. <code class="docutils literal notranslate"><span class="pre">name</span></code> is an optional name for the
output port; if it is unspecified, then a default name will be
provided.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>If supplied at all, <code class="docutils literal notranslate"><span class="pre">name</span></code> must not be empty.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The index of the exported output port of the entire diagram.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiagramBuilder_[Expression].GetMutableSubsystemByName(self:</span> <span class="pre">pydrake.systems.framework.DiagramBuilder_[Expression],</span> <span class="pre">name:</span> <span class="pre">str)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.System_[Expression]</span></span></dt>
<dd><p>Retrieves a mutable reference to the subsystem with name <code class="docutils literal notranslate"><span class="pre">name</span></code>
returned by get_name().</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if a unique match cannot be found.</strong> – </p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>System&lt;T&gt;::get_name()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>GetSubsystemByName()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>GetMutableDowncastSubsystemByName()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiagramBuilder_[Expression].GetMutableSystems(self:</span> <span class="pre">pydrake.systems.framework.DiagramBuilder_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">list[pydrake.systems.framework.System_[Expression]]</span></span></dt>
<dd><p>Returns the list of contained Systems.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>GetMutableSubsystemByName()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>GetSystems()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiagramBuilder_[Expression].GetSubsystemByName(self:</span> <span class="pre">pydrake.systems.framework.DiagramBuilder_[Expression],</span> <span class="pre">name:</span> <span class="pre">str)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.System_[Expression]</span></span></dt>
<dd><p>Retrieves a const reference to the subsystem with name <code class="docutils literal notranslate"><span class="pre">name</span></code>
returned by get_name().</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if a unique match cannot be found.</strong> – </p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>System&lt;T&gt;::get_name()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>GetMutableSubsystemByName()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>GetDowncastSubsystemByName()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiagramBuilder_[Expression].GetSystems(self:</span> <span class="pre">pydrake.systems.framework.DiagramBuilder_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">list[pydrake.systems.framework.System_[Expression]]</span></span></dt>
<dd><p>Returns the list of contained Systems.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>GetSubsystemByName()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>GetMutableSystems()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiagramBuilder_[Expression].HasSubsystemNamed(self:</span> <span class="pre">pydrake.systems.framework.DiagramBuilder_[Expression],</span> <span class="pre">name:</span> <span class="pre">str)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns true iff this contains a subsystem with the given name.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>GetSubsystemByName()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiagramBuilder_[Expression].IsConnectedOrExported(self:</span> <span class="pre">pydrake.systems.framework.DiagramBuilder_[Expression],</span> <span class="pre">port:</span> <span class="pre">pydrake.systems.framework.InputPort_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns true iff the given input <code class="docutils literal notranslate"><span class="pre">port</span></code> of a constituent system is
either connected to another constituent system or exported as a
diagram input.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiagramBuilder_[Expression].num_input_ports(self:</span> <span class="pre">pydrake.systems.framework.DiagramBuilder_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the current number of diagram input ports. The count may
change as more ports are exported.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiagramBuilder_[Expression].num_output_ports(self:</span> <span class="pre">pydrake.systems.framework.DiagramBuilder_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the current number of diagram output outputs. The count may
change as more ports are exported.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiagramBuilder_[Expression].RemoveSystem(self:</span> <span class="pre">pydrake.systems.framework.DiagramBuilder_[Expression],</span> <span class="pre">system:</span> <span class="pre">pydrake.systems.framework.System_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Removes the given system from this builder and disconnects any
connections or exported ports associated with it.</p>
<p>Note that un-exporting this system’s ports might have a ripple effect
on other exported port index assignments. The relative order will
remain intact, but any “holes” created by this removal will be filled
in by decrementing the indices of all higher-numbered ports that
remain.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Because a DiagramBuilder owns the objects it contains, the system
will be deleted.</p>
</div>
</dd></dl>

</section>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteStateIndex</span></span></dt>
<dd><dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteStateIndex.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.systems.framework.DiscreteStateIndex) -&gt; None</p></li>
</ol>
<p>Default constructor; the result is an <em>invalid</em> index. This only
exists to serve applications which require a default constructor.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.systems.framework.DiscreteStateIndex, arg0: int) -&gt; None</p></li>
</ol>
<p>Construction from a non-negative <code class="docutils literal notranslate"><span class="pre">int</span></code> value. The value must lie in
the range of [0, 2³¹). Constructor only promises to test validity in
Debug build.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteStateIndex.is_valid(self:</span> <span class="pre">pydrake.systems.framework.DiscreteStateIndex)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Reports if the index is valid–the only operation on an invalid index
that doesn’t throw an exception in Debug builds.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteUpdateEvent</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.Event</span></code></p>
<p>This class represents a discrete update event. It has an optional
callback function to do custom handling of this event, and that can
write updates to a mutable, non-null DiscreteValues object.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>LeafSystem for more convenient interfaces to discrete update
events via the Declare*DiscreteUpdateEvent() methods.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">DiscreteUpdateEvent_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteUpdateEvent.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteUpdateEvent_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">DiscreteUpdateEvent_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">DiscreteUpdateEvent_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">DiscreteUpdateEvent_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteUpdateEvent_[AutoDiffXd]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.Event_[AutoDiffXd]</span></code></p>
<p>This class represents a discrete update event. It has an optional
callback function to do custom handling of this event, and that can
write updates to a mutable, non-null DiscreteValues object.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>LeafSystem for more convenient interfaces to discrete update
events via the Declare*DiscreteUpdateEvent() methods.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteUpdateEvent_[AutoDiffXd].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteUpdateEvent_[Expression]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.Event_[Expression]</span></code></p>
<p>This class represents a discrete update event. It has an optional
callback function to do custom handling of this event, and that can
write updates to a mutable, non-null DiscreteValues object.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>LeafSystem for more convenient interfaces to discrete update
events via the Declare*DiscreteUpdateEvent() methods.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteUpdateEvent_[Expression].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteValues</span></span></dt>
<dd><p>%DiscreteValues is a container for numerical but non-continuous state
and parameters. It may own its underlying data, for use with leaf
Systems, or not, for use with Diagrams.</p>
<p>DiscreteValues is an ordered collection xd of BasicVector “groups” so
xd = [xd₀, xd₁…], where each group xdᵢ is a contiguous vector.
Requesting a specific group index from this collection is the most
granular way to retrieve discrete values from the Context, and thus is
the unit of cache invalidation. System authors are encouraged to
partition their DiscreteValues such that each cacheable computation
within the System may depend on only the elements of DiscreteValues
that it needs.</p>
<p>None of the contained vectors (groups) may be null, although any of
them may be zero-length.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">DiscreteValues_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteValues.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.systems.framework.DiscreteValues, datum: pydrake.systems.framework.BasicVector) -&gt; None</p></li>
</ol>
<p>Constructs a one-group DiscreteValues object that owns a single
<code class="docutils literal notranslate"><span class="pre">datum</span></code> vector which may not be null.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.systems.framework.DiscreteValues, data: list[pydrake.systems.framework.BasicVector]) -&gt; None</p></li>
</ol>
<p>Constructs a DiscreteValues that owns the underlying <code class="docutils literal notranslate"><span class="pre">data</span></code>. Every
entry must be non-null.</p>
<ol class="arabic simple" start="3">
<li><p>__init__(self: pydrake.systems.framework.DiscreteValues) -&gt; None</p></li>
</ol>
<p>Constructs an empty DiscreteValues object containing no groups.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteValues.Clone(self:</span> <span class="pre">pydrake.systems.framework.DiscreteValues)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.DiscreteValues</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteValues.get_data(self:</span> <span class="pre">pydrake.systems.framework.DiscreteValues)</span> <span class="pre">-&gt;</span> <span class="pre">list[pydrake.systems.framework.BasicVector]</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteValues.get_mutable_value(self:</span> <span class="pre">pydrake.systems.framework.DiscreteValues,</span> <span class="pre">index:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">0)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1],</span> <span class="pre">flags.writeable]</span></span></dt>
<dd><p>Returns the entire vector for the indicated group as a mutable
Eigen::VectorBlock, which allows mutation of the values, but does not
allow resize() to be called on the vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteValues.get_mutable_vector(self:</span> <span class="pre">pydrake.systems.framework.DiscreteValues,</span> <span class="pre">index:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">0)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.BasicVector</span></span></dt>
<dd><p>(Advanced) Returns a mutable reference to the BasicVector holding data
for the indicated group. Prefer <code class="docutils literal notranslate"><span class="pre">get_mutable_value()</span></code> to get the
underlying Eigen object unless you really need the BasicVector
wrapping it.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteValues.get_value(self:</span> <span class="pre">pydrake.systems.framework.DiscreteValues,</span> <span class="pre">index:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">0)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>(Don’t use this in new code) Returns the entire vector as a const
Eigen::VectorBlock for the indicated group. Prefer <code class="docutils literal notranslate"><span class="pre">value()</span></code> which
returns direct access to the underlying VectorX rather than wrapping
it in a VectorBlock.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteValues.get_vector(self:</span> <span class="pre">pydrake.systems.framework.DiscreteValues,</span> <span class="pre">index:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">0)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.BasicVector</span></span></dt>
<dd><p>(Advanced) Returns a const reference to the BasicVector holding data
for the indicated group. Prefer <code class="docutils literal notranslate"><span class="pre">value(index)</span></code> to get the underlying
VectorX directly unless you really need the BasicVector wrapping it.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteValues.num_groups(self:</span> <span class="pre">pydrake.systems.framework.DiscreteValues)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteValues.set_value(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>set_value(self: pydrake.systems.framework.DiscreteValues, value: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</p></li>
</ol>
<p>Sets the vector to the given value for the <em>only</em> group.</p>
<ol class="arabic simple" start="2">
<li><p>set_value(self: pydrake.systems.framework.DiscreteValues, index: int, value: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</p></li>
</ol>
<p>Sets the vector to the given value for the indicated group.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteValues.SetFrom(self:</span> <span class="pre">pydrake.systems.framework.DiscreteValues,</span> <span class="pre">arg0:</span> <span class="pre">pydrake.systems.framework.DiscreteValues)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Resets the values in this DiscreteValues from the values in <code class="docutils literal notranslate"><span class="pre">other</span></code>,
possibly writing through to unowned data. Throws if the dimensions
don’t match.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteValues.size(self:</span> <span class="pre">pydrake.systems.framework.DiscreteValues)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the number of elements in the only DiscreteValues group.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteValues.value(self:</span> <span class="pre">pydrake.systems.framework.DiscreteValues,</span> <span class="pre">index:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">0)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns a const reference to the underlying VectorX containing the
values for the indicated group. This is the preferred method for
examining the value of a group.</p>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteValues_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">DiscreteValues_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">DiscreteValues_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">DiscreteValues_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteValues_[AutoDiffXd]</span></span></dt>
<dd><p>%DiscreteValues is a container for numerical but non-continuous state
and parameters. It may own its underlying data, for use with leaf
Systems, or not, for use with Diagrams.</p>
<p>DiscreteValues is an ordered collection xd of BasicVector “groups” so
xd = [xd₀, xd₁…], where each group xdᵢ is a contiguous vector.
Requesting a specific group index from this collection is the most
granular way to retrieve discrete values from the Context, and thus is
the unit of cache invalidation. System authors are encouraged to
partition their DiscreteValues such that each cacheable computation
within the System may depend on only the elements of DiscreteValues
that it needs.</p>
<p>None of the contained vectors (groups) may be null, although any of
them may be zero-length.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteValues_[AutoDiffXd].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.systems.framework.DiscreteValues_[AutoDiffXd], datum: pydrake.systems.framework.BasicVector_[AutoDiffXd]) -&gt; None</p></li>
</ol>
<p>Constructs a one-group DiscreteValues object that owns a single
<code class="docutils literal notranslate"><span class="pre">datum</span></code> vector which may not be null.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.systems.framework.DiscreteValues_[AutoDiffXd], data: list[pydrake.systems.framework.BasicVector_[AutoDiffXd]]) -&gt; None</p></li>
</ol>
<p>Constructs a DiscreteValues that owns the underlying <code class="docutils literal notranslate"><span class="pre">data</span></code>. Every
entry must be non-null.</p>
<ol class="arabic simple" start="3">
<li><p>__init__(self: pydrake.systems.framework.DiscreteValues_[AutoDiffXd]) -&gt; None</p></li>
</ol>
<p>Constructs an empty DiscreteValues object containing no groups.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteValues_[AutoDiffXd].Clone(self:</span> <span class="pre">pydrake.systems.framework.DiscreteValues_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.DiscreteValues_[AutoDiffXd]</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteValues_[AutoDiffXd].get_data(self:</span> <span class="pre">pydrake.systems.framework.DiscreteValues_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">list[pydrake.systems.framework.BasicVector_[AutoDiffXd]]</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteValues_[AutoDiffXd].get_mutable_value(self:</span> <span class="pre">pydrake.systems.framework.DiscreteValues_[AutoDiffXd],</span> <span class="pre">index:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">0)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1],</span> <span class="pre">flags.writeable]</span></span></dt>
<dd><p>Returns the entire vector for the indicated group as a mutable
Eigen::VectorBlock, which allows mutation of the values, but does not
allow resize() to be called on the vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteValues_[AutoDiffXd].get_mutable_vector(self:</span> <span class="pre">pydrake.systems.framework.DiscreteValues_[AutoDiffXd],</span> <span class="pre">index:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">0)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.BasicVector_[AutoDiffXd]</span></span></dt>
<dd><p>(Advanced) Returns a mutable reference to the BasicVector holding data
for the indicated group. Prefer <code class="docutils literal notranslate"><span class="pre">get_mutable_value()</span></code> to get the
underlying Eigen object unless you really need the BasicVector
wrapping it.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteValues_[AutoDiffXd].get_value(self:</span> <span class="pre">pydrake.systems.framework.DiscreteValues_[AutoDiffXd],</span> <span class="pre">index:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">0)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>(Don’t use this in new code) Returns the entire vector as a const
Eigen::VectorBlock for the indicated group. Prefer <code class="docutils literal notranslate"><span class="pre">value()</span></code> which
returns direct access to the underlying VectorX rather than wrapping
it in a VectorBlock.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteValues_[AutoDiffXd].get_vector(self:</span> <span class="pre">pydrake.systems.framework.DiscreteValues_[AutoDiffXd],</span> <span class="pre">index:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">0)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.BasicVector_[AutoDiffXd]</span></span></dt>
<dd><p>(Advanced) Returns a const reference to the BasicVector holding data
for the indicated group. Prefer <code class="docutils literal notranslate"><span class="pre">value(index)</span></code> to get the underlying
VectorX directly unless you really need the BasicVector wrapping it.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteValues_[AutoDiffXd].num_groups(self:</span> <span class="pre">pydrake.systems.framework.DiscreteValues_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteValues_[AutoDiffXd].set_value(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>set_value(self: pydrake.systems.framework.DiscreteValues_[AutoDiffXd], value: numpy.ndarray[object[m, 1]]) -&gt; None</p></li>
</ol>
<p>Sets the vector to the given value for the <em>only</em> group.</p>
<ol class="arabic simple" start="2">
<li><p>set_value(self: pydrake.systems.framework.DiscreteValues_[AutoDiffXd], index: int, value: numpy.ndarray[object[m, 1]]) -&gt; None</p></li>
</ol>
<p>Sets the vector to the given value for the indicated group.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteValues_[AutoDiffXd].SetFrom(self:</span> <span class="pre">pydrake.systems.framework.DiscreteValues_[AutoDiffXd],</span> <span class="pre">arg0:</span> <span class="pre">pydrake.systems.framework.DiscreteValues)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Resets the values in this DiscreteValues from the values in <code class="docutils literal notranslate"><span class="pre">other</span></code>,
possibly writing through to unowned data. Throws if the dimensions
don’t match.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteValues_[AutoDiffXd].size(self:</span> <span class="pre">pydrake.systems.framework.DiscreteValues_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the number of elements in the only DiscreteValues group.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteValues_[AutoDiffXd].value(self:</span> <span class="pre">pydrake.systems.framework.DiscreteValues_[AutoDiffXd],</span> <span class="pre">index:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">0)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns a const reference to the underlying VectorX containing the
values for the indicated group. This is the preferred method for
examining the value of a group.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteValues_[Expression]</span></span></dt>
<dd><p>%DiscreteValues is a container for numerical but non-continuous state
and parameters. It may own its underlying data, for use with leaf
Systems, or not, for use with Diagrams.</p>
<p>DiscreteValues is an ordered collection xd of BasicVector “groups” so
xd = [xd₀, xd₁…], where each group xdᵢ is a contiguous vector.
Requesting a specific group index from this collection is the most
granular way to retrieve discrete values from the Context, and thus is
the unit of cache invalidation. System authors are encouraged to
partition their DiscreteValues such that each cacheable computation
within the System may depend on only the elements of DiscreteValues
that it needs.</p>
<p>None of the contained vectors (groups) may be null, although any of
them may be zero-length.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteValues_[Expression].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.systems.framework.DiscreteValues_[Expression], datum: pydrake.systems.framework.BasicVector_[Expression]) -&gt; None</p></li>
</ol>
<p>Constructs a one-group DiscreteValues object that owns a single
<code class="docutils literal notranslate"><span class="pre">datum</span></code> vector which may not be null.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.systems.framework.DiscreteValues_[Expression], data: list[pydrake.systems.framework.BasicVector_[Expression]]) -&gt; None</p></li>
</ol>
<p>Constructs a DiscreteValues that owns the underlying <code class="docutils literal notranslate"><span class="pre">data</span></code>. Every
entry must be non-null.</p>
<ol class="arabic simple" start="3">
<li><p>__init__(self: pydrake.systems.framework.DiscreteValues_[Expression]) -&gt; None</p></li>
</ol>
<p>Constructs an empty DiscreteValues object containing no groups.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteValues_[Expression].Clone(self:</span> <span class="pre">pydrake.systems.framework.DiscreteValues_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.DiscreteValues_[Expression]</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteValues_[Expression].get_data(self:</span> <span class="pre">pydrake.systems.framework.DiscreteValues_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">list[pydrake.systems.framework.BasicVector_[Expression]]</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteValues_[Expression].get_mutable_value(self:</span> <span class="pre">pydrake.systems.framework.DiscreteValues_[Expression],</span> <span class="pre">index:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">0)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1],</span> <span class="pre">flags.writeable]</span></span></dt>
<dd><p>Returns the entire vector for the indicated group as a mutable
Eigen::VectorBlock, which allows mutation of the values, but does not
allow resize() to be called on the vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteValues_[Expression].get_mutable_vector(self:</span> <span class="pre">pydrake.systems.framework.DiscreteValues_[Expression],</span> <span class="pre">index:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">0)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.BasicVector_[Expression]</span></span></dt>
<dd><p>(Advanced) Returns a mutable reference to the BasicVector holding data
for the indicated group. Prefer <code class="docutils literal notranslate"><span class="pre">get_mutable_value()</span></code> to get the
underlying Eigen object unless you really need the BasicVector
wrapping it.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteValues_[Expression].get_value(self:</span> <span class="pre">pydrake.systems.framework.DiscreteValues_[Expression],</span> <span class="pre">index:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">0)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>(Don’t use this in new code) Returns the entire vector as a const
Eigen::VectorBlock for the indicated group. Prefer <code class="docutils literal notranslate"><span class="pre">value()</span></code> which
returns direct access to the underlying VectorX rather than wrapping
it in a VectorBlock.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteValues_[Expression].get_vector(self:</span> <span class="pre">pydrake.systems.framework.DiscreteValues_[Expression],</span> <span class="pre">index:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">0)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.BasicVector_[Expression]</span></span></dt>
<dd><p>(Advanced) Returns a const reference to the BasicVector holding data
for the indicated group. Prefer <code class="docutils literal notranslate"><span class="pre">value(index)</span></code> to get the underlying
VectorX directly unless you really need the BasicVector wrapping it.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteValues_[Expression].num_groups(self:</span> <span class="pre">pydrake.systems.framework.DiscreteValues_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteValues_[Expression].set_value(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>set_value(self: pydrake.systems.framework.DiscreteValues_[Expression], value: numpy.ndarray[object[m, 1]]) -&gt; None</p></li>
</ol>
<p>Sets the vector to the given value for the <em>only</em> group.</p>
<ol class="arabic simple" start="2">
<li><p>set_value(self: pydrake.systems.framework.DiscreteValues_[Expression], index: int, value: numpy.ndarray[object[m, 1]]) -&gt; None</p></li>
</ol>
<p>Sets the vector to the given value for the indicated group.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteValues_[Expression].SetFrom(self:</span> <span class="pre">pydrake.systems.framework.DiscreteValues_[Expression],</span> <span class="pre">arg0:</span> <span class="pre">pydrake.systems.framework.DiscreteValues)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Resets the values in this DiscreteValues from the values in <code class="docutils literal notranslate"><span class="pre">other</span></code>,
possibly writing through to unowned data. Throws if the dimensions
don’t match.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteValues_[Expression].size(self:</span> <span class="pre">pydrake.systems.framework.DiscreteValues_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the number of elements in the only DiscreteValues group.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteValues_[Expression].value(self:</span> <span class="pre">pydrake.systems.framework.DiscreteValues_[Expression],</span> <span class="pre">index:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">0)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns a const reference to the underlying VectorX containing the
values for the indicated group. This is the preferred method for
examining the value of a group.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Event</span></span></dt>
<dd><p>Abstract base class that represents an event. The base event contains
two main pieces of information: an enum trigger type and an optional
attribute that can be used to explain why the event is triggered.</p>
<p>Concrete derived classes contain a function pointer to an optional
callback that handles the event. No-op is the default handling
behavior. The System framework supports three concrete event types:
PublishEvent, DiscreteUpdateEvent, and UnrestrictedUpdateEvent
distinguished by their callback functions’ write access level to the
State.</p>
<p>The most common and convenient use of events and callbacks will happen
via the LeafSystem Declare*Event() methods. To that end, the callback
signature always passes the <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">System&lt;T&gt;&amp;</span></code> as the first
argument, so that LeafSystem does not need to capture <code class="docutils literal notranslate"><span class="pre">this</span></code> into
the lambda; typically only a pointer-to-member- function is captured.
Capturing any more than that would defeat std::function’s small buffer
optimization and cause heap allocations when scheduling events.</p>
<p>Event handling occurs during a simulation of a system. The logic that
describes when particular event types are handled is described in the
class documentation for Simulator.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">Event_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Event.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Event.get_trigger_type(self:</span> <span class="pre">pydrake.systems.framework.Event)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.TriggerType</span></span></dt>
<dd><p>Returns the trigger type.</p>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Event_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">Event_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Event_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Event_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Event_[AutoDiffXd]</span></span></dt>
<dd><p>Abstract base class that represents an event. The base event contains
two main pieces of information: an enum trigger type and an optional
attribute that can be used to explain why the event is triggered.</p>
<p>Concrete derived classes contain a function pointer to an optional
callback that handles the event. No-op is the default handling
behavior. The System framework supports three concrete event types:
PublishEvent, DiscreteUpdateEvent, and UnrestrictedUpdateEvent
distinguished by their callback functions’ write access level to the
State.</p>
<p>The most common and convenient use of events and callbacks will happen
via the LeafSystem Declare*Event() methods. To that end, the callback
signature always passes the <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">System&lt;T&gt;&amp;</span></code> as the first
argument, so that LeafSystem does not need to capture <code class="docutils literal notranslate"><span class="pre">this</span></code> into
the lambda; typically only a pointer-to-member- function is captured.
Capturing any more than that would defeat std::function’s small buffer
optimization and cause heap allocations when scheduling events.</p>
<p>Event handling occurs during a simulation of a system. The logic that
describes when particular event types are handled is described in the
class documentation for Simulator.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Event_[AutoDiffXd].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Event_[AutoDiffXd].get_trigger_type(self:</span> <span class="pre">pydrake.systems.framework.Event_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.TriggerType</span></span></dt>
<dd><p>Returns the trigger type.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Event_[Expression]</span></span></dt>
<dd><p>Abstract base class that represents an event. The base event contains
two main pieces of information: an enum trigger type and an optional
attribute that can be used to explain why the event is triggered.</p>
<p>Concrete derived classes contain a function pointer to an optional
callback that handles the event. No-op is the default handling
behavior. The System framework supports three concrete event types:
PublishEvent, DiscreteUpdateEvent, and UnrestrictedUpdateEvent
distinguished by their callback functions’ write access level to the
State.</p>
<p>The most common and convenient use of events and callbacks will happen
via the LeafSystem Declare*Event() methods. To that end, the callback
signature always passes the <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">System&lt;T&gt;&amp;</span></code> as the first
argument, so that LeafSystem does not need to capture <code class="docutils literal notranslate"><span class="pre">this</span></code> into
the lambda; typically only a pointer-to-member- function is captured.
Capturing any more than that would defeat std::function’s small buffer
optimization and cause heap allocations when scheduling events.</p>
<p>Event handling occurs during a simulation of a system. The logic that
describes when particular event types are handled is described in the
class documentation for Simulator.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Event_[Expression].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Event_[Expression].get_trigger_type(self:</span> <span class="pre">pydrake.systems.framework.Event_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.TriggerType</span></span></dt>
<dd><p>Returns the trigger type.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">EventStatus</span></span></dt>
<dd><p>Holds the return status from execution of an event handler function,
or the effective status after a series of handler executions due to
dispatching of simultaneous events. Drake API users will typically use
only the four factory methods below to return status, and optionally a
human-readable message, from their event handlers.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">EventStatus.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">EventStatus.DidNothing()</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.EventStatus</span></span></dt>
<dd><p>Returns “did nothing” status, with no message.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">EventStatus.Failed(system:</span> <span class="pre">object,</span> <span class="pre">message:</span> <span class="pre">str)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.EventStatus</span></span></dt>
<dd><p>Returns “failed” status, with a message explaining why.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">EventStatus.KeepMoreSevere(self:</span> <span class="pre">pydrake.systems.framework.EventStatus,</span> <span class="pre">candidate:</span> <span class="pre">pydrake.systems.framework.EventStatus)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.EventStatus</span></span></dt>
<dd><p>(Advanced) Replaces the contents of <code class="docutils literal notranslate"><span class="pre">this</span></code> with the more-severe
status if <code class="docutils literal notranslate"><span class="pre">candidate</span></code> is a more severe status than <code class="docutils literal notranslate"><span class="pre">this</span></code> one.
Does nothing if <code class="docutils literal notranslate"><span class="pre">candidate</span></code> severity is less than or equal to
<code class="docutils literal notranslate"><span class="pre">this</span></code> severity. This method is for use in event dispatchers for
accumulating status returns from a series of event handlers for a set
of simultaneous events.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">EventStatus.message(self:</span> <span class="pre">pydrake.systems.framework.EventStatus)</span> <span class="pre">-&gt;</span> <span class="pre">str</span></span></dt>
<dd><p>Returns the optionally-provided human-readable message supplied by the
event handler that produced the current status. Returns an empty
string if no message was provided.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">EventStatus.ReachedTermination(system:</span> <span class="pre">object,</span> <span class="pre">message:</span> <span class="pre">str)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.EventStatus</span></span></dt>
<dd><p>Returns “reached termination” status, with a message explaining why.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">EventStatus.Severity</span></span></dt>
<dd><p>The numerical values are ordered, with did_nothing &lt; success &lt;
terminate &lt; fatal.</p>
<p>Members:</p>
<blockquote>
<div><p>kDidNothing : Successful, but nothing happened; no state update needed.</p>
<p>kSucceeded : Handler executed successfully; state may have been updated.</p>
<p>kReachedTermination : Handler succeeded but detected a normal termination condition (has</p>
</div></blockquote>
<p>message). Intended primarily for internal use by the Simulator.</p>
<blockquote>
<div><p>kFailed : Handler was unable to perform its job (has message).</p>
</div></blockquote>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">EventStatus.Severity.__init__(self:</span> <span class="pre">pydrake.systems.framework.EventStatus.Severity,</span> <span class="pre">value:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">EventStatus.Severity.kDidNothing</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">EventStatus.Severity.kFailed</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">EventStatus.Severity.kReachedTermination</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">EventStatus.Severity.kSucceeded</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">EventStatus.Severity.name</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">EventStatus.Severity.value</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">EventStatus.severity(self:</span> <span class="pre">pydrake.systems.framework.EventStatus)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.EventStatus.Severity</span></span></dt>
<dd><p>Returns the severity of the current status.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">EventStatus.Succeeded()</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.EventStatus</span></span></dt>
<dd><p>Returns “succeeded” status, with no message.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">EventStatus.system(self:</span> <span class="pre">pydrake.systems.framework.EventStatus)</span> <span class="pre">-&gt;</span> <span class="pre">object</span></span></dt>
<dd><p>Returns the optionally-provided subsystem that generated a status
return that can include a message (reached termination or failed).
Returns nullptr if no subsystem was provided.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">FixedInputPortValue</span></span></dt>
<dd><p>A FixedInputPortValue encapsulates a vector or abstract value for use
as an internal value source for one of a System’s input ports. The
semantics are identical to a Parameter. We assign a DependencyTracker
to this object and subscribe the InputPort to it when that port is
fixed. Any modification to the value here issues a notification to its
dependent, and increments a serial number kept here.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">FixedInputPortValue.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">FixedInputPortValue.GetMutableData(self:</span> <span class="pre">pydrake.systems.framework.FixedInputPortValue)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.common.value.AbstractValue</span></span></dt>
<dd><p>Returns a pointer to the data inside this FixedInputPortValue, and
notifies the dependent input port that the value has changed.</p>
<p>To ensure invalidation notifications are delivered, callers should
call this method every time they wish to update the stored value. In
particular, callers MUST NOT write through the returned pointer if
there is any possibility this FixedInputPortValue has been accessed
since the last time this method was called.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">InputPort</span></span></dt>
<dd><p>An InputPort is a System resource that describes the kind of input a
System accepts, on a given port. It does not directly contain any
runtime input port data; that is always contained in a Context. The
actual value will be either the value of an OutputPort to which this
is connected, or a fixed value set in a Context.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">InputPort_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">InputPort.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">InputPort.Allocate(self:</span> <span class="pre">pydrake.systems.framework.InputPort)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.common.value.AbstractValue</span></span></dt>
<dd><p>Allocates a concrete object suitable for holding the value to be
provided by this input port, and returns that as an AbstractValue. The
returned object will never be null.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">InputPort.Eval(self:</span> <span class="pre">pydrake.systems.framework.InputPort,</span> <span class="pre">arg0:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">object</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">InputPort.EvalAbstract(self:</span> <span class="pre">pydrake.systems.framework.InputPort,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.common.value.AbstractValue</span></span></dt>
<dd><p>(Advanced.) Returns the value of this input port, typed as an AbstractValue. Most users should call Eval() instead. This method is only needed when the result will be passed into some other API that only accepts an AbstractValue.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">InputPort.EvalBasicVector(self:</span> <span class="pre">pydrake.systems.framework.InputPort,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">object</span></span></dt>
<dd><p>(Advanced.) Returns the value of this input port, typed as a BasicVector. Most users should call Eval() instead. This method is only needed when the result will be passed into some other API that only accepts a BasicVector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">InputPort.FixValue(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>FixValue(self: pydrake.systems.framework.InputPort, context: pydrake.systems.framework.Context, value: pydrake.common.value.AbstractValue) -&gt; pydrake.systems.framework.FixedInputPortValue</p></li>
</ol>
<p>Provides a fixed value for this InputPort in the given Context. If the
port is already connected, this value will override the connected
source value. (By “connected” we mean that the port appeared in a
DiagramBuilder::Connect() call.)</p>
<p>For vector-valued input ports, you can provide an Eigen vector
expression, a BasicVector object, or a scalar (treated as a Vector1).
In each of these cases the value is copied into a
<code class="docutils literal notranslate"><span class="pre">Value&lt;BasicVector&gt;</span></code>. If the original value was a
BasicVector-derived object, its concrete type is maintained although
the stored type is still <code class="docutils literal notranslate"><span class="pre">Value&lt;BasicVector&gt;</span></code>. The supplied vector
must have the right size for the vector port or an RuntimeError is
thrown.</p>
<p>For abstract-valued input ports, you can provide any ValueType that is
compatible with the model type provided when the port was declared. If
the type has a copy constructor it will be copied into a
<code class="docutils literal notranslate"><span class="pre">Value&lt;ValueType&gt;</span></code> object for storage. Otherwise it must have an
accessible <code class="docutils literal notranslate"><span class="pre">Clone()</span></code> method and it is stored using the type returned
by that method, which must be ValueType or a base class of ValueType.
Eigen objects and expressions are not accepted directly, but you can
store then in abstract ports by providing an already-abstract object
like <code class="docutils literal notranslate"><span class="pre">Value&lt;MatrixXd&gt;(your_matrix)</span></code>.</p>
<p>The returned FixedInputPortValue reference may be used to modify the
input port’s value subsequently using the appropriate
FixedInputPortValue method, which will ensure that cache invalidation
notifications are delivered.</p>
<dl class="simple">
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">ValueType</span></code>:</dt><dd><p>The type of the supplied <code class="docutils literal notranslate"><span class="pre">value</span></code> object. This will be inferred
so no template argument need be specified. The type must be copy
constructible or have an accessible <code class="docutils literal notranslate"><span class="pre">Clone()</span></code> method.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>A Context that is compatible with the System that owns this port.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">value</span></code>:</dt><dd><p>The fixed value for this port. Must be convertible to the input
port’s data type.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a reference to the FixedInputPortValue object in the Context that
contains this port’s value.</p>
</dd>
</dl>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">context</span></code> is compatible with the System that owns this
InputPort.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">value</span></code> is compatible with this InputPort’s data type.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>FixValue(self: pydrake.systems.framework.InputPort, context: pydrake.systems.framework.Context, value: object) -&gt; pydrake.systems.framework.FixedInputPortValue</p></li>
</ol>
<p>Provides a fixed value for this InputPort in the given Context. If the
port is already connected, this value will override the connected
source value. (By “connected” we mean that the port appeared in a
DiagramBuilder::Connect() call.)</p>
<p>For vector-valued input ports, you can provide an Eigen vector
expression, a BasicVector object, or a scalar (treated as a Vector1).
In each of these cases the value is copied into a
<code class="docutils literal notranslate"><span class="pre">Value&lt;BasicVector&gt;</span></code>. If the original value was a
BasicVector-derived object, its concrete type is maintained although
the stored type is still <code class="docutils literal notranslate"><span class="pre">Value&lt;BasicVector&gt;</span></code>. The supplied vector
must have the right size for the vector port or an RuntimeError is
thrown.</p>
<p>For abstract-valued input ports, you can provide any ValueType that is
compatible with the model type provided when the port was declared. If
the type has a copy constructor it will be copied into a
<code class="docutils literal notranslate"><span class="pre">Value&lt;ValueType&gt;</span></code> object for storage. Otherwise it must have an
accessible <code class="docutils literal notranslate"><span class="pre">Clone()</span></code> method and it is stored using the type returned
by that method, which must be ValueType or a base class of ValueType.
Eigen objects and expressions are not accepted directly, but you can
store then in abstract ports by providing an already-abstract object
like <code class="docutils literal notranslate"><span class="pre">Value&lt;MatrixXd&gt;(your_matrix)</span></code>.</p>
<p>The returned FixedInputPortValue reference may be used to modify the
input port’s value subsequently using the appropriate
FixedInputPortValue method, which will ensure that cache invalidation
notifications are delivered.</p>
<dl class="simple">
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">ValueType</span></code>:</dt><dd><p>The type of the supplied <code class="docutils literal notranslate"><span class="pre">value</span></code> object. This will be inferred
so no template argument need be specified. The type must be copy
constructible or have an accessible <code class="docutils literal notranslate"><span class="pre">Clone()</span></code> method.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>A Context that is compatible with the System that owns this port.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">value</span></code>:</dt><dd><p>The fixed value for this port. Must be convertible to the input
port’s data type.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a reference to the FixedInputPortValue object in the Context that
contains this port’s value.</p>
</dd>
</dl>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">context</span></code> is compatible with the System that owns this
InputPort.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">value</span></code> is compatible with this InputPort’s data type.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">InputPort.get_data_type(self:</span> <span class="pre">pydrake.systems.framework.InputPort)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.PortDataType</span></span></dt>
<dd><p>Returns the port data type.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">InputPort.get_index(self:</span> <span class="pre">pydrake.systems.framework.InputPort)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.InputPortIndex</span></span></dt>
<dd><p>Returns the index of this input port within the owning System. For a
Diagram, this will be the index within the Diagram, <em>not</em> the index
within a LeafSystem whose input port was exported.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">InputPort.get_name(self:</span> <span class="pre">pydrake.systems.framework.InputPort)</span> <span class="pre">-&gt;</span> <span class="pre">str</span></span></dt>
<dd><p>Get port name.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">InputPort.get_system(self:</span> <span class="pre">pydrake.systems.framework.InputPort)</span> <span class="pre">-&gt;</span> <span class="pre">object</span></span></dt>
<dd><p>Returns a reference to the System that owns this input port. Note that
for a Diagram input port this will be the Diagram, not the LeafSystem
whose input port was exported.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">InputPort.GetFullDescription(self:</span> <span class="pre">pydrake.systems.framework.InputPort)</span> <span class="pre">-&gt;</span> <span class="pre">str</span></span></dt>
<dd><p>Returns a verbose human-readable description of port. This is useful
for error messages or debugging.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">InputPort.HasValue(self:</span> <span class="pre">pydrake.systems.framework.InputPort,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns true iff this port is connected or has had a fixed value
provided in the given Context. Beware that at the moment, this could
be an expensive operation, because the value is brought up-to-date as
part of this operation.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">InputPort.size(self:</span> <span class="pre">pydrake.systems.framework.InputPort)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the fixed size expected for a vector-valued port. Not
meaningful for abstract-valued ports.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">InputPort.ticket(self:</span> <span class="pre">pydrake.systems.framework.InputPort)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.DependencyTicket</span></span></dt>
<dd><p>(Advanced.) Returns the DependencyTicket for this port within the
owning System.</p>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">InputPort_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">InputPort_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">InputPort_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">InputPort_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">InputPort_[AutoDiffXd]</span></span></dt>
<dd><p>An InputPort is a System resource that describes the kind of input a
System accepts, on a given port. It does not directly contain any
runtime input port data; that is always contained in a Context. The
actual value will be either the value of an OutputPort to which this
is connected, or a fixed value set in a Context.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">InputPort_[AutoDiffXd].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">InputPort_[AutoDiffXd].Allocate(self:</span> <span class="pre">pydrake.systems.framework.InputPort_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.common.value.AbstractValue</span></span></dt>
<dd><p>Allocates a concrete object suitable for holding the value to be
provided by this input port, and returns that as an AbstractValue. The
returned object will never be null.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">InputPort_[AutoDiffXd].Eval(self:</span> <span class="pre">pydrake.systems.framework.InputPort_[AutoDiffXd],</span> <span class="pre">arg0:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">object</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">InputPort_[AutoDiffXd].EvalAbstract(self:</span> <span class="pre">pydrake.systems.framework.InputPort_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.common.value.AbstractValue</span></span></dt>
<dd><p>(Advanced.) Returns the value of this input port, typed as an AbstractValue. Most users should call Eval() instead. This method is only needed when the result will be passed into some other API that only accepts an AbstractValue.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">InputPort_[AutoDiffXd].EvalBasicVector(self:</span> <span class="pre">pydrake.systems.framework.InputPort_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">object</span></span></dt>
<dd><p>(Advanced.) Returns the value of this input port, typed as a BasicVector. Most users should call Eval() instead. This method is only needed when the result will be passed into some other API that only accepts a BasicVector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">InputPort_[AutoDiffXd].FixValue(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>FixValue(self: pydrake.systems.framework.InputPort_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], value: pydrake.common.value.AbstractValue) -&gt; pydrake.systems.framework.FixedInputPortValue</p></li>
</ol>
<p>Provides a fixed value for this InputPort in the given Context. If the
port is already connected, this value will override the connected
source value. (By “connected” we mean that the port appeared in a
DiagramBuilder::Connect() call.)</p>
<p>For vector-valued input ports, you can provide an Eigen vector
expression, a BasicVector object, or a scalar (treated as a Vector1).
In each of these cases the value is copied into a
<code class="docutils literal notranslate"><span class="pre">Value&lt;BasicVector&gt;</span></code>. If the original value was a
BasicVector-derived object, its concrete type is maintained although
the stored type is still <code class="docutils literal notranslate"><span class="pre">Value&lt;BasicVector&gt;</span></code>. The supplied vector
must have the right size for the vector port or an RuntimeError is
thrown.</p>
<p>For abstract-valued input ports, you can provide any ValueType that is
compatible with the model type provided when the port was declared. If
the type has a copy constructor it will be copied into a
<code class="docutils literal notranslate"><span class="pre">Value&lt;ValueType&gt;</span></code> object for storage. Otherwise it must have an
accessible <code class="docutils literal notranslate"><span class="pre">Clone()</span></code> method and it is stored using the type returned
by that method, which must be ValueType or a base class of ValueType.
Eigen objects and expressions are not accepted directly, but you can
store then in abstract ports by providing an already-abstract object
like <code class="docutils literal notranslate"><span class="pre">Value&lt;MatrixXd&gt;(your_matrix)</span></code>.</p>
<p>The returned FixedInputPortValue reference may be used to modify the
input port’s value subsequently using the appropriate
FixedInputPortValue method, which will ensure that cache invalidation
notifications are delivered.</p>
<dl class="simple">
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">ValueType</span></code>:</dt><dd><p>The type of the supplied <code class="docutils literal notranslate"><span class="pre">value</span></code> object. This will be inferred
so no template argument need be specified. The type must be copy
constructible or have an accessible <code class="docutils literal notranslate"><span class="pre">Clone()</span></code> method.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>A Context that is compatible with the System that owns this port.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">value</span></code>:</dt><dd><p>The fixed value for this port. Must be convertible to the input
port’s data type.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a reference to the FixedInputPortValue object in the Context that
contains this port’s value.</p>
</dd>
</dl>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">context</span></code> is compatible with the System that owns this
InputPort.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">value</span></code> is compatible with this InputPort’s data type.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>FixValue(self: pydrake.systems.framework.InputPort_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], value: object) -&gt; pydrake.systems.framework.FixedInputPortValue</p></li>
</ol>
<p>Provides a fixed value for this InputPort in the given Context. If the
port is already connected, this value will override the connected
source value. (By “connected” we mean that the port appeared in a
DiagramBuilder::Connect() call.)</p>
<p>For vector-valued input ports, you can provide an Eigen vector
expression, a BasicVector object, or a scalar (treated as a Vector1).
In each of these cases the value is copied into a
<code class="docutils literal notranslate"><span class="pre">Value&lt;BasicVector&gt;</span></code>. If the original value was a
BasicVector-derived object, its concrete type is maintained although
the stored type is still <code class="docutils literal notranslate"><span class="pre">Value&lt;BasicVector&gt;</span></code>. The supplied vector
must have the right size for the vector port or an RuntimeError is
thrown.</p>
<p>For abstract-valued input ports, you can provide any ValueType that is
compatible with the model type provided when the port was declared. If
the type has a copy constructor it will be copied into a
<code class="docutils literal notranslate"><span class="pre">Value&lt;ValueType&gt;</span></code> object for storage. Otherwise it must have an
accessible <code class="docutils literal notranslate"><span class="pre">Clone()</span></code> method and it is stored using the type returned
by that method, which must be ValueType or a base class of ValueType.
Eigen objects and expressions are not accepted directly, but you can
store then in abstract ports by providing an already-abstract object
like <code class="docutils literal notranslate"><span class="pre">Value&lt;MatrixXd&gt;(your_matrix)</span></code>.</p>
<p>The returned FixedInputPortValue reference may be used to modify the
input port’s value subsequently using the appropriate
FixedInputPortValue method, which will ensure that cache invalidation
notifications are delivered.</p>
<dl class="simple">
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">ValueType</span></code>:</dt><dd><p>The type of the supplied <code class="docutils literal notranslate"><span class="pre">value</span></code> object. This will be inferred
so no template argument need be specified. The type must be copy
constructible or have an accessible <code class="docutils literal notranslate"><span class="pre">Clone()</span></code> method.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>A Context that is compatible with the System that owns this port.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">value</span></code>:</dt><dd><p>The fixed value for this port. Must be convertible to the input
port’s data type.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a reference to the FixedInputPortValue object in the Context that
contains this port’s value.</p>
</dd>
</dl>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">context</span></code> is compatible with the System that owns this
InputPort.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">value</span></code> is compatible with this InputPort’s data type.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">InputPort_[AutoDiffXd].get_data_type(self:</span> <span class="pre">pydrake.systems.framework.InputPort_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.PortDataType</span></span></dt>
<dd><p>Returns the port data type.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">InputPort_[AutoDiffXd].get_index(self:</span> <span class="pre">pydrake.systems.framework.InputPort_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.InputPortIndex</span></span></dt>
<dd><p>Returns the index of this input port within the owning System. For a
Diagram, this will be the index within the Diagram, <em>not</em> the index
within a LeafSystem whose input port was exported.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">InputPort_[AutoDiffXd].get_name(self:</span> <span class="pre">pydrake.systems.framework.InputPort_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">str</span></span></dt>
<dd><p>Get port name.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">InputPort_[AutoDiffXd].get_system(self:</span> <span class="pre">pydrake.systems.framework.InputPort_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">object</span></span></dt>
<dd><p>Returns a reference to the System that owns this input port. Note that
for a Diagram input port this will be the Diagram, not the LeafSystem
whose input port was exported.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">InputPort_[AutoDiffXd].GetFullDescription(self:</span> <span class="pre">pydrake.systems.framework.InputPort_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">str</span></span></dt>
<dd><p>Returns a verbose human-readable description of port. This is useful
for error messages or debugging.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">InputPort_[AutoDiffXd].HasValue(self:</span> <span class="pre">pydrake.systems.framework.InputPort_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns true iff this port is connected or has had a fixed value
provided in the given Context. Beware that at the moment, this could
be an expensive operation, because the value is brought up-to-date as
part of this operation.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">InputPort_[AutoDiffXd].size(self:</span> <span class="pre">pydrake.systems.framework.InputPort_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the fixed size expected for a vector-valued port. Not
meaningful for abstract-valued ports.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">InputPort_[AutoDiffXd].ticket(self:</span> <span class="pre">pydrake.systems.framework.InputPort_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.DependencyTicket</span></span></dt>
<dd><p>(Advanced.) Returns the DependencyTicket for this port within the
owning System.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">InputPort_[Expression]</span></span></dt>
<dd><p>An InputPort is a System resource that describes the kind of input a
System accepts, on a given port. It does not directly contain any
runtime input port data; that is always contained in a Context. The
actual value will be either the value of an OutputPort to which this
is connected, or a fixed value set in a Context.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">InputPort_[Expression].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">InputPort_[Expression].Allocate(self:</span> <span class="pre">pydrake.systems.framework.InputPort_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.common.value.AbstractValue</span></span></dt>
<dd><p>Allocates a concrete object suitable for holding the value to be
provided by this input port, and returns that as an AbstractValue. The
returned object will never be null.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">InputPort_[Expression].Eval(self:</span> <span class="pre">pydrake.systems.framework.InputPort_[Expression],</span> <span class="pre">arg0:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">object</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">InputPort_[Expression].EvalAbstract(self:</span> <span class="pre">pydrake.systems.framework.InputPort_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.common.value.AbstractValue</span></span></dt>
<dd><p>(Advanced.) Returns the value of this input port, typed as an AbstractValue. Most users should call Eval() instead. This method is only needed when the result will be passed into some other API that only accepts an AbstractValue.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">InputPort_[Expression].EvalBasicVector(self:</span> <span class="pre">pydrake.systems.framework.InputPort_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">object</span></span></dt>
<dd><p>(Advanced.) Returns the value of this input port, typed as a BasicVector. Most users should call Eval() instead. This method is only needed when the result will be passed into some other API that only accepts a BasicVector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">InputPort_[Expression].FixValue(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>FixValue(self: pydrake.systems.framework.InputPort_[Expression], context: pydrake.systems.framework.Context_[Expression], value: pydrake.common.value.AbstractValue) -&gt; pydrake.systems.framework.FixedInputPortValue</p></li>
</ol>
<p>Provides a fixed value for this InputPort in the given Context. If the
port is already connected, this value will override the connected
source value. (By “connected” we mean that the port appeared in a
DiagramBuilder::Connect() call.)</p>
<p>For vector-valued input ports, you can provide an Eigen vector
expression, a BasicVector object, or a scalar (treated as a Vector1).
In each of these cases the value is copied into a
<code class="docutils literal notranslate"><span class="pre">Value&lt;BasicVector&gt;</span></code>. If the original value was a
BasicVector-derived object, its concrete type is maintained although
the stored type is still <code class="docutils literal notranslate"><span class="pre">Value&lt;BasicVector&gt;</span></code>. The supplied vector
must have the right size for the vector port or an RuntimeError is
thrown.</p>
<p>For abstract-valued input ports, you can provide any ValueType that is
compatible with the model type provided when the port was declared. If
the type has a copy constructor it will be copied into a
<code class="docutils literal notranslate"><span class="pre">Value&lt;ValueType&gt;</span></code> object for storage. Otherwise it must have an
accessible <code class="docutils literal notranslate"><span class="pre">Clone()</span></code> method and it is stored using the type returned
by that method, which must be ValueType or a base class of ValueType.
Eigen objects and expressions are not accepted directly, but you can
store then in abstract ports by providing an already-abstract object
like <code class="docutils literal notranslate"><span class="pre">Value&lt;MatrixXd&gt;(your_matrix)</span></code>.</p>
<p>The returned FixedInputPortValue reference may be used to modify the
input port’s value subsequently using the appropriate
FixedInputPortValue method, which will ensure that cache invalidation
notifications are delivered.</p>
<dl class="simple">
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">ValueType</span></code>:</dt><dd><p>The type of the supplied <code class="docutils literal notranslate"><span class="pre">value</span></code> object. This will be inferred
so no template argument need be specified. The type must be copy
constructible or have an accessible <code class="docutils literal notranslate"><span class="pre">Clone()</span></code> method.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>A Context that is compatible with the System that owns this port.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">value</span></code>:</dt><dd><p>The fixed value for this port. Must be convertible to the input
port’s data type.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a reference to the FixedInputPortValue object in the Context that
contains this port’s value.</p>
</dd>
</dl>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">context</span></code> is compatible with the System that owns this
InputPort.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">value</span></code> is compatible with this InputPort’s data type.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>FixValue(self: pydrake.systems.framework.InputPort_[Expression], context: pydrake.systems.framework.Context_[Expression], value: object) -&gt; pydrake.systems.framework.FixedInputPortValue</p></li>
</ol>
<p>Provides a fixed value for this InputPort in the given Context. If the
port is already connected, this value will override the connected
source value. (By “connected” we mean that the port appeared in a
DiagramBuilder::Connect() call.)</p>
<p>For vector-valued input ports, you can provide an Eigen vector
expression, a BasicVector object, or a scalar (treated as a Vector1).
In each of these cases the value is copied into a
<code class="docutils literal notranslate"><span class="pre">Value&lt;BasicVector&gt;</span></code>. If the original value was a
BasicVector-derived object, its concrete type is maintained although
the stored type is still <code class="docutils literal notranslate"><span class="pre">Value&lt;BasicVector&gt;</span></code>. The supplied vector
must have the right size for the vector port or an RuntimeError is
thrown.</p>
<p>For abstract-valued input ports, you can provide any ValueType that is
compatible with the model type provided when the port was declared. If
the type has a copy constructor it will be copied into a
<code class="docutils literal notranslate"><span class="pre">Value&lt;ValueType&gt;</span></code> object for storage. Otherwise it must have an
accessible <code class="docutils literal notranslate"><span class="pre">Clone()</span></code> method and it is stored using the type returned
by that method, which must be ValueType or a base class of ValueType.
Eigen objects and expressions are not accepted directly, but you can
store then in abstract ports by providing an already-abstract object
like <code class="docutils literal notranslate"><span class="pre">Value&lt;MatrixXd&gt;(your_matrix)</span></code>.</p>
<p>The returned FixedInputPortValue reference may be used to modify the
input port’s value subsequently using the appropriate
FixedInputPortValue method, which will ensure that cache invalidation
notifications are delivered.</p>
<dl class="simple">
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">ValueType</span></code>:</dt><dd><p>The type of the supplied <code class="docutils literal notranslate"><span class="pre">value</span></code> object. This will be inferred
so no template argument need be specified. The type must be copy
constructible or have an accessible <code class="docutils literal notranslate"><span class="pre">Clone()</span></code> method.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>A Context that is compatible with the System that owns this port.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">value</span></code>:</dt><dd><p>The fixed value for this port. Must be convertible to the input
port’s data type.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a reference to the FixedInputPortValue object in the Context that
contains this port’s value.</p>
</dd>
</dl>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">context</span></code> is compatible with the System that owns this
InputPort.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">value</span></code> is compatible with this InputPort’s data type.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">InputPort_[Expression].get_data_type(self:</span> <span class="pre">pydrake.systems.framework.InputPort_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.PortDataType</span></span></dt>
<dd><p>Returns the port data type.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">InputPort_[Expression].get_index(self:</span> <span class="pre">pydrake.systems.framework.InputPort_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.InputPortIndex</span></span></dt>
<dd><p>Returns the index of this input port within the owning System. For a
Diagram, this will be the index within the Diagram, <em>not</em> the index
within a LeafSystem whose input port was exported.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">InputPort_[Expression].get_name(self:</span> <span class="pre">pydrake.systems.framework.InputPort_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">str</span></span></dt>
<dd><p>Get port name.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">InputPort_[Expression].get_system(self:</span> <span class="pre">pydrake.systems.framework.InputPort_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">object</span></span></dt>
<dd><p>Returns a reference to the System that owns this input port. Note that
for a Diagram input port this will be the Diagram, not the LeafSystem
whose input port was exported.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">InputPort_[Expression].GetFullDescription(self:</span> <span class="pre">pydrake.systems.framework.InputPort_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">str</span></span></dt>
<dd><p>Returns a verbose human-readable description of port. This is useful
for error messages or debugging.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">InputPort_[Expression].HasValue(self:</span> <span class="pre">pydrake.systems.framework.InputPort_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns true iff this port is connected or has had a fixed value
provided in the given Context. Beware that at the moment, this could
be an expensive operation, because the value is brought up-to-date as
part of this operation.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">InputPort_[Expression].size(self:</span> <span class="pre">pydrake.systems.framework.InputPort_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the fixed size expected for a vector-valued port. Not
meaningful for abstract-valued ports.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">InputPort_[Expression].ticket(self:</span> <span class="pre">pydrake.systems.framework.InputPort_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.DependencyTicket</span></span></dt>
<dd><p>(Advanced.) Returns the DependencyTicket for this port within the
owning System.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">InputPortIndex</span></span></dt>
<dd><dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">InputPortIndex.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.systems.framework.InputPortIndex) -&gt; None</p></li>
</ol>
<p>Default constructor; the result is an <em>invalid</em> index. This only
exists to serve applications which require a default constructor.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.systems.framework.InputPortIndex, arg0: int) -&gt; None</p></li>
</ol>
<p>Construction from a non-negative <code class="docutils literal notranslate"><span class="pre">int</span></code> value. The value must lie in
the range of [0, 2³¹). Constructor only promises to test validity in
Debug build.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">InputPortIndex.is_valid(self:</span> <span class="pre">pydrake.systems.framework.InputPortIndex)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Reports if the index is valid–the only operation on an invalid index
that doesn’t throw an exception in Debug builds.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">InputPortSelection</span></span></dt>
<dd><p>Members:</p>
<p>kNoInput</p>
<p>kUseFirstInputIfItExists</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">InputPortSelection.__init__(self:</span> <span class="pre">pydrake.systems.framework.InputPortSelection,</span> <span class="pre">value:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">InputPortSelection.kNoInput</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">InputPortSelection.kUseFirstInputIfItExists</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">InputPortSelection.name</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">InputPortSelection.value</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafContext</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.Context</span></code></p>
<p>LeafContext contains all prerequisite data necessary to uniquely
determine the results of computations performed by the associated
LeafSystem.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>Context for more information.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">LeafContext_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafContext.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafContext_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">LeafContext_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">LeafContext_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">LeafContext_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafContext_[AutoDiffXd]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.Context_[AutoDiffXd]</span></code></p>
<p>LeafContext contains all prerequisite data necessary to uniquely
determine the results of computations performed by the associated
LeafSystem.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>Context for more information.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafContext_[AutoDiffXd].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafContext_[Expression]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.Context_[Expression]</span></code></p>
<p>LeafContext contains all prerequisite data necessary to uniquely
determine the results of computations performed by the associated
LeafSystem.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>Context for more information.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafContext_[Expression].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafOutputPort</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.OutputPort</span></code></p>
<p>(Advanced.) Implements an output port whose value is managed by a
cache entry in the same LeafSystem as the port. This is intended for
internal use in implementing the DeclareOutputPort() variants in
LeafSystem.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">LeafOutputPort_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafOutputPort.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafOutputPort.cache_entry(self:</span> <span class="pre">pydrake.systems.framework.LeafOutputPort)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.CacheEntry</span></span></dt>
<dd><p>Returns the cache entry associated with this output port.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafOutputPort.disable_caching_by_default(self:</span> <span class="pre">pydrake.systems.framework.LeafOutputPort)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>(Debugging) Specifies that caching should be disabled for this output
port when a Context is first allocated. This is useful if you have
observed different behavior with caching on or off and would like to
determine if the problem is caused by this port.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CacheEntry::disable_caching_by_default()</p>
</div>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafOutputPort_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">LeafOutputPort_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">LeafOutputPort_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">LeafOutputPort_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafOutputPort_[AutoDiffXd]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.OutputPort_[AutoDiffXd]</span></code></p>
<p>(Advanced.) Implements an output port whose value is managed by a
cache entry in the same LeafSystem as the port. This is intended for
internal use in implementing the DeclareOutputPort() variants in
LeafSystem.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafOutputPort_[AutoDiffXd].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafOutputPort_[AutoDiffXd].cache_entry(self:</span> <span class="pre">pydrake.systems.framework.LeafOutputPort_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.CacheEntry</span></span></dt>
<dd><p>Returns the cache entry associated with this output port.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafOutputPort_[AutoDiffXd].disable_caching_by_default(self:</span> <span class="pre">pydrake.systems.framework.LeafOutputPort_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>(Debugging) Specifies that caching should be disabled for this output
port when a Context is first allocated. This is useful if you have
observed different behavior with caching on or off and would like to
determine if the problem is caused by this port.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CacheEntry::disable_caching_by_default()</p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafOutputPort_[Expression]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.OutputPort_[Expression]</span></code></p>
<p>(Advanced.) Implements an output port whose value is managed by a
cache entry in the same LeafSystem as the port. This is intended for
internal use in implementing the DeclareOutputPort() variants in
LeafSystem.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafOutputPort_[Expression].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafOutputPort_[Expression].cache_entry(self:</span> <span class="pre">pydrake.systems.framework.LeafOutputPort_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.CacheEntry</span></span></dt>
<dd><p>Returns the cache entry associated with this output port.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafOutputPort_[Expression].disable_caching_by_default(self:</span> <span class="pre">pydrake.systems.framework.LeafOutputPort_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>(Debugging) Specifies that caching should be disabled for this output
port when a Context is first allocated. This is useful if you have
observed different behavior with caching on or off and would like to
determine if the problem is caused by this port.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CacheEntry::disable_caching_by_default()</p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafSystem</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.System</span></code></p>
<p>A superclass template that extends System with some convenience
utilities that are not applicable to Diagrams.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">LeafSystem_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafSystem.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.systems.framework.LeafSystem) -&gt; None</p></li>
</ol>
<p>Default constructor that declares no inputs, outputs, state,
parameters, events, nor scalar-type conversion support (AutoDiff,
etc.). To enable AutoDiff support, use the SystemScalarConverter-based
constructor.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.systems.framework.LeafSystem, converter: pydrake.systems.framework.SystemScalarConverter) -&gt; None</p></li>
</ol>
<p>Constructor that declares no inputs, outputs, state, parameters, or
events, but allows subclasses to declare scalar-type conversion
support (AutoDiff, etc.).</p>
<p>The scalar-type conversion support will use <code class="docutils literal notranslate"><span class="pre">converter</span></code>. To enable
scalar-type conversion support, pass a <code class="docutils literal notranslate"><span class="pre">SystemTypeTag&lt;S&gt;{}</span></code> where
<code class="docutils literal notranslate"><span class="pre">S</span></code> must be the exact class of <code class="docutils literal notranslate"><span class="pre">this</span></code> being constructed.</p>
<p>See system_scalar_conversion for detailed background and examples
related to scalar-type conversion support.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafSystem.DeclareAbstractInputPort(self:</span> <span class="pre">pydrake.systems.framework.LeafSystem,</span> <span class="pre">name:</span> <span class="pre">str,</span> <span class="pre">model_value:</span> <span class="pre">pydrake.common.value.AbstractValue)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.InputPort</span></span></dt>
<dd><p>Declares an abstract-valued input port using the given
<code class="docutils literal notranslate"><span class="pre">model_value</span></code>. This is the best way to declare LeafSystem abstract
input ports.</p>
<p>Any port connected to this input, and any call to FixValue for this
input, must provide for values whose type matches this
<code class="docutils literal notranslate"><span class="pre">model_value</span></code>.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>System::DeclareInputPort() for more information.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafSystem.DeclareAbstractOutputPort(self:</span> <span class="pre">pydrake.systems.framework.LeafSystem,</span> <span class="pre">name:</span> <span class="pre">str,</span> <span class="pre">alloc:</span> <span class="pre">Callable,</span> <span class="pre">calc:</span> <span class="pre">Callable[[object,</span> <span class="pre">object],</span> <span class="pre">None],</span> <span class="pre">prerequisites_of_calc:</span> <span class="pre">set[pydrake.systems.framework.DependencyTicket]</span> <span class="pre">=</span> <span class="pre">{DependencyTicket(15)})</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.OutputPort</span></span></dt>
<dd><p>(Advanced) Declares an abstract-valued output port using the given
allocator and calculator functions provided in their most generic
forms. If you have a member function available use one of the other
signatures.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">alloc</span></code>:</dt><dd><p>Callback function that allocates storage for the value. It takes
no arguments and must return an AbstractValue.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">calc</span></code>:</dt><dd><p>Callback function that computes the value. It takes two arguments
(context, value) and does not return anything; instead, it should
mutate the AbstractValue object pointed to by <code class="docutils literal notranslate"><span class="pre">value</span></code> with the
new result.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>LeafOutputPort::AllocCallback, LeafOutputPort::CalcCallback</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafSystem.DeclareAbstractParameter(self:</span> <span class="pre">pydrake.systems.framework.LeafSystem,</span> <span class="pre">model_value:</span> <span class="pre">pydrake.common.value.AbstractValue)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Declares an abstract parameter using the given <code class="docutils literal notranslate"><span class="pre">model_value</span></code>.
LeafSystem’s default implementation of SetDefaultParameters() will
reset parameters to their model values. Returns the index of the new
parameter.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafSystem.DeclareAbstractState(self:</span> <span class="pre">pydrake.systems.framework.LeafSystem,</span> <span class="pre">model_value:</span> <span class="pre">pydrake.common.value.AbstractValue)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.AbstractStateIndex</span></span></dt>
<dd><p>Declares an abstract state variable and provides a model value for it.
A Context obtained with CreateDefaultContext() will contain this
abstract state variable initially set to a clone of the
<code class="docutils literal notranslate"><span class="pre">model_value</span></code> given here. The actual concrete type is always
preserved.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">model_value</span></code>:</dt><dd><p>The abstract state model value to be cloned as needed.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>index of the declared abstract state variable.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafSystem.DeclareContinuousState(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>DeclareContinuousState(self: pydrake.systems.framework.LeafSystem, num_state_variables: int) -&gt; pydrake.systems.framework.ContinuousStateIndex</p></li>
</ol>
<p>Declares that this System should reserve continuous state with
<code class="docutils literal notranslate"><span class="pre">num_state_variables</span></code> state variables, which have no second-order
structure.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>index of the declared state (currently always zero).</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>DeclareContinuousState(self: pydrake.systems.framework.LeafSystem, num_q: int, num_v: int, num_z: int) -&gt; pydrake.systems.framework.ContinuousStateIndex</p></li>
</ol>
<p>Declares that this System should reserve continuous state with
<code class="docutils literal notranslate"><span class="pre">num_q</span></code> generalized positions, <code class="docutils literal notranslate"><span class="pre">num_v</span></code> generalized velocities, and
<code class="docutils literal notranslate"><span class="pre">num_z</span></code> miscellaneous state variables.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>index of the declared state (currently always zero).</p>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li><p>DeclareContinuousState(self: pydrake.systems.framework.LeafSystem, model_vector: pydrake.systems.framework.BasicVector) -&gt; pydrake.systems.framework.ContinuousStateIndex</p></li>
</ol>
<p>Declares that this System should reserve continuous state with
<code class="docutils literal notranslate"><span class="pre">model_vector</span></code>.size() miscellaneous state variables, stored in a
vector cloned from <code class="docutils literal notranslate"><span class="pre">model_vector</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>index of the declared state (currently always zero).</p>
</dd>
</dl>
<ol class="arabic simple" start="4">
<li><p>DeclareContinuousState(self: pydrake.systems.framework.LeafSystem, model_vector: pydrake.systems.framework.BasicVector, num_q: int, num_v: int, num_z: int) -&gt; pydrake.systems.framework.ContinuousStateIndex</p></li>
</ol>
<p>Declares that this System should reserve continuous state with
<code class="docutils literal notranslate"><span class="pre">num_q</span></code> generalized positions, <code class="docutils literal notranslate"><span class="pre">num_v</span></code> generalized velocities, and
<code class="docutils literal notranslate"><span class="pre">num_z</span></code> miscellaneous state variables, stored in a vector cloned
from <code class="docutils literal notranslate"><span class="pre">model_vector</span></code>. Aborts if <code class="docutils literal notranslate"><span class="pre">model_vector</span></code> has the wrong size.
If the <code class="docutils literal notranslate"><span class="pre">model_vector</span></code> declares any VectorBase::GetElementBounds()
constraints, they will be re-declared as inequality constraints on
this system (see DeclareInequalityConstraint()).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>index of the declared state (currently always zero).</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafSystem.DeclareDiscreteState(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>DeclareDiscreteState(self: pydrake.systems.framework.LeafSystem, model_vector: pydrake.systems.framework.BasicVector) -&gt; pydrake.systems.framework.DiscreteStateIndex</p></li>
</ol>
<p>Declares a discrete state group with <code class="docutils literal notranslate"><span class="pre">model_vector</span></code>.size() state
variables, stored in a vector cloned from <code class="docutils literal notranslate"><span class="pre">model_vector</span></code> (preserving
the concrete type and value).</p>
<ol class="arabic simple" start="2">
<li><p>DeclareDiscreteState(self: pydrake.systems.framework.LeafSystem, vector: numpy.ndarray[numpy.float64[m, 1]]) -&gt; pydrake.systems.framework.DiscreteStateIndex</p></li>
</ol>
<p>Declares a discrete state group with <code class="docutils literal notranslate"><span class="pre">vector</span></code>.size() state
variables, stored in a BasicVector initialized with the contents of
<code class="docutils literal notranslate"><span class="pre">vector</span></code>.</p>
<ol class="arabic simple" start="3">
<li><p>DeclareDiscreteState(self: pydrake.systems.framework.LeafSystem, num_state_variables: int) -&gt; pydrake.systems.framework.DiscreteStateIndex</p></li>
</ol>
<p>Declares a discrete state group with <code class="docutils literal notranslate"><span class="pre">num_state_variables</span></code> state
variables, stored in a BasicVector initialized to be all-zero. If you
want non-zero initial values, use an alternate DeclareDiscreteState()
signature that accepts a <code class="docutils literal notranslate"><span class="pre">model_vector</span></code> parameter.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">num_state_variables</span></code> must be non-negative.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafSystem.DeclareForcedDiscreteUpdateEvent(self:</span> <span class="pre">pydrake.systems.framework.LeafSystem,</span> <span class="pre">update:</span> <span class="pre">Callable[[pydrake.systems.framework.Context,</span> <span class="pre">pydrake.systems.framework.DiscreteValues],</span> <span class="pre">Optional[pydrake.systems.framework.EventStatus]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Declares a function that is called whenever a user directly calls
CalcForcedDiscreteVariableUpdate(const Context&amp;, DiscreteValues&lt;T&gt;*).
Multiple calls to DeclareForcedDiscreteUpdateEvent() will cause
multiple handlers to be called upon a call to
CalcForcedDiscreteVariableUpdate(); these handlers will be called with
the same const Context in arbitrary order. The handler should be a
class member function (method) with this signature:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">EventStatus</span><span class="w"> </span><span class="nf">MySystem::MyDiscreteVariableUpdates</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Context</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="p">,</span>
<span class="n">DiscreteValues</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span><span class="p">);</span>
</pre></div>
</div>
</details><p>where <code class="docutils literal notranslate"><span class="pre">MySystem</span></code> is a class derived from <code class="docutils literal notranslate"><span class="pre">LeafSystem&lt;T&gt;</span></code> and the
method name is arbitrary.</p>
<p>See declare_forced_events “Declare forced events” for more
information.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">this</span></code> must be dynamic_cast-able to MySystem.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">update</span></code> must not be null.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafSystem.DeclareForcedPublishEvent(self:</span> <span class="pre">pydrake.systems.framework.LeafSystem,</span> <span class="pre">publish:</span> <span class="pre">Callable[[pydrake.systems.framework.Context],</span> <span class="pre">Optional[pydrake.systems.framework.EventStatus]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Declares a function that is called whenever a user directly calls
ForcedPublish(const Context&amp;). Multiple calls to
DeclareForcedPublishEvent() will cause multiple handlers to be called
upon a call to ForcedPublish(); these handlers which will be called
with the same const Context in arbitrary order. The handler should be
a class member function (method) with this signature:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">EventStatus</span><span class="w"> </span><span class="nf">MySystem::MyPublish</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Context</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
</details><p>where <code class="docutils literal notranslate"><span class="pre">MySystem</span></code> is a class derived from <code class="docutils literal notranslate"><span class="pre">LeafSystem&lt;T&gt;</span></code> and the
method name is arbitrary.</p>
<p>See declare_forced_events “Declare forced events” for more
information.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">this</span></code> must be dynamic_cast-able to MySystem.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">publish</span></code> must not be null.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafSystem.DeclareForcedUnrestrictedUpdateEvent(self:</span> <span class="pre">pydrake.systems.framework.LeafSystem,</span> <span class="pre">update:</span> <span class="pre">Callable[[pydrake.systems.framework.Context,</span> <span class="pre">pydrake.systems.framework.State],</span> <span class="pre">Optional[pydrake.systems.framework.EventStatus]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Declares a function that is called whenever a user directly calls
CalcForcedUnrestrictedUpdate(const Context&amp;, State&lt;T&gt;*). Multiple
calls to DeclareForcedUnrestrictedUpdateEvent() will cause multiple
handlers to be called upon a call to CalcForcedUnrestrictedUpdate();
these handlers which will be called with the same const Context in
arbitrary order.The handler should be a class member function (method)
with this signature:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">EventStatus</span><span class="w"> </span><span class="nf">MySystem::MyUnrestrictedUpdates</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Context</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="p">,</span>
<span class="n">State</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span><span class="p">);</span>
</pre></div>
</div>
</details><p>where <code class="docutils literal notranslate"><span class="pre">MySystem</span></code> is a class derived from <code class="docutils literal notranslate"><span class="pre">LeafSystem&lt;T&gt;</span></code> and the
method name is arbitrary.</p>
<p>See declare_forced_events “Declare forced events” for more
information.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">this</span></code> must be dynamic_cast-able to MySystem.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">update</span></code> must not be null.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafSystem.DeclareInitializationDiscreteUpdateEvent(self:</span> <span class="pre">pydrake.systems.framework.LeafSystem,</span> <span class="pre">update:</span> <span class="pre">Callable[[pydrake.systems.framework.Context,</span> <span class="pre">pydrake.systems.framework.DiscreteValues],</span> <span class="pre">Optional[pydrake.systems.framework.EventStatus]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Declares that a DiscreteUpdate event should occur at initialization
and that it should invoke the given event handler method. The handler
should be a class member function (method) with this signature:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">EventStatus</span><span class="w"> </span><span class="nf">MySystem::MyUpdate</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Context</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="p">,</span>
<span class="n">DiscreteValues</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
</details><p>where <code class="docutils literal notranslate"><span class="pre">MySystem</span></code> is a class derived from <code class="docutils literal notranslate"><span class="pre">LeafSystem&lt;T&gt;</span></code> and the
method name is arbitrary.</p>
<p>See declare_initialization_events “Declare initialization events” for
more information.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">this</span></code> must be dynamic_cast-able to MySystem.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">update</span></code> must not be null.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclareInitializationPublishEvent()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclareInitializationUnrestrictedUpdateEvent()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclareInitializationEvent()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafSystem.DeclareInitializationEvent(self:</span> <span class="pre">pydrake.systems.framework.LeafSystem,</span> <span class="pre">event:</span> <span class="pre">pydrake.systems.framework.Event)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>(Advanced) Declares that a particular Event object should be
dispatched at initialization. This is the most general form for
declaring initialization events and most users should use one of the
other methods in this group instead.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclareInitializationPublishEvent()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclareInitializationDiscreteUpdateEvent()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclareInitializationUnrestrictedUpdateEvent()</p>
</div>
<p>See declare_initialization_events “Declare initialization events” for
more information.</p>
<p>Depending on the type of <code class="docutils literal notranslate"><span class="pre">event</span></code>, on initialization it will be
passed to the Publish, DiscreteUpdate, or UnrestrictedUpdate event
dispatcher. If the <code class="docutils literal notranslate"><span class="pre">event</span></code> object contains a handler function,
Drake’s default dispatchers will invoke that handler. If not, then no
further action is taken. Thus an <code class="docutils literal notranslate"><span class="pre">event</span></code> with no handler has no
effect unless its dispatcher has been overridden. We strongly
recommend that you <em>do not</em> override the dispatcher and instead <em>do</em>
supply a handler.</p>
<p>The given <code class="docutils literal notranslate"><span class="pre">event</span></code> object is deep-copied (cloned), and the copy is
stored internally so you do not need to keep the object around after
this call.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><cite>event</cite>’s associated trigger type must be TriggerType::kUnknown or
already set to TriggerType::kInitialization.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafSystem.DeclareInitializationPublishEvent(self:</span> <span class="pre">pydrake.systems.framework.LeafSystem,</span> <span class="pre">publish:</span> <span class="pre">Callable[[pydrake.systems.framework.Context],</span> <span class="pre">Optional[pydrake.systems.framework.EventStatus]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Declares that a Publish event should occur at initialization and that
it should invoke the given event handler method. The handler should be
a class member function (method) with this signature:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">EventStatus</span><span class="w"> </span><span class="nf">MySystem::MyPublish</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Context</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
</details><p>where <code class="docutils literal notranslate"><span class="pre">MySystem</span></code> is a class derived from <code class="docutils literal notranslate"><span class="pre">LeafSystem&lt;T&gt;</span></code> and the
method name is arbitrary.</p>
<p>See declare_initialization_events “Declare initialization events” for
more information.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">this</span></code> must be dynamic_cast-able to MySystem.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">publish</span></code> must not be null.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclareInitializationDiscreteUpdateEvent()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclareInitializationUnrestrictedUpdateEvent()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclareInitializationEvent()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafSystem.DeclareInitializationUnrestrictedUpdateEvent(self:</span> <span class="pre">pydrake.systems.framework.LeafSystem,</span> <span class="pre">update:</span> <span class="pre">Callable[[pydrake.systems.framework.Context,</span> <span class="pre">pydrake.systems.framework.State],</span> <span class="pre">Optional[pydrake.systems.framework.EventStatus]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Declares that an UnrestrictedUpdate event should occur at
initialization and that it should invoke the given event handler
method. The handler should be a class member function (method) with
this signature:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">EventStatus</span><span class="w"> </span><span class="nf">MySystem::MyUpdate</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Context</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="p">,</span>
<span class="n">State</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
</details><p>where <code class="docutils literal notranslate"><span class="pre">MySystem</span></code> is a class derived from <code class="docutils literal notranslate"><span class="pre">LeafSystem&lt;T&gt;</span></code> and the
method name is arbitrary.</p>
<p>See declare_initialization_events “Declare initialization events” for
more information.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">this</span></code> must be dynamic_cast-able to MySystem.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">update</span></code> must not be null.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclareInitializationPublishEvent()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclareInitializationDiscreteUpdateEvent()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclareInitializationEvent()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafSystem.DeclareNumericParameter(self:</span> <span class="pre">pydrake.systems.framework.LeafSystem,</span> <span class="pre">model_vector:</span> <span class="pre">pydrake.systems.framework.BasicVector)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Declares a numeric parameter using the given <code class="docutils literal notranslate"><span class="pre">model_vector</span></code>.
LeafSystem’s default implementation of SetDefaultParameters() will
reset parameters to their model vectors. If the <code class="docutils literal notranslate"><span class="pre">model_vector</span></code>
declares any VectorBase::GetElementBounds() constraints, they will be
re-declared as inequality constraints on this system (see
DeclareInequalityConstraint()). Returns the index of the new
parameter.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafSystem.DeclarePeriodicDiscreteUpdateEvent(self:</span> <span class="pre">pydrake.systems.framework.LeafSystem,</span> <span class="pre">period_sec:</span> <span class="pre">float,</span> <span class="pre">offset_sec:</span> <span class="pre">float,</span> <span class="pre">update:</span> <span class="pre">Callable[[pydrake.systems.framework.Context,</span> <span class="pre">pydrake.systems.framework.DiscreteValues],</span> <span class="pre">Optional[pydrake.systems.framework.EventStatus]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Declares that a DiscreteUpdate event should occur periodically and
that it should invoke the given event handler method. The handler
should be a class member function (method) with this signature:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">EventStatus</span><span class="w"> </span><span class="nf">MySystem::MyUpdate</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Context</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="p">,</span>
<span class="n">DiscreteValues</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
</details><p>where <code class="docutils literal notranslate"><span class="pre">MySystem</span></code> is a class derived from <code class="docutils literal notranslate"><span class="pre">LeafSystem&lt;T&gt;</span></code> and the
method name is arbitrary.</p>
<p>See declare_periodic_events “Declare periodic events” for more
information.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">this</span></code> must be dynamic_cast-able to MySystem.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">update</span></code> must not be null.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclarePeriodicPublishEvent()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclarePeriodicUnrestrictedUpdateEvent()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclarePeriodicEvent()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafSystem.DeclarePeriodicEvent(self:</span> <span class="pre">pydrake.systems.framework.LeafSystem,</span> <span class="pre">period_sec:</span> <span class="pre">float,</span> <span class="pre">offset_sec:</span> <span class="pre">float,</span> <span class="pre">event:</span> <span class="pre">pydrake.systems.framework.Event)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>(Advanced) Declares that a particular Event object should be
dispatched periodically. This is the most general form for declaring
periodic events and most users should use one of the other methods in
this group instead.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclarePeriodicPublishEvent()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclarePeriodicDiscreteUpdateEvent()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclarePeriodicUnrestrictedUpdateEvent()</p>
</div>
<p>See declare_periodic_events “Declare periodic events” for more
information.</p>
<p>Depending on the type of <code class="docutils literal notranslate"><span class="pre">event</span></code>, when triggered it will be passed
to the Publish, DiscreteUpdate, or UnrestrictedUpdate event
dispatcher. If the <code class="docutils literal notranslate"><span class="pre">event</span></code> object contains a handler function,
Drake’s default dispatchers will invoke that handler. If not, then no
further action is taken. Thus an <code class="docutils literal notranslate"><span class="pre">event</span></code> with no handler has no
effect unless its dispatcher has been overridden. We strongly
recommend that you <em>do not</em> override the dispatcher and instead <em>do</em>
supply a handler.</p>
<p>The given <code class="docutils literal notranslate"><span class="pre">event</span></code> object is deep-copied (cloned), and the copy is
stored internally so you do not need to keep the object around after
this call.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><cite>event</cite>’s associated trigger type must be TriggerType::kUnknown or
already set to TriggerType::kPeriodic.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafSystem.DeclarePeriodicPublishEvent(self:</span> <span class="pre">pydrake.systems.framework.LeafSystem,</span> <span class="pre">period_sec:</span> <span class="pre">float,</span> <span class="pre">offset_sec:</span> <span class="pre">float,</span> <span class="pre">publish:</span> <span class="pre">Callable[[pydrake.systems.framework.Context],</span> <span class="pre">Optional[pydrake.systems.framework.EventStatus]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Declares that a Publish event should occur periodically and that it
should invoke the given event handler method. The handler should be a
class member function (method) with this signature:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">EventStatus</span><span class="w"> </span><span class="nf">MySystem::MyPublish</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Context</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
</details><p>where <code class="docutils literal notranslate"><span class="pre">MySystem</span></code> is a class derived from <code class="docutils literal notranslate"><span class="pre">LeafSystem&lt;T&gt;</span></code> and the
method name is arbitrary.</p>
<p>See declare_periodic_events “Declare periodic events” for more
information.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">this</span></code> must be dynamic_cast-able to MySystem.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">publish</span></code> must not be null.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclarePeriodicDiscreteUpdateEvent()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclarePeriodicUnrestrictedUpdateEvent()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclarePeriodicEvent()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafSystem.DeclarePeriodicUnrestrictedUpdateEvent(self:</span> <span class="pre">pydrake.systems.framework.LeafSystem,</span> <span class="pre">period_sec:</span> <span class="pre">float,</span> <span class="pre">offset_sec:</span> <span class="pre">float,</span> <span class="pre">update:</span> <span class="pre">Callable[[pydrake.systems.framework.Context,</span> <span class="pre">pydrake.systems.framework.State],</span> <span class="pre">Optional[pydrake.systems.framework.EventStatus]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Declares that an UnrestrictedUpdate event should occur periodically
and that it should invoke the given event handler method. The handler
should be a class member function (method) with this signature:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">EventStatus</span><span class="w"> </span><span class="nf">MySystem::MyUpdate</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Context</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="p">,</span><span class="w"> </span><span class="n">State</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
</details><p>where <code class="docutils literal notranslate"><span class="pre">MySystem</span></code> is a class derived from <code class="docutils literal notranslate"><span class="pre">LeafSystem&lt;T&gt;</span></code> and the
method name is arbitrary.</p>
<p>See declare_periodic_events “Declare periodic events” for more
information.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">this</span></code> must be dynamic_cast-able to MySystem.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">update</span></code> must not be null.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclarePeriodicPublishEvent()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclarePeriodicDiscreteUpdateEvent()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclarePeriodicEvent()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafSystem.DeclarePerStepDiscreteUpdateEvent(self:</span> <span class="pre">pydrake.systems.framework.LeafSystem,</span> <span class="pre">update:</span> <span class="pre">Callable[[pydrake.systems.framework.Context,</span> <span class="pre">pydrake.systems.framework.DiscreteValues],</span> <span class="pre">Optional[pydrake.systems.framework.EventStatus]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Declares that a DiscreteUpdate event should occur at the start of
every trajectory-advancing step and that it should invoke the given
event handler method. The handler should be a class member function
(method) with this signature:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">EventStatus</span><span class="w"> </span><span class="nf">MySystem::MyUpdate</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Context</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="p">,</span>
<span class="n">DiscreteValues</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
</details><p>where <code class="docutils literal notranslate"><span class="pre">MySystem</span></code> is a class derived from <code class="docutils literal notranslate"><span class="pre">LeafSystem&lt;T&gt;</span></code> and the
method name is arbitrary.</p>
<p>See declare_per-step_events “Declare per-step events” for more
information.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">this</span></code> must be dynamic_cast-able to MySystem.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">update</span></code> must not be null.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclarePerStepPublishEvent()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclarePerStepUnrestrictedUpdateEvent()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclarePerStepEvent()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafSystem.DeclarePerStepEvent(self:</span> <span class="pre">pydrake.systems.framework.LeafSystem,</span> <span class="pre">event:</span> <span class="pre">pydrake.systems.framework.Event)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>(Advanced) Declares that a particular Event object should be
dispatched at every trajectory-advancing step. Publish events are
dispatched at the end of initialization and at the end of each step.
Discrete- and unrestricted update events are dispatched at the start
of each step. This is the most general form for declaring per-step
events and most users should use one of the other methods in this
group instead.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclarePerStepPublishEvent()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclarePerStepDiscreteUpdateEvent()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclarePerStepUnrestrictedUpdateEvent()</p>
</div>
<p>See declare_per-step_events “Declare per-step events” for more
information.</p>
<p>Depending on the type of <code class="docutils literal notranslate"><span class="pre">event</span></code>, at each step it will be passed to
the Publish, DiscreteUpdate, or UnrestrictedUpdate event dispatcher.
If the <code class="docutils literal notranslate"><span class="pre">event</span></code> object contains a handler function, Drake’s default
dispatchers will invoke that handler. If not, then no further action
is taken. Thus an <code class="docutils literal notranslate"><span class="pre">event</span></code> with no handler has no effect unless its
dispatcher has been overridden. We strongly recommend that you <em>do
not</em> override the dispatcher and instead <em>do</em> supply a handler.</p>
<p>The given <code class="docutils literal notranslate"><span class="pre">event</span></code> object is deep-copied (cloned), and the copy is
stored internally so you do not need to keep the object around after
this call.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><cite>event</cite>’s associated trigger type must be TriggerType::kUnknown or
already set to TriggerType::kPerStep.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafSystem.DeclarePerStepPublishEvent(self:</span> <span class="pre">pydrake.systems.framework.LeafSystem,</span> <span class="pre">publish:</span> <span class="pre">Callable[[pydrake.systems.framework.Context],</span> <span class="pre">Optional[pydrake.systems.framework.EventStatus]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Declares that a Publish event should occur at initialization and at
the end of every trajectory-advancing step and that it should invoke
the given event handler method. The handler should be a class member
function (method) with this signature:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">EventStatus</span><span class="w"> </span><span class="nf">MySystem::MyPublish</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Context</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
</details><p>where <code class="docutils literal notranslate"><span class="pre">MySystem</span></code> is a class derived from <code class="docutils literal notranslate"><span class="pre">LeafSystem&lt;T&gt;</span></code> and the
method name is arbitrary.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>These per-step publish events are independent of the Simulator’s
optional “publish every time step” and “publish at initialization”
features. Generally if you are declaring per-step publish events
yourself you should turn off those Simulation options.</p>
</div>
<p>See declare_per-step_events “Declare per-step events” for more
information.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">this</span></code> must be dynamic_cast-able to MySystem.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">publish</span></code> must not be null.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclarePerStepDiscreteUpdateEvent()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclarePerStepUnrestrictedUpdateEvent()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclarePerStepEvent()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>Simulator::set_publish_at_initialization()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>Simulator::set_publish_every_time_step()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafSystem.DeclarePerStepUnrestrictedUpdateEvent(self:</span> <span class="pre">pydrake.systems.framework.LeafSystem,</span> <span class="pre">update:</span> <span class="pre">Callable[[pydrake.systems.framework.Context,</span> <span class="pre">pydrake.systems.framework.State],</span> <span class="pre">Optional[pydrake.systems.framework.EventStatus]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Declares that an UnrestrictedUpdate event should occur at the start of
every trajectory-advancing step and that it should invoke the given
event handler method. The handler should be a class member function
(method) with this signature:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">EventStatus</span><span class="w"> </span><span class="nf">MySystem::MyUpdate</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Context</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="p">,</span>
<span class="n">State</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
</details><p>where <code class="docutils literal notranslate"><span class="pre">MySystem</span></code> is a class derived from <code class="docutils literal notranslate"><span class="pre">LeafSystem&lt;T&gt;</span></code> and the
method name is arbitrary.</p>
<p>See declare_per-step_events “Declare per-step events” for more
information.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">this</span></code> must be dynamic_cast-able to MySystem.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">update</span></code> must not be null.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclarePerStepPublishEvent()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclarePerStepDiscreteUpdateEvent()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclarePerStepEvent()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafSystem.DeclareStateOutputPort(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>DeclareStateOutputPort(self: pydrake.systems.framework.LeafSystem, name: Union[str, pydrake.systems.framework.UseDefaultName], state_index: pydrake.systems.framework.ContinuousStateIndex) -&gt; pydrake.systems.framework.LeafOutputPort</p></li>
</ol>
<p>Declares a vector-valued output port whose value is the continuous
state of this system.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">state_index</span></code>:</dt><dd><p>must be ContinuousStateIndex(0) for now, since LeafSystem only
supports a single continuous state group at the moment.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>DeclareStateOutputPort(self: pydrake.systems.framework.LeafSystem, name: Union[str, pydrake.systems.framework.UseDefaultName], state_index: pydrake.systems.framework.DiscreteStateIndex) -&gt; pydrake.systems.framework.LeafOutputPort</p></li>
</ol>
<p>Declares a vector-valued output port whose value is the given discrete
state group of this system.</p>
<ol class="arabic simple" start="3">
<li><p>DeclareStateOutputPort(self: pydrake.systems.framework.LeafSystem, name: Union[str, pydrake.systems.framework.UseDefaultName], state_index: pydrake.systems.framework.AbstractStateIndex) -&gt; pydrake.systems.framework.LeafOutputPort</p></li>
</ol>
<p>Declares an abstract-valued output port whose value is the given
abstract state of this system.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafSystem.DeclareVectorInputPort(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>DeclareVectorInputPort(self: pydrake.systems.framework.LeafSystem, name: str, model_vector: pydrake.systems.framework.BasicVector, random_type: Optional[pydrake.common.RandomDistribution] = None) -&gt; pydrake.systems.framework.InputPort</p></li>
</ol>
<p>Declares a vector-valued input port using the given <code class="docutils literal notranslate"><span class="pre">model_vector</span></code>.
This is the best way to declare LeafSystem input ports that require
subclasses of BasicVector. The port’s size and type will be the same
as model_vector. If the port is intended to model a random noise or
disturbance input, <code class="docutils literal notranslate"><span class="pre">random_type</span></code> can (optionally) be used to label
it as such. If the <code class="docutils literal notranslate"><span class="pre">model_vector</span></code> declares any
VectorBase::GetElementBounds() constraints, they will be re-declared
as inequality constraints on this system (see
DeclareInequalityConstraint()).</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>System::DeclareInputPort() for more information.</p>
</div>
<ol class="arabic simple" start="2">
<li><p>DeclareVectorInputPort(self: pydrake.systems.framework.LeafSystem, name: str, size: int, random_type: Optional[pydrake.common.RandomDistribution] = None) -&gt; pydrake.systems.framework.InputPort</p></li>
</ol>
<p>Declares a vector-valued input port with type BasicVector and size
<code class="docutils literal notranslate"><span class="pre">size</span></code>. If the port is intended to model a random noise or
disturbance input, <code class="docutils literal notranslate"><span class="pre">random_type</span></code> can (optionally) be used to label
it as such.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>System::DeclareInputPort() for more information.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafSystem.DeclareVectorOutputPort(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>DeclareVectorOutputPort(self: pydrake.systems.framework.LeafSystem, name: str, model_value: pydrake.systems.framework.BasicVector, calc: Callable[[pydrake.systems.framework.Context, pydrake.systems.framework.BasicVector], None], prerequisites_of_calc: set[pydrake.systems.framework.DependencyTicket] = {DependencyTicket(15)}) -&gt; pydrake.systems.framework.OutputPort</p></li>
</ol>
<p>(Advanced) Declares a vector-valued output port using the given
<code class="docutils literal notranslate"><span class="pre">model_vector</span></code> and a function for calculating the port’s value at
runtime. The port’s size will be model_vector.size(), and the default
allocator for the port will be model_vector.Clone(). Note that this
takes the calculator function in its most generic form; if you have a
member function available use one of the other signatures.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>LeafOutputPort::CalcVectorCallback</p>
</div>
<ol class="arabic simple" start="2">
<li><p>DeclareVectorOutputPort(self: pydrake.systems.framework.LeafSystem, name: str, size: int, calc: Callable[[pydrake.systems.framework.Context, pydrake.systems.framework.BasicVector], None], prerequisites_of_calc: set[pydrake.systems.framework.DependencyTicket] = {DependencyTicket(15)}) -&gt; pydrake.systems.framework.OutputPort</p></li>
</ol>
<p>(Advanced) Declares a vector-valued output port with type
BasicVector&lt;T&gt; and size <code class="docutils literal notranslate"><span class="pre">size</span></code>, using the drake::dummy_value&lt;T&gt;,
which is NaN when T = double. <code class="docutils literal notranslate"><span class="pre">vector_calc_function</span></code> is a function
for calculating the port’s value at runtime. Note that this takes the
calculator function in its most generic form; if you have a member
function available use one of the other signatures.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>LeafOutputPort::CalcVectorCallback</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafSystem.DoCalcTimeDerivatives(self:</span> <span class="pre">pydrake.systems.framework.LeafSystem,</span> <span class="pre">arg0:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">arg1:</span> <span class="pre">pydrake.systems.framework.ContinuousState)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafSystem.MakeWitnessFunction(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>MakeWitnessFunction(self: pydrake.systems.framework.LeafSystem, description: str, direction_type: pydrake.systems.framework.WitnessFunctionDirection, calc: Callable[[pydrake.systems.framework.Context], Optional[float]]) -&gt; pydrake.systems.framework.WitnessFunction</p></li>
</ol>
<p>Constructs the witness function with the given description (used
primarily for debugging and logging), direction type, and calculator
function; and with no event object.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In order for the witness function to be used, you MUST overload
System::DoGetWitnessFunctions().</p>
</div>
<ol class="arabic simple" start="2">
<li><p>MakeWitnessFunction(self: pydrake.systems.framework.LeafSystem, description: str, direction_type: pydrake.systems.framework.WitnessFunctionDirection, calc: Callable[[pydrake.systems.framework.Context], float], e: pydrake.systems.framework.Event) -&gt; pydrake.systems.framework.WitnessFunction</p></li>
</ol>
<p>Constructs the witness function with the given description (used
primarily for debugging and logging), direction type, and calculator
function, and with an object corresponding to the event that is to be
dispatched when this witness function triggers. Example types of event
objects are publish, discrete variable update, unrestricted update
events. A clone of the event will be owned by the newly constructed
WitnessFunction.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In order for the witness function to be used, you MUST overload
System::DoGetWitnessFunctions().</p>
</div>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafSystem_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">LeafSystem_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">LeafSystem_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">LeafSystem_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafSystem_[AutoDiffXd]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.System_[AutoDiffXd]</span></code></p>
<p>A superclass template that extends System with some convenience
utilities that are not applicable to Diagrams.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafSystem_[AutoDiffXd].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.systems.framework.LeafSystem_[AutoDiffXd]) -&gt; None</p></li>
</ol>
<p>Default constructor that declares no inputs, outputs, state,
parameters, events, nor scalar-type conversion support (AutoDiff,
etc.). To enable AutoDiff support, use the SystemScalarConverter-based
constructor.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.systems.framework.LeafSystem_[AutoDiffXd], converter: pydrake.systems.framework.SystemScalarConverter) -&gt; None</p></li>
</ol>
<p>Constructor that declares no inputs, outputs, state, parameters, or
events, but allows subclasses to declare scalar-type conversion
support (AutoDiff, etc.).</p>
<p>The scalar-type conversion support will use <code class="docutils literal notranslate"><span class="pre">converter</span></code>. To enable
scalar-type conversion support, pass a <code class="docutils literal notranslate"><span class="pre">SystemTypeTag&lt;S&gt;{}</span></code> where
<code class="docutils literal notranslate"><span class="pre">S</span></code> must be the exact class of <code class="docutils literal notranslate"><span class="pre">this</span></code> being constructed.</p>
<p>See system_scalar_conversion for detailed background and examples
related to scalar-type conversion support.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafSystem_[AutoDiffXd].DeclareAbstractInputPort(self:</span> <span class="pre">pydrake.systems.framework.LeafSystem_[AutoDiffXd],</span> <span class="pre">name:</span> <span class="pre">str,</span> <span class="pre">model_value:</span> <span class="pre">pydrake.common.value.AbstractValue)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.InputPort_[AutoDiffXd]</span></span></dt>
<dd><p>Declares an abstract-valued input port using the given
<code class="docutils literal notranslate"><span class="pre">model_value</span></code>. This is the best way to declare LeafSystem abstract
input ports.</p>
<p>Any port connected to this input, and any call to FixValue for this
input, must provide for values whose type matches this
<code class="docutils literal notranslate"><span class="pre">model_value</span></code>.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>System::DeclareInputPort() for more information.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafSystem_[AutoDiffXd].DeclareAbstractOutputPort(self:</span> <span class="pre">pydrake.systems.framework.LeafSystem_[AutoDiffXd],</span> <span class="pre">name:</span> <span class="pre">str,</span> <span class="pre">alloc:</span> <span class="pre">Callable,</span> <span class="pre">calc:</span> <span class="pre">Callable[[object,</span> <span class="pre">object],</span> <span class="pre">None],</span> <span class="pre">prerequisites_of_calc:</span> <span class="pre">set[pydrake.systems.framework.DependencyTicket]</span> <span class="pre">=</span> <span class="pre">{DependencyTicket(15)})</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.OutputPort_[AutoDiffXd]</span></span></dt>
<dd><p>(Advanced) Declares an abstract-valued output port using the given
allocator and calculator functions provided in their most generic
forms. If you have a member function available use one of the other
signatures.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">alloc</span></code>:</dt><dd><p>Callback function that allocates storage for the value. It takes
no arguments and must return an AbstractValue.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">calc</span></code>:</dt><dd><p>Callback function that computes the value. It takes two arguments
(context, value) and does not return anything; instead, it should
mutate the AbstractValue object pointed to by <code class="docutils literal notranslate"><span class="pre">value</span></code> with the
new result.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>LeafOutputPort::AllocCallback, LeafOutputPort::CalcCallback</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafSystem_[AutoDiffXd].DeclareAbstractParameter(self:</span> <span class="pre">pydrake.systems.framework.LeafSystem_[AutoDiffXd],</span> <span class="pre">model_value:</span> <span class="pre">pydrake.common.value.AbstractValue)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Declares an abstract parameter using the given <code class="docutils literal notranslate"><span class="pre">model_value</span></code>.
LeafSystem’s default implementation of SetDefaultParameters() will
reset parameters to their model values. Returns the index of the new
parameter.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafSystem_[AutoDiffXd].DeclareAbstractState(self:</span> <span class="pre">pydrake.systems.framework.LeafSystem_[AutoDiffXd],</span> <span class="pre">model_value:</span> <span class="pre">pydrake.common.value.AbstractValue)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.AbstractStateIndex</span></span></dt>
<dd><p>Declares an abstract state variable and provides a model value for it.
A Context obtained with CreateDefaultContext() will contain this
abstract state variable initially set to a clone of the
<code class="docutils literal notranslate"><span class="pre">model_value</span></code> given here. The actual concrete type is always
preserved.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">model_value</span></code>:</dt><dd><p>The abstract state model value to be cloned as needed.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>index of the declared abstract state variable.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafSystem_[AutoDiffXd].DeclareContinuousState(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>DeclareContinuousState(self: pydrake.systems.framework.LeafSystem_[AutoDiffXd], num_state_variables: int) -&gt; pydrake.systems.framework.ContinuousStateIndex</p></li>
</ol>
<p>Declares that this System should reserve continuous state with
<code class="docutils literal notranslate"><span class="pre">num_state_variables</span></code> state variables, which have no second-order
structure.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>index of the declared state (currently always zero).</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>DeclareContinuousState(self: pydrake.systems.framework.LeafSystem_[AutoDiffXd], num_q: int, num_v: int, num_z: int) -&gt; pydrake.systems.framework.ContinuousStateIndex</p></li>
</ol>
<p>Declares that this System should reserve continuous state with
<code class="docutils literal notranslate"><span class="pre">num_q</span></code> generalized positions, <code class="docutils literal notranslate"><span class="pre">num_v</span></code> generalized velocities, and
<code class="docutils literal notranslate"><span class="pre">num_z</span></code> miscellaneous state variables.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>index of the declared state (currently always zero).</p>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li><p>DeclareContinuousState(self: pydrake.systems.framework.LeafSystem_[AutoDiffXd], model_vector: pydrake.systems.framework.BasicVector_[AutoDiffXd]) -&gt; pydrake.systems.framework.ContinuousStateIndex</p></li>
</ol>
<p>Declares that this System should reserve continuous state with
<code class="docutils literal notranslate"><span class="pre">model_vector</span></code>.size() miscellaneous state variables, stored in a
vector cloned from <code class="docutils literal notranslate"><span class="pre">model_vector</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>index of the declared state (currently always zero).</p>
</dd>
</dl>
<ol class="arabic simple" start="4">
<li><p>DeclareContinuousState(self: pydrake.systems.framework.LeafSystem_[AutoDiffXd], model_vector: pydrake.systems.framework.BasicVector_[AutoDiffXd], num_q: int, num_v: int, num_z: int) -&gt; pydrake.systems.framework.ContinuousStateIndex</p></li>
</ol>
<p>Declares that this System should reserve continuous state with
<code class="docutils literal notranslate"><span class="pre">num_q</span></code> generalized positions, <code class="docutils literal notranslate"><span class="pre">num_v</span></code> generalized velocities, and
<code class="docutils literal notranslate"><span class="pre">num_z</span></code> miscellaneous state variables, stored in a vector cloned
from <code class="docutils literal notranslate"><span class="pre">model_vector</span></code>. Aborts if <code class="docutils literal notranslate"><span class="pre">model_vector</span></code> has the wrong size.
If the <code class="docutils literal notranslate"><span class="pre">model_vector</span></code> declares any VectorBase::GetElementBounds()
constraints, they will be re-declared as inequality constraints on
this system (see DeclareInequalityConstraint()).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>index of the declared state (currently always zero).</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafSystem_[AutoDiffXd].DeclareDiscreteState(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>DeclareDiscreteState(self: pydrake.systems.framework.LeafSystem_[AutoDiffXd], model_vector: pydrake.systems.framework.BasicVector_[AutoDiffXd]) -&gt; pydrake.systems.framework.DiscreteStateIndex</p></li>
</ol>
<p>Declares a discrete state group with <code class="docutils literal notranslate"><span class="pre">model_vector</span></code>.size() state
variables, stored in a vector cloned from <code class="docutils literal notranslate"><span class="pre">model_vector</span></code> (preserving
the concrete type and value).</p>
<ol class="arabic simple" start="2">
<li><p>DeclareDiscreteState(self: pydrake.systems.framework.LeafSystem_[AutoDiffXd], vector: numpy.ndarray[object[m, 1]]) -&gt; pydrake.systems.framework.DiscreteStateIndex</p></li>
</ol>
<p>Declares a discrete state group with <code class="docutils literal notranslate"><span class="pre">vector</span></code>.size() state
variables, stored in a BasicVector initialized with the contents of
<code class="docutils literal notranslate"><span class="pre">vector</span></code>.</p>
<ol class="arabic simple" start="3">
<li><p>DeclareDiscreteState(self: pydrake.systems.framework.LeafSystem_[AutoDiffXd], num_state_variables: int) -&gt; pydrake.systems.framework.DiscreteStateIndex</p></li>
</ol>
<p>Declares a discrete state group with <code class="docutils literal notranslate"><span class="pre">num_state_variables</span></code> state
variables, stored in a BasicVector initialized to be all-zero. If you
want non-zero initial values, use an alternate DeclareDiscreteState()
signature that accepts a <code class="docutils literal notranslate"><span class="pre">model_vector</span></code> parameter.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">num_state_variables</span></code> must be non-negative.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafSystem_[AutoDiffXd].DeclareForcedDiscreteUpdateEvent(self:</span> <span class="pre">pydrake.systems.framework.LeafSystem_[AutoDiffXd],</span> <span class="pre">update:</span> <span class="pre">Callable[[pydrake.systems.framework.Context_[AutoDiffXd],</span> <span class="pre">pydrake.systems.framework.DiscreteValues_[AutoDiffXd]],</span> <span class="pre">Optional[pydrake.systems.framework.EventStatus]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Declares a function that is called whenever a user directly calls
CalcForcedDiscreteVariableUpdate(const Context&amp;, DiscreteValues&lt;T&gt;*).
Multiple calls to DeclareForcedDiscreteUpdateEvent() will cause
multiple handlers to be called upon a call to
CalcForcedDiscreteVariableUpdate(); these handlers will be called with
the same const Context in arbitrary order. The handler should be a
class member function (method) with this signature:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">EventStatus</span><span class="w"> </span><span class="nf">MySystem::MyDiscreteVariableUpdates</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Context</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="p">,</span>
<span class="n">DiscreteValues</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span><span class="p">);</span>
</pre></div>
</div>
</details><p>where <code class="docutils literal notranslate"><span class="pre">MySystem</span></code> is a class derived from <code class="docutils literal notranslate"><span class="pre">LeafSystem&lt;T&gt;</span></code> and the
method name is arbitrary.</p>
<p>See declare_forced_events “Declare forced events” for more
information.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">this</span></code> must be dynamic_cast-able to MySystem.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">update</span></code> must not be null.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafSystem_[AutoDiffXd].DeclareForcedPublishEvent(self:</span> <span class="pre">pydrake.systems.framework.LeafSystem_[AutoDiffXd],</span> <span class="pre">publish:</span> <span class="pre">Callable[[pydrake.systems.framework.Context_[AutoDiffXd]],</span> <span class="pre">Optional[pydrake.systems.framework.EventStatus]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Declares a function that is called whenever a user directly calls
ForcedPublish(const Context&amp;). Multiple calls to
DeclareForcedPublishEvent() will cause multiple handlers to be called
upon a call to ForcedPublish(); these handlers which will be called
with the same const Context in arbitrary order. The handler should be
a class member function (method) with this signature:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">EventStatus</span><span class="w"> </span><span class="nf">MySystem::MyPublish</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Context</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
</details><p>where <code class="docutils literal notranslate"><span class="pre">MySystem</span></code> is a class derived from <code class="docutils literal notranslate"><span class="pre">LeafSystem&lt;T&gt;</span></code> and the
method name is arbitrary.</p>
<p>See declare_forced_events “Declare forced events” for more
information.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">this</span></code> must be dynamic_cast-able to MySystem.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">publish</span></code> must not be null.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafSystem_[AutoDiffXd].DeclareForcedUnrestrictedUpdateEvent(self:</span> <span class="pre">pydrake.systems.framework.LeafSystem_[AutoDiffXd],</span> <span class="pre">update:</span> <span class="pre">Callable[[pydrake.systems.framework.Context_[AutoDiffXd],</span> <span class="pre">pydrake.systems.framework.State_[AutoDiffXd]],</span> <span class="pre">Optional[pydrake.systems.framework.EventStatus]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Declares a function that is called whenever a user directly calls
CalcForcedUnrestrictedUpdate(const Context&amp;, State&lt;T&gt;*). Multiple
calls to DeclareForcedUnrestrictedUpdateEvent() will cause multiple
handlers to be called upon a call to CalcForcedUnrestrictedUpdate();
these handlers which will be called with the same const Context in
arbitrary order.The handler should be a class member function (method)
with this signature:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">EventStatus</span><span class="w"> </span><span class="nf">MySystem::MyUnrestrictedUpdates</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Context</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="p">,</span>
<span class="n">State</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span><span class="p">);</span>
</pre></div>
</div>
</details><p>where <code class="docutils literal notranslate"><span class="pre">MySystem</span></code> is a class derived from <code class="docutils literal notranslate"><span class="pre">LeafSystem&lt;T&gt;</span></code> and the
method name is arbitrary.</p>
<p>See declare_forced_events “Declare forced events” for more
information.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">this</span></code> must be dynamic_cast-able to MySystem.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">update</span></code> must not be null.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafSystem_[AutoDiffXd].DeclareInitializationDiscreteUpdateEvent(self:</span> <span class="pre">pydrake.systems.framework.LeafSystem_[AutoDiffXd],</span> <span class="pre">update:</span> <span class="pre">Callable[[pydrake.systems.framework.Context_[AutoDiffXd],</span> <span class="pre">pydrake.systems.framework.DiscreteValues_[AutoDiffXd]],</span> <span class="pre">Optional[pydrake.systems.framework.EventStatus]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Declares that a DiscreteUpdate event should occur at initialization
and that it should invoke the given event handler method. The handler
should be a class member function (method) with this signature:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">EventStatus</span><span class="w"> </span><span class="nf">MySystem::MyUpdate</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Context</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="p">,</span>
<span class="n">DiscreteValues</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
</details><p>where <code class="docutils literal notranslate"><span class="pre">MySystem</span></code> is a class derived from <code class="docutils literal notranslate"><span class="pre">LeafSystem&lt;T&gt;</span></code> and the
method name is arbitrary.</p>
<p>See declare_initialization_events “Declare initialization events” for
more information.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">this</span></code> must be dynamic_cast-able to MySystem.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">update</span></code> must not be null.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclareInitializationPublishEvent()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclareInitializationUnrestrictedUpdateEvent()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclareInitializationEvent()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafSystem_[AutoDiffXd].DeclareInitializationEvent(self:</span> <span class="pre">pydrake.systems.framework.LeafSystem_[AutoDiffXd],</span> <span class="pre">event:</span> <span class="pre">pydrake.systems.framework.Event_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>(Advanced) Declares that a particular Event object should be
dispatched at initialization. This is the most general form for
declaring initialization events and most users should use one of the
other methods in this group instead.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclareInitializationPublishEvent()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclareInitializationDiscreteUpdateEvent()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclareInitializationUnrestrictedUpdateEvent()</p>
</div>
<p>See declare_initialization_events “Declare initialization events” for
more information.</p>
<p>Depending on the type of <code class="docutils literal notranslate"><span class="pre">event</span></code>, on initialization it will be
passed to the Publish, DiscreteUpdate, or UnrestrictedUpdate event
dispatcher. If the <code class="docutils literal notranslate"><span class="pre">event</span></code> object contains a handler function,
Drake’s default dispatchers will invoke that handler. If not, then no
further action is taken. Thus an <code class="docutils literal notranslate"><span class="pre">event</span></code> with no handler has no
effect unless its dispatcher has been overridden. We strongly
recommend that you <em>do not</em> override the dispatcher and instead <em>do</em>
supply a handler.</p>
<p>The given <code class="docutils literal notranslate"><span class="pre">event</span></code> object is deep-copied (cloned), and the copy is
stored internally so you do not need to keep the object around after
this call.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><cite>event</cite>’s associated trigger type must be TriggerType::kUnknown or
already set to TriggerType::kInitialization.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafSystem_[AutoDiffXd].DeclareInitializationPublishEvent(self:</span> <span class="pre">pydrake.systems.framework.LeafSystem_[AutoDiffXd],</span> <span class="pre">publish:</span> <span class="pre">Callable[[pydrake.systems.framework.Context_[AutoDiffXd]],</span> <span class="pre">Optional[pydrake.systems.framework.EventStatus]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Declares that a Publish event should occur at initialization and that
it should invoke the given event handler method. The handler should be
a class member function (method) with this signature:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">EventStatus</span><span class="w"> </span><span class="nf">MySystem::MyPublish</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Context</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
</details><p>where <code class="docutils literal notranslate"><span class="pre">MySystem</span></code> is a class derived from <code class="docutils literal notranslate"><span class="pre">LeafSystem&lt;T&gt;</span></code> and the
method name is arbitrary.</p>
<p>See declare_initialization_events “Declare initialization events” for
more information.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">this</span></code> must be dynamic_cast-able to MySystem.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">publish</span></code> must not be null.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclareInitializationDiscreteUpdateEvent()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclareInitializationUnrestrictedUpdateEvent()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclareInitializationEvent()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafSystem_[AutoDiffXd].DeclareInitializationUnrestrictedUpdateEvent(self:</span> <span class="pre">pydrake.systems.framework.LeafSystem_[AutoDiffXd],</span> <span class="pre">update:</span> <span class="pre">Callable[[pydrake.systems.framework.Context_[AutoDiffXd],</span> <span class="pre">pydrake.systems.framework.State_[AutoDiffXd]],</span> <span class="pre">Optional[pydrake.systems.framework.EventStatus]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Declares that an UnrestrictedUpdate event should occur at
initialization and that it should invoke the given event handler
method. The handler should be a class member function (method) with
this signature:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">EventStatus</span><span class="w"> </span><span class="nf">MySystem::MyUpdate</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Context</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="p">,</span>
<span class="n">State</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
</details><p>where <code class="docutils literal notranslate"><span class="pre">MySystem</span></code> is a class derived from <code class="docutils literal notranslate"><span class="pre">LeafSystem&lt;T&gt;</span></code> and the
method name is arbitrary.</p>
<p>See declare_initialization_events “Declare initialization events” for
more information.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">this</span></code> must be dynamic_cast-able to MySystem.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">update</span></code> must not be null.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclareInitializationPublishEvent()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclareInitializationDiscreteUpdateEvent()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclareInitializationEvent()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafSystem_[AutoDiffXd].DeclareNumericParameter(self:</span> <span class="pre">pydrake.systems.framework.LeafSystem_[AutoDiffXd],</span> <span class="pre">model_vector:</span> <span class="pre">pydrake.systems.framework.BasicVector_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Declares a numeric parameter using the given <code class="docutils literal notranslate"><span class="pre">model_vector</span></code>.
LeafSystem’s default implementation of SetDefaultParameters() will
reset parameters to their model vectors. If the <code class="docutils literal notranslate"><span class="pre">model_vector</span></code>
declares any VectorBase::GetElementBounds() constraints, they will be
re-declared as inequality constraints on this system (see
DeclareInequalityConstraint()). Returns the index of the new
parameter.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafSystem_[AutoDiffXd].DeclarePeriodicDiscreteUpdateEvent(self:</span> <span class="pre">pydrake.systems.framework.LeafSystem_[AutoDiffXd],</span> <span class="pre">period_sec:</span> <span class="pre">float,</span> <span class="pre">offset_sec:</span> <span class="pre">float,</span> <span class="pre">update:</span> <span class="pre">Callable[[pydrake.systems.framework.Context_[AutoDiffXd],</span> <span class="pre">pydrake.systems.framework.DiscreteValues_[AutoDiffXd]],</span> <span class="pre">Optional[pydrake.systems.framework.EventStatus]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Declares that a DiscreteUpdate event should occur periodically and
that it should invoke the given event handler method. The handler
should be a class member function (method) with this signature:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">EventStatus</span><span class="w"> </span><span class="nf">MySystem::MyUpdate</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Context</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="p">,</span>
<span class="n">DiscreteValues</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
</details><p>where <code class="docutils literal notranslate"><span class="pre">MySystem</span></code> is a class derived from <code class="docutils literal notranslate"><span class="pre">LeafSystem&lt;T&gt;</span></code> and the
method name is arbitrary.</p>
<p>See declare_periodic_events “Declare periodic events” for more
information.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">this</span></code> must be dynamic_cast-able to MySystem.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">update</span></code> must not be null.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclarePeriodicPublishEvent()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclarePeriodicUnrestrictedUpdateEvent()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclarePeriodicEvent()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafSystem_[AutoDiffXd].DeclarePeriodicEvent(self:</span> <span class="pre">pydrake.systems.framework.LeafSystem_[AutoDiffXd],</span> <span class="pre">period_sec:</span> <span class="pre">float,</span> <span class="pre">offset_sec:</span> <span class="pre">float,</span> <span class="pre">event:</span> <span class="pre">pydrake.systems.framework.Event_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>(Advanced) Declares that a particular Event object should be
dispatched periodically. This is the most general form for declaring
periodic events and most users should use one of the other methods in
this group instead.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclarePeriodicPublishEvent()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclarePeriodicDiscreteUpdateEvent()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclarePeriodicUnrestrictedUpdateEvent()</p>
</div>
<p>See declare_periodic_events “Declare periodic events” for more
information.</p>
<p>Depending on the type of <code class="docutils literal notranslate"><span class="pre">event</span></code>, when triggered it will be passed
to the Publish, DiscreteUpdate, or UnrestrictedUpdate event
dispatcher. If the <code class="docutils literal notranslate"><span class="pre">event</span></code> object contains a handler function,
Drake’s default dispatchers will invoke that handler. If not, then no
further action is taken. Thus an <code class="docutils literal notranslate"><span class="pre">event</span></code> with no handler has no
effect unless its dispatcher has been overridden. We strongly
recommend that you <em>do not</em> override the dispatcher and instead <em>do</em>
supply a handler.</p>
<p>The given <code class="docutils literal notranslate"><span class="pre">event</span></code> object is deep-copied (cloned), and the copy is
stored internally so you do not need to keep the object around after
this call.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><cite>event</cite>’s associated trigger type must be TriggerType::kUnknown or
already set to TriggerType::kPeriodic.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafSystem_[AutoDiffXd].DeclarePeriodicPublishEvent(self:</span> <span class="pre">pydrake.systems.framework.LeafSystem_[AutoDiffXd],</span> <span class="pre">period_sec:</span> <span class="pre">float,</span> <span class="pre">offset_sec:</span> <span class="pre">float,</span> <span class="pre">publish:</span> <span class="pre">Callable[[pydrake.systems.framework.Context_[AutoDiffXd]],</span> <span class="pre">Optional[pydrake.systems.framework.EventStatus]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Declares that a Publish event should occur periodically and that it
should invoke the given event handler method. The handler should be a
class member function (method) with this signature:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">EventStatus</span><span class="w"> </span><span class="nf">MySystem::MyPublish</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Context</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
</details><p>where <code class="docutils literal notranslate"><span class="pre">MySystem</span></code> is a class derived from <code class="docutils literal notranslate"><span class="pre">LeafSystem&lt;T&gt;</span></code> and the
method name is arbitrary.</p>
<p>See declare_periodic_events “Declare periodic events” for more
information.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">this</span></code> must be dynamic_cast-able to MySystem.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">publish</span></code> must not be null.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclarePeriodicDiscreteUpdateEvent()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclarePeriodicUnrestrictedUpdateEvent()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclarePeriodicEvent()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafSystem_[AutoDiffXd].DeclarePeriodicUnrestrictedUpdateEvent(self:</span> <span class="pre">pydrake.systems.framework.LeafSystem_[AutoDiffXd],</span> <span class="pre">period_sec:</span> <span class="pre">float,</span> <span class="pre">offset_sec:</span> <span class="pre">float,</span> <span class="pre">update:</span> <span class="pre">Callable[[pydrake.systems.framework.Context_[AutoDiffXd],</span> <span class="pre">pydrake.systems.framework.State_[AutoDiffXd]],</span> <span class="pre">Optional[pydrake.systems.framework.EventStatus]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Declares that an UnrestrictedUpdate event should occur periodically
and that it should invoke the given event handler method. The handler
should be a class member function (method) with this signature:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">EventStatus</span><span class="w"> </span><span class="nf">MySystem::MyUpdate</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Context</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="p">,</span><span class="w"> </span><span class="n">State</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
</details><p>where <code class="docutils literal notranslate"><span class="pre">MySystem</span></code> is a class derived from <code class="docutils literal notranslate"><span class="pre">LeafSystem&lt;T&gt;</span></code> and the
method name is arbitrary.</p>
<p>See declare_periodic_events “Declare periodic events” for more
information.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">this</span></code> must be dynamic_cast-able to MySystem.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">update</span></code> must not be null.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclarePeriodicPublishEvent()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclarePeriodicDiscreteUpdateEvent()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclarePeriodicEvent()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafSystem_[AutoDiffXd].DeclarePerStepDiscreteUpdateEvent(self:</span> <span class="pre">pydrake.systems.framework.LeafSystem_[AutoDiffXd],</span> <span class="pre">update:</span> <span class="pre">Callable[[pydrake.systems.framework.Context_[AutoDiffXd],</span> <span class="pre">pydrake.systems.framework.DiscreteValues_[AutoDiffXd]],</span> <span class="pre">Optional[pydrake.systems.framework.EventStatus]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Declares that a DiscreteUpdate event should occur at the start of
every trajectory-advancing step and that it should invoke the given
event handler method. The handler should be a class member function
(method) with this signature:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">EventStatus</span><span class="w"> </span><span class="nf">MySystem::MyUpdate</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Context</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="p">,</span>
<span class="n">DiscreteValues</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
</details><p>where <code class="docutils literal notranslate"><span class="pre">MySystem</span></code> is a class derived from <code class="docutils literal notranslate"><span class="pre">LeafSystem&lt;T&gt;</span></code> and the
method name is arbitrary.</p>
<p>See declare_per-step_events “Declare per-step events” for more
information.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">this</span></code> must be dynamic_cast-able to MySystem.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">update</span></code> must not be null.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclarePerStepPublishEvent()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclarePerStepUnrestrictedUpdateEvent()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclarePerStepEvent()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafSystem_[AutoDiffXd].DeclarePerStepEvent(self:</span> <span class="pre">pydrake.systems.framework.LeafSystem_[AutoDiffXd],</span> <span class="pre">event:</span> <span class="pre">pydrake.systems.framework.Event_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>(Advanced) Declares that a particular Event object should be
dispatched at every trajectory-advancing step. Publish events are
dispatched at the end of initialization and at the end of each step.
Discrete- and unrestricted update events are dispatched at the start
of each step. This is the most general form for declaring per-step
events and most users should use one of the other methods in this
group instead.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclarePerStepPublishEvent()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclarePerStepDiscreteUpdateEvent()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclarePerStepUnrestrictedUpdateEvent()</p>
</div>
<p>See declare_per-step_events “Declare per-step events” for more
information.</p>
<p>Depending on the type of <code class="docutils literal notranslate"><span class="pre">event</span></code>, at each step it will be passed to
the Publish, DiscreteUpdate, or UnrestrictedUpdate event dispatcher.
If the <code class="docutils literal notranslate"><span class="pre">event</span></code> object contains a handler function, Drake’s default
dispatchers will invoke that handler. If not, then no further action
is taken. Thus an <code class="docutils literal notranslate"><span class="pre">event</span></code> with no handler has no effect unless its
dispatcher has been overridden. We strongly recommend that you <em>do
not</em> override the dispatcher and instead <em>do</em> supply a handler.</p>
<p>The given <code class="docutils literal notranslate"><span class="pre">event</span></code> object is deep-copied (cloned), and the copy is
stored internally so you do not need to keep the object around after
this call.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><cite>event</cite>’s associated trigger type must be TriggerType::kUnknown or
already set to TriggerType::kPerStep.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafSystem_[AutoDiffXd].DeclarePerStepPublishEvent(self:</span> <span class="pre">pydrake.systems.framework.LeafSystem_[AutoDiffXd],</span> <span class="pre">publish:</span> <span class="pre">Callable[[pydrake.systems.framework.Context_[AutoDiffXd]],</span> <span class="pre">Optional[pydrake.systems.framework.EventStatus]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Declares that a Publish event should occur at initialization and at
the end of every trajectory-advancing step and that it should invoke
the given event handler method. The handler should be a class member
function (method) with this signature:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">EventStatus</span><span class="w"> </span><span class="nf">MySystem::MyPublish</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Context</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
</details><p>where <code class="docutils literal notranslate"><span class="pre">MySystem</span></code> is a class derived from <code class="docutils literal notranslate"><span class="pre">LeafSystem&lt;T&gt;</span></code> and the
method name is arbitrary.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>These per-step publish events are independent of the Simulator’s
optional “publish every time step” and “publish at initialization”
features. Generally if you are declaring per-step publish events
yourself you should turn off those Simulation options.</p>
</div>
<p>See declare_per-step_events “Declare per-step events” for more
information.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">this</span></code> must be dynamic_cast-able to MySystem.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">publish</span></code> must not be null.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclarePerStepDiscreteUpdateEvent()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclarePerStepUnrestrictedUpdateEvent()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclarePerStepEvent()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>Simulator::set_publish_at_initialization()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>Simulator::set_publish_every_time_step()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafSystem_[AutoDiffXd].DeclarePerStepUnrestrictedUpdateEvent(self:</span> <span class="pre">pydrake.systems.framework.LeafSystem_[AutoDiffXd],</span> <span class="pre">update:</span> <span class="pre">Callable[[pydrake.systems.framework.Context_[AutoDiffXd],</span> <span class="pre">pydrake.systems.framework.State_[AutoDiffXd]],</span> <span class="pre">Optional[pydrake.systems.framework.EventStatus]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Declares that an UnrestrictedUpdate event should occur at the start of
every trajectory-advancing step and that it should invoke the given
event handler method. The handler should be a class member function
(method) with this signature:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">EventStatus</span><span class="w"> </span><span class="nf">MySystem::MyUpdate</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Context</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="p">,</span>
<span class="n">State</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
</details><p>where <code class="docutils literal notranslate"><span class="pre">MySystem</span></code> is a class derived from <code class="docutils literal notranslate"><span class="pre">LeafSystem&lt;T&gt;</span></code> and the
method name is arbitrary.</p>
<p>See declare_per-step_events “Declare per-step events” for more
information.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">this</span></code> must be dynamic_cast-able to MySystem.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">update</span></code> must not be null.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclarePerStepPublishEvent()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclarePerStepDiscreteUpdateEvent()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclarePerStepEvent()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafSystem_[AutoDiffXd].DeclareStateOutputPort(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>DeclareStateOutputPort(self: pydrake.systems.framework.LeafSystem_[AutoDiffXd], name: Union[str, pydrake.systems.framework.UseDefaultName], state_index: pydrake.systems.framework.ContinuousStateIndex) -&gt; pydrake.systems.framework.LeafOutputPort_[AutoDiffXd]</p></li>
</ol>
<p>Declares a vector-valued output port whose value is the continuous
state of this system.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">state_index</span></code>:</dt><dd><p>must be ContinuousStateIndex(0) for now, since LeafSystem only
supports a single continuous state group at the moment.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>DeclareStateOutputPort(self: pydrake.systems.framework.LeafSystem_[AutoDiffXd], name: Union[str, pydrake.systems.framework.UseDefaultName], state_index: pydrake.systems.framework.DiscreteStateIndex) -&gt; pydrake.systems.framework.LeafOutputPort_[AutoDiffXd]</p></li>
</ol>
<p>Declares a vector-valued output port whose value is the given discrete
state group of this system.</p>
<ol class="arabic simple" start="3">
<li><p>DeclareStateOutputPort(self: pydrake.systems.framework.LeafSystem_[AutoDiffXd], name: Union[str, pydrake.systems.framework.UseDefaultName], state_index: pydrake.systems.framework.AbstractStateIndex) -&gt; pydrake.systems.framework.LeafOutputPort_[AutoDiffXd]</p></li>
</ol>
<p>Declares an abstract-valued output port whose value is the given
abstract state of this system.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafSystem_[AutoDiffXd].DeclareVectorInputPort(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>DeclareVectorInputPort(self: pydrake.systems.framework.LeafSystem_[AutoDiffXd], name: str, model_vector: pydrake.systems.framework.BasicVector_[AutoDiffXd], random_type: Optional[pydrake.common.RandomDistribution] = None) -&gt; pydrake.systems.framework.InputPort_[AutoDiffXd]</p></li>
</ol>
<p>Declares a vector-valued input port using the given <code class="docutils literal notranslate"><span class="pre">model_vector</span></code>.
This is the best way to declare LeafSystem input ports that require
subclasses of BasicVector. The port’s size and type will be the same
as model_vector. If the port is intended to model a random noise or
disturbance input, <code class="docutils literal notranslate"><span class="pre">random_type</span></code> can (optionally) be used to label
it as such. If the <code class="docutils literal notranslate"><span class="pre">model_vector</span></code> declares any
VectorBase::GetElementBounds() constraints, they will be re-declared
as inequality constraints on this system (see
DeclareInequalityConstraint()).</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>System::DeclareInputPort() for more information.</p>
</div>
<ol class="arabic simple" start="2">
<li><p>DeclareVectorInputPort(self: pydrake.systems.framework.LeafSystem_[AutoDiffXd], name: str, size: int, random_type: Optional[pydrake.common.RandomDistribution] = None) -&gt; pydrake.systems.framework.InputPort_[AutoDiffXd]</p></li>
</ol>
<p>Declares a vector-valued input port with type BasicVector and size
<code class="docutils literal notranslate"><span class="pre">size</span></code>. If the port is intended to model a random noise or
disturbance input, <code class="docutils literal notranslate"><span class="pre">random_type</span></code> can (optionally) be used to label
it as such.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>System::DeclareInputPort() for more information.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafSystem_[AutoDiffXd].DeclareVectorOutputPort(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>DeclareVectorOutputPort(self: pydrake.systems.framework.LeafSystem_[AutoDiffXd], name: str, model_value: pydrake.systems.framework.BasicVector_[AutoDiffXd], calc: Callable[[pydrake.systems.framework.Context_[AutoDiffXd], pydrake.systems.framework.BasicVector_[AutoDiffXd]], None], prerequisites_of_calc: set[pydrake.systems.framework.DependencyTicket] = {DependencyTicket(15)}) -&gt; pydrake.systems.framework.OutputPort_[AutoDiffXd]</p></li>
</ol>
<p>(Advanced) Declares a vector-valued output port using the given
<code class="docutils literal notranslate"><span class="pre">model_vector</span></code> and a function for calculating the port’s value at
runtime. The port’s size will be model_vector.size(), and the default
allocator for the port will be model_vector.Clone(). Note that this
takes the calculator function in its most generic form; if you have a
member function available use one of the other signatures.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>LeafOutputPort::CalcVectorCallback</p>
</div>
<ol class="arabic simple" start="2">
<li><p>DeclareVectorOutputPort(self: pydrake.systems.framework.LeafSystem_[AutoDiffXd], name: str, size: int, calc: Callable[[pydrake.systems.framework.Context_[AutoDiffXd], pydrake.systems.framework.BasicVector_[AutoDiffXd]], None], prerequisites_of_calc: set[pydrake.systems.framework.DependencyTicket] = {DependencyTicket(15)}) -&gt; pydrake.systems.framework.OutputPort_[AutoDiffXd]</p></li>
</ol>
<p>(Advanced) Declares a vector-valued output port with type
BasicVector&lt;T&gt; and size <code class="docutils literal notranslate"><span class="pre">size</span></code>, using the drake::dummy_value&lt;T&gt;,
which is NaN when T = double. <code class="docutils literal notranslate"><span class="pre">vector_calc_function</span></code> is a function
for calculating the port’s value at runtime. Note that this takes the
calculator function in its most generic form; if you have a member
function available use one of the other signatures.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>LeafOutputPort::CalcVectorCallback</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafSystem_[AutoDiffXd].DoCalcTimeDerivatives(self:</span> <span class="pre">pydrake.systems.framework.LeafSystem_[AutoDiffXd],</span> <span class="pre">arg0:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd],</span> <span class="pre">arg1:</span> <span class="pre">pydrake.systems.framework.ContinuousState_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafSystem_[AutoDiffXd].MakeWitnessFunction(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>MakeWitnessFunction(self: pydrake.systems.framework.LeafSystem_[AutoDiffXd], description: str, direction_type: pydrake.systems.framework.WitnessFunctionDirection, calc: Callable[[pydrake.systems.framework.Context_[AutoDiffXd]], Optional[pydrake.autodiffutils.AutoDiffXd]]) -&gt; pydrake.systems.framework.WitnessFunction_[AutoDiffXd]</p></li>
</ol>
<p>Constructs the witness function with the given description (used
primarily for debugging and logging), direction type, and calculator
function; and with no event object.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In order for the witness function to be used, you MUST overload
System::DoGetWitnessFunctions().</p>
</div>
<ol class="arabic simple" start="2">
<li><p>MakeWitnessFunction(self: pydrake.systems.framework.LeafSystem_[AutoDiffXd], description: str, direction_type: pydrake.systems.framework.WitnessFunctionDirection, calc: Callable[[pydrake.systems.framework.Context_[AutoDiffXd]], pydrake.autodiffutils.AutoDiffXd], e: pydrake.systems.framework.Event_[AutoDiffXd]) -&gt; pydrake.systems.framework.WitnessFunction_[AutoDiffXd]</p></li>
</ol>
<p>Constructs the witness function with the given description (used
primarily for debugging and logging), direction type, and calculator
function, and with an object corresponding to the event that is to be
dispatched when this witness function triggers. Example types of event
objects are publish, discrete variable update, unrestricted update
events. A clone of the event will be owned by the newly constructed
WitnessFunction.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In order for the witness function to be used, you MUST overload
System::DoGetWitnessFunctions().</p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafSystem_[Expression]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.System_[Expression]</span></code></p>
<p>A superclass template that extends System with some convenience
utilities that are not applicable to Diagrams.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafSystem_[Expression].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.systems.framework.LeafSystem_[Expression]) -&gt; None</p></li>
</ol>
<p>Default constructor that declares no inputs, outputs, state,
parameters, events, nor scalar-type conversion support (AutoDiff,
etc.). To enable AutoDiff support, use the SystemScalarConverter-based
constructor.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.systems.framework.LeafSystem_[Expression], converter: pydrake.systems.framework.SystemScalarConverter) -&gt; None</p></li>
</ol>
<p>Constructor that declares no inputs, outputs, state, parameters, or
events, but allows subclasses to declare scalar-type conversion
support (AutoDiff, etc.).</p>
<p>The scalar-type conversion support will use <code class="docutils literal notranslate"><span class="pre">converter</span></code>. To enable
scalar-type conversion support, pass a <code class="docutils literal notranslate"><span class="pre">SystemTypeTag&lt;S&gt;{}</span></code> where
<code class="docutils literal notranslate"><span class="pre">S</span></code> must be the exact class of <code class="docutils literal notranslate"><span class="pre">this</span></code> being constructed.</p>
<p>See system_scalar_conversion for detailed background and examples
related to scalar-type conversion support.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafSystem_[Expression].DeclareAbstractInputPort(self:</span> <span class="pre">pydrake.systems.framework.LeafSystem_[Expression],</span> <span class="pre">name:</span> <span class="pre">str,</span> <span class="pre">model_value:</span> <span class="pre">pydrake.common.value.AbstractValue)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.InputPort_[Expression]</span></span></dt>
<dd><p>Declares an abstract-valued input port using the given
<code class="docutils literal notranslate"><span class="pre">model_value</span></code>. This is the best way to declare LeafSystem abstract
input ports.</p>
<p>Any port connected to this input, and any call to FixValue for this
input, must provide for values whose type matches this
<code class="docutils literal notranslate"><span class="pre">model_value</span></code>.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>System::DeclareInputPort() for more information.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafSystem_[Expression].DeclareAbstractOutputPort(self:</span> <span class="pre">pydrake.systems.framework.LeafSystem_[Expression],</span> <span class="pre">name:</span> <span class="pre">str,</span> <span class="pre">alloc:</span> <span class="pre">Callable,</span> <span class="pre">calc:</span> <span class="pre">Callable[[object,</span> <span class="pre">object],</span> <span class="pre">None],</span> <span class="pre">prerequisites_of_calc:</span> <span class="pre">set[pydrake.systems.framework.DependencyTicket]</span> <span class="pre">=</span> <span class="pre">{DependencyTicket(15)})</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.OutputPort_[Expression]</span></span></dt>
<dd><p>(Advanced) Declares an abstract-valued output port using the given
allocator and calculator functions provided in their most generic
forms. If you have a member function available use one of the other
signatures.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">alloc</span></code>:</dt><dd><p>Callback function that allocates storage for the value. It takes
no arguments and must return an AbstractValue.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">calc</span></code>:</dt><dd><p>Callback function that computes the value. It takes two arguments
(context, value) and does not return anything; instead, it should
mutate the AbstractValue object pointed to by <code class="docutils literal notranslate"><span class="pre">value</span></code> with the
new result.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>LeafOutputPort::AllocCallback, LeafOutputPort::CalcCallback</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafSystem_[Expression].DeclareAbstractParameter(self:</span> <span class="pre">pydrake.systems.framework.LeafSystem_[Expression],</span> <span class="pre">model_value:</span> <span class="pre">pydrake.common.value.AbstractValue)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Declares an abstract parameter using the given <code class="docutils literal notranslate"><span class="pre">model_value</span></code>.
LeafSystem’s default implementation of SetDefaultParameters() will
reset parameters to their model values. Returns the index of the new
parameter.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafSystem_[Expression].DeclareAbstractState(self:</span> <span class="pre">pydrake.systems.framework.LeafSystem_[Expression],</span> <span class="pre">model_value:</span> <span class="pre">pydrake.common.value.AbstractValue)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.AbstractStateIndex</span></span></dt>
<dd><p>Declares an abstract state variable and provides a model value for it.
A Context obtained with CreateDefaultContext() will contain this
abstract state variable initially set to a clone of the
<code class="docutils literal notranslate"><span class="pre">model_value</span></code> given here. The actual concrete type is always
preserved.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">model_value</span></code>:</dt><dd><p>The abstract state model value to be cloned as needed.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>index of the declared abstract state variable.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafSystem_[Expression].DeclareContinuousState(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>DeclareContinuousState(self: pydrake.systems.framework.LeafSystem_[Expression], num_state_variables: int) -&gt; pydrake.systems.framework.ContinuousStateIndex</p></li>
</ol>
<p>Declares that this System should reserve continuous state with
<code class="docutils literal notranslate"><span class="pre">num_state_variables</span></code> state variables, which have no second-order
structure.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>index of the declared state (currently always zero).</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>DeclareContinuousState(self: pydrake.systems.framework.LeafSystem_[Expression], num_q: int, num_v: int, num_z: int) -&gt; pydrake.systems.framework.ContinuousStateIndex</p></li>
</ol>
<p>Declares that this System should reserve continuous state with
<code class="docutils literal notranslate"><span class="pre">num_q</span></code> generalized positions, <code class="docutils literal notranslate"><span class="pre">num_v</span></code> generalized velocities, and
<code class="docutils literal notranslate"><span class="pre">num_z</span></code> miscellaneous state variables.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>index of the declared state (currently always zero).</p>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li><p>DeclareContinuousState(self: pydrake.systems.framework.LeafSystem_[Expression], model_vector: pydrake.systems.framework.BasicVector_[Expression]) -&gt; pydrake.systems.framework.ContinuousStateIndex</p></li>
</ol>
<p>Declares that this System should reserve continuous state with
<code class="docutils literal notranslate"><span class="pre">model_vector</span></code>.size() miscellaneous state variables, stored in a
vector cloned from <code class="docutils literal notranslate"><span class="pre">model_vector</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>index of the declared state (currently always zero).</p>
</dd>
</dl>
<ol class="arabic simple" start="4">
<li><p>DeclareContinuousState(self: pydrake.systems.framework.LeafSystem_[Expression], model_vector: pydrake.systems.framework.BasicVector_[Expression], num_q: int, num_v: int, num_z: int) -&gt; pydrake.systems.framework.ContinuousStateIndex</p></li>
</ol>
<p>Declares that this System should reserve continuous state with
<code class="docutils literal notranslate"><span class="pre">num_q</span></code> generalized positions, <code class="docutils literal notranslate"><span class="pre">num_v</span></code> generalized velocities, and
<code class="docutils literal notranslate"><span class="pre">num_z</span></code> miscellaneous state variables, stored in a vector cloned
from <code class="docutils literal notranslate"><span class="pre">model_vector</span></code>. Aborts if <code class="docutils literal notranslate"><span class="pre">model_vector</span></code> has the wrong size.
If the <code class="docutils literal notranslate"><span class="pre">model_vector</span></code> declares any VectorBase::GetElementBounds()
constraints, they will be re-declared as inequality constraints on
this system (see DeclareInequalityConstraint()).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>index of the declared state (currently always zero).</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafSystem_[Expression].DeclareDiscreteState(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>DeclareDiscreteState(self: pydrake.systems.framework.LeafSystem_[Expression], model_vector: pydrake.systems.framework.BasicVector_[Expression]) -&gt; pydrake.systems.framework.DiscreteStateIndex</p></li>
</ol>
<p>Declares a discrete state group with <code class="docutils literal notranslate"><span class="pre">model_vector</span></code>.size() state
variables, stored in a vector cloned from <code class="docutils literal notranslate"><span class="pre">model_vector</span></code> (preserving
the concrete type and value).</p>
<ol class="arabic simple" start="2">
<li><p>DeclareDiscreteState(self: pydrake.systems.framework.LeafSystem_[Expression], vector: numpy.ndarray[object[m, 1]]) -&gt; pydrake.systems.framework.DiscreteStateIndex</p></li>
</ol>
<p>Declares a discrete state group with <code class="docutils literal notranslate"><span class="pre">vector</span></code>.size() state
variables, stored in a BasicVector initialized with the contents of
<code class="docutils literal notranslate"><span class="pre">vector</span></code>.</p>
<ol class="arabic simple" start="3">
<li><p>DeclareDiscreteState(self: pydrake.systems.framework.LeafSystem_[Expression], num_state_variables: int) -&gt; pydrake.systems.framework.DiscreteStateIndex</p></li>
</ol>
<p>Declares a discrete state group with <code class="docutils literal notranslate"><span class="pre">num_state_variables</span></code> state
variables, stored in a BasicVector initialized to be all-zero. If you
want non-zero initial values, use an alternate DeclareDiscreteState()
signature that accepts a <code class="docutils literal notranslate"><span class="pre">model_vector</span></code> parameter.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">num_state_variables</span></code> must be non-negative.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafSystem_[Expression].DeclareForcedDiscreteUpdateEvent(self:</span> <span class="pre">pydrake.systems.framework.LeafSystem_[Expression],</span> <span class="pre">update:</span> <span class="pre">Callable[[pydrake.systems.framework.Context_[Expression],</span> <span class="pre">pydrake.systems.framework.DiscreteValues_[Expression]],</span> <span class="pre">Optional[pydrake.systems.framework.EventStatus]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Declares a function that is called whenever a user directly calls
CalcForcedDiscreteVariableUpdate(const Context&amp;, DiscreteValues&lt;T&gt;*).
Multiple calls to DeclareForcedDiscreteUpdateEvent() will cause
multiple handlers to be called upon a call to
CalcForcedDiscreteVariableUpdate(); these handlers will be called with
the same const Context in arbitrary order. The handler should be a
class member function (method) with this signature:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">EventStatus</span><span class="w"> </span><span class="nf">MySystem::MyDiscreteVariableUpdates</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Context</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="p">,</span>
<span class="n">DiscreteValues</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span><span class="p">);</span>
</pre></div>
</div>
</details><p>where <code class="docutils literal notranslate"><span class="pre">MySystem</span></code> is a class derived from <code class="docutils literal notranslate"><span class="pre">LeafSystem&lt;T&gt;</span></code> and the
method name is arbitrary.</p>
<p>See declare_forced_events “Declare forced events” for more
information.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">this</span></code> must be dynamic_cast-able to MySystem.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">update</span></code> must not be null.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafSystem_[Expression].DeclareForcedPublishEvent(self:</span> <span class="pre">pydrake.systems.framework.LeafSystem_[Expression],</span> <span class="pre">publish:</span> <span class="pre">Callable[[pydrake.systems.framework.Context_[Expression]],</span> <span class="pre">Optional[pydrake.systems.framework.EventStatus]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Declares a function that is called whenever a user directly calls
ForcedPublish(const Context&amp;). Multiple calls to
DeclareForcedPublishEvent() will cause multiple handlers to be called
upon a call to ForcedPublish(); these handlers which will be called
with the same const Context in arbitrary order. The handler should be
a class member function (method) with this signature:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">EventStatus</span><span class="w"> </span><span class="nf">MySystem::MyPublish</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Context</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
</details><p>where <code class="docutils literal notranslate"><span class="pre">MySystem</span></code> is a class derived from <code class="docutils literal notranslate"><span class="pre">LeafSystem&lt;T&gt;</span></code> and the
method name is arbitrary.</p>
<p>See declare_forced_events “Declare forced events” for more
information.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">this</span></code> must be dynamic_cast-able to MySystem.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">publish</span></code> must not be null.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafSystem_[Expression].DeclareForcedUnrestrictedUpdateEvent(self:</span> <span class="pre">pydrake.systems.framework.LeafSystem_[Expression],</span> <span class="pre">update:</span> <span class="pre">Callable[[pydrake.systems.framework.Context_[Expression],</span> <span class="pre">pydrake.systems.framework.State_[Expression]],</span> <span class="pre">Optional[pydrake.systems.framework.EventStatus]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Declares a function that is called whenever a user directly calls
CalcForcedUnrestrictedUpdate(const Context&amp;, State&lt;T&gt;*). Multiple
calls to DeclareForcedUnrestrictedUpdateEvent() will cause multiple
handlers to be called upon a call to CalcForcedUnrestrictedUpdate();
these handlers which will be called with the same const Context in
arbitrary order.The handler should be a class member function (method)
with this signature:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">EventStatus</span><span class="w"> </span><span class="nf">MySystem::MyUnrestrictedUpdates</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Context</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="p">,</span>
<span class="n">State</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span><span class="p">);</span>
</pre></div>
</div>
</details><p>where <code class="docutils literal notranslate"><span class="pre">MySystem</span></code> is a class derived from <code class="docutils literal notranslate"><span class="pre">LeafSystem&lt;T&gt;</span></code> and the
method name is arbitrary.</p>
<p>See declare_forced_events “Declare forced events” for more
information.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">this</span></code> must be dynamic_cast-able to MySystem.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">update</span></code> must not be null.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafSystem_[Expression].DeclareInitializationDiscreteUpdateEvent(self:</span> <span class="pre">pydrake.systems.framework.LeafSystem_[Expression],</span> <span class="pre">update:</span> <span class="pre">Callable[[pydrake.systems.framework.Context_[Expression],</span> <span class="pre">pydrake.systems.framework.DiscreteValues_[Expression]],</span> <span class="pre">Optional[pydrake.systems.framework.EventStatus]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Declares that a DiscreteUpdate event should occur at initialization
and that it should invoke the given event handler method. The handler
should be a class member function (method) with this signature:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">EventStatus</span><span class="w"> </span><span class="nf">MySystem::MyUpdate</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Context</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="p">,</span>
<span class="n">DiscreteValues</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
</details><p>where <code class="docutils literal notranslate"><span class="pre">MySystem</span></code> is a class derived from <code class="docutils literal notranslate"><span class="pre">LeafSystem&lt;T&gt;</span></code> and the
method name is arbitrary.</p>
<p>See declare_initialization_events “Declare initialization events” for
more information.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">this</span></code> must be dynamic_cast-able to MySystem.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">update</span></code> must not be null.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclareInitializationPublishEvent()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclareInitializationUnrestrictedUpdateEvent()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclareInitializationEvent()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafSystem_[Expression].DeclareInitializationEvent(self:</span> <span class="pre">pydrake.systems.framework.LeafSystem_[Expression],</span> <span class="pre">event:</span> <span class="pre">pydrake.systems.framework.Event_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>(Advanced) Declares that a particular Event object should be
dispatched at initialization. This is the most general form for
declaring initialization events and most users should use one of the
other methods in this group instead.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclareInitializationPublishEvent()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclareInitializationDiscreteUpdateEvent()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclareInitializationUnrestrictedUpdateEvent()</p>
</div>
<p>See declare_initialization_events “Declare initialization events” for
more information.</p>
<p>Depending on the type of <code class="docutils literal notranslate"><span class="pre">event</span></code>, on initialization it will be
passed to the Publish, DiscreteUpdate, or UnrestrictedUpdate event
dispatcher. If the <code class="docutils literal notranslate"><span class="pre">event</span></code> object contains a handler function,
Drake’s default dispatchers will invoke that handler. If not, then no
further action is taken. Thus an <code class="docutils literal notranslate"><span class="pre">event</span></code> with no handler has no
effect unless its dispatcher has been overridden. We strongly
recommend that you <em>do not</em> override the dispatcher and instead <em>do</em>
supply a handler.</p>
<p>The given <code class="docutils literal notranslate"><span class="pre">event</span></code> object is deep-copied (cloned), and the copy is
stored internally so you do not need to keep the object around after
this call.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><cite>event</cite>’s associated trigger type must be TriggerType::kUnknown or
already set to TriggerType::kInitialization.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafSystem_[Expression].DeclareInitializationPublishEvent(self:</span> <span class="pre">pydrake.systems.framework.LeafSystem_[Expression],</span> <span class="pre">publish:</span> <span class="pre">Callable[[pydrake.systems.framework.Context_[Expression]],</span> <span class="pre">Optional[pydrake.systems.framework.EventStatus]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Declares that a Publish event should occur at initialization and that
it should invoke the given event handler method. The handler should be
a class member function (method) with this signature:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">EventStatus</span><span class="w"> </span><span class="nf">MySystem::MyPublish</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Context</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
</details><p>where <code class="docutils literal notranslate"><span class="pre">MySystem</span></code> is a class derived from <code class="docutils literal notranslate"><span class="pre">LeafSystem&lt;T&gt;</span></code> and the
method name is arbitrary.</p>
<p>See declare_initialization_events “Declare initialization events” for
more information.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">this</span></code> must be dynamic_cast-able to MySystem.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">publish</span></code> must not be null.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclareInitializationDiscreteUpdateEvent()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclareInitializationUnrestrictedUpdateEvent()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclareInitializationEvent()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafSystem_[Expression].DeclareInitializationUnrestrictedUpdateEvent(self:</span> <span class="pre">pydrake.systems.framework.LeafSystem_[Expression],</span> <span class="pre">update:</span> <span class="pre">Callable[[pydrake.systems.framework.Context_[Expression],</span> <span class="pre">pydrake.systems.framework.State_[Expression]],</span> <span class="pre">Optional[pydrake.systems.framework.EventStatus]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Declares that an UnrestrictedUpdate event should occur at
initialization and that it should invoke the given event handler
method. The handler should be a class member function (method) with
this signature:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">EventStatus</span><span class="w"> </span><span class="nf">MySystem::MyUpdate</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Context</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="p">,</span>
<span class="n">State</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
</details><p>where <code class="docutils literal notranslate"><span class="pre">MySystem</span></code> is a class derived from <code class="docutils literal notranslate"><span class="pre">LeafSystem&lt;T&gt;</span></code> and the
method name is arbitrary.</p>
<p>See declare_initialization_events “Declare initialization events” for
more information.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">this</span></code> must be dynamic_cast-able to MySystem.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">update</span></code> must not be null.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclareInitializationPublishEvent()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclareInitializationDiscreteUpdateEvent()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclareInitializationEvent()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafSystem_[Expression].DeclareNumericParameter(self:</span> <span class="pre">pydrake.systems.framework.LeafSystem_[Expression],</span> <span class="pre">model_vector:</span> <span class="pre">pydrake.systems.framework.BasicVector_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Declares a numeric parameter using the given <code class="docutils literal notranslate"><span class="pre">model_vector</span></code>.
LeafSystem’s default implementation of SetDefaultParameters() will
reset parameters to their model vectors. If the <code class="docutils literal notranslate"><span class="pre">model_vector</span></code>
declares any VectorBase::GetElementBounds() constraints, they will be
re-declared as inequality constraints on this system (see
DeclareInequalityConstraint()). Returns the index of the new
parameter.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafSystem_[Expression].DeclarePeriodicDiscreteUpdateEvent(self:</span> <span class="pre">pydrake.systems.framework.LeafSystem_[Expression],</span> <span class="pre">period_sec:</span> <span class="pre">float,</span> <span class="pre">offset_sec:</span> <span class="pre">float,</span> <span class="pre">update:</span> <span class="pre">Callable[[pydrake.systems.framework.Context_[Expression],</span> <span class="pre">pydrake.systems.framework.DiscreteValues_[Expression]],</span> <span class="pre">Optional[pydrake.systems.framework.EventStatus]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Declares that a DiscreteUpdate event should occur periodically and
that it should invoke the given event handler method. The handler
should be a class member function (method) with this signature:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">EventStatus</span><span class="w"> </span><span class="nf">MySystem::MyUpdate</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Context</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="p">,</span>
<span class="n">DiscreteValues</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
</details><p>where <code class="docutils literal notranslate"><span class="pre">MySystem</span></code> is a class derived from <code class="docutils literal notranslate"><span class="pre">LeafSystem&lt;T&gt;</span></code> and the
method name is arbitrary.</p>
<p>See declare_periodic_events “Declare periodic events” for more
information.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">this</span></code> must be dynamic_cast-able to MySystem.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">update</span></code> must not be null.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclarePeriodicPublishEvent()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclarePeriodicUnrestrictedUpdateEvent()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclarePeriodicEvent()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafSystem_[Expression].DeclarePeriodicEvent(self:</span> <span class="pre">pydrake.systems.framework.LeafSystem_[Expression],</span> <span class="pre">period_sec:</span> <span class="pre">float,</span> <span class="pre">offset_sec:</span> <span class="pre">float,</span> <span class="pre">event:</span> <span class="pre">pydrake.systems.framework.Event_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>(Advanced) Declares that a particular Event object should be
dispatched periodically. This is the most general form for declaring
periodic events and most users should use one of the other methods in
this group instead.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclarePeriodicPublishEvent()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclarePeriodicDiscreteUpdateEvent()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclarePeriodicUnrestrictedUpdateEvent()</p>
</div>
<p>See declare_periodic_events “Declare periodic events” for more
information.</p>
<p>Depending on the type of <code class="docutils literal notranslate"><span class="pre">event</span></code>, when triggered it will be passed
to the Publish, DiscreteUpdate, or UnrestrictedUpdate event
dispatcher. If the <code class="docutils literal notranslate"><span class="pre">event</span></code> object contains a handler function,
Drake’s default dispatchers will invoke that handler. If not, then no
further action is taken. Thus an <code class="docutils literal notranslate"><span class="pre">event</span></code> with no handler has no
effect unless its dispatcher has been overridden. We strongly
recommend that you <em>do not</em> override the dispatcher and instead <em>do</em>
supply a handler.</p>
<p>The given <code class="docutils literal notranslate"><span class="pre">event</span></code> object is deep-copied (cloned), and the copy is
stored internally so you do not need to keep the object around after
this call.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><cite>event</cite>’s associated trigger type must be TriggerType::kUnknown or
already set to TriggerType::kPeriodic.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafSystem_[Expression].DeclarePeriodicPublishEvent(self:</span> <span class="pre">pydrake.systems.framework.LeafSystem_[Expression],</span> <span class="pre">period_sec:</span> <span class="pre">float,</span> <span class="pre">offset_sec:</span> <span class="pre">float,</span> <span class="pre">publish:</span> <span class="pre">Callable[[pydrake.systems.framework.Context_[Expression]],</span> <span class="pre">Optional[pydrake.systems.framework.EventStatus]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Declares that a Publish event should occur periodically and that it
should invoke the given event handler method. The handler should be a
class member function (method) with this signature:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">EventStatus</span><span class="w"> </span><span class="nf">MySystem::MyPublish</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Context</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
</details><p>where <code class="docutils literal notranslate"><span class="pre">MySystem</span></code> is a class derived from <code class="docutils literal notranslate"><span class="pre">LeafSystem&lt;T&gt;</span></code> and the
method name is arbitrary.</p>
<p>See declare_periodic_events “Declare periodic events” for more
information.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">this</span></code> must be dynamic_cast-able to MySystem.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">publish</span></code> must not be null.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclarePeriodicDiscreteUpdateEvent()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclarePeriodicUnrestrictedUpdateEvent()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclarePeriodicEvent()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafSystem_[Expression].DeclarePeriodicUnrestrictedUpdateEvent(self:</span> <span class="pre">pydrake.systems.framework.LeafSystem_[Expression],</span> <span class="pre">period_sec:</span> <span class="pre">float,</span> <span class="pre">offset_sec:</span> <span class="pre">float,</span> <span class="pre">update:</span> <span class="pre">Callable[[pydrake.systems.framework.Context_[Expression],</span> <span class="pre">pydrake.systems.framework.State_[Expression]],</span> <span class="pre">Optional[pydrake.systems.framework.EventStatus]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Declares that an UnrestrictedUpdate event should occur periodically
and that it should invoke the given event handler method. The handler
should be a class member function (method) with this signature:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">EventStatus</span><span class="w"> </span><span class="nf">MySystem::MyUpdate</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Context</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="p">,</span><span class="w"> </span><span class="n">State</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
</details><p>where <code class="docutils literal notranslate"><span class="pre">MySystem</span></code> is a class derived from <code class="docutils literal notranslate"><span class="pre">LeafSystem&lt;T&gt;</span></code> and the
method name is arbitrary.</p>
<p>See declare_periodic_events “Declare periodic events” for more
information.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">this</span></code> must be dynamic_cast-able to MySystem.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">update</span></code> must not be null.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclarePeriodicPublishEvent()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclarePeriodicDiscreteUpdateEvent()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclarePeriodicEvent()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafSystem_[Expression].DeclarePerStepDiscreteUpdateEvent(self:</span> <span class="pre">pydrake.systems.framework.LeafSystem_[Expression],</span> <span class="pre">update:</span> <span class="pre">Callable[[pydrake.systems.framework.Context_[Expression],</span> <span class="pre">pydrake.systems.framework.DiscreteValues_[Expression]],</span> <span class="pre">Optional[pydrake.systems.framework.EventStatus]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Declares that a DiscreteUpdate event should occur at the start of
every trajectory-advancing step and that it should invoke the given
event handler method. The handler should be a class member function
(method) with this signature:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">EventStatus</span><span class="w"> </span><span class="nf">MySystem::MyUpdate</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Context</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="p">,</span>
<span class="n">DiscreteValues</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
</details><p>where <code class="docutils literal notranslate"><span class="pre">MySystem</span></code> is a class derived from <code class="docutils literal notranslate"><span class="pre">LeafSystem&lt;T&gt;</span></code> and the
method name is arbitrary.</p>
<p>See declare_per-step_events “Declare per-step events” for more
information.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">this</span></code> must be dynamic_cast-able to MySystem.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">update</span></code> must not be null.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclarePerStepPublishEvent()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclarePerStepUnrestrictedUpdateEvent()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclarePerStepEvent()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafSystem_[Expression].DeclarePerStepEvent(self:</span> <span class="pre">pydrake.systems.framework.LeafSystem_[Expression],</span> <span class="pre">event:</span> <span class="pre">pydrake.systems.framework.Event_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>(Advanced) Declares that a particular Event object should be
dispatched at every trajectory-advancing step. Publish events are
dispatched at the end of initialization and at the end of each step.
Discrete- and unrestricted update events are dispatched at the start
of each step. This is the most general form for declaring per-step
events and most users should use one of the other methods in this
group instead.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclarePerStepPublishEvent()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclarePerStepDiscreteUpdateEvent()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclarePerStepUnrestrictedUpdateEvent()</p>
</div>
<p>See declare_per-step_events “Declare per-step events” for more
information.</p>
<p>Depending on the type of <code class="docutils literal notranslate"><span class="pre">event</span></code>, at each step it will be passed to
the Publish, DiscreteUpdate, or UnrestrictedUpdate event dispatcher.
If the <code class="docutils literal notranslate"><span class="pre">event</span></code> object contains a handler function, Drake’s default
dispatchers will invoke that handler. If not, then no further action
is taken. Thus an <code class="docutils literal notranslate"><span class="pre">event</span></code> with no handler has no effect unless its
dispatcher has been overridden. We strongly recommend that you <em>do
not</em> override the dispatcher and instead <em>do</em> supply a handler.</p>
<p>The given <code class="docutils literal notranslate"><span class="pre">event</span></code> object is deep-copied (cloned), and the copy is
stored internally so you do not need to keep the object around after
this call.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><cite>event</cite>’s associated trigger type must be TriggerType::kUnknown or
already set to TriggerType::kPerStep.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafSystem_[Expression].DeclarePerStepPublishEvent(self:</span> <span class="pre">pydrake.systems.framework.LeafSystem_[Expression],</span> <span class="pre">publish:</span> <span class="pre">Callable[[pydrake.systems.framework.Context_[Expression]],</span> <span class="pre">Optional[pydrake.systems.framework.EventStatus]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Declares that a Publish event should occur at initialization and at
the end of every trajectory-advancing step and that it should invoke
the given event handler method. The handler should be a class member
function (method) with this signature:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">EventStatus</span><span class="w"> </span><span class="nf">MySystem::MyPublish</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Context</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
</details><p>where <code class="docutils literal notranslate"><span class="pre">MySystem</span></code> is a class derived from <code class="docutils literal notranslate"><span class="pre">LeafSystem&lt;T&gt;</span></code> and the
method name is arbitrary.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>These per-step publish events are independent of the Simulator’s
optional “publish every time step” and “publish at initialization”
features. Generally if you are declaring per-step publish events
yourself you should turn off those Simulation options.</p>
</div>
<p>See declare_per-step_events “Declare per-step events” for more
information.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">this</span></code> must be dynamic_cast-able to MySystem.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">publish</span></code> must not be null.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclarePerStepDiscreteUpdateEvent()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclarePerStepUnrestrictedUpdateEvent()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclarePerStepEvent()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>Simulator::set_publish_at_initialization()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>Simulator::set_publish_every_time_step()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafSystem_[Expression].DeclarePerStepUnrestrictedUpdateEvent(self:</span> <span class="pre">pydrake.systems.framework.LeafSystem_[Expression],</span> <span class="pre">update:</span> <span class="pre">Callable[[pydrake.systems.framework.Context_[Expression],</span> <span class="pre">pydrake.systems.framework.State_[Expression]],</span> <span class="pre">Optional[pydrake.systems.framework.EventStatus]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Declares that an UnrestrictedUpdate event should occur at the start of
every trajectory-advancing step and that it should invoke the given
event handler method. The handler should be a class member function
(method) with this signature:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">EventStatus</span><span class="w"> </span><span class="nf">MySystem::MyUpdate</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Context</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="p">,</span>
<span class="n">State</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
</details><p>where <code class="docutils literal notranslate"><span class="pre">MySystem</span></code> is a class derived from <code class="docutils literal notranslate"><span class="pre">LeafSystem&lt;T&gt;</span></code> and the
method name is arbitrary.</p>
<p>See declare_per-step_events “Declare per-step events” for more
information.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">this</span></code> must be dynamic_cast-able to MySystem.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">update</span></code> must not be null.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclarePerStepPublishEvent()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclarePerStepDiscreteUpdateEvent()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DeclarePerStepEvent()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafSystem_[Expression].DeclareStateOutputPort(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>DeclareStateOutputPort(self: pydrake.systems.framework.LeafSystem_[Expression], name: Union[str, pydrake.systems.framework.UseDefaultName], state_index: pydrake.systems.framework.ContinuousStateIndex) -&gt; pydrake.systems.framework.LeafOutputPort_[Expression]</p></li>
</ol>
<p>Declares a vector-valued output port whose value is the continuous
state of this system.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">state_index</span></code>:</dt><dd><p>must be ContinuousStateIndex(0) for now, since LeafSystem only
supports a single continuous state group at the moment.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>DeclareStateOutputPort(self: pydrake.systems.framework.LeafSystem_[Expression], name: Union[str, pydrake.systems.framework.UseDefaultName], state_index: pydrake.systems.framework.DiscreteStateIndex) -&gt; pydrake.systems.framework.LeafOutputPort_[Expression]</p></li>
</ol>
<p>Declares a vector-valued output port whose value is the given discrete
state group of this system.</p>
<ol class="arabic simple" start="3">
<li><p>DeclareStateOutputPort(self: pydrake.systems.framework.LeafSystem_[Expression], name: Union[str, pydrake.systems.framework.UseDefaultName], state_index: pydrake.systems.framework.AbstractStateIndex) -&gt; pydrake.systems.framework.LeafOutputPort_[Expression]</p></li>
</ol>
<p>Declares an abstract-valued output port whose value is the given
abstract state of this system.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafSystem_[Expression].DeclareVectorInputPort(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>DeclareVectorInputPort(self: pydrake.systems.framework.LeafSystem_[Expression], name: str, model_vector: pydrake.systems.framework.BasicVector_[Expression], random_type: Optional[pydrake.common.RandomDistribution] = None) -&gt; pydrake.systems.framework.InputPort_[Expression]</p></li>
</ol>
<p>Declares a vector-valued input port using the given <code class="docutils literal notranslate"><span class="pre">model_vector</span></code>.
This is the best way to declare LeafSystem input ports that require
subclasses of BasicVector. The port’s size and type will be the same
as model_vector. If the port is intended to model a random noise or
disturbance input, <code class="docutils literal notranslate"><span class="pre">random_type</span></code> can (optionally) be used to label
it as such. If the <code class="docutils literal notranslate"><span class="pre">model_vector</span></code> declares any
VectorBase::GetElementBounds() constraints, they will be re-declared
as inequality constraints on this system (see
DeclareInequalityConstraint()).</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>System::DeclareInputPort() for more information.</p>
</div>
<ol class="arabic simple" start="2">
<li><p>DeclareVectorInputPort(self: pydrake.systems.framework.LeafSystem_[Expression], name: str, size: int, random_type: Optional[pydrake.common.RandomDistribution] = None) -&gt; pydrake.systems.framework.InputPort_[Expression]</p></li>
</ol>
<p>Declares a vector-valued input port with type BasicVector and size
<code class="docutils literal notranslate"><span class="pre">size</span></code>. If the port is intended to model a random noise or
disturbance input, <code class="docutils literal notranslate"><span class="pre">random_type</span></code> can (optionally) be used to label
it as such.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>System::DeclareInputPort() for more information.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafSystem_[Expression].DeclareVectorOutputPort(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>DeclareVectorOutputPort(self: pydrake.systems.framework.LeafSystem_[Expression], name: str, model_value: pydrake.systems.framework.BasicVector_[Expression], calc: Callable[[pydrake.systems.framework.Context_[Expression], pydrake.systems.framework.BasicVector_[Expression]], None], prerequisites_of_calc: set[pydrake.systems.framework.DependencyTicket] = {DependencyTicket(15)}) -&gt; pydrake.systems.framework.OutputPort_[Expression]</p></li>
</ol>
<p>(Advanced) Declares a vector-valued output port using the given
<code class="docutils literal notranslate"><span class="pre">model_vector</span></code> and a function for calculating the port’s value at
runtime. The port’s size will be model_vector.size(), and the default
allocator for the port will be model_vector.Clone(). Note that this
takes the calculator function in its most generic form; if you have a
member function available use one of the other signatures.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>LeafOutputPort::CalcVectorCallback</p>
</div>
<ol class="arabic simple" start="2">
<li><p>DeclareVectorOutputPort(self: pydrake.systems.framework.LeafSystem_[Expression], name: str, size: int, calc: Callable[[pydrake.systems.framework.Context_[Expression], pydrake.systems.framework.BasicVector_[Expression]], None], prerequisites_of_calc: set[pydrake.systems.framework.DependencyTicket] = {DependencyTicket(15)}) -&gt; pydrake.systems.framework.OutputPort_[Expression]</p></li>
</ol>
<p>(Advanced) Declares a vector-valued output port with type
BasicVector&lt;T&gt; and size <code class="docutils literal notranslate"><span class="pre">size</span></code>, using the drake::dummy_value&lt;T&gt;,
which is NaN when T = double. <code class="docutils literal notranslate"><span class="pre">vector_calc_function</span></code> is a function
for calculating the port’s value at runtime. Note that this takes the
calculator function in its most generic form; if you have a member
function available use one of the other signatures.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>LeafOutputPort::CalcVectorCallback</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafSystem_[Expression].DoCalcTimeDerivatives(self:</span> <span class="pre">pydrake.systems.framework.LeafSystem_[Expression],</span> <span class="pre">arg0:</span> <span class="pre">pydrake.systems.framework.Context_[Expression],</span> <span class="pre">arg1:</span> <span class="pre">pydrake.systems.framework.ContinuousState_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LeafSystem_[Expression].MakeWitnessFunction(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>MakeWitnessFunction(self: pydrake.systems.framework.LeafSystem_[Expression], description: str, direction_type: pydrake.systems.framework.WitnessFunctionDirection, calc: Callable[[pydrake.systems.framework.Context_[Expression]], Optional[pydrake.symbolic.Expression]]) -&gt; pydrake.systems.framework.WitnessFunction_[Expression]</p></li>
</ol>
<p>Constructs the witness function with the given description (used
primarily for debugging and logging), direction type, and calculator
function; and with no event object.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In order for the witness function to be used, you MUST overload
System::DoGetWitnessFunctions().</p>
</div>
<ol class="arabic simple" start="2">
<li><p>MakeWitnessFunction(self: pydrake.systems.framework.LeafSystem_[Expression], description: str, direction_type: pydrake.systems.framework.WitnessFunctionDirection, calc: Callable[[pydrake.systems.framework.Context_[Expression]], pydrake.symbolic.Expression], e: pydrake.systems.framework.Event_[Expression]) -&gt; pydrake.systems.framework.WitnessFunction_[Expression]</p></li>
</ol>
<p>Constructs the witness function with the given description (used
primarily for debugging and logging), direction type, and calculator
function, and with an object corresponding to the event that is to be
dispatched when this witness function triggers. Example types of event
objects are publish, discrete variable update, unrestricted update
events. A clone of the event will be owned by the newly constructed
WitnessFunction.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In order for the witness function to be used, you MUST overload
System::DoGetWitnessFunctions().</p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">NumericParameterIndex</span></span></dt>
<dd><dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">NumericParameterIndex.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.systems.framework.NumericParameterIndex) -&gt; None</p></li>
</ol>
<p>Default constructor; the result is an <em>invalid</em> index. This only
exists to serve applications which require a default constructor.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.systems.framework.NumericParameterIndex, arg0: int) -&gt; None</p></li>
</ol>
<p>Construction from a non-negative <code class="docutils literal notranslate"><span class="pre">int</span></code> value. The value must lie in
the range of [0, 2³¹). Constructor only promises to test validity in
Debug build.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">NumericParameterIndex.is_valid(self:</span> <span class="pre">pydrake.systems.framework.NumericParameterIndex)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Reports if the index is valid–the only operation on an invalid index
that doesn’t throw an exception in Debug builds.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">OutputPort</span></span></dt>
<dd><p>An OutputPort belongs to a System and represents the properties of one
of that System’s output ports. OutputPort objects are assigned
OutputPortIndex values in the order they are declared; these are
unique within a single System.</p>
<p>An output port can be considered a “window” into a System that permits
controlled exposure of one of the values contained in that System’s
Context at run time. Input ports of other subsystems may be connected
to an output port to construct system diagrams with carefully managed
interdependencies.</p>
<p>The exposed value may be the result of an output computation, or it
may simply expose some other value contained in the Context, such as
the values of state variables. The Context handles caching of output
port values and tracks dependencies to ensure that the values are
valid with respect to their prerequisites. Leaf systems provide for
the production of output port values, by computation or forwarding
from other values within the associated leaf context. A diagram’s
output ports, on the other hand, are exported from output ports of its
contained subsystems.</p>
<p>An output port’s value is always stored as an AbstractValue, but we
also provide special handling for output ports known to have numeric
(vector) values. Vector-valued ports may specify a particular vector
length, or may leave that to be determined at runtime.</p>
<p>OutputPort objects support three important operations:</p>
<ul class="simple">
<li><p>Allocate() returns an object that can hold the port’s value.</p></li>
<li><p>Calc() unconditionally computes the port’s value.</p></li>
<li><p>Eval() updates a cached value if necessary.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">OutputPort_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">OutputPort.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">OutputPort.Allocate(self:</span> <span class="pre">pydrake.systems.framework.OutputPort)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.common.value.AbstractValue</span></span></dt>
<dd><p>Allocates a concrete object suitable for holding the value to be
exposed by this output port, and returns that as an AbstractValue. The
returned object will never be null. If Drake assertions are enabled
(typically only in Debug builds), validates for a vector-valued port
that the returned AbstractValue is actually a BasicVector-derived type
and that it has an acceptable size.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If this is a vector-valued port, the underlying type is
<code class="docutils literal notranslate"><span class="pre">Value&lt;BasicVector&lt;T&gt;&gt;</span></code>; downcast to <code class="docutils literal notranslate"><span class="pre">BasicVector&lt;T&gt;</span></code> before
downcasting to the specific <code class="docutils literal notranslate"><span class="pre">BasicVector</span></code> subclass.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">OutputPort.Eval(self:</span> <span class="pre">pydrake.systems.framework.OutputPort,</span> <span class="pre">arg0:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">object</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">OutputPort.EvalAbstract(self:</span> <span class="pre">pydrake.systems.framework.OutputPort,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">object</span></span></dt>
<dd><p>(Advanced.) Returns the value of this output port, typed as an AbstractValue. Most users should call Eval() instead. This method is only needed when the result will be passed into some other API that only accepts an AbstractValue.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">OutputPort.EvalBasicVector(self:</span> <span class="pre">pydrake.systems.framework.OutputPort,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">object</span></span></dt>
<dd><p>(Advanced.) Returns the value of this output port, typed as a BasicVector. Most users should call Eval() instead. This method is only needed when the result will be passed into some other API that only accepts a BasicVector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">OutputPort.get_data_type(self:</span> <span class="pre">pydrake.systems.framework.OutputPort)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.PortDataType</span></span></dt>
<dd><p>Returns the port data type.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">OutputPort.get_index(self:</span> <span class="pre">pydrake.systems.framework.OutputPort)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.OutputPortIndex</span></span></dt>
<dd><p>Returns the index of this output port within the owning System. For a
Diagram, this will be the index within the Diagram, <em>not</em> the index
within the LeafSystem whose output port was forwarded.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">OutputPort.get_name(self:</span> <span class="pre">pydrake.systems.framework.OutputPort)</span> <span class="pre">-&gt;</span> <span class="pre">str</span></span></dt>
<dd><p>Get port name.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">OutputPort.get_system(self:</span> <span class="pre">pydrake.systems.framework.OutputPort)</span> <span class="pre">-&gt;</span> <span class="pre">object</span></span></dt>
<dd><p>Returns a reference to the System that owns this output port. Note
that for a diagram output port this will be the diagram, not the leaf
system whose output port was forwarded.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">OutputPort.size(self:</span> <span class="pre">pydrake.systems.framework.OutputPort)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the fixed size expected for a vector-valued port. Not
meaningful for abstract-valued ports.</p>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">OutputPort_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">OutputPort_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">OutputPort_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">OutputPort_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">OutputPort_[AutoDiffXd]</span></span></dt>
<dd><p>An OutputPort belongs to a System and represents the properties of one
of that System’s output ports. OutputPort objects are assigned
OutputPortIndex values in the order they are declared; these are
unique within a single System.</p>
<p>An output port can be considered a “window” into a System that permits
controlled exposure of one of the values contained in that System’s
Context at run time. Input ports of other subsystems may be connected
to an output port to construct system diagrams with carefully managed
interdependencies.</p>
<p>The exposed value may be the result of an output computation, or it
may simply expose some other value contained in the Context, such as
the values of state variables. The Context handles caching of output
port values and tracks dependencies to ensure that the values are
valid with respect to their prerequisites. Leaf systems provide for
the production of output port values, by computation or forwarding
from other values within the associated leaf context. A diagram’s
output ports, on the other hand, are exported from output ports of its
contained subsystems.</p>
<p>An output port’s value is always stored as an AbstractValue, but we
also provide special handling for output ports known to have numeric
(vector) values. Vector-valued ports may specify a particular vector
length, or may leave that to be determined at runtime.</p>
<p>OutputPort objects support three important operations:</p>
<ul class="simple">
<li><p>Allocate() returns an object that can hold the port’s value.</p></li>
<li><p>Calc() unconditionally computes the port’s value.</p></li>
<li><p>Eval() updates a cached value if necessary.</p></li>
</ul>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">OutputPort_[AutoDiffXd].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">OutputPort_[AutoDiffXd].Allocate(self:</span> <span class="pre">pydrake.systems.framework.OutputPort_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.common.value.AbstractValue</span></span></dt>
<dd><p>Allocates a concrete object suitable for holding the value to be
exposed by this output port, and returns that as an AbstractValue. The
returned object will never be null. If Drake assertions are enabled
(typically only in Debug builds), validates for a vector-valued port
that the returned AbstractValue is actually a BasicVector-derived type
and that it has an acceptable size.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If this is a vector-valued port, the underlying type is
<code class="docutils literal notranslate"><span class="pre">Value&lt;BasicVector&lt;T&gt;&gt;</span></code>; downcast to <code class="docutils literal notranslate"><span class="pre">BasicVector&lt;T&gt;</span></code> before
downcasting to the specific <code class="docutils literal notranslate"><span class="pre">BasicVector</span></code> subclass.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">OutputPort_[AutoDiffXd].Eval(self:</span> <span class="pre">pydrake.systems.framework.OutputPort_[AutoDiffXd],</span> <span class="pre">arg0:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">object</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">OutputPort_[AutoDiffXd].EvalAbstract(self:</span> <span class="pre">pydrake.systems.framework.OutputPort_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">object</span></span></dt>
<dd><p>(Advanced.) Returns the value of this output port, typed as an AbstractValue. Most users should call Eval() instead. This method is only needed when the result will be passed into some other API that only accepts an AbstractValue.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">OutputPort_[AutoDiffXd].EvalBasicVector(self:</span> <span class="pre">pydrake.systems.framework.OutputPort_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">object</span></span></dt>
<dd><p>(Advanced.) Returns the value of this output port, typed as a BasicVector. Most users should call Eval() instead. This method is only needed when the result will be passed into some other API that only accepts a BasicVector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">OutputPort_[AutoDiffXd].get_data_type(self:</span> <span class="pre">pydrake.systems.framework.OutputPort_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.PortDataType</span></span></dt>
<dd><p>Returns the port data type.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">OutputPort_[AutoDiffXd].get_index(self:</span> <span class="pre">pydrake.systems.framework.OutputPort_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.OutputPortIndex</span></span></dt>
<dd><p>Returns the index of this output port within the owning System. For a
Diagram, this will be the index within the Diagram, <em>not</em> the index
within the LeafSystem whose output port was forwarded.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">OutputPort_[AutoDiffXd].get_name(self:</span> <span class="pre">pydrake.systems.framework.OutputPort_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">str</span></span></dt>
<dd><p>Get port name.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">OutputPort_[AutoDiffXd].get_system(self:</span> <span class="pre">pydrake.systems.framework.OutputPort_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">object</span></span></dt>
<dd><p>Returns a reference to the System that owns this output port. Note
that for a diagram output port this will be the diagram, not the leaf
system whose output port was forwarded.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">OutputPort_[AutoDiffXd].size(self:</span> <span class="pre">pydrake.systems.framework.OutputPort_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the fixed size expected for a vector-valued port. Not
meaningful for abstract-valued ports.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">OutputPort_[Expression]</span></span></dt>
<dd><p>An OutputPort belongs to a System and represents the properties of one
of that System’s output ports. OutputPort objects are assigned
OutputPortIndex values in the order they are declared; these are
unique within a single System.</p>
<p>An output port can be considered a “window” into a System that permits
controlled exposure of one of the values contained in that System’s
Context at run time. Input ports of other subsystems may be connected
to an output port to construct system diagrams with carefully managed
interdependencies.</p>
<p>The exposed value may be the result of an output computation, or it
may simply expose some other value contained in the Context, such as
the values of state variables. The Context handles caching of output
port values and tracks dependencies to ensure that the values are
valid with respect to their prerequisites. Leaf systems provide for
the production of output port values, by computation or forwarding
from other values within the associated leaf context. A diagram’s
output ports, on the other hand, are exported from output ports of its
contained subsystems.</p>
<p>An output port’s value is always stored as an AbstractValue, but we
also provide special handling for output ports known to have numeric
(vector) values. Vector-valued ports may specify a particular vector
length, or may leave that to be determined at runtime.</p>
<p>OutputPort objects support three important operations:</p>
<ul class="simple">
<li><p>Allocate() returns an object that can hold the port’s value.</p></li>
<li><p>Calc() unconditionally computes the port’s value.</p></li>
<li><p>Eval() updates a cached value if necessary.</p></li>
</ul>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">OutputPort_[Expression].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">OutputPort_[Expression].Allocate(self:</span> <span class="pre">pydrake.systems.framework.OutputPort_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.common.value.AbstractValue</span></span></dt>
<dd><p>Allocates a concrete object suitable for holding the value to be
exposed by this output port, and returns that as an AbstractValue. The
returned object will never be null. If Drake assertions are enabled
(typically only in Debug builds), validates for a vector-valued port
that the returned AbstractValue is actually a BasicVector-derived type
and that it has an acceptable size.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If this is a vector-valued port, the underlying type is
<code class="docutils literal notranslate"><span class="pre">Value&lt;BasicVector&lt;T&gt;&gt;</span></code>; downcast to <code class="docutils literal notranslate"><span class="pre">BasicVector&lt;T&gt;</span></code> before
downcasting to the specific <code class="docutils literal notranslate"><span class="pre">BasicVector</span></code> subclass.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">OutputPort_[Expression].Eval(self:</span> <span class="pre">pydrake.systems.framework.OutputPort_[Expression],</span> <span class="pre">arg0:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">object</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">OutputPort_[Expression].EvalAbstract(self:</span> <span class="pre">pydrake.systems.framework.OutputPort_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">object</span></span></dt>
<dd><p>(Advanced.) Returns the value of this output port, typed as an AbstractValue. Most users should call Eval() instead. This method is only needed when the result will be passed into some other API that only accepts an AbstractValue.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">OutputPort_[Expression].EvalBasicVector(self:</span> <span class="pre">pydrake.systems.framework.OutputPort_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">object</span></span></dt>
<dd><p>(Advanced.) Returns the value of this output port, typed as a BasicVector. Most users should call Eval() instead. This method is only needed when the result will be passed into some other API that only accepts a BasicVector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">OutputPort_[Expression].get_data_type(self:</span> <span class="pre">pydrake.systems.framework.OutputPort_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.PortDataType</span></span></dt>
<dd><p>Returns the port data type.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">OutputPort_[Expression].get_index(self:</span> <span class="pre">pydrake.systems.framework.OutputPort_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.OutputPortIndex</span></span></dt>
<dd><p>Returns the index of this output port within the owning System. For a
Diagram, this will be the index within the Diagram, <em>not</em> the index
within the LeafSystem whose output port was forwarded.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">OutputPort_[Expression].get_name(self:</span> <span class="pre">pydrake.systems.framework.OutputPort_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">str</span></span></dt>
<dd><p>Get port name.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">OutputPort_[Expression].get_system(self:</span> <span class="pre">pydrake.systems.framework.OutputPort_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">object</span></span></dt>
<dd><p>Returns a reference to the System that owns this output port. Note
that for a diagram output port this will be the diagram, not the leaf
system whose output port was forwarded.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">OutputPort_[Expression].size(self:</span> <span class="pre">pydrake.systems.framework.OutputPort_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the fixed size expected for a vector-valued port. Not
meaningful for abstract-valued ports.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">OutputPortIndex</span></span></dt>
<dd><dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">OutputPortIndex.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.systems.framework.OutputPortIndex) -&gt; None</p></li>
</ol>
<p>Default constructor; the result is an <em>invalid</em> index. This only
exists to serve applications which require a default constructor.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.systems.framework.OutputPortIndex, arg0: int) -&gt; None</p></li>
</ol>
<p>Construction from a non-negative <code class="docutils literal notranslate"><span class="pre">int</span></code> value. The value must lie in
the range of [0, 2³¹). Constructor only promises to test validity in
Debug build.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">OutputPortIndex.is_valid(self:</span> <span class="pre">pydrake.systems.framework.OutputPortIndex)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Reports if the index is valid–the only operation on an invalid index
that doesn’t throw an exception in Debug builds.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">OutputPortSelection</span></span></dt>
<dd><p>Members:</p>
<p>kNoOutput</p>
<p>kUseFirstOutputIfItExists</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">OutputPortSelection.__init__(self:</span> <span class="pre">pydrake.systems.framework.OutputPortSelection,</span> <span class="pre">value:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">OutputPortSelection.kNoOutput</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">OutputPortSelection.kUseFirstOutputIfItExists</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">OutputPortSelection.name</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">OutputPortSelection.value</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Parameters</span></span></dt>
<dd><p>Parameters is a container for variables that parameterize a System so
that it can represent a family of related models. Parameters are
members of the Context. Parameters are not Inputs because they do not
flow from upstream Systems, and they are not State because the System
does not define update functions for them. If Parameters are modified,
they are modified by application-specific logic, extrinsic to the
System framework and to the flow of simulation time.</p>
<p>The Parameters include both vector-valued and abstract-valued
elements.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">Parameters_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Parameters.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.systems.framework.Parameters) -&gt; None</p></li>
</ol>
<p>Constructs an empty Parameters.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.systems.framework.Parameters, numeric: list[pydrake.systems.framework.BasicVector], abstract: list[pydrake.common.value.AbstractValue]) -&gt; None</p></li>
</ol>
<p>Constructs Parameters both <code class="docutils literal notranslate"><span class="pre">numeric</span></code> and <code class="docutils literal notranslate"><span class="pre">abstract</span></code>.</p>
<ol class="arabic simple" start="3">
<li><p>__init__(self: pydrake.systems.framework.Parameters, numeric: list[pydrake.systems.framework.BasicVector]) -&gt; None</p></li>
</ol>
<p>Constructs Parameters that are purely <code class="docutils literal notranslate"><span class="pre">numeric</span></code>.</p>
<ol class="arabic simple" start="4">
<li><p>__init__(self: pydrake.systems.framework.Parameters, abstract: list[pydrake.common.value.AbstractValue]) -&gt; None</p></li>
</ol>
<p>Constructs Parameters that are purely <code class="docutils literal notranslate"><span class="pre">abstract</span></code>.</p>
<ol class="arabic simple" start="5">
<li><p>__init__(self: pydrake.systems.framework.Parameters, vec: pydrake.systems.framework.BasicVector) -&gt; None</p></li>
</ol>
<p>Constructs Parameters in the common case where the parameters consist
of exactly one numeric vector.</p>
<ol class="arabic simple" start="6">
<li><p>__init__(self: pydrake.systems.framework.Parameters, value: pydrake.common.value.AbstractValue) -&gt; None</p></li>
</ol>
<p>Constructs Parameters in the common case where the parameters consist
of exactly one abstract value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Parameters.Clone(self:</span> <span class="pre">pydrake.systems.framework.Parameters)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.Parameters</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Parameters.get_abstract_parameter(self:</span> <span class="pre">pydrake.systems.framework.Parameters,</span> <span class="pre">index:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.common.value.AbstractValue</span></span></dt>
<dd><p>Returns the abstract-valued parameter at <code class="docutils literal notranslate"><span class="pre">index</span></code>. Asserts if the
index is out of bounds.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Parameters.get_abstract_parameters(self:</span> <span class="pre">pydrake.systems.framework.Parameters)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.AbstractValues</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Parameters.get_mutable_abstract_parameter(self:</span> <span class="pre">pydrake.systems.framework.Parameters,</span> <span class="pre">index:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.common.value.AbstractValue</span></span></dt>
<dd><p>Returns the abstract-valued parameter at <code class="docutils literal notranslate"><span class="pre">index</span></code>. Asserts if the
index is out of bounds.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Parameters.get_mutable_numeric_parameter(self:</span> <span class="pre">pydrake.systems.framework.Parameters,</span> <span class="pre">index:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.BasicVector</span></span></dt>
<dd><p>Returns the vector-valued parameter at <code class="docutils literal notranslate"><span class="pre">index</span></code>. Asserts if the index
is out of bounds.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Parameters.get_numeric_parameter(self:</span> <span class="pre">pydrake.systems.framework.Parameters,</span> <span class="pre">index:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.BasicVector</span></span></dt>
<dd><p>Returns the vector-valued parameter at <code class="docutils literal notranslate"><span class="pre">index</span></code>. Asserts if the index
is out of bounds.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Parameters.get_numeric_parameters(self:</span> <span class="pre">pydrake.systems.framework.Parameters)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.DiscreteValues</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Parameters.num_abstract_parameters(self:</span> <span class="pre">pydrake.systems.framework.Parameters)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Parameters.num_numeric_parameter_groups(self:</span> <span class="pre">pydrake.systems.framework.Parameters)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Parameters.set_abstract_parameters(self:</span> <span class="pre">pydrake.systems.framework.Parameters,</span> <span class="pre">abstract_params:</span> <span class="pre">pydrake.systems.framework.AbstractValues)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Parameters.set_numeric_parameters(self:</span> <span class="pre">pydrake.systems.framework.Parameters,</span> <span class="pre">numeric_params:</span> <span class="pre">pydrake.systems.framework.DiscreteValues)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Parameters.SetFrom(self:</span> <span class="pre">pydrake.systems.framework.Parameters,</span> <span class="pre">arg0:</span> <span class="pre">pydrake.systems.framework.Parameters)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Initializes this object from <code class="docutils literal notranslate"><span class="pre">other</span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Parameters_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">Parameters_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Parameters_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Parameters_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Parameters_[AutoDiffXd]</span></span></dt>
<dd><p>Parameters is a container for variables that parameterize a System so
that it can represent a family of related models. Parameters are
members of the Context. Parameters are not Inputs because they do not
flow from upstream Systems, and they are not State because the System
does not define update functions for them. If Parameters are modified,
they are modified by application-specific logic, extrinsic to the
System framework and to the flow of simulation time.</p>
<p>The Parameters include both vector-valued and abstract-valued
elements.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Parameters_[AutoDiffXd].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.systems.framework.Parameters_[AutoDiffXd]) -&gt; None</p></li>
</ol>
<p>Constructs an empty Parameters.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.systems.framework.Parameters_[AutoDiffXd], numeric: list[pydrake.systems.framework.BasicVector_[AutoDiffXd]], abstract: list[pydrake.common.value.AbstractValue]) -&gt; None</p></li>
</ol>
<p>Constructs Parameters both <code class="docutils literal notranslate"><span class="pre">numeric</span></code> and <code class="docutils literal notranslate"><span class="pre">abstract</span></code>.</p>
<ol class="arabic simple" start="3">
<li><p>__init__(self: pydrake.systems.framework.Parameters_[AutoDiffXd], numeric: list[pydrake.systems.framework.BasicVector_[AutoDiffXd]]) -&gt; None</p></li>
</ol>
<p>Constructs Parameters that are purely <code class="docutils literal notranslate"><span class="pre">numeric</span></code>.</p>
<ol class="arabic simple" start="4">
<li><p>__init__(self: pydrake.systems.framework.Parameters_[AutoDiffXd], abstract: list[pydrake.common.value.AbstractValue]) -&gt; None</p></li>
</ol>
<p>Constructs Parameters that are purely <code class="docutils literal notranslate"><span class="pre">abstract</span></code>.</p>
<ol class="arabic simple" start="5">
<li><p>__init__(self: pydrake.systems.framework.Parameters_[AutoDiffXd], vec: pydrake.systems.framework.BasicVector_[AutoDiffXd]) -&gt; None</p></li>
</ol>
<p>Constructs Parameters in the common case where the parameters consist
of exactly one numeric vector.</p>
<ol class="arabic simple" start="6">
<li><p>__init__(self: pydrake.systems.framework.Parameters_[AutoDiffXd], value: pydrake.common.value.AbstractValue) -&gt; None</p></li>
</ol>
<p>Constructs Parameters in the common case where the parameters consist
of exactly one abstract value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Parameters_[AutoDiffXd].Clone(self:</span> <span class="pre">pydrake.systems.framework.Parameters_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.Parameters_[AutoDiffXd]</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Parameters_[AutoDiffXd].get_abstract_parameter(self:</span> <span class="pre">pydrake.systems.framework.Parameters_[AutoDiffXd],</span> <span class="pre">index:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.common.value.AbstractValue</span></span></dt>
<dd><p>Returns the abstract-valued parameter at <code class="docutils literal notranslate"><span class="pre">index</span></code>. Asserts if the
index is out of bounds.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Parameters_[AutoDiffXd].get_abstract_parameters(self:</span> <span class="pre">pydrake.systems.framework.Parameters_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.AbstractValues</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Parameters_[AutoDiffXd].get_mutable_abstract_parameter(self:</span> <span class="pre">pydrake.systems.framework.Parameters_[AutoDiffXd],</span> <span class="pre">index:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.common.value.AbstractValue</span></span></dt>
<dd><p>Returns the abstract-valued parameter at <code class="docutils literal notranslate"><span class="pre">index</span></code>. Asserts if the
index is out of bounds.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Parameters_[AutoDiffXd].get_mutable_numeric_parameter(self:</span> <span class="pre">pydrake.systems.framework.Parameters_[AutoDiffXd],</span> <span class="pre">index:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.BasicVector_[AutoDiffXd]</span></span></dt>
<dd><p>Returns the vector-valued parameter at <code class="docutils literal notranslate"><span class="pre">index</span></code>. Asserts if the index
is out of bounds.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Parameters_[AutoDiffXd].get_numeric_parameter(self:</span> <span class="pre">pydrake.systems.framework.Parameters_[AutoDiffXd],</span> <span class="pre">index:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.BasicVector_[AutoDiffXd]</span></span></dt>
<dd><p>Returns the vector-valued parameter at <code class="docutils literal notranslate"><span class="pre">index</span></code>. Asserts if the index
is out of bounds.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Parameters_[AutoDiffXd].get_numeric_parameters(self:</span> <span class="pre">pydrake.systems.framework.Parameters_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.DiscreteValues_[AutoDiffXd]</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Parameters_[AutoDiffXd].num_abstract_parameters(self:</span> <span class="pre">pydrake.systems.framework.Parameters_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Parameters_[AutoDiffXd].num_numeric_parameter_groups(self:</span> <span class="pre">pydrake.systems.framework.Parameters_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Parameters_[AutoDiffXd].set_abstract_parameters(self:</span> <span class="pre">pydrake.systems.framework.Parameters_[AutoDiffXd],</span> <span class="pre">abstract_params:</span> <span class="pre">pydrake.systems.framework.AbstractValues)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Parameters_[AutoDiffXd].set_numeric_parameters(self:</span> <span class="pre">pydrake.systems.framework.Parameters_[AutoDiffXd],</span> <span class="pre">numeric_params:</span> <span class="pre">pydrake.systems.framework.DiscreteValues_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Parameters_[AutoDiffXd].SetFrom(self:</span> <span class="pre">pydrake.systems.framework.Parameters_[AutoDiffXd],</span> <span class="pre">arg0:</span> <span class="pre">pydrake.systems.framework.Parameters)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Initializes this object from <code class="docutils literal notranslate"><span class="pre">other</span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Parameters_[Expression]</span></span></dt>
<dd><p>Parameters is a container for variables that parameterize a System so
that it can represent a family of related models. Parameters are
members of the Context. Parameters are not Inputs because they do not
flow from upstream Systems, and they are not State because the System
does not define update functions for them. If Parameters are modified,
they are modified by application-specific logic, extrinsic to the
System framework and to the flow of simulation time.</p>
<p>The Parameters include both vector-valued and abstract-valued
elements.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Parameters_[Expression].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.systems.framework.Parameters_[Expression]) -&gt; None</p></li>
</ol>
<p>Constructs an empty Parameters.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.systems.framework.Parameters_[Expression], numeric: list[pydrake.systems.framework.BasicVector_[Expression]], abstract: list[pydrake.common.value.AbstractValue]) -&gt; None</p></li>
</ol>
<p>Constructs Parameters both <code class="docutils literal notranslate"><span class="pre">numeric</span></code> and <code class="docutils literal notranslate"><span class="pre">abstract</span></code>.</p>
<ol class="arabic simple" start="3">
<li><p>__init__(self: pydrake.systems.framework.Parameters_[Expression], numeric: list[pydrake.systems.framework.BasicVector_[Expression]]) -&gt; None</p></li>
</ol>
<p>Constructs Parameters that are purely <code class="docutils literal notranslate"><span class="pre">numeric</span></code>.</p>
<ol class="arabic simple" start="4">
<li><p>__init__(self: pydrake.systems.framework.Parameters_[Expression], abstract: list[pydrake.common.value.AbstractValue]) -&gt; None</p></li>
</ol>
<p>Constructs Parameters that are purely <code class="docutils literal notranslate"><span class="pre">abstract</span></code>.</p>
<ol class="arabic simple" start="5">
<li><p>__init__(self: pydrake.systems.framework.Parameters_[Expression], vec: pydrake.systems.framework.BasicVector_[Expression]) -&gt; None</p></li>
</ol>
<p>Constructs Parameters in the common case where the parameters consist
of exactly one numeric vector.</p>
<ol class="arabic simple" start="6">
<li><p>__init__(self: pydrake.systems.framework.Parameters_[Expression], value: pydrake.common.value.AbstractValue) -&gt; None</p></li>
</ol>
<p>Constructs Parameters in the common case where the parameters consist
of exactly one abstract value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Parameters_[Expression].Clone(self:</span> <span class="pre">pydrake.systems.framework.Parameters_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.Parameters_[Expression]</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Parameters_[Expression].get_abstract_parameter(self:</span> <span class="pre">pydrake.systems.framework.Parameters_[Expression],</span> <span class="pre">index:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.common.value.AbstractValue</span></span></dt>
<dd><p>Returns the abstract-valued parameter at <code class="docutils literal notranslate"><span class="pre">index</span></code>. Asserts if the
index is out of bounds.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Parameters_[Expression].get_abstract_parameters(self:</span> <span class="pre">pydrake.systems.framework.Parameters_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.AbstractValues</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Parameters_[Expression].get_mutable_abstract_parameter(self:</span> <span class="pre">pydrake.systems.framework.Parameters_[Expression],</span> <span class="pre">index:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.common.value.AbstractValue</span></span></dt>
<dd><p>Returns the abstract-valued parameter at <code class="docutils literal notranslate"><span class="pre">index</span></code>. Asserts if the
index is out of bounds.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Parameters_[Expression].get_mutable_numeric_parameter(self:</span> <span class="pre">pydrake.systems.framework.Parameters_[Expression],</span> <span class="pre">index:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.BasicVector_[Expression]</span></span></dt>
<dd><p>Returns the vector-valued parameter at <code class="docutils literal notranslate"><span class="pre">index</span></code>. Asserts if the index
is out of bounds.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Parameters_[Expression].get_numeric_parameter(self:</span> <span class="pre">pydrake.systems.framework.Parameters_[Expression],</span> <span class="pre">index:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.BasicVector_[Expression]</span></span></dt>
<dd><p>Returns the vector-valued parameter at <code class="docutils literal notranslate"><span class="pre">index</span></code>. Asserts if the index
is out of bounds.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Parameters_[Expression].get_numeric_parameters(self:</span> <span class="pre">pydrake.systems.framework.Parameters_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.DiscreteValues_[Expression]</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Parameters_[Expression].num_abstract_parameters(self:</span> <span class="pre">pydrake.systems.framework.Parameters_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Parameters_[Expression].num_numeric_parameter_groups(self:</span> <span class="pre">pydrake.systems.framework.Parameters_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Parameters_[Expression].set_abstract_parameters(self:</span> <span class="pre">pydrake.systems.framework.Parameters_[Expression],</span> <span class="pre">abstract_params:</span> <span class="pre">pydrake.systems.framework.AbstractValues)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Parameters_[Expression].set_numeric_parameters(self:</span> <span class="pre">pydrake.systems.framework.Parameters_[Expression],</span> <span class="pre">numeric_params:</span> <span class="pre">pydrake.systems.framework.DiscreteValues_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Parameters_[Expression].SetFrom(self:</span> <span class="pre">pydrake.systems.framework.Parameters_[Expression],</span> <span class="pre">arg0:</span> <span class="pre">pydrake.systems.framework.Parameters)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Initializes this object from <code class="docutils literal notranslate"><span class="pre">other</span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PeriodicEventData</span></span></dt>
<dd><p>An event data variant describing an event that recurs on a fixed
period. The events are triggered at time = offset_sec + i *
period_sec, where i is a non-negative integer.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PeriodicEventData.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PeriodicEventData.offset_sec(self:</span> <span class="pre">pydrake.systems.framework.PeriodicEventData)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Gets the time after zero when this event should first occur.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PeriodicEventData.period_sec(self:</span> <span class="pre">pydrake.systems.framework.PeriodicEventData)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Gets the period with which this event should recur.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PortDataType</span></span></dt>
<dd><p>Members:</p>
<p>kVectorValued</p>
<p>kAbstractValued</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PortDataType.__init__(self:</span> <span class="pre">pydrake.systems.framework.PortDataType,</span> <span class="pre">value:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PortDataType.kAbstractValued</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PortDataType.kVectorValued</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PortDataType.name</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PortDataType.value</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PublishEvent</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.Event</span></code></p>
<p>This class represents a publish event. It has an optional callback
function to do custom handling of this event.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>System::Publish for more details.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>LeafSystem for more convenient interfaces to publish events via
the Declare*PublishEvent() methods.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">PublishEvent_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PublishEvent.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.systems.framework.PublishEvent, callback: Callable[[pydrake.systems.framework.Context, pydrake.systems.framework.PublishEvent], Optional[pydrake.systems.framework.EventStatus]]) -&gt; None</p></li>
</ol>
<p>Constructs a PublishEvent with the given callback function.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.systems.framework.PublishEvent, system_callback: Callable[[drake::systems::System&lt;double&gt;, pydrake.systems.framework.Context, pydrake.systems.framework.PublishEvent], Optional[pydrake.systems.framework.EventStatus]]) -&gt; None</p></li>
</ol>
<p>Constructs a PublishEvent with the given callback function.</p>
<ol class="arabic simple" start="3">
<li><p>__init__(self: pydrake.systems.framework.PublishEvent, trigger_type: pydrake.systems.framework.TriggerType, callback: Callable[[pydrake.systems.framework.Context, pydrake.systems.framework.PublishEvent], Optional[pydrake.systems.framework.EventStatus]]) -&gt; None</p></li>
</ol>
<p>Users should not be calling these</p>
<ol class="arabic simple" start="4">
<li><p>__init__(self: pydrake.systems.framework.PublishEvent, trigger_type: pydrake.systems.framework.TriggerType, system_callback: Callable[[drake::systems::System&lt;double&gt;, pydrake.systems.framework.Context, pydrake.systems.framework.PublishEvent], Optional[pydrake.systems.framework.EventStatus]]) -&gt; None</p></li>
</ol>
<p>Users should not be calling these</p>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PublishEvent_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">PublishEvent_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">PublishEvent_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">PublishEvent_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PublishEvent_[AutoDiffXd]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.Event_[AutoDiffXd]</span></code></p>
<p>This class represents a publish event. It has an optional callback
function to do custom handling of this event.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>System::Publish for more details.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>LeafSystem for more convenient interfaces to publish events via
the Declare*PublishEvent() methods.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PublishEvent_[AutoDiffXd].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.systems.framework.PublishEvent_[AutoDiffXd], callback: Callable[[pydrake.systems.framework.Context_[AutoDiffXd], pydrake.systems.framework.PublishEvent_[AutoDiffXd]], Optional[pydrake.systems.framework.EventStatus]]) -&gt; None</p></li>
</ol>
<p>Constructs a PublishEvent with the given callback function.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.systems.framework.PublishEvent_[AutoDiffXd], system_callback: Callable[[drake::systems::System&lt;Eigen::AutoDiffScalar&lt;Eigen::Matrix&lt;double, -1, 1, 0, -1, 1&gt; &gt; &gt;, pydrake.systems.framework.Context_[AutoDiffXd], pydrake.systems.framework.PublishEvent_[AutoDiffXd]], Optional[pydrake.systems.framework.EventStatus]]) -&gt; None</p></li>
</ol>
<p>Constructs a PublishEvent with the given callback function.</p>
<ol class="arabic simple" start="3">
<li><p>__init__(self: pydrake.systems.framework.PublishEvent_[AutoDiffXd], trigger_type: pydrake.systems.framework.TriggerType, callback: Callable[[pydrake.systems.framework.Context_[AutoDiffXd], pydrake.systems.framework.PublishEvent_[AutoDiffXd]], Optional[pydrake.systems.framework.EventStatus]]) -&gt; None</p></li>
</ol>
<p>Users should not be calling these</p>
<ol class="arabic simple" start="4">
<li><p>__init__(self: pydrake.systems.framework.PublishEvent_[AutoDiffXd], trigger_type: pydrake.systems.framework.TriggerType, system_callback: Callable[[drake::systems::System&lt;Eigen::AutoDiffScalar&lt;Eigen::Matrix&lt;double, -1, 1, 0, -1, 1&gt; &gt; &gt;, pydrake.systems.framework.Context_[AutoDiffXd], pydrake.systems.framework.PublishEvent_[AutoDiffXd]], Optional[pydrake.systems.framework.EventStatus]]) -&gt; None</p></li>
</ol>
<p>Users should not be calling these</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PublishEvent_[Expression]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.Event_[Expression]</span></code></p>
<p>This class represents a publish event. It has an optional callback
function to do custom handling of this event.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>System::Publish for more details.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>LeafSystem for more convenient interfaces to publish events via
the Declare*PublishEvent() methods.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PublishEvent_[Expression].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.systems.framework.PublishEvent_[Expression], callback: Callable[[pydrake.systems.framework.Context_[Expression], pydrake.systems.framework.PublishEvent_[Expression]], Optional[pydrake.systems.framework.EventStatus]]) -&gt; None</p></li>
</ol>
<p>Constructs a PublishEvent with the given callback function.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.systems.framework.PublishEvent_[Expression], system_callback: Callable[[drake::systems::System&lt;drake::symbolic::Expression&gt;, pydrake.systems.framework.Context_[Expression], pydrake.systems.framework.PublishEvent_[Expression]], Optional[pydrake.systems.framework.EventStatus]]) -&gt; None</p></li>
</ol>
<p>Constructs a PublishEvent with the given callback function.</p>
<ol class="arabic simple" start="3">
<li><p>__init__(self: pydrake.systems.framework.PublishEvent_[Expression], trigger_type: pydrake.systems.framework.TriggerType, callback: Callable[[pydrake.systems.framework.Context_[Expression], pydrake.systems.framework.PublishEvent_[Expression]], Optional[pydrake.systems.framework.EventStatus]]) -&gt; None</p></li>
</ol>
<p>Users should not be calling these</p>
<ol class="arabic simple" start="4">
<li><p>__init__(self: pydrake.systems.framework.PublishEvent_[Expression], trigger_type: pydrake.systems.framework.TriggerType, system_callback: Callable[[drake::systems::System&lt;drake::symbolic::Expression&gt;, pydrake.systems.framework.Context_[Expression], pydrake.systems.framework.PublishEvent_[Expression]], Optional[pydrake.systems.framework.EventStatus]]) -&gt; None</p></li>
</ol>
<p>Users should not be calling these</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">State</span></span></dt>
<dd><p>%State is a container for all the data comprising the complete state
of a particular System at a particular moment. Any field in State may
be empty if it is not applicable to the System in question. A System
may not maintain state in any place other than a State object.</p>
<p>A State <code class="docutils literal notranslate"><span class="pre">x</span></code> contains three types of state variables:</p>
<ul class="simple">
<li><p>Continuous state <code class="docutils literal notranslate"><span class="pre">xc</span></code></p></li>
<li><p>Discrete state   <code class="docutils literal notranslate"><span class="pre">xd</span></code></p></li>
<li><p>Abstract state   <code class="docutils literal notranslate"><span class="pre">xa</span></code></p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">State_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">State.__init__(self:</span> <span class="pre">pydrake.systems.framework.State)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">State.get_abstract_state(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>get_abstract_state(self: pydrake.systems.framework.State) -&gt; pydrake.systems.framework.AbstractValues</p></li>
</ol>
<p>Returns a const pointer to the abstract component of the state at
<code class="docutils literal notranslate"><span class="pre">index</span></code>. Asserts if <code class="docutils literal notranslate"><span class="pre">index</span></code> doesn’t exist.</p>
<ol class="arabic simple" start="2">
<li><p>get_abstract_state(self: pydrake.systems.framework.State, index: int) -&gt; pydrake.common.value.AbstractValue</p></li>
</ol>
<p>Returns a const pointer to the abstract component of the state at
<code class="docutils literal notranslate"><span class="pre">index</span></code>. Asserts if <code class="docutils literal notranslate"><span class="pre">index</span></code> doesn’t exist.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">State.get_continuous_state(self:</span> <span class="pre">pydrake.systems.framework.State)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.ContinuousState</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">State.get_discrete_state(self:</span> <span class="pre">pydrake.systems.framework.State)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.DiscreteValues</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">State.get_mutable_abstract_state(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>get_mutable_abstract_state(self: pydrake.systems.framework.State) -&gt; pydrake.systems.framework.AbstractValues</p></li>
</ol>
<p>Returns a mutable reference to the abstract component of the state,
which may be of size zero.</p>
<ol class="arabic simple" start="2">
<li><p>get_mutable_abstract_state(self: pydrake.systems.framework.State, index: int) -&gt; pydrake.common.value.AbstractValue</p></li>
</ol>
<p>Returns a mutable pointer to element <code class="docutils literal notranslate"><span class="pre">index</span></code> of the abstract state.
Asserts if <code class="docutils literal notranslate"><span class="pre">index</span></code> doesn’t exist.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">State.get_mutable_continuous_state(self:</span> <span class="pre">pydrake.systems.framework.State)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.ContinuousState</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">State.get_mutable_discrete_state(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>get_mutable_discrete_state(self: pydrake.systems.framework.State) -&gt; pydrake.systems.framework.DiscreteValues</p></li>
<li><p>get_mutable_discrete_state(self: pydrake.systems.framework.State, index: int) -&gt; pydrake.systems.framework.BasicVector</p></li>
</ol>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">State_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">State_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">State_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">State_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">State_[AutoDiffXd]</span></span></dt>
<dd><p>%State is a container for all the data comprising the complete state
of a particular System at a particular moment. Any field in State may
be empty if it is not applicable to the System in question. A System
may not maintain state in any place other than a State object.</p>
<p>A State <code class="docutils literal notranslate"><span class="pre">x</span></code> contains three types of state variables:</p>
<ul class="simple">
<li><p>Continuous state <code class="docutils literal notranslate"><span class="pre">xc</span></code></p></li>
<li><p>Discrete state   <code class="docutils literal notranslate"><span class="pre">xd</span></code></p></li>
<li><p>Abstract state   <code class="docutils literal notranslate"><span class="pre">xa</span></code></p></li>
</ul>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">State_[AutoDiffXd].__init__(self:</span> <span class="pre">pydrake.systems.framework.State_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">State_[AutoDiffXd].get_abstract_state(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>get_abstract_state(self: pydrake.systems.framework.State_[AutoDiffXd]) -&gt; pydrake.systems.framework.AbstractValues</p></li>
</ol>
<p>Returns a const pointer to the abstract component of the state at
<code class="docutils literal notranslate"><span class="pre">index</span></code>. Asserts if <code class="docutils literal notranslate"><span class="pre">index</span></code> doesn’t exist.</p>
<ol class="arabic simple" start="2">
<li><p>get_abstract_state(self: pydrake.systems.framework.State_[AutoDiffXd], index: int) -&gt; pydrake.common.value.AbstractValue</p></li>
</ol>
<p>Returns a const pointer to the abstract component of the state at
<code class="docutils literal notranslate"><span class="pre">index</span></code>. Asserts if <code class="docutils literal notranslate"><span class="pre">index</span></code> doesn’t exist.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">State_[AutoDiffXd].get_continuous_state(self:</span> <span class="pre">pydrake.systems.framework.State_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.ContinuousState_[AutoDiffXd]</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">State_[AutoDiffXd].get_discrete_state(self:</span> <span class="pre">pydrake.systems.framework.State_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.DiscreteValues_[AutoDiffXd]</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">State_[AutoDiffXd].get_mutable_abstract_state(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>get_mutable_abstract_state(self: pydrake.systems.framework.State_[AutoDiffXd]) -&gt; pydrake.systems.framework.AbstractValues</p></li>
</ol>
<p>Returns a mutable reference to the abstract component of the state,
which may be of size zero.</p>
<ol class="arabic simple" start="2">
<li><p>get_mutable_abstract_state(self: pydrake.systems.framework.State_[AutoDiffXd], index: int) -&gt; pydrake.common.value.AbstractValue</p></li>
</ol>
<p>Returns a mutable pointer to element <code class="docutils literal notranslate"><span class="pre">index</span></code> of the abstract state.
Asserts if <code class="docutils literal notranslate"><span class="pre">index</span></code> doesn’t exist.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">State_[AutoDiffXd].get_mutable_continuous_state(self:</span> <span class="pre">pydrake.systems.framework.State_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.ContinuousState_[AutoDiffXd]</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">State_[AutoDiffXd].get_mutable_discrete_state(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>get_mutable_discrete_state(self: pydrake.systems.framework.State_[AutoDiffXd]) -&gt; pydrake.systems.framework.DiscreteValues_[AutoDiffXd]</p></li>
<li><p>get_mutable_discrete_state(self: pydrake.systems.framework.State_[AutoDiffXd], index: int) -&gt; pydrake.systems.framework.BasicVector_[AutoDiffXd]</p></li>
</ol>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">State_[Expression]</span></span></dt>
<dd><p>%State is a container for all the data comprising the complete state
of a particular System at a particular moment. Any field in State may
be empty if it is not applicable to the System in question. A System
may not maintain state in any place other than a State object.</p>
<p>A State <code class="docutils literal notranslate"><span class="pre">x</span></code> contains three types of state variables:</p>
<ul class="simple">
<li><p>Continuous state <code class="docutils literal notranslate"><span class="pre">xc</span></code></p></li>
<li><p>Discrete state   <code class="docutils literal notranslate"><span class="pre">xd</span></code></p></li>
<li><p>Abstract state   <code class="docutils literal notranslate"><span class="pre">xa</span></code></p></li>
</ul>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">State_[Expression].__init__(self:</span> <span class="pre">pydrake.systems.framework.State_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">State_[Expression].get_abstract_state(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>get_abstract_state(self: pydrake.systems.framework.State_[Expression]) -&gt; pydrake.systems.framework.AbstractValues</p></li>
</ol>
<p>Returns a const pointer to the abstract component of the state at
<code class="docutils literal notranslate"><span class="pre">index</span></code>. Asserts if <code class="docutils literal notranslate"><span class="pre">index</span></code> doesn’t exist.</p>
<ol class="arabic simple" start="2">
<li><p>get_abstract_state(self: pydrake.systems.framework.State_[Expression], index: int) -&gt; pydrake.common.value.AbstractValue</p></li>
</ol>
<p>Returns a const pointer to the abstract component of the state at
<code class="docutils literal notranslate"><span class="pre">index</span></code>. Asserts if <code class="docutils literal notranslate"><span class="pre">index</span></code> doesn’t exist.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">State_[Expression].get_continuous_state(self:</span> <span class="pre">pydrake.systems.framework.State_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.ContinuousState_[Expression]</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">State_[Expression].get_discrete_state(self:</span> <span class="pre">pydrake.systems.framework.State_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.DiscreteValues_[Expression]</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">State_[Expression].get_mutable_abstract_state(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>get_mutable_abstract_state(self: pydrake.systems.framework.State_[Expression]) -&gt; pydrake.systems.framework.AbstractValues</p></li>
</ol>
<p>Returns a mutable reference to the abstract component of the state,
which may be of size zero.</p>
<ol class="arabic simple" start="2">
<li><p>get_mutable_abstract_state(self: pydrake.systems.framework.State_[Expression], index: int) -&gt; pydrake.common.value.AbstractValue</p></li>
</ol>
<p>Returns a mutable pointer to element <code class="docutils literal notranslate"><span class="pre">index</span></code> of the abstract state.
Asserts if <code class="docutils literal notranslate"><span class="pre">index</span></code> doesn’t exist.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">State_[Expression].get_mutable_continuous_state(self:</span> <span class="pre">pydrake.systems.framework.State_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.ContinuousState_[Expression]</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">State_[Expression].get_mutable_discrete_state(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>get_mutable_discrete_state(self: pydrake.systems.framework.State_[Expression]) -&gt; pydrake.systems.framework.DiscreteValues_[Expression]</p></li>
<li><p>get_mutable_discrete_state(self: pydrake.systems.framework.State_[Expression], index: int) -&gt; pydrake.systems.framework.BasicVector_[Expression]</p></li>
</ol>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SubsystemIndex</span></span></dt>
<dd><dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SubsystemIndex.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.systems.framework.SubsystemIndex) -&gt; None</p></li>
</ol>
<p>Default constructor; the result is an <em>invalid</em> index. This only
exists to serve applications which require a default constructor.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.systems.framework.SubsystemIndex, arg0: int) -&gt; None</p></li>
</ol>
<p>Construction from a non-negative <code class="docutils literal notranslate"><span class="pre">int</span></code> value. The value must lie in
the range of [0, 2³¹). Constructor only promises to test validity in
Debug build.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SubsystemIndex.is_valid(self:</span> <span class="pre">pydrake.systems.framework.SubsystemIndex)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Reports if the index is valid–the only operation on an invalid index
that doesn’t throw an exception in Debug builds.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Subvector</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.VectorBase</span></code></p>
<p>Subvector is a concrete class template that implements VectorBase by
providing a sliced view of a VectorBase.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">Subvector_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Subvector.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Subvector_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">Subvector_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Subvector_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Subvector_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Subvector_[AutoDiffXd]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.VectorBase_[AutoDiffXd]</span></code></p>
<p>Subvector is a concrete class template that implements VectorBase by
providing a sliced view of a VectorBase.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Subvector_[AutoDiffXd].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Subvector_[Expression]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.VectorBase_[Expression]</span></code></p>
<p>Subvector is a concrete class template that implements VectorBase by
providing a sliced view of a VectorBase.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Subvector_[Expression].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Supervector</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.VectorBase</span></code></p>
<p>Supervector is a concrete class template that implements VectorBase by
concatenating multiple VectorBases, which it does not own.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">Supervector_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Supervector.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Supervector_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">Supervector_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Supervector_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Supervector_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Supervector_[AutoDiffXd]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.VectorBase_[AutoDiffXd]</span></code></p>
<p>Supervector is a concrete class template that implements VectorBase by
concatenating multiple VectorBases, which it does not own.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Supervector_[AutoDiffXd].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Supervector_[Expression]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.VectorBase_[Expression]</span></code></p>
<p>Supervector is a concrete class template that implements VectorBase by
concatenating multiple VectorBases, which it does not own.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Supervector_[Expression].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.SystemBase</span></code></p>
<p>Base class for all System functionality that is dependent on the
templatized scalar type T for input, state, parameters, and outputs.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">System_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System.Accept(self:</span> <span class="pre">pydrake.systems.framework.System,</span> <span class="pre">v:</span> <span class="pre">pydrake.systems.framework.SystemVisitor)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Implements a visitor pattern.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>SystemVisitor&lt;T&gt;.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System.AllocateContext(self:</span> <span class="pre">pydrake.systems.framework.System)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.Context</span></span></dt>
<dd><p>(Advanced) Returns an <strong>uninitialized</strong> Context&lt;T&gt; suitable for use
with this System&lt;T&gt;. Most users should use CreateDefaultContext(),
instead.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The returned context is uninitialized (contains invalid data). It
is useful for pre-allocating storage which will later be
overwritten (e.g., by SetDefaultContext() or
Context&lt;T&gt;::SetTimeStateAndParametersFrom()) and <strong>must not</strong> be
used for any calculations until it’s been overwritten.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System.AllocateDiscreteVariables(self:</span> <span class="pre">pydrake.systems.framework.System)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.DiscreteValues</span></span></dt>
<dd><p>Returns a DiscreteValues of the same dimensions as the discrete_state
allocated in CreateDefaultContext. The simulator will provide this
state as the output argument to Update.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System.AllocateImplicitTimeDerivativesResidual(self:</span> <span class="pre">pydrake.systems.framework.System)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns an Eigen VectorX suitable for use as the output argument to
the CalcImplicitTimeDerivativesResidual() method. The returned VectorX
will have size implicit_time_derivatives_residual_size() with the
elements uninitialized. This is just a convenience method – you are
free to use any properly-sized mutable Eigen object as the residual
vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System.AllocateInputAbstract(self:</span> <span class="pre">pydrake.systems.framework.System,</span> <span class="pre">input_port:</span> <span class="pre">pydrake.systems.framework.InputPort)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.common.value.AbstractValue</span></span></dt>
<dd><p>Given an input port, allocates the abstract storage. The
<code class="docutils literal notranslate"><span class="pre">input_port</span></code> must match a port declared via DeclareInputPort.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System.AllocateInputVector(self:</span> <span class="pre">pydrake.systems.framework.System,</span> <span class="pre">input_port:</span> <span class="pre">pydrake.systems.framework.InputPort)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.BasicVector</span></span></dt>
<dd><p>Given an input port, allocates the vector storage. The <code class="docutils literal notranslate"><span class="pre">input_port</span></code>
must match a port declared via DeclareInputPort.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System.AllocateOutput(self:</span> <span class="pre">pydrake.systems.framework.System)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.SystemOutput</span></span></dt>
<dd><p>Returns a container that can hold the values of all of this System’s
output ports. It is sized with the number of output ports and uses
each output port’s allocation method to provide an object of the right
type for that port.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System.AllocateTimeDerivatives(self:</span> <span class="pre">pydrake.systems.framework.System)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.ContinuousState</span></span></dt>
<dd><p>Returns a ContinuousState of the same size as the continuous_state
allocated in CreateDefaultContext. The simulator will provide this
state as the output argument to EvalTimeDerivatives.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System.CalcConservativePower(self:</span> <span class="pre">pydrake.systems.framework.System,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Calculates and returns the conservative power represented by the
current contents of the given <code class="docutils literal notranslate"><span class="pre">context</span></code>. Prefer
EvalConservativePower() to avoid unnecessary recalculation.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>EvalConservativePower() for more information.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System.CalcForcedDiscreteVariableUpdate(self:</span> <span class="pre">pydrake.systems.framework.System,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">discrete_state:</span> <span class="pre">pydrake.systems.framework.DiscreteValues)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>(Advanced) Manually triggers any DiscreteUpdateEvent that has trigger
type kForced. Invokes the discrete event dispatcher on this System
with the given Context providing the initial values for the discrete
variables. The updated values of the discrete variables are written to
the <code class="docutils literal notranslate"><span class="pre">discrete_state</span></code> output argument; no change is made to the
Context.</p>
<p>The default dispatcher will invoke the handlers (if any) associated
with each force-triggered event.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>There will always be at least one force-triggered event, though
with no associated handler. By default that will do nothing when
triggered, but that behavior can be changed by overriding the
dispatcher (not recommended).</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if it invokes an event handler that returns status</strong> – </p></li>
<li><p><strong>indicating failure.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcDiscreteVariableUpdate(), CalcForcedUnrestrictedUpdate()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System.CalcForcedUnrestrictedUpdate(self:</span> <span class="pre">pydrake.systems.framework.System,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">state:</span> <span class="pre">pydrake.systems.framework.State)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>(Advanced) Manually triggers any UnrestrictedUpdateEvent that has
trigger type kForced. Invokes the unrestricted event dispatcher on
this System with the given Context providing the initial values for
the state variables. The updated values of the state variables are
written to the <code class="docutils literal notranslate"><span class="pre">state</span></code> output argument; no change is made to the
Context.</p>
<p>The default dispatcher will invoke the handlers (if any) associated
with each force-triggered event.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>There will always be at least one force-triggered event, though
with no associated handler. By default that will do nothing when
triggered, but that behavior can be changed by overriding the
dispatcher (not recommended).</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if it invokes an event handler that returns status</strong> – </p></li>
<li><p><strong>indicating failure.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcUnrestrictedUpdate()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System.CalcImplicitTimeDerivativesResidual(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>CalcImplicitTimeDerivativesResidual(self: pydrake.systems.framework.System, context: pydrake.systems.framework.Context, proposed_derivatives: pydrake.systems.framework.ContinuousState, residual: Optional[numpy.ndarray[numpy.float64[m, 1], flags.writeable]]) -&gt; None</p></li>
</ol>
<p>Evaluates the implicit form of the System equations and returns the
residual.</p>
<p>The explicit and implicit forms of the System equations are</p>
<ol class="arabic simple">
<li><p>ẋ꜀ = fₑ(𝓒) explicit (2) 0 = fᵢ(𝓒; ẋ꜀) implicit</p></li>
</ol>
<p>where <code class="docutils literal notranslate"><span class="pre">𝓒</span> <span class="pre">=</span> <span class="pre">{a,</span> <span class="pre">p,</span> <span class="pre">t,</span> <span class="pre">x,</span> <span class="pre">u}</span></code> is the current value of the given
Context from which accuracy a, parameters p, time t, state x (<code class="docutils literal notranslate"><span class="pre">={x꜀</span>
<span class="pre">xd</span> <span class="pre">xₐ}</span></code>) and input values u are obtained. Substituting (1) into (2)
shows that the following condition must always hold:</p>
<ol class="arabic simple" start="3">
<li><p>fᵢ(𝓒; fₑ(𝓒)) = 0 always true</p></li>
</ol>
<p>When <code class="docutils literal notranslate"><span class="pre">fᵢ(𝓒;</span> <span class="pre">ẋ꜀ₚ)</span></code> is evaluated with a proposed time derivative ẋ꜀ₚ
that differs from ẋ꜀ the result will be non-zero; we call that the
<em>residual</em> of the implicit equation. Given a Context and proposed time
derivative ẋ꜀ₚ, this method returns the residual r such that</p>
<ol class="arabic simple" start="4">
<li><p>r = fᵢ(𝓒; ẋ꜀ₚ).</p></li>
</ol>
<p>The returned r will typically be the same length as x꜀ although that
is not required. And even if r and x꜀ are the same size, there will
not necessarily be any elementwise correspondence between them. (That
is, you should not assume that r[i] is the “residual” of ẋ꜀ₚ[i].) For
a Diagram, r is the concatenation of residuals from each of the
subsystems, in order of subsystem index within the Diagram.</p>
<p>A default implementation fᵢ⁽ᵈᵉᶠ⁾ for the implicit form is always
provided and makes use of the explicit form as follows:</p>
<ol class="arabic simple" start="5">
<li><p>fᵢ⁽ᵈᵉᶠ⁾(𝓒; ẋ꜀ₚ) ≜ ẋ꜀ₚ − fₑ(𝓒)</p></li>
</ol>
<p>which satisfies condition (3) by construction. (Note that the default
implementation requires the residual to have the same size as x꜀.)
Substantial efficiency gains can often be obtained by replacing the
default function with a customized implementation. Override
DoCalcImplicitTimeDerivativesResidual() to replace the default
implementation with a better one.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The source for time, state, inputs, etc. to be used in calculating
the residual.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">proposed_derivatives</span></code>:</dt><dd><p>The proposed value ẋ꜀ₚ for the time derivatives of x꜀.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">residual</span></code>:</dt><dd><p>The result r of evaluating the implicit function. Can be any
mutable Eigen vector object of size
implicit_time_derivatives_residual_size().</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">proposed_derivatives</span></code> is compatible with this System.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">residual</span></code> is of size implicit_time_derivatives_residual_size().</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>SystemBase::implicit_time_derivatives_residual_size()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>LeafSystem::DeclareImplicitTimeDerivativesResidualSize()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DoCalcImplicitTimeDerivativesResidual()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcTimeDerivatives()</p>
</div>
<ol class="arabic simple" start="2">
<li><p>CalcImplicitTimeDerivativesResidual(self: pydrake.systems.framework.System, context: pydrake.systems.framework.Context, proposed_derivatives: pydrake.systems.framework.ContinuousState) -&gt; numpy.ndarray[numpy.float64[m, 1]]</p></li>
</ol>
<p>Evaluates the implicit form of the System equations and returns the
residual.</p>
<p>The explicit and implicit forms of the System equations are</p>
<ol class="arabic simple">
<li><p>ẋ꜀ = fₑ(𝓒) explicit (2) 0 = fᵢ(𝓒; ẋ꜀) implicit</p></li>
</ol>
<p>where <code class="docutils literal notranslate"><span class="pre">𝓒</span> <span class="pre">=</span> <span class="pre">{a,</span> <span class="pre">p,</span> <span class="pre">t,</span> <span class="pre">x,</span> <span class="pre">u}</span></code> is the current value of the given
Context from which accuracy a, parameters p, time t, state x (<code class="docutils literal notranslate"><span class="pre">={x꜀</span>
<span class="pre">xd</span> <span class="pre">xₐ}</span></code>) and input values u are obtained. Substituting (1) into (2)
shows that the following condition must always hold:</p>
<ol class="arabic simple" start="3">
<li><p>fᵢ(𝓒; fₑ(𝓒)) = 0 always true</p></li>
</ol>
<p>When <code class="docutils literal notranslate"><span class="pre">fᵢ(𝓒;</span> <span class="pre">ẋ꜀ₚ)</span></code> is evaluated with a proposed time derivative ẋ꜀ₚ
that differs from ẋ꜀ the result will be non-zero; we call that the
<em>residual</em> of the implicit equation. Given a Context and proposed time
derivative ẋ꜀ₚ, this method returns the residual r such that</p>
<ol class="arabic simple" start="4">
<li><p>r = fᵢ(𝓒; ẋ꜀ₚ).</p></li>
</ol>
<p>The returned r will typically be the same length as x꜀ although that
is not required. And even if r and x꜀ are the same size, there will
not necessarily be any elementwise correspondence between them. (That
is, you should not assume that r[i] is the “residual” of ẋ꜀ₚ[i].) For
a Diagram, r is the concatenation of residuals from each of the
subsystems, in order of subsystem index within the Diagram.</p>
<p>A default implementation fᵢ⁽ᵈᵉᶠ⁾ for the implicit form is always
provided and makes use of the explicit form as follows:</p>
<ol class="arabic simple" start="5">
<li><p>fᵢ⁽ᵈᵉᶠ⁾(𝓒; ẋ꜀ₚ) ≜ ẋ꜀ₚ − fₑ(𝓒)</p></li>
</ol>
<p>which satisfies condition (3) by construction. (Note that the default
implementation requires the residual to have the same size as x꜀.)
Substantial efficiency gains can often be obtained by replacing the
default function with a customized implementation. Override
DoCalcImplicitTimeDerivativesResidual() to replace the default
implementation with a better one.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The source for time, state, inputs, etc. to be used in calculating
the residual.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">proposed_derivatives</span></code>:</dt><dd><p>The proposed value ẋ꜀ₚ for the time derivatives of x꜀.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">residual</span></code>:</dt><dd><p>The result r of evaluating the implicit function. Can be any
mutable Eigen vector object of size
implicit_time_derivatives_residual_size().</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">proposed_derivatives</span></code> is compatible with this System.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">residual</span></code> is of size implicit_time_derivatives_residual_size().</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>SystemBase::implicit_time_derivatives_residual_size()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>LeafSystem::DeclareImplicitTimeDerivativesResidualSize()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DoCalcImplicitTimeDerivativesResidual()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcTimeDerivatives()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System.CalcKineticEnergy(self:</span> <span class="pre">pydrake.systems.framework.System,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Calculates and returns the kinetic energy represented by the current
configuration and velocity provided in <code class="docutils literal notranslate"><span class="pre">context</span></code>. Prefer
EvalKineticEnergy() to avoid unnecessary recalculation.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>EvalKineticEnergy() for more information.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System.CalcNonConservativePower(self:</span> <span class="pre">pydrake.systems.framework.System,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Calculates and returns the non-conservative power represented by the
current contents of the given <code class="docutils literal notranslate"><span class="pre">context</span></code>. Prefer
EvalNonConservativePower() to avoid unnecessary recalculation.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>EvalNonConservativePower() for more information.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System.CalcOutput(self:</span> <span class="pre">pydrake.systems.framework.System,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">outputs:</span> <span class="pre">pydrake.systems.framework.SystemOutput)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Utility method that computes for <em>every</em> output port i the value y(i)
that should result from the current contents of the given Context.
Note that individual output port values can be calculated using
<code class="docutils literal notranslate"><span class="pre">get_output_port(i).Calc()</span></code>; this method invokes that for each
output port in index order. The result may depend on time and the
current values of input ports, parameters, and state variables. The
result is written to <code class="docutils literal notranslate"><span class="pre">outputs</span></code> which must already have been
allocated to have the right number of entries of the right types.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System.CalcPotentialEnergy(self:</span> <span class="pre">pydrake.systems.framework.System,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Calculates and returns the potential energy represented by the current
configuration provided in <code class="docutils literal notranslate"><span class="pre">context</span></code>. Prefer EvalPotentialEnergy() to
avoid unnecessary recalculation.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>EvalPotentialEnergy() for more information.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System.CalcTimeDerivatives(self:</span> <span class="pre">pydrake.systems.framework.System,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">derivatives:</span> <span class="pre">pydrake.systems.framework.ContinuousState)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Calculates the time derivatives ẋ꜀ of the continuous state x꜀ into a
given output argument. Prefer EvalTimeDerivatives() instead to avoid
unnecessary recomputation.</p>
<p>This method solves the System equations in explicit form:</p>
<p>ẋ꜀ = fₑ(𝓒)</p>
<p>where <code class="docutils literal notranslate"><span class="pre">𝓒</span> <span class="pre">=</span> <span class="pre">{a,</span> <span class="pre">p,</span> <span class="pre">t,</span> <span class="pre">x,</span> <span class="pre">u}</span></code> is the current value of the given
Context from which accuracy a, parameters p, time t, state x (<code class="docutils literal notranslate"><span class="pre">={x꜀</span>
<span class="pre">xd</span> <span class="pre">xₐ}</span></code>) and input values u are obtained.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The source for time, state, inputs, etc. defining the point at
which the derivatives should be calculated.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">derivatives</span></code>:</dt><dd><p>The time derivatives ẋ꜀. Must be the same size as the continuous
state vector in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>EvalTimeDerivatives() for more information.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcImplicitTimeDerivativesResidual() for the implicit form of
these equations.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System.Clone(self:</span> <span class="pre">pydrake.systems.framework.System)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.System</span></span></dt>
<dd><p>Creates a deep copy of this system.</p>
<p>Even though the cloned system is functionally identical, any contexts
created for this system are not compatible with the cloned system, and
vice versa.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>Context::SetTimeStateAndParametersFrom() for how to copy context
data between clones.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This implementation is somewhat incomplete at the moment. Many
systems will not be able to be cloned, and will throw an exception
instead. To be cloned, at minimum a system must support scalar
conversion. See system_scalar_conversion.</p>
</div>
<p>The result is never nullptr.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System.CreateDefaultContext(self:</span> <span class="pre">pydrake.systems.framework.System)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.Context</span></span></dt>
<dd><p>This convenience method allocates a context using AllocateContext()
and sets its default values using SetDefaultContext().</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System.DeclareInputPort(self:</span> <span class="pre">pydrake.systems.framework.System,</span> <span class="pre">name:</span> <span class="pre">Union[str,</span> <span class="pre">pydrake.systems.framework.UseDefaultName],</span> <span class="pre">type:</span> <span class="pre">pydrake.systems.framework.PortDataType,</span> <span class="pre">size:</span> <span class="pre">int,</span> <span class="pre">random_type:</span> <span class="pre">Optional[pydrake.common.RandomDistribution]</span> <span class="pre">=</span> <span class="pre">None)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.InputPort</span></span></dt>
<dd><p>Adds a port with the specified <code class="docutils literal notranslate"><span class="pre">type</span></code> and <code class="docutils literal notranslate"><span class="pre">size</span></code> to the input
topology.</p>
<p>Input port names must be unique for this system (passing in a
duplicate <code class="docutils literal notranslate"><span class="pre">name</span></code> will throw RuntimeError). If <code class="docutils literal notranslate"><span class="pre">name</span></code> is given as
kUseDefaultName, then a default value of e.g. “u2”, where 2 is the
input number will be provided. An empty <code class="docutils literal notranslate"><span class="pre">name</span></code> is not permitted.</p>
<p>If the port is intended to model a random noise or disturbance input,
<code class="docutils literal notranslate"><span class="pre">random_type</span></code> can (optionally) be used to label it as such; doing so
enables algorithms for design and analysis (e.g. state estimation) to
reason explicitly about randomness at the system level. All random
input ports are assumed to be statistically independent.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">name</span></code> must not be empty.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError for a duplicate port name.</strong> – </p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>the declared port.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System.EvalAbstractInput(self:</span> <span class="pre">pydrake.systems.framework.System,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">port_index:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.common.value.AbstractValue</span></span></dt>
<dd><p>Returns the value of the input port with the given <code class="docutils literal notranslate"><span class="pre">port_index</span></code> as
an AbstractValue, which is permitted for ports of any type. Causes the
value to become up to date first if necessary, delegating to our
parent Diagram. Returns a pointer to the port’s value, or nullptr if
the port is not connected. If you know the actual type, use one of the
more-specific signatures.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">port_index</span></code> selects an existing input port of this System.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>InputPort::Eval() (preferred)</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System.EvalKineticEnergy(self:</span> <span class="pre">pydrake.systems.framework.System,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns a reference to the cached value of the kinetic energy (KE),
evaluating first if necessary using CalcKineticEnergy().</p>
<p>By definition here, kinetic energy depends only on “configuration” and
“velocity” (e.g. angular and translational velocity) of moving masses
which includes a subset of the state variables, and parameters that
affect configuration, velocities, or mass properties. The calculated
value may also be affected by the accuracy value supplied in the
Context. KE cannot depend explicitly on time (∂KE/∂t = 0) or input
port values (∂KE/∂u = 0).</p>
<p>Non-physical systems where KE is not meaningful will return KE = 0.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The Context whose configuration and velocity variables may be used
to evaluate kinetic energy.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">KE</span></code>:</dt><dd><p>The kinetic energy in joules (J) represented by the configuration
and velocity given in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcKineticEnergy()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System.EvalPotentialEnergy(self:</span> <span class="pre">pydrake.systems.framework.System,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns a reference to the cached value of the potential energy (PE),
evaluating first if necessary using CalcPotentialEnergy().</p>
<p>By definition here, potential energy depends only on “configuration”
(e.g. orientation and position), which includes a subset of the state
variables, and parameters that affect configuration or conservative
forces (such as lengths and masses). The calculated value may also be
affected by the accuracy value supplied in the Context. PE cannot
depend explicitly on time (∂PE/∂t = 0), velocities (∂PE/∂v = 0), or
input port values (∂PE/∂u = 0).</p>
<p>Non-physical systems where PE is not meaningful will return PE = 0.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The Context whose configuration variables may be used to evaluate
potential energy.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">PE</span></code>:</dt><dd><p>The potential energy in joules (J) represented by the
configuration given in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcPotentialEnergy()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System.EvalTimeDerivatives(self:</span> <span class="pre">pydrake.systems.framework.System,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.ContinuousState</span></span></dt>
<dd><p>Returns a reference to the cached value of the continuous state
variable time derivatives, evaluating first if necessary using
CalcTimeDerivatives().</p>
<p>This method returns the time derivatives ẋ꜀ of the continuous state
x꜀. The referenced return object will correspond elementwise with the
continuous state in the given Context. Thus, if the state in the
Context has second-order structure <code class="docutils literal notranslate"><span class="pre">x꜀</span> <span class="pre">=</span> <span class="pre">[q</span> <span class="pre">v</span> <span class="pre">z]</span></code>, that same
structure applies to the derivatives so we will have <code class="docutils literal notranslate"><span class="pre">ẋ꜀</span> <span class="pre">=</span> <span class="pre">[q̇</span> <span class="pre">̇v̇</span>
<span class="pre">ż]</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The Context whose time, input port, parameter, state, and accuracy
values may be used to evaluate the derivatives.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">xcdot</span></code>:</dt><dd><p>Time derivatives ẋ꜀ of x꜀ returned as a reference to an object of
the same type and size as <cite>context</cite>’s continuous state.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>BatchEvalTimeDerivatives() for a batch version of this method.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcTimeDerivatives(), CalcImplicitTimeDerivativesResidual(),
get_time_derivatives_cache_entry()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System.EvalUniquePeriodicDiscreteUpdate(self:</span> <span class="pre">pydrake.systems.framework.System,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.DiscreteValues</span></span></dt>
<dd><p>If this System contains a unique periodic timing for discrete update
events, this function executes the handlers for those periodic events
to determine what their effect would be. Returns a reference to the
discrete variable cache entry containing what values the discrete
variables would have if these periodic events were triggered.</p>
<p>Note that this function <em>does not</em> change the value of the discrete
variables in the supplied Context. However, you can apply the result
to the Context like this:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="n">DiscreteValues</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">updated</span><span class="w"> </span><span class="o">=</span>
<span class="n">system</span><span class="p">.</span><span class="n">EvalUniquePeriodicDiscreteUpdate</span><span class="p">(</span><span class="n">context</span><span class="p">);</span>
<span class="n">context</span><span class="p">.</span><span class="n">SetDiscreteState</span><span class="p">(</span><span class="n">updated</span><span class="p">);</span>
</pre></div>
</div>
</details><p>You can write the updated values to a different Context than the one
you used to calculate the update; the requirement is only that the
discrete state in the destination has the same structure (number of
groups and size of each group).</p>
<p>You can use GetUniquePeriodicDiscreteUpdateAttribute() to check
whether you can call EvalUniquePeriodicDiscreteUpdate() safely, and to
find the unique periodic timing information (offset and period).</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Even if we find a unique discrete update timing as described
above, there may also be unrestricted updates performed with that
timing or other timings. (Unrestricted updates can modify any
state variables <em>including</em> discrete variables.) Also, there may
be trigger types other than periodic that can modify discrete
variables. This function does not attempt to look for any of
those; they are simply ignored. If you are concerned with those,
you can use GetPerStepEvents(), GetInitializationEvents(), and
GetPeriodicEvents() to get a more comprehensive picture of the
event landscape.</p>
</div>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The Context containing the current System state and the mutable
cache space into which the result is written. The current state is
<em>not</em> modified, though the cache entry may be updated.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A reference to the DiscreteValues cache space in <code class="docutils literal notranslate"><span class="pre">context</span></code>
containing the result of applying the discrete update event
handlers to the current discrete variable values.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The referenced cache entry is recalculated if anything in the
given Context has changed since last calculation. Subsequent calls
just return the already-calculated value.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if there is not exactly one periodic timing in this</strong> – </p></li>
<li><p><strong>System</strong><strong> (</strong><strong>which may be a Diagram</strong><strong>) </strong><strong>that triggers discrete update</strong> – </p></li>
<li><p><strong>events.</strong> – </p></li>
<li><p><strong>RuntimeError if it invokes an event handler that returns status</strong> – </p></li>
<li><p><strong>indicating failure.</strong> – </p></li>
</ul>
</dd>
</dl>
<p>&#64;par Implementation If recalculation is needed, copies the current
discrete state values into preallocated <code class="docutils literal notranslate"><span class="pre">context</span></code> cache space.
Applies the discrete update event handlers (in an unspecified order)
to the cache copy, possibly updating it. Returns a reference to the
possibly-updated cache space.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>BatchEvalUniquePeriodicDiscreteUpdate() for a batch version of
this method.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>GetUniquePeriodicDiscreteUpdateAttribute(), GetPeriodicEvents()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System.EvalVectorInput(self:</span> <span class="pre">pydrake.systems.framework.System,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">port_index:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.BasicVector</span></span></dt>
<dd><p>Returns the value of the vector-valued input port with the given
<code class="docutils literal notranslate"><span class="pre">port_index</span></code> as a BasicVector or a specific subclass <code class="docutils literal notranslate"><span class="pre">Vec</span></code> derived
from BasicVector. Causes the value to become up to date first if
necessary. See EvalAbstractInput() for more information.</p>
<p>The result is returned as a pointer to the input port’s value of type
<code class="docutils literal notranslate"><span class="pre">Vec&lt;T&gt;</span></code> or nullptr if the port is not connected.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">port_index</span></code> selects an existing input port of this System.</p>
</dd>
<dt>Precondition:</dt><dd><p>the port must have been declared to be vector-valued.</p>
</dd>
<dt>Precondition:</dt><dd><p>the port’s value must be of type Vec&lt;T&gt;.</p>
</dd>
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">Vec</span></code>:</dt><dd><p>The template type of the input vector, which must be a subclass of
BasicVector.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System.ExecuteForcedEvents(self:</span> <span class="pre">pydrake.systems.framework.System,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">publish:</span> <span class="pre">bool</span> <span class="pre">=</span> <span class="pre">True)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>This method triggers all of the forced events registered with this
System (which might be a Diagram). Ordering and status return handling
mimic the Simulator: unrestricted events are processed first, then
discrete update events, then publish events. “Reached termination”
status returns are ignored.</p>
<p>An option is provided to suppress publish events. This can be useful,
for example, to update state in a Diagram without triggering a
visualization.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The Context supplied to the handlers and modified in place on
return.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if it invokes an event handler that returns status</strong> – </p></li>
<li><p><strong>indicating failure.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System.ExecuteInitializationEvents(self:</span> <span class="pre">pydrake.systems.framework.System,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>This method triggers all of the initialization events returned by
GetInitializationEvents(). The method allocates temporary storage to
perform the updates, and is intended only as a convenience method for
callers who do not want to use the full Simulator workflow.</p>
<p>Note that this is not fully equivalent to Simulator::Initialize()
because <em>only</em> initialization events are handled here, while
Simulator::Initialize() also processes other events associated with
time zero. Also, “reached termination” returns are ignored here.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The Context supplied to the handlers and modified in place on
return.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if it invokes an event handler that returns status</strong> – </p></li>
<li><p><strong>indicating failure.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System.FixInputPortsFrom(self:</span> <span class="pre">pydrake.systems.framework.System,</span> <span class="pre">other_system:</span> <span class="pre">pydrake.systems.framework.System,</span> <span class="pre">other_context:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">target_context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Fixes all of the input ports in <code class="docutils literal notranslate"><span class="pre">target_context</span></code> to their current
values in <code class="docutils literal notranslate"><span class="pre">other_context</span></code>, as evaluated by <code class="docutils literal notranslate"><span class="pre">other_system</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError unless other_context and target_context both</strong> – </p></li>
<li><p><strong>have the same shape as this System</strong><strong>, </strong><strong>and the other_system.</strong> – </p></li>
<li><p><strong>Ignores disconnected inputs.</strong> – </p></li>
<li><p><strong>RuntimeError if this system's scalar type T != double and</strong> – </p></li>
<li><p><strong>other_system` has any abstract input ports whose contained typ</strong> – </p></li>
<li><p><strong>depends on scalar type.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System.ForcedPublish(self:</span> <span class="pre">pydrake.systems.framework.System,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>(Advanced) Manually triggers any PublishEvent that has trigger type
kForced. Invokes the publish event dispatcher on this System with the
given Context.</p>
<p>The default dispatcher will invoke the handlers (if any) associated
with each force-triggered event.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>There will always be at least one force-triggered event, though
with no associated handler (so will do nothing when triggered).</p>
</div>
<p>The Simulator can be configured to call this in
Simulator::Initialize() and at the start of each continuous
integration step. See the Simulator API for more details.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if it invokes an event handler that returns status</strong> – </p></li>
<li><p><strong>indicating failure.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>Publish(), CalcForcedDiscreteVariableUpdate(),
CalcForcedUnrestrictedUpdate()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System.get_input_port(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>get_input_port(self: pydrake.systems.framework.System, port_index: int, warn_deprecated: bool = True) -&gt; pydrake.systems.framework.InputPort</p></li>
</ol>
<p>Returns the typed input port at index <code class="docutils literal notranslate"><span class="pre">port_index</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">warn_deprecated</span></code>:</dt><dd><p>Whether or not to print a warning in case the port was marked as
deprecated.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>get_input_port(self: pydrake.systems.framework.System) -&gt; pydrake.systems.framework.InputPort</p></li>
</ol>
<p>Convenience method for the case of exactly one input port. This
function ignores deprecated ports, unless there is only one port in
which case it will return the deprecated port.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System.get_output_port(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>get_output_port(self: pydrake.systems.framework.System, port_index: int, warn_deprecated: bool = True) -&gt; pydrake.systems.framework.OutputPort</p></li>
</ol>
<p>Returns the typed output port at index <code class="docutils literal notranslate"><span class="pre">port_index</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">warn_deprecated</span></code>:</dt><dd><p>Whether or not to print a warning in case the port was marked as
deprecated.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>get_output_port(self: pydrake.systems.framework.System) -&gt; pydrake.systems.framework.OutputPort</p></li>
</ol>
<p>Convenience method for the case of exactly one output port. This
function ignores deprecated ports, unless there is only one port in
which case it will return the deprecated port.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System.get_system_scalar_converter(self:</span> <span class="pre">pydrake.systems.framework.System)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.SystemScalarConverter</span></span></dt>
<dd><p>(Advanced) Returns the SystemScalarConverter for this object. This is
an expert-level API intended for framework authors. Most users should
prefer the convenience helpers such as System::ToAutoDiffXd.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System.GetInputPort(self:</span> <span class="pre">pydrake.systems.framework.System,</span> <span class="pre">port_name:</span> <span class="pre">str)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.InputPort</span></span></dt>
<dd><p>Returns the typed input port with the unique name <code class="docutils literal notranslate"><span class="pre">port_name</span></code>. The
current implementation performs a linear search over strings; prefer
get_input_port() when performance is a concern.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if port_name is not found.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System.GetMutableSubsystemContext(self:</span> <span class="pre">pydrake.systems.framework.System,</span> <span class="pre">subsystem:</span> <span class="pre">pydrake.systems.framework.System,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.Context</span></span></dt>
<dd><p>Returns a mutable reference to the subcontext that corresponds to the
contained System <code class="docutils literal notranslate"><span class="pre">subsystem</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if subsystem not contained in this System.</strong> – </p>
</dd>
</dl>
<dl class="simple">
<dt>Precondition:</dt><dd><p>The given <code class="docutils literal notranslate"><span class="pre">context</span></code> is valid for use with <code class="docutils literal notranslate"><span class="pre">this</span></code> System.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System.GetMyContextFromRoot(self:</span> <span class="pre">pydrake.systems.framework.System,</span> <span class="pre">root_context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.Context</span></span></dt>
<dd><p>Returns the mutable subsystem context for <code class="docutils literal notranslate"><span class="pre">this</span></code> system, given a
root context.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>GetMyContextFromRoot()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System.GetMyMutableContextFromRoot(self:</span> <span class="pre">pydrake.systems.framework.System,</span> <span class="pre">root_context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.Context</span></span></dt>
<dd><p>Returns the mutable subsystem context for <code class="docutils literal notranslate"><span class="pre">this</span></code> system, given a
root context.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>GetMyContextFromRoot()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System.GetOutputPort(self:</span> <span class="pre">pydrake.systems.framework.System,</span> <span class="pre">port_name:</span> <span class="pre">str)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.OutputPort</span></span></dt>
<dd><p>Returns the typed output port with the unique name <code class="docutils literal notranslate"><span class="pre">port_name</span></code>. The
current implementation performs a linear search over strings; prefer
get_output_port() when performance is a concern.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if port_name is not found.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System.GetSubsystemContext(self:</span> <span class="pre">pydrake.systems.framework.System,</span> <span class="pre">subsystem:</span> <span class="pre">pydrake.systems.framework.System,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.Context</span></span></dt>
<dd><p>Returns a mutable reference to the subcontext that corresponds to the
contained System <code class="docutils literal notranslate"><span class="pre">subsystem</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if subsystem not contained in this System.</strong> – </p>
</dd>
</dl>
<dl class="simple">
<dt>Precondition:</dt><dd><p>The given <code class="docutils literal notranslate"><span class="pre">context</span></code> is valid for use with <code class="docutils literal notranslate"><span class="pre">this</span></code> System.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System.GetUniquePeriodicDiscreteUpdateAttribute(self:</span> <span class="pre">pydrake.systems.framework.System)</span> <span class="pre">-&gt;</span> <span class="pre">Optional[pydrake.systems.framework.PeriodicEventData]</span></span></dt>
<dd><p>Determines whether there exists a unique periodic timing (offset and
period) that triggers one or more discrete update events (and, if so,
returns that unique periodic timing). Thus, this method can be used
(1) as a test to determine whether a system’s dynamics are at least
partially governed by difference equations, and (2) to obtain the
difference equation update times. Use
EvalUniquePeriodicDiscreteUpdate() if you want to determine the actual
effects of triggering these events.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Even if we find a unique discrete update timing as described
above, there may also be unrestricted updates performed with that
timing or other timings. (Unrestricted updates can modify any
state variables <em>including</em> discrete variables.) Also, there may
be trigger types other than periodic that can modify discrete
variables. This function does not attempt to look for any of
those; they are simply ignored. If you are concerned with those,
you can use GetPerStepEvents(), GetInitializationEvents(), and
GetPeriodicEvents() to get a more comprehensive picture of the
event landscape.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>optional&lt;PeriodicEventData&gt; Contains the unique periodic trigger
timing if it exists, otherwise <code class="docutils literal notranslate"><span class="pre">nullopt</span></code>.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>EvalUniquePeriodicDiscreteUpdate(), IsDifferenceEquationSystem()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System.GetWitnessFunctions(self:</span> <span class="pre">pydrake.systems.framework.System,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">list[pydrake.systems.framework.WitnessFunction]</span></span></dt>
<dd><p>Derived classes can override this method to provide witness functions
active for the given state. The default implementation does nothing.
On entry to this function, the context will have already been
validated and the vector of witness functions will have been validated
to be both empty and non-null.
Note: The above is for the C++ documentation. For Python, use
<cite>witnesses = GetWitnessFunctions(context)</cite></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System.HasAnyDirectFeedthrough(self:</span> <span class="pre">pydrake.systems.framework.System)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if any of the inputs to the system might be directly
fed through to any of its outputs and <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System.HasDirectFeedthrough(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>HasDirectFeedthrough(self: pydrake.systems.framework.System, output_port: int) -&gt; bool</p></li>
</ol>
<p>Returns true if there might be direct-feedthrough from any input port
to the given <code class="docutils literal notranslate"><span class="pre">output_port</span></code>, and false otherwise.</p>
<ol class="arabic simple" start="2">
<li><p>HasDirectFeedthrough(self: pydrake.systems.framework.System, input_port: int, output_port: int) -&gt; bool</p></li>
</ol>
<p>Returns true if there might be direct-feedthrough from the given
<code class="docutils literal notranslate"><span class="pre">input_port</span></code> to the given <code class="docutils literal notranslate"><span class="pre">output_port</span></code>, and false otherwise.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System.HasInputPort(self:</span> <span class="pre">pydrake.systems.framework.System,</span> <span class="pre">port_name:</span> <span class="pre">str)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns true iff the system has an InputPort of the given
<code class="docutils literal notranslate"><span class="pre">port_name</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System.HasOutputPort(self:</span> <span class="pre">pydrake.systems.framework.System,</span> <span class="pre">port_name:</span> <span class="pre">str)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns true iff the system has an OutputPort of the given
<code class="docutils literal notranslate"><span class="pre">port_name</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System.IsDifferenceEquationSystem(self:</span> <span class="pre">pydrake.systems.framework.System)</span> <span class="pre">-&gt;</span> <span class="pre">tuple[bool,</span> <span class="pre">float]</span></span></dt>
<dd><p>Returns true iff the state dynamics of this system are governed
exclusively by a difference equation on a single discrete state group
and with a unique periodic update (having zero offset). E.g., it is
amenable to analysis of the form:</p>
<p>x[n+1] = f(n, x[n], u[n], w[n]; p)</p>
<p>where t is time, x is (discrete) state, u is a vector input, w is
random (disturbance) input, and p are parameters. Note that we do NOT
consider the number of input ports here, because in practice many
systems of interest (e.g. MultibodyPlant) have input ports that are
safely treated as constant during the analysis. Consider using
get_input_port_selection() to choose one.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>In determining whether this system is governed as above, we do not
consider unrestricted updates nor any update events that have
trigger types other than periodic. See
GetUniquePeriodicDiscreteUpdateAttribute() for more information.</p>
</div>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">time_period</span></code>:</dt><dd><p>if non-null, then iff the function returns <code class="docutils literal notranslate"><span class="pre">True</span></code>, then
time_period is set to the period data returned from
GetUniquePeriodicDiscreteUpdateAttribute(). If the function
returns <code class="docutils literal notranslate"><span class="pre">False</span></code> (the system is not a difference equation
system), then <code class="docutils literal notranslate"><span class="pre">time_period</span></code> does not receive a value.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>GetUniquePeriodicDiscreteUpdateAttribute()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>EvalUniquePeriodicDiscreteUpdate()</p>
</div>
<p>Note: The above is for the C++ documentation. For Python, use
<cite>is_diff_eq, period = IsDifferenceEquationSystem()</cite></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System.IsDifferentialEquationSystem(self:</span> <span class="pre">pydrake.systems.framework.System)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns true iff the state dynamics of this system are governed
exclusively by a differential equation. E.g., it is amenable to
analysis of the form:</p>
<p>ẋ = f(t, x(t), u(t), w(t); p),</p>
<p>where t is time, x is (continuous) state, u is a vector input, w is
random (disturbance) input, and p are parameters. This requires that
it has no discrete nor abstract states, and no abstract input ports.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>In determining whether this system is governed as above, we do not
consider unrestricted updates which could potentially update the
state.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System.num_constraints(self:</span> <span class="pre">pydrake.systems.framework.System)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the number of constraints specified for the system.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System.SetDefaultContext(self:</span> <span class="pre">pydrake.systems.framework.System,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets Context fields to their default values. User code should not
override.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System.SetRandomContext(self:</span> <span class="pre">pydrake.systems.framework.System,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">generator:</span> <span class="pre">pydrake.common.RandomGenerator)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets Context fields to random values. User code should not override.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System.ToAutoDiffXd(self:</span> <span class="pre">pydrake.systems.framework.System)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.System_[AutoDiffXd]</span></span></dt>
<dd><p>Creates a deep copy of this System, transmogrified to use the autodiff
scalar type, with a dynamic-sized vector of partial derivatives. The
result is never nullptr.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if this System does not support autodiff</strong> – </p>
</dd>
</dl>
<p>See system_scalar_conversion for detailed background and examples
related to scalar-type conversion support.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System.ToAutoDiffXdMaybe(self:</span> <span class="pre">pydrake.systems.framework.System)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.System_[AutoDiffXd]</span></span></dt>
<dd><p>Creates a deep copy of this system exactly like ToAutoDiffXd(), but
returns nullptr if this System does not support autodiff, instead of
throwing an exception.</p>
</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System.ToScalarType</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">ToScalarType[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ToScalarType[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ToScalarType[Expression]</span></code></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System.ToScalarType[AutoDiffXd](self:</span> <span class="pre">pydrake.systems.framework.System)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.System_[AutoDiffXd]</span></span></dt>
<dd><p>Creates a deep copy of this System, transmogrified to use the scalar
type selected by a template parameter. The result is never nullptr.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if this System does not support the destination type.</strong> – </p>
</dd>
</dl>
<dl class="simple">
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">U</span></code>:</dt><dd><p>The destination scalar type. For a list of supported types, see
the default_scalars “default scalars”.</p>
</dd>
</dl>
<p>See system_scalar_conversion for detailed background and examples
related to scalar-type conversion support.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System.ToScalarType[Expression](self:</span> <span class="pre">pydrake.systems.framework.System)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.System_[Expression]</span></span></dt>
<dd><p>Creates a deep copy of this System, transmogrified to use the scalar
type selected by a template parameter. The result is never nullptr.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if this System does not support the destination type.</strong> – </p>
</dd>
</dl>
<dl class="simple">
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">U</span></code>:</dt><dd><p>The destination scalar type. For a list of supported types, see
the default_scalars “default scalars”.</p>
</dd>
</dl>
<p>See system_scalar_conversion for detailed background and examples
related to scalar-type conversion support.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System.ToScalarType[float](self:</span> <span class="pre">pydrake.systems.framework.System)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.System</span></span></dt>
<dd><p>Creates a deep copy of this System, transmogrified to use the scalar
type selected by a template parameter. The result is never nullptr.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if this System does not support the destination type.</strong> – </p>
</dd>
</dl>
<dl class="simple">
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">U</span></code>:</dt><dd><p>The destination scalar type. For a list of supported types, see
the default_scalars “default scalars”.</p>
</dd>
</dl>
<p>See system_scalar_conversion for detailed background and examples
related to scalar-type conversion support.</p>
</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System.ToScalarTypeMaybe</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">ToScalarTypeMaybe[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ToScalarTypeMaybe[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ToScalarTypeMaybe[Expression]</span></code></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System.ToScalarTypeMaybe[AutoDiffXd](self:</span> <span class="pre">pydrake.systems.framework.System)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.System_[AutoDiffXd]</span></span></dt>
<dd><p>Creates a deep copy of this system exactly like ToScalarType(), but
returns nullptr if this System does not support the destination type,
instead of throwing an exception.</p>
<dl class="simple">
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">U</span></code>:</dt><dd><p>The destination scalar type. For a list of supported types, see
the default_scalars “default scalars”.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System.ToScalarTypeMaybe[Expression](self:</span> <span class="pre">pydrake.systems.framework.System)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.System_[Expression]</span></span></dt>
<dd><p>Creates a deep copy of this system exactly like ToScalarType(), but
returns nullptr if this System does not support the destination type,
instead of throwing an exception.</p>
<dl class="simple">
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">U</span></code>:</dt><dd><p>The destination scalar type. For a list of supported types, see
the default_scalars “default scalars”.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System.ToScalarTypeMaybe[float](self:</span> <span class="pre">pydrake.systems.framework.System)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.System</span></span></dt>
<dd><p>Creates a deep copy of this system exactly like ToScalarType(), but
returns nullptr if this System does not support the destination type,
instead of throwing an exception.</p>
<dl class="simple">
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">U</span></code>:</dt><dd><p>The destination scalar type. For a list of supported types, see
the default_scalars “default scalars”.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System.ToSymbolic(self:</span> <span class="pre">pydrake.systems.framework.System)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.System_[Expression]</span></span></dt>
<dd><p>Creates a deep copy of this System, transmogrified to use the symbolic
scalar type. The result is never nullptr.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if this System does not support symbolic</strong> – </p>
</dd>
</dl>
<p>See system_scalar_conversion for detailed background and examples
related to scalar-type conversion support.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System.ToSymbolicMaybe(self:</span> <span class="pre">pydrake.systems.framework.System)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.System_[Expression]</span></span></dt>
<dd><p>Creates a deep copy of this system exactly like ToSymbolic(), but
returns nullptr if this System does not support symbolic, instead of
throwing an exception.</p>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">System_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">System_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">System_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[AutoDiffXd]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.SystemBase</span></code></p>
<p>Base class for all System functionality that is dependent on the
templatized scalar type T for input, state, parameters, and outputs.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[AutoDiffXd].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[AutoDiffXd].Accept(self:</span> <span class="pre">pydrake.systems.framework.System_[AutoDiffXd],</span> <span class="pre">v:</span> <span class="pre">pydrake.systems.framework.SystemVisitor_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Implements a visitor pattern.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>SystemVisitor&lt;T&gt;.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[AutoDiffXd].AllocateContext(self:</span> <span class="pre">pydrake.systems.framework.System_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd]</span></span></dt>
<dd><p>(Advanced) Returns an <strong>uninitialized</strong> Context&lt;T&gt; suitable for use
with this System&lt;T&gt;. Most users should use CreateDefaultContext(),
instead.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The returned context is uninitialized (contains invalid data). It
is useful for pre-allocating storage which will later be
overwritten (e.g., by SetDefaultContext() or
Context&lt;T&gt;::SetTimeStateAndParametersFrom()) and <strong>must not</strong> be
used for any calculations until it’s been overwritten.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[AutoDiffXd].AllocateDiscreteVariables(self:</span> <span class="pre">pydrake.systems.framework.System_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.DiscreteValues_[AutoDiffXd]</span></span></dt>
<dd><p>Returns a DiscreteValues of the same dimensions as the discrete_state
allocated in CreateDefaultContext. The simulator will provide this
state as the output argument to Update.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[AutoDiffXd].AllocateImplicitTimeDerivativesResidual(self:</span> <span class="pre">pydrake.systems.framework.System_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns an Eigen VectorX suitable for use as the output argument to
the CalcImplicitTimeDerivativesResidual() method. The returned VectorX
will have size implicit_time_derivatives_residual_size() with the
elements uninitialized. This is just a convenience method – you are
free to use any properly-sized mutable Eigen object as the residual
vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[AutoDiffXd].AllocateInputAbstract(self:</span> <span class="pre">pydrake.systems.framework.System_[AutoDiffXd],</span> <span class="pre">input_port:</span> <span class="pre">pydrake.systems.framework.InputPort_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.common.value.AbstractValue</span></span></dt>
<dd><p>Given an input port, allocates the abstract storage. The
<code class="docutils literal notranslate"><span class="pre">input_port</span></code> must match a port declared via DeclareInputPort.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[AutoDiffXd].AllocateInputVector(self:</span> <span class="pre">pydrake.systems.framework.System_[AutoDiffXd],</span> <span class="pre">input_port:</span> <span class="pre">pydrake.systems.framework.InputPort_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.BasicVector_[AutoDiffXd]</span></span></dt>
<dd><p>Given an input port, allocates the vector storage. The <code class="docutils literal notranslate"><span class="pre">input_port</span></code>
must match a port declared via DeclareInputPort.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[AutoDiffXd].AllocateOutput(self:</span> <span class="pre">pydrake.systems.framework.System_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.SystemOutput_[AutoDiffXd]</span></span></dt>
<dd><p>Returns a container that can hold the values of all of this System’s
output ports. It is sized with the number of output ports and uses
each output port’s allocation method to provide an object of the right
type for that port.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[AutoDiffXd].AllocateTimeDerivatives(self:</span> <span class="pre">pydrake.systems.framework.System_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.ContinuousState_[AutoDiffXd]</span></span></dt>
<dd><p>Returns a ContinuousState of the same size as the continuous_state
allocated in CreateDefaultContext. The simulator will provide this
state as the output argument to EvalTimeDerivatives.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[AutoDiffXd].CalcConservativePower(self:</span> <span class="pre">pydrake.systems.framework.System_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd</span></span></dt>
<dd><p>Calculates and returns the conservative power represented by the
current contents of the given <code class="docutils literal notranslate"><span class="pre">context</span></code>. Prefer
EvalConservativePower() to avoid unnecessary recalculation.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>EvalConservativePower() for more information.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[AutoDiffXd].CalcForcedDiscreteVariableUpdate(self:</span> <span class="pre">pydrake.systems.framework.System_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd],</span> <span class="pre">discrete_state:</span> <span class="pre">pydrake.systems.framework.DiscreteValues_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>(Advanced) Manually triggers any DiscreteUpdateEvent that has trigger
type kForced. Invokes the discrete event dispatcher on this System
with the given Context providing the initial values for the discrete
variables. The updated values of the discrete variables are written to
the <code class="docutils literal notranslate"><span class="pre">discrete_state</span></code> output argument; no change is made to the
Context.</p>
<p>The default dispatcher will invoke the handlers (if any) associated
with each force-triggered event.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>There will always be at least one force-triggered event, though
with no associated handler. By default that will do nothing when
triggered, but that behavior can be changed by overriding the
dispatcher (not recommended).</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if it invokes an event handler that returns status</strong> – </p></li>
<li><p><strong>indicating failure.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcDiscreteVariableUpdate(), CalcForcedUnrestrictedUpdate()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[AutoDiffXd].CalcForcedUnrestrictedUpdate(self:</span> <span class="pre">pydrake.systems.framework.System_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd],</span> <span class="pre">state:</span> <span class="pre">pydrake.systems.framework.State_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>(Advanced) Manually triggers any UnrestrictedUpdateEvent that has
trigger type kForced. Invokes the unrestricted event dispatcher on
this System with the given Context providing the initial values for
the state variables. The updated values of the state variables are
written to the <code class="docutils literal notranslate"><span class="pre">state</span></code> output argument; no change is made to the
Context.</p>
<p>The default dispatcher will invoke the handlers (if any) associated
with each force-triggered event.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>There will always be at least one force-triggered event, though
with no associated handler. By default that will do nothing when
triggered, but that behavior can be changed by overriding the
dispatcher (not recommended).</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if it invokes an event handler that returns status</strong> – </p></li>
<li><p><strong>indicating failure.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcUnrestrictedUpdate()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[AutoDiffXd].CalcImplicitTimeDerivativesResidual(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>CalcImplicitTimeDerivativesResidual(self: pydrake.systems.framework.System_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], proposed_derivatives: pydrake.systems.framework.ContinuousState_[AutoDiffXd], residual: Optional[numpy.ndarray[object[m, 1], flags.writeable]]) -&gt; None</p></li>
</ol>
<p>Evaluates the implicit form of the System equations and returns the
residual.</p>
<p>The explicit and implicit forms of the System equations are</p>
<ol class="arabic simple">
<li><p>ẋ꜀ = fₑ(𝓒) explicit (2) 0 = fᵢ(𝓒; ẋ꜀) implicit</p></li>
</ol>
<p>where <code class="docutils literal notranslate"><span class="pre">𝓒</span> <span class="pre">=</span> <span class="pre">{a,</span> <span class="pre">p,</span> <span class="pre">t,</span> <span class="pre">x,</span> <span class="pre">u}</span></code> is the current value of the given
Context from which accuracy a, parameters p, time t, state x (<code class="docutils literal notranslate"><span class="pre">={x꜀</span>
<span class="pre">xd</span> <span class="pre">xₐ}</span></code>) and input values u are obtained. Substituting (1) into (2)
shows that the following condition must always hold:</p>
<ol class="arabic simple" start="3">
<li><p>fᵢ(𝓒; fₑ(𝓒)) = 0 always true</p></li>
</ol>
<p>When <code class="docutils literal notranslate"><span class="pre">fᵢ(𝓒;</span> <span class="pre">ẋ꜀ₚ)</span></code> is evaluated with a proposed time derivative ẋ꜀ₚ
that differs from ẋ꜀ the result will be non-zero; we call that the
<em>residual</em> of the implicit equation. Given a Context and proposed time
derivative ẋ꜀ₚ, this method returns the residual r such that</p>
<ol class="arabic simple" start="4">
<li><p>r = fᵢ(𝓒; ẋ꜀ₚ).</p></li>
</ol>
<p>The returned r will typically be the same length as x꜀ although that
is not required. And even if r and x꜀ are the same size, there will
not necessarily be any elementwise correspondence between them. (That
is, you should not assume that r[i] is the “residual” of ẋ꜀ₚ[i].) For
a Diagram, r is the concatenation of residuals from each of the
subsystems, in order of subsystem index within the Diagram.</p>
<p>A default implementation fᵢ⁽ᵈᵉᶠ⁾ for the implicit form is always
provided and makes use of the explicit form as follows:</p>
<ol class="arabic simple" start="5">
<li><p>fᵢ⁽ᵈᵉᶠ⁾(𝓒; ẋ꜀ₚ) ≜ ẋ꜀ₚ − fₑ(𝓒)</p></li>
</ol>
<p>which satisfies condition (3) by construction. (Note that the default
implementation requires the residual to have the same size as x꜀.)
Substantial efficiency gains can often be obtained by replacing the
default function with a customized implementation. Override
DoCalcImplicitTimeDerivativesResidual() to replace the default
implementation with a better one.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The source for time, state, inputs, etc. to be used in calculating
the residual.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">proposed_derivatives</span></code>:</dt><dd><p>The proposed value ẋ꜀ₚ for the time derivatives of x꜀.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">residual</span></code>:</dt><dd><p>The result r of evaluating the implicit function. Can be any
mutable Eigen vector object of size
implicit_time_derivatives_residual_size().</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">proposed_derivatives</span></code> is compatible with this System.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">residual</span></code> is of size implicit_time_derivatives_residual_size().</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>SystemBase::implicit_time_derivatives_residual_size()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>LeafSystem::DeclareImplicitTimeDerivativesResidualSize()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DoCalcImplicitTimeDerivativesResidual()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcTimeDerivatives()</p>
</div>
<ol class="arabic simple" start="2">
<li><p>CalcImplicitTimeDerivativesResidual(self: pydrake.systems.framework.System_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], proposed_derivatives: pydrake.systems.framework.ContinuousState_[AutoDiffXd]) -&gt; numpy.ndarray[object[m, 1]]</p></li>
</ol>
<p>Evaluates the implicit form of the System equations and returns the
residual.</p>
<p>The explicit and implicit forms of the System equations are</p>
<ol class="arabic simple">
<li><p>ẋ꜀ = fₑ(𝓒) explicit (2) 0 = fᵢ(𝓒; ẋ꜀) implicit</p></li>
</ol>
<p>where <code class="docutils literal notranslate"><span class="pre">𝓒</span> <span class="pre">=</span> <span class="pre">{a,</span> <span class="pre">p,</span> <span class="pre">t,</span> <span class="pre">x,</span> <span class="pre">u}</span></code> is the current value of the given
Context from which accuracy a, parameters p, time t, state x (<code class="docutils literal notranslate"><span class="pre">={x꜀</span>
<span class="pre">xd</span> <span class="pre">xₐ}</span></code>) and input values u are obtained. Substituting (1) into (2)
shows that the following condition must always hold:</p>
<ol class="arabic simple" start="3">
<li><p>fᵢ(𝓒; fₑ(𝓒)) = 0 always true</p></li>
</ol>
<p>When <code class="docutils literal notranslate"><span class="pre">fᵢ(𝓒;</span> <span class="pre">ẋ꜀ₚ)</span></code> is evaluated with a proposed time derivative ẋ꜀ₚ
that differs from ẋ꜀ the result will be non-zero; we call that the
<em>residual</em> of the implicit equation. Given a Context and proposed time
derivative ẋ꜀ₚ, this method returns the residual r such that</p>
<ol class="arabic simple" start="4">
<li><p>r = fᵢ(𝓒; ẋ꜀ₚ).</p></li>
</ol>
<p>The returned r will typically be the same length as x꜀ although that
is not required. And even if r and x꜀ are the same size, there will
not necessarily be any elementwise correspondence between them. (That
is, you should not assume that r[i] is the “residual” of ẋ꜀ₚ[i].) For
a Diagram, r is the concatenation of residuals from each of the
subsystems, in order of subsystem index within the Diagram.</p>
<p>A default implementation fᵢ⁽ᵈᵉᶠ⁾ for the implicit form is always
provided and makes use of the explicit form as follows:</p>
<ol class="arabic simple" start="5">
<li><p>fᵢ⁽ᵈᵉᶠ⁾(𝓒; ẋ꜀ₚ) ≜ ẋ꜀ₚ − fₑ(𝓒)</p></li>
</ol>
<p>which satisfies condition (3) by construction. (Note that the default
implementation requires the residual to have the same size as x꜀.)
Substantial efficiency gains can often be obtained by replacing the
default function with a customized implementation. Override
DoCalcImplicitTimeDerivativesResidual() to replace the default
implementation with a better one.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The source for time, state, inputs, etc. to be used in calculating
the residual.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">proposed_derivatives</span></code>:</dt><dd><p>The proposed value ẋ꜀ₚ for the time derivatives of x꜀.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">residual</span></code>:</dt><dd><p>The result r of evaluating the implicit function. Can be any
mutable Eigen vector object of size
implicit_time_derivatives_residual_size().</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">proposed_derivatives</span></code> is compatible with this System.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">residual</span></code> is of size implicit_time_derivatives_residual_size().</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>SystemBase::implicit_time_derivatives_residual_size()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>LeafSystem::DeclareImplicitTimeDerivativesResidualSize()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DoCalcImplicitTimeDerivativesResidual()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcTimeDerivatives()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[AutoDiffXd].CalcKineticEnergy(self:</span> <span class="pre">pydrake.systems.framework.System_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd</span></span></dt>
<dd><p>Calculates and returns the kinetic energy represented by the current
configuration and velocity provided in <code class="docutils literal notranslate"><span class="pre">context</span></code>. Prefer
EvalKineticEnergy() to avoid unnecessary recalculation.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>EvalKineticEnergy() for more information.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[AutoDiffXd].CalcNonConservativePower(self:</span> <span class="pre">pydrake.systems.framework.System_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd</span></span></dt>
<dd><p>Calculates and returns the non-conservative power represented by the
current contents of the given <code class="docutils literal notranslate"><span class="pre">context</span></code>. Prefer
EvalNonConservativePower() to avoid unnecessary recalculation.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>EvalNonConservativePower() for more information.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[AutoDiffXd].CalcOutput(self:</span> <span class="pre">pydrake.systems.framework.System_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd],</span> <span class="pre">outputs:</span> <span class="pre">pydrake.systems.framework.SystemOutput_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Utility method that computes for <em>every</em> output port i the value y(i)
that should result from the current contents of the given Context.
Note that individual output port values can be calculated using
<code class="docutils literal notranslate"><span class="pre">get_output_port(i).Calc()</span></code>; this method invokes that for each
output port in index order. The result may depend on time and the
current values of input ports, parameters, and state variables. The
result is written to <code class="docutils literal notranslate"><span class="pre">outputs</span></code> which must already have been
allocated to have the right number of entries of the right types.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[AutoDiffXd].CalcPotentialEnergy(self:</span> <span class="pre">pydrake.systems.framework.System_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd</span></span></dt>
<dd><p>Calculates and returns the potential energy represented by the current
configuration provided in <code class="docutils literal notranslate"><span class="pre">context</span></code>. Prefer EvalPotentialEnergy() to
avoid unnecessary recalculation.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>EvalPotentialEnergy() for more information.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[AutoDiffXd].CalcTimeDerivatives(self:</span> <span class="pre">pydrake.systems.framework.System_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd],</span> <span class="pre">derivatives:</span> <span class="pre">pydrake.systems.framework.ContinuousState_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Calculates the time derivatives ẋ꜀ of the continuous state x꜀ into a
given output argument. Prefer EvalTimeDerivatives() instead to avoid
unnecessary recomputation.</p>
<p>This method solves the System equations in explicit form:</p>
<p>ẋ꜀ = fₑ(𝓒)</p>
<p>where <code class="docutils literal notranslate"><span class="pre">𝓒</span> <span class="pre">=</span> <span class="pre">{a,</span> <span class="pre">p,</span> <span class="pre">t,</span> <span class="pre">x,</span> <span class="pre">u}</span></code> is the current value of the given
Context from which accuracy a, parameters p, time t, state x (<code class="docutils literal notranslate"><span class="pre">={x꜀</span>
<span class="pre">xd</span> <span class="pre">xₐ}</span></code>) and input values u are obtained.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The source for time, state, inputs, etc. defining the point at
which the derivatives should be calculated.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">derivatives</span></code>:</dt><dd><p>The time derivatives ẋ꜀. Must be the same size as the continuous
state vector in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>EvalTimeDerivatives() for more information.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcImplicitTimeDerivativesResidual() for the implicit form of
these equations.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[AutoDiffXd].Clone(self:</span> <span class="pre">pydrake.systems.framework.System_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.System_[AutoDiffXd]</span></span></dt>
<dd><p>Creates a deep copy of this system.</p>
<p>Even though the cloned system is functionally identical, any contexts
created for this system are not compatible with the cloned system, and
vice versa.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>Context::SetTimeStateAndParametersFrom() for how to copy context
data between clones.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This implementation is somewhat incomplete at the moment. Many
systems will not be able to be cloned, and will throw an exception
instead. To be cloned, at minimum a system must support scalar
conversion. See system_scalar_conversion.</p>
</div>
<p>The result is never nullptr.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[AutoDiffXd].CreateDefaultContext(self:</span> <span class="pre">pydrake.systems.framework.System_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd]</span></span></dt>
<dd><p>This convenience method allocates a context using AllocateContext()
and sets its default values using SetDefaultContext().</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[AutoDiffXd].DeclareInputPort(self:</span> <span class="pre">pydrake.systems.framework.System_[AutoDiffXd],</span> <span class="pre">name:</span> <span class="pre">Union[str,</span> <span class="pre">pydrake.systems.framework.UseDefaultName],</span> <span class="pre">type:</span> <span class="pre">pydrake.systems.framework.PortDataType,</span> <span class="pre">size:</span> <span class="pre">int,</span> <span class="pre">random_type:</span> <span class="pre">Optional[pydrake.common.RandomDistribution]</span> <span class="pre">=</span> <span class="pre">None)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.InputPort_[AutoDiffXd]</span></span></dt>
<dd><p>Adds a port with the specified <code class="docutils literal notranslate"><span class="pre">type</span></code> and <code class="docutils literal notranslate"><span class="pre">size</span></code> to the input
topology.</p>
<p>Input port names must be unique for this system (passing in a
duplicate <code class="docutils literal notranslate"><span class="pre">name</span></code> will throw RuntimeError). If <code class="docutils literal notranslate"><span class="pre">name</span></code> is given as
kUseDefaultName, then a default value of e.g. “u2”, where 2 is the
input number will be provided. An empty <code class="docutils literal notranslate"><span class="pre">name</span></code> is not permitted.</p>
<p>If the port is intended to model a random noise or disturbance input,
<code class="docutils literal notranslate"><span class="pre">random_type</span></code> can (optionally) be used to label it as such; doing so
enables algorithms for design and analysis (e.g. state estimation) to
reason explicitly about randomness at the system level. All random
input ports are assumed to be statistically independent.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">name</span></code> must not be empty.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError for a duplicate port name.</strong> – </p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>the declared port.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[AutoDiffXd].EvalAbstractInput(self:</span> <span class="pre">pydrake.systems.framework.System_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd],</span> <span class="pre">port_index:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.common.value.AbstractValue</span></span></dt>
<dd><p>Returns the value of the input port with the given <code class="docutils literal notranslate"><span class="pre">port_index</span></code> as
an AbstractValue, which is permitted for ports of any type. Causes the
value to become up to date first if necessary, delegating to our
parent Diagram. Returns a pointer to the port’s value, or nullptr if
the port is not connected. If you know the actual type, use one of the
more-specific signatures.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">port_index</span></code> selects an existing input port of this System.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>InputPort::Eval() (preferred)</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[AutoDiffXd].EvalKineticEnergy(self:</span> <span class="pre">pydrake.systems.framework.System_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd</span></span></dt>
<dd><p>Returns a reference to the cached value of the kinetic energy (KE),
evaluating first if necessary using CalcKineticEnergy().</p>
<p>By definition here, kinetic energy depends only on “configuration” and
“velocity” (e.g. angular and translational velocity) of moving masses
which includes a subset of the state variables, and parameters that
affect configuration, velocities, or mass properties. The calculated
value may also be affected by the accuracy value supplied in the
Context. KE cannot depend explicitly on time (∂KE/∂t = 0) or input
port values (∂KE/∂u = 0).</p>
<p>Non-physical systems where KE is not meaningful will return KE = 0.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The Context whose configuration and velocity variables may be used
to evaluate kinetic energy.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">KE</span></code>:</dt><dd><p>The kinetic energy in joules (J) represented by the configuration
and velocity given in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcKineticEnergy()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[AutoDiffXd].EvalPotentialEnergy(self:</span> <span class="pre">pydrake.systems.framework.System_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd</span></span></dt>
<dd><p>Returns a reference to the cached value of the potential energy (PE),
evaluating first if necessary using CalcPotentialEnergy().</p>
<p>By definition here, potential energy depends only on “configuration”
(e.g. orientation and position), which includes a subset of the state
variables, and parameters that affect configuration or conservative
forces (such as lengths and masses). The calculated value may also be
affected by the accuracy value supplied in the Context. PE cannot
depend explicitly on time (∂PE/∂t = 0), velocities (∂PE/∂v = 0), or
input port values (∂PE/∂u = 0).</p>
<p>Non-physical systems where PE is not meaningful will return PE = 0.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The Context whose configuration variables may be used to evaluate
potential energy.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">PE</span></code>:</dt><dd><p>The potential energy in joules (J) represented by the
configuration given in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcPotentialEnergy()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[AutoDiffXd].EvalTimeDerivatives(self:</span> <span class="pre">pydrake.systems.framework.System_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.ContinuousState_[AutoDiffXd]</span></span></dt>
<dd><p>Returns a reference to the cached value of the continuous state
variable time derivatives, evaluating first if necessary using
CalcTimeDerivatives().</p>
<p>This method returns the time derivatives ẋ꜀ of the continuous state
x꜀. The referenced return object will correspond elementwise with the
continuous state in the given Context. Thus, if the state in the
Context has second-order structure <code class="docutils literal notranslate"><span class="pre">x꜀</span> <span class="pre">=</span> <span class="pre">[q</span> <span class="pre">v</span> <span class="pre">z]</span></code>, that same
structure applies to the derivatives so we will have <code class="docutils literal notranslate"><span class="pre">ẋ꜀</span> <span class="pre">=</span> <span class="pre">[q̇</span> <span class="pre">̇v̇</span>
<span class="pre">ż]</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The Context whose time, input port, parameter, state, and accuracy
values may be used to evaluate the derivatives.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">xcdot</span></code>:</dt><dd><p>Time derivatives ẋ꜀ of x꜀ returned as a reference to an object of
the same type and size as <cite>context</cite>’s continuous state.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>BatchEvalTimeDerivatives() for a batch version of this method.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcTimeDerivatives(), CalcImplicitTimeDerivativesResidual(),
get_time_derivatives_cache_entry()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[AutoDiffXd].EvalUniquePeriodicDiscreteUpdate(self:</span> <span class="pre">pydrake.systems.framework.System_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.DiscreteValues_[AutoDiffXd]</span></span></dt>
<dd><p>If this System contains a unique periodic timing for discrete update
events, this function executes the handlers for those periodic events
to determine what their effect would be. Returns a reference to the
discrete variable cache entry containing what values the discrete
variables would have if these periodic events were triggered.</p>
<p>Note that this function <em>does not</em> change the value of the discrete
variables in the supplied Context. However, you can apply the result
to the Context like this:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="n">DiscreteValues</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">updated</span><span class="w"> </span><span class="o">=</span>
<span class="n">system</span><span class="p">.</span><span class="n">EvalUniquePeriodicDiscreteUpdate</span><span class="p">(</span><span class="n">context</span><span class="p">);</span>
<span class="n">context</span><span class="p">.</span><span class="n">SetDiscreteState</span><span class="p">(</span><span class="n">updated</span><span class="p">);</span>
</pre></div>
</div>
</details><p>You can write the updated values to a different Context than the one
you used to calculate the update; the requirement is only that the
discrete state in the destination has the same structure (number of
groups and size of each group).</p>
<p>You can use GetUniquePeriodicDiscreteUpdateAttribute() to check
whether you can call EvalUniquePeriodicDiscreteUpdate() safely, and to
find the unique periodic timing information (offset and period).</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Even if we find a unique discrete update timing as described
above, there may also be unrestricted updates performed with that
timing or other timings. (Unrestricted updates can modify any
state variables <em>including</em> discrete variables.) Also, there may
be trigger types other than periodic that can modify discrete
variables. This function does not attempt to look for any of
those; they are simply ignored. If you are concerned with those,
you can use GetPerStepEvents(), GetInitializationEvents(), and
GetPeriodicEvents() to get a more comprehensive picture of the
event landscape.</p>
</div>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The Context containing the current System state and the mutable
cache space into which the result is written. The current state is
<em>not</em> modified, though the cache entry may be updated.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A reference to the DiscreteValues cache space in <code class="docutils literal notranslate"><span class="pre">context</span></code>
containing the result of applying the discrete update event
handlers to the current discrete variable values.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The referenced cache entry is recalculated if anything in the
given Context has changed since last calculation. Subsequent calls
just return the already-calculated value.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if there is not exactly one periodic timing in this</strong> – </p></li>
<li><p><strong>System</strong><strong> (</strong><strong>which may be a Diagram</strong><strong>) </strong><strong>that triggers discrete update</strong> – </p></li>
<li><p><strong>events.</strong> – </p></li>
<li><p><strong>RuntimeError if it invokes an event handler that returns status</strong> – </p></li>
<li><p><strong>indicating failure.</strong> – </p></li>
</ul>
</dd>
</dl>
<p>&#64;par Implementation If recalculation is needed, copies the current
discrete state values into preallocated <code class="docutils literal notranslate"><span class="pre">context</span></code> cache space.
Applies the discrete update event handlers (in an unspecified order)
to the cache copy, possibly updating it. Returns a reference to the
possibly-updated cache space.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>BatchEvalUniquePeriodicDiscreteUpdate() for a batch version of
this method.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>GetUniquePeriodicDiscreteUpdateAttribute(), GetPeriodicEvents()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[AutoDiffXd].EvalVectorInput(self:</span> <span class="pre">pydrake.systems.framework.System_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd],</span> <span class="pre">port_index:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.BasicVector_[AutoDiffXd]</span></span></dt>
<dd><p>Returns the value of the vector-valued input port with the given
<code class="docutils literal notranslate"><span class="pre">port_index</span></code> as a BasicVector or a specific subclass <code class="docutils literal notranslate"><span class="pre">Vec</span></code> derived
from BasicVector. Causes the value to become up to date first if
necessary. See EvalAbstractInput() for more information.</p>
<p>The result is returned as a pointer to the input port’s value of type
<code class="docutils literal notranslate"><span class="pre">Vec&lt;T&gt;</span></code> or nullptr if the port is not connected.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">port_index</span></code> selects an existing input port of this System.</p>
</dd>
<dt>Precondition:</dt><dd><p>the port must have been declared to be vector-valued.</p>
</dd>
<dt>Precondition:</dt><dd><p>the port’s value must be of type Vec&lt;T&gt;.</p>
</dd>
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">Vec</span></code>:</dt><dd><p>The template type of the input vector, which must be a subclass of
BasicVector.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[AutoDiffXd].ExecuteForcedEvents(self:</span> <span class="pre">pydrake.systems.framework.System_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd],</span> <span class="pre">publish:</span> <span class="pre">bool</span> <span class="pre">=</span> <span class="pre">True)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>This method triggers all of the forced events registered with this
System (which might be a Diagram). Ordering and status return handling
mimic the Simulator: unrestricted events are processed first, then
discrete update events, then publish events. “Reached termination”
status returns are ignored.</p>
<p>An option is provided to suppress publish events. This can be useful,
for example, to update state in a Diagram without triggering a
visualization.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The Context supplied to the handlers and modified in place on
return.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if it invokes an event handler that returns status</strong> – </p></li>
<li><p><strong>indicating failure.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[AutoDiffXd].ExecuteInitializationEvents(self:</span> <span class="pre">pydrake.systems.framework.System_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>This method triggers all of the initialization events returned by
GetInitializationEvents(). The method allocates temporary storage to
perform the updates, and is intended only as a convenience method for
callers who do not want to use the full Simulator workflow.</p>
<p>Note that this is not fully equivalent to Simulator::Initialize()
because <em>only</em> initialization events are handled here, while
Simulator::Initialize() also processes other events associated with
time zero. Also, “reached termination” returns are ignored here.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The Context supplied to the handlers and modified in place on
return.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if it invokes an event handler that returns status</strong> – </p></li>
<li><p><strong>indicating failure.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[AutoDiffXd].FixInputPortsFrom(self:</span> <span class="pre">pydrake.systems.framework.System_[AutoDiffXd],</span> <span class="pre">other_system:</span> <span class="pre">pydrake.systems.framework.System,</span> <span class="pre">other_context:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">target_context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Fixes all of the input ports in <code class="docutils literal notranslate"><span class="pre">target_context</span></code> to their current
values in <code class="docutils literal notranslate"><span class="pre">other_context</span></code>, as evaluated by <code class="docutils literal notranslate"><span class="pre">other_system</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError unless other_context and target_context both</strong> – </p></li>
<li><p><strong>have the same shape as this System</strong><strong>, </strong><strong>and the other_system.</strong> – </p></li>
<li><p><strong>Ignores disconnected inputs.</strong> – </p></li>
<li><p><strong>RuntimeError if this system's scalar type T != double and</strong> – </p></li>
<li><p><strong>other_system` has any abstract input ports whose contained typ</strong> – </p></li>
<li><p><strong>depends on scalar type.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[AutoDiffXd].ForcedPublish(self:</span> <span class="pre">pydrake.systems.framework.System_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>(Advanced) Manually triggers any PublishEvent that has trigger type
kForced. Invokes the publish event dispatcher on this System with the
given Context.</p>
<p>The default dispatcher will invoke the handlers (if any) associated
with each force-triggered event.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>There will always be at least one force-triggered event, though
with no associated handler (so will do nothing when triggered).</p>
</div>
<p>The Simulator can be configured to call this in
Simulator::Initialize() and at the start of each continuous
integration step. See the Simulator API for more details.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if it invokes an event handler that returns status</strong> – </p></li>
<li><p><strong>indicating failure.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>Publish(), CalcForcedDiscreteVariableUpdate(),
CalcForcedUnrestrictedUpdate()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[AutoDiffXd].get_input_port(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>get_input_port(self: pydrake.systems.framework.System_[AutoDiffXd], port_index: int, warn_deprecated: bool = True) -&gt; pydrake.systems.framework.InputPort_[AutoDiffXd]</p></li>
</ol>
<p>Returns the typed input port at index <code class="docutils literal notranslate"><span class="pre">port_index</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">warn_deprecated</span></code>:</dt><dd><p>Whether or not to print a warning in case the port was marked as
deprecated.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>get_input_port(self: pydrake.systems.framework.System_[AutoDiffXd]) -&gt; pydrake.systems.framework.InputPort_[AutoDiffXd]</p></li>
</ol>
<p>Convenience method for the case of exactly one input port. This
function ignores deprecated ports, unless there is only one port in
which case it will return the deprecated port.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[AutoDiffXd].get_output_port(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>get_output_port(self: pydrake.systems.framework.System_[AutoDiffXd], port_index: int, warn_deprecated: bool = True) -&gt; pydrake.systems.framework.OutputPort_[AutoDiffXd]</p></li>
</ol>
<p>Returns the typed output port at index <code class="docutils literal notranslate"><span class="pre">port_index</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">warn_deprecated</span></code>:</dt><dd><p>Whether or not to print a warning in case the port was marked as
deprecated.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>get_output_port(self: pydrake.systems.framework.System_[AutoDiffXd]) -&gt; pydrake.systems.framework.OutputPort_[AutoDiffXd]</p></li>
</ol>
<p>Convenience method for the case of exactly one output port. This
function ignores deprecated ports, unless there is only one port in
which case it will return the deprecated port.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[AutoDiffXd].get_system_scalar_converter(self:</span> <span class="pre">pydrake.systems.framework.System_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.SystemScalarConverter</span></span></dt>
<dd><p>(Advanced) Returns the SystemScalarConverter for this object. This is
an expert-level API intended for framework authors. Most users should
prefer the convenience helpers such as System::ToAutoDiffXd.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[AutoDiffXd].GetInputPort(self:</span> <span class="pre">pydrake.systems.framework.System_[AutoDiffXd],</span> <span class="pre">port_name:</span> <span class="pre">str)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.InputPort_[AutoDiffXd]</span></span></dt>
<dd><p>Returns the typed input port with the unique name <code class="docutils literal notranslate"><span class="pre">port_name</span></code>. The
current implementation performs a linear search over strings; prefer
get_input_port() when performance is a concern.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if port_name is not found.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[AutoDiffXd].GetMutableSubsystemContext(self:</span> <span class="pre">pydrake.systems.framework.System_[AutoDiffXd],</span> <span class="pre">subsystem:</span> <span class="pre">pydrake.systems.framework.System_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd]</span></span></dt>
<dd><p>Returns a mutable reference to the subcontext that corresponds to the
contained System <code class="docutils literal notranslate"><span class="pre">subsystem</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if subsystem not contained in this System.</strong> – </p>
</dd>
</dl>
<dl class="simple">
<dt>Precondition:</dt><dd><p>The given <code class="docutils literal notranslate"><span class="pre">context</span></code> is valid for use with <code class="docutils literal notranslate"><span class="pre">this</span></code> System.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[AutoDiffXd].GetMyContextFromRoot(self:</span> <span class="pre">pydrake.systems.framework.System_[AutoDiffXd],</span> <span class="pre">root_context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd]</span></span></dt>
<dd><p>Returns the mutable subsystem context for <code class="docutils literal notranslate"><span class="pre">this</span></code> system, given a
root context.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>GetMyContextFromRoot()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[AutoDiffXd].GetMyMutableContextFromRoot(self:</span> <span class="pre">pydrake.systems.framework.System_[AutoDiffXd],</span> <span class="pre">root_context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd]</span></span></dt>
<dd><p>Returns the mutable subsystem context for <code class="docutils literal notranslate"><span class="pre">this</span></code> system, given a
root context.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>GetMyContextFromRoot()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[AutoDiffXd].GetOutputPort(self:</span> <span class="pre">pydrake.systems.framework.System_[AutoDiffXd],</span> <span class="pre">port_name:</span> <span class="pre">str)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.OutputPort_[AutoDiffXd]</span></span></dt>
<dd><p>Returns the typed output port with the unique name <code class="docutils literal notranslate"><span class="pre">port_name</span></code>. The
current implementation performs a linear search over strings; prefer
get_output_port() when performance is a concern.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if port_name is not found.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[AutoDiffXd].GetSubsystemContext(self:</span> <span class="pre">pydrake.systems.framework.System_[AutoDiffXd],</span> <span class="pre">subsystem:</span> <span class="pre">pydrake.systems.framework.System_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd]</span></span></dt>
<dd><p>Returns a mutable reference to the subcontext that corresponds to the
contained System <code class="docutils literal notranslate"><span class="pre">subsystem</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if subsystem not contained in this System.</strong> – </p>
</dd>
</dl>
<dl class="simple">
<dt>Precondition:</dt><dd><p>The given <code class="docutils literal notranslate"><span class="pre">context</span></code> is valid for use with <code class="docutils literal notranslate"><span class="pre">this</span></code> System.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[AutoDiffXd].GetUniquePeriodicDiscreteUpdateAttribute(self:</span> <span class="pre">pydrake.systems.framework.System_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">Optional[pydrake.systems.framework.PeriodicEventData]</span></span></dt>
<dd><p>Determines whether there exists a unique periodic timing (offset and
period) that triggers one or more discrete update events (and, if so,
returns that unique periodic timing). Thus, this method can be used
(1) as a test to determine whether a system’s dynamics are at least
partially governed by difference equations, and (2) to obtain the
difference equation update times. Use
EvalUniquePeriodicDiscreteUpdate() if you want to determine the actual
effects of triggering these events.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Even if we find a unique discrete update timing as described
above, there may also be unrestricted updates performed with that
timing or other timings. (Unrestricted updates can modify any
state variables <em>including</em> discrete variables.) Also, there may
be trigger types other than periodic that can modify discrete
variables. This function does not attempt to look for any of
those; they are simply ignored. If you are concerned with those,
you can use GetPerStepEvents(), GetInitializationEvents(), and
GetPeriodicEvents() to get a more comprehensive picture of the
event landscape.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>optional&lt;PeriodicEventData&gt; Contains the unique periodic trigger
timing if it exists, otherwise <code class="docutils literal notranslate"><span class="pre">nullopt</span></code>.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>EvalUniquePeriodicDiscreteUpdate(), IsDifferenceEquationSystem()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[AutoDiffXd].GetWitnessFunctions(self:</span> <span class="pre">pydrake.systems.framework.System_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">list[pydrake.systems.framework.WitnessFunction_[AutoDiffXd]]</span></span></dt>
<dd><p>Derived classes can override this method to provide witness functions
active for the given state. The default implementation does nothing.
On entry to this function, the context will have already been
validated and the vector of witness functions will have been validated
to be both empty and non-null.
Note: The above is for the C++ documentation. For Python, use
<cite>witnesses = GetWitnessFunctions(context)</cite></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[AutoDiffXd].HasAnyDirectFeedthrough(self:</span> <span class="pre">pydrake.systems.framework.System_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if any of the inputs to the system might be directly
fed through to any of its outputs and <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[AutoDiffXd].HasDirectFeedthrough(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>HasDirectFeedthrough(self: pydrake.systems.framework.System_[AutoDiffXd], output_port: int) -&gt; bool</p></li>
</ol>
<p>Returns true if there might be direct-feedthrough from any input port
to the given <code class="docutils literal notranslate"><span class="pre">output_port</span></code>, and false otherwise.</p>
<ol class="arabic simple" start="2">
<li><p>HasDirectFeedthrough(self: pydrake.systems.framework.System_[AutoDiffXd], input_port: int, output_port: int) -&gt; bool</p></li>
</ol>
<p>Returns true if there might be direct-feedthrough from the given
<code class="docutils literal notranslate"><span class="pre">input_port</span></code> to the given <code class="docutils literal notranslate"><span class="pre">output_port</span></code>, and false otherwise.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[AutoDiffXd].HasInputPort(self:</span> <span class="pre">pydrake.systems.framework.System_[AutoDiffXd],</span> <span class="pre">port_name:</span> <span class="pre">str)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns true iff the system has an InputPort of the given
<code class="docutils literal notranslate"><span class="pre">port_name</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[AutoDiffXd].HasOutputPort(self:</span> <span class="pre">pydrake.systems.framework.System_[AutoDiffXd],</span> <span class="pre">port_name:</span> <span class="pre">str)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns true iff the system has an OutputPort of the given
<code class="docutils literal notranslate"><span class="pre">port_name</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[AutoDiffXd].IsDifferenceEquationSystem(self:</span> <span class="pre">pydrake.systems.framework.System_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">tuple[bool,</span> <span class="pre">float]</span></span></dt>
<dd><p>Returns true iff the state dynamics of this system are governed
exclusively by a difference equation on a single discrete state group
and with a unique periodic update (having zero offset). E.g., it is
amenable to analysis of the form:</p>
<p>x[n+1] = f(n, x[n], u[n], w[n]; p)</p>
<p>where t is time, x is (discrete) state, u is a vector input, w is
random (disturbance) input, and p are parameters. Note that we do NOT
consider the number of input ports here, because in practice many
systems of interest (e.g. MultibodyPlant) have input ports that are
safely treated as constant during the analysis. Consider using
get_input_port_selection() to choose one.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>In determining whether this system is governed as above, we do not
consider unrestricted updates nor any update events that have
trigger types other than periodic. See
GetUniquePeriodicDiscreteUpdateAttribute() for more information.</p>
</div>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">time_period</span></code>:</dt><dd><p>if non-null, then iff the function returns <code class="docutils literal notranslate"><span class="pre">True</span></code>, then
time_period is set to the period data returned from
GetUniquePeriodicDiscreteUpdateAttribute(). If the function
returns <code class="docutils literal notranslate"><span class="pre">False</span></code> (the system is not a difference equation
system), then <code class="docutils literal notranslate"><span class="pre">time_period</span></code> does not receive a value.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>GetUniquePeriodicDiscreteUpdateAttribute()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>EvalUniquePeriodicDiscreteUpdate()</p>
</div>
<p>Note: The above is for the C++ documentation. For Python, use
<cite>is_diff_eq, period = IsDifferenceEquationSystem()</cite></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[AutoDiffXd].IsDifferentialEquationSystem(self:</span> <span class="pre">pydrake.systems.framework.System_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns true iff the state dynamics of this system are governed
exclusively by a differential equation. E.g., it is amenable to
analysis of the form:</p>
<p>ẋ = f(t, x(t), u(t), w(t); p),</p>
<p>where t is time, x is (continuous) state, u is a vector input, w is
random (disturbance) input, and p are parameters. This requires that
it has no discrete nor abstract states, and no abstract input ports.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>In determining whether this system is governed as above, we do not
consider unrestricted updates which could potentially update the
state.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[AutoDiffXd].num_constraints(self:</span> <span class="pre">pydrake.systems.framework.System_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the number of constraints specified for the system.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[AutoDiffXd].SetDefaultContext(self:</span> <span class="pre">pydrake.systems.framework.System_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets Context fields to their default values. User code should not
override.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[AutoDiffXd].SetRandomContext(self:</span> <span class="pre">pydrake.systems.framework.System_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd],</span> <span class="pre">generator:</span> <span class="pre">pydrake.common.RandomGenerator)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets Context fields to random values. User code should not override.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[AutoDiffXd].ToAutoDiffXd(self:</span> <span class="pre">pydrake.systems.framework.System_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.System_[AutoDiffXd]</span></span></dt>
<dd><p>Creates a deep copy of this System, transmogrified to use the autodiff
scalar type, with a dynamic-sized vector of partial derivatives. The
result is never nullptr.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if this System does not support autodiff</strong> – </p>
</dd>
</dl>
<p>See system_scalar_conversion for detailed background and examples
related to scalar-type conversion support.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[AutoDiffXd].ToAutoDiffXdMaybe(self:</span> <span class="pre">pydrake.systems.framework.System_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.System_[AutoDiffXd]</span></span></dt>
<dd><p>Creates a deep copy of this system exactly like ToAutoDiffXd(), but
returns nullptr if this System does not support autodiff, instead of
throwing an exception.</p>
</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[AutoDiffXd].ToScalarType</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">ToScalarType[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ToScalarType[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ToScalarType[Expression]</span></code></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[AutoDiffXd].ToScalarType[AutoDiffXd](self:</span> <span class="pre">pydrake.systems.framework.System_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.System_[AutoDiffXd]</span></span></dt>
<dd><p>Creates a deep copy of this System, transmogrified to use the scalar
type selected by a template parameter. The result is never nullptr.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if this System does not support the destination type.</strong> – </p>
</dd>
</dl>
<dl class="simple">
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">U</span></code>:</dt><dd><p>The destination scalar type. For a list of supported types, see
the default_scalars “default scalars”.</p>
</dd>
</dl>
<p>See system_scalar_conversion for detailed background and examples
related to scalar-type conversion support.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[AutoDiffXd].ToScalarType[Expression](self:</span> <span class="pre">pydrake.systems.framework.System_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.System_[Expression]</span></span></dt>
<dd><p>Creates a deep copy of this System, transmogrified to use the scalar
type selected by a template parameter. The result is never nullptr.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if this System does not support the destination type.</strong> – </p>
</dd>
</dl>
<dl class="simple">
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">U</span></code>:</dt><dd><p>The destination scalar type. For a list of supported types, see
the default_scalars “default scalars”.</p>
</dd>
</dl>
<p>See system_scalar_conversion for detailed background and examples
related to scalar-type conversion support.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[AutoDiffXd].ToScalarType[float](self:</span> <span class="pre">pydrake.systems.framework.System_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.System</span></span></dt>
<dd><p>Creates a deep copy of this System, transmogrified to use the scalar
type selected by a template parameter. The result is never nullptr.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if this System does not support the destination type.</strong> – </p>
</dd>
</dl>
<dl class="simple">
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">U</span></code>:</dt><dd><p>The destination scalar type. For a list of supported types, see
the default_scalars “default scalars”.</p>
</dd>
</dl>
<p>See system_scalar_conversion for detailed background and examples
related to scalar-type conversion support.</p>
</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[AutoDiffXd].ToScalarTypeMaybe</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">ToScalarTypeMaybe[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ToScalarTypeMaybe[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ToScalarTypeMaybe[Expression]</span></code></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[AutoDiffXd].ToScalarTypeMaybe[AutoDiffXd](self:</span> <span class="pre">pydrake.systems.framework.System_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.System_[AutoDiffXd]</span></span></dt>
<dd><p>Creates a deep copy of this system exactly like ToScalarType(), but
returns nullptr if this System does not support the destination type,
instead of throwing an exception.</p>
<dl class="simple">
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">U</span></code>:</dt><dd><p>The destination scalar type. For a list of supported types, see
the default_scalars “default scalars”.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[AutoDiffXd].ToScalarTypeMaybe[Expression](self:</span> <span class="pre">pydrake.systems.framework.System_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.System_[Expression]</span></span></dt>
<dd><p>Creates a deep copy of this system exactly like ToScalarType(), but
returns nullptr if this System does not support the destination type,
instead of throwing an exception.</p>
<dl class="simple">
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">U</span></code>:</dt><dd><p>The destination scalar type. For a list of supported types, see
the default_scalars “default scalars”.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[AutoDiffXd].ToScalarTypeMaybe[float](self:</span> <span class="pre">pydrake.systems.framework.System_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.System</span></span></dt>
<dd><p>Creates a deep copy of this system exactly like ToScalarType(), but
returns nullptr if this System does not support the destination type,
instead of throwing an exception.</p>
<dl class="simple">
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">U</span></code>:</dt><dd><p>The destination scalar type. For a list of supported types, see
the default_scalars “default scalars”.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[AutoDiffXd].ToSymbolic(self:</span> <span class="pre">pydrake.systems.framework.System_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.System_[Expression]</span></span></dt>
<dd><p>Creates a deep copy of this System, transmogrified to use the symbolic
scalar type. The result is never nullptr.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if this System does not support symbolic</strong> – </p>
</dd>
</dl>
<p>See system_scalar_conversion for detailed background and examples
related to scalar-type conversion support.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[AutoDiffXd].ToSymbolicMaybe(self:</span> <span class="pre">pydrake.systems.framework.System_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.System_[Expression]</span></span></dt>
<dd><p>Creates a deep copy of this system exactly like ToSymbolic(), but
returns nullptr if this System does not support symbolic, instead of
throwing an exception.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[Expression]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.SystemBase</span></code></p>
<p>Base class for all System functionality that is dependent on the
templatized scalar type T for input, state, parameters, and outputs.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[Expression].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[Expression].Accept(self:</span> <span class="pre">pydrake.systems.framework.System_[Expression],</span> <span class="pre">v:</span> <span class="pre">pydrake.systems.framework.SystemVisitor_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Implements a visitor pattern.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>SystemVisitor&lt;T&gt;.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[Expression].AllocateContext(self:</span> <span class="pre">pydrake.systems.framework.System_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.Context_[Expression]</span></span></dt>
<dd><p>(Advanced) Returns an <strong>uninitialized</strong> Context&lt;T&gt; suitable for use
with this System&lt;T&gt;. Most users should use CreateDefaultContext(),
instead.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The returned context is uninitialized (contains invalid data). It
is useful for pre-allocating storage which will later be
overwritten (e.g., by SetDefaultContext() or
Context&lt;T&gt;::SetTimeStateAndParametersFrom()) and <strong>must not</strong> be
used for any calculations until it’s been overwritten.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[Expression].AllocateDiscreteVariables(self:</span> <span class="pre">pydrake.systems.framework.System_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.DiscreteValues_[Expression]</span></span></dt>
<dd><p>Returns a DiscreteValues of the same dimensions as the discrete_state
allocated in CreateDefaultContext. The simulator will provide this
state as the output argument to Update.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[Expression].AllocateImplicitTimeDerivativesResidual(self:</span> <span class="pre">pydrake.systems.framework.System_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns an Eigen VectorX suitable for use as the output argument to
the CalcImplicitTimeDerivativesResidual() method. The returned VectorX
will have size implicit_time_derivatives_residual_size() with the
elements uninitialized. This is just a convenience method – you are
free to use any properly-sized mutable Eigen object as the residual
vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[Expression].AllocateInputAbstract(self:</span> <span class="pre">pydrake.systems.framework.System_[Expression],</span> <span class="pre">input_port:</span> <span class="pre">pydrake.systems.framework.InputPort_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.common.value.AbstractValue</span></span></dt>
<dd><p>Given an input port, allocates the abstract storage. The
<code class="docutils literal notranslate"><span class="pre">input_port</span></code> must match a port declared via DeclareInputPort.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[Expression].AllocateInputVector(self:</span> <span class="pre">pydrake.systems.framework.System_[Expression],</span> <span class="pre">input_port:</span> <span class="pre">pydrake.systems.framework.InputPort_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.BasicVector_[Expression]</span></span></dt>
<dd><p>Given an input port, allocates the vector storage. The <code class="docutils literal notranslate"><span class="pre">input_port</span></code>
must match a port declared via DeclareInputPort.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[Expression].AllocateOutput(self:</span> <span class="pre">pydrake.systems.framework.System_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.SystemOutput_[Expression]</span></span></dt>
<dd><p>Returns a container that can hold the values of all of this System’s
output ports. It is sized with the number of output ports and uses
each output port’s allocation method to provide an object of the right
type for that port.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[Expression].AllocateTimeDerivatives(self:</span> <span class="pre">pydrake.systems.framework.System_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.ContinuousState_[Expression]</span></span></dt>
<dd><p>Returns a ContinuousState of the same size as the continuous_state
allocated in CreateDefaultContext. The simulator will provide this
state as the output argument to EvalTimeDerivatives.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[Expression].CalcConservativePower(self:</span> <span class="pre">pydrake.systems.framework.System_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.symbolic.Expression</span></span></dt>
<dd><p>Calculates and returns the conservative power represented by the
current contents of the given <code class="docutils literal notranslate"><span class="pre">context</span></code>. Prefer
EvalConservativePower() to avoid unnecessary recalculation.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>EvalConservativePower() for more information.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[Expression].CalcForcedDiscreteVariableUpdate(self:</span> <span class="pre">pydrake.systems.framework.System_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression],</span> <span class="pre">discrete_state:</span> <span class="pre">pydrake.systems.framework.DiscreteValues_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>(Advanced) Manually triggers any DiscreteUpdateEvent that has trigger
type kForced. Invokes the discrete event dispatcher on this System
with the given Context providing the initial values for the discrete
variables. The updated values of the discrete variables are written to
the <code class="docutils literal notranslate"><span class="pre">discrete_state</span></code> output argument; no change is made to the
Context.</p>
<p>The default dispatcher will invoke the handlers (if any) associated
with each force-triggered event.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>There will always be at least one force-triggered event, though
with no associated handler. By default that will do nothing when
triggered, but that behavior can be changed by overriding the
dispatcher (not recommended).</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if it invokes an event handler that returns status</strong> – </p></li>
<li><p><strong>indicating failure.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcDiscreteVariableUpdate(), CalcForcedUnrestrictedUpdate()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[Expression].CalcForcedUnrestrictedUpdate(self:</span> <span class="pre">pydrake.systems.framework.System_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression],</span> <span class="pre">state:</span> <span class="pre">pydrake.systems.framework.State_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>(Advanced) Manually triggers any UnrestrictedUpdateEvent that has
trigger type kForced. Invokes the unrestricted event dispatcher on
this System with the given Context providing the initial values for
the state variables. The updated values of the state variables are
written to the <code class="docutils literal notranslate"><span class="pre">state</span></code> output argument; no change is made to the
Context.</p>
<p>The default dispatcher will invoke the handlers (if any) associated
with each force-triggered event.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>There will always be at least one force-triggered event, though
with no associated handler. By default that will do nothing when
triggered, but that behavior can be changed by overriding the
dispatcher (not recommended).</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if it invokes an event handler that returns status</strong> – </p></li>
<li><p><strong>indicating failure.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcUnrestrictedUpdate()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[Expression].CalcImplicitTimeDerivativesResidual(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>CalcImplicitTimeDerivativesResidual(self: pydrake.systems.framework.System_[Expression], context: pydrake.systems.framework.Context_[Expression], proposed_derivatives: pydrake.systems.framework.ContinuousState_[Expression], residual: Optional[numpy.ndarray[object[m, 1], flags.writeable]]) -&gt; None</p></li>
</ol>
<p>Evaluates the implicit form of the System equations and returns the
residual.</p>
<p>The explicit and implicit forms of the System equations are</p>
<ol class="arabic simple">
<li><p>ẋ꜀ = fₑ(𝓒) explicit (2) 0 = fᵢ(𝓒; ẋ꜀) implicit</p></li>
</ol>
<p>where <code class="docutils literal notranslate"><span class="pre">𝓒</span> <span class="pre">=</span> <span class="pre">{a,</span> <span class="pre">p,</span> <span class="pre">t,</span> <span class="pre">x,</span> <span class="pre">u}</span></code> is the current value of the given
Context from which accuracy a, parameters p, time t, state x (<code class="docutils literal notranslate"><span class="pre">={x꜀</span>
<span class="pre">xd</span> <span class="pre">xₐ}</span></code>) and input values u are obtained. Substituting (1) into (2)
shows that the following condition must always hold:</p>
<ol class="arabic simple" start="3">
<li><p>fᵢ(𝓒; fₑ(𝓒)) = 0 always true</p></li>
</ol>
<p>When <code class="docutils literal notranslate"><span class="pre">fᵢ(𝓒;</span> <span class="pre">ẋ꜀ₚ)</span></code> is evaluated with a proposed time derivative ẋ꜀ₚ
that differs from ẋ꜀ the result will be non-zero; we call that the
<em>residual</em> of the implicit equation. Given a Context and proposed time
derivative ẋ꜀ₚ, this method returns the residual r such that</p>
<ol class="arabic simple" start="4">
<li><p>r = fᵢ(𝓒; ẋ꜀ₚ).</p></li>
</ol>
<p>The returned r will typically be the same length as x꜀ although that
is not required. And even if r and x꜀ are the same size, there will
not necessarily be any elementwise correspondence between them. (That
is, you should not assume that r[i] is the “residual” of ẋ꜀ₚ[i].) For
a Diagram, r is the concatenation of residuals from each of the
subsystems, in order of subsystem index within the Diagram.</p>
<p>A default implementation fᵢ⁽ᵈᵉᶠ⁾ for the implicit form is always
provided and makes use of the explicit form as follows:</p>
<ol class="arabic simple" start="5">
<li><p>fᵢ⁽ᵈᵉᶠ⁾(𝓒; ẋ꜀ₚ) ≜ ẋ꜀ₚ − fₑ(𝓒)</p></li>
</ol>
<p>which satisfies condition (3) by construction. (Note that the default
implementation requires the residual to have the same size as x꜀.)
Substantial efficiency gains can often be obtained by replacing the
default function with a customized implementation. Override
DoCalcImplicitTimeDerivativesResidual() to replace the default
implementation with a better one.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The source for time, state, inputs, etc. to be used in calculating
the residual.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">proposed_derivatives</span></code>:</dt><dd><p>The proposed value ẋ꜀ₚ for the time derivatives of x꜀.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">residual</span></code>:</dt><dd><p>The result r of evaluating the implicit function. Can be any
mutable Eigen vector object of size
implicit_time_derivatives_residual_size().</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">proposed_derivatives</span></code> is compatible with this System.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">residual</span></code> is of size implicit_time_derivatives_residual_size().</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>SystemBase::implicit_time_derivatives_residual_size()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>LeafSystem::DeclareImplicitTimeDerivativesResidualSize()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DoCalcImplicitTimeDerivativesResidual()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcTimeDerivatives()</p>
</div>
<ol class="arabic simple" start="2">
<li><p>CalcImplicitTimeDerivativesResidual(self: pydrake.systems.framework.System_[Expression], context: pydrake.systems.framework.Context_[Expression], proposed_derivatives: pydrake.systems.framework.ContinuousState_[Expression]) -&gt; numpy.ndarray[object[m, 1]]</p></li>
</ol>
<p>Evaluates the implicit form of the System equations and returns the
residual.</p>
<p>The explicit and implicit forms of the System equations are</p>
<ol class="arabic simple">
<li><p>ẋ꜀ = fₑ(𝓒) explicit (2) 0 = fᵢ(𝓒; ẋ꜀) implicit</p></li>
</ol>
<p>where <code class="docutils literal notranslate"><span class="pre">𝓒</span> <span class="pre">=</span> <span class="pre">{a,</span> <span class="pre">p,</span> <span class="pre">t,</span> <span class="pre">x,</span> <span class="pre">u}</span></code> is the current value of the given
Context from which accuracy a, parameters p, time t, state x (<code class="docutils literal notranslate"><span class="pre">={x꜀</span>
<span class="pre">xd</span> <span class="pre">xₐ}</span></code>) and input values u are obtained. Substituting (1) into (2)
shows that the following condition must always hold:</p>
<ol class="arabic simple" start="3">
<li><p>fᵢ(𝓒; fₑ(𝓒)) = 0 always true</p></li>
</ol>
<p>When <code class="docutils literal notranslate"><span class="pre">fᵢ(𝓒;</span> <span class="pre">ẋ꜀ₚ)</span></code> is evaluated with a proposed time derivative ẋ꜀ₚ
that differs from ẋ꜀ the result will be non-zero; we call that the
<em>residual</em> of the implicit equation. Given a Context and proposed time
derivative ẋ꜀ₚ, this method returns the residual r such that</p>
<ol class="arabic simple" start="4">
<li><p>r = fᵢ(𝓒; ẋ꜀ₚ).</p></li>
</ol>
<p>The returned r will typically be the same length as x꜀ although that
is not required. And even if r and x꜀ are the same size, there will
not necessarily be any elementwise correspondence between them. (That
is, you should not assume that r[i] is the “residual” of ẋ꜀ₚ[i].) For
a Diagram, r is the concatenation of residuals from each of the
subsystems, in order of subsystem index within the Diagram.</p>
<p>A default implementation fᵢ⁽ᵈᵉᶠ⁾ for the implicit form is always
provided and makes use of the explicit form as follows:</p>
<ol class="arabic simple" start="5">
<li><p>fᵢ⁽ᵈᵉᶠ⁾(𝓒; ẋ꜀ₚ) ≜ ẋ꜀ₚ − fₑ(𝓒)</p></li>
</ol>
<p>which satisfies condition (3) by construction. (Note that the default
implementation requires the residual to have the same size as x꜀.)
Substantial efficiency gains can often be obtained by replacing the
default function with a customized implementation. Override
DoCalcImplicitTimeDerivativesResidual() to replace the default
implementation with a better one.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The source for time, state, inputs, etc. to be used in calculating
the residual.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">proposed_derivatives</span></code>:</dt><dd><p>The proposed value ẋ꜀ₚ for the time derivatives of x꜀.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">residual</span></code>:</dt><dd><p>The result r of evaluating the implicit function. Can be any
mutable Eigen vector object of size
implicit_time_derivatives_residual_size().</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">proposed_derivatives</span></code> is compatible with this System.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">residual</span></code> is of size implicit_time_derivatives_residual_size().</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>SystemBase::implicit_time_derivatives_residual_size()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>LeafSystem::DeclareImplicitTimeDerivativesResidualSize()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DoCalcImplicitTimeDerivativesResidual()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcTimeDerivatives()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[Expression].CalcKineticEnergy(self:</span> <span class="pre">pydrake.systems.framework.System_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.symbolic.Expression</span></span></dt>
<dd><p>Calculates and returns the kinetic energy represented by the current
configuration and velocity provided in <code class="docutils literal notranslate"><span class="pre">context</span></code>. Prefer
EvalKineticEnergy() to avoid unnecessary recalculation.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>EvalKineticEnergy() for more information.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[Expression].CalcNonConservativePower(self:</span> <span class="pre">pydrake.systems.framework.System_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.symbolic.Expression</span></span></dt>
<dd><p>Calculates and returns the non-conservative power represented by the
current contents of the given <code class="docutils literal notranslate"><span class="pre">context</span></code>. Prefer
EvalNonConservativePower() to avoid unnecessary recalculation.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>EvalNonConservativePower() for more information.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[Expression].CalcOutput(self:</span> <span class="pre">pydrake.systems.framework.System_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression],</span> <span class="pre">outputs:</span> <span class="pre">pydrake.systems.framework.SystemOutput_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Utility method that computes for <em>every</em> output port i the value y(i)
that should result from the current contents of the given Context.
Note that individual output port values can be calculated using
<code class="docutils literal notranslate"><span class="pre">get_output_port(i).Calc()</span></code>; this method invokes that for each
output port in index order. The result may depend on time and the
current values of input ports, parameters, and state variables. The
result is written to <code class="docutils literal notranslate"><span class="pre">outputs</span></code> which must already have been
allocated to have the right number of entries of the right types.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[Expression].CalcPotentialEnergy(self:</span> <span class="pre">pydrake.systems.framework.System_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.symbolic.Expression</span></span></dt>
<dd><p>Calculates and returns the potential energy represented by the current
configuration provided in <code class="docutils literal notranslate"><span class="pre">context</span></code>. Prefer EvalPotentialEnergy() to
avoid unnecessary recalculation.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>EvalPotentialEnergy() for more information.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[Expression].CalcTimeDerivatives(self:</span> <span class="pre">pydrake.systems.framework.System_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression],</span> <span class="pre">derivatives:</span> <span class="pre">pydrake.systems.framework.ContinuousState_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Calculates the time derivatives ẋ꜀ of the continuous state x꜀ into a
given output argument. Prefer EvalTimeDerivatives() instead to avoid
unnecessary recomputation.</p>
<p>This method solves the System equations in explicit form:</p>
<p>ẋ꜀ = fₑ(𝓒)</p>
<p>where <code class="docutils literal notranslate"><span class="pre">𝓒</span> <span class="pre">=</span> <span class="pre">{a,</span> <span class="pre">p,</span> <span class="pre">t,</span> <span class="pre">x,</span> <span class="pre">u}</span></code> is the current value of the given
Context from which accuracy a, parameters p, time t, state x (<code class="docutils literal notranslate"><span class="pre">={x꜀</span>
<span class="pre">xd</span> <span class="pre">xₐ}</span></code>) and input values u are obtained.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The source for time, state, inputs, etc. defining the point at
which the derivatives should be calculated.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">derivatives</span></code>:</dt><dd><p>The time derivatives ẋ꜀. Must be the same size as the continuous
state vector in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>EvalTimeDerivatives() for more information.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcImplicitTimeDerivativesResidual() for the implicit form of
these equations.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[Expression].Clone(self:</span> <span class="pre">pydrake.systems.framework.System_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.System_[Expression]</span></span></dt>
<dd><p>Creates a deep copy of this system.</p>
<p>Even though the cloned system is functionally identical, any contexts
created for this system are not compatible with the cloned system, and
vice versa.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>Context::SetTimeStateAndParametersFrom() for how to copy context
data between clones.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This implementation is somewhat incomplete at the moment. Many
systems will not be able to be cloned, and will throw an exception
instead. To be cloned, at minimum a system must support scalar
conversion. See system_scalar_conversion.</p>
</div>
<p>The result is never nullptr.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[Expression].CreateDefaultContext(self:</span> <span class="pre">pydrake.systems.framework.System_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.Context_[Expression]</span></span></dt>
<dd><p>This convenience method allocates a context using AllocateContext()
and sets its default values using SetDefaultContext().</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[Expression].DeclareInputPort(self:</span> <span class="pre">pydrake.systems.framework.System_[Expression],</span> <span class="pre">name:</span> <span class="pre">Union[str,</span> <span class="pre">pydrake.systems.framework.UseDefaultName],</span> <span class="pre">type:</span> <span class="pre">pydrake.systems.framework.PortDataType,</span> <span class="pre">size:</span> <span class="pre">int,</span> <span class="pre">random_type:</span> <span class="pre">Optional[pydrake.common.RandomDistribution]</span> <span class="pre">=</span> <span class="pre">None)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.InputPort_[Expression]</span></span></dt>
<dd><p>Adds a port with the specified <code class="docutils literal notranslate"><span class="pre">type</span></code> and <code class="docutils literal notranslate"><span class="pre">size</span></code> to the input
topology.</p>
<p>Input port names must be unique for this system (passing in a
duplicate <code class="docutils literal notranslate"><span class="pre">name</span></code> will throw RuntimeError). If <code class="docutils literal notranslate"><span class="pre">name</span></code> is given as
kUseDefaultName, then a default value of e.g. “u2”, where 2 is the
input number will be provided. An empty <code class="docutils literal notranslate"><span class="pre">name</span></code> is not permitted.</p>
<p>If the port is intended to model a random noise or disturbance input,
<code class="docutils literal notranslate"><span class="pre">random_type</span></code> can (optionally) be used to label it as such; doing so
enables algorithms for design and analysis (e.g. state estimation) to
reason explicitly about randomness at the system level. All random
input ports are assumed to be statistically independent.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">name</span></code> must not be empty.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError for a duplicate port name.</strong> – </p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>the declared port.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[Expression].EvalAbstractInput(self:</span> <span class="pre">pydrake.systems.framework.System_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression],</span> <span class="pre">port_index:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.common.value.AbstractValue</span></span></dt>
<dd><p>Returns the value of the input port with the given <code class="docutils literal notranslate"><span class="pre">port_index</span></code> as
an AbstractValue, which is permitted for ports of any type. Causes the
value to become up to date first if necessary, delegating to our
parent Diagram. Returns a pointer to the port’s value, or nullptr if
the port is not connected. If you know the actual type, use one of the
more-specific signatures.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">port_index</span></code> selects an existing input port of this System.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>InputPort::Eval() (preferred)</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[Expression].EvalKineticEnergy(self:</span> <span class="pre">pydrake.systems.framework.System_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.symbolic.Expression</span></span></dt>
<dd><p>Returns a reference to the cached value of the kinetic energy (KE),
evaluating first if necessary using CalcKineticEnergy().</p>
<p>By definition here, kinetic energy depends only on “configuration” and
“velocity” (e.g. angular and translational velocity) of moving masses
which includes a subset of the state variables, and parameters that
affect configuration, velocities, or mass properties. The calculated
value may also be affected by the accuracy value supplied in the
Context. KE cannot depend explicitly on time (∂KE/∂t = 0) or input
port values (∂KE/∂u = 0).</p>
<p>Non-physical systems where KE is not meaningful will return KE = 0.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The Context whose configuration and velocity variables may be used
to evaluate kinetic energy.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">KE</span></code>:</dt><dd><p>The kinetic energy in joules (J) represented by the configuration
and velocity given in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcKineticEnergy()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[Expression].EvalPotentialEnergy(self:</span> <span class="pre">pydrake.systems.framework.System_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.symbolic.Expression</span></span></dt>
<dd><p>Returns a reference to the cached value of the potential energy (PE),
evaluating first if necessary using CalcPotentialEnergy().</p>
<p>By definition here, potential energy depends only on “configuration”
(e.g. orientation and position), which includes a subset of the state
variables, and parameters that affect configuration or conservative
forces (such as lengths and masses). The calculated value may also be
affected by the accuracy value supplied in the Context. PE cannot
depend explicitly on time (∂PE/∂t = 0), velocities (∂PE/∂v = 0), or
input port values (∂PE/∂u = 0).</p>
<p>Non-physical systems where PE is not meaningful will return PE = 0.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The Context whose configuration variables may be used to evaluate
potential energy.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">PE</span></code>:</dt><dd><p>The potential energy in joules (J) represented by the
configuration given in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcPotentialEnergy()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[Expression].EvalTimeDerivatives(self:</span> <span class="pre">pydrake.systems.framework.System_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.ContinuousState_[Expression]</span></span></dt>
<dd><p>Returns a reference to the cached value of the continuous state
variable time derivatives, evaluating first if necessary using
CalcTimeDerivatives().</p>
<p>This method returns the time derivatives ẋ꜀ of the continuous state
x꜀. The referenced return object will correspond elementwise with the
continuous state in the given Context. Thus, if the state in the
Context has second-order structure <code class="docutils literal notranslate"><span class="pre">x꜀</span> <span class="pre">=</span> <span class="pre">[q</span> <span class="pre">v</span> <span class="pre">z]</span></code>, that same
structure applies to the derivatives so we will have <code class="docutils literal notranslate"><span class="pre">ẋ꜀</span> <span class="pre">=</span> <span class="pre">[q̇</span> <span class="pre">̇v̇</span>
<span class="pre">ż]</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The Context whose time, input port, parameter, state, and accuracy
values may be used to evaluate the derivatives.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">xcdot</span></code>:</dt><dd><p>Time derivatives ẋ꜀ of x꜀ returned as a reference to an object of
the same type and size as <cite>context</cite>’s continuous state.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>BatchEvalTimeDerivatives() for a batch version of this method.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcTimeDerivatives(), CalcImplicitTimeDerivativesResidual(),
get_time_derivatives_cache_entry()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[Expression].EvalUniquePeriodicDiscreteUpdate(self:</span> <span class="pre">pydrake.systems.framework.System_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.DiscreteValues_[Expression]</span></span></dt>
<dd><p>If this System contains a unique periodic timing for discrete update
events, this function executes the handlers for those periodic events
to determine what their effect would be. Returns a reference to the
discrete variable cache entry containing what values the discrete
variables would have if these periodic events were triggered.</p>
<p>Note that this function <em>does not</em> change the value of the discrete
variables in the supplied Context. However, you can apply the result
to the Context like this:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="n">DiscreteValues</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">updated</span><span class="w"> </span><span class="o">=</span>
<span class="n">system</span><span class="p">.</span><span class="n">EvalUniquePeriodicDiscreteUpdate</span><span class="p">(</span><span class="n">context</span><span class="p">);</span>
<span class="n">context</span><span class="p">.</span><span class="n">SetDiscreteState</span><span class="p">(</span><span class="n">updated</span><span class="p">);</span>
</pre></div>
</div>
</details><p>You can write the updated values to a different Context than the one
you used to calculate the update; the requirement is only that the
discrete state in the destination has the same structure (number of
groups and size of each group).</p>
<p>You can use GetUniquePeriodicDiscreteUpdateAttribute() to check
whether you can call EvalUniquePeriodicDiscreteUpdate() safely, and to
find the unique periodic timing information (offset and period).</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Even if we find a unique discrete update timing as described
above, there may also be unrestricted updates performed with that
timing or other timings. (Unrestricted updates can modify any
state variables <em>including</em> discrete variables.) Also, there may
be trigger types other than periodic that can modify discrete
variables. This function does not attempt to look for any of
those; they are simply ignored. If you are concerned with those,
you can use GetPerStepEvents(), GetInitializationEvents(), and
GetPeriodicEvents() to get a more comprehensive picture of the
event landscape.</p>
</div>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The Context containing the current System state and the mutable
cache space into which the result is written. The current state is
<em>not</em> modified, though the cache entry may be updated.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A reference to the DiscreteValues cache space in <code class="docutils literal notranslate"><span class="pre">context</span></code>
containing the result of applying the discrete update event
handlers to the current discrete variable values.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The referenced cache entry is recalculated if anything in the
given Context has changed since last calculation. Subsequent calls
just return the already-calculated value.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if there is not exactly one periodic timing in this</strong> – </p></li>
<li><p><strong>System</strong><strong> (</strong><strong>which may be a Diagram</strong><strong>) </strong><strong>that triggers discrete update</strong> – </p></li>
<li><p><strong>events.</strong> – </p></li>
<li><p><strong>RuntimeError if it invokes an event handler that returns status</strong> – </p></li>
<li><p><strong>indicating failure.</strong> – </p></li>
</ul>
</dd>
</dl>
<p>&#64;par Implementation If recalculation is needed, copies the current
discrete state values into preallocated <code class="docutils literal notranslate"><span class="pre">context</span></code> cache space.
Applies the discrete update event handlers (in an unspecified order)
to the cache copy, possibly updating it. Returns a reference to the
possibly-updated cache space.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>BatchEvalUniquePeriodicDiscreteUpdate() for a batch version of
this method.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>GetUniquePeriodicDiscreteUpdateAttribute(), GetPeriodicEvents()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[Expression].EvalVectorInput(self:</span> <span class="pre">pydrake.systems.framework.System_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression],</span> <span class="pre">port_index:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.BasicVector_[Expression]</span></span></dt>
<dd><p>Returns the value of the vector-valued input port with the given
<code class="docutils literal notranslate"><span class="pre">port_index</span></code> as a BasicVector or a specific subclass <code class="docutils literal notranslate"><span class="pre">Vec</span></code> derived
from BasicVector. Causes the value to become up to date first if
necessary. See EvalAbstractInput() for more information.</p>
<p>The result is returned as a pointer to the input port’s value of type
<code class="docutils literal notranslate"><span class="pre">Vec&lt;T&gt;</span></code> or nullptr if the port is not connected.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">port_index</span></code> selects an existing input port of this System.</p>
</dd>
<dt>Precondition:</dt><dd><p>the port must have been declared to be vector-valued.</p>
</dd>
<dt>Precondition:</dt><dd><p>the port’s value must be of type Vec&lt;T&gt;.</p>
</dd>
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">Vec</span></code>:</dt><dd><p>The template type of the input vector, which must be a subclass of
BasicVector.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[Expression].ExecuteForcedEvents(self:</span> <span class="pre">pydrake.systems.framework.System_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression],</span> <span class="pre">publish:</span> <span class="pre">bool</span> <span class="pre">=</span> <span class="pre">True)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>This method triggers all of the forced events registered with this
System (which might be a Diagram). Ordering and status return handling
mimic the Simulator: unrestricted events are processed first, then
discrete update events, then publish events. “Reached termination”
status returns are ignored.</p>
<p>An option is provided to suppress publish events. This can be useful,
for example, to update state in a Diagram without triggering a
visualization.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The Context supplied to the handlers and modified in place on
return.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if it invokes an event handler that returns status</strong> – </p></li>
<li><p><strong>indicating failure.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[Expression].ExecuteInitializationEvents(self:</span> <span class="pre">pydrake.systems.framework.System_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>This method triggers all of the initialization events returned by
GetInitializationEvents(). The method allocates temporary storage to
perform the updates, and is intended only as a convenience method for
callers who do not want to use the full Simulator workflow.</p>
<p>Note that this is not fully equivalent to Simulator::Initialize()
because <em>only</em> initialization events are handled here, while
Simulator::Initialize() also processes other events associated with
time zero. Also, “reached termination” returns are ignored here.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The Context supplied to the handlers and modified in place on
return.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if it invokes an event handler that returns status</strong> – </p></li>
<li><p><strong>indicating failure.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[Expression].FixInputPortsFrom(self:</span> <span class="pre">pydrake.systems.framework.System_[Expression],</span> <span class="pre">other_system:</span> <span class="pre">pydrake.systems.framework.System,</span> <span class="pre">other_context:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">target_context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Fixes all of the input ports in <code class="docutils literal notranslate"><span class="pre">target_context</span></code> to their current
values in <code class="docutils literal notranslate"><span class="pre">other_context</span></code>, as evaluated by <code class="docutils literal notranslate"><span class="pre">other_system</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError unless other_context and target_context both</strong> – </p></li>
<li><p><strong>have the same shape as this System</strong><strong>, </strong><strong>and the other_system.</strong> – </p></li>
<li><p><strong>Ignores disconnected inputs.</strong> – </p></li>
<li><p><strong>RuntimeError if this system's scalar type T != double and</strong> – </p></li>
<li><p><strong>other_system` has any abstract input ports whose contained typ</strong> – </p></li>
<li><p><strong>depends on scalar type.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[Expression].ForcedPublish(self:</span> <span class="pre">pydrake.systems.framework.System_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>(Advanced) Manually triggers any PublishEvent that has trigger type
kForced. Invokes the publish event dispatcher on this System with the
given Context.</p>
<p>The default dispatcher will invoke the handlers (if any) associated
with each force-triggered event.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>There will always be at least one force-triggered event, though
with no associated handler (so will do nothing when triggered).</p>
</div>
<p>The Simulator can be configured to call this in
Simulator::Initialize() and at the start of each continuous
integration step. See the Simulator API for more details.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if it invokes an event handler that returns status</strong> – </p></li>
<li><p><strong>indicating failure.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>Publish(), CalcForcedDiscreteVariableUpdate(),
CalcForcedUnrestrictedUpdate()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[Expression].get_input_port(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>get_input_port(self: pydrake.systems.framework.System_[Expression], port_index: int, warn_deprecated: bool = True) -&gt; pydrake.systems.framework.InputPort_[Expression]</p></li>
</ol>
<p>Returns the typed input port at index <code class="docutils literal notranslate"><span class="pre">port_index</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">warn_deprecated</span></code>:</dt><dd><p>Whether or not to print a warning in case the port was marked as
deprecated.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>get_input_port(self: pydrake.systems.framework.System_[Expression]) -&gt; pydrake.systems.framework.InputPort_[Expression]</p></li>
</ol>
<p>Convenience method for the case of exactly one input port. This
function ignores deprecated ports, unless there is only one port in
which case it will return the deprecated port.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[Expression].get_output_port(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>get_output_port(self: pydrake.systems.framework.System_[Expression], port_index: int, warn_deprecated: bool = True) -&gt; pydrake.systems.framework.OutputPort_[Expression]</p></li>
</ol>
<p>Returns the typed output port at index <code class="docutils literal notranslate"><span class="pre">port_index</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">warn_deprecated</span></code>:</dt><dd><p>Whether or not to print a warning in case the port was marked as
deprecated.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>get_output_port(self: pydrake.systems.framework.System_[Expression]) -&gt; pydrake.systems.framework.OutputPort_[Expression]</p></li>
</ol>
<p>Convenience method for the case of exactly one output port. This
function ignores deprecated ports, unless there is only one port in
which case it will return the deprecated port.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[Expression].get_system_scalar_converter(self:</span> <span class="pre">pydrake.systems.framework.System_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.SystemScalarConverter</span></span></dt>
<dd><p>(Advanced) Returns the SystemScalarConverter for this object. This is
an expert-level API intended for framework authors. Most users should
prefer the convenience helpers such as System::ToAutoDiffXd.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[Expression].GetInputPort(self:</span> <span class="pre">pydrake.systems.framework.System_[Expression],</span> <span class="pre">port_name:</span> <span class="pre">str)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.InputPort_[Expression]</span></span></dt>
<dd><p>Returns the typed input port with the unique name <code class="docutils literal notranslate"><span class="pre">port_name</span></code>. The
current implementation performs a linear search over strings; prefer
get_input_port() when performance is a concern.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if port_name is not found.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[Expression].GetMutableSubsystemContext(self:</span> <span class="pre">pydrake.systems.framework.System_[Expression],</span> <span class="pre">subsystem:</span> <span class="pre">pydrake.systems.framework.System_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.Context_[Expression]</span></span></dt>
<dd><p>Returns a mutable reference to the subcontext that corresponds to the
contained System <code class="docutils literal notranslate"><span class="pre">subsystem</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if subsystem not contained in this System.</strong> – </p>
</dd>
</dl>
<dl class="simple">
<dt>Precondition:</dt><dd><p>The given <code class="docutils literal notranslate"><span class="pre">context</span></code> is valid for use with <code class="docutils literal notranslate"><span class="pre">this</span></code> System.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[Expression].GetMyContextFromRoot(self:</span> <span class="pre">pydrake.systems.framework.System_[Expression],</span> <span class="pre">root_context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.Context_[Expression]</span></span></dt>
<dd><p>Returns the mutable subsystem context for <code class="docutils literal notranslate"><span class="pre">this</span></code> system, given a
root context.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>GetMyContextFromRoot()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[Expression].GetMyMutableContextFromRoot(self:</span> <span class="pre">pydrake.systems.framework.System_[Expression],</span> <span class="pre">root_context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.Context_[Expression]</span></span></dt>
<dd><p>Returns the mutable subsystem context for <code class="docutils literal notranslate"><span class="pre">this</span></code> system, given a
root context.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>GetMyContextFromRoot()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[Expression].GetOutputPort(self:</span> <span class="pre">pydrake.systems.framework.System_[Expression],</span> <span class="pre">port_name:</span> <span class="pre">str)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.OutputPort_[Expression]</span></span></dt>
<dd><p>Returns the typed output port with the unique name <code class="docutils literal notranslate"><span class="pre">port_name</span></code>. The
current implementation performs a linear search over strings; prefer
get_output_port() when performance is a concern.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if port_name is not found.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[Expression].GetSubsystemContext(self:</span> <span class="pre">pydrake.systems.framework.System_[Expression],</span> <span class="pre">subsystem:</span> <span class="pre">pydrake.systems.framework.System_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.Context_[Expression]</span></span></dt>
<dd><p>Returns a mutable reference to the subcontext that corresponds to the
contained System <code class="docutils literal notranslate"><span class="pre">subsystem</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if subsystem not contained in this System.</strong> – </p>
</dd>
</dl>
<dl class="simple">
<dt>Precondition:</dt><dd><p>The given <code class="docutils literal notranslate"><span class="pre">context</span></code> is valid for use with <code class="docutils literal notranslate"><span class="pre">this</span></code> System.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[Expression].GetUniquePeriodicDiscreteUpdateAttribute(self:</span> <span class="pre">pydrake.systems.framework.System_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">Optional[pydrake.systems.framework.PeriodicEventData]</span></span></dt>
<dd><p>Determines whether there exists a unique periodic timing (offset and
period) that triggers one or more discrete update events (and, if so,
returns that unique periodic timing). Thus, this method can be used
(1) as a test to determine whether a system’s dynamics are at least
partially governed by difference equations, and (2) to obtain the
difference equation update times. Use
EvalUniquePeriodicDiscreteUpdate() if you want to determine the actual
effects of triggering these events.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Even if we find a unique discrete update timing as described
above, there may also be unrestricted updates performed with that
timing or other timings. (Unrestricted updates can modify any
state variables <em>including</em> discrete variables.) Also, there may
be trigger types other than periodic that can modify discrete
variables. This function does not attempt to look for any of
those; they are simply ignored. If you are concerned with those,
you can use GetPerStepEvents(), GetInitializationEvents(), and
GetPeriodicEvents() to get a more comprehensive picture of the
event landscape.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>optional&lt;PeriodicEventData&gt; Contains the unique periodic trigger
timing if it exists, otherwise <code class="docutils literal notranslate"><span class="pre">nullopt</span></code>.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>EvalUniquePeriodicDiscreteUpdate(), IsDifferenceEquationSystem()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[Expression].GetWitnessFunctions(self:</span> <span class="pre">pydrake.systems.framework.System_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">list[pydrake.systems.framework.WitnessFunction_[Expression]]</span></span></dt>
<dd><p>Derived classes can override this method to provide witness functions
active for the given state. The default implementation does nothing.
On entry to this function, the context will have already been
validated and the vector of witness functions will have been validated
to be both empty and non-null.
Note: The above is for the C++ documentation. For Python, use
<cite>witnesses = GetWitnessFunctions(context)</cite></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[Expression].HasAnyDirectFeedthrough(self:</span> <span class="pre">pydrake.systems.framework.System_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if any of the inputs to the system might be directly
fed through to any of its outputs and <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[Expression].HasDirectFeedthrough(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>HasDirectFeedthrough(self: pydrake.systems.framework.System_[Expression], output_port: int) -&gt; bool</p></li>
</ol>
<p>Returns true if there might be direct-feedthrough from any input port
to the given <code class="docutils literal notranslate"><span class="pre">output_port</span></code>, and false otherwise.</p>
<ol class="arabic simple" start="2">
<li><p>HasDirectFeedthrough(self: pydrake.systems.framework.System_[Expression], input_port: int, output_port: int) -&gt; bool</p></li>
</ol>
<p>Returns true if there might be direct-feedthrough from the given
<code class="docutils literal notranslate"><span class="pre">input_port</span></code> to the given <code class="docutils literal notranslate"><span class="pre">output_port</span></code>, and false otherwise.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[Expression].HasInputPort(self:</span> <span class="pre">pydrake.systems.framework.System_[Expression],</span> <span class="pre">port_name:</span> <span class="pre">str)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns true iff the system has an InputPort of the given
<code class="docutils literal notranslate"><span class="pre">port_name</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[Expression].HasOutputPort(self:</span> <span class="pre">pydrake.systems.framework.System_[Expression],</span> <span class="pre">port_name:</span> <span class="pre">str)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns true iff the system has an OutputPort of the given
<code class="docutils literal notranslate"><span class="pre">port_name</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[Expression].IsDifferenceEquationSystem(self:</span> <span class="pre">pydrake.systems.framework.System_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">tuple[bool,</span> <span class="pre">float]</span></span></dt>
<dd><p>Returns true iff the state dynamics of this system are governed
exclusively by a difference equation on a single discrete state group
and with a unique periodic update (having zero offset). E.g., it is
amenable to analysis of the form:</p>
<p>x[n+1] = f(n, x[n], u[n], w[n]; p)</p>
<p>where t is time, x is (discrete) state, u is a vector input, w is
random (disturbance) input, and p are parameters. Note that we do NOT
consider the number of input ports here, because in practice many
systems of interest (e.g. MultibodyPlant) have input ports that are
safely treated as constant during the analysis. Consider using
get_input_port_selection() to choose one.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>In determining whether this system is governed as above, we do not
consider unrestricted updates nor any update events that have
trigger types other than periodic. See
GetUniquePeriodicDiscreteUpdateAttribute() for more information.</p>
</div>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">time_period</span></code>:</dt><dd><p>if non-null, then iff the function returns <code class="docutils literal notranslate"><span class="pre">True</span></code>, then
time_period is set to the period data returned from
GetUniquePeriodicDiscreteUpdateAttribute(). If the function
returns <code class="docutils literal notranslate"><span class="pre">False</span></code> (the system is not a difference equation
system), then <code class="docutils literal notranslate"><span class="pre">time_period</span></code> does not receive a value.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>GetUniquePeriodicDiscreteUpdateAttribute()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>EvalUniquePeriodicDiscreteUpdate()</p>
</div>
<p>Note: The above is for the C++ documentation. For Python, use
<cite>is_diff_eq, period = IsDifferenceEquationSystem()</cite></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[Expression].IsDifferentialEquationSystem(self:</span> <span class="pre">pydrake.systems.framework.System_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns true iff the state dynamics of this system are governed
exclusively by a differential equation. E.g., it is amenable to
analysis of the form:</p>
<p>ẋ = f(t, x(t), u(t), w(t); p),</p>
<p>where t is time, x is (continuous) state, u is a vector input, w is
random (disturbance) input, and p are parameters. This requires that
it has no discrete nor abstract states, and no abstract input ports.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>In determining whether this system is governed as above, we do not
consider unrestricted updates which could potentially update the
state.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[Expression].num_constraints(self:</span> <span class="pre">pydrake.systems.framework.System_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the number of constraints specified for the system.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[Expression].SetDefaultContext(self:</span> <span class="pre">pydrake.systems.framework.System_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets Context fields to their default values. User code should not
override.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[Expression].SetRandomContext(self:</span> <span class="pre">pydrake.systems.framework.System_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression],</span> <span class="pre">generator:</span> <span class="pre">pydrake.common.RandomGenerator)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets Context fields to random values. User code should not override.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[Expression].ToAutoDiffXd(self:</span> <span class="pre">pydrake.systems.framework.System_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.System_[AutoDiffXd]</span></span></dt>
<dd><p>Creates a deep copy of this System, transmogrified to use the autodiff
scalar type, with a dynamic-sized vector of partial derivatives. The
result is never nullptr.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if this System does not support autodiff</strong> – </p>
</dd>
</dl>
<p>See system_scalar_conversion for detailed background and examples
related to scalar-type conversion support.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[Expression].ToAutoDiffXdMaybe(self:</span> <span class="pre">pydrake.systems.framework.System_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.System_[AutoDiffXd]</span></span></dt>
<dd><p>Creates a deep copy of this system exactly like ToAutoDiffXd(), but
returns nullptr if this System does not support autodiff, instead of
throwing an exception.</p>
</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[Expression].ToScalarType</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">ToScalarType[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ToScalarType[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ToScalarType[Expression]</span></code></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[Expression].ToScalarType[AutoDiffXd](self:</span> <span class="pre">pydrake.systems.framework.System_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.System_[AutoDiffXd]</span></span></dt>
<dd><p>Creates a deep copy of this System, transmogrified to use the scalar
type selected by a template parameter. The result is never nullptr.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if this System does not support the destination type.</strong> – </p>
</dd>
</dl>
<dl class="simple">
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">U</span></code>:</dt><dd><p>The destination scalar type. For a list of supported types, see
the default_scalars “default scalars”.</p>
</dd>
</dl>
<p>See system_scalar_conversion for detailed background and examples
related to scalar-type conversion support.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[Expression].ToScalarType[Expression](self:</span> <span class="pre">pydrake.systems.framework.System_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.System_[Expression]</span></span></dt>
<dd><p>Creates a deep copy of this System, transmogrified to use the scalar
type selected by a template parameter. The result is never nullptr.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if this System does not support the destination type.</strong> – </p>
</dd>
</dl>
<dl class="simple">
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">U</span></code>:</dt><dd><p>The destination scalar type. For a list of supported types, see
the default_scalars “default scalars”.</p>
</dd>
</dl>
<p>See system_scalar_conversion for detailed background and examples
related to scalar-type conversion support.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[Expression].ToScalarType[float](self:</span> <span class="pre">pydrake.systems.framework.System_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.System</span></span></dt>
<dd><p>Creates a deep copy of this System, transmogrified to use the scalar
type selected by a template parameter. The result is never nullptr.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if this System does not support the destination type.</strong> – </p>
</dd>
</dl>
<dl class="simple">
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">U</span></code>:</dt><dd><p>The destination scalar type. For a list of supported types, see
the default_scalars “default scalars”.</p>
</dd>
</dl>
<p>See system_scalar_conversion for detailed background and examples
related to scalar-type conversion support.</p>
</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[Expression].ToScalarTypeMaybe</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">ToScalarTypeMaybe[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ToScalarTypeMaybe[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ToScalarTypeMaybe[Expression]</span></code></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[Expression].ToScalarTypeMaybe[AutoDiffXd](self:</span> <span class="pre">pydrake.systems.framework.System_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.System_[AutoDiffXd]</span></span></dt>
<dd><p>Creates a deep copy of this system exactly like ToScalarType(), but
returns nullptr if this System does not support the destination type,
instead of throwing an exception.</p>
<dl class="simple">
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">U</span></code>:</dt><dd><p>The destination scalar type. For a list of supported types, see
the default_scalars “default scalars”.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[Expression].ToScalarTypeMaybe[Expression](self:</span> <span class="pre">pydrake.systems.framework.System_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.System_[Expression]</span></span></dt>
<dd><p>Creates a deep copy of this system exactly like ToScalarType(), but
returns nullptr if this System does not support the destination type,
instead of throwing an exception.</p>
<dl class="simple">
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">U</span></code>:</dt><dd><p>The destination scalar type. For a list of supported types, see
the default_scalars “default scalars”.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[Expression].ToScalarTypeMaybe[float](self:</span> <span class="pre">pydrake.systems.framework.System_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.System</span></span></dt>
<dd><p>Creates a deep copy of this system exactly like ToScalarType(), but
returns nullptr if this System does not support the destination type,
instead of throwing an exception.</p>
<dl class="simple">
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">U</span></code>:</dt><dd><p>The destination scalar type. For a list of supported types, see
the default_scalars “default scalars”.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[Expression].ToSymbolic(self:</span> <span class="pre">pydrake.systems.framework.System_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.System_[Expression]</span></span></dt>
<dd><p>Creates a deep copy of this System, transmogrified to use the symbolic
scalar type. The result is never nullptr.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if this System does not support symbolic</strong> – </p>
</dd>
</dl>
<p>See system_scalar_conversion for detailed background and examples
related to scalar-type conversion support.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">System_[Expression].ToSymbolicMaybe(self:</span> <span class="pre">pydrake.systems.framework.System_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.System_[Expression]</span></span></dt>
<dd><p>Creates a deep copy of this system exactly like ToSymbolic(), but
returns nullptr if this System does not support symbolic, instead of
throwing an exception.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemBase</span></span></dt>
<dd><p>Provides non-templatized functionality shared by the templatized
System classes.</p>
<p>Terminology: in general a Drake System is a tree structure composed of
“subsystems”, which are themselves System objects. The corresponding
Context is a parallel tree structure composed of “subcontexts”, which
are themselves Context objects. There is a one-to-one correspondence
between subsystems and subcontexts. Within a given System (Context),
its child subsystems (subcontexts) are indexed using a SubsystemIndex;
there is no separate SubcontextIndex since the numbering must be
identical.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemBase.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemBase.abstract_parameter_ticket(self:</span> <span class="pre">pydrake.systems.framework.SystemBase,</span> <span class="pre">index:</span> <span class="pre">pydrake.systems.framework.AbstractParameterIndex)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.DependencyTicket</span></span></dt>
<dd><p>Returns a ticket indicating dependence on a particular abstract
parameter paᵢ.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>pa_ticket() to obtain a ticket for <em>all</em> abstract parameters.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemBase.abstract_state_ticket(self:</span> <span class="pre">pydrake.systems.framework.SystemBase,</span> <span class="pre">index:</span> <span class="pre">pydrake.systems.framework.AbstractStateIndex)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.DependencyTicket</span></span></dt>
<dd><p>Returns a ticket indicating dependence on a particular abstract state
variable xaᵢ.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>xa_ticket() to obtain a ticket for <em>all</em> abstract variables.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemBase.accuracy_ticket()</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.DependencyTicket</span></span></dt>
<dd><p>Returns a ticket indicating dependence on the accuracy setting in the
Context. This is the same ticket for all systems and refers to the
same accuracy value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemBase.all_input_ports_ticket()</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.DependencyTicket</span></span></dt>
<dd><p>Returns a ticket indicating dependence on <em>all</em> input ports u of this
system.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>input_port_ticket() to obtain a ticket for just one input port.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemBase.all_parameters_ticket()</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.DependencyTicket</span></span></dt>
<dd><p>Returns a ticket indicating dependence on <em>all</em> parameters p in this
system, including numeric parameters pn, and abstract parameters pa.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemBase.all_sources_except_input_ports_ticket()</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.DependencyTicket</span></span></dt>
<dd><p>Returns a ticket indicating dependence on every possible independent
source value <em>except</em> input ports. This can be helpful in avoiding the
incorrect appearance of algebraic loops in a Diagram (those always
involve apparent input port dependencies). For an output port, use
this ticket plus tickets for just the input ports on which the output
computation <em>actually</em> depends. The sources included in this ticket
are: time, accuracy, state, and parameters. Note that dependencies on
cache entries are <em>not</em> included here. Usually that won’t matter since
cache entries typically depend on at least one of time, accuracy,
state, or parameters so will be invalidated for the same reason the
current computation is. However, for a computation that depends on a
cache entry that depends only on input ports, be sure that you have
included those input ports in the dependency list, or include a direct
dependency on the cache entry.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>input_port_ticket() to obtain a ticket for an input port.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>cache_entry_ticket() to obtain a ticket for a cache entry.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>all_sources_ticket() to also include all input ports as
dependencies.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemBase.all_sources_ticket()</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.DependencyTicket</span></span></dt>
<dd><p>Returns a ticket indicating dependence on every possible independent
source value, including time, accuracy, state, input ports, and
parameters (but not cache entries). This is the default dependency for
computations that have not specified anything more refined. It is
equivalent to the set <code class="docutils literal notranslate"><span class="pre">{all_sources_except_input_ports_ticket(),</span>
<span class="pre">all_input_ports_ticket()}</span></code>.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>cache_entry_ticket() to obtain a ticket for a cache entry.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemBase.all_state_ticket()</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.DependencyTicket</span></span></dt>
<dd><p>Returns a ticket indicating dependence on <em>all</em> state variables x in
this system, including continuous variables xc, discrete (numeric)
variables xd, and abstract state variables xa. This does not imply
dependence on time, accuracy, parameters, or inputs; those must be
specified separately. If you mean to express dependence on all
possible value sources, use all_sources_ticket() instead.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemBase.cache_entry_ticket(self:</span> <span class="pre">pydrake.systems.framework.SystemBase,</span> <span class="pre">index:</span> <span class="pre">pydrake.systems.framework.CacheIndex)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.DependencyTicket</span></span></dt>
<dd><p>Returns a ticket indicating dependence on the cache entry indicated by
<code class="docutils literal notranslate"><span class="pre">index</span></code>. Note that cache entries are <em>not</em> included in the
<code class="docutils literal notranslate"><span class="pre">all_sources</span></code> ticket so must be listed separately.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">index</span></code> selects an existing cache entry in this System.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemBase.configuration_ticket()</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.DependencyTicket</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemBase.DeclareCacheEntry(self:</span> <span class="pre">pydrake.systems.framework.SystemBase,</span> <span class="pre">description:</span> <span class="pre">str,</span> <span class="pre">value_producer:</span> <span class="pre">pydrake.systems.framework.ValueProducer,</span> <span class="pre">prerequisites_of_calc:</span> <span class="pre">set[pydrake.systems.framework.DependencyTicket]</span> <span class="pre">=</span> <span class="pre">{DependencyTicket(15)})</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.CacheEntry</span></span></dt>
<dd><p>Declares a new CacheEntry in this System using the most generic form
of the calculation function. Prefer one of the more convenient
signatures below if you can. The new cache entry is assigned a unique
CacheIndex and DependencyTicket, which can be obtained from the
returned CacheEntry.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">description</span></code>:</dt><dd><p>A human-readable description of this cache entry, most useful for
debugging and documentation. Not interpreted in any way by Drake;
it is retained by the cache entry and used to generate the
description for the corresponding CacheEntryValue in the Context.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">value_producer</span></code>:</dt><dd><p>Provides the computation that maps from a given Context to the
current value that this cache entry should have, as well as a way
to allocate storage prior to the computation.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">prerequisites_of_calc</span></code>:</dt><dd><p>Provides the DependencyTicket list containing a ticket for <em>every</em>
Context value on which <code class="docutils literal notranslate"><span class="pre">calc_function</span></code> may depend when it
computes its result. Defaults to <code class="docutils literal notranslate"><span class="pre">{all_sources_ticket()}</span></code> if
unspecified. If the cache value is truly independent of the
Context (rare!) say so explicitly by providing the list
<code class="docutils literal notranslate"><span class="pre">{nothing_ticket()}</span></code>; an explicitly empty list <code class="docutils literal notranslate"><span class="pre">{}</span></code> is
forbidden.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a reference to the newly-created CacheEntry.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>RuntimeError if given an explicitly empty prerequisite list.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemBase.discrete_state_ticket(self:</span> <span class="pre">pydrake.systems.framework.SystemBase,</span> <span class="pre">index:</span> <span class="pre">pydrake.systems.framework.DiscreteStateIndex)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.DependencyTicket</span></span></dt>
<dd><p>Returns a ticket indicating dependence on a particular discrete state
variable xdᵢ (may be a vector). (We sometimes refer to this as a
“discrete variable group”.)</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>xd_ticket() to obtain a ticket for <em>all</em> discrete variables.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemBase.DoGetGraphvizFragment(self:</span> <span class="pre">pydrake.systems.framework.SystemBase,</span> <span class="pre">arg0:</span> <span class="pre">pydrake.systems.framework.SystemBase.GraphvizFragmentParams)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.SystemBase.GraphvizFragment</span></span></dt>
<dd><p>The NVI implementation of GetGraphvizFragment() for subclasses to
override if desired. The default behavior should be sufficient in most
cases.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemBase.get_cache_entry(self:</span> <span class="pre">pydrake.systems.framework.SystemBase,</span> <span class="pre">index:</span> <span class="pre">pydrake.systems.framework.CacheIndex)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.CacheEntry</span></span></dt>
<dd><p>Returns a reference to a CacheEntry given its <code class="docutils literal notranslate"><span class="pre">index</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemBase.get_name(self:</span> <span class="pre">pydrake.systems.framework.SystemBase)</span> <span class="pre">-&gt;</span> <span class="pre">str</span></span></dt>
<dd><p>Returns the name last supplied to set_name(), if any. Diagrams built
with DiagramBuilder will always have a default name for every
contained subsystem for which no user-provided name is available.
Systems created by copying with a scalar type change have the same
name as the source system. An empty string is returned if no name has
been set.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemBase.GetGraphvizFragment(self:</span> <span class="pre">pydrake.systems.framework.SystemBase,</span> <span class="pre">max_depth:</span> <span class="pre">Optional[int]</span> <span class="pre">=</span> <span class="pre">None,</span> <span class="pre">options:</span> <span class="pre">dict[str,</span> <span class="pre">str]</span> <span class="pre">=</span> <span class="pre">{})</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.SystemBase.GraphvizFragment</span></span></dt>
<dd><p>(Advanced) Like GetGraphvizString() but does not wrap the string in a
<code class="docutils literal notranslate"><span class="pre">digraph</span> <span class="pre">{</span> <span class="pre">…</span> <span class="pre">}</span></code>. This is useful when merging the fragment into
another graph, and is how Diagram obtains the Graphviz content for its
subsystems. The parameters are identical to GetGraphvizString(). The
return value contains additional metadata beyond the Graphviz content,
to better support merging.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemBase.GetGraphvizString(self:</span> <span class="pre">pydrake.systems.framework.SystemBase,</span> <span class="pre">max_depth:</span> <span class="pre">Optional[int]</span> <span class="pre">=</span> <span class="pre">None,</span> <span class="pre">options:</span> <span class="pre">dict[str,</span> <span class="pre">str]</span> <span class="pre">=</span> <span class="pre">{})</span> <span class="pre">-&gt;</span> <span class="pre">str</span></span></dt>
<dd><p>Returns a Graphviz string describing this System. To render the
string, use the <a class="reference external" href="http://www.graphviz.org/">Graphviz</a> tool, <code class="docutils literal notranslate"><span class="pre">dot</span></code>.</p>
<p>Notes about the display conventions:</p>
<ul class="simple">
<li><p>The nodes of the graph are systems, and the solid edges are connections</p></li>
</ul>
<p>between system input and output ports.</p>
<ul class="simple">
<li><p>The class name of a System is shown in <strong>Bold</strong> atop the node.</p></li>
<li><p>Under the class name, if a System has been given a name via set_name(),</p></li>
</ul>
<p>it will be displayed as <code class="docutils literal notranslate"><span class="pre">name=...</span></code>.</p>
<ul class="simple">
<li><p>Systems can elect to display additional properties besides their name;</p></li>
</ul>
<p>see GraphvizFragmentParams::header_lines for implementation details.</p>
<ul class="simple">
<li><p>A Diagram’s input ports are shown with a</p></li>
</ul>
<p>&lt;span style=”border:2px solid blue;border-radius:4px”&gt;blue border&lt;/span&gt;
and output ports are shown with a
&lt;span style=”border:2px solid green;border-radius:4px”&gt;green border&lt;/span&gt;.</p>
<ul class="simple">
<li><p>Zero-sized ports are &lt;span style=”color:grey”&gt;greyed out&lt;/span&gt;.</p></li>
<li><p>Deprecated ports are &lt;strike&gt;struck through&lt;/strike&gt; and flagged with a</p></li>
</ul>
<p>headstone emoji (🪦) after their name.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">max_depth</span></code>:</dt><dd><p>Sets a limit to the depth of nested diagrams to visualize. Use
zero to render a diagram as a single system block.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">options</span></code>:</dt><dd><p>Arbitrary strings to request alterations to the output. Options
that are unknown will be silently skipped. These options are often
bespoke flags that are only understood by particular systems, but
Drake has one built-in flag that is generally applicable:
<code class="docutils literal notranslate"><span class="pre">&quot;split&quot;</span></code>. When set to <code class="docutils literal notranslate"><span class="pre">&quot;I/O&quot;</span></code>, the system will be added as
two nodes with all inputs on one node and all outputs on the
other; this is useful for systems that might otherwise cause
problematic visual cycles.</p>
</dd>
</dl>
<p>Options are applied only to this immediate system; they are not
inherited by the subsystems of a Diagram. To specify an option for a
Diagram’s subsystem, prefix the option name with the subsystem’s path,
e.g., use <code class="docutils literal notranslate"><span class="pre">&quot;plant/split&quot;=&quot;I/O&quot;</span></code> to set the <code class="docutils literal notranslate"><span class="pre">&quot;split&quot;</span></code> option on the
subsystem named <code class="docutils literal notranslate"><span class="pre">&quot;plant&quot;</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemBase.GetSystemName(self:</span> <span class="pre">pydrake.systems.framework.SystemBase)</span> <span class="pre">-&gt;</span> <span class="pre">str</span></span></dt>
<dd><p>Returns a human-readable name for this system, for use in messages and
logging. This will be the same as returned by get_name(), unless that
would be an empty string. In that case we return a non-unique
placeholder name, currently just “_” (a lone underscore).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemBase.GetSystemPathname(self:</span> <span class="pre">pydrake.systems.framework.SystemBase)</span> <span class="pre">-&gt;</span> <span class="pre">str</span></span></dt>
<dd><p>Generates and returns a human-readable full path name of this
subsystem, for use in messages and logging. The name starts from the
root System, with “::” delimiters between parent and child subsystems,
with the individual subsystems represented by their names as returned
by GetSystemName().</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemBase.GetSystemType(self:</span> <span class="pre">pydrake.systems.framework.SystemBase)</span> <span class="pre">-&gt;</span> <span class="pre">str</span></span></dt>
<dd><p>Returns the most-derived type of this concrete System object as a
human-readable string suitable for use in error messages. The format
is as generated by NiceTypeName and will include namespace
qualification if present.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>NiceTypeName for more specifics.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemBase.GraphvizFragment</span></span></dt>
<dd><p>(Advanced) The return type of GetGraphvizFragment().</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemBase.GraphvizFragment.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemBase.GraphvizFragment.fragments</span></span></dt>
<dd><p>The Graphviz content for this System. The fragments must be a valid
Graphviz figure when concatenated and then wrapped in a <code class="docutils literal notranslate"><span class="pre">digraph</span> <span class="pre">{</span> <span class="pre">…</span>
<span class="pre">}</span></code> or <code class="docutils literal notranslate"><span class="pre">subgraph</span> <span class="pre">{</span> <span class="pre">…</span> <span class="pre">}</span></code> stanza. During concatenation, no extra
newlines or any other kind of whitespace should be inserted. (This is
a list of strings, rather than a single string, to avoid redundant
string concatenation until the last moment when we return the final
GetGraphvizString().)</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemBase.GraphvizFragment.input_ports</span></span></dt>
<dd><p>The Graphviz IDs for this System’s input ports, to be used for adding
Graphviz edges. The i’th element is the ID for <code class="docutils literal notranslate"><span class="pre">get_input_port(i)</span></code>.
For a typical LeafSystem these will look like “s123:u0”, “s123:u1”, …
but for diagrams and other special cases they might vary.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemBase.GraphvizFragment.output_ports</span></span></dt>
<dd><p>The Graphviz IDs for this System’s output ports, to be used for adding
Graphviz edges. The i’th element is the ID for <code class="docutils literal notranslate"><span class="pre">get_output_port(i)</span></code>.
For a typical LeafSystem these will look like “s123:y0”, “s123:y1”, …
but for diagrams and other special cases they might vary.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemBase.GraphvizFragmentParams</span></span></dt>
<dd><p>(Advanced) The arguments to the protected method
DoGetGraphvizFragment(). This struct typically is only used by
subclasses of LeafSystem that need to customize their Graphviz
representation. These parameters constitute a polite request; a user’s
System’s implementation of DoGetGraphvizFragment() is not strictly
required to honor any of these parameters, but generally should
attempt to honor as many as possible.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemBase.GraphvizFragmentParams.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemBase.GraphvizFragmentParams.header_lines</span></span></dt>
<dd><p>The header line(s) to use for this Graphviz node’s table. The strings
in <code class="docutils literal notranslate"><span class="pre">header_lines</span></code> should not contain newlines; those are added
automatically, along with ``</p>
<p>`` breaks between lines.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemBase.GraphvizFragmentParams.max_depth</span></span></dt>
<dd><p>As per GetGraphvizString().</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemBase.GraphvizFragmentParams.node_id</span></span></dt>
<dd><p>The Graphviz ID to use for this node.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemBase.GraphvizFragmentParams.options</span></span></dt>
<dd><p>As per GetGraphvizString().</p>
</dd></dl>

</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemBase.implicit_time_derivatives_residual_size(self:</span> <span class="pre">pydrake.systems.framework.SystemBase)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the size of the implicit time derivatives residual vector. By
default this is the same as num_continuous_states() but a LeafSystem
can change it during construction via
LeafSystem::DeclareImplicitTimeDerivativesResidualSize().</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemBase.input_port_ticket(self:</span> <span class="pre">pydrake.systems.framework.SystemBase,</span> <span class="pre">index:</span> <span class="pre">pydrake.systems.framework.InputPortIndex)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.DependencyTicket</span></span></dt>
<dd><p>Returns a ticket indicating dependence on input port uᵢ indicated by
<code class="docutils literal notranslate"><span class="pre">index</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">index</span></code> selects an existing input port of this System.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemBase.ke_ticket()</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.DependencyTicket</span></span></dt>
<dd><p>Returns a ticket for the cache entry that holds the kinetic energy
calculation.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>System::EvalKineticEnergy()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemBase.kinematics_ticket()</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.DependencyTicket</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemBase.nothing_ticket()</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.DependencyTicket</span></span></dt>
<dd><p>Returns a ticket indicating that a computation does not depend on
<em>any</em> source value; that is, it is a constant. If this appears in a
prerequisite list, it must be the only entry.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemBase.num_abstract_parameters(self:</span> <span class="pre">pydrake.systems.framework.SystemBase)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the number of declared abstract parameters.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemBase.num_abstract_states(self:</span> <span class="pre">pydrake.systems.framework.SystemBase)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the number of declared abstract state variables.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemBase.num_continuous_states(self:</span> <span class="pre">pydrake.systems.framework.SystemBase)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the number of declared continuous state variables.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemBase.num_discrete_state_groups(self:</span> <span class="pre">pydrake.systems.framework.SystemBase)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the number of declared discrete state groups (each group is a
vector-valued discrete state variable).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemBase.num_input_ports(self:</span> <span class="pre">pydrake.systems.framework.SystemBase)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the number of input ports currently allocated in this System.
These are indexed from 0 to num_input_ports()-1.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemBase.num_numeric_parameter_groups(self:</span> <span class="pre">pydrake.systems.framework.SystemBase)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the number of declared numeric parameters (each of these is a
vector-valued parameter).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemBase.num_output_ports(self:</span> <span class="pre">pydrake.systems.framework.SystemBase)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the number of output ports currently allocated in this System.
These are indexed from 0 to num_output_ports()-1.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemBase.numeric_parameter_ticket(self:</span> <span class="pre">pydrake.systems.framework.SystemBase,</span> <span class="pre">index:</span> <span class="pre">pydrake.systems.framework.NumericParameterIndex)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.DependencyTicket</span></span></dt>
<dd><p>Returns a ticket indicating dependence on a particular numeric
parameter pnᵢ (may be a vector).</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>pn_ticket() to obtain a ticket for <em>all</em> numeric parameters.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemBase.pa_ticket()</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.DependencyTicket</span></span></dt>
<dd><p>Returns a ticket indicating dependence on all of the abstract
parameters pa in the current Context.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>abstract_parameter_ticket() to obtain a ticket for just one
abstract parameter.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemBase.pc_ticket()</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.DependencyTicket</span></span></dt>
<dd><p>Returns a ticket for the cache entry that holds the conservative power
calculation.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>System::EvalConservativePower()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemBase.pe_ticket()</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.DependencyTicket</span></span></dt>
<dd><p>Returns a ticket for the cache entry that holds the potential energy
calculation.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>System::EvalPotentialEnergy()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemBase.pn_ticket()</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.DependencyTicket</span></span></dt>
<dd><p>Returns a ticket indicating dependence on all of the numerical
parameters in the current Context.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>numeric_parameter_ticket() to obtain a ticket for just one numeric
parameter.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemBase.pnc_ticket()</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.DependencyTicket</span></span></dt>
<dd><p>Returns a ticket for the cache entry that holds the non-conservative
power calculation.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>System::EvalNonConservativePower()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemBase.q_ticket()</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.DependencyTicket</span></span></dt>
<dd><p>Returns a ticket indicating that a computation depends on
configuration state variables q. There is no ticket representing just
one of the state variables qᵢ.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemBase.set_name(self:</span> <span class="pre">pydrake.systems.framework.SystemBase,</span> <span class="pre">name:</span> <span class="pre">str)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the name of the system. Do not use the path delimiter character
‘:’ in the name. When creating a Diagram, names of sibling subsystems
should be unique. DiagramBuilder uses this method to assign a unique
default name if none is provided.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemBase.time_ticket()</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.DependencyTicket</span></span></dt>
<dd><p>Returns a ticket indicating dependence on time. This is the same
ticket for all systems and refers to the same time value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemBase.v_ticket()</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.DependencyTicket</span></span></dt>
<dd><p>Returns a ticket indicating dependence on velocity state variables v.
This does <em>not</em> also indicate a dependence on configuration variables
q – you must list that explicitly or use kinematics_ticket() instead.
There is no ticket representing just one of the state variables vᵢ.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemBase.ValidateContext(self:</span> <span class="pre">pydrake.systems.framework.SystemBase,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.ContextBase)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Checks whether the given context was created for this system.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is sufficiently fast for performance sensitive code.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if the System Ids don't match.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemBase.xa_ticket()</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.DependencyTicket</span></span></dt>
<dd><p>Returns a ticket indicating dependence on all of the abstract state
variables in the current Context.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>abstract_state_ticket() to obtain a ticket for just one abstract
state variable.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemBase.xc_ticket()</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.DependencyTicket</span></span></dt>
<dd><p>Returns a ticket indicating dependence on <em>all</em> of the continuous
state variables q, v, or z.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemBase.xcdot_ticket()</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.DependencyTicket</span></span></dt>
<dd><p>Returns a ticket for the cache entry that holds time derivatives of
the continuous variables.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>EvalTimeDerivatives()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemBase.xd_ticket()</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.DependencyTicket</span></span></dt>
<dd><p>Returns a ticket indicating dependence on all of the numerical
discrete state variables, in any discrete variable group.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>discrete_state_ticket() to obtain a ticket for just one discrete
state variable.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemBase.z_ticket()</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.DependencyTicket</span></span></dt>
<dd><p>Returns a ticket indicating dependence on any or all of the
miscellaneous continuous state variables z. There is no ticket
representing just one of the state variables zᵢ.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemConstraintIndex</span></span></dt>
<dd><dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemConstraintIndex.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.systems.framework.SystemConstraintIndex) -&gt; None</p></li>
</ol>
<p>Default constructor; the result is an <em>invalid</em> index. This only
exists to serve applications which require a default constructor.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.systems.framework.SystemConstraintIndex, arg0: int) -&gt; None</p></li>
</ol>
<p>Construction from a non-negative <code class="docutils literal notranslate"><span class="pre">int</span></code> value. The value must lie in
the range of [0, 2³¹). Constructor only promises to test validity in
Debug build.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemConstraintIndex.is_valid(self:</span> <span class="pre">pydrake.systems.framework.SystemConstraintIndex)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Reports if the index is valid–the only operation on an invalid index
that doesn’t throw an exception in Debug builds.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemOutput</span></span></dt>
<dd><p>Conveniently stores a snapshot of the values of every output port of a
System. There is framework support for allocating the right types and
filling them in but otherwise this is not used internally. Note that
there is never any live connection between a SystemOutput object and
the System whose output values it has captured.</p>
<p>A <code class="docutils literal notranslate"><span class="pre">SystemOutput&lt;T&gt;</span></code> object can only be obtained using
<code class="docutils literal notranslate"><span class="pre">System&lt;T&gt;::AllocateOutput()</span></code> or by copying an existing SystemOutput
object.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">SystemOutput_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemOutput.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemOutput.get_data(self:</span> <span class="pre">pydrake.systems.framework.SystemOutput,</span> <span class="pre">arg0:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.common.value.AbstractValue</span></span></dt>
<dd><p>Returns the last-saved value of output port <code class="docutils literal notranslate"><span class="pre">index</span></code> as an
AbstractValue. This works for any output port regardless of it actual
type.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemOutput.get_vector_data(self:</span> <span class="pre">pydrake.systems.framework.SystemOutput,</span> <span class="pre">arg0:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.BasicVector</span></span></dt>
<dd><p>Returns the last-saved value of output port <code class="docutils literal notranslate"><span class="pre">index</span></code> as a
<code class="docutils literal notranslate"><span class="pre">BasicVector&lt;T&gt;</span></code>, although the actual concrete type is preserved
from the actual output port.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if the port is not vector-valued.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemOutput.num_ports(self:</span> <span class="pre">pydrake.systems.framework.SystemOutput)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the number of output ports specified for this SystemOutput
during allocation.</p>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemOutput_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">SystemOutput_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">SystemOutput_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">SystemOutput_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemOutput_[AutoDiffXd]</span></span></dt>
<dd><p>Conveniently stores a snapshot of the values of every output port of a
System. There is framework support for allocating the right types and
filling them in but otherwise this is not used internally. Note that
there is never any live connection between a SystemOutput object and
the System whose output values it has captured.</p>
<p>A <code class="docutils literal notranslate"><span class="pre">SystemOutput&lt;T&gt;</span></code> object can only be obtained using
<code class="docutils literal notranslate"><span class="pre">System&lt;T&gt;::AllocateOutput()</span></code> or by copying an existing SystemOutput
object.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemOutput_[AutoDiffXd].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemOutput_[AutoDiffXd].get_data(self:</span> <span class="pre">pydrake.systems.framework.SystemOutput_[AutoDiffXd],</span> <span class="pre">arg0:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.common.value.AbstractValue</span></span></dt>
<dd><p>Returns the last-saved value of output port <code class="docutils literal notranslate"><span class="pre">index</span></code> as an
AbstractValue. This works for any output port regardless of it actual
type.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemOutput_[AutoDiffXd].get_vector_data(self:</span> <span class="pre">pydrake.systems.framework.SystemOutput_[AutoDiffXd],</span> <span class="pre">arg0:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.BasicVector_[AutoDiffXd]</span></span></dt>
<dd><p>Returns the last-saved value of output port <code class="docutils literal notranslate"><span class="pre">index</span></code> as a
<code class="docutils literal notranslate"><span class="pre">BasicVector&lt;T&gt;</span></code>, although the actual concrete type is preserved
from the actual output port.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if the port is not vector-valued.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemOutput_[AutoDiffXd].num_ports(self:</span> <span class="pre">pydrake.systems.framework.SystemOutput_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the number of output ports specified for this SystemOutput
during allocation.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemOutput_[Expression]</span></span></dt>
<dd><p>Conveniently stores a snapshot of the values of every output port of a
System. There is framework support for allocating the right types and
filling them in but otherwise this is not used internally. Note that
there is never any live connection between a SystemOutput object and
the System whose output values it has captured.</p>
<p>A <code class="docutils literal notranslate"><span class="pre">SystemOutput&lt;T&gt;</span></code> object can only be obtained using
<code class="docutils literal notranslate"><span class="pre">System&lt;T&gt;::AllocateOutput()</span></code> or by copying an existing SystemOutput
object.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemOutput_[Expression].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemOutput_[Expression].get_data(self:</span> <span class="pre">pydrake.systems.framework.SystemOutput_[Expression],</span> <span class="pre">arg0:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.common.value.AbstractValue</span></span></dt>
<dd><p>Returns the last-saved value of output port <code class="docutils literal notranslate"><span class="pre">index</span></code> as an
AbstractValue. This works for any output port regardless of it actual
type.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemOutput_[Expression].get_vector_data(self:</span> <span class="pre">pydrake.systems.framework.SystemOutput_[Expression],</span> <span class="pre">arg0:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.BasicVector_[Expression]</span></span></dt>
<dd><p>Returns the last-saved value of output port <code class="docutils literal notranslate"><span class="pre">index</span></code> as a
<code class="docutils literal notranslate"><span class="pre">BasicVector&lt;T&gt;</span></code>, although the actual concrete type is preserved
from the actual output port.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if the port is not vector-valued.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemOutput_[Expression].num_ports(self:</span> <span class="pre">pydrake.systems.framework.SystemOutput_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the number of output ports specified for this SystemOutput
during allocation.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemScalarConverter</span></span></dt>
<dd><dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemScalarConverter.__init__(self:</span> <span class="pre">pydrake.systems.framework.SystemScalarConverter)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemScalarConverter.IsConvertible</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">IsConvertible[AutoDiffXd,float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">IsConvertible[Expression,float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">IsConvertible[float,AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">IsConvertible[Expression,AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">IsConvertible[float,Expression]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">IsConvertible[AutoDiffXd,Expression]</span></code></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemScalarConverter.IsConvertible[AutoDiffXd,Expression](self:</span> <span class="pre">pydrake.systems.framework.SystemScalarConverter)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns true iff this object can convert a System&lt;U&gt; into a System&lt;T&gt;,
i.e., whether Convert() will return non-null.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemScalarConverter.IsConvertible[AutoDiffXd,float](self:</span> <span class="pre">pydrake.systems.framework.SystemScalarConverter)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns true iff this object can convert a System&lt;U&gt; into a System&lt;T&gt;,
i.e., whether Convert() will return non-null.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemScalarConverter.IsConvertible[Expression,AutoDiffXd](self:</span> <span class="pre">pydrake.systems.framework.SystemScalarConverter)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns true iff this object can convert a System&lt;U&gt; into a System&lt;T&gt;,
i.e., whether Convert() will return non-null.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemScalarConverter.IsConvertible[Expression,float](self:</span> <span class="pre">pydrake.systems.framework.SystemScalarConverter)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns true iff this object can convert a System&lt;U&gt; into a System&lt;T&gt;,
i.e., whether Convert() will return non-null.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemScalarConverter.IsConvertible[float,AutoDiffXd](self:</span> <span class="pre">pydrake.systems.framework.SystemScalarConverter)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns true iff this object can convert a System&lt;U&gt; into a System&lt;T&gt;,
i.e., whether Convert() will return non-null.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemScalarConverter.IsConvertible[float,Expression](self:</span> <span class="pre">pydrake.systems.framework.SystemScalarConverter)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns true iff this object can convert a System&lt;U&gt; into a System&lt;T&gt;,
i.e., whether Convert() will return non-null.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemScalarConverter.SupportedConversionPairs</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemScalarConverter.SupportedScalars</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemVisitor</span></span></dt>
<dd><p>Provides a “Visitor Pattern” for System and Diagram. Rather than
adding more virtual methods to the System base class, or performing a
dynamic_cast to test if a System is a Diagram, you may use the visitor
pattern enabled by this class, e.g.:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">MySystemVisitor</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">SystemVisitor</span><span class="w"> </span><span class="p">{</span>
<span class="p">...</span>
<span class="p">}</span>

<span class="n">MySystemVisitor</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">visitor</span><span class="p">;</span>
<span class="n">system</span><span class="p">.</span><span class="n">Accept</span><span class="p">(</span><span class="n">visitor</span><span class="p">);</span>
</pre></div>
</div>
</details><p>will call the correct <code class="docutils literal notranslate"><span class="pre">Visit</span></code> overload.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method does <em>not</em> recurse through the subsystems of a
Diagram, but that is easy to do: just call Diagram::GetSystems()
in your visitor and then call Accept on the subsystems.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">SystemVisitor_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemVisitor.__init__(self:</span> <span class="pre">pydrake.systems.framework.SystemVisitor)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemVisitor.VisitDiagram(self:</span> <span class="pre">pydrake.systems.framework.SystemVisitor,</span> <span class="pre">diagram:</span> <span class="pre">pydrake.systems.framework.Diagram)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>This method will be called by System&lt;T&gt;::accept() if the System <em>is</em> a
Diagram&lt;T&gt;.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemVisitor.VisitSystem(self:</span> <span class="pre">pydrake.systems.framework.SystemVisitor,</span> <span class="pre">system:</span> <span class="pre">pydrake.systems.framework.System)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>This method will be called by System&lt;T&gt;::accept() if the System <em>is
not</em> a Diagram&lt;T&gt;.</p>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemVisitor_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">SystemVisitor_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">SystemVisitor_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">SystemVisitor_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemVisitor_[AutoDiffXd]</span></span></dt>
<dd><p>Provides a “Visitor Pattern” for System and Diagram. Rather than
adding more virtual methods to the System base class, or performing a
dynamic_cast to test if a System is a Diagram, you may use the visitor
pattern enabled by this class, e.g.:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">MySystemVisitor</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">SystemVisitor</span><span class="w"> </span><span class="p">{</span>
<span class="p">...</span>
<span class="p">}</span>

<span class="n">MySystemVisitor</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">visitor</span><span class="p">;</span>
<span class="n">system</span><span class="p">.</span><span class="n">Accept</span><span class="p">(</span><span class="n">visitor</span><span class="p">);</span>
</pre></div>
</div>
</details><p>will call the correct <code class="docutils literal notranslate"><span class="pre">Visit</span></code> overload.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method does <em>not</em> recurse through the subsystems of a
Diagram, but that is easy to do: just call Diagram::GetSystems()
in your visitor and then call Accept on the subsystems.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemVisitor_[AutoDiffXd].__init__(self:</span> <span class="pre">pydrake.systems.framework.SystemVisitor_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemVisitor_[AutoDiffXd].VisitDiagram(self:</span> <span class="pre">pydrake.systems.framework.SystemVisitor_[AutoDiffXd],</span> <span class="pre">diagram:</span> <span class="pre">pydrake.systems.framework.Diagram_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>This method will be called by System&lt;T&gt;::accept() if the System <em>is</em> a
Diagram&lt;T&gt;.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemVisitor_[AutoDiffXd].VisitSystem(self:</span> <span class="pre">pydrake.systems.framework.SystemVisitor_[AutoDiffXd],</span> <span class="pre">system:</span> <span class="pre">pydrake.systems.framework.System_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>This method will be called by System&lt;T&gt;::accept() if the System <em>is
not</em> a Diagram&lt;T&gt;.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemVisitor_[Expression]</span></span></dt>
<dd><p>Provides a “Visitor Pattern” for System and Diagram. Rather than
adding more virtual methods to the System base class, or performing a
dynamic_cast to test if a System is a Diagram, you may use the visitor
pattern enabled by this class, e.g.:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">MySystemVisitor</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">SystemVisitor</span><span class="w"> </span><span class="p">{</span>
<span class="p">...</span>
<span class="p">}</span>

<span class="n">MySystemVisitor</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">visitor</span><span class="p">;</span>
<span class="n">system</span><span class="p">.</span><span class="n">Accept</span><span class="p">(</span><span class="n">visitor</span><span class="p">);</span>
</pre></div>
</div>
</details><p>will call the correct <code class="docutils literal notranslate"><span class="pre">Visit</span></code> overload.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method does <em>not</em> recurse through the subsystems of a
Diagram, but that is easy to do: just call Diagram::GetSystems()
in your visitor and then call Accept on the subsystems.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemVisitor_[Expression].__init__(self:</span> <span class="pre">pydrake.systems.framework.SystemVisitor_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemVisitor_[Expression].VisitDiagram(self:</span> <span class="pre">pydrake.systems.framework.SystemVisitor_[Expression],</span> <span class="pre">diagram:</span> <span class="pre">pydrake.systems.framework.Diagram_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>This method will be called by System&lt;T&gt;::accept() if the System <em>is</em> a
Diagram&lt;T&gt;.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SystemVisitor_[Expression].VisitSystem(self:</span> <span class="pre">pydrake.systems.framework.SystemVisitor_[Expression],</span> <span class="pre">system:</span> <span class="pre">pydrake.systems.framework.System_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>This method will be called by System&lt;T&gt;::accept() if the System <em>is
not</em> a Diagram&lt;T&gt;.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">TriggerType</span></span></dt>
<dd><p>Predefined types of triggers for events. Used at run time to determine
why the associated event has occurred.</p>
<p>Members:</p>
<blockquote>
<div><p>kUnknown :</p>
<p>kInitialization : This trigger indicates that an associated event is triggered at system</p>
</div></blockquote>
<p>initialization.</p>
<blockquote>
<div><p>kForced : This trigger indicates that an associated event is triggered by</p>
</div></blockquote>
<p>directly calling the corresponding public system API for event
handling (e.g. Publish(context)).</p>
<blockquote>
<div><p>kTimed : This trigger indicates that an associated event is triggered by the</p>
</div></blockquote>
<p>system proceeding to a single, arbitrary time. Timed events are
commonly created in System::CalcNextUpdateTime().</p>
<blockquote>
<div><p>kPeriodic : This type indicates that an associated event is triggered by the</p>
</div></blockquote>
<p>system proceeding to a time t ∈ {tᵢ = t₀ + p * i} for some period p,
time offset t₀, and i is a non-negative integer.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<blockquote>
<div><p>PeriodicEventData. Periodic events are commonly created in
System::CalcNextUpdateTime().</p>
</div></blockquote>
<p>kPerStep : This trigger indicates that an associated event is triggered whenever</p>
</div>
<p>a <code class="docutils literal notranslate"><span class="pre">solver</span></code> takes a <code class="docutils literal notranslate"><span class="pre">step</span></code>. A <code class="docutils literal notranslate"><span class="pre">solver</span></code> is an abstract construct
that controls or tracks the time and state evolution of a System. A
simulator is a <code class="docutils literal notranslate"><span class="pre">solver</span></code>- it advances time a finite duration by
integrating a system, modifying its state accordingly- as is a process
that receives some numeric state from IPC that is then used to, e.g.,
update abstract state. Steps may occur at irregular time intervals: a
step typically coincides with a point in time where it is advantageous
to poll for events, like immediately after an integrator has advanced
time and state.</p>
<p>Per-step events are most commonly created in
System::GetPerStepEvents(). A very common use of such per-step events
is to update a discrete or abstract state variable that changes
whenever the continuous state advances; examples are computing the
“min” or “max” of some state variable, recording a signal in a delay
buffer, or publishing. Per-step events are also useful to implement
feedback controllers interfaced with physical devices; the controller
can be implemented in the event handler, and the “step” would
correspond to receiving sensory data from the hardware.</p>
<blockquote>
<div><p>kWitness : This trigger indicates that an associated event is triggered by the</p>
</div></blockquote>
<p>zero crossing of a witness function.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>WitnessTriggeredEventData.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">TriggerType.__init__(self:</span> <span class="pre">pydrake.systems.framework.TriggerType,</span> <span class="pre">value:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">TriggerType.kForced</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">TriggerType.kInitialization</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">TriggerType.kPeriodic</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">TriggerType.kPerStep</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">TriggerType.kTimed</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">TriggerType.kUnknown</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">TriggerType.kWitness</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">TriggerType.name</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">TriggerType.value</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UnrestrictedUpdateEvent</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.Event</span></code></p>
<p>This class represents an unrestricted update event. It has an optional
callback function to do custom handling of this event, and that can
write updates to a mutable, non-null State object.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>LeafSystem for more convenient interfaces to unrestricted update
events via the Declare*UnrestrictedUpdateEvent() methods.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">UnrestrictedUpdateEvent_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UnrestrictedUpdateEvent.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.systems.framework.UnrestrictedUpdateEvent, callback: Callable[[pydrake.systems.framework.Context, pydrake.systems.framework.UnrestrictedUpdateEvent, pydrake.systems.framework.State], Optional[pydrake.systems.framework.EventStatus]]) -&gt; None</p></li>
</ol>
<p>Constructs an UnrestrictedUpdateEvent with the given callback function.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.systems.framework.UnrestrictedUpdateEvent, system_callback: Callable[[drake::systems::System&lt;double&gt;, pydrake.systems.framework.Context, pydrake.systems.framework.UnrestrictedUpdateEvent, pydrake.systems.framework.State], Optional[pydrake.systems.framework.EventStatus]]) -&gt; None</p></li>
</ol>
<p>Constructs an UnrestrictedUpdateEvent with the given callback function.</p>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UnrestrictedUpdateEvent_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">UnrestrictedUpdateEvent_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">UnrestrictedUpdateEvent_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">UnrestrictedUpdateEvent_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UnrestrictedUpdateEvent_[AutoDiffXd]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.Event_[AutoDiffXd]</span></code></p>
<p>This class represents an unrestricted update event. It has an optional
callback function to do custom handling of this event, and that can
write updates to a mutable, non-null State object.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>LeafSystem for more convenient interfaces to unrestricted update
events via the Declare*UnrestrictedUpdateEvent() methods.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UnrestrictedUpdateEvent_[AutoDiffXd].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.systems.framework.UnrestrictedUpdateEvent_[AutoDiffXd], callback: Callable[[pydrake.systems.framework.Context_[AutoDiffXd], pydrake.systems.framework.UnrestrictedUpdateEvent_[AutoDiffXd], pydrake.systems.framework.State_[AutoDiffXd]], Optional[pydrake.systems.framework.EventStatus]]) -&gt; None</p></li>
</ol>
<p>Constructs an UnrestrictedUpdateEvent with the given callback function.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.systems.framework.UnrestrictedUpdateEvent_[AutoDiffXd], system_callback: Callable[[drake::systems::System&lt;Eigen::AutoDiffScalar&lt;Eigen::Matrix&lt;double, -1, 1, 0, -1, 1&gt; &gt; &gt;, pydrake.systems.framework.Context_[AutoDiffXd], pydrake.systems.framework.UnrestrictedUpdateEvent_[AutoDiffXd], pydrake.systems.framework.State_[AutoDiffXd]], Optional[pydrake.systems.framework.EventStatus]]) -&gt; None</p></li>
</ol>
<p>Constructs an UnrestrictedUpdateEvent with the given callback function.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UnrestrictedUpdateEvent_[Expression]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.Event_[Expression]</span></code></p>
<p>This class represents an unrestricted update event. It has an optional
callback function to do custom handling of this event, and that can
write updates to a mutable, non-null State object.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>LeafSystem for more convenient interfaces to unrestricted update
events via the Declare*UnrestrictedUpdateEvent() methods.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UnrestrictedUpdateEvent_[Expression].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.systems.framework.UnrestrictedUpdateEvent_[Expression], callback: Callable[[pydrake.systems.framework.Context_[Expression], pydrake.systems.framework.UnrestrictedUpdateEvent_[Expression], pydrake.systems.framework.State_[Expression]], Optional[pydrake.systems.framework.EventStatus]]) -&gt; None</p></li>
</ol>
<p>Constructs an UnrestrictedUpdateEvent with the given callback function.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.systems.framework.UnrestrictedUpdateEvent_[Expression], system_callback: Callable[[drake::systems::System&lt;drake::symbolic::Expression&gt;, pydrake.systems.framework.Context_[Expression], pydrake.systems.framework.UnrestrictedUpdateEvent_[Expression], pydrake.systems.framework.State_[Expression]], Optional[pydrake.systems.framework.EventStatus]]) -&gt; None</p></li>
</ol>
<p>Constructs an UnrestrictedUpdateEvent with the given callback function.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UseDefaultName</span></span></dt>
<dd><p>(Advanced.) Tag type that indicates a system or port should use a
default name, instead of a user-provided name. Most users will use the
kUseDefaultName constant, without ever having to mention this type.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UseDefaultName.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ValueProducer</span></span></dt>
<dd><p>ValueProducer computes an AbstractValue output based on a ContextBase
input. This is commonly used for declaring output ports and cache
entries.</p>
<p>It provides two functions for that purpose: - Allocate() returns new
storage that is suitably typed to hold the output. - Calc() takes a
context as input and writes to an output pointer.</p>
<p>For example, given this example calculator lambda:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="w"> </span><span class="n">calc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[](</span><span class="k">const</span><span class="w"> </span><span class="n">Context</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">*</span><span class="w"> </span><span class="n">output</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="n">output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">context</span><span class="p">.</span><span class="n">get_time</span><span class="p">());</span>
<span class="p">};</span>
</pre></div>
</div>
</details><p>We can capture it into a producer and then call it:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">ValueProducer</span><span class="w"> </span><span class="nf">producer</span><span class="p">(</span><span class="n">calc</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">AbstractValue</span><span class="o">&gt;</span><span class="w"> </span><span class="n">storage</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">producer</span><span class="p">.</span><span class="n">Allocate</span><span class="p">();</span>
<span class="k">const</span><span class="w"> </span><span class="n">LeafContext</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">context</span><span class="p">;</span>
<span class="n">producer</span><span class="p">.</span><span class="n">Calc</span><span class="p">(</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="n">storage</span><span class="p">.</span><span class="n">get</span><span class="p">());</span>
<span class="n">EXPECT_THAT</span><span class="p">(</span><span class="n">storage</span><span class="o">-&gt;</span><span class="n">get_value</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">StartsWith</span><span class="p">(</span><span class="s">&quot;0.0&quot;</span><span class="p">));</span>
</pre></div>
</div>
</details><p>Sugar is provided to create ValueProducer objects from function
pointers that operate on un-erased types, so that the user can ignore
the details of type erasure and Context&lt;T&gt; downcasting. Refer to the
ValueProducer_constructors “Constructor overloads” for details.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ValueProducer.__init__(self:</span> <span class="pre">pydrake.systems.framework.ValueProducer,</span> <span class="pre">allocate:</span> <span class="pre">Callable,</span> <span class="pre">calc:</span> <span class="pre">Callable[[object,</span> <span class="pre">object],</span> <span class="pre">None])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Overload (5d). Refer to the C++ ValueProducer_constructors
“Constructor overloads” for further details.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">allocate</span></code>:</dt><dd><p>Callback function that allocates storage for the value. It takes
no arguments and must return an AbstractValue.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">calc</span></code>:</dt><dd><p>Callback function that computes the value. It takes two arguments
(context, value) and does not return anything; instead, it should
mutate the AbstractValue object pointed to by <code class="docutils literal notranslate"><span class="pre">value</span></code> with the
new result.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ValueProducer.NoopCalc(arg0:</span> <span class="pre">pydrake.systems.framework.ContextBase,</span> <span class="pre">arg1:</span> <span class="pre">pydrake.common.value.AbstractValue)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>This static function is provided for users who need an empty
CalcCallback. Passing <code class="docutils literal notranslate"><span class="pre">&amp;ValueProducer::NoopCalc</span></code> as ValueProducer’s
last constructor argument will create a function that does not compute
anything, but can still allocate.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VectorBase</span></span></dt>
<dd><p>VectorBase is an abstract base class that real-valued signals between
Systems and real-valued System state vectors must implement. Classes
that inherit from VectorBase will typically provide names for the
elements of the vector, and may also provide other computations for
the convenience of Systems handling the signal. The vector is always a
column vector. It may or may not be contiguous in memory. Contiguous
subclasses should typically inherit from BasicVector, not from
VectorBase directly.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">VectorBase_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VectorBase.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VectorBase.CopyToVector(self:</span> <span class="pre">pydrake.systems.framework.VectorBase)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Copies this entire VectorBase into a contiguous Eigen Vector.</p>
<p>Implementations should ensure this operation is O(N) in the size of
the value and allocates only the O(N) memory that it returns.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VectorBase.GetAtIndex(self:</span> <span class="pre">pydrake.systems.framework.VectorBase,</span> <span class="pre">index:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns the element at the given index in the vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the index is &gt;= size</strong><strong>(</strong><strong>) or </strong><strong>negative. Consider</strong> – </p></li>
<li><p><strong>operator</strong><strong>[</strong><strong>]</strong><strong>(</strong><strong>) </strong><strong>instead if bounds-checking is unwanted.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VectorBase.PlusEqScaled(self:</span> <span class="pre">pydrake.systems.framework.VectorBase,</span> <span class="pre">scale:</span> <span class="pre">float,</span> <span class="pre">rhs:</span> <span class="pre">pydrake.systems.framework.VectorBase)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.VectorBase</span></span></dt>
<dd><p>Add in scaled vector <code class="docutils literal notranslate"><span class="pre">rhs</span></code> to this vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if rhs is a different size than this.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VectorBase.SetAtIndex(self:</span> <span class="pre">pydrake.systems.framework.VectorBase,</span> <span class="pre">index:</span> <span class="pre">int,</span> <span class="pre">value:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Replaces the state at the given index with the value.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the index is &gt;= size</strong><strong>(</strong><strong>)</strong><strong>. Consider operator</strong><strong>[</strong><strong>]</strong><strong>(</strong><strong>)</strong> – </p></li>
<li><p><strong>instead if bounds-checking is unwanted.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VectorBase.SetFrom(self:</span> <span class="pre">pydrake.systems.framework.VectorBase,</span> <span class="pre">value:</span> <span class="pre">pydrake.systems.framework.VectorBase)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Replaces the entire vector with the contents of <code class="docutils literal notranslate"><span class="pre">value</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if value is not a column vector with size</strong><strong>(</strong><strong>) </strong><strong>rows.</strong> – </p>
</dd>
</dl>
<p>Implementations should ensure this operation is O(N) in the size of
the value and allocates no memory.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VectorBase.SetFromVector(self:</span> <span class="pre">pydrake.systems.framework.VectorBase,</span> <span class="pre">value:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Replaces the entire vector with the contents of <code class="docutils literal notranslate"><span class="pre">value</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if value is not a column vector with size</strong><strong>(</strong><strong>) </strong><strong>rows.</strong> – </p>
</dd>
</dl>
<p>Implementations should ensure this operation is O(N) in the size of
the value and allocates no memory.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VectorBase.SetZero(self:</span> <span class="pre">pydrake.systems.framework.VectorBase)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets all elements of this vector to zero.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VectorBase.size(self:</span> <span class="pre">pydrake.systems.framework.VectorBase)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the number of elements in the vector.</p>
<p>Implementations should ensure this operation is O(1) and allocates no
memory.</p>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VectorBase_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">VectorBase_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">VectorBase_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">VectorBase_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VectorBase_[AutoDiffXd]</span></span></dt>
<dd><p>VectorBase is an abstract base class that real-valued signals between
Systems and real-valued System state vectors must implement. Classes
that inherit from VectorBase will typically provide names for the
elements of the vector, and may also provide other computations for
the convenience of Systems handling the signal. The vector is always a
column vector. It may or may not be contiguous in memory. Contiguous
subclasses should typically inherit from BasicVector, not from
VectorBase directly.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VectorBase_[AutoDiffXd].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VectorBase_[AutoDiffXd].CopyToVector(self:</span> <span class="pre">pydrake.systems.framework.VectorBase_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Copies this entire VectorBase into a contiguous Eigen Vector.</p>
<p>Implementations should ensure this operation is O(N) in the size of
the value and allocates only the O(N) memory that it returns.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VectorBase_[AutoDiffXd].GetAtIndex(self:</span> <span class="pre">pydrake.systems.framework.VectorBase_[AutoDiffXd],</span> <span class="pre">index:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd</span></span></dt>
<dd><p>Returns the element at the given index in the vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the index is &gt;= size</strong><strong>(</strong><strong>) or </strong><strong>negative. Consider</strong> – </p></li>
<li><p><strong>operator</strong><strong>[</strong><strong>]</strong><strong>(</strong><strong>) </strong><strong>instead if bounds-checking is unwanted.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VectorBase_[AutoDiffXd].PlusEqScaled(self:</span> <span class="pre">pydrake.systems.framework.VectorBase_[AutoDiffXd],</span> <span class="pre">scale:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd,</span> <span class="pre">rhs:</span> <span class="pre">pydrake.systems.framework.VectorBase_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.VectorBase_[AutoDiffXd]</span></span></dt>
<dd><p>Add in scaled vector <code class="docutils literal notranslate"><span class="pre">rhs</span></code> to this vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if rhs is a different size than this.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VectorBase_[AutoDiffXd].SetAtIndex(self:</span> <span class="pre">pydrake.systems.framework.VectorBase_[AutoDiffXd],</span> <span class="pre">index:</span> <span class="pre">int,</span> <span class="pre">value:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Replaces the state at the given index with the value.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the index is &gt;= size</strong><strong>(</strong><strong>)</strong><strong>. Consider operator</strong><strong>[</strong><strong>]</strong><strong>(</strong><strong>)</strong> – </p></li>
<li><p><strong>instead if bounds-checking is unwanted.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VectorBase_[AutoDiffXd].SetFrom(self:</span> <span class="pre">pydrake.systems.framework.VectorBase_[AutoDiffXd],</span> <span class="pre">value:</span> <span class="pre">pydrake.systems.framework.VectorBase_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Replaces the entire vector with the contents of <code class="docutils literal notranslate"><span class="pre">value</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if value is not a column vector with size</strong><strong>(</strong><strong>) </strong><strong>rows.</strong> – </p>
</dd>
</dl>
<p>Implementations should ensure this operation is O(N) in the size of
the value and allocates no memory.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VectorBase_[AutoDiffXd].SetFromVector(self:</span> <span class="pre">pydrake.systems.framework.VectorBase_[AutoDiffXd],</span> <span class="pre">value:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Replaces the entire vector with the contents of <code class="docutils literal notranslate"><span class="pre">value</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if value is not a column vector with size</strong><strong>(</strong><strong>) </strong><strong>rows.</strong> – </p>
</dd>
</dl>
<p>Implementations should ensure this operation is O(N) in the size of
the value and allocates no memory.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VectorBase_[AutoDiffXd].SetZero(self:</span> <span class="pre">pydrake.systems.framework.VectorBase_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets all elements of this vector to zero.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VectorBase_[AutoDiffXd].size(self:</span> <span class="pre">pydrake.systems.framework.VectorBase_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the number of elements in the vector.</p>
<p>Implementations should ensure this operation is O(1) and allocates no
memory.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VectorBase_[Expression]</span></span></dt>
<dd><p>VectorBase is an abstract base class that real-valued signals between
Systems and real-valued System state vectors must implement. Classes
that inherit from VectorBase will typically provide names for the
elements of the vector, and may also provide other computations for
the convenience of Systems handling the signal. The vector is always a
column vector. It may or may not be contiguous in memory. Contiguous
subclasses should typically inherit from BasicVector, not from
VectorBase directly.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VectorBase_[Expression].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VectorBase_[Expression].CopyToVector(self:</span> <span class="pre">pydrake.systems.framework.VectorBase_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Copies this entire VectorBase into a contiguous Eigen Vector.</p>
<p>Implementations should ensure this operation is O(N) in the size of
the value and allocates only the O(N) memory that it returns.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VectorBase_[Expression].GetAtIndex(self:</span> <span class="pre">pydrake.systems.framework.VectorBase_[Expression],</span> <span class="pre">index:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.symbolic.Expression</span></span></dt>
<dd><p>Returns the element at the given index in the vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the index is &gt;= size</strong><strong>(</strong><strong>) or </strong><strong>negative. Consider</strong> – </p></li>
<li><p><strong>operator</strong><strong>[</strong><strong>]</strong><strong>(</strong><strong>) </strong><strong>instead if bounds-checking is unwanted.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VectorBase_[Expression].PlusEqScaled(self:</span> <span class="pre">pydrake.systems.framework.VectorBase_[Expression],</span> <span class="pre">scale:</span> <span class="pre">pydrake.symbolic.Expression,</span> <span class="pre">rhs:</span> <span class="pre">pydrake.systems.framework.VectorBase_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.VectorBase_[Expression]</span></span></dt>
<dd><p>Add in scaled vector <code class="docutils literal notranslate"><span class="pre">rhs</span></code> to this vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if rhs is a different size than this.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VectorBase_[Expression].SetAtIndex(self:</span> <span class="pre">pydrake.systems.framework.VectorBase_[Expression],</span> <span class="pre">index:</span> <span class="pre">int,</span> <span class="pre">value:</span> <span class="pre">pydrake.symbolic.Expression)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Replaces the state at the given index with the value.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the index is &gt;= size</strong><strong>(</strong><strong>)</strong><strong>. Consider operator</strong><strong>[</strong><strong>]</strong><strong>(</strong><strong>)</strong> – </p></li>
<li><p><strong>instead if bounds-checking is unwanted.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VectorBase_[Expression].SetFrom(self:</span> <span class="pre">pydrake.systems.framework.VectorBase_[Expression],</span> <span class="pre">value:</span> <span class="pre">pydrake.systems.framework.VectorBase_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Replaces the entire vector with the contents of <code class="docutils literal notranslate"><span class="pre">value</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if value is not a column vector with size</strong><strong>(</strong><strong>) </strong><strong>rows.</strong> – </p>
</dd>
</dl>
<p>Implementations should ensure this operation is O(N) in the size of
the value and allocates no memory.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VectorBase_[Expression].SetFromVector(self:</span> <span class="pre">pydrake.systems.framework.VectorBase_[Expression],</span> <span class="pre">value:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Replaces the entire vector with the contents of <code class="docutils literal notranslate"><span class="pre">value</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if value is not a column vector with size</strong><strong>(</strong><strong>) </strong><strong>rows.</strong> – </p>
</dd>
</dl>
<p>Implementations should ensure this operation is O(N) in the size of
the value and allocates no memory.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VectorBase_[Expression].SetZero(self:</span> <span class="pre">pydrake.systems.framework.VectorBase_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets all elements of this vector to zero.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VectorBase_[Expression].size(self:</span> <span class="pre">pydrake.systems.framework.VectorBase_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the number of elements in the vector.</p>
<p>Implementations should ensure this operation is O(1) and allocates no
memory.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VectorSystem</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem</span></code></p>
<p>A base class that specializes LeafSystem for use with only zero or one
vector input ports, and only zero or one vector output ports.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">u0&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>VectorSystem</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y0</td></tr></table></td></tr></table><p>By default, this base class does not declare any state; subclasses may
optionally declare continuous or discrete state, but not both;
subclasses may not declare abstract state.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">VectorSystem_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VectorSystem.__init__(self:</span> <span class="pre">pydrake.systems.framework.VectorSystem,</span> <span class="pre">input_size:</span> <span class="pre">int,</span> <span class="pre">output_size:</span> <span class="pre">int,</span> <span class="pre">direct_feedthrough:</span> <span class="pre">Optional[bool])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Creates a system with one input port and one output port of the given
sizes, when the sizes are non-zero. Either size can be zero, in which
case no input (or output) port is created.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">direct_feedthrough</span></code> specifies whether the input port direct
feeds through to the output port. (See
SystemBase::GetDirectFeedthroughs().) When nullopt, assumes true (the
output is direct feedthrough). When false, the DoCalcVectorOutput
<code class="docutils literal notranslate"><span class="pre">input</span></code> will be empty (zero-sized).</p>
<p>Does <em>not</em> declare scalar-type conversion support (AutoDiff, etc.). To
enable AutoDiff support, use the SystemScalarConverter-based
constructor. (For that, see system_scalar_conversion at the example
titled “Example using drake::systems::VectorSystem as the base
class”.)</p>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VectorSystem_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">VectorSystem_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">VectorSystem_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">VectorSystem_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VectorSystem_[AutoDiffXd]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem_[AutoDiffXd]</span></code></p>
<p>A base class that specializes LeafSystem for use with only zero or one
vector input ports, and only zero or one vector output ports.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">u0&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>VectorSystem</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y0</td></tr></table></td></tr></table><p>By default, this base class does not declare any state; subclasses may
optionally declare continuous or discrete state, but not both;
subclasses may not declare abstract state.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VectorSystem_[AutoDiffXd].__init__(self:</span> <span class="pre">pydrake.systems.framework.VectorSystem_[AutoDiffXd],</span> <span class="pre">input_size:</span> <span class="pre">int,</span> <span class="pre">output_size:</span> <span class="pre">int,</span> <span class="pre">direct_feedthrough:</span> <span class="pre">Optional[bool])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Creates a system with one input port and one output port of the given
sizes, when the sizes are non-zero. Either size can be zero, in which
case no input (or output) port is created.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">direct_feedthrough</span></code> specifies whether the input port direct
feeds through to the output port. (See
SystemBase::GetDirectFeedthroughs().) When nullopt, assumes true (the
output is direct feedthrough). When false, the DoCalcVectorOutput
<code class="docutils literal notranslate"><span class="pre">input</span></code> will be empty (zero-sized).</p>
<p>Does <em>not</em> declare scalar-type conversion support (AutoDiff, etc.). To
enable AutoDiff support, use the SystemScalarConverter-based
constructor. (For that, see system_scalar_conversion at the example
titled “Example using drake::systems::VectorSystem as the base
class”.)</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VectorSystem_[Expression]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem_[Expression]</span></code></p>
<p>A base class that specializes LeafSystem for use with only zero or one
vector input ports, and only zero or one vector output ports.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">u0&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>VectorSystem</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y0</td></tr></table></td></tr></table><p>By default, this base class does not declare any state; subclasses may
optionally declare continuous or discrete state, but not both;
subclasses may not declare abstract state.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VectorSystem_[Expression].__init__(self:</span> <span class="pre">pydrake.systems.framework.VectorSystem_[Expression],</span> <span class="pre">input_size:</span> <span class="pre">int,</span> <span class="pre">output_size:</span> <span class="pre">int,</span> <span class="pre">direct_feedthrough:</span> <span class="pre">Optional[bool])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Creates a system with one input port and one output port of the given
sizes, when the sizes are non-zero. Either size can be zero, in which
case no input (or output) port is created.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">direct_feedthrough</span></code> specifies whether the input port direct
feeds through to the output port. (See
SystemBase::GetDirectFeedthroughs().) When nullopt, assumes true (the
output is direct feedthrough). When false, the DoCalcVectorOutput
<code class="docutils literal notranslate"><span class="pre">input</span></code> will be empty (zero-sized).</p>
<p>Does <em>not</em> declare scalar-type conversion support (AutoDiff, etc.). To
enable AutoDiff support, use the SystemScalarConverter-based
constructor. (For that, see system_scalar_conversion at the example
titled “Example using drake::systems::VectorSystem as the base
class”.)</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">WitnessFunction</span></span></dt>
<dd><p>Class that stores a function that is able to help determine the time
and state at which a step of the initial value problem integration of
a System should end, which may be done for any number of purposes,
including publishing or state reinitialization (i.e., event handling).
System authors declare witness functions through
LeafSystem::MakeWitnessFunction().</p>
<p>For the ensuing discussion, consider two times (<code class="docutils literal notranslate"><span class="pre">t₀</span></code> and <code class="docutils literal notranslate"><span class="pre">t₁</span> <span class="pre">&gt;</span>
<span class="pre">t₀</span></code>) and states corresponding to those times (<code class="docutils literal notranslate"><span class="pre">x(t₀)</span></code> and
<code class="docutils literal notranslate"><span class="pre">x(t₁)</span></code>). A witness function, <code class="docutils literal notranslate"><span class="pre">w(t,</span> <span class="pre">x)</span></code>, “triggers” only when it
crosses zero at a time <code class="docutils literal notranslate"><span class="pre">t*</span></code> where <code class="docutils literal notranslate"><span class="pre">t₀</span> <span class="pre">&lt;</span> <span class="pre">t*</span> <span class="pre">≤</span> <span class="pre">t₁</span></code>. Note the
half-open interval. For an example of a witness function, consider the
“signed distance” (i.e., Euclidean distance when bodies are disjoint
and minimum translational distance when bodies intersect) between two
rigid bodies; this witness function can be used to determine both the
time of impact for rigid bodies and their states at that time of
impact.</p>
<p>Precision in the definition of the witness function is necessary,
because we want the witness function to trigger only once if, for
example, <code class="docutils literal notranslate"><span class="pre">w(t₀,</span> <span class="pre">x(t₀))</span> <span class="pre">≠</span> <span class="pre">0</span></code>, <cite>w(t₁, x(t₁)) = 0</cite>, and <code class="docutils literal notranslate"><span class="pre">w(t₂,</span> <span class="pre">x(t₂))</span>
<span class="pre">≠</span> <span class="pre">0</span></code>, for some t₂ &gt; t₁. In other words, if the witness function is
evaluated over the intervals [t₀, t₁] and [t₁, t₂], meaning that the
zero occurs precisely at an interval endpoint, the witness function
should trigger once. Similarly, the witness function should trigger
exactly once if <code class="docutils literal notranslate"><span class="pre">w(t₀,</span> <span class="pre">x(t₀))</span> <span class="pre">≠</span> <span class="pre">0</span></code>, <cite>w(t*, x(t*)) = 0</cite>, and <code class="docutils literal notranslate"><span class="pre">w(t₁,</span>
<span class="pre">x(t₁))</span> <span class="pre">=</span> <span class="pre">0</span></code>, for <code class="docutils literal notranslate"><span class="pre">t*</span> <span class="pre">∈</span> <span class="pre">(t₀,</span> <span class="pre">t₁)</span></code>. We can define the trigger
condition formally over interval <code class="docutils literal notranslate"><span class="pre">[t₀,</span> <span class="pre">t₁]</span></code> using the function:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">T</span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="w"> </span><span class="n">t₀</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">(</span><span class="n">t₀</span><span class="p">),</span><span class="w"> </span><span class="n">t₁</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w">   </span><span class="mi">1</span><span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="n">w</span><span class="p">(</span><span class="n">t₀</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">(</span><span class="n">t₀</span><span class="p">))</span><span class="w"> </span><span class="err">≠</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="k">and</span>
<span class="w">                               </span><span class="n">w</span><span class="p">(</span><span class="n">t₀</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">(</span><span class="n">t₀</span><span class="p">))</span><span class="err">⋅</span><span class="n">w</span><span class="p">(</span><span class="n">t₁</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">(</span><span class="n">t₁</span><span class="p">))</span><span class="w"> </span><span class="err">≤</span><span class="w"> </span><span class="mi">0</span>
<span class="w">                        </span><span class="mi">0</span><span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="n">w</span><span class="p">(</span><span class="n">t₀</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">(</span><span class="n">t₀</span><span class="p">))</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="k">or</span>
<span class="w">                               </span><span class="n">w</span><span class="p">(</span><span class="n">t₀</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">(</span><span class="n">t₀</span><span class="p">))</span><span class="err">⋅</span><span class="n">w</span><span class="p">(</span><span class="n">t₁</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">(</span><span class="n">t₁</span><span class="p">))</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span>
</pre></div>
</div>
</details><p>We wish for the witness function to trigger if the trigger function
evaluates to one. The trigger function can be further modified, if
desired, to incorporate the constraint that the witness function
should trigger only when crossing from positive values to negative
values, or vice versa.</p>
<p>A good witness function should not cross zero repeatedly over a small
interval of time (relative to the maximum designated integration step
size) or over small changes in state; when a witness function has been
“bracketed” over an interval of time (i.e., it changes sign), that
witness function will ideally cross zero only once in that interval.</p>
<p>A witness function trigger time is isolated only to a small interval
of time (as described in Simulator). The disadvantage of this scheme
is that it always requires the length of the interval to be reduced to
the requisite length <em>and that each function evaluation (which
requires numerical integration) is extraordinarily expensive</em>. If, for
example, the (slow) bisection algorithm were used to isolate the time
interval, the number of integrations necessary to cut the interval
from a length of ℓ to a length of ε will be log₂(ℓ / ε). Bisection is
just one of several possible algorithms for isolating the time
interval, though it’s a reliable choice and always converges linearly.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">WitnessFunction_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">WitnessFunction.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">WitnessFunction_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">WitnessFunction_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">WitnessFunction_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">WitnessFunction_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">WitnessFunction_[AutoDiffXd]</span></span></dt>
<dd><p>Class that stores a function that is able to help determine the time
and state at which a step of the initial value problem integration of
a System should end, which may be done for any number of purposes,
including publishing or state reinitialization (i.e., event handling).
System authors declare witness functions through
LeafSystem::MakeWitnessFunction().</p>
<p>For the ensuing discussion, consider two times (<code class="docutils literal notranslate"><span class="pre">t₀</span></code> and <code class="docutils literal notranslate"><span class="pre">t₁</span> <span class="pre">&gt;</span>
<span class="pre">t₀</span></code>) and states corresponding to those times (<code class="docutils literal notranslate"><span class="pre">x(t₀)</span></code> and
<code class="docutils literal notranslate"><span class="pre">x(t₁)</span></code>). A witness function, <code class="docutils literal notranslate"><span class="pre">w(t,</span> <span class="pre">x)</span></code>, “triggers” only when it
crosses zero at a time <code class="docutils literal notranslate"><span class="pre">t*</span></code> where <code class="docutils literal notranslate"><span class="pre">t₀</span> <span class="pre">&lt;</span> <span class="pre">t*</span> <span class="pre">≤</span> <span class="pre">t₁</span></code>. Note the
half-open interval. For an example of a witness function, consider the
“signed distance” (i.e., Euclidean distance when bodies are disjoint
and minimum translational distance when bodies intersect) between two
rigid bodies; this witness function can be used to determine both the
time of impact for rigid bodies and their states at that time of
impact.</p>
<p>Precision in the definition of the witness function is necessary,
because we want the witness function to trigger only once if, for
example, <code class="docutils literal notranslate"><span class="pre">w(t₀,</span> <span class="pre">x(t₀))</span> <span class="pre">≠</span> <span class="pre">0</span></code>, <cite>w(t₁, x(t₁)) = 0</cite>, and <code class="docutils literal notranslate"><span class="pre">w(t₂,</span> <span class="pre">x(t₂))</span>
<span class="pre">≠</span> <span class="pre">0</span></code>, for some t₂ &gt; t₁. In other words, if the witness function is
evaluated over the intervals [t₀, t₁] and [t₁, t₂], meaning that the
zero occurs precisely at an interval endpoint, the witness function
should trigger once. Similarly, the witness function should trigger
exactly once if <code class="docutils literal notranslate"><span class="pre">w(t₀,</span> <span class="pre">x(t₀))</span> <span class="pre">≠</span> <span class="pre">0</span></code>, <cite>w(t*, x(t*)) = 0</cite>, and <code class="docutils literal notranslate"><span class="pre">w(t₁,</span>
<span class="pre">x(t₁))</span> <span class="pre">=</span> <span class="pre">0</span></code>, for <code class="docutils literal notranslate"><span class="pre">t*</span> <span class="pre">∈</span> <span class="pre">(t₀,</span> <span class="pre">t₁)</span></code>. We can define the trigger
condition formally over interval <code class="docutils literal notranslate"><span class="pre">[t₀,</span> <span class="pre">t₁]</span></code> using the function:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">T</span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="w"> </span><span class="n">t₀</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">(</span><span class="n">t₀</span><span class="p">),</span><span class="w"> </span><span class="n">t₁</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w">   </span><span class="mi">1</span><span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="n">w</span><span class="p">(</span><span class="n">t₀</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">(</span><span class="n">t₀</span><span class="p">))</span><span class="w"> </span><span class="err">≠</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="k">and</span>
<span class="w">                               </span><span class="n">w</span><span class="p">(</span><span class="n">t₀</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">(</span><span class="n">t₀</span><span class="p">))</span><span class="err">⋅</span><span class="n">w</span><span class="p">(</span><span class="n">t₁</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">(</span><span class="n">t₁</span><span class="p">))</span><span class="w"> </span><span class="err">≤</span><span class="w"> </span><span class="mi">0</span>
<span class="w">                        </span><span class="mi">0</span><span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="n">w</span><span class="p">(</span><span class="n">t₀</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">(</span><span class="n">t₀</span><span class="p">))</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="k">or</span>
<span class="w">                               </span><span class="n">w</span><span class="p">(</span><span class="n">t₀</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">(</span><span class="n">t₀</span><span class="p">))</span><span class="err">⋅</span><span class="n">w</span><span class="p">(</span><span class="n">t₁</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">(</span><span class="n">t₁</span><span class="p">))</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span>
</pre></div>
</div>
</details><p>We wish for the witness function to trigger if the trigger function
evaluates to one. The trigger function can be further modified, if
desired, to incorporate the constraint that the witness function
should trigger only when crossing from positive values to negative
values, or vice versa.</p>
<p>A good witness function should not cross zero repeatedly over a small
interval of time (relative to the maximum designated integration step
size) or over small changes in state; when a witness function has been
“bracketed” over an interval of time (i.e., it changes sign), that
witness function will ideally cross zero only once in that interval.</p>
<p>A witness function trigger time is isolated only to a small interval
of time (as described in Simulator). The disadvantage of this scheme
is that it always requires the length of the interval to be reduced to
the requisite length <em>and that each function evaluation (which
requires numerical integration) is extraordinarily expensive</em>. If, for
example, the (slow) bisection algorithm were used to isolate the time
interval, the number of integrations necessary to cut the interval
from a length of ℓ to a length of ε will be log₂(ℓ / ε). Bisection is
just one of several possible algorithms for isolating the time
interval, though it’s a reliable choice and always converges linearly.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">WitnessFunction_[AutoDiffXd].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">WitnessFunction_[Expression]</span></span></dt>
<dd><p>Class that stores a function that is able to help determine the time
and state at which a step of the initial value problem integration of
a System should end, which may be done for any number of purposes,
including publishing or state reinitialization (i.e., event handling).
System authors declare witness functions through
LeafSystem::MakeWitnessFunction().</p>
<p>For the ensuing discussion, consider two times (<code class="docutils literal notranslate"><span class="pre">t₀</span></code> and <code class="docutils literal notranslate"><span class="pre">t₁</span> <span class="pre">&gt;</span>
<span class="pre">t₀</span></code>) and states corresponding to those times (<code class="docutils literal notranslate"><span class="pre">x(t₀)</span></code> and
<code class="docutils literal notranslate"><span class="pre">x(t₁)</span></code>). A witness function, <code class="docutils literal notranslate"><span class="pre">w(t,</span> <span class="pre">x)</span></code>, “triggers” only when it
crosses zero at a time <code class="docutils literal notranslate"><span class="pre">t*</span></code> where <code class="docutils literal notranslate"><span class="pre">t₀</span> <span class="pre">&lt;</span> <span class="pre">t*</span> <span class="pre">≤</span> <span class="pre">t₁</span></code>. Note the
half-open interval. For an example of a witness function, consider the
“signed distance” (i.e., Euclidean distance when bodies are disjoint
and minimum translational distance when bodies intersect) between two
rigid bodies; this witness function can be used to determine both the
time of impact for rigid bodies and their states at that time of
impact.</p>
<p>Precision in the definition of the witness function is necessary,
because we want the witness function to trigger only once if, for
example, <code class="docutils literal notranslate"><span class="pre">w(t₀,</span> <span class="pre">x(t₀))</span> <span class="pre">≠</span> <span class="pre">0</span></code>, <cite>w(t₁, x(t₁)) = 0</cite>, and <code class="docutils literal notranslate"><span class="pre">w(t₂,</span> <span class="pre">x(t₂))</span>
<span class="pre">≠</span> <span class="pre">0</span></code>, for some t₂ &gt; t₁. In other words, if the witness function is
evaluated over the intervals [t₀, t₁] and [t₁, t₂], meaning that the
zero occurs precisely at an interval endpoint, the witness function
should trigger once. Similarly, the witness function should trigger
exactly once if <code class="docutils literal notranslate"><span class="pre">w(t₀,</span> <span class="pre">x(t₀))</span> <span class="pre">≠</span> <span class="pre">0</span></code>, <cite>w(t*, x(t*)) = 0</cite>, and <code class="docutils literal notranslate"><span class="pre">w(t₁,</span>
<span class="pre">x(t₁))</span> <span class="pre">=</span> <span class="pre">0</span></code>, for <code class="docutils literal notranslate"><span class="pre">t*</span> <span class="pre">∈</span> <span class="pre">(t₀,</span> <span class="pre">t₁)</span></code>. We can define the trigger
condition formally over interval <code class="docutils literal notranslate"><span class="pre">[t₀,</span> <span class="pre">t₁]</span></code> using the function:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">T</span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="w"> </span><span class="n">t₀</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">(</span><span class="n">t₀</span><span class="p">),</span><span class="w"> </span><span class="n">t₁</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w">   </span><span class="mi">1</span><span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="n">w</span><span class="p">(</span><span class="n">t₀</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">(</span><span class="n">t₀</span><span class="p">))</span><span class="w"> </span><span class="err">≠</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="k">and</span>
<span class="w">                               </span><span class="n">w</span><span class="p">(</span><span class="n">t₀</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">(</span><span class="n">t₀</span><span class="p">))</span><span class="err">⋅</span><span class="n">w</span><span class="p">(</span><span class="n">t₁</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">(</span><span class="n">t₁</span><span class="p">))</span><span class="w"> </span><span class="err">≤</span><span class="w"> </span><span class="mi">0</span>
<span class="w">                        </span><span class="mi">0</span><span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="n">w</span><span class="p">(</span><span class="n">t₀</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">(</span><span class="n">t₀</span><span class="p">))</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="k">or</span>
<span class="w">                               </span><span class="n">w</span><span class="p">(</span><span class="n">t₀</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">(</span><span class="n">t₀</span><span class="p">))</span><span class="err">⋅</span><span class="n">w</span><span class="p">(</span><span class="n">t₁</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">(</span><span class="n">t₁</span><span class="p">))</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span>
</pre></div>
</div>
</details><p>We wish for the witness function to trigger if the trigger function
evaluates to one. The trigger function can be further modified, if
desired, to incorporate the constraint that the witness function
should trigger only when crossing from positive values to negative
values, or vice versa.</p>
<p>A good witness function should not cross zero repeatedly over a small
interval of time (relative to the maximum designated integration step
size) or over small changes in state; when a witness function has been
“bracketed” over an interval of time (i.e., it changes sign), that
witness function will ideally cross zero only once in that interval.</p>
<p>A witness function trigger time is isolated only to a small interval
of time (as described in Simulator). The disadvantage of this scheme
is that it always requires the length of the interval to be reduced to
the requisite length <em>and that each function evaluation (which
requires numerical integration) is extraordinarily expensive</em>. If, for
example, the (slow) bisection algorithm were used to isolate the time
interval, the number of integrations necessary to cut the interval
from a length of ℓ to a length of ε will be log₂(ℓ / ε). Bisection is
just one of several possible algorithms for isolating the time
interval, though it’s a reliable choice and always converges linearly.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">WitnessFunction_[Expression].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">WitnessFunctionDirection</span></span></dt>
<dd><p>Members:</p>
<blockquote>
<div><p>kNone : This witness function will never be triggered.</p>
<p>kPositiveThenNonPositive : Witness function triggers when the function crosses or touches zero</p>
</div></blockquote>
<p>after an initial positive evaluation.</p>
<blockquote>
<div><p>kNegativeThenNonNegative : Witness function triggers when the function crosses or touches zero</p>
</div></blockquote>
<p>after an initial negative evaluation.</p>
<blockquote>
<div><p>kCrossesZero : Witness function triggers <em>any time</em> the function crosses/touches</p>
</div></blockquote>
<p>zero, <em>except</em> when the witness function evaluates to zero at the
beginning of the interval. Conceptually equivalent to
kPositiveThenNonNegative OR kNegativeThenNonNegative.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">WitnessFunctionDirection.__init__(self:</span> <span class="pre">pydrake.systems.framework.WitnessFunctionDirection,</span> <span class="pre">value:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">WitnessFunctionDirection.kCrossesZero</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">WitnessFunctionDirection.kNegativeThenNonNegative</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">WitnessFunctionDirection.kNone</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">WitnessFunctionDirection.kPositiveThenNonPositive</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">WitnessFunctionDirection.name</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">WitnessFunctionDirection.value</span></span></dt>
<dd></dd></dl>

</dd></dl>

</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="pydrake.systems.estimators.html" class="btn btn-neutral float-left" title="pydrake.systems.estimators" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="pydrake.systems.lcm.html" class="btn btn-neutral float-right" title="pydrake.systems.lcm" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p></p>
  </div>

  
</footer>
<script>
  /* Enables clicking for the mobile "hamburger" (three-line) menu item. */
  const siteHeader = document.querySelector('.site-header')
  const mobileButton = document.querySelector('.menu-mobile-toggle')
  const body = document.querySelector('body')

  mobileButton.addEventListener('click', function(event) {
    siteHeader.classList.toggle('open');
    body.classList.toggle('overflow-hidden');
  })
</script>
<footer class="site-footer padding">
  <div class="contain">
    <a href="/" class="drake-logo">
      <img src="/images/drake-logo.svg">
    </a>
    <div class="footer-menu">
      <ul>
        <li>
          <a href="/doxygen_cxx/index.html" class="site-menu-item">C++</a>
        </li>
        <li>
          <a href="/pydrake/index.html" class="site-menu-item">Python</a>
        </li>
        <li class="github-link">
          <a href="https://github.com/RobotLocomotion/drake" class="site-menu-item">GitHub <img src="/third_party/images/GitHub-Mark-64px.png"></a>
        </li>
      </ul>
    </div>
  </div>


</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>