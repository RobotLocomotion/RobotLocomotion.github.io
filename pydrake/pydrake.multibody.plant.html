<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>pydrake.multibody.plant &mdash; pydrake  documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=86f27845" />
      <link rel="stylesheet" type="text/css" href="_static/css/custom.css?v=65885df3" />

  
  
        <script src="_static/jquery.js?v=8dae8fb0"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="_static/documentation_options.js?v=7f41d439"></script>
        <script src="_static/doctools.js?v=888ff710"></script>
        <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="pydrake.multibody.rational" href="pydrake.multibody.rational.html" />
    <link rel="prev" title="pydrake.multibody.parsing" href="pydrake.multibody.parsing.html" /> 
</head>

<body class="wy-body-for-nav">
<header class="site-header">
  <div class="site-header-inner contain">
    <a class="drake-logo" href="/"><img src="/images/drake-logo-white.svg"></a>
    <div class="menu-mobile-toggle">
      <span></span>
    </div>
    <nav class="site-menu">
      <ul>
        <li class="site-menu-item site-menu-item-main">
          <a class="site-menu-item" href="/">Home</a>
        </li>
        <li class="site-menu-item site-menu-item-main">
          <a class="site-menu-item" href="/installation.html">Installation</a>
        </li>
        <li class="site-menu-item site-menu-item-main">
          <a class="site-menu-item" href="/gallery.html">Gallery</a>
        </li>
        <li class="site-menu-item site-menu-item-main">API Documentation
          <div class="sub">
            <a class="site-menu-item" href="/doxygen_cxx/index.html">C++</a> <a class="site-menu-item" href="/pydrake/index.html">Python</a>
          </div>
        </li>
        <li class="site-menu-item site-menu-item-main">Resources
          <div class="sub">
            <a class="site-menu-item" href="/getting_help.html">Getting Help</a> <a class="site-menu-item" href="https://deepnote.com/workspace/Drake-0b3b2c53-a7ad-441b-80f8-bf8350752305/project/Tutorials-2b4fc509-aef2-417d-a40d-6071dfed9199/notebook/index-753e3c9d261247ba9f0eb1d7868c18c8">Tutorials</a> <a class="site-menu-item" href="/python_bindings.html">Python Bindings</a> <a class="site-menu-item" href="/developers.html">For Developers</a> <a class="site-menu-item" href="/credits.html">Credits</a>
          </div>
        </li>
        <li class="github-link">
          <a class="site-menu-item" href="https://github.com/RobotLocomotion/drake">GitHub <img src="/third_party/images/GitHub-Mark-Light-64px.png"></a>
        </li>
      </ul>
    </nav>
  </div>
</header>

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            pydrake
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search pydrake only…" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
  <form id="search_form" class="wy_form" action="https://google.com/search" method="get">
    <input type="text" name="q" placeholder="Search all of Drake…" />
    <input type="hidden" name="q" value="site:drake.mit.edu OR site:underactuated.csail.mit.edu OR site:manipulation.csail.mit.edu" />
  </form>
</div>

        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="pydrake.all.html">pydrake.all</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.autodiffutils.html">pydrake.autodiffutils</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.common.html">pydrake.common</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.examples.html">pydrake.examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.forwarddiff.html">pydrake.forwarddiff</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.geometry.html">pydrake.geometry</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.gym.html">pydrake.gym</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.lcm.html">pydrake.lcm</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.manipulation.html">pydrake.manipulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.math.html">pydrake.math</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="pydrake.multibody.html">pydrake.multibody</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="pydrake.multibody.all.html">pydrake.multibody.all</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.multibody.benchmarks.html">pydrake.multibody.benchmarks</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.multibody.fem.html">pydrake.multibody.fem</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.multibody.fix_inertia.html">pydrake.multibody.fix_inertia</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.multibody.inverse_kinematics.html">pydrake.multibody.inverse_kinematics</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.multibody.math.html">pydrake.multibody.math</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.multibody.mesh_to_model.html">pydrake.multibody.mesh_to_model</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.multibody.meshcat.html">pydrake.multibody.meshcat</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.multibody.optimization.html">pydrake.multibody.optimization</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.multibody.parsing.html">pydrake.multibody.parsing</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">pydrake.multibody.plant</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.multibody.rational.html">pydrake.multibody.rational</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.multibody.tree.html">pydrake.multibody.tree</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.perception.html">pydrake.perception</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.planning.html">pydrake.planning</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.polynomial.html">pydrake.polynomial</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.solvers.html">pydrake.solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.symbolic.html">pydrake.symbolic</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.systems.html">pydrake.systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.trajectories.html">pydrake.trajectories</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.tutorials.html">pydrake.tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.visualization.html">pydrake.visualization</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">pydrake</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="pydrake.multibody.html">pydrake.multibody</a></li>
      <li class="breadcrumb-item active">pydrake.multibody.plant</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="module-pydrake.multibody.plant">
<span id="pydrake-multibody-plant"></span><h1>pydrake.multibody.plant<a class="headerlink" href="#module-pydrake.multibody.plant" title="Link to this heading"></a></h1>
<p>Bindings for MultibodyPlant and related classes.</p>
<dl class="py function">
<dt class="sig sig-object py" id="pydrake.multibody.plant.AddMultibodyPlant">
<span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">AddMultibodyPlant</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.AddMultibodyPlant" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>AddMultibodyPlant(config: pydrake.multibody.plant.MultibodyPlantConfig, builder: pydrake.systems.framework.DiagramBuilder) -&gt; tuple</p></li>
</ol>
<p>Adds a new MultibodyPlant and SceneGraph to the given <code class="docutils literal notranslate"><span class="pre">builder</span></code>. The
plant’s settings such as <code class="docutils literal notranslate"><span class="pre">time_step</span></code> are set using the given
<code class="docutils literal notranslate"><span class="pre">config</span></code>.</p>
<ol class="arabic simple" start="2">
<li><p>AddMultibodyPlant(plant_config: pydrake.multibody.plant.MultibodyPlantConfig, scene_graph_config: pydrake.geometry.SceneGraphConfig, builder: pydrake.systems.framework.DiagramBuilder) -&gt; tuple</p></li>
</ol>
<p>Adds a new MultibodyPlant and SceneGraph to the given <code class="docutils literal notranslate"><span class="pre">builder</span></code>. The
plant’s settings such as <code class="docutils literal notranslate"><span class="pre">time_step</span></code> are set using the given
<code class="docutils literal notranslate"><span class="pre">plant_config</span></code>. The scene graph’s settings are set using the given
<code class="docutils literal notranslate"><span class="pre">scene_graph_config</span></code>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydrake.multibody.plant.AddMultibodyPlantSceneGraph">
<span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">AddMultibodyPlantSceneGraph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.AddMultibodyPlantSceneGraph" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>AddMultibodyPlantSceneGraph(builder: pydrake.systems.framework.DiagramBuilder, plant: pydrake.multibody.plant.MultibodyPlant, scene_graph: pydrake.geometry.SceneGraph = None) -&gt; tuple</p></li>
</ol>
<p>Adds a MultibodyPlant and a SceneGraph instance to a diagram builder,
connecting the geometry ports.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Usage examples in add_multibody_plant_scene_graph
“AddMultibodyPlantSceneGraph”.</p>
</div>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">builder</span></code>:</dt><dd><p>Builder to add to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">plant</span></code>:</dt><dd><p>Plant to be added to the builder.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">scene_graph</span></code>:</dt><dd><p>(optional) Constructed scene graph. If none is provided, one will
be created and used.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Pair of the registered plant and scene graph.</p>
</dd>
</dl>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">builder</span></code> and <code class="docutils literal notranslate"><span class="pre">plant</span></code> must be non-null.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>AddMultibodyPlantSceneGraph(builder: pydrake.systems.framework.DiagramBuilder, time_step: float, scene_graph: pydrake.geometry.SceneGraph = None) -&gt; tuple</p></li>
</ol>
<p>Makes a new MultibodyPlant with discrete update period <code class="docutils literal notranslate"><span class="pre">time_step</span></code>
and adds it to a diagram builder together with the provided SceneGraph
instance, connecting the geometry ports.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Usage examples in add_multibody_plant_scene_graph
“AddMultibodyPlantSceneGraph”.</p>
</div>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">builder</span></code>:</dt><dd><p>Builder to add to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">time_step</span></code>:</dt><dd><p>The discrete update period for the new MultibodyPlant to be added.
Please refer to the documentation provided in
MultibodyPlant::MultibodyPlant(double) for further details on the
parameter <code class="docutils literal notranslate"><span class="pre">time_step</span></code>.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">scene_graph</span></code>:</dt><dd><p>(optional) Constructed scene graph. If none is provided, one will
be created and used.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Pair of the registered plant and scene graph.</p>
</dd>
</dl>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">builder</span></code> must be non-null.</p>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li><p>AddMultibodyPlantSceneGraph(builder: pydrake.systems.framework.DiagramBuilder_[AutoDiffXd], plant: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], scene_graph: pydrake.geometry.SceneGraph_[AutoDiffXd] = None) -&gt; tuple</p></li>
</ol>
<p>Adds a MultibodyPlant and a SceneGraph instance to a diagram builder,
connecting the geometry ports.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Usage examples in add_multibody_plant_scene_graph
“AddMultibodyPlantSceneGraph”.</p>
</div>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">builder</span></code>:</dt><dd><p>Builder to add to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">plant</span></code>:</dt><dd><p>Plant to be added to the builder.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">scene_graph</span></code>:</dt><dd><p>(optional) Constructed scene graph. If none is provided, one will
be created and used.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Pair of the registered plant and scene graph.</p>
</dd>
</dl>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">builder</span></code> and <code class="docutils literal notranslate"><span class="pre">plant</span></code> must be non-null.</p>
</dd>
</dl>
<ol class="arabic simple" start="4">
<li><p>AddMultibodyPlantSceneGraph(builder: pydrake.systems.framework.DiagramBuilder_[AutoDiffXd], time_step: float, scene_graph: pydrake.geometry.SceneGraph_[AutoDiffXd] = None) -&gt; tuple</p></li>
</ol>
<p>Makes a new MultibodyPlant with discrete update period <code class="docutils literal notranslate"><span class="pre">time_step</span></code>
and adds it to a diagram builder together with the provided SceneGraph
instance, connecting the geometry ports.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Usage examples in add_multibody_plant_scene_graph
“AddMultibodyPlantSceneGraph”.</p>
</div>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">builder</span></code>:</dt><dd><p>Builder to add to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">time_step</span></code>:</dt><dd><p>The discrete update period for the new MultibodyPlant to be added.
Please refer to the documentation provided in
MultibodyPlant::MultibodyPlant(double) for further details on the
parameter <code class="docutils literal notranslate"><span class="pre">time_step</span></code>.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">scene_graph</span></code>:</dt><dd><p>(optional) Constructed scene graph. If none is provided, one will
be created and used.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Pair of the registered plant and scene graph.</p>
</dd>
</dl>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">builder</span></code> must be non-null.</p>
</dd>
</dl>
<ol class="arabic simple" start="5">
<li><p>AddMultibodyPlantSceneGraph(builder: pydrake.systems.framework.DiagramBuilder_[Expression], plant: pydrake.multibody.plant.MultibodyPlant_[Expression], scene_graph: pydrake.geometry.SceneGraph_[Expression] = None) -&gt; tuple</p></li>
</ol>
<p>Adds a MultibodyPlant and a SceneGraph instance to a diagram builder,
connecting the geometry ports.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Usage examples in add_multibody_plant_scene_graph
“AddMultibodyPlantSceneGraph”.</p>
</div>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">builder</span></code>:</dt><dd><p>Builder to add to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">plant</span></code>:</dt><dd><p>Plant to be added to the builder.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">scene_graph</span></code>:</dt><dd><p>(optional) Constructed scene graph. If none is provided, one will
be created and used.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Pair of the registered plant and scene graph.</p>
</dd>
</dl>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">builder</span></code> and <code class="docutils literal notranslate"><span class="pre">plant</span></code> must be non-null.</p>
</dd>
</dl>
<ol class="arabic simple" start="6">
<li><p>AddMultibodyPlantSceneGraph(builder: pydrake.systems.framework.DiagramBuilder_[Expression], time_step: float, scene_graph: pydrake.geometry.SceneGraph_[Expression] = None) -&gt; tuple</p></li>
</ol>
<p>Makes a new MultibodyPlant with discrete update period <code class="docutils literal notranslate"><span class="pre">time_step</span></code>
and adds it to a diagram builder together with the provided SceneGraph
instance, connecting the geometry ports.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Usage examples in add_multibody_plant_scene_graph
“AddMultibodyPlantSceneGraph”.</p>
</div>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">builder</span></code>:</dt><dd><p>Builder to add to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">time_step</span></code>:</dt><dd><p>The discrete update period for the new MultibodyPlant to be added.
Please refer to the documentation provided in
MultibodyPlant::MultibodyPlant(double) for further details on the
parameter <code class="docutils literal notranslate"><span class="pre">time_step</span></code>.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">scene_graph</span></code>:</dt><dd><p>(optional) Constructed scene graph. If none is provided, one will
be created and used.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Pair of the registered plant and scene graph.</p>
</dd>
</dl>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">builder</span></code> must be non-null.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ApplyMultibodyPlantConfig">
<span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">ApplyMultibodyPlantConfig</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">config</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlantConfig" title="pydrake.multibody.plant.MultibodyPlantConfig"><span class="pre">pydrake.multibody.plant.MultibodyPlantConfig</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">plant</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.ApplyMultibodyPlantConfig" title="Link to this definition"></a></dt>
<dd><p>Applies settings given in <code class="docutils literal notranslate"><span class="pre">config</span></code> to an existing <code class="docutils literal notranslate"><span class="pre">plant</span></code>. The
<code class="docutils literal notranslate"><span class="pre">time_step</span></code> is the one value in <code class="docutils literal notranslate"><span class="pre">config</span></code> that cannot be updated –
it can only be set in the MultibodyPlant constructor. Consider using
AddMultibodyPlant() or manually passing <code class="docutils literal notranslate"><span class="pre">config.time_step</span></code> when you
construct the MultibodyPlant.</p>
<p>This method must be called pre-Finalize.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if plant is finalized</strong><strong> or </strong><strong>if time_step is changed.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydrake.multibody.plant.CalcContactFrictionFromSurfaceProperties">
<span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">CalcContactFrictionFromSurfaceProperties</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.CalcContactFrictionFromSurfaceProperties" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>CalcContactFrictionFromSurfaceProperties(surface_properties1: pydrake.multibody.plant.CoulombFriction, surface_properties2: pydrake.multibody.plant.CoulombFriction) -&gt; pydrake.multibody.plant.CoulombFriction</p></li>
</ol>
<p>Given the surface properties of two different surfaces, this method
computes the Coulomb’s law coefficients of friction characterizing the
interaction by friction of the given surface pair. The surface
properties are specified by individual Coulomb’s law coefficients of
friction. As outlined in the class’s documentation for
CoulombFriction, friction coefficients characterize a surface pair and
not individual surfaces. However, we find it useful in practice to
associate the abstract <strong>idea</strong> of friction coefficients to a single
surface. Please refer to the documentation for CoulombFriction for
details on this topic.</p>
<p>More specifically, this method computes the contact coefficients for
the given surface pair as:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">μ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="n">μₘμₙ</span><span class="o">/</span><span class="p">(</span><span class="n">μₘ</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">μₙ</span><span class="p">)</span>
</pre></div>
</div>
</details><p>where the operation above is performed separately on the static and
dynamic friction coefficients.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">surface_properties1</span></code>:</dt><dd><p>Surface properties for surface 1. Specified as an individual set
of Coulomb’s law coefficients of friction.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">surface_properties2</span></code>:</dt><dd><p>Surface properties for surface 2. Specified as an individual set
of Coulomb’s law coefficients of friction.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>the combined friction coefficients for the interacting surfaces.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>CalcContactFrictionFromSurfaceProperties(surface_properties1: pydrake.multibody.plant.CoulombFriction_[AutoDiffXd], surface_properties2: pydrake.multibody.plant.CoulombFriction_[AutoDiffXd]) -&gt; pydrake.multibody.plant.CoulombFriction_[AutoDiffXd]</p></li>
</ol>
<p>Given the surface properties of two different surfaces, this method
computes the Coulomb’s law coefficients of friction characterizing the
interaction by friction of the given surface pair. The surface
properties are specified by individual Coulomb’s law coefficients of
friction. As outlined in the class’s documentation for
CoulombFriction, friction coefficients characterize a surface pair and
not individual surfaces. However, we find it useful in practice to
associate the abstract <strong>idea</strong> of friction coefficients to a single
surface. Please refer to the documentation for CoulombFriction for
details on this topic.</p>
<p>More specifically, this method computes the contact coefficients for
the given surface pair as:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">μ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="n">μₘμₙ</span><span class="o">/</span><span class="p">(</span><span class="n">μₘ</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">μₙ</span><span class="p">)</span>
</pre></div>
</div>
</details><p>where the operation above is performed separately on the static and
dynamic friction coefficients.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">surface_properties1</span></code>:</dt><dd><p>Surface properties for surface 1. Specified as an individual set
of Coulomb’s law coefficients of friction.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">surface_properties2</span></code>:</dt><dd><p>Surface properties for surface 2. Specified as an individual set
of Coulomb’s law coefficients of friction.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>the combined friction coefficients for the interacting surfaces.</p>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li><p>CalcContactFrictionFromSurfaceProperties(surface_properties1: pydrake.multibody.plant.CoulombFriction_[Expression], surface_properties2: pydrake.multibody.plant.CoulombFriction_[Expression]) -&gt; pydrake.multibody.plant.CoulombFriction_[Expression]</p></li>
</ol>
<p>Given the surface properties of two different surfaces, this method
computes the Coulomb’s law coefficients of friction characterizing the
interaction by friction of the given surface pair. The surface
properties are specified by individual Coulomb’s law coefficients of
friction. As outlined in the class’s documentation for
CoulombFriction, friction coefficients characterize a surface pair and
not individual surfaces. However, we find it useful in practice to
associate the abstract <strong>idea</strong> of friction coefficients to a single
surface. Please refer to the documentation for CoulombFriction for
details on this topic.</p>
<p>More specifically, this method computes the contact coefficients for
the given surface pair as:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">μ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="n">μₘμₙ</span><span class="o">/</span><span class="p">(</span><span class="n">μₘ</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">μₙ</span><span class="p">)</span>
</pre></div>
</div>
</details><p>where the operation above is performed separately on the static and
dynamic friction coefficients.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">surface_properties1</span></code>:</dt><dd><p>Surface properties for surface 1. Specified as an individual set
of Coulomb’s law coefficients of friction.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">surface_properties2</span></code>:</dt><dd><p>Surface properties for surface 2. Specified as an individual set
of Coulomb’s law coefficients of friction.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>the combined friction coefficients for the interacting surfaces.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ConnectContactResultsToDrakeVisualizer">
<span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">ConnectContactResultsToDrakeVisualizer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">builder:</span> <span class="pre">pydrake.systems.framework.DiagramBuilder</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plant:</span> <span class="pre">drake::multibody::MultibodyPlant&lt;double&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scene_graph:</span> <span class="pre">pydrake.geometry.SceneGraph</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lcm:</span> <span class="pre">pydrake.lcm.DrakeLcmInterface</span> <span class="pre">=</span> <span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">publish_period:</span> <span class="pre">Optional[float]</span> <span class="pre">=</span> <span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.lcm.html#pydrake.systems.lcm.LcmPublisherSystem" title="pydrake.systems.lcm.LcmPublisherSystem"><span class="pre">pydrake.systems.lcm.LcmPublisherSystem</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.ConnectContactResultsToDrakeVisualizer" title="Link to this definition"></a></dt>
<dd><p>MultibodyPlant-connecting overload.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ContactModel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">ContactModel</span></span><a class="headerlink" href="#pydrake.multibody.plant.ContactModel" title="Link to this definition"></a></dt>
<dd><p>Enumeration for contact model options.</p>
<p>Members:</p>
<blockquote>
<div><p>kHydroelastic : Contact forces are computed using the Hydroelastic model. Contact</p>
</div></blockquote>
<p>between unsupported geometries will cause a runtime exception.</p>
<blockquote>
<div><p>kPoint : Contact forces are computed using a point contact model, see</p>
</div></blockquote>
<p>compliant_point_contact.</p>
<blockquote>
<div><p>kHydroelasticWithFallback : Contact forces are computed using the hydroelastic model, where</p>
</div></blockquote>
<p>possible. For most other unsupported colliding pairs, the point model
from kPoint is used. See
geometry::QueryObject::ComputeContactSurfacesWithFallback for more
details.</p>
<blockquote>
<div><p>kHydroelasticsOnly : Legacy alias. TODO(jwnimmer-tri) Deprecate this constant.</p>
<p>kPointContactOnly : Legacy alias. TODO(jwnimmer-tri) Deprecate this constant.</p>
</div></blockquote>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ContactModel.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.ContactModel" title="pydrake.multibody.plant.ContactModel"><span class="pre">pydrake.multibody.plant.ContactModel</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.ContactModel.__init__" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ContactModel.kHydroelastic">
<span class="sig-name descname"><span class="pre">kHydroelastic</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;ContactModel.kHydroelastic:</span> <span class="pre">0&gt;</span></em><a class="headerlink" href="#pydrake.multibody.plant.ContactModel.kHydroelastic" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ContactModel.kHydroelasticsOnly">
<span class="sig-name descname"><span class="pre">kHydroelasticsOnly</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;ContactModel.kHydroelastic:</span> <span class="pre">0&gt;</span></em><a class="headerlink" href="#pydrake.multibody.plant.ContactModel.kHydroelasticsOnly" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ContactModel.kHydroelasticWithFallback">
<span class="sig-name descname"><span class="pre">kHydroelasticWithFallback</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;ContactModel.kHydroelasticWithFallback:</span> <span class="pre">2&gt;</span></em><a class="headerlink" href="#pydrake.multibody.plant.ContactModel.kHydroelasticWithFallback" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ContactModel.kPoint">
<span class="sig-name descname"><span class="pre">kPoint</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;ContactModel.kPoint:</span> <span class="pre">1&gt;</span></em><a class="headerlink" href="#pydrake.multibody.plant.ContactModel.kPoint" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ContactModel.kPointContactOnly">
<span class="sig-name descname"><span class="pre">kPointContactOnly</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;ContactModel.kPoint:</span> <span class="pre">1&gt;</span></em><a class="headerlink" href="#pydrake.multibody.plant.ContactModel.kPointContactOnly" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ContactModel.name">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">name</span></span><a class="headerlink" href="#pydrake.multibody.plant.ContactModel.name" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ContactModel.value">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">value</span></span><a class="headerlink" href="#pydrake.multibody.plant.ContactModel.value" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ContactResults">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">ContactResults</span></span><a class="headerlink" href="#pydrake.multibody.plant.ContactResults" title="Link to this definition"></a></dt>
<dd><p>A container class storing the contact results information for each
contact pair for a given state of the simulation.</p>
<p>This class is immutable, so can be efficiently copied and moved.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <a class="reference internal" href="#pydrake.multibody.plant.ContactResults_" title="pydrake.multibody.plant.ContactResults_"><code class="xref py py-class docutils literal notranslate"><span class="pre">ContactResults_</span></code></a>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ContactResults.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.ContactResults" title="pydrake.multibody.plant.ContactResults"><span class="pre">pydrake.multibody.plant.ContactResults</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.ContactResults.__init__" title="Link to this definition"></a></dt>
<dd><p>Constructs an empty ContactResults.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ContactResults.deformable_contact_info">
<span class="sig-name descname"><span class="pre">deformable_contact_info</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.ContactResults" title="pydrake.multibody.plant.ContactResults"><span class="pre">pydrake.multibody.plant.ContactResults</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">i</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.multibody.plant.DeformableContactInfo" title="pydrake.multibody.plant.DeformableContactInfo"><span class="pre">pydrake.multibody.plant.DeformableContactInfo</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.ContactResults.deformable_contact_info" title="Link to this definition"></a></dt>
<dd><p>Retrieves the ith DeformableContactInfo instance. The input index i
must be in the range [0, <code class="docutils literal notranslate"><span class="pre">num_deformable_contacts()</span></code>) or this method
throws.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ContactResults.hydroelastic_contact_info">
<span class="sig-name descname"><span class="pre">hydroelastic_contact_info</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.ContactResults" title="pydrake.multibody.plant.ContactResults"><span class="pre">pydrake.multibody.plant.ContactResults</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">i</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.multibody.plant.HydroelasticContactInfo" title="pydrake.multibody.plant.HydroelasticContactInfo"><span class="pre">pydrake.multibody.plant.HydroelasticContactInfo</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.ContactResults.hydroelastic_contact_info" title="Link to this definition"></a></dt>
<dd><p>Retrieves the ith HydroelasticContactInfo instance. The input index i
must be in the range [0, <code class="docutils literal notranslate"><span class="pre">num_hydroelastic_contacts()</span></code>) or this
method throws.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ContactResults.num_deformable_contacts">
<span class="sig-name descname"><span class="pre">num_deformable_contacts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.ContactResults" title="pydrake.multibody.plant.ContactResults"><span class="pre">pydrake.multibody.plant.ContactResults</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.ContactResults.num_deformable_contacts" title="Link to this definition"></a></dt>
<dd><p>Returns the number of deformable contacts.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ContactResults.num_hydroelastic_contacts">
<span class="sig-name descname"><span class="pre">num_hydroelastic_contacts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.ContactResults" title="pydrake.multibody.plant.ContactResults"><span class="pre">pydrake.multibody.plant.ContactResults</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.ContactResults.num_hydroelastic_contacts" title="Link to this definition"></a></dt>
<dd><p>Returns the number of hydroelastic contacts.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ContactResults.num_point_pair_contacts">
<span class="sig-name descname"><span class="pre">num_point_pair_contacts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.ContactResults" title="pydrake.multibody.plant.ContactResults"><span class="pre">pydrake.multibody.plant.ContactResults</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.ContactResults.num_point_pair_contacts" title="Link to this definition"></a></dt>
<dd><p>Returns the number of point pair contacts.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ContactResults.plant">
<span class="sig-name descname"><span class="pre">plant</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.ContactResults" title="pydrake.multibody.plant.ContactResults"><span class="pre">pydrake.multibody.plant.ContactResults</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">drake::multibody::MultibodyPlant&lt;double&gt;</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.ContactResults.plant" title="Link to this definition"></a></dt>
<dd><p>Returns the plant that produced these contact results. In most cases
the result will be non-null, but default-constructed results might
have nulls.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ContactResults.point_pair_contact_info">
<span class="sig-name descname"><span class="pre">point_pair_contact_info</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.ContactResults" title="pydrake.multibody.plant.ContactResults"><span class="pre">pydrake.multibody.plant.ContactResults</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">i</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.multibody.plant.PointPairContactInfo" title="pydrake.multibody.plant.PointPairContactInfo"><span class="pre">pydrake.multibody.plant.PointPairContactInfo</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.ContactResults.point_pair_contact_info" title="Link to this definition"></a></dt>
<dd><p>Retrieves the ith PointPairContactInfo instance. The input index i
must be in the range [0, <code class="docutils literal notranslate"><span class="pre">num_point_pair_contacts()</span></code>) or this method
throws.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ContactResults.SelectHydroelastic">
<span class="sig-name descname"><span class="pre">SelectHydroelastic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.ContactResults" title="pydrake.multibody.plant.ContactResults"><span class="pre">pydrake.multibody.plant.ContactResults</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">selector</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#pydrake.multibody.plant.HydroelasticContactInfo" title="pydrake.multibody.plant.HydroelasticContactInfo"><span class="pre">pydrake.multibody.plant.HydroelasticContactInfo</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">bool</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.multibody.plant.ContactResults" title="pydrake.multibody.plant.ContactResults"><span class="pre">pydrake.multibody.plant.ContactResults</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.ContactResults.SelectHydroelastic" title="Link to this definition"></a></dt>
<dd><p>Returns a selective copy of this object. Only HydroelasticContactInfo
instances satisfying the selection criterion are copied; all other
contacts (point_pair and deformable) are unconditionally copied.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">selector</span></code>:</dt><dd><p>Boolean predicate that returns true to select which
HydroelasticContactInfo.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It uses deep copy (unless the operation is trivially identifiable
as being vacuous, e.g., when num_hydroelastic_contacts() == 0).</p>
</div>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ContactResults_">
<em class="property"><span class="pre">template</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">ContactResults_</span></span><a class="headerlink" href="#pydrake.multibody.plant.ContactResults_" title="Link to this definition"></a></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">ContactResults_[float]</span></code>, <a class="reference internal" href="#pydrake.multibody.plant.ContactResults_-AutoDiffXd" title="pydrake.multibody.plant.ContactResults_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">ContactResults_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.plant.ContactResults_-Expression" title="pydrake.multibody.plant.ContactResults_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">ContactResults_[Expression]</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ContactResults_-AutoDiffXd">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">ContactResults_[AutoDiffXd]</span></span><a class="headerlink" href="#pydrake.multibody.plant.ContactResults_-AutoDiffXd" title="Link to this definition"></a></dt>
<dd><p>A container class storing the contact results information for each
contact pair for a given state of the simulation.</p>
<p>This class is immutable, so can be efficiently copied and moved.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ContactResults_-AutoDiffXd-.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.ContactResults_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.ContactResults_-AutoDiffXd-.__init__" title="Link to this definition"></a></dt>
<dd><p>Constructs an empty ContactResults.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ContactResults_-AutoDiffXd-.deformable_contact_info">
<span class="sig-name descname"><span class="pre">deformable_contact_info</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.ContactResults_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.multibody.plant.DeformableContactInfo_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.ContactResults_-AutoDiffXd-.deformable_contact_info" title="Link to this definition"></a></dt>
<dd><p>Retrieves the ith DeformableContactInfo instance. The input index i
must be in the range [0, <code class="docutils literal notranslate"><span class="pre">num_deformable_contacts()</span></code>) or this method
throws.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ContactResults_-AutoDiffXd-.hydroelastic_contact_info">
<span class="sig-name descname"><span class="pre">hydroelastic_contact_info</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.ContactResults_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.multibody.plant.HydroelasticContactInfo_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.ContactResults_-AutoDiffXd-.hydroelastic_contact_info" title="Link to this definition"></a></dt>
<dd><p>Retrieves the ith HydroelasticContactInfo instance. The input index i
must be in the range [0, <code class="docutils literal notranslate"><span class="pre">num_hydroelastic_contacts()</span></code>) or this
method throws.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ContactResults_-AutoDiffXd-.num_deformable_contacts">
<span class="sig-name descname"><span class="pre">num_deformable_contacts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.ContactResults_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.ContactResults_-AutoDiffXd-.num_deformable_contacts" title="Link to this definition"></a></dt>
<dd><p>Returns the number of deformable contacts.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ContactResults_-AutoDiffXd-.num_hydroelastic_contacts">
<span class="sig-name descname"><span class="pre">num_hydroelastic_contacts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.ContactResults_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.ContactResults_-AutoDiffXd-.num_hydroelastic_contacts" title="Link to this definition"></a></dt>
<dd><p>Returns the number of hydroelastic contacts.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ContactResults_-AutoDiffXd-.num_point_pair_contacts">
<span class="sig-name descname"><span class="pre">num_point_pair_contacts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.ContactResults_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.ContactResults_-AutoDiffXd-.num_point_pair_contacts" title="Link to this definition"></a></dt>
<dd><p>Returns the number of point pair contacts.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ContactResults_-AutoDiffXd-.plant">
<span class="sig-name descname"><span class="pre">plant</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.ContactResults_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">drake::multibody::MultibodyPlant&lt;Eigen::AutoDiffScalar&lt;Eigen::Matrix&lt;double,</span> <span class="pre">-1,</span> <span class="pre">1,</span> <span class="pre">0,</span> <span class="pre">-1,</span> <span class="pre">1&gt;</span> <span class="pre">&gt;</span> <span class="pre">&gt;</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.ContactResults_-AutoDiffXd-.plant" title="Link to this definition"></a></dt>
<dd><p>Returns the plant that produced these contact results. In most cases
the result will be non-null, but default-constructed results might
have nulls.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ContactResults_-AutoDiffXd-.point_pair_contact_info">
<span class="sig-name descname"><span class="pre">point_pair_contact_info</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.ContactResults_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.multibody.plant.PointPairContactInfo_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.ContactResults_-AutoDiffXd-.point_pair_contact_info" title="Link to this definition"></a></dt>
<dd><p>Retrieves the ith PointPairContactInfo instance. The input index i
must be in the range [0, <code class="docutils literal notranslate"><span class="pre">num_point_pair_contacts()</span></code>) or this method
throws.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ContactResults_-AutoDiffXd-.SelectHydroelastic">
<span class="sig-name descname"><span class="pre">SelectHydroelastic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.ContactResults_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">selector</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">[</span></span><span class="pre">pydrake.multibody.plant.HydroelasticContactInfo_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">bool</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.multibody.plant.ContactResults_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.ContactResults_-AutoDiffXd-.SelectHydroelastic" title="Link to this definition"></a></dt>
<dd><p>Returns a selective copy of this object. Only HydroelasticContactInfo
instances satisfying the selection criterion are copied; all other
contacts (point_pair and deformable) are unconditionally copied.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">selector</span></code>:</dt><dd><p>Boolean predicate that returns true to select which
HydroelasticContactInfo.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It uses deep copy (unless the operation is trivially identifiable
as being vacuous, e.g., when num_hydroelastic_contacts() == 0).</p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ContactResults_-Expression">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">ContactResults_[Expression]</span></span><a class="headerlink" href="#pydrake.multibody.plant.ContactResults_-Expression" title="Link to this definition"></a></dt>
<dd><p>A container class storing the contact results information for each
contact pair for a given state of the simulation.</p>
<p>This class is immutable, so can be efficiently copied and moved.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ContactResults_-Expression-.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.ContactResults_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.ContactResults_-Expression-.__init__" title="Link to this definition"></a></dt>
<dd><p>Constructs an empty ContactResults.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ContactResults_-Expression-.deformable_contact_info">
<span class="sig-name descname"><span class="pre">deformable_contact_info</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.ContactResults_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.multibody.plant.DeformableContactInfo_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.ContactResults_-Expression-.deformable_contact_info" title="Link to this definition"></a></dt>
<dd><p>Retrieves the ith DeformableContactInfo instance. The input index i
must be in the range [0, <code class="docutils literal notranslate"><span class="pre">num_deformable_contacts()</span></code>) or this method
throws.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ContactResults_-Expression-.hydroelastic_contact_info">
<span class="sig-name descname"><span class="pre">hydroelastic_contact_info</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.ContactResults_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.multibody.plant.HydroelasticContactInfo_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.ContactResults_-Expression-.hydroelastic_contact_info" title="Link to this definition"></a></dt>
<dd><p>Retrieves the ith HydroelasticContactInfo instance. The input index i
must be in the range [0, <code class="docutils literal notranslate"><span class="pre">num_hydroelastic_contacts()</span></code>) or this
method throws.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ContactResults_-Expression-.num_deformable_contacts">
<span class="sig-name descname"><span class="pre">num_deformable_contacts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.ContactResults_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.ContactResults_-Expression-.num_deformable_contacts" title="Link to this definition"></a></dt>
<dd><p>Returns the number of deformable contacts.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ContactResults_-Expression-.num_hydroelastic_contacts">
<span class="sig-name descname"><span class="pre">num_hydroelastic_contacts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.ContactResults_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.ContactResults_-Expression-.num_hydroelastic_contacts" title="Link to this definition"></a></dt>
<dd><p>Returns the number of hydroelastic contacts.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ContactResults_-Expression-.num_point_pair_contacts">
<span class="sig-name descname"><span class="pre">num_point_pair_contacts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.ContactResults_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.ContactResults_-Expression-.num_point_pair_contacts" title="Link to this definition"></a></dt>
<dd><p>Returns the number of point pair contacts.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ContactResults_-Expression-.plant">
<span class="sig-name descname"><span class="pre">plant</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.ContactResults_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">drake::multibody::MultibodyPlant&lt;drake::symbolic::Expression&gt;</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.ContactResults_-Expression-.plant" title="Link to this definition"></a></dt>
<dd><p>Returns the plant that produced these contact results. In most cases
the result will be non-null, but default-constructed results might
have nulls.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ContactResults_-Expression-.point_pair_contact_info">
<span class="sig-name descname"><span class="pre">point_pair_contact_info</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.ContactResults_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.multibody.plant.PointPairContactInfo_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.ContactResults_-Expression-.point_pair_contact_info" title="Link to this definition"></a></dt>
<dd><p>Retrieves the ith PointPairContactInfo instance. The input index i
must be in the range [0, <code class="docutils literal notranslate"><span class="pre">num_point_pair_contacts()</span></code>) or this method
throws.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ContactResults_-Expression-.SelectHydroelastic">
<span class="sig-name descname"><span class="pre">SelectHydroelastic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.ContactResults_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">selector</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">[</span></span><span class="pre">pydrake.multibody.plant.HydroelasticContactInfo_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">bool</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.multibody.plant.ContactResults_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.ContactResults_-Expression-.SelectHydroelastic" title="Link to this definition"></a></dt>
<dd><p>Returns a selective copy of this object. Only HydroelasticContactInfo
instances satisfying the selection criterion are copied; all other
contacts (point_pair and deformable) are unconditionally copied.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">selector</span></code>:</dt><dd><p>Boolean predicate that returns true to select which
HydroelasticContactInfo.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It uses deep copy (unless the operation is trivially identifiable
as being vacuous, e.g., when num_hydroelastic_contacts() == 0).</p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ContactResultsToLcmSystem">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">ContactResultsToLcmSystem</span></span><a class="headerlink" href="#pydrake.multibody.plant.ContactResultsToLcmSystem" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.LeafSystem" title="pydrake.systems.framework.LeafSystem"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem</span></code></a></p>
<p>A System that encodes ContactResults into a
lcmt_contact_results_for_viz message. It has a single input port with
type ContactResults&lt;T&gt; and a single output port with
lcmt_contact_results_for_viz.</p>
<p>Although this class can be instantiated on all default scalars, its
functionality will be limited for <code class="docutils literal notranslate"><span class="pre">T</span></code> = symbolic::Expression. If
there are any symbolic::Variable instances in the expression,
attempting to evaluate the output port will throw an exception. The
support is sufficient that a systems::Diagram with a
ContactResultsToLcmSystem can be scalar converted to
symbolic::Expression without error, but not necessarily evaluated.</p>
<p><strong>Constructing instances</strong></p>
<p>Generally, you shouldn’t construct ContactResultsToLcmSystem instances
directly. We recommend using one of the overloaded
contact_result_vis_creation “ConnectContactResultsToDrakeVisualizer()”
functions to add contact visualization to your diagram.</p>
<p><strong>How contacts are described in visualization</strong></p>
<p>In the visualizer, each contact between two bodies is uniquely
characterized by two triples of names: (model instance name, body
name, geometry name). These triples help distinguish contacts which
might otherwise be ambiguous (e.g., contact with two bodies, both
called “box” but part of different model instances).</p>
<p>ContactResultsToLcmSystem gets the model instance and body names from
an instance of MultibodyPlant, but <em>geometry</em> names are not available
from the plant. By default, ContactResultsToLcmSystem will <em>generate</em>
a unique name based on a geometry’s unique id (e.g., “Id(7)”). For
many applications (those cases where each body has only a single
collision geometry), this is perfectly acceptable. However, in cases
where a body has multiple collision geometries, those default names
may not be helpful when viewing the visualized results. Instead,
ContactResultsToLcmSystem can use the names associated with the id in
a geometry::SceneGraph instance. The only method for doing this is via
the contact_result_vis_creation
“ConnectContactResultsToDrakeVisualizer()” functions and requires the
diagram to be instantiated as double valued. If a diagram with a
different scalar type is required, it should subsequently be scalar
converted.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">u0&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>ContactResultsToLcmSystem</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y0</td></tr></table></td></tr></table><dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ContactResultsToLcmSystem.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self:</span> <span class="pre">pydrake.multibody.plant.ContactResultsToLcmSystem</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plant:</span> <span class="pre">drake::multibody::MultibodyPlant&lt;double&gt;</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.ContactResultsToLcmSystem.__init__" title="Link to this definition"></a></dt>
<dd><p>Constructs an instance with <em>default</em> geometry names (e.g., “Id(7)”).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">plant</span></code>:</dt><dd><p>The MultibodyPlant that the ContactResults are generated from.</p>
</dd>
<dt>Precondition:</dt><dd><p>The <code class="docutils literal notranslate"><span class="pre">plant</span></code> parameter (or a fully equivalent plant) connects to
<code class="docutils literal notranslate"><span class="pre">this</span></code> system’s input port.</p>
</dd>
<dt>Precondition:</dt><dd><p>The <code class="docutils literal notranslate"><span class="pre">plant</span></code> parameter is finalized.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ContactResultsToLcmSystem.get_contact_result_input_port">
<span class="sig-name descname"><span class="pre">get_contact_result_input_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.ContactResultsToLcmSystem" title="pydrake.multibody.plant.ContactResultsToLcmSystem"><span class="pre">pydrake.multibody.plant.ContactResultsToLcmSystem</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.InputPort" title="pydrake.systems.framework.InputPort"><span class="pre">pydrake.systems.framework.InputPort</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.ContactResultsToLcmSystem.get_contact_result_input_port" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ContactResultsToLcmSystem.get_lcm_message_output_port">
<span class="sig-name descname"><span class="pre">get_lcm_message_output_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.ContactResultsToLcmSystem" title="pydrake.multibody.plant.ContactResultsToLcmSystem"><span class="pre">pydrake.multibody.plant.ContactResultsToLcmSystem</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.OutputPort" title="pydrake.systems.framework.OutputPort"><span class="pre">pydrake.systems.framework.OutputPort</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.ContactResultsToLcmSystem.get_lcm_message_output_port" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.multibody.plant.CoulombFriction">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">CoulombFriction</span></span><a class="headerlink" href="#pydrake.multibody.plant.CoulombFriction" title="Link to this definition"></a></dt>
<dd><p>Parameters for Coulomb’s Law of Friction, namely:</p>
<ul class="simple">
<li><p>Static friction coefficient, for a pair of surfaces at rest relative to
each other.</p></li>
<li><p>Dynamic (or kinematic) friction coefficient, for a pair of surfaces in
relative motion.</p></li>
</ul>
<p>These coefficients are an empirical property characterizing the
interaction by friction between a pair of contacting surfaces.
Friction coefficients depend upon the mechanical properties of the
surfaces’ materials and on the roughness of the surfaces. They are
determined experimentally.</p>
<p>Even though the Coulomb’s law coefficients of friction characterize a
pair of surfaces interacting by friction, we associate the abstract
<strong>idea</strong> of friction coefficients to a single surface by considering
the coefficients for contact between two identical surfaces. For this
case of two identical surfaces, the friction coefficients that
describe the surface pair are taken to equal those of one of the
identical surfaces. We extend this idea to the case of different
surfaces by defining a <strong>combination law</strong> that allow us to obtain the
Coulomb’s law coefficients of friction characterizing the pair of
surfaces, given the individual friction coefficients of each surface.
We would like this <strong>combination law</strong> to satisfy:</p>
<ul class="simple">
<li><p>The friction coefficient of two identical surfaces is the friction
coefficient of one of the surfaces.</p></li>
<li><p>The combination law is commutative. That is, surface A combined with
surface B gives the same results as surface B combined with surface A.</p></li>
<li><p>For two surfaces M and N with very different friction coefficients, say
<code class="docutils literal notranslate"><span class="pre">μₘ</span> <span class="pre">≪</span> <span class="pre">μₙ</span></code>, the combined friction coefficient should be in the order of
magnitude of the smallest friction coefficient (in the example μₘ). To
understand this requirement, consider rubber (high friction coefficient)
sliding on ice (low friction coefficient). We’d like the surface pair
to be defined by a friction coefficient close to that of ice, since rubber
will easily slide on ice.</p></li>
</ul>
<p>These requirements are met by the following ad-hoc combination law:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">μ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="n">μₘμₙ</span><span class="o">/</span><span class="p">(</span><span class="n">μₘ</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">μₙ</span><span class="p">)</span>
</pre></div>
</div>
</details><p>See CalcContactFrictionFromSurfaceProperties(), which implements this
law. More complex combination laws could also be a function of other
parameters such as the mechanical properties of the interacting
surfaces or even their roughnesses. For instance, if the rubber
surface above has metal studs (somehow making the surface “rougher”),
it will definitely have a better grip on an ice surface. Therefore
this new variable should be taken into account in the combination law.
Notice that in this example, this new combination law model for tires,
will have a different set of requirements from the ones stated above.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <a class="reference internal" href="#pydrake.multibody.plant.CoulombFriction_" title="pydrake.multibody.plant.CoulombFriction_"><code class="xref py py-class docutils literal notranslate"><span class="pre">CoulombFriction_</span></code></a>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.CoulombFriction.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.CoulombFriction.__init__" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.multibody.plant.CoulombFriction) -&gt; None</p></li>
</ol>
<p>Default constructor for a frictionless surface, i.e. with zero static
and dynamic coefficients of friction.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.multibody.plant.CoulombFriction, static_friction: float, dynamic_friction: float) -&gt; None</p></li>
</ol>
<p>Specifies both the static and dynamic friction coefficients for a
given surface.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if any</strong><strong> of </strong><strong>the friction coefficients are negative or</strong> – </p></li>
<li><p><strong>if dynamic_friction &gt; static_friction</strong><strong> (</strong><strong>they can be equal.</strong><strong>)</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.CoulombFriction.dynamic_friction">
<span class="sig-name descname"><span class="pre">dynamic_friction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.CoulombFriction" title="pydrake.multibody.plant.CoulombFriction"><span class="pre">pydrake.multibody.plant.CoulombFriction</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.CoulombFriction.dynamic_friction" title="Link to this definition"></a></dt>
<dd><p>Returns the coefficient of dynamic friction.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.CoulombFriction.static_friction">
<span class="sig-name descname"><span class="pre">static_friction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.CoulombFriction" title="pydrake.multibody.plant.CoulombFriction"><span class="pre">pydrake.multibody.plant.CoulombFriction</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.CoulombFriction.static_friction" title="Link to this definition"></a></dt>
<dd><p>Returns the coefficient of static friction.</p>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py" id="pydrake.multibody.plant.CoulombFriction_">
<em class="property"><span class="pre">template</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">CoulombFriction_</span></span><a class="headerlink" href="#pydrake.multibody.plant.CoulombFriction_" title="Link to this definition"></a></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">CoulombFriction_[float]</span></code>, <a class="reference internal" href="#pydrake.multibody.plant.CoulombFriction_-AutoDiffXd" title="pydrake.multibody.plant.CoulombFriction_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">CoulombFriction_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.plant.CoulombFriction_-Expression" title="pydrake.multibody.plant.CoulombFriction_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">CoulombFriction_[Expression]</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.multibody.plant.CoulombFriction_-AutoDiffXd">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">CoulombFriction_[AutoDiffXd]</span></span><a class="headerlink" href="#pydrake.multibody.plant.CoulombFriction_-AutoDiffXd" title="Link to this definition"></a></dt>
<dd><p>Parameters for Coulomb’s Law of Friction, namely:</p>
<ul class="simple">
<li><p>Static friction coefficient, for a pair of surfaces at rest relative to
each other.</p></li>
<li><p>Dynamic (or kinematic) friction coefficient, for a pair of surfaces in
relative motion.</p></li>
</ul>
<p>These coefficients are an empirical property characterizing the
interaction by friction between a pair of contacting surfaces.
Friction coefficients depend upon the mechanical properties of the
surfaces’ materials and on the roughness of the surfaces. They are
determined experimentally.</p>
<p>Even though the Coulomb’s law coefficients of friction characterize a
pair of surfaces interacting by friction, we associate the abstract
<strong>idea</strong> of friction coefficients to a single surface by considering
the coefficients for contact between two identical surfaces. For this
case of two identical surfaces, the friction coefficients that
describe the surface pair are taken to equal those of one of the
identical surfaces. We extend this idea to the case of different
surfaces by defining a <strong>combination law</strong> that allow us to obtain the
Coulomb’s law coefficients of friction characterizing the pair of
surfaces, given the individual friction coefficients of each surface.
We would like this <strong>combination law</strong> to satisfy:</p>
<ul class="simple">
<li><p>The friction coefficient of two identical surfaces is the friction
coefficient of one of the surfaces.</p></li>
<li><p>The combination law is commutative. That is, surface A combined with
surface B gives the same results as surface B combined with surface A.</p></li>
<li><p>For two surfaces M and N with very different friction coefficients, say
<code class="docutils literal notranslate"><span class="pre">μₘ</span> <span class="pre">≪</span> <span class="pre">μₙ</span></code>, the combined friction coefficient should be in the order of
magnitude of the smallest friction coefficient (in the example μₘ). To
understand this requirement, consider rubber (high friction coefficient)
sliding on ice (low friction coefficient). We’d like the surface pair
to be defined by a friction coefficient close to that of ice, since rubber
will easily slide on ice.</p></li>
</ul>
<p>These requirements are met by the following ad-hoc combination law:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">μ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="n">μₘμₙ</span><span class="o">/</span><span class="p">(</span><span class="n">μₘ</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">μₙ</span><span class="p">)</span>
</pre></div>
</div>
</details><p>See CalcContactFrictionFromSurfaceProperties(), which implements this
law. More complex combination laws could also be a function of other
parameters such as the mechanical properties of the interacting
surfaces or even their roughnesses. For instance, if the rubber
surface above has metal studs (somehow making the surface “rougher”),
it will definitely have a better grip on an ice surface. Therefore
this new variable should be taken into account in the combination law.
Notice that in this example, this new combination law model for tires,
will have a different set of requirements from the ones stated above.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.CoulombFriction_-AutoDiffXd-.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.CoulombFriction_-AutoDiffXd-.__init__" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.multibody.plant.CoulombFriction_[AutoDiffXd]) -&gt; None</p></li>
</ol>
<p>Default constructor for a frictionless surface, i.e. with zero static
and dynamic coefficients of friction.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.multibody.plant.CoulombFriction_[AutoDiffXd], static_friction: pydrake.autodiffutils.AutoDiffXd, dynamic_friction: pydrake.autodiffutils.AutoDiffXd) -&gt; None</p></li>
</ol>
<p>Specifies both the static and dynamic friction coefficients for a
given surface.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if any</strong><strong> of </strong><strong>the friction coefficients are negative or</strong> – </p></li>
<li><p><strong>if dynamic_friction &gt; static_friction</strong><strong> (</strong><strong>they can be equal.</strong><strong>)</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.CoulombFriction_-AutoDiffXd-.dynamic_friction">
<span class="sig-name descname"><span class="pre">dynamic_friction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.CoulombFriction_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">pydrake.autodiffutils.AutoDiffXd</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.CoulombFriction_-AutoDiffXd-.dynamic_friction" title="Link to this definition"></a></dt>
<dd><p>Returns the coefficient of dynamic friction.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.CoulombFriction_-AutoDiffXd-.static_friction">
<span class="sig-name descname"><span class="pre">static_friction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.CoulombFriction_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">pydrake.autodiffutils.AutoDiffXd</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.CoulombFriction_-AutoDiffXd-.static_friction" title="Link to this definition"></a></dt>
<dd><p>Returns the coefficient of static friction.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.multibody.plant.CoulombFriction_-Expression">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">CoulombFriction_[Expression]</span></span><a class="headerlink" href="#pydrake.multibody.plant.CoulombFriction_-Expression" title="Link to this definition"></a></dt>
<dd><p>Parameters for Coulomb’s Law of Friction, namely:</p>
<ul class="simple">
<li><p>Static friction coefficient, for a pair of surfaces at rest relative to
each other.</p></li>
<li><p>Dynamic (or kinematic) friction coefficient, for a pair of surfaces in
relative motion.</p></li>
</ul>
<p>These coefficients are an empirical property characterizing the
interaction by friction between a pair of contacting surfaces.
Friction coefficients depend upon the mechanical properties of the
surfaces’ materials and on the roughness of the surfaces. They are
determined experimentally.</p>
<p>Even though the Coulomb’s law coefficients of friction characterize a
pair of surfaces interacting by friction, we associate the abstract
<strong>idea</strong> of friction coefficients to a single surface by considering
the coefficients for contact between two identical surfaces. For this
case of two identical surfaces, the friction coefficients that
describe the surface pair are taken to equal those of one of the
identical surfaces. We extend this idea to the case of different
surfaces by defining a <strong>combination law</strong> that allow us to obtain the
Coulomb’s law coefficients of friction characterizing the pair of
surfaces, given the individual friction coefficients of each surface.
We would like this <strong>combination law</strong> to satisfy:</p>
<ul class="simple">
<li><p>The friction coefficient of two identical surfaces is the friction
coefficient of one of the surfaces.</p></li>
<li><p>The combination law is commutative. That is, surface A combined with
surface B gives the same results as surface B combined with surface A.</p></li>
<li><p>For two surfaces M and N with very different friction coefficients, say
<code class="docutils literal notranslate"><span class="pre">μₘ</span> <span class="pre">≪</span> <span class="pre">μₙ</span></code>, the combined friction coefficient should be in the order of
magnitude of the smallest friction coefficient (in the example μₘ). To
understand this requirement, consider rubber (high friction coefficient)
sliding on ice (low friction coefficient). We’d like the surface pair
to be defined by a friction coefficient close to that of ice, since rubber
will easily slide on ice.</p></li>
</ul>
<p>These requirements are met by the following ad-hoc combination law:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">μ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="n">μₘμₙ</span><span class="o">/</span><span class="p">(</span><span class="n">μₘ</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">μₙ</span><span class="p">)</span>
</pre></div>
</div>
</details><p>See CalcContactFrictionFromSurfaceProperties(), which implements this
law. More complex combination laws could also be a function of other
parameters such as the mechanical properties of the interacting
surfaces or even their roughnesses. For instance, if the rubber
surface above has metal studs (somehow making the surface “rougher”),
it will definitely have a better grip on an ice surface. Therefore
this new variable should be taken into account in the combination law.
Notice that in this example, this new combination law model for tires,
will have a different set of requirements from the ones stated above.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.CoulombFriction_-Expression-.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.CoulombFriction_-Expression-.__init__" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.multibody.plant.CoulombFriction_[Expression]) -&gt; None</p></li>
</ol>
<p>Default constructor for a frictionless surface, i.e. with zero static
and dynamic coefficients of friction.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.multibody.plant.CoulombFriction_[Expression], static_friction: pydrake.symbolic.Expression, dynamic_friction: pydrake.symbolic.Expression) -&gt; None</p></li>
</ol>
<p>Specifies both the static and dynamic friction coefficients for a
given surface.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if any</strong><strong> of </strong><strong>the friction coefficients are negative or</strong> – </p></li>
<li><p><strong>if dynamic_friction &gt; static_friction</strong><strong> (</strong><strong>they can be equal.</strong><strong>)</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.CoulombFriction_-Expression-.dynamic_friction">
<span class="sig-name descname"><span class="pre">dynamic_friction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.CoulombFriction_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">pydrake.symbolic.Expression</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.CoulombFriction_-Expression-.dynamic_friction" title="Link to this definition"></a></dt>
<dd><p>Returns the coefficient of dynamic friction.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.CoulombFriction_-Expression-.static_friction">
<span class="sig-name descname"><span class="pre">static_friction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.CoulombFriction_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">pydrake.symbolic.Expression</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.CoulombFriction_-Expression-.static_friction" title="Link to this definition"></a></dt>
<dd><p>Returns the coefficient of static friction.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.multibody.plant.DeformableContactInfo">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">DeformableContactInfo</span></span><a class="headerlink" href="#pydrake.multibody.plant.DeformableContactInfo" title="Link to this definition"></a></dt>
<dd><p>A class containing information regarding contact and contact response
between two geometries belonging to a pair of bodies with at least one
of them being a deformable body. This class provides:</p>
<ul class="simple">
<li><p>The shared contact mesh between the two geometries.</p></li>
<li><p>The tractions acting at the contact points on the contact mesh.</p></li>
<li><p>The slip speeds at the contact points on the contact mesh.</p></li>
<li><p>The spatial force from the integrated tractions that is applied at the</p></li>
</ul>
<p>centroid of the contact surface.</p>
<p>The two geometries are denoted as A and B respectively with geometry A
guaranteed to be belonging to a deformable body.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This feature is considered to be <strong>experimental</strong> and may change
or be removed at any time, without any deprecation notice ahead of
time.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <a class="reference internal" href="#pydrake.multibody.plant.DeformableContactInfo_" title="pydrake.multibody.plant.DeformableContactInfo_"><code class="xref py py-class docutils literal notranslate"><span class="pre">DeformableContactInfo_</span></code></a>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.DeformableContactInfo.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.DeformableContactInfo" title="pydrake.multibody.plant.DeformableContactInfo"><span class="pre">pydrake.multibody.plant.DeformableContactInfo</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">id_A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.GeometryId" title="pydrake.geometry.GeometryId"><span class="pre">pydrake.geometry.GeometryId</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">id_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.GeometryId" title="pydrake.geometry.GeometryId"><span class="pre">pydrake.geometry.GeometryId</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">contact_mesh_W</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.PolygonSurfaceMesh" title="pydrake.geometry.PolygonSurfaceMesh"><span class="pre">pydrake.geometry.PolygonSurfaceMesh</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">F_Ac_W</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.math.html#pydrake.multibody.math.SpatialForce" title="pydrake.multibody.math.SpatialForce"><span class="pre">pydrake.multibody.math.SpatialForce</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.DeformableContactInfo.__init__" title="Link to this definition"></a></dt>
<dd><p>Constructs a DeformableContactInfo.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">id_A</span></code>:</dt><dd><p>The geometry id of the deformable geometry A.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">id_B</span></code>:</dt><dd><p>The geometry id of geometry B.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">contact_mesh_W</span></code>:</dt><dd><p>The contact mesh between geometries A and B in the world frame.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">F_Ac_W</span></code>:</dt><dd><p>Spatial force acting on body A, at contact mesh centroid C, and
expressed in the world frame.</p>
</dd>
<dt>Precondition:</dt><dd><p>id_A corresponds to a deformable geometry.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.DeformableContactInfo.contact_mesh">
<span class="sig-name descname"><span class="pre">contact_mesh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.DeformableContactInfo" title="pydrake.multibody.plant.DeformableContactInfo"><span class="pre">pydrake.multibody.plant.DeformableContactInfo</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.PolygonSurfaceMesh" title="pydrake.geometry.PolygonSurfaceMesh"><span class="pre">pydrake.geometry.PolygonSurfaceMesh</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.DeformableContactInfo.contact_mesh" title="Link to this definition"></a></dt>
<dd><p>Returns a reference to the contact mesh expressed in the world frame.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.DeformableContactInfo.F_Ac_W">
<span class="sig-name descname"><span class="pre">F_Ac_W</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.DeformableContactInfo" title="pydrake.multibody.plant.DeformableContactInfo"><span class="pre">pydrake.multibody.plant.DeformableContactInfo</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.math.html#pydrake.multibody.math.SpatialForce" title="pydrake.multibody.math.SpatialForce"><span class="pre">pydrake.multibody.math.SpatialForce</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.DeformableContactInfo.F_Ac_W" title="Link to this definition"></a></dt>
<dd><p>Gets the spatial force applied on the deformable body associated with
geometry A, at the centroid point C of the contact surface mesh, and
expressed in the world frame W.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.DeformableContactInfo.id_A">
<span class="sig-name descname"><span class="pre">id_A</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.DeformableContactInfo" title="pydrake.multibody.plant.DeformableContactInfo"><span class="pre">pydrake.multibody.plant.DeformableContactInfo</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.GeometryId" title="pydrake.geometry.GeometryId"><span class="pre">pydrake.geometry.GeometryId</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.DeformableContactInfo.id_A" title="Link to this definition"></a></dt>
<dd><p>The geometry id of geometry A, guaranteed to belong to a deformable
body in contact.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.DeformableContactInfo.id_B">
<span class="sig-name descname"><span class="pre">id_B</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.DeformableContactInfo" title="pydrake.multibody.plant.DeformableContactInfo"><span class="pre">pydrake.multibody.plant.DeformableContactInfo</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.GeometryId" title="pydrake.geometry.GeometryId"><span class="pre">pydrake.geometry.GeometryId</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.DeformableContactInfo.id_B" title="Link to this definition"></a></dt>
<dd><p>The geometry id of geometry B.</p>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py" id="pydrake.multibody.plant.DeformableContactInfo_">
<em class="property"><span class="pre">template</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">DeformableContactInfo_</span></span><a class="headerlink" href="#pydrake.multibody.plant.DeformableContactInfo_" title="Link to this definition"></a></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">DeformableContactInfo_[float]</span></code>, <a class="reference internal" href="#pydrake.multibody.plant.DeformableContactInfo_-AutoDiffXd" title="pydrake.multibody.plant.DeformableContactInfo_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">DeformableContactInfo_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.plant.DeformableContactInfo_-Expression" title="pydrake.multibody.plant.DeformableContactInfo_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">DeformableContactInfo_[Expression]</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.multibody.plant.DeformableContactInfo_-AutoDiffXd">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">DeformableContactInfo_[AutoDiffXd]</span></span><a class="headerlink" href="#pydrake.multibody.plant.DeformableContactInfo_-AutoDiffXd" title="Link to this definition"></a></dt>
<dd><p>A class containing information regarding contact and contact response
between two geometries belonging to a pair of bodies with at least one
of them being a deformable body. This class provides:</p>
<ul class="simple">
<li><p>The shared contact mesh between the two geometries.</p></li>
<li><p>The tractions acting at the contact points on the contact mesh.</p></li>
<li><p>The slip speeds at the contact points on the contact mesh.</p></li>
<li><p>The spatial force from the integrated tractions that is applied at the</p></li>
</ul>
<p>centroid of the contact surface.</p>
<p>The two geometries are denoted as A and B respectively with geometry A
guaranteed to be belonging to a deformable body.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This feature is considered to be <strong>experimental</strong> and may change
or be removed at any time, without any deprecation notice ahead of
time.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.DeformableContactInfo_-AutoDiffXd-.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.DeformableContactInfo_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">id_A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.GeometryId" title="pydrake.geometry.GeometryId"><span class="pre">pydrake.geometry.GeometryId</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">id_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.GeometryId" title="pydrake.geometry.GeometryId"><span class="pre">pydrake.geometry.GeometryId</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">contact_mesh_W</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.geometry.PolygonSurfaceMesh_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">F_Ac_W</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.math.SpatialForce_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.DeformableContactInfo_-AutoDiffXd-.__init__" title="Link to this definition"></a></dt>
<dd><p>Constructs a DeformableContactInfo.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">id_A</span></code>:</dt><dd><p>The geometry id of the deformable geometry A.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">id_B</span></code>:</dt><dd><p>The geometry id of geometry B.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">contact_mesh_W</span></code>:</dt><dd><p>The contact mesh between geometries A and B in the world frame.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">F_Ac_W</span></code>:</dt><dd><p>Spatial force acting on body A, at contact mesh centroid C, and
expressed in the world frame.</p>
</dd>
<dt>Precondition:</dt><dd><p>id_A corresponds to a deformable geometry.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.DeformableContactInfo_-AutoDiffXd-.contact_mesh">
<span class="sig-name descname"><span class="pre">contact_mesh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.DeformableContactInfo_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.geometry.PolygonSurfaceMesh_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.DeformableContactInfo_-AutoDiffXd-.contact_mesh" title="Link to this definition"></a></dt>
<dd><p>Returns a reference to the contact mesh expressed in the world frame.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.DeformableContactInfo_-AutoDiffXd-.F_Ac_W">
<span class="sig-name descname"><span class="pre">F_Ac_W</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.DeformableContactInfo_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.multibody.math.SpatialForce_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.DeformableContactInfo_-AutoDiffXd-.F_Ac_W" title="Link to this definition"></a></dt>
<dd><p>Gets the spatial force applied on the deformable body associated with
geometry A, at the centroid point C of the contact surface mesh, and
expressed in the world frame W.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.DeformableContactInfo_-AutoDiffXd-.id_A">
<span class="sig-name descname"><span class="pre">id_A</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.DeformableContactInfo_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.GeometryId" title="pydrake.geometry.GeometryId"><span class="pre">pydrake.geometry.GeometryId</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.DeformableContactInfo_-AutoDiffXd-.id_A" title="Link to this definition"></a></dt>
<dd><p>The geometry id of geometry A, guaranteed to belong to a deformable
body in contact.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.DeformableContactInfo_-AutoDiffXd-.id_B">
<span class="sig-name descname"><span class="pre">id_B</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.DeformableContactInfo_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.GeometryId" title="pydrake.geometry.GeometryId"><span class="pre">pydrake.geometry.GeometryId</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.DeformableContactInfo_-AutoDiffXd-.id_B" title="Link to this definition"></a></dt>
<dd><p>The geometry id of geometry B.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.multibody.plant.DeformableContactInfo_-Expression">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">DeformableContactInfo_[Expression]</span></span><a class="headerlink" href="#pydrake.multibody.plant.DeformableContactInfo_-Expression" title="Link to this definition"></a></dt>
<dd><p>A class containing information regarding contact and contact response
between two geometries belonging to a pair of bodies with at least one
of them being a deformable body. This class provides:</p>
<ul class="simple">
<li><p>The shared contact mesh between the two geometries.</p></li>
<li><p>The tractions acting at the contact points on the contact mesh.</p></li>
<li><p>The slip speeds at the contact points on the contact mesh.</p></li>
<li><p>The spatial force from the integrated tractions that is applied at the</p></li>
</ul>
<p>centroid of the contact surface.</p>
<p>The two geometries are denoted as A and B respectively with geometry A
guaranteed to be belonging to a deformable body.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This feature is considered to be <strong>experimental</strong> and may change
or be removed at any time, without any deprecation notice ahead of
time.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.DeformableContactInfo_-Expression-.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.DeformableContactInfo_-Expression-.__init__" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.multibody.plant.DeformableModel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">DeformableModel</span></span><a class="headerlink" href="#pydrake.multibody.plant.DeformableModel" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.plant.PhysicalModel" title="pydrake.multibody.plant.PhysicalModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.plant.PhysicalModel</span></code></a></p>
<p>DeformableModel implements the interface in PhysicalModel and provides
the functionalities to specify deformable bodies. Unlike rigid bodies,
the shape of deformable bodies can change in a simulation. Each
deformable body is modeled as a volumetric mesh with persisting
topology, changing vertex positions, and an approximated signed
distance field. A finite element model is built for each registered
deformable body that is used to evaluate the dynamics of the body.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This feature is considered to be <strong>experimental</strong> and may change
or be removed at any time, without any deprecation notice ahead of
time.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.DeformableModel.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.DeformableModel.__init__" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.DeformableModel.AddExternalForce">
<span class="sig-name descname"><span class="pre">AddExternalForce</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.DeformableModel" title="pydrake.multibody.plant.DeformableModel"><span class="pre">pydrake.multibody.plant.DeformableModel</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">external_force</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.fem.html#pydrake.multibody.fem.ForceDensityFieldBase" title="pydrake.multibody.fem.ForceDensityFieldBase"><span class="pre">pydrake.multibody.fem.ForceDensityFieldBase</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.DeformableModel.AddExternalForce" title="Link to this definition"></a></dt>
<dd><p>Registers an external force density field that applies external force
to all deformable bodies.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if this DeformableModel is not</strong><strong> of </strong><strong>scalar type</strong> – </p></li>
<li><p><strong>double.</strong> – </p></li>
<li><p><strong>RuntimeError if this DeformableModel belongs to a continuous</strong> – </p></li>
<li><p><strong>MultibodyPlant.</strong> – </p></li>
<li><p><strong>RuntimeError if Finalize</strong><strong>(</strong><strong>) </strong><strong>has been called on the multibody plant</strong> – </p></li>
<li><p><strong>owning this deformable model.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.DeformableModel.AddFixedConstraint">
<span class="sig-name descname"><span class="pre">AddFixedConstraint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.DeformableModel" title="pydrake.multibody.plant.DeformableModel"><span class="pre">pydrake.multibody.plant.DeformableModel</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">body_A_id</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.DeformableBodyId" title="pydrake.multibody.tree.DeformableBodyId"><span class="pre">pydrake.multibody.tree.DeformableBodyId</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">body_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody" title="pydrake.multibody.tree.RigidBody"><span class="pre">pydrake.multibody.tree.RigidBody</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">X_BA</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.math.html#pydrake.math.RigidTransform" title="pydrake.math.RigidTransform"><span class="pre">pydrake.math.RigidTransform</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">shape_G</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.Shape" title="pydrake.geometry.Shape"><span class="pre">pydrake.geometry.Shape</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">X_BG</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.math.html#pydrake.math.RigidTransform" title="pydrake.math.RigidTransform"><span class="pre">pydrake.math.RigidTransform</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.MultibodyConstraintId" title="pydrake.multibody.tree.MultibodyConstraintId"><span class="pre">pydrake.multibody.tree.MultibodyConstraintId</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.DeformableModel.AddFixedConstraint" title="Link to this definition"></a></dt>
<dd><p>Defines a fixed constraint between a deformable body A and a rigid
body B. Such a fixed constraint is modeled as distance holonomic
constraints:</p>
<p>p_PᵢQᵢ(q) = 0 for each constrained vertex Pᵢ</p>
<p>where Pᵢ is the i-th vertex of the deformable body under constraint
and Qᵢ is a point rigidly affixed to the rigid body B. To specify the
constraint, we put the reference mesh M of the deformable body A in
B’s body frame with the given pose <code class="docutils literal notranslate"><span class="pre">X_BA</span></code> and prescribe a shape G
with pose <code class="docutils literal notranslate"><span class="pre">X_BG</span></code> in B’s body frame. All vertices Pᵢ in M that are
inside (or on the surface of) G are subject to the fixed constraints
with Qᵢ being coincident with Pᵢ when M is in pose X_BA. p_PᵢQᵢ(q)
denotes the relative position of point Qᵢ with respect to point Pᵢ as
a function of the configuration of the model q. Imposing this
constraint forces Pᵢ and Qᵢ to be coincident for each vertex i of the
deformable body specified to be under constraint.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body_A_id</span></code>:</dt><dd><p>The unique id of the deformable body under the fixed constraint.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body_B</span></code>:</dt><dd><p>The rigid body under constraint.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">X_BA</span></code>:</dt><dd><p>The pose of deformable body A’s reference mesh in B’s body frame</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">shape_G</span></code>:</dt><dd><p>The prescribed geometry shape, attached to rigid body B, used to
determine which vertices of the deformable body A is under
constraint.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">X_BG</span></code>:</dt><dd><p>The fixed pose of the geometry frame of the given <code class="docutils literal notranslate"><span class="pre">shape</span></code> in
body B’s frame.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>the unique id of the newly added constraint.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>RuntimeError if no deformable body with the given body_A_id</strong> – </p></li>
<li><p><strong>has been registered.</strong> – </p></li>
<li><p><strong>RuntimeError unless body_B is registered with the same</strong> – </p></li>
<li><p><strong>multibody plant owning this deformable model.</strong> – </p></li>
<li><p><strong>RuntimeError if Finalize</strong><strong>(</strong><strong>) </strong><strong>has been called on the multibody plant</strong> – </p></li>
<li><p><strong>owning this deformable model.</strong> – </p></li>
<li><p><strong>RuntimeError if this DeformableModel is not</strong><strong> of </strong><strong>scalar type</strong> – </p></li>
<li><p><strong>double.</strong> – </p></li>
<li><p><strong>RuntimeError if no constraint is added</strong><strong> (</strong><strong>i.e. no vertex</strong><strong> of </strong><strong>the</strong> – </p></li>
<li><p><strong>deformable body is inside the given shape with the given</strong> – </p></li>
<li><p><strong>poses</strong><strong>)</strong><strong>.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.DeformableModel.Disable">
<span class="sig-name descname"><span class="pre">Disable</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.DeformableModel" title="pydrake.multibody.plant.DeformableModel"><span class="pre">pydrake.multibody.plant.DeformableModel</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">id</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.DeformableBodyId" title="pydrake.multibody.tree.DeformableBodyId"><span class="pre">pydrake.multibody.tree.DeformableBodyId</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context" title="pydrake.systems.framework.Context"><span class="pre">pydrake.systems.framework.Context</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.DeformableModel.Disable" title="Link to this definition"></a></dt>
<dd><p>Disables the deformable body with the given <code class="docutils literal notranslate"><span class="pre">id</span></code> in the given
context. Disabling a deformable body sets its vertex velocities and
accelerations to zero and freezes its vertex positions. A disabled
deformable body is not subject to any constraint (e.g. frictional
contact constraint or fixed constraint); it does not move under the
influence of external forces (e.g. gravity); and it does not
necessarily satisfy the prescribed boundary condition (if any). On the
flip side, a disabled deformable body does not affect the dynamics of
other bodies, even if the collision between the disabled body’s
geometry and other geometries is not filtered. Effectively, the
physics of the deformable body stop being computed. The deformable
body can be enabled by calling Enable(). Calling Disable() on a body
which is already disabled has no effect.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>Enable().</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the passed in context isn't compatible with the</strong> – </p></li>
<li><p><strong>MultibodyPlant associated with this DeformableModel.</strong> – </p></li>
<li><p><strong>RuntimeError if a deformable body with the given id is not</strong> – </p></li>
<li><p><strong>registered.</strong> – </p></li>
<li><p><strong>RuntimeError if context is null.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.DeformableModel.Enable">
<span class="sig-name descname"><span class="pre">Enable</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.DeformableModel" title="pydrake.multibody.plant.DeformableModel"><span class="pre">pydrake.multibody.plant.DeformableModel</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">id</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.DeformableBodyId" title="pydrake.multibody.tree.DeformableBodyId"><span class="pre">pydrake.multibody.tree.DeformableBodyId</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context" title="pydrake.systems.framework.Context"><span class="pre">pydrake.systems.framework.Context</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.DeformableModel.Enable" title="Link to this definition"></a></dt>
<dd><p>Enables the deformable body with the given <code class="docutils literal notranslate"><span class="pre">id</span></code> in the given
context. Calling Enable() on a body which is already enabled has no
effect.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>Disable().</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the passed in context isn't compatible with the</strong> – </p></li>
<li><p><strong>MultibodyPlant associated with this DeformableModel.</strong> – </p></li>
<li><p><strong>RuntimeError if a deformable body with the given id is not</strong> – </p></li>
<li><p><strong>registered.</strong> – </p></li>
<li><p><strong>RuntimeError if context is null.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.DeformableModel.GetBody">
<span class="sig-name descname"><span class="pre">GetBody</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.DeformableModel.GetBody" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetBody(self: pydrake.multibody.plant.DeformableModel, id: pydrake.multibody.tree.DeformableBodyId) -&gt; pydrake.multibody.tree.DeformableBody</p></li>
</ol>
<p>Returns the deformable body with the given <code class="docutils literal notranslate"><span class="pre">id</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if no deformable body with the given id has been</strong> – </p></li>
<li><p><strong>registered in this model.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>GetBody(self: pydrake.multibody.plant.DeformableModel, index: pydrake.multibody.tree.DeformableBodyIndex) -&gt; pydrake.multibody.tree.DeformableBody</p></li>
</ol>
<p>Returns the deformable body with the given <code class="docutils literal notranslate"><span class="pre">index</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if no deformable body with the given index is</strong> – </p></li>
<li><p><strong>registered in this model.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.DeformableModel.GetBodyByName">
<span class="sig-name descname"><span class="pre">GetBodyByName</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.DeformableModel.GetBodyByName" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetBodyByName(self: pydrake.multibody.plant.DeformableModel, name: str) -&gt; pydrake.multibody.tree.DeformableBody</p></li>
</ol>
<p>Returns the DeformableBody with the given name.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if there's no body with the given name</strong><strong> or </strong><strong>if more</strong> – </p></li>
<li><p><strong>than one model instance contains a deformable body with the given</strong> – </p></li>
<li><p><strong>name.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>GetBodyByName(self: pydrake.multibody.plant.DeformableModel, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; pydrake.multibody.tree.DeformableBody</p></li>
</ol>
<p>Returns the DeformableBody with the given name from the given model
instance.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if there's no body with the given name that is</strong> – </p></li>
<li><p><strong>registered with the given model instance.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.DeformableModel.GetBodyId">
<span class="sig-name descname"><span class="pre">GetBodyId</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.DeformableModel.GetBodyId" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetBodyId(self: pydrake.multibody.plant.DeformableModel, index: pydrake.multibody.tree.DeformableBodyIndex) -&gt; pydrake.multibody.tree.DeformableBodyId</p></li>
</ol>
<p>Returns the DeformableBodyId of the body with the given body index.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if no deformable body with the given index has been</strong> – </p></li>
<li><p><strong>registered in this model.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>GetBodyId(self: pydrake.multibody.plant.DeformableModel, geometry_id: pydrake.geometry.GeometryId) -&gt; pydrake.multibody.tree.DeformableBodyId</p></li>
</ol>
<p>Returns the DeformableBodyId associated with the given
<code class="docutils literal notranslate"><span class="pre">geometry_id</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the given geometry_id does not correspond to a</strong> – </p></li>
<li><p><strong>deformable body registered with this model.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.DeformableModel.GetBodyIds">
<span class="sig-name descname"><span class="pre">GetBodyIds</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.DeformableModel" title="pydrake.multibody.plant.DeformableModel"><span class="pre">pydrake.multibody.plant.DeformableModel</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.DeformableBodyId" title="pydrake.multibody.tree.DeformableBodyId"><span class="pre">pydrake.multibody.tree.DeformableBodyId</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.DeformableModel.GetBodyIds" title="Link to this definition"></a></dt>
<dd><p>Returns the DeformableIds of the bodies that belong to the given model
instance. Returns the empty vector if no deformable bodies are
registered with the given model instance.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.DeformableModel.GetBodyIndex">
<span class="sig-name descname"><span class="pre">GetBodyIndex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.DeformableModel" title="pydrake.multibody.plant.DeformableModel"><span class="pre">pydrake.multibody.plant.DeformableModel</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">id</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.DeformableBodyId" title="pydrake.multibody.tree.DeformableBodyId"><span class="pre">pydrake.multibody.tree.DeformableBodyId</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.DeformableBodyIndex" title="pydrake.multibody.tree.DeformableBodyIndex"><span class="pre">pydrake.multibody.tree.DeformableBodyIndex</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.DeformableModel.GetBodyIndex" title="Link to this definition"></a></dt>
<dd><p>Returns the DeformableBodyIndex of the body with the given id.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if no body with the given id has been registered.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.DeformableModel.GetDiscreteStateIndex">
<span class="sig-name descname"><span class="pre">GetDiscreteStateIndex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.DeformableModel" title="pydrake.multibody.plant.DeformableModel"><span class="pre">pydrake.multibody.plant.DeformableModel</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">id</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.DeformableBodyId" title="pydrake.multibody.tree.DeformableBodyId"><span class="pre">pydrake.multibody.tree.DeformableBodyId</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.DiscreteStateIndex" title="pydrake.systems.framework.DiscreteStateIndex"><span class="pre">pydrake.systems.framework.DiscreteStateIndex</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.DeformableModel.GetDiscreteStateIndex" title="Link to this definition"></a></dt>
<dd><p>Returns the discrete state index of the deformable body identified by
the given <code class="docutils literal notranslate"><span class="pre">id</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if MultibodyPlant::Finalize</strong><strong>(</strong><strong>) </strong><strong>has not been called</strong> – </p></li>
<li><p><strong>yet.</strong><strong> or </strong><strong>if no deformable body with the given id has been</strong> – </p></li>
<li><p><strong>registered in this model.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.DeformableModel.GetExternalForces">
<span class="sig-name descname"><span class="pre">GetExternalForces</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.DeformableModel" title="pydrake.multibody.plant.DeformableModel"><span class="pre">pydrake.multibody.plant.DeformableModel</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">id</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.DeformableBodyId" title="pydrake.multibody.tree.DeformableBodyId"><span class="pre">pydrake.multibody.tree.DeformableBodyId</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.multibody.fem.html#pydrake.multibody.fem.ForceDensityFieldBase" title="pydrake.multibody.fem.ForceDensityFieldBase"><span class="pre">pydrake.multibody.fem.ForceDensityFieldBase</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.DeformableModel.GetExternalForces" title="Link to this definition"></a></dt>
<dd><p>Returns the force density fields acting on the deformable body with
the given <code class="docutils literal notranslate"><span class="pre">id</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if MultibodyPlant::Finalize</strong><strong>(</strong><strong>) </strong><strong>has not been called</strong> – </p></li>
<li><p><strong>yet.</strong><strong> or </strong><strong>if no deformable body with the given id has been</strong> – </p></li>
<li><p><strong>registered in this model.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.DeformableModel.GetGeometryId">
<span class="sig-name descname"><span class="pre">GetGeometryId</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.DeformableModel" title="pydrake.multibody.plant.DeformableModel"><span class="pre">pydrake.multibody.plant.DeformableModel</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">id</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.DeformableBodyId" title="pydrake.multibody.tree.DeformableBodyId"><span class="pre">pydrake.multibody.tree.DeformableBodyId</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.GeometryId" title="pydrake.geometry.GeometryId"><span class="pre">pydrake.geometry.GeometryId</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.DeformableModel.GetGeometryId" title="Link to this definition"></a></dt>
<dd><p>Returns the GeometryId of the geometry associated with the body with
the given <code class="docutils literal notranslate"><span class="pre">id</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if no body with the given id has been registered.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.DeformableModel.GetMutableBody">
<span class="sig-name descname"><span class="pre">GetMutableBody</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.DeformableModel" title="pydrake.multibody.plant.DeformableModel"><span class="pre">pydrake.multibody.plant.DeformableModel</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">id</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.DeformableBodyId" title="pydrake.multibody.tree.DeformableBodyId"><span class="pre">pydrake.multibody.tree.DeformableBodyId</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.DeformableBody" title="pydrake.multibody.tree.DeformableBody"><span class="pre">pydrake.multibody.tree.DeformableBody</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.DeformableModel.GetMutableBody" title="Link to this definition"></a></dt>
<dd><p>Returns a mutable reference to the deformable body with the given
<code class="docutils literal notranslate"><span class="pre">id</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if no deformable body with the given id has been</strong> – </p></li>
<li><p><strong>registered in this model.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.DeformableModel.GetPositions">
<span class="sig-name descname"><span class="pre">GetPositions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.DeformableModel" title="pydrake.multibody.plant.DeformableModel"><span class="pre">pydrake.multibody.plant.DeformableModel</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context" title="pydrake.systems.framework.Context"><span class="pre">pydrake.systems.framework.Context</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">id</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.DeformableBodyId" title="pydrake.multibody.tree.DeformableBodyId"><span class="pre">pydrake.multibody.tree.DeformableBodyId</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.DeformableModel.GetPositions" title="Link to this definition"></a></dt>
<dd><p>Returns the matrix of vertex positions for the deformable body with
the given <code class="docutils literal notranslate"><span class="pre">id</span></code> in the provided <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context associated with the MultibodyPlant that owns this
DeformableModel.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">id</span></code>:</dt><dd><p>The identifier of the deformable body whose positions are being
queried.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">q</span></code>:</dt><dd><p>A 3×N matrix containing the positions of all vertices of the body.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if any</strong><strong> of </strong><strong>the following conditions are met</strong> – <ol class="arabic simple">
<li></li>
</ol>
</p></li>
<li><p><strong>context` does not belong to the MultibodyPlant associated wit</strong> – </p></li>
<li><p><strong>this DeformableModel. 2. No body with the given id is</strong> – </p></li>
<li><p><strong>registered. 3. Finalize</strong><strong>(</strong><strong>) </strong><strong>has not been called on the</strong> – </p></li>
<li><p><strong>MultibodyPlant that owns this deformable model.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.DeformableModel.GetPositionsAndVelocities">
<span class="sig-name descname"><span class="pre">GetPositionsAndVelocities</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.DeformableModel" title="pydrake.multibody.plant.DeformableModel"><span class="pre">pydrake.multibody.plant.DeformableModel</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context" title="pydrake.systems.framework.Context"><span class="pre">pydrake.systems.framework.Context</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">id</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.DeformableBodyId" title="pydrake.multibody.tree.DeformableBodyId"><span class="pre">pydrake.multibody.tree.DeformableBodyId</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.DeformableModel.GetPositionsAndVelocities" title="Link to this definition"></a></dt>
<dd><p>Returns the matrix of vertex positions and velocities for the
deformable body with the given <code class="docutils literal notranslate"><span class="pre">id</span></code> in the provided <code class="docutils literal notranslate"><span class="pre">context</span></code>. The
first N columns are the positions and the next N columns are the
velocities.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context associated with the MultibodyPlant that owns this
DeformableModel.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">id</span></code>:</dt><dd><p>The identifier of the deformable body whose state is being
queried.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A 3x2N matrix containing the positions and velocities of all
vertices of the body.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>RuntimeError if any</strong><strong> of </strong><strong>the following conditions are met</strong> – <ol class="arabic simple">
<li></li>
</ol>
</p></li>
<li><p><strong>context` does not belong to the MultibodyPlant associated wit</strong> – </p></li>
<li><p><strong>this DeformableModel. 2. No body with the given id is</strong> – </p></li>
<li><p><strong>registered. 3. Finalize</strong><strong>(</strong><strong>) </strong><strong>has not been called on the</strong> – </p></li>
<li><p><strong>MultibodyPlant that owns this deformable model.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.DeformableModel.GetReferencePositions">
<span class="sig-name descname"><span class="pre">GetReferencePositions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.DeformableModel" title="pydrake.multibody.plant.DeformableModel"><span class="pre">pydrake.multibody.plant.DeformableModel</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">id</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.DeformableBodyId" title="pydrake.multibody.tree.DeformableBodyId"><span class="pre">pydrake.multibody.tree.DeformableBodyId</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.DeformableModel.GetReferencePositions" title="Link to this definition"></a></dt>
<dd><p>Returns the reference positions of the vertices of the deformable body
identified by the given <code class="docutils literal notranslate"><span class="pre">id</span></code>. The reference positions are
represented as a VectorX with 3N values where N is the number of
vertices. The x-, y-, and z-positions (measured and expressed in the
world frame) of the j-th vertex are 3j, 3j + 1, and 3j + 2 in the
VectorX.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if no deformable body with the given id has been</strong> – </p></li>
<li><p><strong>registered in this model.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.DeformableModel.GetVelocities">
<span class="sig-name descname"><span class="pre">GetVelocities</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.DeformableModel" title="pydrake.multibody.plant.DeformableModel"><span class="pre">pydrake.multibody.plant.DeformableModel</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context" title="pydrake.systems.framework.Context"><span class="pre">pydrake.systems.framework.Context</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">id</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.DeformableBodyId" title="pydrake.multibody.tree.DeformableBodyId"><span class="pre">pydrake.multibody.tree.DeformableBodyId</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.DeformableModel.GetVelocities" title="Link to this definition"></a></dt>
<dd><p>Returns the matrix of vertex velocities for the deformable body with
the given <code class="docutils literal notranslate"><span class="pre">id</span></code> in the provided <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context associated with the MultibodyPlant that owns this
DeformableModel.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">id</span></code>:</dt><dd><p>The identifier of the deformable body whose velocities are being
queried.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">v</span></code>:</dt><dd><p>A 3×N matrix containing the velocities of all vertices of the
body.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if any</strong><strong> of </strong><strong>the following conditions are met</strong> – <ol class="arabic simple">
<li></li>
</ol>
</p></li>
<li><p><strong>context` does not belong to the MultibodyPlant associated wit</strong> – </p></li>
<li><p><strong>this DeformableModel. 2. No body with the given id is</strong> – </p></li>
<li><p><strong>registered. 3. Finalize</strong><strong>(</strong><strong>) </strong><strong>has not been called on the</strong> – </p></li>
<li><p><strong>MultibodyPlant that owns this deformable model.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.DeformableModel.HasBodyNamed">
<span class="sig-name descname"><span class="pre">HasBodyNamed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.DeformableModel.HasBodyNamed" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>HasBodyNamed(self: pydrake.multibody.plant.DeformableModel, name: str) -&gt; bool</p></li>
</ol>
<p>Returns true if and only if a deformable body with the given <code class="docutils literal notranslate"><span class="pre">name</span></code>
has been registered with this model.</p>
<ol class="arabic simple" start="2">
<li><p>HasBodyNamed(self: pydrake.multibody.plant.DeformableModel, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; bool</p></li>
</ol>
<p>Returns true if and only if a deformable body with the given <code class="docutils literal notranslate"><span class="pre">name</span></code>
has been registered with this model under the given
<code class="docutils literal notranslate"><span class="pre">model_instance</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.DeformableModel.HasConstraint">
<span class="sig-name descname"><span class="pre">HasConstraint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.DeformableModel" title="pydrake.multibody.plant.DeformableModel"><span class="pre">pydrake.multibody.plant.DeformableModel</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">id</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.DeformableBodyId" title="pydrake.multibody.tree.DeformableBodyId"><span class="pre">pydrake.multibody.tree.DeformableBodyId</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.DeformableModel.HasConstraint" title="Link to this definition"></a></dt>
<dd><p>Returns the true if the deformable body with the given <code class="docutils literal notranslate"><span class="pre">id</span></code> has
constraints associated with it.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.DeformableModel.is_empty">
<span class="sig-name descname"><span class="pre">is_empty</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.DeformableModel" title="pydrake.multibody.plant.DeformableModel"><span class="pre">pydrake.multibody.plant.DeformableModel</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.DeformableModel.is_empty" title="Link to this definition"></a></dt>
<dd><p>Returns true if there’s no deformable body or external force
registered to <code class="docutils literal notranslate"><span class="pre">this</span></code> DeformableModel.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.DeformableModel.is_enabled">
<span class="sig-name descname"><span class="pre">is_enabled</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.DeformableModel" title="pydrake.multibody.plant.DeformableModel"><span class="pre">pydrake.multibody.plant.DeformableModel</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">id</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.DeformableBodyId" title="pydrake.multibody.tree.DeformableBodyId"><span class="pre">pydrake.multibody.tree.DeformableBodyId</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context" title="pydrake.systems.framework.Context"><span class="pre">pydrake.systems.framework.Context</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.DeformableModel.is_enabled" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>true if and only if the deformable body with the given id is
enabled.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>RuntimeError if the passed in context isn't compatible with the</strong> – </p></li>
<li><p><strong>MultibodyPlant associated with this DeformableModel.</strong> – </p></li>
<li><p><strong>RuntimeError if a deformable body with the given id is not</strong> – </p></li>
<li><p><strong>registered.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.DeformableModel.num_bodies">
<span class="sig-name descname"><span class="pre">num_bodies</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.DeformableModel" title="pydrake.multibody.plant.DeformableModel"><span class="pre">pydrake.multibody.plant.DeformableModel</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.DeformableModel.num_bodies" title="Link to this definition"></a></dt>
<dd><p>Returns the number of deformable bodies registered with this
DeformableModel.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.DeformableModel.RegisterDeformableBody">
<span class="sig-name descname"><span class="pre">RegisterDeformableBody</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.DeformableModel.RegisterDeformableBody" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>RegisterDeformableBody(self: pydrake.multibody.plant.DeformableModel, geometry_instance: pydrake.geometry.GeometryInstance, config: pydrake.multibody.fem.DeformableBodyConfig, resolution_hint: float) -&gt; pydrake.multibody.tree.DeformableBodyId</p></li>
</ol>
<p>Registers a deformable body in <code class="docutils literal notranslate"><span class="pre">this</span></code> DeformableModel with the
default model instance.</p>
<ol class="arabic simple" start="2">
<li><p>RegisterDeformableBody(self: pydrake.multibody.plant.DeformableModel, geometry_instance: pydrake.geometry.GeometryInstance, model_instance: pydrake.multibody.tree.ModelInstanceIndex, config: pydrake.multibody.fem.DeformableBodyConfig, resolution_hint: float) -&gt; pydrake.multibody.tree.DeformableBodyId</p></li>
</ol>
<p>Registers a deformable body in <code class="docutils literal notranslate"><span class="pre">this</span></code> DeformableModel with the given
GeometryInstance. The body is represented in the world frame and
simulated with FEM with linear elements and a first order quadrature
rule that integrates linear functions exactly. See FemModel for
details. Returns a unique identifier for the added geometry.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">geometry_instance</span></code>:</dt><dd><p>The geometry to be registered with the model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">config</span></code>:</dt><dd><p>The physical properties of deformable body.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>:</dt><dd><p>The model instance index which this body is part of.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">resolution_hint</span></code>:</dt><dd><p>The parameter that guides the level of mesh refinement of the
deformable geometry. It has length units (in meters) and roughly
corresponds to a typical edge length in the resulting mesh for a
primitive shape.</p>
</dd>
<dt>Precondition:</dt><dd><p>resolution_hint &gt; 0.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if this DeformableModel is not</strong><strong> of </strong><strong>scalar type</strong> – </p></li>
<li><p><strong>double.</strong> – </p></li>
<li><p><strong>RuntimeError if this DeformableModel belongs to a continuous</strong> – </p></li>
<li><p><strong>MultibodyPlant.</strong> – </p></li>
<li><p><strong>RuntimeError if the model instance does not exist.</strong> – </p></li>
<li><p><strong>RuntimeError if a deformable body with the same name has already</strong> – </p></li>
<li><p><strong>been registered to the model instance.</strong> – </p></li>
<li><p><strong>RuntimeError if Finalize</strong><strong>(</strong><strong>) </strong><strong>has been called on the multibody plant</strong> – </p></li>
<li><p><strong>owning this deformable model.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.DeformableModel.SetPositions">
<span class="sig-name descname"><span class="pre">SetPositions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.DeformableModel" title="pydrake.multibody.plant.DeformableModel"><span class="pre">pydrake.multibody.plant.DeformableModel</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context" title="pydrake.systems.framework.Context"><span class="pre">pydrake.systems.framework.Context</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">id</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.DeformableBodyId" title="pydrake.multibody.tree.DeformableBodyId"><span class="pre">pydrake.multibody.tree.DeformableBodyId</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.f_contiguous</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.DeformableModel.SetPositions" title="Link to this definition"></a></dt>
<dd><p>Sets the vertex positions of the deformable body with the given <code class="docutils literal notranslate"><span class="pre">id</span></code>
in the provided <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">out</span></code>:</dt><dd><p>] context The context associated with the MultibodyPlant that owns
this DeformableModel.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">id</span></code>:</dt><dd><p>The identifier of the deformable body whose positions are being
set.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">q</span></code>:</dt><dd><p>A 3×N matrix of vertex positions.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if any</strong><strong> of </strong><strong>the following conditions are met</strong> – <ol class="arabic simple">
<li></li>
</ol>
</p></li>
<li><p><strong>context` is nullptr. 2. context does not belong to th</strong> – </p></li>
<li><p><strong>MultibodyPlant associated with this DeformableModel. 3. No body</strong> – </p></li>
<li><p><strong>with the given id is registered. 4. The number</strong><strong> of </strong><strong>columns of</strong> – </p></li>
<li><p><strong>q` does not match the number</strong><strong> of </strong><strong>vertices</strong><strong> of </strong><strong>the body. 5. ``q`</strong> – </p></li>
<li><p><strong>contains non-finite values. 6. Finalize</strong><strong>(</strong><strong>) </strong><strong>has not been called</strong> – </p></li>
<li><p><strong>on the MultibodyPlant that owns this deformable model.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.DeformableModel.SetPositionsAndVelocities">
<span class="sig-name descname"><span class="pre">SetPositionsAndVelocities</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.DeformableModel" title="pydrake.multibody.plant.DeformableModel"><span class="pre">pydrake.multibody.plant.DeformableModel</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context" title="pydrake.systems.framework.Context"><span class="pre">pydrake.systems.framework.Context</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">id</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.DeformableBodyId" title="pydrake.multibody.tree.DeformableBodyId"><span class="pre">pydrake.multibody.tree.DeformableBodyId</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.f_contiguous</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.f_contiguous</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.DeformableModel.SetPositionsAndVelocities" title="Link to this definition"></a></dt>
<dd><p>Sets the vertex positions and velocities of the deformable body with
the given <code class="docutils literal notranslate"><span class="pre">id</span></code> in the provided <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">out</span></code>:</dt><dd><p>] context The context associated with the MultibodyPlant that owns
this DeformableModel.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">id</span></code>:</dt><dd><p>The identifier of the deformable body whose positions and
velocities are being set.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">q</span></code>:</dt><dd><p>A 3×N matrix of vertex positions.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">v</span></code>:</dt><dd><p>A 3×N matrix of vertex velocities.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if any</strong><strong> of </strong><strong>the following conditions are met</strong> – <ol class="arabic simple">
<li></li>
</ol>
</p></li>
<li><p><strong>context` is nullptr. 2. context does not belong to th</strong> – </p></li>
<li><p><strong>MultibodyPlant associated with this DeformableModel. 3. No body</strong> – </p></li>
<li><p><strong>with the given id is registered. 4. The number</strong><strong> of </strong><strong>columns of</strong> – </p></li>
<li><p><strong>q`</strong><strong> or </strong><strong>v does not match the number</strong><strong> of </strong><strong>vertices</strong><strong> of </strong><strong>the body</strong> – </p></li>
<li><p><strong>5. q</strong><strong> or </strong><strong>v contains non-finite values. 6. Finalize</strong><strong>(</strong><strong>)</strong> – </p></li>
<li><p><strong>has not been called on the MultibodyPlant that owns this</strong> – </p></li>
<li><p><strong>deformable model.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.DeformableModel.SetVelocities">
<span class="sig-name descname"><span class="pre">SetVelocities</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.DeformableModel" title="pydrake.multibody.plant.DeformableModel"><span class="pre">pydrake.multibody.plant.DeformableModel</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context" title="pydrake.systems.framework.Context"><span class="pre">pydrake.systems.framework.Context</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">id</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.DeformableBodyId" title="pydrake.multibody.tree.DeformableBodyId"><span class="pre">pydrake.multibody.tree.DeformableBodyId</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.f_contiguous</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.DeformableModel.SetVelocities" title="Link to this definition"></a></dt>
<dd><p>Sets the vertex velocities of the deformable body with the given
<code class="docutils literal notranslate"><span class="pre">id</span></code> in the provided <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">out</span></code>:</dt><dd><p>] context The context associated with the MultibodyPlant that owns
this DeformableModel.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">id</span></code>:</dt><dd><p>The identifier of the deformable body whose velocities are being
set.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">v</span></code>:</dt><dd><p>A 3×N matrix of vertex velocities.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if any</strong><strong> of </strong><strong>the following conditions are met</strong> – <ol class="arabic simple">
<li></li>
</ol>
</p></li>
<li><p><strong>context` is nullptr. 2. context does not belong to th</strong> – </p></li>
<li><p><strong>MultibodyPlant associated with this DeformableModel. 3. No body</strong> – </p></li>
<li><p><strong>with the given id is registered. 4. The number</strong><strong> of </strong><strong>columns of</strong> – </p></li>
<li><p><strong>v` does not match the number</strong><strong> of </strong><strong>vertices</strong><strong> of </strong><strong>the body. 5. ``v`</strong> – </p></li>
<li><p><strong>contains non-finite values. 6. Finalize</strong><strong>(</strong><strong>) </strong><strong>has not been called</strong> – </p></li>
<li><p><strong>on the MultibodyPlant that owns this deformable model.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.DeformableModel.SetWallBoundaryCondition">
<span class="sig-name descname"><span class="pre">SetWallBoundaryCondition</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.DeformableModel" title="pydrake.multibody.plant.DeformableModel"><span class="pre">pydrake.multibody.plant.DeformableModel</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">id</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.DeformableBodyId" title="pydrake.multibody.tree.DeformableBodyId"><span class="pre">pydrake.multibody.tree.DeformableBodyId</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_WQ</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_W</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.DeformableModel.SetWallBoundaryCondition" title="Link to this definition"></a></dt>
<dd><p>Sets wall boundary conditions for the body with the given <code class="docutils literal notranslate"><span class="pre">id</span></code>. All
vertices of the mesh of the deformable body whose reference positions
are inside the prescribed open half space are put under zero
displacement boundary conditions. The open half space is defined by a
plane with outward normal n_W. A vertex V is considered to be subject
to the boundary condition if n̂ ⋅ p_QV &lt; 0 where Q is a point on the
plane and n̂ is normalized n_W.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">id</span></code>:</dt><dd><p>The body to be put under boundary condition.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_WQ</span></code>:</dt><dd><p>The position of a point Q on the plane in the world frame.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">n_W</span></code>:</dt><dd><p>Outward normal to the half space expressed in the world frame.</p>
</dd>
<dt>Precondition:</dt><dd><p>n_W.norm() &gt; 1e-10.</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Be aware of round-off errors in floating computations when placing
a vertex very close to the plane defining the half space.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if no deformable body with the given id has been</strong> – </p></li>
<li><p><strong>registered in this model.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.multibody.plant.DiscreteContactApproximation">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">DiscreteContactApproximation</span></span><a class="headerlink" href="#pydrake.multibody.plant.DiscreteContactApproximation" title="Link to this definition"></a></dt>
<dd><p>The type of the contact approximation used for a discrete
MultibodyPlant model.</p>
<p>kTamsi, kSimilar and kLagged are all approximations to the same
contact model – Compliant contact with regularized friction, refer to
mbp_contact_modeling “Contact Modeling” for further details. The key
difference however, is that the kSimilar and kLagged approximations
are convex and therefore our contact solver has both theoretical and
practical convergence guarantees — the solver will always succeed.
Conversely, being non-convex, kTamsi can fail to find a solution.</p>
<p>kSap is also a convex model of compliant contact with regularized
friction. There are a couple of key differences however: - Dissipation
is modeled using a linear Kelvin–Voigt model, parameterized by a
relaxation time constant. See accessing_contact_properties “contact
parameters”. - Unlike kTamsi, kSimilar and kLagged where
regularization of friction is parameterized by a stiction tolerance
(see set_stiction_tolerance()), SAP determines regularization
automatically solely based on numerics. Users have no control on the
amount of regularization.</p>
<p>How to choose an approximation</p>
<p>The Hunt &amp; Crossley model is based on physics, it is continuous and
has been experimentally validated. Therefore it is the preferred model
to capture the physics of contact.</p>
<p>Being approximations, kSap and kSimilar introduce a spurious effect of
“gliding” in sliding contact, see [Castro et al., 2023]. This artifact
is 𝒪(δt) but can be significant at large time steps and/or large slip
velocities. kLagged does not suffer from this, but introduces a “weak”
coupling of friction that can introduce non-negligible effects in the
dynamics during impacts or strong transients.</p>
<p>Summarizing, kLagged is the preferred approximation when strong
transients are not expected or don’t need to be accurately resolved.
If strong transients do need to be accurately resolved (unusual for
robotics applications), kSimilar is the preferred approximation.</p>
<p class="rubric">References</p>
<ul class="simple">
<li><p>[Castro et al., 2019] Castro A., Qu A., Kuppuswamy N., Alspach A.,
Sherman M, 2019. A Transition-Aware Method for the Simulation of
Compliant Contact with Regularized Friction. Available online at
<a class="reference external" href="https://arxiv.org/abs/1909.05700">https://arxiv.org/abs/1909.05700</a>.</p></li>
<li><p>[Castro et al., 2022] Castro A., Permenter F. and Han X., 2022. An
Unconstrained Convex Formulation of Compliant Contact. Available online at
<a class="reference external" href="https://arxiv.org/abs/2110.10107">https://arxiv.org/abs/2110.10107</a>.</p></li>
<li><p>[Castro et al., 2023] Castro A., Han X., and Masterjohn J., 2023. A Theory
of Irrotational Contact Fields. Available online at
<a class="reference external" href="https://arxiv.org/abs/2312.03908">https://arxiv.org/abs/2312.03908</a></p></li>
</ul>
<p>Members:</p>
<blockquote>
<div><p>kTamsi : TAMSI solver approximation, see [Castro et al., 2019].</p>
<p>kSap : SAP solver model approximation, see [Castro et al., 2022].</p>
<p>kSimilar : Similarity approximation found in [Castro et al., 2023].</p>
<p>kLagged : Approximation in which the normal force is lagged in Coulomb’s law,</p>
</div></blockquote>
<p>such that ‖γₜ‖ ≤ μ γₙ₀, [Castro et al., 2023].</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.DiscreteContactApproximation.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.DiscreteContactApproximation" title="pydrake.multibody.plant.DiscreteContactApproximation"><span class="pre">pydrake.multibody.plant.DiscreteContactApproximation</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.DiscreteContactApproximation.__init__" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pydrake.multibody.plant.DiscreteContactApproximation.kLagged">
<span class="sig-name descname"><span class="pre">kLagged</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;DiscreteContactApproximation.kLagged:</span> <span class="pre">3&gt;</span></em><a class="headerlink" href="#pydrake.multibody.plant.DiscreteContactApproximation.kLagged" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pydrake.multibody.plant.DiscreteContactApproximation.kSap">
<span class="sig-name descname"><span class="pre">kSap</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;DiscreteContactApproximation.kSap:</span> <span class="pre">1&gt;</span></em><a class="headerlink" href="#pydrake.multibody.plant.DiscreteContactApproximation.kSap" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pydrake.multibody.plant.DiscreteContactApproximation.kSimilar">
<span class="sig-name descname"><span class="pre">kSimilar</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;DiscreteContactApproximation.kSimilar:</span> <span class="pre">2&gt;</span></em><a class="headerlink" href="#pydrake.multibody.plant.DiscreteContactApproximation.kSimilar" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pydrake.multibody.plant.DiscreteContactApproximation.kTamsi">
<span class="sig-name descname"><span class="pre">kTamsi</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;DiscreteContactApproximation.kTamsi:</span> <span class="pre">0&gt;</span></em><a class="headerlink" href="#pydrake.multibody.plant.DiscreteContactApproximation.kTamsi" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.multibody.plant.DiscreteContactApproximation.name">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">name</span></span><a class="headerlink" href="#pydrake.multibody.plant.DiscreteContactApproximation.name" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.multibody.plant.DiscreteContactApproximation.value">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">value</span></span><a class="headerlink" href="#pydrake.multibody.plant.DiscreteContactApproximation.value" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.multibody.plant.DiscreteContactSolver">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">DiscreteContactSolver</span></span><a class="headerlink" href="#pydrake.multibody.plant.DiscreteContactSolver" title="Link to this definition"></a></dt>
<dd><p>The type of the contact solver used for a discrete MultibodyPlant
model.</p>
<p>Note: the SAP solver only fully supports scalar type <code class="docutils literal notranslate"><span class="pre">double</span></code>. For
scalar type <code class="docutils literal notranslate"><span class="pre">AutoDiffXd</span></code>, the SAP solver throws if any constraint
(including contact) is detected. As a consequence, one can only run
dynamic simulations without any constraints under the combination of
SAP and <code class="docutils literal notranslate"><span class="pre">AutoDiffXd</span></code>. The SAP solver does not support symbolic
calculations.</p>
<p class="rubric">References</p>
<ul class="simple">
<li><p>[Castro et al., 2019] Castro, A.M, Qu, A., Kuppuswamy, N., Alspach, A.,
Sherman, M.A., 2019. A Transition-Aware Method for the Simulation of
Compliant Contact with Regularized Friction. Available online at
<a class="reference external" href="https://arxiv.org/abs/1909.05700">https://arxiv.org/abs/1909.05700</a>.</p></li>
<li><p>[Castro et al., 2022] Castro A., Permenter F. and Han X., 2022. An
Unconstrained Convex Formulation of Compliant Contact. Available online at
<a class="reference external" href="https://arxiv.org/abs/2110.10107">https://arxiv.org/abs/2110.10107</a>.</p></li>
</ul>
<p>Members:</p>
<blockquote>
<div><p>kTamsi : TAMSI solver, see [Castro et al., 2019].</p>
<p>kSap : SAP solver, see [Castro et al., 2022].</p>
</div></blockquote>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.DiscreteContactSolver.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.DiscreteContactSolver" title="pydrake.multibody.plant.DiscreteContactSolver"><span class="pre">pydrake.multibody.plant.DiscreteContactSolver</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.DiscreteContactSolver.__init__" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pydrake.multibody.plant.DiscreteContactSolver.kSap">
<span class="sig-name descname"><span class="pre">kSap</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;DiscreteContactSolver.kSap:</span> <span class="pre">1&gt;</span></em><a class="headerlink" href="#pydrake.multibody.plant.DiscreteContactSolver.kSap" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pydrake.multibody.plant.DiscreteContactSolver.kTamsi">
<span class="sig-name descname"><span class="pre">kTamsi</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;DiscreteContactSolver.kTamsi:</span> <span class="pre">0&gt;</span></em><a class="headerlink" href="#pydrake.multibody.plant.DiscreteContactSolver.kTamsi" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.multibody.plant.DiscreteContactSolver.name">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">name</span></span><a class="headerlink" href="#pydrake.multibody.plant.DiscreteContactSolver.name" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.multibody.plant.DiscreteContactSolver.value">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">value</span></span><a class="headerlink" href="#pydrake.multibody.plant.DiscreteContactSolver.value" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.multibody.plant.DistanceConstraintParams">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">DistanceConstraintParams</span></span><a class="headerlink" href="#pydrake.multibody.plant.DistanceConstraintParams" title="Link to this definition"></a></dt>
<dd><p>Parameters for a distance constraint. A distance constraint is modeled
as a holonomic constraint. Distance constraints can be “soft”, and are
implemented as a spring force, f: f = -k⋅(d(q) - d₀) - c⋅ḋ(q), where
d₀ is a fixed length, k a stiffness parameter in N/m and c a damping
parameter in N⋅s/m. We use d(q) to denote the Euclidean distance
between two points P and Q, rigidly affixed to bodies A and B
respectively, as a function of the configuration of the model q. This
constraint reduces to d(q) = d₀ in the limit to infinite stiffness and
it behaves as a linear spring damper for finite values of stiffness
and damping.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>A distance constraint is the wrong modeling choice if the distance
needs to go through zero. To constrain two points to be coincident
we need a 3-dof ball constraint, the 1-dof distance constraint is
singular in this case. Therefore we require the distance parameter
to be strictly positive.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.DistanceConstraintParams.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.DistanceConstraintParams.__init__" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.multibody.plant.DistanceConstraintParams) -&gt; None</p></li>
</ol>
<p>Construction to an invalid set of parameters only meant to facilitate
use with STL containers.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.multibody.plant.DistanceConstraintParams, bodyA: pydrake.multibody.tree.BodyIndex, p_AP: numpy.ndarray[numpy.float64[3, 1]], bodyB: pydrake.multibody.tree.BodyIndex, p_BQ: numpy.ndarray[numpy.float64[3, 1]], distance: float, stiffness: float, damping: float) -&gt; None</p></li>
</ol>
<p>Constructor for a set of valid parameters.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">bodyA</span></code>:</dt><dd><p>Index of body A in the MultibodyPlant.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">bodyB</span></code>:</dt><dd><p>Index of body B in the MultibodyPlant.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_AP</span></code>:</dt><dd><p>Position of a point P in A’s body frame.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BQ</span></code>:</dt><dd><p>Position of a point Q in Q’s body frame.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">distance</span></code>:</dt><dd><p>The fixed length of this constraint.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">stiffness</span></code>:</dt><dd><p>If finite, this constraint models a massless elastic rod of length
<code class="docutils literal notranslate"><span class="pre">distance</span></code> with the given <code class="docutils literal notranslate"><span class="pre">stiffness</span></code> and <code class="docutils literal notranslate"><span class="pre">damping</span></code>.
“Infinite” is a valid value if a hard constraint is intended. See
the class documentation for details.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">damping</span></code>:</dt><dd><p>When <code class="docutils literal notranslate"><span class="pre">stiffness</span></code> is finite, this value parametrizes the damping
model of the elastic massless rod. See the class documentation for
details.</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This class does not have a way to check whether body indices do
correspond to valid indices in a MultibodyPlant. Use
MultibodyPlant APIs to safely register distance constraints
between valid bodies and to later retrieve their valid set of
parameters.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if BodyIndex::is_valid</strong><strong>(</strong><strong>) </strong><strong>is false for either body.</strong> – </p></li>
<li><p><strong>RuntimeError if bodies A and B are the same body.</strong> – </p></li>
<li><p><strong>RuntimeError if distance is not strictly positive.</strong> – </p></li>
<li><p><strong>RuntimeError if stiffness is not strictly positive.</strong> – </p></li>
<li><p><strong>RuntimeError if damping is not positive</strong><strong> or </strong><strong>zero.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.DistanceConstraintParams.bodyA">
<span class="sig-name descname"><span class="pre">bodyA</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.DistanceConstraintParams" title="pydrake.multibody.plant.DistanceConstraintParams"><span class="pre">pydrake.multibody.plant.DistanceConstraintParams</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.BodyIndex" title="pydrake.multibody.tree.BodyIndex"><span class="pre">pydrake.multibody.tree.BodyIndex</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.DistanceConstraintParams.bodyA" title="Link to this definition"></a></dt>
<dd><p>Index of body A.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.DistanceConstraintParams.bodyB">
<span class="sig-name descname"><span class="pre">bodyB</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.DistanceConstraintParams" title="pydrake.multibody.plant.DistanceConstraintParams"><span class="pre">pydrake.multibody.plant.DistanceConstraintParams</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.BodyIndex" title="pydrake.multibody.tree.BodyIndex"><span class="pre">pydrake.multibody.tree.BodyIndex</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.DistanceConstraintParams.bodyB" title="Link to this definition"></a></dt>
<dd><p>Index of body B.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.DistanceConstraintParams.damping">
<span class="sig-name descname"><span class="pre">damping</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.DistanceConstraintParams" title="pydrake.multibody.plant.DistanceConstraintParams"><span class="pre">pydrake.multibody.plant.DistanceConstraintParams</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.DistanceConstraintParams.damping" title="Link to this definition"></a></dt>
<dd><p>Constraint damping. See class documentation.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.DistanceConstraintParams.distance">
<span class="sig-name descname"><span class="pre">distance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.DistanceConstraintParams" title="pydrake.multibody.plant.DistanceConstraintParams"><span class="pre">pydrake.multibody.plant.DistanceConstraintParams</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.DistanceConstraintParams.distance" title="Link to this definition"></a></dt>
<dd><p>The fixed length of the constraint.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.DistanceConstraintParams.p_AP">
<span class="sig-name descname"><span class="pre">p_AP</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.DistanceConstraintParams" title="pydrake.multibody.plant.DistanceConstraintParams"><span class="pre">pydrake.multibody.plant.DistanceConstraintParams</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.DistanceConstraintParams.p_AP" title="Link to this definition"></a></dt>
<dd><p>Position of point P in body A’s frame.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.DistanceConstraintParams.p_BQ">
<span class="sig-name descname"><span class="pre">p_BQ</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.DistanceConstraintParams" title="pydrake.multibody.plant.DistanceConstraintParams"><span class="pre">pydrake.multibody.plant.DistanceConstraintParams</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.DistanceConstraintParams.p_BQ" title="Link to this definition"></a></dt>
<dd><p>Position of point Q in body B’s frame.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.DistanceConstraintParams.stiffness">
<span class="sig-name descname"><span class="pre">stiffness</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.DistanceConstraintParams" title="pydrake.multibody.plant.DistanceConstraintParams"><span class="pre">pydrake.multibody.plant.DistanceConstraintParams</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.DistanceConstraintParams.stiffness" title="Link to this definition"></a></dt>
<dd><p>Constraint stiffness. See class documentation.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ExternallyAppliedSpatialForce">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">ExternallyAppliedSpatialForce</span></span><a class="headerlink" href="#pydrake.multibody.plant.ExternallyAppliedSpatialForce" title="Link to this definition"></a></dt>
<dd><div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <a class="reference internal" href="#pydrake.multibody.plant.ExternallyAppliedSpatialForce_" title="pydrake.multibody.plant.ExternallyAppliedSpatialForce_"><code class="xref py py-class docutils literal notranslate"><span class="pre">ExternallyAppliedSpatialForce_</span></code></a>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ExternallyAppliedSpatialForce.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.ExternallyAppliedSpatialForce" title="pydrake.multibody.plant.ExternallyAppliedSpatialForce"><span class="pre">pydrake.multibody.plant.ExternallyAppliedSpatialForce</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.ExternallyAppliedSpatialForce.__init__" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ExternallyAppliedSpatialForce.body_index">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">body_index</span></span><a class="headerlink" href="#pydrake.multibody.plant.ExternallyAppliedSpatialForce.body_index" title="Link to this definition"></a></dt>
<dd><p>The index of the body that the force is to be applied to.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ExternallyAppliedSpatialForce.F_Bq_W">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">F_Bq_W</span></span><a class="headerlink" href="#pydrake.multibody.plant.ExternallyAppliedSpatialForce.F_Bq_W" title="Link to this definition"></a></dt>
<dd><p>A spatial force applied to Body B at point Bq, expressed in the world
frame.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ExternallyAppliedSpatialForce.p_BoBq_B">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">p_BoBq_B</span></span><a class="headerlink" href="#pydrake.multibody.plant.ExternallyAppliedSpatialForce.p_BoBq_B" title="Link to this definition"></a></dt>
<dd><p>A position vector from Body B’s origin (Bo) to a point Bq (a point of
B), expressed in B’s frame.</p>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ExternallyAppliedSpatialForce_">
<em class="property"><span class="pre">template</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">ExternallyAppliedSpatialForce_</span></span><a class="headerlink" href="#pydrake.multibody.plant.ExternallyAppliedSpatialForce_" title="Link to this definition"></a></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">ExternallyAppliedSpatialForce_[float]</span></code>, <a class="reference internal" href="#pydrake.multibody.plant.ExternallyAppliedSpatialForce_-AutoDiffXd" title="pydrake.multibody.plant.ExternallyAppliedSpatialForce_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">ExternallyAppliedSpatialForce_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.plant.ExternallyAppliedSpatialForce_-Expression" title="pydrake.multibody.plant.ExternallyAppliedSpatialForce_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">ExternallyAppliedSpatialForce_[Expression]</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ExternallyAppliedSpatialForce_-AutoDiffXd">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">ExternallyAppliedSpatialForce_[AutoDiffXd]</span></span><a class="headerlink" href="#pydrake.multibody.plant.ExternallyAppliedSpatialForce_-AutoDiffXd" title="Link to this definition"></a></dt>
<dd><dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ExternallyAppliedSpatialForce_-AutoDiffXd-.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.ExternallyAppliedSpatialForce_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.ExternallyAppliedSpatialForce_-AutoDiffXd-.__init__" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ExternallyAppliedSpatialForce_-AutoDiffXd-.body_index">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">body_index</span></span><a class="headerlink" href="#pydrake.multibody.plant.ExternallyAppliedSpatialForce_-AutoDiffXd-.body_index" title="Link to this definition"></a></dt>
<dd><p>The index of the body that the force is to be applied to.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ExternallyAppliedSpatialForce_-AutoDiffXd-.F_Bq_W">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">F_Bq_W</span></span><a class="headerlink" href="#pydrake.multibody.plant.ExternallyAppliedSpatialForce_-AutoDiffXd-.F_Bq_W" title="Link to this definition"></a></dt>
<dd><p>A spatial force applied to Body B at point Bq, expressed in the world
frame.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ExternallyAppliedSpatialForce_-AutoDiffXd-.p_BoBq_B">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">p_BoBq_B</span></span><a class="headerlink" href="#pydrake.multibody.plant.ExternallyAppliedSpatialForce_-AutoDiffXd-.p_BoBq_B" title="Link to this definition"></a></dt>
<dd><p>A position vector from Body B’s origin (Bo) to a point Bq (a point of
B), expressed in B’s frame.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ExternallyAppliedSpatialForce_-Expression">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">ExternallyAppliedSpatialForce_[Expression]</span></span><a class="headerlink" href="#pydrake.multibody.plant.ExternallyAppliedSpatialForce_-Expression" title="Link to this definition"></a></dt>
<dd><dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ExternallyAppliedSpatialForce_-Expression-.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.ExternallyAppliedSpatialForce_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.ExternallyAppliedSpatialForce_-Expression-.__init__" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ExternallyAppliedSpatialForce_-Expression-.body_index">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">body_index</span></span><a class="headerlink" href="#pydrake.multibody.plant.ExternallyAppliedSpatialForce_-Expression-.body_index" title="Link to this definition"></a></dt>
<dd><p>The index of the body that the force is to be applied to.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ExternallyAppliedSpatialForce_-Expression-.F_Bq_W">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">F_Bq_W</span></span><a class="headerlink" href="#pydrake.multibody.plant.ExternallyAppliedSpatialForce_-Expression-.F_Bq_W" title="Link to this definition"></a></dt>
<dd><p>A spatial force applied to Body B at point Bq, expressed in the world
frame.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ExternallyAppliedSpatialForce_-Expression-.p_BoBq_B">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">p_BoBq_B</span></span><a class="headerlink" href="#pydrake.multibody.plant.ExternallyAppliedSpatialForce_-Expression-.p_BoBq_B" title="Link to this definition"></a></dt>
<dd><p>A position vector from Body B’s origin (Bo) to a point Bq (a point of
B), expressed in B’s frame.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ExternallyAppliedSpatialForceMultiplexer">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">ExternallyAppliedSpatialForceMultiplexer</span></span><a class="headerlink" href="#pydrake.multibody.plant.ExternallyAppliedSpatialForceMultiplexer" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.LeafSystem" title="pydrake.systems.framework.LeafSystem"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem</span></code></a></p>
<p>Concatenates multiple std::vector&lt;&gt;’s of
ExternallyAppliedSpatialForce&lt;T&gt;.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">u0&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">...&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">u(N-1)&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>ExternallyAppliedSpatialForceMultiplexer</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y0</td></tr></table></td></tr></table><div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <a class="reference internal" href="#pydrake.multibody.plant.ExternallyAppliedSpatialForceMultiplexer_" title="pydrake.multibody.plant.ExternallyAppliedSpatialForceMultiplexer_"><code class="xref py py-class docutils literal notranslate"><span class="pre">ExternallyAppliedSpatialForceMultiplexer_</span></code></a>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ExternallyAppliedSpatialForceMultiplexer.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.ExternallyAppliedSpatialForceMultiplexer" title="pydrake.multibody.plant.ExternallyAppliedSpatialForceMultiplexer"><span class="pre">pydrake.multibody.plant.ExternallyAppliedSpatialForceMultiplexer</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_inputs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.ExternallyAppliedSpatialForceMultiplexer.__init__" title="Link to this definition"></a></dt>
<dd><p>Constructor.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">num_inputs</span></code>:</dt><dd><p>Number of input ports to be added.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ExternallyAppliedSpatialForceMultiplexer_">
<em class="property"><span class="pre">template</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">ExternallyAppliedSpatialForceMultiplexer_</span></span><a class="headerlink" href="#pydrake.multibody.plant.ExternallyAppliedSpatialForceMultiplexer_" title="Link to this definition"></a></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">ExternallyAppliedSpatialForceMultiplexer_[float]</span></code>, <a class="reference internal" href="#pydrake.multibody.plant.ExternallyAppliedSpatialForceMultiplexer_-AutoDiffXd" title="pydrake.multibody.plant.ExternallyAppliedSpatialForceMultiplexer_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">ExternallyAppliedSpatialForceMultiplexer_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.plant.ExternallyAppliedSpatialForceMultiplexer_-Expression" title="pydrake.multibody.plant.ExternallyAppliedSpatialForceMultiplexer_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">ExternallyAppliedSpatialForceMultiplexer_[Expression]</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ExternallyAppliedSpatialForceMultiplexer_-AutoDiffXd">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">ExternallyAppliedSpatialForceMultiplexer_[AutoDiffXd]</span></span><a class="headerlink" href="#pydrake.multibody.plant.ExternallyAppliedSpatialForceMultiplexer_-AutoDiffXd" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.LeafSystem_-AutoDiffXd" title="pydrake.systems.framework.LeafSystem_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem_[AutoDiffXd]</span></code></a></p>
<p>Concatenates multiple std::vector&lt;&gt;’s of
ExternallyAppliedSpatialForce&lt;T&gt;.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">u0&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">...&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">u(N-1)&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>ExternallyAppliedSpatialForceMultiplexer</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y0</td></tr></table></td></tr></table><dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ExternallyAppliedSpatialForceMultiplexer_-AutoDiffXd-.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.ExternallyAppliedSpatialForceMultiplexer_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_inputs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.ExternallyAppliedSpatialForceMultiplexer_-AutoDiffXd-.__init__" title="Link to this definition"></a></dt>
<dd><p>Constructor.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">num_inputs</span></code>:</dt><dd><p>Number of input ports to be added.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ExternallyAppliedSpatialForceMultiplexer_-Expression">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">ExternallyAppliedSpatialForceMultiplexer_[Expression]</span></span><a class="headerlink" href="#pydrake.multibody.plant.ExternallyAppliedSpatialForceMultiplexer_-Expression" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.LeafSystem_-Expression" title="pydrake.systems.framework.LeafSystem_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem_[Expression]</span></code></a></p>
<p>Concatenates multiple std::vector&lt;&gt;’s of
ExternallyAppliedSpatialForce&lt;T&gt;.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">u0&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">...&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">u(N-1)&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>ExternallyAppliedSpatialForceMultiplexer</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y0</td></tr></table></td></tr></table><dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ExternallyAppliedSpatialForceMultiplexer_-Expression-.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.ExternallyAppliedSpatialForceMultiplexer_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_inputs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.ExternallyAppliedSpatialForceMultiplexer_-Expression-.__init__" title="Link to this definition"></a></dt>
<dd><p>Constructor.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">num_inputs</span></code>:</dt><dd><p>Number of input ports to be added.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.multibody.plant.HydroelasticContactInfo">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">HydroelasticContactInfo</span></span><a class="headerlink" href="#pydrake.multibody.plant.HydroelasticContactInfo" title="Link to this definition"></a></dt>
<dd><p>A class containing information regarding contact and contact response
between two geometries attached to a pair of bodies. This class
provides the output from the Hydroelastic contact model and includes:</p>
<ul class="simple">
<li><p>The shared contact surface between the two geometries, which includes</p></li>
</ul>
<p>the virtual pressures acting at every point on the contact surface.
- The spatial force from the integrated tractions that is applied at the
centroid of the contact surface.</p>
<p>The two geometries, denoted M and N (and obtainable via
<code class="docutils literal notranslate"><span class="pre">contact_surface().id_M()</span></code> and <code class="docutils literal notranslate"><span class="pre">contact_surface().id_N()</span></code>) are
attached to bodies A and B, respectively.</p>
<p>When T = Expression, the class is specialized to not contain any
member data, because ContactSurface doesn’t support Expression.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <a class="reference internal" href="#pydrake.multibody.plant.HydroelasticContactInfo_" title="pydrake.multibody.plant.HydroelasticContactInfo_"><code class="xref py py-class docutils literal notranslate"><span class="pre">HydroelasticContactInfo_</span></code></a>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.HydroelasticContactInfo.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.HydroelasticContactInfo.__init__" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.HydroelasticContactInfo.contact_surface">
<span class="sig-name descname"><span class="pre">contact_surface</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.HydroelasticContactInfo" title="pydrake.multibody.plant.HydroelasticContactInfo"><span class="pre">pydrake.multibody.plant.HydroelasticContactInfo</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.ContactSurface" title="pydrake.geometry.ContactSurface"><span class="pre">pydrake.geometry.ContactSurface</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.HydroelasticContactInfo.contact_surface" title="Link to this definition"></a></dt>
<dd><p>Returns a reference to the ContactSurface data structure. Note that
the mesh and gradient vector fields are expressed in the world frame.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.HydroelasticContactInfo.F_Ac_W">
<span class="sig-name descname"><span class="pre">F_Ac_W</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.HydroelasticContactInfo" title="pydrake.multibody.plant.HydroelasticContactInfo"><span class="pre">pydrake.multibody.plant.HydroelasticContactInfo</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.math.html#pydrake.multibody.math.SpatialForce" title="pydrake.multibody.math.SpatialForce"><span class="pre">pydrake.multibody.math.SpatialForce</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.HydroelasticContactInfo.F_Ac_W" title="Link to this definition"></a></dt>
<dd><p>Gets the spatial force applied on body A, at the centroid point C of
the surface mesh M, and expressed in the world frame W. The position
<code class="docutils literal notranslate"><span class="pre">p_WC</span></code> of the centroid point C in the world frame W can be obtained
with <code class="docutils literal notranslate"><span class="pre">contact_surface().centroid()</span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py" id="pydrake.multibody.plant.HydroelasticContactInfo_">
<em class="property"><span class="pre">template</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">HydroelasticContactInfo_</span></span><a class="headerlink" href="#pydrake.multibody.plant.HydroelasticContactInfo_" title="Link to this definition"></a></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">HydroelasticContactInfo_[float]</span></code>, <a class="reference internal" href="#pydrake.multibody.plant.HydroelasticContactInfo_-AutoDiffXd" title="pydrake.multibody.plant.HydroelasticContactInfo_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">HydroelasticContactInfo_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.plant.HydroelasticContactInfo_-Expression" title="pydrake.multibody.plant.HydroelasticContactInfo_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">HydroelasticContactInfo_[Expression]</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.multibody.plant.HydroelasticContactInfo_-AutoDiffXd">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">HydroelasticContactInfo_[AutoDiffXd]</span></span><a class="headerlink" href="#pydrake.multibody.plant.HydroelasticContactInfo_-AutoDiffXd" title="Link to this definition"></a></dt>
<dd><p>A class containing information regarding contact and contact response
between two geometries attached to a pair of bodies. This class
provides the output from the Hydroelastic contact model and includes:</p>
<ul class="simple">
<li><p>The shared contact surface between the two geometries, which includes</p></li>
</ul>
<p>the virtual pressures acting at every point on the contact surface.
- The spatial force from the integrated tractions that is applied at the
centroid of the contact surface.</p>
<p>The two geometries, denoted M and N (and obtainable via
<code class="docutils literal notranslate"><span class="pre">contact_surface().id_M()</span></code> and <code class="docutils literal notranslate"><span class="pre">contact_surface().id_N()</span></code>) are
attached to bodies A and B, respectively.</p>
<p>When T = Expression, the class is specialized to not contain any
member data, because ContactSurface doesn’t support Expression.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.HydroelasticContactInfo_-AutoDiffXd-.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.HydroelasticContactInfo_-AutoDiffXd-.__init__" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.HydroelasticContactInfo_-AutoDiffXd-.contact_surface">
<span class="sig-name descname"><span class="pre">contact_surface</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.HydroelasticContactInfo_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.geometry.ContactSurface_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.HydroelasticContactInfo_-AutoDiffXd-.contact_surface" title="Link to this definition"></a></dt>
<dd><p>Returns a reference to the ContactSurface data structure. Note that
the mesh and gradient vector fields are expressed in the world frame.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.HydroelasticContactInfo_-AutoDiffXd-.F_Ac_W">
<span class="sig-name descname"><span class="pre">F_Ac_W</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.HydroelasticContactInfo_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.multibody.math.SpatialForce_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.HydroelasticContactInfo_-AutoDiffXd-.F_Ac_W" title="Link to this definition"></a></dt>
<dd><p>Gets the spatial force applied on body A, at the centroid point C of
the surface mesh M, and expressed in the world frame W. The position
<code class="docutils literal notranslate"><span class="pre">p_WC</span></code> of the centroid point C in the world frame W can be obtained
with <code class="docutils literal notranslate"><span class="pre">contact_surface().centroid()</span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.multibody.plant.HydroelasticContactInfo_-Expression">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">HydroelasticContactInfo_[Expression]</span></span><a class="headerlink" href="#pydrake.multibody.plant.HydroelasticContactInfo_-Expression" title="Link to this definition"></a></dt>
<dd><p>A class containing information regarding contact and contact response
between two geometries attached to a pair of bodies. This class
provides the output from the Hydroelastic contact model and includes:</p>
<ul class="simple">
<li><p>The shared contact surface between the two geometries, which includes</p></li>
</ul>
<p>the virtual pressures acting at every point on the contact surface.
- The spatial force from the integrated tractions that is applied at the
centroid of the contact surface.</p>
<p>The two geometries, denoted M and N (and obtainable via
<code class="docutils literal notranslate"><span class="pre">contact_surface().id_M()</span></code> and <code class="docutils literal notranslate"><span class="pre">contact_surface().id_N()</span></code>) are
attached to bodies A and B, respectively.</p>
<p>When T = Expression, the class is specialized to not contain any
member data, because ContactSurface doesn’t support Expression.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.HydroelasticContactInfo_-Expression-.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.HydroelasticContactInfo_-Expression-.__init__" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">MultibodyPlant</span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.LeafSystem" title="pydrake.systems.framework.LeafSystem"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem</span></code></a></p>
<p>MultibodyPlant is a Drake system framework representation (see
systems::System) for the model of a physical system consisting of a
collection of interconnected bodies. See multibody for an overview of
concepts/notation.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">actuation&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">applied_generalized_force&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">applied_spatial_force&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px"><em style="color:gray">model_instance_name[i]</em>_actuation&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px"><em style="color:gray">model_instance_name[i]</em>_desired_state&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px"><span style="color:green">geometry_query</span>&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>MultibodyPlant</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; state</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; body_poses</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; body_spatial_velocities</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; body_spatial_accelerations</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; generalized_acceleration</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; net_actuation</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; reaction_forces</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; contact_results</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; <em style="color:gray">model_instance_name[i]</em>_state</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; <em style="color:gray">model_instance_name[i]</em>_generalized_acceleration</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; <em style="color:gray">model_instance_name[i]</em>_generalized_contact_forces</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; <em style="color:gray">model_instance_name[i]</em>_net_actuation</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; <span style="color:green">geometry_pose</span></td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; <span style="color:green">deformable_body_configuration</span></td></tr></table></td></tr></table><p>The ports whose names begin with &lt;em style=”color:gray”&gt;
model_instance_name[i]&lt;/em&gt; represent groups of ports, one for each of
the model_instances “model instances”, with i ∈ {0, …, N-1} for the
N model instances. If a model instance does not contain any data of
the indicated type the port will still be present but its value will
be a zero-length vector. (Model instances <code class="docutils literal notranslate"><span class="pre">world_model_instance()</span></code>
and <code class="docutils literal notranslate"><span class="pre">default_model_instance()</span></code> always exist.)</p>
<p>The ports shown in &lt;span style=”color:green”&gt;green&lt;/span&gt; are for
communication with Drake’s geometry::SceneGraph “SceneGraph” system
for dealing with geometry.</p>
<p>MultibodyPlant provides a user-facing API for:</p>
<ul class="simple">
<li><p>mbp_input_and_output_ports “Ports”:</p></li>
</ul>
<p>Access input and output ports.
- mbp_construction “Construction”:
Add bodies, joints, frames, force elements, and actuators.
- mbp_geometry “Geometry”:
Register geometries to a provided SceneGraph instance.
- mbp_contact_modeling “Contact modeling”:
Select and parameterize contact models.
- mbp_state_accessors_and_mutators “State access and modification”:
Obtain and manipulate position and velocity state variables.
- mbp_parameters “Parameters”
Working with system parameters for various multibody elements.
- mbp_working_with_free_bodies “Free and floating base bodies”:
Work conveniently with free (floating) bodies.
- mbp_kinematic_and_dynamic_computations “Kinematics and dynamics”:
Perform systems::Context “Context”-dependent kinematic and dynamic
queries.
- mbp_system_matrix_computations “System matrices”:
Explicitly form matrices that appear in the equations of motion.
- mbp_introspection “Introspection”:
Perform introspection to find out what’s in the MultibodyPlant.</p>
<p><a href="#id5"><span class="problematic" id="id6">**</span></a>** Model Instances</p>
<p>A MultiBodyPlant may contain multiple model instances. Each model
instance corresponds to a set of bodies and their connections
(joints). Model instances provide methods to get or set the state of
the set of bodies (e.g., through GetPositionsAndVelocities() and
SetPositionsAndVelocities()), connecting controllers (through
get_state_output_port() and get_actuation_input_port()), and
organizing duplicate models (read through a parser). In fact, many
MultibodyPlant methods are overloaded to allow operating on the entire
plant or just the subset corresponding to the model instance; for
example, one GetPositions() method obtains the generalized positions
for the entire plant while another GetPositions() method obtains the
generalized positions for model instance.</p>
<p>Model instances are frequently defined through SDFormat files (using
the <code class="docutils literal notranslate"><span class="pre">model</span></code> tag) and are automatically created when SDFormat files
are parsed (by Parser). There are two special
multibody::ModelInstanceIndex values. The world body is always
multibody::ModelInstanceIndex 0. multibody::ModelInstanceIndex 1 is
reserved for all elements with no explicit model instance and is
generally only relevant for elements created programmatically (and
only when a model instance is not explicitly specified). Note that
Parser creates model instances (resulting in a
multibody::ModelInstanceIndex ≥ 2) as needed.</p>
<p>See num_model_instances(), num_positions(), num_velocities(),
num_actuated_dofs(), AddModelInstance() GetPositionsAndVelocities(),
GetPositions(), GetVelocities(), SetPositionsAndVelocities(),
SetPositions(), SetVelocities(), GetPositionsFromArray(),
GetVelocitiesFromArray(), SetPositionsInArray(),
SetVelocitiesInArray(), SetActuationInArray(),
HasModelInstanceNamed(), GetModelInstanceName(),
get_state_output_port(), get_actuation_input_port().</p>
<p><a href="#id7"><span class="problematic" id="id8">**</span></a>** System dynamics</p>
<p>The state of a multibody system <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">[q;</span> <span class="pre">v]</span></code> is given by its
generalized positions vector q, of size <code class="docutils literal notranslate"><span class="pre">nq</span></code> (see num_positions()),
and by its generalized velocities vector v, of size <code class="docutils literal notranslate"><span class="pre">nv</span></code> (see
num_velocities()).</p>
<p>A MultibodyPlant can be constructed to be either continuous or
discrete. The choice is indicated by the time_step passed to the
constructor – a non-zero time_step indicates a discrete plant, while
a zero time_step indicates continuous. A systems::Simulator
“Simulator” will step a discrete plant using the indicated time_step,
but will allow a numerical integrator to choose how to advance time
for a continuous MultibodyPlant.</p>
<p>We’ll discuss continuous plant dynamics in this section. Discrete
dynamics is more complicated and gets its own section below.</p>
<p>As a Drake systems::System “System”, MultibodyPlant implements the
governing equations for a multibody dynamical system in the form <code class="docutils literal notranslate"><span class="pre">ẋ</span>
<span class="pre">=</span> <span class="pre">f(t,</span> <span class="pre">x,</span> <span class="pre">u)</span></code> with t being time and u external inputs such as
actuation forces. The governing equations for the dynamics of a
multibody system modeled with MultibodyPlant are [Featherstone 2008,
Jain 2010]:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">q</span><span class="err">̇</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">N</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="n">v</span>
<span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w">    </span><span class="n">M</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="n">v</span><span class="err">̇</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">C</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">τ</span>
</pre></div>
</div>
</details><p>where <code class="docutils literal notranslate"><span class="pre">M(q)</span></code> is the mass matrix of the multibody system (including
rigid body mass properties and reflected_inertia “reflected
inertias”), <code class="docutils literal notranslate"><span class="pre">C(q,</span> <span class="pre">v)v</span></code> contains Coriolis, centripetal, and
gyroscopic terms and <code class="docutils literal notranslate"><span class="pre">N(q)</span></code> is the kinematic coupling matrix
describing the relationship between q̇ (the time derivatives of the
generalized positions) and the generalized velocities v, [Seth 2010].
<code class="docutils literal notranslate"><span class="pre">N(q)</span></code> is an <code class="docutils literal notranslate"><span class="pre">nq</span> <span class="pre">x</span> <span class="pre">nv</span></code> matrix. The vector <code class="docutils literal notranslate"><span class="pre">τ</span> <span class="pre">∈</span> <span class="pre">ℝⁿᵛ</span></code> on the right
hand side of Eq. (1) is the system’s generalized forces. These
incorporate gravity, springs, externally applied body forces,
constraint forces, and contact forces.</p>
<p><a href="#id9"><span class="problematic" id="id10">**</span></a>** Discrete system dynamics</p>
<p>We’ll start with the basic difference equation interpretation of a
discrete plant and then explain some Drake-specific subtleties.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>We use “kinematics” here to refer to quantities that involve only
position or velocity, and “dynamics” to refer to quantities that
also involve forces.</p>
</div>
<p>By default, a discrete MultibodyPlant has these update dynamics:</p>
<p>x[0] = initial kinematics state variables x (={q, v}), s s[0] = empty
(no sample yet)</p>
<p>s[n+1] = g(t[n], x[n], u[n]) record sample x[n+1] = f(t[n], x[n],
u[n]) update kinematics yd[n+1] = gd(s) dynamic outputs use sampled
values yk[n+1] = gk(x) kinematic outputs use current x</p>
<p>Optionally, output port sampling can be disabled. In that case we
have:</p>
<p>x[n+1] = f(t[n], x[n], u[n]) update kinematics yd[n+1] = gd(g(t, x,
u)) dynamic outputs use current values yk[n+1] = gk(x) kinematic
outputs use current x</p>
<p>We’re using <code class="docutils literal notranslate"><span class="pre">yd</span></code> and <code class="docutils literal notranslate"><span class="pre">yk</span></code> above to represent the calculated values
of dynamic and kinematic output ports, resp. Kinematic output ports
are those that depend only on position and velocity: <code class="docutils literal notranslate"><span class="pre">state</span></code>,
<cite>body_poses</cite>, <code class="docutils literal notranslate"><span class="pre">body_spatial_velocities</span></code>. Everything else depends on
forces so is a dynamic output port: <code class="docutils literal notranslate"><span class="pre">body_spatial_accelerations</span></code>,
<cite>generalized_acceleration</cite>, <code class="docutils literal notranslate"><span class="pre">net_actuation</span></code>, <cite>reaction_forces</cite>, and
<code class="docutils literal notranslate"><span class="pre">contact_results</span></code>.</p>
<p>Use the function SetUseSampledOutputPorts() to choose which dynamics
you prefer. The default behavior (output port sampling) is more
efficient for simulation, but use slightly-different kinematics for
the dynamic output port computations versus the kinematic output
ports. Disabling output port sampling provides “live” output port
results that are recalculated from the current state and inputs
whenever changes occur. It also eliminates the sampling state variable
(s above). Note that kinematic output ports (that is, those depending
only on position and velocity) are always “live” – they are
calculated as needed from the current (updated) state.</p>
<p>The reason that the default mode is more efficient for simulation is
that the sample variable s records expensive-to-compute results (such
as hydroelastic contact forces) that are needed to advance the state
x. Those results are thus available for free at the start of step n.
If instead we wait until after the state is updated to n+1, we would
have to recalculate those expensive results at the new state in order
to report them. Thus sampling means the output ports show the results
that were calculated using kinematics values x[n], although the
Context has been updated to kinematics values x[n+1]. If that isn’t
tolerable you should disable output port sampling. You can also force
an update to occur using ExecuteForcedEvents().</p>
<p>See output_port_sampling “Output port sampling” below for more
practical considerations.</p>
<p>Minor details most users won’t care about:</p>
<ul class="simple">
<li><p>The sample variable s is a Drake Abstract state variable. When it is</p></li>
</ul>
<p>present, the plant update is performed using an Unrestricted update; when it
is absent we are able to use a Discrete update. Some Drake features (e.g.
linearization of discrete systems) may be restricted to systems that use
only Discrete (numeric) state variables and Discrete update.
- The sample variable s is used only by output ports. It does not affect the
behavior of any MultibodyPlant “Calc” or “Eval” functions – those are
always calculated using the current values of time, kinematic state, and
input port values.</p>
<p><a href="#id11"><span class="problematic" id="id12">**</span></a>** Output port sampling</p>
<p>As described in mbp_discrete_dynamics “Discrete system dynamics”
above, the semantics of certain MultibodyPlant output ports depends on
whether the plant is configured to advance using continuous time
integration or discrete time steps (see is_discrete()). This section
explains the details, focusing on the practical aspects moreso than
the equations.</p>
<p>Output ports that only depend on the [q, v] kinematic state (such as
get_body_poses_output_port() or
get_body_spatial_velocities_output_port()) do <em>not</em> change semantics
for continuous vs discrete time. In all cases, the output value is a
function of the kinematic state in the context.</p>
<p>Output ports that incorporate dynamics (i.e., forces) <em>do</em> change
semantics based on the plant mode. Imagine that the
get_applied_spatial_force_input_port() provides a continuously
time-varying input force. The
get_body_spatial_accelerations_output_port() output is dependent on
that force. We could return a snapshot of the acceleration that was
used in the last time step, or we could recalculate the acceleration
to immediately reflect the changing forces. We call the former a
“sampled” port and the latter a “live” port.</p>
<p>For a continuous-time plant, there is no distinction – the output
port is always live – it immediately reflects the instantaneous input
value. It is a “direct feedthrough” output port (see
SystemBase::GetDirectFeedthroughs()).</p>
<p>For a discrete-time plant, the user can choose whether the output
should be sampled or live: Use the function SetUseSampledOutputPorts()
to change whether output ports are sampled or not, and
has_sampled_output_ports() to check the current setting. When sampling
is disabled, the only state in the context is the kinematic [q, v], so
dynamics output ports will always reflect the instantaneous answer
(i.e., direct feedthrough). When sampling is enabled (the default),
the plant state incorporates a snapshot of the most recent step’s
kinematics and dynamics, and the output ports will reflect that
sampled state (i.e., not direct feedthrough). For a detailed
discussion, see mbp_discrete_dynamics “Discrete system dynamics”.</p>
<p>For a discrete-time plant, the sampled outputs are generally <em>much</em>
faster to calculate than the feedthrough outputs when any inputs ports
are changing values faster than the discrete time step, e.g., during a
simulation. When input ports are fixed, or change at the time step
rate (e.g., during motion planning), sampled vs feedthrough will have
similar computational performance.</p>
<p>Direct plant API function calls (e.g.,
EvalBodySpatialAccelerationInWorld()) that depend on forces always use
the instantaneous (not sampled) accelerations.</p>
<p>Here are some practical tips that might help inform your particular
situation:</p>
<p>(1) If you need a minimal-state representation for motion planning,
mathematical optimization, or similar, then you can either use a
continuous-time plant or set the config option
<code class="docutils literal notranslate"><span class="pre">use_sampled_output_ports=false</span></code> on a discrete-time plant.</p>
<p>(2) By default, setting the positions of a discrete-time plant in the
Context will not have any effect on the dynamics-related output ports,
e.g., the contact results will not change. If you need to see changes
to outputs without running the plant in a Simulator, then you can
either use a continuous-time plant, set the config option
<code class="docutils literal notranslate"><span class="pre">use_sampled_output_ports=false</span></code>, or use ExecuteForcedEvents() to
force a dynamics step and then the outputs (and positions) will
change.</p>
<p><a href="#id13"><span class="problematic" id="id14">**</span></a>** Actuation</p>
<p>In a MultibodyPlant model an actuator can be added as a JointActuator,
see AddJointActuator(). The plant declares actuation input ports to
provide feedforward actuation, both for the MultibodyPlant as a whole
(see get_actuation_input_port()) and for each individual
model_instances “model instance” in the MultibodyPlant (see
get_actuation_input_port(ModelInstanceIndex)const
“get_actuation_input_port(ModelInstanceIndex)”). - Actuation inputs
and actuation effort limits are taken to be in joint coordinates (they
are not affected by the actuator gear ratio). - Any actuation input
ports not connected are assumed to be zero. - Actuation values from
the full MultibodyPlant model port (get_actuation_input_port()) and
from the per model-instance ports (
get_actuation_input_port(ModelInstanceIndex)const
“get_actuation_input_port(ModelInstanceIndex)”) are summed up.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A JointActuator’s index into the vector data supplied to
MultibodyPlant’s actuation input port for all actuators
(get_actuation_input_port()) is given by
JointActuator::input_start(), NOT by its JointActuatorIndex. That
is, the vector element data for a JointActuator at index
JointActuatorIndex(i) in the full input port vector is found at
index:
MultibodyPlant::get_joint_actuator(JointActuatorIndex(i)).input_start().
For the get_actuation_input_port(ModelInstanceIndex)const
“get_actuation_input_port(ModelInstanceIndex)” specific to a model
index, the vector data is ordered by monotonically increasing
JointActuatorIndex for the actuators within that model instance:
the 0ᵗʰ vector element corresponds to the lowest-numbered
JointActuatorIndex of that instance, the 1ˢᵗ vector element
corresponds to the second-lowest-numbered JointActuatorIndex of
that instance, etc.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The following snippet shows how per model instance actuation can
be set:</p>
</div>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">ModelInstanceIndex</span><span class="w"> </span><span class="n">model_instance_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...;</span>
<span class="n">VectorX</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">u_instance</span><span class="p">(</span><span class="n">plant</span><span class="p">.</span><span class="n">num_actuated_dofs</span><span class="p">(</span><span class="n">model_instance_index</span><span class="p">));</span>
<span class="kt">int</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">JointActuatorIndex</span><span class="w"> </span><span class="n">joint_actuator_index</span><span class="w"> </span><span class="o">:</span>
<span class="n">plant</span><span class="p">.</span><span class="n">GetJointActuatorIndices</span><span class="p">(</span><span class="n">model_instance_index</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="k">const</span><span class="w"> </span><span class="n">JointActuator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">actuator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">plant</span><span class="p">.</span><span class="n">get_joint_actuator</span><span class="p">(</span>
<span class="n">joint_actuator_index</span><span class="p">);</span>
<span class="k">const</span><span class="w"> </span><span class="n">Joint</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">joint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">actuator</span><span class="p">.</span><span class="n">joint</span><span class="p">();</span>
<span class="n">VectorX</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">u_joint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="n">my_actuation_logic_for</span><span class="p">(</span><span class="n">joint</span><span class="p">)</span><span class="w"> </span><span class="p">...;</span>
<span class="n">ASSERT</span><span class="p">(</span><span class="n">u_joint</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">joint_actuator</span><span class="p">.</span><span class="n">num_inputs</span><span class="p">());</span>
<span class="n">u_instance</span><span class="p">.</span><span class="n">segment</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="n">u_joint</span><span class="p">.</span><span class="n">size</span><span class="p">())</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">u_joint</span><span class="p">;</span>
<span class="n">offset</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">u_joint</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
<span class="p">}</span>
<span class="n">plant</span><span class="p">.</span><span class="n">get_actuation_input_port</span><span class="p">(</span><span class="n">model_instance_index</span><span class="p">).</span><span class="n">FixValue</span><span class="p">(</span>
<span class="n">plant_context</span><span class="p">,</span><span class="w"> </span><span class="n">u_instance</span><span class="p">);</span>
</pre></div>
</div>
</details><div class="admonition note">
<p class="admonition-title">Note</p>
<p>To inter-operate between the whole plant actuation vector and sets
of per-model instance actuation vectors, see SetActuationInArray()
to gather the model instance vectors into a whole plant vector and
GetActuationFromArray() to scatter the whole plant vector into
per-model instance vectors.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Effort limits (JointActuator::effort_limit()) are not enforced,
unless PD controllers are defined. See pd_controllers “Using PD
controlled actuators”.</p>
</div>
<p>** Using PD controlled actuators</p>
<p>While PD controllers can be modeled externally and be connected to the
MultibodyPlant model via the get_actuation_input_port(), simulation
stability at discrete-time steps can be compromised for high
controller gains. For such cases, simulation stability and robustness
can be improved significantly by moving your PD controller into the
plant where the discrete solver can strongly couple controller and
model dynamics.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Currently, this feature is only supported for discrete models
(is_discrete() is true) using the SAP solver
(get_discrete_contact_solver() returns
DiscreteContactSolver::kSap.)</p>
</div>
<p>PD controlled joint actuators can be defined by setting PD gains for
each joint actuator, see JointActuator::set_controller_gains(). Unless
these gains are specified, joint actuators will not be PD controlled
and JointActuator::has_controller() will return <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
<p>For models with PD controllers, the actuation torque per actuator is
computed according to:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">u</span><span class="err">̃</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">Kp</span><span class="err">⋅</span><span class="p">(</span><span class="n">q</span><span class="w"> </span><span class="err">−</span><span class="w"> </span><span class="n">qd</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">Kd</span><span class="err">⋅</span><span class="p">(</span><span class="n">v</span><span class="w"> </span><span class="err">−</span><span class="w"> </span><span class="n">vd</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">u_ff</span>
<span class="n">u</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="err">−</span><span class="n">e</span><span class="p">,</span><span class="w"> </span><span class="n">min</span><span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="w"> </span><span class="n">u</span><span class="err">̃</span><span class="p">))</span>
</pre></div>
</div>
</details><p>where qd and vd are desired configuration and velocity (see
get_desired_state_input_port()) for the actuated joint (see
JointActuator::joint()), Kp and Kd are the proportional and derivative
gains of the actuator (see JointActuator::get_controller_gains()),
<code class="docutils literal notranslate"><span class="pre">u_ff</span></code> is the feed-forward actuation specified with
get_actuation_input_port(), and <code class="docutils literal notranslate"><span class="pre">e</span></code> corresponds to effort limit (see
JointActuator::effort_limit()).</p>
<p>Notice that actuation through get_actuation_input_port() and PD
control are not mutually exclusive, and they can be used together.
This is better explained through examples: 1. <strong>PD controlled
gripper</strong>. In this case, only PD control is used to drive the opening
and closing of the fingers. The feed-forward term is assumed to be
zero and the actuation input port is not required to be connected. 2.
<strong>Robot arm</strong>. A typical configuration consists on applying gravity
compensation in the feed-forward term plus PD control to drive the
robot to a given desired state.</p>
<p>** Actuation input ports requirements</p>
<p>Actuation input ports and desired state input ports need not be
connected: - Unconnected actuation inputs default to zero, simplifying
diagram wiring for models relying solely on PD controllers. - PD
controllers are disarmed when their model instance’s desired state
input port is disconnected. In this state, they have no effect on
dynamics, behaving as if no PD controller exists. This allows a
MultibodyPlant model to be used outside simulation (e.g., for
visualization).</p>
<p>Note that both ports are always created but will be zero-sized for
model instances without actuation.</p>
<p>** Net actuation</p>
<p>The total joint actuation applied via the actuation input port
(get_actuation_input_port()) and applied by the PD controllers is
reported by the net actuation port (get_net_actuation_output_port()).
That is, the net actuation port reports the total actuation applied by
a given actuator.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>PD controllers are ignored when a joint is locked (see
Joint::Lock()), and thus they have no effect on the actuation
output.</p>
</div>
<p><a href="#id15"><span class="problematic" id="id16">**</span></a>** Loading models from SDFormat files</p>
<p>Drake has the capability to load multibody models from SDFormat and
URDF files. Consider the example below which loads an acrobot model:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">acrobot</span><span class="p">;</span>
<span class="n">SceneGraph</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">scene_graph</span><span class="p">;</span>
<span class="n">Parser</span><span class="w"> </span><span class="nf">parser</span><span class="p">(</span><span class="o">&amp;</span><span class="n">acrobot</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">scene_graph</span><span class="p">);</span>
<span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">url</span><span class="w"> </span><span class="o">=</span>
<span class="s">&quot;package://drake/multibody/benchmarks/acrobot/acrobot.sdf&quot;</span><span class="p">;</span>
<span class="n">parser</span><span class="p">.</span><span class="n">AddModelsFromUrl</span><span class="p">(</span><span class="n">url</span><span class="p">);</span>
</pre></div>
</div>
</details><p>As in the example above, for models including visual geometry,
collision geometry or both, the user must specify a SceneGraph for
geometry handling. You can find a full example of the LQR controlled
acrobot in examples/multibody/acrobot/run_lqr.cc.</p>
<p>AddModelFromFile() can be invoked multiple times on the same plant in
order to load multiple model instances. Other methods are available on
Parser such as AddModels() which allows creating model instances per
each <code class="docutils literal notranslate"><span class="pre">&lt;model&gt;</span></code> tag found in the file. Please refer to each of these
methods’ documentation for further details.</p>
<p><a href="#id17"><span class="problematic" id="id18">**</span></a>** Working with SceneGraph</p>
<p>** Adding a MultibodyPlant connected to a SceneGraph to your Diagram</p>
<p>Probably the simplest way to add and wire up a MultibodyPlant with a
SceneGraph in your Diagram is using AddMultibodyPlantSceneGraph().</p>
<p>Recommended usages:</p>
<p>Assign to a MultibodyPlant reference (ignoring the SceneGraph):</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">plant</span><span class="w"> </span><span class="o">=</span>
<span class="n">AddMultibodyPlantSceneGraph</span><span class="p">(</span><span class="o">&amp;</span><span class="n">builder</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="o">/+</span><span class="w"> </span><span class="n">time_step</span><span class="w"> </span><span class="o">+/</span><span class="p">);</span>
<span class="n">plant</span><span class="p">.</span><span class="n">DoFoo</span><span class="p">(...);</span>
</pre></div>
</div>
</details><p>This flavor is the simplest, when the SceneGraph is not explicitly
needed. (It can always be retrieved later via
GetSubsystemByName(“scene_graph”).)</p>
<p>Assign to auto, and use the named public fields:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="n">items</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AddMultibodyPlantSceneGraph</span><span class="p">(</span><span class="o">&amp;</span><span class="n">builder</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="o">/+</span><span class="w"> </span><span class="n">time_step</span><span class="w"> </span><span class="o">+/</span><span class="p">);</span>
<span class="n">items</span><span class="p">.</span><span class="n">plant</span><span class="p">.</span><span class="n">DoFoo</span><span class="p">(...);</span>
<span class="n">items</span><span class="p">.</span><span class="n">scene_graph</span><span class="p">.</span><span class="n">DoBar</span><span class="p">(...);</span>
</pre></div>
</div>
</details><p>or taking advantage of C++’s structured binding:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="p">[</span><span class="n">plant</span><span class="p">,</span><span class="w"> </span><span class="n">scene_graph</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AddMultibodyPlantSceneGraph</span><span class="p">(</span><span class="o">&amp;</span><span class="n">builder</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">);</span>
<span class="p">...</span>
<span class="n">plant</span><span class="p">.</span><span class="n">DoFoo</span><span class="p">(...);</span>
<span class="n">scene_graph</span><span class="p">.</span><span class="n">DoBar</span><span class="p">(...);</span>
</pre></div>
</div>
</details><p>This is the easiest way to use both the plant and scene_graph.</p>
<p>Assign to already-declared pointer variables:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;*</span><span class="w"> </span><span class="n">plant</span><span class="p">{};</span>
<span class="n">SceneGraph</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;*</span><span class="w"> </span><span class="n">scene_graph</span><span class="p">{};</span>
<span class="n">std</span><span class="o">::</span><span class="n">tie</span><span class="p">(</span><span class="n">plant</span><span class="p">,</span><span class="w"> </span><span class="n">scene_graph</span><span class="p">)</span><span class="w"> </span><span class="o">=</span>
<span class="n">AddMultibodyPlantSceneGraph</span><span class="p">(</span><span class="o">&amp;</span><span class="n">builder</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="o">/+</span><span class="w"> </span><span class="n">time_step</span><span class="w"> </span><span class="o">+/</span><span class="p">);</span>
<span class="n">plant</span><span class="o">-&gt;</span><span class="n">DoFoo</span><span class="p">(...);</span>
<span class="n">scene_graph</span><span class="o">-&gt;</span><span class="n">DoBar</span><span class="p">(...);</span>
</pre></div>
</div>
</details><p>This flavor is most useful when the pointers are class member fields
(and so perhaps cannot be references).</p>
<p>** Registering geometry with a SceneGraph</p>
<p>MultibodyPlant users can register geometry with a SceneGraph for
essentially two purposes; a) visualization and, b) contact modeling.</p>
<p>Before any geometry registration takes place, a user <strong>must</strong> first
make a call to RegisterAsSourceForSceneGraph() in order to register
the MultibodyPlant as a client of a SceneGraph instance, point at
which the plant will have assigned a valid geometry::SourceId. At
Finalize(), MultibodyPlant will declare input/output ports as
appropriate to communicate with the SceneGraph instance on which
registrations took place. All geometry registration <strong>must</strong> be
performed pre-finalize.</p>
<p>Multibodyplant declares an input port for geometric queries, see
get_geometry_query_input_port(). If MultibodyPlant registers geometry
with a SceneGraph via calls to RegisterCollisionGeometry(), users may
use this port for geometric queries. The port must be connected to the
same SceneGraph used for registration. The preferred mechanism is to
use AddMultibodyPlantSceneGraph() as documented above.</p>
<p>In extraordinary circumstances, this can be done by hand and the setup
process will include:</p>
<ol class="arabic simple">
<li><p>Call to RegisterAsSourceForSceneGraph().</p></li>
<li><p>Calls to RegisterCollisionGeometry(), as many as needed.</p></li>
<li><p>Call to Finalize(), user is done specifying the model.</p></li>
</ol>
<p>4. Connect geometry::SceneGraph::get_query_output_port() to
get_geometry_query_input_port().
5. Connect get_geometry_pose_output_port() to
geometry::SceneGraph::get_source_pose_port()</p>
<p>Refer to the documentation provided in each of the methods above for
further details.</p>
<p>** Accessing point contact parameters MultibodyPlant’s point contact
model looks for model parameters stored as
geometry::ProximityProperties by geometry::SceneGraph. These
properties can be obtained before or after context creation through
geometry::SceneGraphInspector APIs as outlined below. MultibodyPlant
expects the following properties for point contact modeling:</p>
<p><a href="#id107"><span class="problematic" id="id108">|Group name|Property Name|Required|Property Type|Property Description|</span></a>
<a href="#id109"><span class="problematic" id="id110">|:--------:|</span></a>:———–:<a href="#id111"><span class="problematic" id="id112">|:------:|</span></a>:—————-:<a href="#id113"><span class="problematic" id="id114">|:-------------------|</span></a>
<a href="#id115"><span class="problematic" id="id116">|material|coulomb_friction|yes¹|CoulombFriction&lt;T&gt;|Static and Dynamic
friction.|</span></a> <a href="#id117"><span class="problematic" id="id118">|material|point_contact_stiffness|no²|T|</span></a> Compliant point
contact stiffness.| <a href="#id119"><span class="problematic" id="id120">|material|hunt_crossley_dissipation |no²⁴|T|</span></a>
Compliant contact dissipation.|
<a href="#id121"><span class="problematic" id="id122">|material|relaxation_time|yes³⁴|T|Linear Kelvin–Voigt model
parameter.|</span></a></p>
<p>¹ Collision geometry is required to be registered with a
geometry::ProximityProperties object that contains the (“material”,
“coulomb_friction”) property. If the property is missing,
MultibodyPlant will throw an exception.</p>
<p>² If the property is missing, MultibodyPlant will use a heuristic
value as the default. Refer to the section point_contact_defaults
“Point Contact Default Parameters” for further details.</p>
<p>³ When using a linear Kelvin–Voigt model of dissipation (for instance
when selecting the SAP solver), collision geometry is required to be
registered with a geometry::ProximityProperties object that contains
the (“material”, “relaxation_time”) property. If the property is
missing, an exception will be thrown.</p>
<p>⁴ We allow to specify both hunt_crossley_dissipation and
relaxation_time for a given geometry. However only one of these will
get used, depending on the configuration of the MultibodyPlant. As an
example, if the SAP contact approximation is specified (see
set_discrete_contact_approximation()) only the relaxation_time is used
while hunt_crossley_dissipation is ignored. Conversely, if the TAMSI,
Similar or Lagged approximation is used (see
set_discrete_contact_approximation()) only hunt_crossley_dissipation
is used while relaxation_time is ignored. Currently, a continuous
MultibodyPlant model will always use the Hunt &amp; Crossley model and
relaxation_time will be ignored.</p>
<p>Accessing and modifying contact properties requires interfacing with
geometry::SceneGraph’s model inspector. Interfacing with a model
inspector obtained from geometry::SceneGraph will provide the default
registered values for a given parameter. These are the values that
will initially appear in a systems::Context created by
CreateDefaultContext(). Subsequently, true system parameters can be
accessed and changed through a systems::Context once available. For
both of the above cases, proximity properties are accessed through
geometry::SceneGraphInspector APIs.</p>
<p>Before context creation an inspector can be retrieved directly from
SceneGraph as:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// For a SceneGraph&lt;T&gt; instance called scene_graph.</span>
<span class="k">const</span><span class="w"> </span><span class="n">geometry</span><span class="o">::</span><span class="n">SceneGraphInspector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">inspector</span><span class="w"> </span><span class="o">=</span>
<span class="n">scene_graph</span><span class="p">.</span><span class="n">model_inspector</span><span class="p">();</span>
</pre></div>
</div>
</details><p>After context creation, an inspector can be retrieved from the state
stored in the context:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// For a MultibodyPlant&lt;T&gt; instance called mbp and a Context&lt;T&gt; called</span>
<span class="c1">// context.</span>
<span class="k">const</span><span class="w"> </span><span class="n">geometry</span><span class="o">::</span><span class="n">SceneGraphInspector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">inspector</span><span class="w"> </span><span class="o">=</span>
<span class="n">mbp</span><span class="p">.</span><span class="n">EvalSceneGraphInspector</span><span class="p">(</span><span class="n">context</span><span class="p">);</span>
</pre></div>
</div>
</details><p>Once an inspector is available, proximity properties can be retrieved
as:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// For a body with GeometryId called geometry_id</span>
<span class="k">const</span><span class="w"> </span><span class="n">geometry</span><span class="o">::</span><span class="n">ProximityProperties</span><span class="o">*</span><span class="w"> </span><span class="n">props</span><span class="w"> </span><span class="o">=</span>
<span class="n">inspector</span><span class="p">.</span><span class="n">GetProximityProperties</span><span class="p">(</span><span class="n">geometry_id</span><span class="p">);</span>
<span class="k">const</span><span class="w"> </span><span class="n">CoulombFriction</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">geometry_friction</span><span class="w"> </span><span class="o">=</span>
<span class="n">props</span><span class="o">-&gt;</span><span class="n">GetProperty</span><span class="o">&lt;</span><span class="n">CoulombFriction</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="s">&quot;material&quot;</span><span class="p">,</span>
<span class="s">&quot;coulomb_friction&quot;</span><span class="p">);</span>
</pre></div>
</div>
</details><p><a href="#id19"><span class="problematic" id="id20">**</span></a>** Working with MultibodyElement parameters Several
MultibodyElements expose parameters, allowing the user flexible
modification of some aspects of the plant’s model, post
systems::Context creation. For details, refer to the documentation for
the MultibodyElement whose parameters you are trying to modify/access
(e.g. RigidBody, FixedOffsetFrame, etc.)</p>
<p>As an example, here is how to access and modify rigid body mass
parameters:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">plant</span><span class="p">;</span>
<span class="c1">// ... Code to add bodies, finalize plant, and to obtain a context.</span>
<span class="k">const</span><span class="w"> </span><span class="n">RigidBody</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">body</span><span class="w"> </span><span class="o">=</span>
<span class="n">plant</span><span class="p">.</span><span class="n">GetRigidBodyByName</span><span class="p">(</span><span class="s">&quot;BodyName&quot;</span><span class="p">);</span>
<span class="k">const</span><span class="w"> </span><span class="n">SpatialInertia</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">M_BBo_B</span><span class="w"> </span><span class="o">=</span>
<span class="n">body</span><span class="p">.</span><span class="n">GetSpatialInertiaInBodyFrame</span><span class="p">(</span><span class="n">context</span><span class="p">);</span>
<span class="c1">// .. logic to determine a new SpatialInertia parameter for body.</span>
<span class="k">const</span><span class="w"> </span><span class="n">SpatialInertia</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">M_BBo_B_new</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">....</span>

<span class="c1">// Modify the body parameter for spatial inertia.</span>
<span class="n">body</span><span class="p">.</span><span class="n">SetSpatialInertiaInBodyFrame</span><span class="p">(</span><span class="o">&amp;</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="n">M_BBo_B_new</span><span class="p">);</span>
</pre></div>
</div>
</details><p>Another example, working with automatic differentiation in order to
take derivatives with respect to one of the bodies’ masses:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">plant</span><span class="p">;</span>
<span class="c1">// ... Code to add bodies, finalize plant, and to obtain a</span>
<span class="c1">// context and a body&#39;s spatial inertia M_BBo_B.</span>

<span class="c1">// Scalar convert the plant.</span>
<span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="n">AutoDiffXd</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">plant_autodiff</span><span class="w"> </span><span class="o">=</span>
<span class="n">systems</span><span class="o">::</span><span class="n">System</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">ToAutoDiffXd</span><span class="p">(</span><span class="n">plant</span><span class="p">);</span>
<span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Context</span><span class="o">&lt;</span><span class="n">AutoDiffXd</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">context_autodiff</span><span class="w"> </span><span class="o">=</span>
<span class="n">plant_autodiff</span><span class="o">-&gt;</span><span class="n">CreateDefaultContext</span><span class="p">();</span>
<span class="n">context_autodiff</span><span class="o">-&gt;</span><span class="n">SetTimeStateAndParametersFrom</span><span class="p">(</span><span class="n">context</span><span class="p">);</span>

<span class="k">const</span><span class="w"> </span><span class="n">RigidBody</span><span class="o">&lt;</span><span class="n">AutoDiffXd</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">body</span><span class="w"> </span><span class="o">=</span>
<span class="n">plant_autodiff</span><span class="o">-&gt;</span><span class="n">GetRigidBodyByName</span><span class="p">(</span><span class="s">&quot;BodyName&quot;</span><span class="p">);</span>

<span class="c1">// Modify the body parameter for mass.</span>
<span class="k">const</span><span class="w"> </span><span class="n">AutoDiffXd</span><span class="w"> </span><span class="nf">mass_autodiff</span><span class="p">(</span><span class="n">mass</span><span class="p">,</span><span class="w"> </span><span class="n">Vector1d</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
<span class="n">body</span><span class="p">.</span><span class="n">SetMass</span><span class="p">(</span><span class="n">context_autodiff</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span><span class="w"> </span><span class="n">mass_autodiff</span><span class="p">);</span>

<span class="c1">// M_autodiff(i, j).derivatives()(0), contains the derivatives of</span>
<span class="c1">// M(i, j) with respect to the body&#39;s mass.</span>
<span class="n">MatrixX</span><span class="o">&lt;</span><span class="n">AutoDiffXd</span><span class="o">&gt;</span><span class="w"> </span><span class="n">M_autodiff</span><span class="p">(</span><span class="n">plant_autodiff</span><span class="o">-&gt;</span><span class="n">num_velocities</span><span class="p">(),</span>
<span class="n">plant_autodiff</span><span class="o">-&gt;</span><span class="n">num_velocities</span><span class="p">());</span>
<span class="n">plant_autodiff</span><span class="o">-&gt;</span><span class="n">CalcMassMatrix</span><span class="p">(</span><span class="o">*</span><span class="n">context_autodiff</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">M_autodiff</span><span class="p">);</span>
</pre></div>
</div>
</details><p><a href="#id21"><span class="problematic" id="id22">**</span></a>** Adding modeling elements</p>
<p>Add multibody elements to a MultibodyPlant with methods like:</p>
<ul class="simple">
<li><p>Bodies: AddRigidBody()</p></li>
<li><p>Joints: AddJoint()</p></li>
<li><p>see mbp_construction “Construction” for more.</p></li>
</ul>
<p>All modeling elements <strong>must</strong> be added before Finalize() is called.
See mbp_finalize_stage “Finalize stage” for a discussion.</p>
<p><a href="#id23"><span class="problematic" id="id24">**</span></a>** Modeling contact</p>
<p>Please refer to drake_contacts “Contact Modeling in Drake” for details
on the available approximations, setup, and considerations for a
multibody simulation with frictional contact.</p>
<p><a href="#id25"><span class="problematic" id="id26">**</span></a>** Energy and Power</p>
<p>MultibodyPlant implements the System energy and power methods, with
some limitations. - Kinetic energy: fully implemented. - Potential
energy and conservative power: currently include only gravity and
contributions from ForceElement objects; potential energy from
compliant contact and joint limits are not included. - Nonconservative
power: currently includes only contributions from ForceElement
objects; actuation and input port forces, joint damping, and
dissipation from joint limits, friction, and contact dissipation are
not included.</p>
<p>See Drake issue #12942 for more discussion.</p>
<p><a href="#id27"><span class="problematic" id="id28">**</span></a>** Finalize() stage</p>
<p>Once the user is done adding modeling elements and registering
geometry, a call to Finalize() must be performed. This call will: -
Build the underlying tree structure of the multibody model, - declare
the plant’s state, - declare the plant’s input and output ports, -
declare collision filters to ignore collisions among rigid bodies: -
between rigid bodies connected by a joint, - within subgraphs of
welded rigid bodies.</p>
<p>Note that MultibodyPlant will <em>not</em> introduce any automatic collision
filters on deformable bodies. Collision filters for deformable bodies
can be explicitly applied via
ExcludeCollisionGeometriesWithCollisionFilterGroupPair() or during
parsing.</p>
<p><a href="#id29"><span class="problematic" id="id30">**</span></a>** References</p>
<ul class="simple">
<li><p>[Featherstone 2008] Featherstone, R., 2008.</p></li>
</ul>
<p>Rigid body dynamics algorithms. Springer.
- [Jain 2010] Jain, A., 2010.
Robot and multibody dynamics: analysis and algorithms.
Springer Science &amp; Business Media.
- [Seth 2010] Seth, A., Sherman, M., Eastman, P. and Delp, S., 2010.
Minimal formulation of joint motion for biomechanisms.
Nonlinear dynamics, 62(1), pp.291-303.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><code class="xref py py-class docutils literal notranslate"><span class="pre">MultibodyPlant_</span></code></a>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_step</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.__init__" title="Link to this definition"></a></dt>
<dd><p>This constructor creates a plant with a single “world” body.
Therefore, right after creation, num_bodies() returns one.</p>
<p>MultibodyPlant offers two different modalities to model mechanical
systems in time. These are: 1. As a discrete system with periodic
updates, <code class="docutils literal notranslate"><span class="pre">time_step</span></code> is strictly greater than zero. 2. As a
continuous system, <code class="docutils literal notranslate"><span class="pre">time_step</span></code> equals exactly zero.</p>
<p>Currently the discrete model is preferred for simulation given its
robustness and speed in problems with frictional contact. However this
might change as we work towards developing better strategies to model
contact. See multibody_simulation for further details.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Users should be aware of current limitations in either modeling
modality. While the discrete model is often the preferred option
for problems with frictional contact given its robustness and
speed, it might become unstable when using large feedback gains,
high damping or large external forcing. MultibodyPlant will throw
an exception whenever the discrete solver is detected to fail.
Conversely, the continuous modality has the potential to leverage
the robustness and accuracy control provide by Drake’s
integrators. However thus far this has proved difficult in
practice and especially due to poor performance.</p>
</div>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">time_step</span></code>:</dt><dd><p>Indicates whether <code class="docutils literal notranslate"><span class="pre">this</span></code> plant is modeled as a continuous system
(<code class="docutils literal notranslate"><span class="pre">time_step</span> <span class="pre">=</span> <span class="pre">0</span></code>) or as a discrete system with periodic updates
of period <code class="docutils literal notranslate"><span class="pre">time_step</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>. See multibody_simulation for further
details.</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Currently the continuous modality with <code class="docutils literal notranslate"><span class="pre">time_step</span> <span class="pre">=</span> <span class="pre">0</span></code> does not
support joint limits for simulation, these are ignored.
MultibodyPlant prints a warning to console if joint limits are
provided. If your simulation requires joint limits currently you
must use a discrete MultibodyPlant model.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if time_step is negative.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.AddBallConstraint">
<span class="sig-name descname"><span class="pre">AddBallConstraint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">body_A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody" title="pydrake.multibody.tree.RigidBody"><span class="pre">pydrake.multibody.tree.RigidBody</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_AP</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody" title="pydrake.multibody.tree.RigidBody"><span class="pre">pydrake.multibody.tree.RigidBody</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_BQ</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.MultibodyConstraintId" title="pydrake.multibody.tree.MultibodyConstraintId"><span class="pre">pydrake.multibody.tree.MultibodyConstraintId</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.AddBallConstraint" title="Link to this definition"></a></dt>
<dd><p>Defines a constraint such that point P affixed to body A is coincident
at all times with point Q affixed to body B, effectively modeling a
ball-and-socket joint.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body_A</span></code>:</dt><dd><p>RigidBody to which point P is rigidly attached.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_AP</span></code>:</dt><dd><p>Position of point P in body A’s frame.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body_B</span></code>:</dt><dd><p>RigidBody to which point Q is rigidly attached.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BQ</span></code>:</dt><dd><p>(optional) Position of point Q in body B’s frame. If p_BQ is
std::nullopt, then p_BQ will be computed so that the constraint is
satisfied for the default configuration at Finalize() time;
subsequent changes to the default configuration will not change
the computed p_BQ.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>the id of the newly added constraint.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>RuntimeError if bodies A and B are the same body.</strong> – </p></li>
<li><p><strong>RuntimeError if the MultibodyPlant has already been finalized.</strong> – </p></li>
<li><p><strong>RuntimeError if this MultibodyPlant is not a discrete model</strong> – </p></li>
<li><p><strong>(</strong><strong>is_discrete</strong><strong>(</strong><strong>) </strong><strong>== false</strong><strong>)</strong> – </p></li>
<li><p><strong>RuntimeError if this MultibodyPlant's underlying contact</strong> – </p></li>
<li><p><strong>solver is not SAP.</strong><strong> (</strong><strong>i.e. get_discrete_contact_solver</strong><strong>(</strong><strong>) </strong><strong>!=</strong> – </p></li>
<li><p><strong>DiscreteContactSolver::kSap</strong><strong>)</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.AddCouplerConstraint">
<span class="sig-name descname"><span class="pre">AddCouplerConstraint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">joint0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Joint" title="pydrake.multibody.tree.Joint"><span class="pre">pydrake.multibody.tree.Joint</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">joint1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Joint" title="pydrake.multibody.tree.Joint"><span class="pre">pydrake.multibody.tree.Joint</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">gear_ratio</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.0</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.MultibodyConstraintId" title="pydrake.multibody.tree.MultibodyConstraintId"><span class="pre">pydrake.multibody.tree.MultibodyConstraintId</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.AddCouplerConstraint" title="Link to this definition"></a></dt>
<dd><p>Defines a holonomic constraint between two single-dof joints
<code class="docutils literal notranslate"><span class="pre">joint0</span></code> and <code class="docutils literal notranslate"><span class="pre">joint1</span></code> with positions q₀ and q₁, respectively, such
that q₀ = ρ⋅q₁ + Δq, where ρ is the gear ratio and Δq is a fixed
offset. The gear ratio can have units if the units of q₀ and q₁ are
different. For instance, between a prismatic and a revolute joint the
gear ratio will specify the “pitch” of the resulting mechanism. As
defined, <code class="docutils literal notranslate"><span class="pre">offset</span></code> has units of <code class="docutils literal notranslate"><span class="pre">q₀</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>joint0 and/or joint1 can still be actuated, regardless of whether
we have coupler constraint among them. That is, one or both of
these joints can have external actuation applied to them.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Generally, to couple (q0, q1, q2), the user would define a coupler
between (q0, q1) and a second coupler between (q1, q2), or any
combination therein.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>if joint0 and joint1 are not both single-dof joints.</strong> – </p></li>
<li><p><strong>RuntimeError if the MultibodyPlant has already been finalized.</strong> – </p></li>
<li><p><strong>RuntimeError if this MultibodyPlant is not a discrete model</strong> – </p></li>
<li><p><strong>(</strong><strong>is_discrete</strong><strong>(</strong><strong>) </strong><strong>== false</strong><strong>)</strong> – </p></li>
<li><p><strong>RuntimeError if this MultibodyPlant's underlying contact</strong> – </p></li>
<li><p><strong>solver is not SAP.</strong><strong> (</strong><strong>i.e. get_discrete_contact_solver</strong><strong>(</strong><strong>) </strong><strong>!=</strong> – </p></li>
<li><p><strong>DiscreteContactSolver::kSap</strong><strong>)</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.AddDistanceConstraint">
<span class="sig-name descname"><span class="pre">AddDistanceConstraint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">body_A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody" title="pydrake.multibody.tree.RigidBody"><span class="pre">pydrake.multibody.tree.RigidBody</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_AP</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody" title="pydrake.multibody.tree.RigidBody"><span class="pre">pydrake.multibody.tree.RigidBody</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_BQ</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stiffness</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">inf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">damping</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.0</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.MultibodyConstraintId" title="pydrake.multibody.tree.MultibodyConstraintId"><span class="pre">pydrake.multibody.tree.MultibodyConstraintId</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.AddDistanceConstraint" title="Link to this definition"></a></dt>
<dd><p>Defines a distance constraint between a point P on a body A and a
point Q on a body B.</p>
<p>This constraint can be compliant, modeling a spring with free length
<code class="docutils literal notranslate"><span class="pre">distance</span></code> and given <code class="docutils literal notranslate"><span class="pre">stiffness</span></code> and <code class="docutils literal notranslate"><span class="pre">damping</span></code> parameters
between points P and Q. For d = ‖p_PQ‖, then a compliant distance
constraint models a spring with force along p_PQ given by:</p>
<p>f = −stiffness ⋅ d − damping ⋅ ḋ</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body_A</span></code>:</dt><dd><p>RigidBody to which point P is rigidly attached.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_AP</span></code>:</dt><dd><p>Position of point P in body A’s frame.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body_B</span></code>:</dt><dd><p>RigidBody to which point Q is rigidly attached.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BQ</span></code>:</dt><dd><p>Position of point Q in body B’s frame.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">distance</span></code>:</dt><dd><p>Fixed length of the distance constraint, in meters. It must be
strictly positive.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">stiffness</span></code>:</dt><dd><p>For modeling a spring with free length equal to <code class="docutils literal notranslate"><span class="pre">distance</span></code>, the
stiffness parameter in N/m. Optional, with its default value being
infinite to model a rigid massless rod of length <code class="docutils literal notranslate"><span class="pre">distance</span></code>
connecting points A and B.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">damping</span></code>:</dt><dd><p>For modeling a spring with free length equal to <code class="docutils literal notranslate"><span class="pre">distance</span></code>,
damping parameter in N⋅s/m. Optional, with its default value being
zero for a non-dissipative constraint.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>the id of the newly added constraint.</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Currently, it is the user’s responsibility to initialize the
model’s context in a configuration compatible with the newly added
constraint.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>A distance constraint is the wrong modeling choice if the distance
needs to go through zero. To constrain two points to be coincident
we need a 3-dof ball constraint, the 1-dof distance constraint is
singular in this case. Therefore we require the distance parameter
to be strictly positive.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When a new context is created, a DistanceConstraintParams is
initialized to store the parameters passed to this function.
Parameters in the context can be modified with calls to
SetDistanceConstraintParams().</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if bodies A and B are the same body.</strong> – </p></li>
<li><p><strong>RuntimeError if distance is not strictly positive.</strong> – </p></li>
<li><p><strong>RuntimeError if stiffness is not positive</strong><strong> or </strong><strong>zero.</strong> – </p></li>
<li><p><strong>RuntimeError if damping is not positive</strong><strong> or </strong><strong>zero.</strong> – </p></li>
<li><p><strong>RuntimeError if the MultibodyPlant has already been finalized.</strong> – </p></li>
<li><p><strong>RuntimeError if this MultibodyPlant is not a discrete model</strong> – </p></li>
<li><p><strong>(</strong><strong>is_discrete</strong><strong>(</strong><strong>) </strong><strong>== false</strong><strong>)</strong> – </p></li>
<li><p><strong>RuntimeError if this MultibodyPlant's underlying contact</strong> – </p></li>
<li><p><strong>solver is not SAP.</strong><strong> (</strong><strong>i.e. get_discrete_contact_solver</strong><strong>(</strong><strong>) </strong><strong>!=</strong> – </p></li>
<li><p><strong>DiscreteContactSolver::kSap</strong><strong>)</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.AddForceElement">
<span class="sig-name descname"><span class="pre">AddForceElement</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">force_element</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ForceElement" title="pydrake.multibody.tree.ForceElement"><span class="pre">pydrake.multibody.tree.ForceElement</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ForceElement" title="pydrake.multibody.tree.ForceElement"><span class="pre">pydrake.multibody.tree.ForceElement</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.AddForceElement" title="Link to this definition"></a></dt>
<dd><p>Adds a new force element model of type <code class="docutils literal notranslate"><span class="pre">ForceElementType</span></code> to
<code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant. The arguments to this method <code class="docutils literal notranslate"><span class="pre">args</span></code> are
forwarded to <a href="#id31"><span class="problematic" id="id32">``</span></a>ForceElementType`’s constructor.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">args</span></code>:</dt><dd><p>Zero or more parameters provided to the constructor of the new
force element. It must be the case that
<cite>ForceElementType&lt;T&gt;(args)`</cite> is a valid constructor.</p>
</dd>
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">ForceElementType</span></code>:</dt><dd><p>The type of the ForceElement to add. As there is always a
UniformGravityFieldElement present (accessible through
gravity_field()), an exception will be thrown if this function is
called to add another UniformGravityFieldElement.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A constant reference to the new ForceElement just added, of type
<code class="docutils literal notranslate"><span class="pre">ForceElementType&lt;T&gt;</span></code> specialized on the scalar type T of
<code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant. It will remain valid for the lifetime of
<code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>The ForceElement class’s documentation for further details on how
a force element is defined.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.AddFrame">
<span class="sig-name descname"><span class="pre">AddFrame</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame" title="pydrake.multibody.tree.Frame"><span class="pre">pydrake.multibody.tree.Frame</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame" title="pydrake.multibody.tree.Frame"><span class="pre">pydrake.multibody.tree.Frame</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.AddFrame" title="Link to this definition"></a></dt>
<dd><p>This method adds a Frame of type <code class="docutils literal notranslate"><span class="pre">FrameType&lt;T&gt;</span></code>. For more
information, please see the corresponding constructor of
<code class="docutils literal notranslate"><span class="pre">FrameType</span></code>.</p>
<dl class="simple">
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">FrameType</span></code>:</dt><dd><p>Template which will be instantiated on <code class="docutils literal notranslate"><span class="pre">T</span></code>.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame</span></code>:</dt><dd><p>Unique pointer frame instance.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A constant reference to the new Frame just added, which will
remain valid for the lifetime of <code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.AddJoint">
<span class="sig-name descname"><span class="pre">AddJoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">joint</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Joint" title="pydrake.multibody.tree.Joint"><span class="pre">pydrake.multibody.tree.Joint</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Joint" title="pydrake.multibody.tree.Joint"><span class="pre">pydrake.multibody.tree.Joint</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.AddJoint" title="Link to this definition"></a></dt>
<dd><p>This method adds a Joint of type <code class="docutils literal notranslate"><span class="pre">JointType</span></code> between two bodies. For
more information, see the below overload of <code class="docutils literal notranslate"><span class="pre">AddJoint&lt;&gt;</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.AddJointActuator">
<span class="sig-name descname"><span class="pre">AddJointActuator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">joint</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Joint" title="pydrake.multibody.tree.Joint"><span class="pre">pydrake.multibody.tree.Joint</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">effort_limit</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">inf</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JointActuator" title="pydrake.multibody.tree.JointActuator"><span class="pre">pydrake.multibody.tree.JointActuator</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.AddJointActuator" title="Link to this definition"></a></dt>
<dd><p>Creates and adds a JointActuator model for an actuator acting on a
given <code class="docutils literal notranslate"><span class="pre">joint</span></code>. This method returns a constant reference to the
actuator just added, which will remain valid for the lifetime of
<code class="docutils literal notranslate"><span class="pre">this</span></code> plant.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">name</span></code>:</dt><dd><p>A string that uniquely identifies the new actuator to be added to
<code class="docutils literal notranslate"><span class="pre">this</span></code> model. A RuntimeError is thrown if an actuator with the
same name already exists in the model. See
HasJointActuatorNamed().</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">joint</span></code>:</dt><dd><p>The Joint to be actuated by the new JointActuator.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">effort_limit</span></code>:</dt><dd><p>The maximum effort for the actuator. It must be strictly positive,
otherwise an RuntimeError is thrown. If +∞, the actuator has no
limit, which is the default. The effort limit has physical units
in accordance to the joint type it actuates. For instance, it will
have units of N⋅m (torque) for revolute joints while it will have
units of N (force) for prismatic joints.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The effort limit is unused by MultibodyPlant and is simply
provided here for bookkeeping purposes. It will not, for instance,
saturate external actuation inputs based on this value. If, for
example, a user intends to saturate the force/torque that is
applied to the MultibodyPlant via this actuator, the user-level
code (e.g., a controller) should query this effort limit and
impose the saturation there.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A constant reference to the new JointActuator just added, which
will remain valid for the lifetime of <code class="docutils literal notranslate"><span class="pre">this</span></code> plant or until the
JointActuator has been removed from the plant with
RemoveJointActuator().</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>RuntimeError if joint.num_velocities</strong><strong>(</strong><strong>) </strong><strong>&gt; 1 since for now we</strong> – </p></li>
<li><p><strong>only support actuators for single dof joints.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>RemoveJointActuator()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.AddModelInstance">
<span class="sig-name descname"><span class="pre">AddModelInstance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.AddModelInstance" title="Link to this definition"></a></dt>
<dd><p>Creates a new model instance. Returns the index for the model
instance.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">name</span></code>:</dt><dd><p>A string that uniquely identifies the new instance to be added to
<code class="docutils literal notranslate"><span class="pre">this</span></code> model. An exception is thrown if an instance with the
same name already exists in the model. See
HasModelInstanceNamed().</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.AddRigidBody">
<span class="sig-name descname"><span class="pre">AddRigidBody</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.AddRigidBody" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>AddRigidBody(self: pydrake.multibody.plant.MultibodyPlant, name: str, M_BBo_B: pydrake.multibody.tree.SpatialInertia = SpatialInertia.Zero()) -&gt; pydrake.multibody.tree.RigidBody</p></li>
</ol>
<p>Creates a rigid body with the provided name and spatial inertia. This
method returns a constant reference to the body just added, which will
remain valid for the lifetime of <code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant. The body
will use the default model instance (model_instance “more on model
instances”).</p>
<p>Example of usage:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">plant</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// ... Code to define spatial_inertia, a SpatialInertia&lt;T&gt; object ...</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">RigidBody</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">body</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="n">plant</span><span class="p">.</span><span class="n">AddRigidBody</span><span class="p">(</span><span class="s">&quot;BodyName&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">spatial_inertia</span><span class="p">);</span>
</pre></div>
</div>
</details><dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">name</span></code>:</dt><dd><p>A string that identifies the new body to be added to <code class="docutils literal notranslate"><span class="pre">this</span></code>
model. A RuntimeError is thrown if a body named <code class="docutils literal notranslate"><span class="pre">name</span></code> already
is part of the model in the default model instance. See
HasBodyNamed(), RigidBody::name().</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">M_BBo_B</span></code>:</dt><dd><p>The SpatialInertia of the new rigid body to be added to <code class="docutils literal notranslate"><span class="pre">this</span></code>
MultibodyPlant, computed about the body frame origin <code class="docutils literal notranslate"><span class="pre">Bo</span></code> and
expressed in the body frame B. When not provided, defaults to
zero.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A constant reference to the new RigidBody just added, which will
remain valid for the lifetime of <code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>RuntimeError if additional model instances have been created</strong> – </p></li>
<li><p><strong>beyond the world and default instances.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>AddRigidBody(self: pydrake.multibody.plant.MultibodyPlant, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex, M_BBo_B: pydrake.multibody.tree.SpatialInertia = SpatialInertia.Zero()) -&gt; pydrake.multibody.tree.RigidBody</p></li>
</ol>
<p>Creates a rigid body with the provided name and spatial inertia. This
method returns a constant reference to the body just added, which will
remain valid for the lifetime of <code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant.</p>
<p>Example of usage:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">plant</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// ... Code to define spatial_inertia, a SpatialInertia&lt;T&gt; object ...</span>
<span class="w">  </span><span class="n">ModelInstanceIndex</span><span class="w"> </span><span class="n">model_instance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">plant</span><span class="p">.</span><span class="n">AddModelInstance</span><span class="p">(</span><span class="s">&quot;instance&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">RigidBody</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">body</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="n">plant</span><span class="p">.</span><span class="n">AddRigidBody</span><span class="p">(</span><span class="s">&quot;BodyName&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">model_instance</span><span class="p">,</span><span class="w"> </span><span class="n">spatial_inertia</span><span class="p">);</span>
</pre></div>
</div>
</details><dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">name</span></code>:</dt><dd><p>A string that identifies the new body to be added to <code class="docutils literal notranslate"><span class="pre">this</span></code>
model. A RuntimeError is thrown if a body named <code class="docutils literal notranslate"><span class="pre">name</span></code> already
is part of <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>. See HasBodyNamed(),
RigidBody::name().</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>:</dt><dd><p>A model instance index which this body is part of.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">M_BBo_B</span></code>:</dt><dd><p>The SpatialInertia of the new rigid body to be added to <code class="docutils literal notranslate"><span class="pre">this</span></code>
MultibodyPlant, computed about the body frame origin <code class="docutils literal notranslate"><span class="pre">Bo</span></code> and
expressed in the body frame B. When not provided, defaults to
zero.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A constant reference to the new RigidBody just added, which will
remain valid for the lifetime of <code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.AddWeldConstraint">
<span class="sig-name descname"><span class="pre">AddWeldConstraint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">body_A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody" title="pydrake.multibody.tree.RigidBody"><span class="pre">pydrake.multibody.tree.RigidBody</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">X_AP</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.math.html#pydrake.math.RigidTransform" title="pydrake.math.RigidTransform"><span class="pre">pydrake.math.RigidTransform</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">body_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody" title="pydrake.multibody.tree.RigidBody"><span class="pre">pydrake.multibody.tree.RigidBody</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">X_BQ</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.math.html#pydrake.math.RigidTransform" title="pydrake.math.RigidTransform"><span class="pre">pydrake.math.RigidTransform</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.MultibodyConstraintId" title="pydrake.multibody.tree.MultibodyConstraintId"><span class="pre">pydrake.multibody.tree.MultibodyConstraintId</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.AddWeldConstraint" title="Link to this definition"></a></dt>
<dd><p>Defines a constraint such that frame P affixed to body A is coincident
at all times with frame Q affixed to body B, effectively modeling a
weld joint.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body_A</span></code>:</dt><dd><p>RigidBody to which frame P is rigidly attached.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">X_AP</span></code>:</dt><dd><p>Pose of frame P in body A’s frame.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body_B</span></code>:</dt><dd><p>RigidBody to which frame Q is rigidly attached.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">X_BQ</span></code>:</dt><dd><p>Pose of frame Q in body B’s frame.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>the id of the newly added constraint.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>RuntimeError if bodies A and B are the same body.</strong> – </p></li>
<li><p><strong>RuntimeError if the MultibodyPlant has already been finalized.</strong> – </p></li>
<li><p><strong>RuntimeError if this MultibodyPlant is not a discrete model</strong> – </p></li>
<li><p><strong>(</strong><strong>is_discrete</strong><strong>(</strong><strong>) </strong><strong>== false</strong><strong>)</strong> – </p></li>
<li><p><strong>RuntimeError if this MultibodyPlant's underlying contact</strong> – </p></li>
<li><p><strong>solver is not SAP.</strong><strong> (</strong><strong>i.e. get_discrete_contact_solver</strong><strong>(</strong><strong>) </strong><strong>!=</strong> – </p></li>
<li><p><strong>DiscreteContactSolver::kSap</strong><strong>)</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.CalcBiasCenterOfMassTranslationalAcceleration">
<span class="sig-name descname"><span class="pre">CalcBiasCenterOfMassTranslationalAcceleration</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.CalcBiasCenterOfMassTranslationalAcceleration" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>CalcBiasCenterOfMassTranslationalAcceleration(self: pydrake.multibody.plant.MultibodyPlant, context: pydrake.systems.framework.Context, with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_A: pydrake.multibody.tree.Frame, frame_E: pydrake.multibody.tree.Frame) -&gt; numpy.ndarray[numpy.float64[3, 1]]</p></li>
</ol>
<p>For the system S of all bodies other than the world body, calculates
a𝑠Bias_AScm_E, Scm’s translational acceleration bias in frame A with
respect to “speeds” 𝑠, expressed in frame E, where Scm is the center
of mass of S and speeds 𝑠 is either q̇ or v.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>Contains the state of the multibody system.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">with_respect_to</span></code>:</dt><dd><p>Enum equal to JacobianWrtVariable::kQDot or
JacobianWrtVariable::kV, indicating whether the accceleration bias
is with respect to 𝑠 = q̇ or 𝑠 = v. Currently, an exception is
thrown if with_respect_to is JacobianWrtVariable::kQDot.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_A</span></code>:</dt><dd><p>The frame in which a𝑠Bias_AScm is measured.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_E</span></code>:</dt><dd><p>The frame in which a𝑠Bias_AScm is expressed on output.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a𝑠Bias_AScm_E Point Scm’s translational acceleration bias in frame
A with respect to speeds 𝑠 (𝑠 = q̇ or 𝑠 = v), expressed in frame
E.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>RuntimeError if this has no body except world_body</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p></li>
<li><p><strong>RuntimeError if mₛ ≤ 0</strong><strong>, </strong><strong>where mₛ is the mass</strong><strong> of </strong><strong>system S.</strong> – </p></li>
<li><p><strong>RuntimeError if with_respect_to is JacobianWrtVariable::kQDot.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcJacobianCenterOfMassTranslationalVelocity() to compute
J𝑠_v_Scm, point Scm’s translational velocity Jacobian in frame A
with respect to 𝑠.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The world_body() is ignored. asBias_AScm_E = ∑ (mᵢ aᵢ) / mₛ, where
mₛ = ∑ mᵢ is the mass of system S, mᵢ is the mass of the iᵗʰ body,
and aᵢ is the translational bias acceleration of Bᵢcm in frame A
expressed in frame E for speeds 𝑠 (Bᵢcm is the center of mass of
the iᵗʰ body).</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>See bias_acceleration_functions “Bias acceleration functions” for
theory and details.</p>
</div>
<ol class="arabic simple" start="2">
<li><p>CalcBiasCenterOfMassTranslationalAcceleration(self: pydrake.multibody.plant.MultibodyPlant, context: pydrake.systems.framework.Context, model_instances: list[pydrake.multibody.tree.ModelInstanceIndex], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_A: pydrake.multibody.tree.Frame, frame_E: pydrake.multibody.tree.Frame) -&gt; numpy.ndarray[numpy.float64[3, 1]]</p></li>
</ol>
<p>For the system S containing the selected model instances, calculates
a𝑠Bias_AScm_E, Scm’s translational acceleration bias in frame A with
respect to “speeds” 𝑠, expressed in frame E, where Scm is the center
of mass of S and speeds 𝑠 is either q̇ or v.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>Contains the state of the multibody system.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">model_instances</span></code>:</dt><dd><p>Vector of selected model instances. If a model instance is
repeated in the vector (unusual), it is only counted once.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">with_respect_to</span></code>:</dt><dd><p>Enum equal to JacobianWrtVariable::kQDot or
JacobianWrtVariable::kV, indicating whether the accceleration bias
is with respect to 𝑠 = q̇ or 𝑠 = v. Currently, an exception is
thrown if with_respect_to is JacobianWrtVariable::kQDot.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_A</span></code>:</dt><dd><p>The frame in which a𝑠Bias_AScm is measured.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_E</span></code>:</dt><dd><p>The frame in which a𝑠Bias_AScm is expressed on output.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a𝑠Bias_AScm_E Point Scm’s translational acceleration bias in frame
A with respect to speeds 𝑠 (𝑠 = q̇ or 𝑠 = v), expressed in frame
E.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>RuntimeError if this has no body except world_body</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p></li>
<li><p><strong>RuntimeError if mₛ ≤ 0</strong><strong>, </strong><strong>where mₛ is the mass</strong><strong> of </strong><strong>system S.</strong> – </p></li>
<li><p><strong>RuntimeError if with_respect_to is JacobianWrtVariable::kQDot.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcJacobianCenterOfMassTranslationalVelocity() to compute
J𝑠_v_Scm, point Scm’s translational velocity Jacobian in frame A
with respect to 𝑠.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The world_body() is ignored. asBias_AScm_E = ∑ (mᵢ aᵢ) / mₛ, where
mₛ = ∑ mᵢ is the mass of system S, mᵢ is the mass of the iᵗʰ body,
and aᵢ is the translational bias acceleration of Bᵢcm in frame A
expressed in frame E for speeds 𝑠 (Bᵢcm is the center of mass of
the iᵗʰ body).</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>See bias_acceleration_functions “Bias acceleration functions” for
theory and details.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.CalcBiasSpatialAcceleration">
<span class="sig-name descname"><span class="pre">CalcBiasSpatialAcceleration</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context" title="pydrake.systems.framework.Context"><span class="pre">pydrake.systems.framework.Context</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_respect_to</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JacobianWrtVariable" title="pydrake.multibody.tree.JacobianWrtVariable"><span class="pre">pydrake.multibody.tree.JacobianWrtVariable</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame" title="pydrake.multibody.tree.Frame"><span class="pre">pydrake.multibody.tree.Frame</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_BoBp_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame" title="pydrake.multibody.tree.Frame"><span class="pre">pydrake.multibody.tree.Frame</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_E</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame" title="pydrake.multibody.tree.Frame"><span class="pre">pydrake.multibody.tree.Frame</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.math.html#pydrake.multibody.math.SpatialAcceleration" title="pydrake.multibody.math.SpatialAcceleration"><span class="pre">pydrake.multibody.math.SpatialAcceleration</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.CalcBiasSpatialAcceleration" title="Link to this definition"></a></dt>
<dd><p>For one point Bp affixed/welded to a frame B, calculates A𝑠Bias_ABp,
Bp’s spatial acceleration bias in frame A with respect to “speeds” 𝑠,
expressed in frame E, where speeds 𝑠 is either q̇ or v.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>Contains the state of the multibody system.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">with_respect_to</span></code>:</dt><dd><p>Enum equal to JacobianWrtVariable::kQDot or
JacobianWrtVariable::kV, indicating whether the spatial
accceleration bias is with respect to 𝑠 = q̇ or 𝑠 = v. Currently,
an exception is thrown if with_respect_to is
JacobianWrtVariable::kQDot.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_B</span></code>:</dt><dd><p>The frame on which point Bp is affixed/welded.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BoBp_B</span></code>:</dt><dd><p>Position vector from Bo (frame_B’s origin) to point Bp (regarded
as affixed/welded to B), expressed in frame_B.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_A</span></code>:</dt><dd><p>The frame in which A𝑠Bias_ABp is measured.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_E</span></code>:</dt><dd><p>The frame in which A𝑠Bias_ABp is expressed on output.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A𝑠Bias_ABp_E Point Bp’s spatial acceleration bias in frame A with
respect to speeds 𝑠 (𝑠 = q̇ or 𝑠 = v), expressed in frame E.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcJacobianSpatialVelocity() to compute J𝑠_V_ABp, point Bp’s
spatial velocity Jacobian in frame A with respect to 𝑠.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if with_respect_to is JacobianWrtVariable::kQDot.</strong> – </p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Use CalcBiasTranslationalAcceleration() to efficiently calculate
bias translational accelerations for a list of points (each fixed
to frame B). This function returns only one bias spatial
acceleration, which contains both frame B’s bias angular
acceleration and point Bp’s bias translational acceleration.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>See bias_acceleration_functions “Bias acceleration functions” for
theory and details.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.CalcBiasTerm">
<span class="sig-name descname"><span class="pre">CalcBiasTerm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context" title="pydrake.systems.framework.Context"><span class="pre">pydrake.systems.framework.Context</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.CalcBiasTerm" title="Link to this definition"></a></dt>
<dd><p>Computes the bias term <code class="docutils literal notranslate"><span class="pre">C(q,</span> <span class="pre">v)</span> <span class="pre">v</span></code> containing Coriolis, centripetal,
and gyroscopic effects in the multibody equations of motion:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">M</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="w"> </span><span class="n">v</span><span class="err">̇</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">C</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tau_app</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="err">∑</span><span class="w"> </span><span class="p">(</span><span class="n">Jv_V_WBᵀ</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="w"> </span><span class="err">⋅</span><span class="w"> </span><span class="n">Fapp_Bo_W</span><span class="p">)</span>
</pre></div>
</div>
</details><p>where <code class="docutils literal notranslate"><span class="pre">M(q)</span></code> is the multibody model’s mass matrix (including rigid
body mass properties and reflected_inertia “reflected inertias”) and
<code class="docutils literal notranslate"><span class="pre">tau_app</span></code> is a vector of applied generalized forces. The last term
is a summation over all bodies of the dot-product of <code class="docutils literal notranslate"><span class="pre">Fapp_Bo_W</span></code>
(applied spatial force on body B at Bo) with <code class="docutils literal notranslate"><span class="pre">Jv_V_WB(q)</span></code> (B’s
spatial Jacobian in world W with respect to generalized velocities v).
Note: B’s spatial velocity in W can be written <code class="docutils literal notranslate"><span class="pre">V_WB</span> <span class="pre">=</span> <span class="pre">Jv_V_WB</span> <span class="pre">*</span> <span class="pre">v</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>Contains the state of the multibody system, including the
generalized positions q and the generalized velocities v.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">Cv</span></code>:</dt><dd><p>On output, <code class="docutils literal notranslate"><span class="pre">Cv</span></code> will contain the product <code class="docutils literal notranslate"><span class="pre">C(q,</span> <span class="pre">v)v</span></code>. It must
be a valid (non-null) pointer to a column vector in <code class="docutils literal notranslate"><span class="pre">ℛⁿ</span></code> with n
the number of generalized velocities (num_velocities()) of the
model. This method aborts if Cv is nullptr or if it does not have
the proper size.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.CalcBiasTranslationalAcceleration">
<span class="sig-name descname"><span class="pre">CalcBiasTranslationalAcceleration</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context" title="pydrake.systems.framework.Context"><span class="pre">pydrake.systems.framework.Context</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_respect_to</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JacobianWrtVariable" title="pydrake.multibody.tree.JacobianWrtVariable"><span class="pre">pydrake.multibody.tree.JacobianWrtVariable</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame" title="pydrake.multibody.tree.Frame"><span class="pre">pydrake.multibody.tree.Frame</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_BoBi_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.f_contiguous</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame" title="pydrake.multibody.tree.Frame"><span class="pre">pydrake.multibody.tree.Frame</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_E</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame" title="pydrake.multibody.tree.Frame"><span class="pre">pydrake.multibody.tree.Frame</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.CalcBiasTranslationalAcceleration" title="Link to this definition"></a></dt>
<dd><p>For each point Bi affixed/welded to a frame B, calculates a𝑠Bias_ABi,
Bi’s translational acceleration bias in frame A with respect to
“speeds” 𝑠, expressed in frame E, where speeds 𝑠 is either q̇ or v.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>Contains the state of the multibody system.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">with_respect_to</span></code>:</dt><dd><p>Enum equal to JacobianWrtVariable::kQDot or
JacobianWrtVariable::kV, indicating whether the translational
acceleration bias is with respect to 𝑠 = q̇ or 𝑠 = v. Currently,
an exception is thrown if with_respect_to is
JacobianWrtVariable::kQDot.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_B</span></code>:</dt><dd><p>The frame on which points Bi are affixed/welded.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BoBi_B</span></code>:</dt><dd><p>A position vector or list of p position vectors from Bo (frame_B’s
origin) to points Bi (regarded as affixed to B), where each
position vector is expressed in frame_B. Each column in the <code class="docutils literal notranslate"><span class="pre">3</span> <span class="pre">x</span>
<span class="pre">p</span></code> matrix p_BoBi_B corresponds to a position vector.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_A</span></code>:</dt><dd><p>The frame in which a𝑠Bias_ABi is measured.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_E</span></code>:</dt><dd><p>The frame in which a𝑠Bias_ABi is expressed on output.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a𝑠Bias_ABi_E Point Bi’s translational acceleration bias in frame A
with respect to speeds 𝑠 (𝑠 = q̇ or 𝑠 = v), expressed in frame E.
a𝑠Bias_ABi_E is a <code class="docutils literal notranslate"><span class="pre">3</span> <span class="pre">x</span> <span class="pre">p</span></code> matrix, where p is the number of
points Bi.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcJacobianTranslationalVelocity() to compute J𝑠_v_ABi, point
Bi’s translational velocity Jacobian in frame A with respect to 𝑠.</p>
</div>
<dl class="simple">
<dt>Precondition:</dt><dd><p>p_BoBi_B must have 3 rows.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if with_respect_to is JacobianWrtVariable::kQDot.</strong> – </p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>See bias_acceleration_functions “Bias acceleration functions” for
theory and details.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.CalcCenterOfMassPositionInWorld">
<span class="sig-name descname"><span class="pre">CalcCenterOfMassPositionInWorld</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.CalcCenterOfMassPositionInWorld" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>CalcCenterOfMassPositionInWorld(self: pydrake.multibody.plant.MultibodyPlant, context: pydrake.systems.framework.Context) -&gt; numpy.ndarray[numpy.float64[3, 1]]</p></li>
</ol>
<p>Calculates the position vector from the world origin Wo to the center
of mass of all bodies in this MultibodyPlant, expressed in the world
frame W.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>Contains the state of the model.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">p_WoScm_W</span></code>:</dt><dd><p>position vector from Wo to Scm expressed in world frame W, where
Scm is the center of mass of the system S stored by <code class="docutils literal notranslate"><span class="pre">this</span></code>
plant.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if this has no body except world_body</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p></li>
<li><p><strong>RuntimeError if mₛ ≤ 0</strong><strong> (</strong><strong>where mₛ is the mass</strong><strong> of </strong><strong>system S</strong><strong>)</strong><strong>.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The world_body() is ignored. p_WoScm_W = ∑ (mᵢ pᵢ) / mₛ, where mₛ
= ∑ mᵢ, mᵢ is the mass of the iᵗʰ body, and pᵢ is Bᵢcm’s position
from Wo expressed in frame W (Bᵢcm is the center of mass of the
iᵗʰ body).</p>
</div>
<ol class="arabic simple" start="2">
<li><p>CalcCenterOfMassPositionInWorld(self: pydrake.multibody.plant.MultibodyPlant, context: pydrake.systems.framework.Context, model_instances: list[pydrake.multibody.tree.ModelInstanceIndex]) -&gt; numpy.ndarray[numpy.float64[3, 1]]</p></li>
</ol>
<p>Calculates the position vector from the world origin Wo to the center
of mass of all non-world bodies contained in model_instances,
expressed in the world frame W.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>Contains the state of the model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">model_instances</span></code>:</dt><dd><p>Vector of selected model instances. If a model instance is
repeated in the vector (unusual), it is only counted once.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">p_WoScm_W</span></code>:</dt><dd><p>position vector from world origin Wo to Scm expressed in the world
frame W, where Scm is the center of mass of the system S of
non-world bodies contained in model_instances.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if model_instances is empty</strong><strong> or </strong><strong>only has world body.</strong> – </p></li>
<li><p><strong>RuntimeError if mₛ ≤ 0</strong><strong> (</strong><strong>where mₛ is the mass</strong><strong> of </strong><strong>system S</strong><strong>)</strong><strong>.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The world_body() is ignored. p_WoScm_W = ∑ (mᵢ pᵢ) / mₛ, where mₛ
= ∑ mᵢ, mᵢ is the mass of the iᵗʰ body contained in
model_instances, and pᵢ is Bᵢcm’s position vector from Wo
expressed in frame W (Bᵢcm is the center of mass of the iᵗʰ body).</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.CalcCenterOfMassTranslationalAccelerationInWorld">
<span class="sig-name descname"><span class="pre">CalcCenterOfMassTranslationalAccelerationInWorld</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.CalcCenterOfMassTranslationalAccelerationInWorld" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>CalcCenterOfMassTranslationalAccelerationInWorld(self: pydrake.multibody.plant.MultibodyPlant, context: pydrake.systems.framework.Context) -&gt; numpy.ndarray[numpy.float64[3, 1]]</p></li>
</ol>
<p>For the system S contained in this MultibodyPlant, calculates Scm’s
translational acceleration in the world frame W expressed in W, where
Scm is the center of mass of S.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context contains the state of the model.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">a_WScm_W</span></code>:</dt><dd><p>Scm’s translational acceleration in the world frame W expressed in
the world frame W.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if this has no body except world_body</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p></li>
<li><p><strong>RuntimeError if mₛ ≤ 0</strong><strong>, </strong><strong>where mₛ is the mass</strong><strong> of </strong><strong>system S.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The world_body() is ignored. a_WScm_W = ∑ (mᵢ aᵢ) / mₛ, where mₛ =
∑ mᵢ is the mass of system S, mᵢ is the mass of the iᵗʰ body, and
aᵢ is the translational acceleration of Bᵢcm in world W expressed
in W (Bᵢcm is the center of mass of the iᵗʰ body).</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When cached values are out of sync with the state stored in
context, this method performs an expensive forward dynamics
computation, whereas once evaluated, successive calls to this
method are inexpensive.</p>
</div>
<ol class="arabic simple" start="2">
<li><p>CalcCenterOfMassTranslationalAccelerationInWorld(self: pydrake.multibody.plant.MultibodyPlant, context: pydrake.systems.framework.Context, model_instances: list[pydrake.multibody.tree.ModelInstanceIndex]) -&gt; numpy.ndarray[numpy.float64[3, 1]]</p></li>
</ol>
<p>For the system S containing the selected model instances, calculates
Scm’s translational acceleration in the world frame W expressed in W,
where Scm is the center of mass of S.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context contains the state of the model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">model_instances</span></code>:</dt><dd><p>Vector of selected model instances. If a model instance is
repeated in the vector (unusual), it is only counted once.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">a_WScm_W</span></code>:</dt><dd><p>Scm’s translational acceleration in the world frame W expressed in
the world frame W.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if model_instances is empty</strong><strong> or </strong><strong>only has world body.</strong> – </p></li>
<li><p><strong>RuntimeError if mₛ ≤ 0</strong><strong>, </strong><strong>where mₛ is the mass</strong><strong> of </strong><strong>system S.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The world_body() is ignored. a_WScm_W = ∑ (mᵢ aᵢ) / mₛ, where mₛ =
∑ mᵢ is the mass of system S, mᵢ is the mass of the iᵗʰ body in
model_instances, and aᵢ is the translational acceleration of Bᵢcm
in world W expressed in W (Bᵢcm is the center of mass of the iᵗʰ
body).</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When cached values are out of sync with the state stored in
context, this method performs an expensive forward dynamics
computation, whereas once evaluated, successive calls to this
method are inexpensive.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.CalcCenterOfMassTranslationalVelocityInWorld">
<span class="sig-name descname"><span class="pre">CalcCenterOfMassTranslationalVelocityInWorld</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.CalcCenterOfMassTranslationalVelocityInWorld" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>CalcCenterOfMassTranslationalVelocityInWorld(self: pydrake.multibody.plant.MultibodyPlant, context: pydrake.systems.framework.Context) -&gt; numpy.ndarray[numpy.float64[3, 1]]</p></li>
</ol>
<p>Calculates system center of mass translational velocity in world frame
W.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context contains the state of the model.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">v_WScm_W</span></code>:</dt><dd><p>Scm’s translational velocity in frame W, expressed in W, where Scm
is the center of mass of the system S stored by <code class="docutils literal notranslate"><span class="pre">this</span></code> plant.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if this has no body except world_body</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p></li>
<li><p><strong>RuntimeError if mₛ ≤ 0</strong><strong> (</strong><strong>where mₛ is the mass</strong><strong> of </strong><strong>system S</strong><strong>)</strong><strong>.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The world_body() is ignored. v_WScm_W = ∑ (mᵢ vᵢ) / mₛ, where mₛ =
∑ mᵢ, mᵢ is the mass of the iᵗʰ body, and vᵢ is Bᵢcm’s velocity in
world W (Bᵢcm is the center of mass of the iᵗʰ body).</p>
</div>
<ol class="arabic simple" start="2">
<li><p>CalcCenterOfMassTranslationalVelocityInWorld(self: pydrake.multibody.plant.MultibodyPlant, context: pydrake.systems.framework.Context, model_instances: list[pydrake.multibody.tree.ModelInstanceIndex]) -&gt; numpy.ndarray[numpy.float64[3, 1]]</p></li>
</ol>
<p>Calculates system center of mass translational velocity in world frame
W.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context contains the state of the model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">model_instances</span></code>:</dt><dd><p>Vector of selected model instances. If a model instance is
repeated in the vector (unusual), it is only counted once.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">v_WScm_W</span></code>:</dt><dd><p>Scm’s translational velocity in frame W, expressed in W, where Scm
is the center of mass of the system S of non-world bodies
contained in model_instances.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if model_instances is empty</strong><strong> or </strong><strong>only has world body.</strong> – </p></li>
<li><p><strong>RuntimeError if mₛ ≤ 0</strong><strong> (</strong><strong>where mₛ is the mass</strong><strong> of </strong><strong>system S</strong><strong>)</strong><strong>.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The world_body() is ignored. v_WScm_W = ∑ (mᵢ vᵢ) / mₛ, where mₛ =
∑ mᵢ, mᵢ is the mass of the iᵗʰ body contained in model_instances,
and vᵢ is Bᵢcm’s velocity in world W expressed in frame W (Bᵢcm is
the center of mass of the iᵗʰ body).</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.CalcForceElementsContribution">
<span class="sig-name descname"><span class="pre">CalcForceElementsContribution</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context" title="pydrake.systems.framework.Context"><span class="pre">pydrake.systems.framework.Context</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">forces</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.MultibodyForces" title="pydrake.multibody.tree.MultibodyForces"><span class="pre">pydrake.multibody.tree.MultibodyForces</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.CalcForceElementsContribution" title="Link to this definition"></a></dt>
<dd><p>Computes the combined force contribution of ForceElement objects in
the model. A ForceElement can apply forces as a spatial force per body
or as generalized forces, depending on the ForceElement model.
ForceElement contributions are a function of the state and time only.
The output from this method can immediately be used as input to
CalcInverseDynamics() to include the effect of applied forces by force
elements.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context containing the state of this model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">forces</span></code>:</dt><dd><p>A pointer to a valid, non nullptr, multibody forces object. On
output <code class="docutils literal notranslate"><span class="pre">forces</span></code> will store the forces exerted by all the
ForceElement objects in the model.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if forces is null</strong><strong> or </strong><strong>not compatible with this</strong> – </p></li>
<li><p><strong>model</strong><strong>, </strong><strong>per MultibodyForces::CheckInvariants</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.CalcGeneralizedForces">
<span class="sig-name descname"><span class="pre">CalcGeneralizedForces</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context" title="pydrake.systems.framework.Context"><span class="pre">pydrake.systems.framework.Context</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">forces</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.MultibodyForces" title="pydrake.multibody.tree.MultibodyForces"><span class="pre">pydrake.multibody.tree.MultibodyForces</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.CalcGeneralizedForces" title="Link to this definition"></a></dt>
<dd><p>Computes the generalized forces result of a set of MultibodyForces
applied to this model.</p>
<p>MultibodyForces stores applied forces as both generalized forces τ and
spatial forces F on each body, refer to documentation in
MultibodyForces for details. Users of MultibodyForces will use
MultibodyForces::mutable_generalized_forces() to mutate the stored
generalized forces directly and will use
RigidBody::AddInForceInWorld() to append spatial forces.</p>
<p>For a given set of forces stored as MultibodyForces, this method will
compute the total generalized forces on this model. More precisely, if
J_WBo is the Jacobian (with respect to velocities) for this model,
including all bodies, then this method computes:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">τᵣₑₛᵤₗₜ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">τ</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">J_WBo</span><span class="err">⋅</span><span class="n">F</span>
</pre></div>
</div>
</details><dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>Context that stores the state of the model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">forces</span></code>:</dt><dd><p>Set of multibody forces, including both generalized forces and
per-body spatial forces.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">generalized_forces</span></code>:</dt><dd><p>The total generalized forces on the model that would result from
applying <code class="docutils literal notranslate"><span class="pre">forces</span></code>. In other words, <code class="docutils literal notranslate"><span class="pre">forces</span></code> can be replaced by
the equivalent <code class="docutils literal notranslate"><span class="pre">generalized_forces</span></code>. On output,
<code class="docutils literal notranslate"><span class="pre">generalized_forces</span></code> is resized to num_velocities().</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if forces is null</strong><strong> or </strong><strong>not compatible with this</strong> – </p></li>
<li><p><strong>model.</strong> – </p></li>
<li><p><strong>RuntimeError if generalized_forces is not a valid non-null</strong> – </p></li>
<li><p><strong>pointer.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.CalcGravityGeneralizedForces">
<span class="sig-name descname"><span class="pre">CalcGravityGeneralizedForces</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context" title="pydrake.systems.framework.Context"><span class="pre">pydrake.systems.framework.Context</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.CalcGravityGeneralizedForces" title="Link to this definition"></a></dt>
<dd><p>Computes the generalized forces <code class="docutils literal notranslate"><span class="pre">tau_g(q)</span></code> due to gravity as a
function of the generalized positions <code class="docutils literal notranslate"><span class="pre">q</span></code> stored in the input
<code class="docutils literal notranslate"><span class="pre">context</span></code>. The vector of generalized forces due to gravity
<code class="docutils literal notranslate"><span class="pre">tau_g(q)</span></code> is defined such that it appears on the right hand side of
the equations of motion together with any other generalized forces,
like so:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Mv</span><span class="err">̇</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">C</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tau_g</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">tau_app</span>
</pre></div>
</div>
</details><p>where <code class="docutils literal notranslate"><span class="pre">tau_app</span></code> includes any other generalized forces applied on the
system.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context storing the state of the model.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>tau_g A vector containing the generalized forces due to gravity.
The generalized forces are consistent with the vector of
generalized velocities <code class="docutils literal notranslate"><span class="pre">v</span></code> for <code class="docutils literal notranslate"><span class="pre">this</span></code> so that the inner
product <code class="docutils literal notranslate"><span class="pre">v⋅tau_g</span></code> corresponds to the power applied by the
gravity forces on the mechanical system. That is, <code class="docutils literal notranslate"><span class="pre">v⋅tau_g</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>
corresponds to potential energy going into the system, as either
mechanical kinetic energy, some other potential energy, or heat,
and therefore to a decrease of the gravitational potential energy.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.CalcInverseDynamics">
<span class="sig-name descname"><span class="pre">CalcInverseDynamics</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context" title="pydrake.systems.framework.Context"><span class="pre">pydrake.systems.framework.Context</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">known_vdot</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">external_forces</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.MultibodyForces" title="pydrake.multibody.tree.MultibodyForces"><span class="pre">pydrake.multibody.tree.MultibodyForces</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.CalcInverseDynamics" title="Link to this definition"></a></dt>
<dd><p>Given the state of this model in <code class="docutils literal notranslate"><span class="pre">context</span></code> and a known vector of
generalized accelerations <code class="docutils literal notranslate"><span class="pre">vdot</span></code>, this method computes the set of
generalized forces <code class="docutils literal notranslate"><span class="pre">tau</span></code> that would need to be applied in order to
attain the specified generalized accelerations. Mathematically, this
method computes:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">tau</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">M</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="n">v</span><span class="err">̇</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">C</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="n">v</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">tau_app</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="err">∑</span><span class="w"> </span><span class="n">J_WBᵀ</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="w"> </span><span class="n">Fapp_Bo_W</span>
</pre></div>
</div>
</details><p>where <code class="docutils literal notranslate"><span class="pre">M(q)</span></code> is the model’s mass matrix (including rigid body mass
properties and reflected_inertia “reflected inertias”), <code class="docutils literal notranslate"><span class="pre">C(q,</span> <span class="pre">v)v</span></code>
is the bias term for Coriolis and gyroscopic effects and <code class="docutils literal notranslate"><span class="pre">tau_app</span></code>
consists of a vector applied generalized forces. The last term is a
summation over all bodies in the model where <code class="docutils literal notranslate"><span class="pre">Fapp_Bo_W</span></code> is an
applied spatial force on body B at <code class="docutils literal notranslate"><span class="pre">Bo</span></code> which gets projected into
the space of generalized forces with the transpose of <code class="docutils literal notranslate"><span class="pre">Jv_V_WB(q)</span></code>
(where <code class="docutils literal notranslate"><span class="pre">Jv_V_WB</span></code> is B’s spatial velocity Jacobian in W with respect
to generalized velocities v). Note: B’s spatial velocity in W can be
written as <code class="docutils literal notranslate"><span class="pre">V_WB</span> <span class="pre">=</span> <span class="pre">Jv_V_WB</span> <span class="pre">*</span> <span class="pre">v</span></code>.</p>
<p>This method does not compute explicit expressions for the mass matrix
nor for the bias term, which would be of at least <code class="docutils literal notranslate"><span class="pre">O(n²)</span></code>
complexity, but it implements an <code class="docutils literal notranslate"><span class="pre">O(n)</span></code> Newton-Euler recursive
algorithm, where n is the number of bodies in the model. The explicit
formation of the mass matrix <code class="docutils literal notranslate"><span class="pre">M(q)</span></code> would require the calculation of
<code class="docutils literal notranslate"><span class="pre">O(n²)</span></code> entries while explicitly forming the product <code class="docutils literal notranslate"><span class="pre">C(q,</span> <span class="pre">v)</span> <span class="pre">*</span> <span class="pre">v</span></code>
could require up to <code class="docutils literal notranslate"><span class="pre">O(n³)</span></code> operations (see [Featherstone 1987,
§4]), depending on the implementation. The recursive Newton-Euler
algorithm is the most efficient currently known general method for
solving inverse dynamics [Featherstone 2008].</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context containing the state of the model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">known_vdot</span></code>:</dt><dd><p>A vector with the known generalized accelerations <code class="docutils literal notranslate"><span class="pre">vdot</span></code> for the
full model. Use the provided Joint APIs in order to access entries
into this array.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">external_forces</span></code>:</dt><dd><p>A set of forces to be applied to the system either as body spatial
forces <code class="docutils literal notranslate"><span class="pre">Fapp_Bo_W</span></code> or generalized forces <code class="docutils literal notranslate"><span class="pre">tau_app</span></code>, see
MultibodyForces for details.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>the vector of generalized forces that would need to be applied to
the mechanical system in order to achieve the desired acceleration
given by <code class="docutils literal notranslate"><span class="pre">known_vdot</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.CalcJacobianAngularVelocity">
<span class="sig-name descname"><span class="pre">CalcJacobianAngularVelocity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context" title="pydrake.systems.framework.Context"><span class="pre">pydrake.systems.framework.Context</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_respect_to</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JacobianWrtVariable" title="pydrake.multibody.tree.JacobianWrtVariable"><span class="pre">pydrake.multibody.tree.JacobianWrtVariable</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame" title="pydrake.multibody.tree.Frame"><span class="pre">pydrake.multibody.tree.Frame</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame" title="pydrake.multibody.tree.Frame"><span class="pre">pydrake.multibody.tree.Frame</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_E</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame" title="pydrake.multibody.tree.Frame"><span class="pre">pydrake.multibody.tree.Frame</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.CalcJacobianAngularVelocity" title="Link to this definition"></a></dt>
<dd><p>Calculates J𝑠_w_AB, a frame B’s angular velocity Jacobian in a frame A
with respect to “speeds” 𝑠.</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">J𝑠_w_AB</span><span class="w"> </span><span class="err">≜</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="err">∂</span><span class="p">(</span><span class="n">w_AB</span><span class="p">)</span><span class="o">/</span><span class="err">∂</span><span class="n">𝑠₁</span><span class="p">,</span><span class="w">  </span><span class="p">...</span><span class="w">  </span><span class="err">∂</span><span class="p">(</span><span class="n">w_AB</span><span class="p">)</span><span class="o">/</span><span class="err">∂</span><span class="n">𝑠ₙ</span><span class="w"> </span><span class="p">]</span><span class="w">    </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="k">or</span><span class="w"> </span><span class="n">k</span><span class="p">)</span>
<span class="w">     </span><span class="n">w_AB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">J𝑠_w_AB</span><span class="w"> </span><span class="err">⋅</span><span class="w"> </span><span class="n">𝑠</span><span class="w">          </span><span class="n">w_AB</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">linear</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">𝑠</span><span class="w"> </span><span class="err">≜</span><span class="w"> </span><span class="p">[</span><span class="n">𝑠₁</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="n">𝑠ₙ</span><span class="p">]</span><span class="n">ᵀ</span>
</pre></div>
</div>
</details><p><code class="docutils literal notranslate"><span class="pre">w_AB</span></code> is B’s angular velocity in frame A and “speeds” 𝑠 is either
q̇ ≜ [q̇₁ … q̇ⱼ]ᵀ (time-derivatives of j generalized positions) or v
≜ [v₁ … vₖ]ᵀ (k generalized velocities).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The state of the multibody system.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">with_respect_to</span></code>:</dt><dd><p>Enum equal to JacobianWrtVariable::kQDot or
JacobianWrtVariable::kV, indicating whether the Jacobian
<code class="docutils literal notranslate"><span class="pre">J𝑠_w_AB</span></code> is partial derivatives with respect to 𝑠 = q̇
(time-derivatives of generalized positions) or with respect to 𝑠 =
v (generalized velocities).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_B</span></code>:</dt><dd><p>The frame B in <code class="docutils literal notranslate"><span class="pre">w_AB</span></code> (B’s angular velocity in A).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_A</span></code>:</dt><dd><p>The frame A in <code class="docutils literal notranslate"><span class="pre">w_AB</span></code> (B’s angular velocity in A).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_E</span></code>:</dt><dd><p>The frame in which <code class="docutils literal notranslate"><span class="pre">w_AB</span></code> is expressed on input and the frame in
which the Jacobian <code class="docutils literal notranslate"><span class="pre">J𝑠_w_AB</span></code> is expressed on output.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">Js_w_AB_E</span></code>:</dt><dd><p>Frame B’s angular velocity Jacobian in frame A with respect to
speeds 𝑠 (which is either q̇ or v), expressed in frame E. The
Jacobian is a function of only generalized positions q (which are
pulled from the context). The previous definition shows
<code class="docutils literal notranslate"><span class="pre">J𝑠_w_AB_E</span></code> is a matrix of size <code class="docutils literal notranslate"><span class="pre">3</span> <span class="pre">x</span> <span class="pre">n</span></code>, where n is the number
of elements in 𝑠.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>See Jacobian_functions “Jacobian functions” for related functions.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if J𝑠_w_AB_E is nullptr</strong><strong> or </strong><strong>not</strong><strong> of </strong><strong>size 3 x n.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.CalcJacobianCenterOfMassTranslationalVelocity">
<span class="sig-name descname"><span class="pre">CalcJacobianCenterOfMassTranslationalVelocity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.CalcJacobianCenterOfMassTranslationalVelocity" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>CalcJacobianCenterOfMassTranslationalVelocity(self: pydrake.multibody.plant.MultibodyPlant, context: pydrake.systems.framework.Context, with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_A: pydrake.multibody.tree.Frame, frame_E: pydrake.multibody.tree.Frame) -&gt; numpy.ndarray[numpy.float64[3, n]]</p></li>
</ol>
<p>Calculates J𝑠_v_AScm_E, point Scm’s translational velocity Jacobian in
frame A with respect to “speeds” 𝑠, expressed in frame E, where point
Scm is the center of mass of the system S of all non-world bodies
contained in <code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>contains the state of the model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">with_respect_to</span></code>:</dt><dd><p>Enum equal to JacobianWrtVariable::kQDot or
JacobianWrtVariable::kV, indicating whether the Jacobian
<code class="docutils literal notranslate"><span class="pre">J𝑠_v_AScm_E</span></code> is partial derivatives with respect to 𝑠 = q̇
(time-derivatives of generalized positions) or with respect to 𝑠 =
v (generalized velocities).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_A</span></code>:</dt><dd><p>The frame in which the translational velocity v_AScm and its
Jacobian J𝑠_v_AScm are measured.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_E</span></code>:</dt><dd><p>The frame in which the Jacobian J𝑠_v_AScm is expressed on output.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">Js_v_AScm_E</span></code>:</dt><dd><p>Point Scm’s translational velocity Jacobian in frame A with
respect to speeds 𝑠 (𝑠 = q̇ or 𝑠 = v), expressed in frame E.
J𝑠_v_AScm_E is a 3 x n matrix, where n is the number of elements
in 𝑠. The Jacobian is a function of only generalized positions q
(which are pulled from the context).</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if Scm does not exist</strong><strong>, </strong><strong>which occurs if there are no</strong> – </p></li>
<li><p><strong>massive bodies in MultibodyPlant</strong><strong> (</strong><strong>except world_body</strong><strong>(</strong><strong>)</strong><strong>)</strong><strong>.</strong> – </p></li>
<li><p><strong>RuntimeError if mₛ ≤ 0</strong><strong> (</strong><strong>where mₛ is the mass</strong><strong> of </strong><strong>all non-world</strong> – </p></li>
<li><p><strong>bodies contained in this MultibodyPlant</strong><strong>)</strong><strong>.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>See Jacobian_functions “Jacobian functions” for related functions.</p>
</div>
<ol class="arabic simple" start="2">
<li><p>CalcJacobianCenterOfMassTranslationalVelocity(self: pydrake.multibody.plant.MultibodyPlant, context: pydrake.systems.framework.Context, model_instances: list[pydrake.multibody.tree.ModelInstanceIndex], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_A: pydrake.multibody.tree.Frame, frame_E: pydrake.multibody.tree.Frame) -&gt; numpy.ndarray[numpy.float64[3, n]]</p></li>
</ol>
<p>Calculates J𝑠_v_AScm_E, point Scm’s translational velocity Jacobian in
frame A with respect to “speeds” 𝑠, expressed in frame E, where point
Scm is the center of mass of the system S of all non-world bodies
contained in model_instances.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>contains the state of the model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">model_instances</span></code>:</dt><dd><p>Vector of selected model instances. If a model instance is
repeated in the vector (unusual), it is only counted once.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">with_respect_to</span></code>:</dt><dd><p>Enum equal to JacobianWrtVariable::kQDot or
JacobianWrtVariable::kV, indicating whether the Jacobian
<code class="docutils literal notranslate"><span class="pre">J𝑠_v_AScm_E</span></code> is partial derivatives with respect to 𝑠 = q̇
(time-derivatives of generalized positions) or with respect to 𝑠 =
v (generalized velocities).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_A</span></code>:</dt><dd><p>The frame in which the translational velocity v_AScm and its
Jacobian J𝑠_v_AScm are measured.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_E</span></code>:</dt><dd><p>The frame in which the Jacobian J𝑠_v_AScm is expressed on output.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">Js_v_AScm_E</span></code>:</dt><dd><p>Point Scm’s translational velocity Jacobian in frame A with
respect to speeds 𝑠 (𝑠 = q̇ or 𝑠 = v), expressed in frame E.
J𝑠_v_AScm_E is a 3 x n matrix, where n is the number of elements
in 𝑠. The Jacobian is a function of only generalized positions q
(which are pulled from the context).</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if mₛ ≤ 0</strong><strong> (</strong><strong>where mₛ is the mass</strong><strong> of </strong><strong>all non-world</strong> – </p></li>
<li><p><strong>bodies contained in model_instances</strong><strong>)</strong><strong>.</strong> – </p></li>
<li><p><strong>RuntimeError if model_instances is empty</strong><strong> or </strong><strong>only has world body.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The world_body() is ignored. <a href="#id155"><span class="problematic" id="id156">J𝑠_v_AScm_</span></a> = ∑ (mᵢ Jᵢ) / mₛ, where mₛ
= ∑ mᵢ, mᵢ is the mass of the iᵗʰ body contained in
model_instances, and Jᵢ is Bᵢcm’s translational velocity Jacobian
in frame A, expressed in frame E (Bᵢcm is the center of mass of
the iᵗʰ body).</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>See Jacobian_functions “Jacobian functions” for related functions.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.CalcJacobianPositionVector">
<span class="sig-name descname"><span class="pre">CalcJacobianPositionVector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context" title="pydrake.systems.framework.Context"><span class="pre">pydrake.systems.framework.Context</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame" title="pydrake.multibody.tree.Frame"><span class="pre">pydrake.multibody.tree.Frame</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_BoBi_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.f_contiguous</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame" title="pydrake.multibody.tree.Frame"><span class="pre">pydrake.multibody.tree.Frame</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_E</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame" title="pydrake.multibody.tree.Frame"><span class="pre">pydrake.multibody.tree.Frame</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.CalcJacobianPositionVector" title="Link to this definition"></a></dt>
<dd><p>For each point Bi affixed/welded to a frame B, calculates Jq_p_AoBi,
Bi’s position vector Jacobian in frame A with respect to the
generalized positions q ≜ [q₁ … qₙ]ᵀ as</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Jq_p_AoBi</span><span class="w"> </span><span class="err">≜</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="n">ᴬ</span><span class="err">∂</span><span class="p">(</span><span class="n">p_AoBi</span><span class="p">)</span><span class="o">/</span><span class="err">∂</span><span class="n">q₁</span><span class="p">,</span><span class="w">  </span><span class="p">...</span><span class="w">  </span><span class="n">ᴬ</span><span class="err">∂</span><span class="p">(</span><span class="n">p_AoBi</span><span class="p">)</span><span class="o">/</span><span class="err">∂</span><span class="n">qₙ</span><span class="w"> </span><span class="p">]</span>
</pre></div>
</div>
</details><p>where p_AoBi is Bi’s position vector from point Ao (frame A’s origin)
and ᴬ∂(p_AoBi)/∂qᵣ denotes the partial derivative in frame A of p_AoBi
with respect to the generalized position qᵣ, where qᵣ is one of q₁ …
qₙ.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The state of the multibody system.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_B</span></code>:</dt><dd><p>The frame on which point Bi is affixed/welded.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BoBi_B</span></code>:</dt><dd><p>A position vector or list of k position vectors from Bo (frame_B’s
origin) to points Bi (Bi is regarded as affixed to B), where each
position vector is expressed in frame_B.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_A</span></code>:</dt><dd><p>The frame in which partial derivatives are calculated and the
frame in which point Ao is affixed.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_E</span></code>:</dt><dd><p>The frame in which the Jacobian Jq_p_AoBi is expressed on output.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">Jq_p_AoBi_E</span></code>:</dt><dd><p>Point Bi’s position vector Jacobian in frame A with generalized
positions q, expressed in frame E. Jq_p_AoBi_E is a <code class="docutils literal notranslate"><span class="pre">3*k</span> <span class="pre">x</span> <span class="pre">n</span></code>
matrix, where k is the number of points Bi and n is the number of
elements in q. The Jacobian is a function of only generalized
positions q (which are pulled from the context).</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if Jq_p_AoBi_E is nullptr</strong><strong> or </strong><strong>not sized 3*k x n.</strong> – </p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Jq̇_v_ABi = Jq_p_AoBi. In other words, point Bi’s velocity
Jacobian in frame A with respect to q̇ is equal to point Bi’s
position vector Jacobian in frame A with respect to q.</p>
</div>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="err">∂</span><span class="p">(</span><span class="n">v_ABi</span><span class="p">)</span><span class="o">/</span><span class="err">∂</span><span class="n">q</span><span class="err">̇</span><span class="n">₁</span><span class="p">,</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="err">∂</span><span class="p">(</span><span class="n">v_ABi</span><span class="p">)</span><span class="o">/</span><span class="err">∂</span><span class="n">q</span><span class="err">̇</span><span class="n">ₙ</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">ᴬ</span><span class="err">∂</span><span class="p">(</span><span class="n">p_AoBi</span><span class="p">)</span><span class="o">/</span><span class="err">∂</span><span class="n">q₁</span><span class="p">,</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="n">ᴬ</span><span class="err">∂</span><span class="p">(</span><span class="n">p_AoBi</span><span class="p">)</span><span class="o">/</span><span class="err">∂</span><span class="n">qₙ</span><span class="p">]</span>
</pre></div>
</div>
</details><div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcJacobianTranslationalVelocity() for details on Jq̇_v_ABi.
Note: Jq_p_AaBi = Jq_p_AoBi, where point Aa is <em>any</em> point
fixed/welded to frame A, i.e., this calculation’s result is the
same if point Ao is replaced with any point fixed on frame A.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>See Jacobian_functions “Jacobian functions” for related functions.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.CalcJacobianSpatialVelocity">
<span class="sig-name descname"><span class="pre">CalcJacobianSpatialVelocity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context" title="pydrake.systems.framework.Context"><span class="pre">pydrake.systems.framework.Context</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_respect_to</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JacobianWrtVariable" title="pydrake.multibody.tree.JacobianWrtVariable"><span class="pre">pydrake.multibody.tree.JacobianWrtVariable</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame" title="pydrake.multibody.tree.Frame"><span class="pre">pydrake.multibody.tree.Frame</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_BoBp_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame" title="pydrake.multibody.tree.Frame"><span class="pre">pydrake.multibody.tree.Frame</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_E</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame" title="pydrake.multibody.tree.Frame"><span class="pre">pydrake.multibody.tree.Frame</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.CalcJacobianSpatialVelocity" title="Link to this definition"></a></dt>
<dd><p>For one point Bp fixed/welded to a frame B, calculates J𝑠_V_ABp, Bp’s
spatial velocity Jacobian in frame A with respect to “speeds” 𝑠.</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">J𝑠_V_ABp</span><span class="w"> </span><span class="err">≜</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="err">∂</span><span class="p">(</span><span class="n">V_ABp</span><span class="p">)</span><span class="o">/</span><span class="err">∂</span><span class="n">𝑠₁</span><span class="p">,</span><span class="w">  </span><span class="p">...</span><span class="w">  </span><span class="err">∂</span><span class="p">(</span><span class="n">V_ABp</span><span class="p">)</span><span class="o">/</span><span class="err">∂</span><span class="n">𝑠ₙ</span><span class="w"> </span><span class="p">]</span><span class="w">    </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="k">or</span><span class="w"> </span><span class="n">k</span><span class="p">)</span>
<span class="w">     </span><span class="n">V_ABp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">J𝑠_V_ABp</span><span class="w"> </span><span class="err">⋅</span><span class="w"> </span><span class="n">𝑠</span><span class="w">          </span><span class="n">V_ABp</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">linear</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">𝑠</span><span class="w"> </span><span class="err">≜</span><span class="w"> </span><span class="p">[</span><span class="n">𝑠₁</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="n">𝑠ₙ</span><span class="p">]</span><span class="n">ᵀ</span>
</pre></div>
</div>
</details><p><code class="docutils literal notranslate"><span class="pre">V_ABp</span></code> is Bp’s spatial velocity in frame A and “speeds” 𝑠 is either
q̇ ≜ [q̇₁ … q̇ⱼ]ᵀ (time-derivatives of j generalized positions) or v
≜ [v₁ … vₖ]ᵀ (k generalized velocities).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The state of the multibody system.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">with_respect_to</span></code>:</dt><dd><p>Enum equal to JacobianWrtVariable::kQDot or
JacobianWrtVariable::kV, indicating whether the Jacobian
<code class="docutils literal notranslate"><span class="pre">J𝑠_V_ABp</span></code> is partial derivatives with respect to 𝑠 = q̇
(time-derivatives of generalized positions) or with respect to 𝑠 =
v (generalized velocities).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_B</span></code>:</dt><dd><p>The frame on which point Bp is fixed/welded.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BoBp_B</span></code>:</dt><dd><p>A position vector from Bo (frame_B’s origin) to point Bp (regarded
as fixed/welded to B), expressed in frame_B.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_A</span></code>:</dt><dd><p>The frame that measures <code class="docutils literal notranslate"><span class="pre">v_ABp</span></code> (Bp’s velocity in A). Note: It
is natural to wonder why there is no parameter p_AoAp_A (similar
to the parameter p_BoBp_B for frame_B). There is no need for
p_AoAp_A because Bp’s velocity in A is defined as the derivative
in frame A of Bp’s position vector from <em>any</em> point fixed to A.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_E</span></code>:</dt><dd><p>The frame in which <code class="docutils literal notranslate"><span class="pre">v_ABp</span></code> is expressed on input and the frame
in which the Jacobian <code class="docutils literal notranslate"><span class="pre">J𝑠_V_ABp</span></code> is expressed on output.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">Js_V_ABp_E</span></code>:</dt><dd><p>Point Bp’s spatial velocity Jacobian in frame A with respect to
speeds 𝑠 (which is either q̇ or v), expressed in frame E.
<code class="docutils literal notranslate"><span class="pre">J𝑠_V_ABp_E</span></code> is a <code class="docutils literal notranslate"><span class="pre">6</span> <span class="pre">x</span> <span class="pre">n</span></code> matrix, where n is the number of
elements in 𝑠. The Jacobian is a function of only generalized
positions q (which are pulled from the context).</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The returned <code class="docutils literal notranslate"><span class="pre">6</span> <span class="pre">x</span> <span class="pre">n</span></code> matrix stores frame B’s angular velocity
Jacobian in A in rows 1-3 and stores point Bp’s translational
velocity Jacobian in A in rows 4-6, i.e.,</p>
</div>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">J𝑠_w_AB_E</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">J𝑠_V_ABp_E</span><span class="p">.</span><span class="n">topRows</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">();</span>
<span class="w">    </span><span class="n">J𝑠_v_ABp_E</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">J𝑠_V_ABp_E</span><span class="p">.</span><span class="n">bottomRows</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">();</span>
</pre></div>
</div>
</details><div class="admonition note">
<p class="admonition-title">Note</p>
<p>Consider CalcJacobianTranslationalVelocity() for multiple points
fixed to frame B and consider CalcJacobianAngularVelocity() to
calculate frame B’s angular velocity Jacobian.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>See Jacobian_functions “Jacobian functions” for related functions.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if J𝑠_V_ABp_E is nullptr</strong><strong> or </strong><strong>not sized 6 x n.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.CalcJacobianTranslationalVelocity">
<span class="sig-name descname"><span class="pre">CalcJacobianTranslationalVelocity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context" title="pydrake.systems.framework.Context"><span class="pre">pydrake.systems.framework.Context</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_respect_to</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JacobianWrtVariable" title="pydrake.multibody.tree.JacobianWrtVariable"><span class="pre">pydrake.multibody.tree.JacobianWrtVariable</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame" title="pydrake.multibody.tree.Frame"><span class="pre">pydrake.multibody.tree.Frame</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_BoBi_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.f_contiguous</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame" title="pydrake.multibody.tree.Frame"><span class="pre">pydrake.multibody.tree.Frame</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_E</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame" title="pydrake.multibody.tree.Frame"><span class="pre">pydrake.multibody.tree.Frame</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.CalcJacobianTranslationalVelocity" title="Link to this definition"></a></dt>
<dd><p>For each point Bi affixed/welded to a frame B, calculates J𝑠_v_ABi,
Bi’s translational velocity Jacobian in frame A with respect to
“speeds” 𝑠.</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">J𝑠_v_ABi</span><span class="w"> </span><span class="err">≜</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="err">∂</span><span class="p">(</span><span class="n">v_ABi</span><span class="p">)</span><span class="o">/</span><span class="err">∂</span><span class="n">𝑠₁</span><span class="p">,</span><span class="w">  </span><span class="p">...</span><span class="w">  </span><span class="err">∂</span><span class="p">(</span><span class="n">v_ABi</span><span class="p">)</span><span class="o">/</span><span class="err">∂</span><span class="n">𝑠ₙ</span><span class="w"> </span><span class="p">]</span><span class="w">    </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="k">or</span><span class="w"> </span><span class="n">k</span><span class="p">)</span>
<span class="w">     </span><span class="n">v_ABi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">J𝑠_v_ABi</span><span class="w"> </span><span class="err">⋅</span><span class="w"> </span><span class="n">𝑠</span><span class="w">          </span><span class="n">v_ABi</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">linear</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">𝑠</span><span class="w"> </span><span class="err">≜</span><span class="w"> </span><span class="p">[</span><span class="n">𝑠₁</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="n">𝑠ₙ</span><span class="p">]</span><span class="n">ᵀ</span>
</pre></div>
</div>
</details><p><code class="docutils literal notranslate"><span class="pre">v_ABi</span></code> is Bi’s translational velocity in frame A and “speeds” 𝑠 is
either q̇ ≜ [q̇₁ … q̇ⱼ]ᵀ (time-derivatives of j generalized
positions) or v ≜ [v₁ … vₖ]ᵀ (k generalized velocities).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The state of the multibody system.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">with_respect_to</span></code>:</dt><dd><p>Enum equal to JacobianWrtVariable::kQDot or
JacobianWrtVariable::kV, indicating whether the Jacobian
<code class="docutils literal notranslate"><span class="pre">J𝑠_v_ABi</span></code> is partial derivatives with respect to 𝑠 = q̇
(time-derivatives of generalized positions) or with respect to 𝑠 =
v (generalized velocities).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_B</span></code>:</dt><dd><p>The frame on which point Bi is affixed/welded.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BoBi_B</span></code>:</dt><dd><p>A position vector or list of p position vectors from Bo (frame_B’s
origin) to points Bi (regarded as affixed to B), where each
position vector is expressed in frame_B.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_A</span></code>:</dt><dd><p>The frame that measures <code class="docutils literal notranslate"><span class="pre">v_ABi</span></code> (Bi’s velocity in A). Note: It
is natural to wonder why there is no parameter p_AoAi_A (similar
to the parameter p_BoBi_B for frame_B). There is no need for
p_AoAi_A because Bi’s velocity in A is defined as the derivative
in frame A of Bi’s position vector from <em>any</em> point affixed to A.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_E</span></code>:</dt><dd><p>The frame in which <code class="docutils literal notranslate"><span class="pre">v_ABi</span></code> is expressed on input and the frame
in which the Jacobian <code class="docutils literal notranslate"><span class="pre">J𝑠_v_ABi</span></code> is expressed on output.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">Js_v_ABi_E</span></code>:</dt><dd><p>Point Bi’s velocity Jacobian in frame A with respect to speeds 𝑠
(which is either q̇ or v), expressed in frame E. <code class="docutils literal notranslate"><span class="pre">J𝑠_v_ABi_E</span></code> is
a <code class="docutils literal notranslate"><span class="pre">3*p</span> <span class="pre">x</span> <span class="pre">n</span></code> matrix, where p is the number of points Bi and n is
the number of elements in 𝑠. The Jacobian is a function of only
generalized positions q (which are pulled from the context).</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if J𝑠_v_ABi_E is nullptr</strong><strong> or </strong><strong>not sized ``3*p x</strong> – </p></li>
<li><p><strong>n``.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When 𝑠 = q̇, <code class="docutils literal notranslate"><span class="pre">Jq̇_v_ABi</span> <span class="pre">=</span> <span class="pre">Jq_p_AoBi</span></code>. In other words, point Bi’s
velocity Jacobian in frame A with respect to q̇ is equal to point
Bi’s position Jacobian from Ao (A’s origin) in frame A with
respect to q.</p>
</div>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="err">∂</span><span class="p">(</span><span class="n">v_ABi</span><span class="p">)</span><span class="o">/</span><span class="err">∂</span><span class="n">q</span><span class="err">̇</span><span class="n">₁</span><span class="p">,</span><span class="w">  </span><span class="p">...</span><span class="w">  </span><span class="err">∂</span><span class="p">(</span><span class="n">v_ABi</span><span class="p">)</span><span class="o">/</span><span class="err">∂</span><span class="n">q</span><span class="err">̇</span><span class="n">ⱼ</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="err">∂</span><span class="p">(</span><span class="n">p_AoBi</span><span class="p">)</span><span class="o">/</span><span class="err">∂</span><span class="n">q₁</span><span class="p">,</span><span class="w">  </span><span class="p">...</span><span class="w">  </span><span class="err">∂</span><span class="p">(</span><span class="n">p_AoBi</span><span class="p">)</span><span class="o">/</span><span class="err">∂</span><span class="n">qⱼ</span><span class="p">]</span>
</pre></div>
</div>
</details><p>Note: Each partial derivative of p_AoBi is taken in frame A.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcJacobianPositionVector() for details on Jq_p_AoBi.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>See Jacobian_functions “Jacobian functions” for related functions.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.CalcMassMatrix">
<span class="sig-name descname"><span class="pre">CalcMassMatrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context" title="pydrake.systems.framework.Context"><span class="pre">pydrake.systems.framework.Context</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.CalcMassMatrix" title="Link to this definition"></a></dt>
<dd><p>Efficiently computes the mass matrix <code class="docutils literal notranslate"><span class="pre">M(q)</span></code> of the model. The
generalized positions q are taken from the given <code class="docutils literal notranslate"><span class="pre">context</span></code>. M
includes the mass properties of rigid bodies and reflected_inertia
“reflected inertias” as provided with JointActuator specifications.</p>
<p>This method employs the Composite Body Algorithm, which we believe to
be the fastest O(n²) algorithm to compute the mass matrix of a
multibody system.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The Context containing the state of the model from which
generalized coordinates q are extracted.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">M</span></code>:</dt><dd><p>A pointer to a square matrix in <code class="docutils literal notranslate"><span class="pre">ℛⁿˣⁿ</span></code> with n the number of
generalized velocities (num_velocities()) of the model. Although
symmetric, the matrix is filled in completely on return.</p>
</dd>
<dt>Precondition:</dt><dd><p>M is non-null and has the right size.</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This is an O(n²) algorithm. Avoid the explicit computation of the
mass matrix whenever possible.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcMassMatrixViaInverseDynamics() (slower)</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.CalcMassMatrixViaInverseDynamics">
<span class="sig-name descname"><span class="pre">CalcMassMatrixViaInverseDynamics</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context" title="pydrake.systems.framework.Context"><span class="pre">pydrake.systems.framework.Context</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.CalcMassMatrixViaInverseDynamics" title="Link to this definition"></a></dt>
<dd><p>Computes the mass matrix <code class="docutils literal notranslate"><span class="pre">M(q)</span></code> of the model using a slow method
(inverse dynamics). The generalized positions q are taken from the
given <code class="docutils literal notranslate"><span class="pre">context</span></code>. M includes the mass properties of rigid bodies and
reflected_inertia “reflected inertias” as provided with JointActuator
specifications.</p>
<p>Use CalcMassMatrix() for a faster implementation using the Composite
Body Algorithm.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The Context containing the state of the model from which
generalized coordinates q are extracted.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">M</span></code>:</dt><dd><p>A pointer to a square matrix in <code class="docutils literal notranslate"><span class="pre">ℛⁿˣⁿ</span></code> with n the number of
generalized velocities (num_velocities()) of the model. Although
symmetric, the matrix is filled in completely on return.</p>
</dd>
<dt>Precondition:</dt><dd><p>M is non-null and has the right size.</p>
</dd>
</dl>
<p>The algorithm used to build <code class="docutils literal notranslate"><span class="pre">M(q)</span></code> consists in computing one column
of <code class="docutils literal notranslate"><span class="pre">M(q)</span></code> at a time using inverse dynamics. The result from inverse
dynamics, with no applied forces, is the vector of generalized forces:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">tau</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">M</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="n">v</span><span class="err">̇</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">C</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="n">v</span>
</pre></div>
</div>
</details><p>where q and v are the generalized positions and velocities,
respectively. When <code class="docutils literal notranslate"><span class="pre">v</span> <span class="pre">=</span> <span class="pre">0</span></code> the Coriolis and gyroscopic forces term
<code class="docutils literal notranslate"><span class="pre">C(q,</span> <span class="pre">v)v</span></code> is zero. Therefore the <code class="docutils literal notranslate"><span class="pre">i-th</span></code> column of <code class="docutils literal notranslate"><span class="pre">M(q)</span></code> can be
obtained performing inverse dynamics with an acceleration vector <code class="docutils literal notranslate"><span class="pre">v̇</span>
<span class="pre">=</span> <span class="pre">eᵢ</span></code>, with <code class="docutils literal notranslate"><span class="pre">eᵢ</span></code> the standard (or natural) basis of <code class="docutils literal notranslate"><span class="pre">ℛⁿ</span></code> with n
the number of generalized velocities. We write this as:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">M</span><span class="p">.</span><span class="n">ᵢ</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">M</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">e_i</span>
</pre></div>
</div>
</details><p>where <code class="docutils literal notranslate"><span class="pre">M.ᵢ(q)</span></code> (notice the dot for the rows index) denotes the
<code class="docutils literal notranslate"><span class="pre">i-th</span></code> column in M(q).</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This is an O(n²) algorithm. Avoid the explicit computation of the
mass matrix whenever possible.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcMassMatrix(), CalcInverseDynamics()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.CalcPointsPositions">
<span class="sig-name descname"><span class="pre">CalcPointsPositions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context" title="pydrake.systems.framework.Context"><span class="pre">pydrake.systems.framework.Context</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame" title="pydrake.multibody.tree.Frame"><span class="pre">pydrake.multibody.tree.Frame</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_BQi</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.f_contiguous</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame" title="pydrake.multibody.tree.Frame"><span class="pre">pydrake.multibody.tree.Frame</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.CalcPointsPositions" title="Link to this definition"></a></dt>
<dd><p>Given the positions <code class="docutils literal notranslate"><span class="pre">p_BQi</span></code> for a set of points <code class="docutils literal notranslate"><span class="pre">Qi</span></code> measured and
expressed in a frame B, this method computes the positions
<code class="docutils literal notranslate"><span class="pre">p_AQi(q)</span></code> of each point <code class="docutils literal notranslate"><span class="pre">Qi</span></code> in the set as measured and expressed
in another frame A, as a function of the generalized positions q of
the model.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context containing the state of the model. It stores the
generalized positions q of the model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_B</span></code>:</dt><dd><p>The frame B in which the positions <code class="docutils literal notranslate"><span class="pre">p_BQi</span></code> of a set of points
<code class="docutils literal notranslate"><span class="pre">Qi</span></code> are given.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BQi</span></code>:</dt><dd><p>The input positions of each point <code class="docutils literal notranslate"><span class="pre">Qi</span></code> in frame B. <code class="docutils literal notranslate"><span class="pre">p_BQi</span> <span class="pre">∈</span>
<span class="pre">ℝ³ˣⁿᵖ</span></code> with <code class="docutils literal notranslate"><span class="pre">np</span></code> the number of points in the set. Each column
of <code class="docutils literal notranslate"><span class="pre">p_BQi</span></code> corresponds to a vector in ℝ³ holding the position of
one of the points in the set as measured and expressed in frame B.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_A</span></code>:</dt><dd><p>The frame A in which it is desired to compute the positions
<code class="docutils literal notranslate"><span class="pre">p_AQi</span></code> of each point <code class="docutils literal notranslate"><span class="pre">Qi</span></code> in the set.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_AQi</span></code>:</dt><dd><p>The output positions of each point <code class="docutils literal notranslate"><span class="pre">Qi</span></code> now computed as measured
and expressed in frame A. The output <code class="docutils literal notranslate"><span class="pre">p_AQi</span></code> <strong>must</strong> have the
same size as the input <code class="docutils literal notranslate"><span class="pre">p_BQi</span></code> or otherwise this method aborts.
That is <code class="docutils literal notranslate"><span class="pre">p_AQi</span></code> <strong>must</strong> be in <code class="docutils literal notranslate"><span class="pre">ℝ³ˣⁿᵖ</span></code>.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Both <code class="docutils literal notranslate"><span class="pre">p_BQi</span></code> and <code class="docutils literal notranslate"><span class="pre">p_AQi</span></code> must have three rows. Otherwise this
method will throw a RuntimeError. This method also throws a
RuntimeError if <code class="docutils literal notranslate"><span class="pre">p_BQi</span></code> and <code class="docutils literal notranslate"><span class="pre">p_AQi</span></code> differ in the number of
columns.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.CalcRelativeRotationMatrix">
<span class="sig-name descname"><span class="pre">CalcRelativeRotationMatrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context" title="pydrake.systems.framework.Context"><span class="pre">pydrake.systems.framework.Context</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame" title="pydrake.multibody.tree.Frame"><span class="pre">pydrake.multibody.tree.Frame</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame" title="pydrake.multibody.tree.Frame"><span class="pre">pydrake.multibody.tree.Frame</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.math.html#pydrake.math.RotationMatrix" title="pydrake.math.RotationMatrix"><span class="pre">pydrake.math.RotationMatrix</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.CalcRelativeRotationMatrix" title="Link to this definition"></a></dt>
<dd><p>Calculates the rotation matrix <code class="docutils literal notranslate"><span class="pre">R_AB</span></code> relating frame A and frame B.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The state of the multibody system, which includes the system’s
generalized positions q. Note: <code class="docutils literal notranslate"><span class="pre">R_AB</span></code> is a function of q.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_A</span></code>:</dt><dd><p>The frame A designated in the rigid transform <code class="docutils literal notranslate"><span class="pre">R_AB</span></code>.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_B</span></code>:</dt><dd><p>The frame G designated in the rigid transform <code class="docutils literal notranslate"><span class="pre">R_AB</span></code>.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">R_AB</span></code>:</dt><dd><p>The RigidTransform relating frame A and frame B.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.CalcRelativeTransform">
<span class="sig-name descname"><span class="pre">CalcRelativeTransform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context" title="pydrake.systems.framework.Context"><span class="pre">pydrake.systems.framework.Context</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame" title="pydrake.multibody.tree.Frame"><span class="pre">pydrake.multibody.tree.Frame</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame" title="pydrake.multibody.tree.Frame"><span class="pre">pydrake.multibody.tree.Frame</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.math.html#pydrake.math.RigidTransform" title="pydrake.math.RigidTransform"><span class="pre">pydrake.math.RigidTransform</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.CalcRelativeTransform" title="Link to this definition"></a></dt>
<dd><p>Calculates the rigid transform (pose) <code class="docutils literal notranslate"><span class="pre">X_AB</span></code> relating frame A and
frame B.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The state of the multibody system, which includes the system’s
generalized positions q. Note: <code class="docutils literal notranslate"><span class="pre">X_AB</span></code> is a function of q.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_A</span></code>:</dt><dd><p>The frame A designated in the rigid transform <code class="docutils literal notranslate"><span class="pre">X_AB</span></code>.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_B</span></code>:</dt><dd><p>The frame G designated in the rigid transform <code class="docutils literal notranslate"><span class="pre">X_AB</span></code>.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">X_AB</span></code>:</dt><dd><p>The RigidTransform relating frame A and frame B.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.CalcSpatialAccelerationsFromVdot">
<span class="sig-name descname"><span class="pre">CalcSpatialAccelerationsFromVdot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context" title="pydrake.systems.framework.Context"><span class="pre">pydrake.systems.framework.Context</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">known_vdot</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.multibody.math.html#pydrake.multibody.math.SpatialAcceleration" title="pydrake.multibody.math.SpatialAcceleration"><span class="pre">pydrake.multibody.math.SpatialAcceleration</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.CalcSpatialAccelerationsFromVdot" title="Link to this definition"></a></dt>
<dd><p>Given the state of this model in <code class="docutils literal notranslate"><span class="pre">context</span></code> and a known vector of
generalized accelerations <code class="docutils literal notranslate"><span class="pre">known_vdot</span></code>, this method computes the
spatial acceleration <code class="docutils literal notranslate"><span class="pre">A_WB</span></code> for each body as measured and expressed
in the world frame W.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context containing the state of this model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">known_vdot</span></code>:</dt><dd><p>A vector with the generalized accelerations for the full model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">A_WB_array</span></code>:</dt><dd><p>A pointer to a valid, non nullptr, vector of spatial accelerations
containing the spatial acceleration <code class="docutils literal notranslate"><span class="pre">A_WB</span></code> for each body. It
must be of size equal to the number of bodies in the model. On
output, entries will be ordered by BodyIndex.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if A_WB_array is not</strong><strong> of </strong><strong>size num_bodies</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.CalcSpatialInertia">
<span class="sig-name descname"><span class="pre">CalcSpatialInertia</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context" title="pydrake.systems.framework.Context"><span class="pre">pydrake.systems.framework.Context</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_F</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame" title="pydrake.multibody.tree.Frame"><span class="pre">pydrake.multibody.tree.Frame</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">body_indexes</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.BodyIndex" title="pydrake.multibody.tree.BodyIndex"><span class="pre">pydrake.multibody.tree.BodyIndex</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.SpatialInertia" title="pydrake.multibody.tree.SpatialInertia"><span class="pre">pydrake.multibody.tree.SpatialInertia</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.CalcSpatialInertia" title="Link to this definition"></a></dt>
<dd><p>Returns M_SFo_F, the spatial inertia of a set S of bodies about point
Fo (the origin of a frame F), expressed in frame F. You may regard
M_SFo_F as measuring spatial inertia as if the set S of bodies were
welded into a single composite body at the configuration specified in
the <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>Contains the configuration of the set S of bodies.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_F</span></code>:</dt><dd><p>specifies the about-point Fo (frame_F’s origin) and the
expressed-in frame for the returned spatial inertia.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body_indexes</span></code>:</dt><dd><p>Array of selected bodies. This method does not distinguish between
welded bodies, joint-connected bodies, etc.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if body_indexes contains an invalid BodyIndex</strong><strong> or </strong><strong>if</strong> – </p></li>
<li><p><strong>there is a repeated BodyIndex.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The mass and inertia of the world_body() does not contribute to
the the returned spatial inertia.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.CalcSpatialMomentumInWorldAboutPoint">
<span class="sig-name descname"><span class="pre">CalcSpatialMomentumInWorldAboutPoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.CalcSpatialMomentumInWorldAboutPoint" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>CalcSpatialMomentumInWorldAboutPoint(self: pydrake.multibody.plant.MultibodyPlant, context: pydrake.systems.framework.Context, p_WoP_W: numpy.ndarray[numpy.float64[3, 1]]) -&gt; pydrake.multibody.math.SpatialMomentum</p></li>
</ol>
<p>This method returns the spatial momentum of <code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant in
the world frame W, about a designated point P, expressed in the world
frame W.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>Contains the state of the model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_WoP_W</span></code>:</dt><dd><p>Position from Wo (origin of the world frame W) to an arbitrary
point P, expressed in the world frame W.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">L_WSP_W</span></code>:</dt><dd><p>, spatial momentum of the system S represented by <code class="docutils literal notranslate"><span class="pre">this</span></code> plant,
measured in the world frame W, about point P, expressed in W.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>To calculate the spatial momentum of this system S in W about Scm
(the system’s center of mass), use something like:</p>
</div>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">plant</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// ... code to load a model ....</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">Vector3</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">p_WoScm_W</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="n">plant</span><span class="p">.</span><span class="n">CalcCenterOfMassPositionInWorld</span><span class="p">(</span><span class="n">context</span><span class="p">);</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">SpatialMomentum</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">L_WScm_W</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="n">plant</span><span class="p">.</span><span class="n">CalcSpatialMomentumInWorldAboutPoint</span><span class="p">(</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="n">p_WoScm_W</span><span class="p">);</span>
</pre></div>
</div>
</details><ol class="arabic simple" start="2">
<li><p>CalcSpatialMomentumInWorldAboutPoint(self: pydrake.multibody.plant.MultibodyPlant, context: pydrake.systems.framework.Context, model_instances: list[pydrake.multibody.tree.ModelInstanceIndex], p_WoP_W: numpy.ndarray[numpy.float64[3, 1]]) -&gt; pydrake.multibody.math.SpatialMomentum</p></li>
</ol>
<p>This method returns the spatial momentum of a set of model instances
in the world frame W, about a designated point P, expressed in frame
W.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>Contains the state of the model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">model_instances</span></code>:</dt><dd><p>Set of selected model instances.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_WoP_W</span></code>:</dt><dd><p>Position from Wo (origin of the world frame W) to an arbitrary
point P, expressed in the world frame W.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">L_WSP_W</span></code>:</dt><dd><p>, spatial momentum of the system S represented by the
model_instances, measured in world frame W, about point P,
expressed in W.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>To calculate the spatial momentum of this system S in W about Scm
(the system’s center of mass), use something like:</p>
</div>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">plant</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// ... code to create a set of selected model instances, e.g., ...</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">ModelInstanceIndex</span><span class="w"> </span><span class="n">gripper_model_instance</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="n">plant</span><span class="p">.</span><span class="n">GetModelInstanceByName</span><span class="p">(</span><span class="s">&quot;gripper&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">ModelInstanceIndex</span><span class="w"> </span><span class="n">robot_model_instance</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="n">plant</span><span class="p">.</span><span class="n">GetBodyByName</span><span class="p">(</span><span class="s">&quot;end_effector&quot;</span><span class="p">).</span><span class="n">model_instance</span><span class="p">();</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ModelInstanceIndex</span><span class="o">&gt;</span><span class="w"> </span><span class="n">model_instances</span><span class="p">{</span>
<span class="w">    </span><span class="n">gripper_model_instance</span><span class="p">,</span><span class="w"> </span><span class="n">robot_model_instance</span><span class="p">};</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">Vector3</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">p_WoScm_W</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="n">plant</span><span class="p">.</span><span class="n">CalcCenterOfMassPositionInWorld</span><span class="p">(</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="n">model_instances</span><span class="p">);</span>
<span class="w">  </span><span class="n">SpatialMomentum</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">L_WScm_W</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="n">plant</span><span class="p">.</span><span class="n">CalcSpatialMomentumInWorldAboutPoint</span><span class="p">(</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="n">model_instances</span><span class="p">,</span>
<span class="w">                                               </span><span class="n">p_WoScm_W</span><span class="p">);</span>
</pre></div>
</div>
</details><dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if model_instances contains an invalid</strong> – </p></li>
<li><p><strong>ModelInstanceIndex.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.CalcTotalMass">
<span class="sig-name descname"><span class="pre">CalcTotalMass</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.CalcTotalMass" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>CalcTotalMass(self: pydrake.multibody.plant.MultibodyPlant, context: pydrake.systems.framework.Context) -&gt; float</p></li>
</ol>
<p>Calculates the total mass of all bodies in this MultibodyPlant.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>Contains the state of the model.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">The</span></code>:</dt><dd><p>total mass of all bodies or 0 if there are none.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The mass of the world_body() does not contribute to the total
mass.</p>
</div>
<ol class="arabic simple" start="2">
<li><p>CalcTotalMass(self: pydrake.multibody.plant.MultibodyPlant, context: pydrake.systems.framework.Context, model_instances: list[pydrake.multibody.tree.ModelInstanceIndex]) -&gt; float</p></li>
</ol>
<p>Calculates the total mass of all bodies contained in model_instances.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>Contains the state of the model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">model_instances</span></code>:</dt><dd><p>Vector of selected model instances. This method does not
distinguish between welded, joint connected, or floating bodies.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">The</span></code>:</dt><dd><p>total mass of all bodies belonging to a model instance in
model_instances or 0 if model_instances is empty.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The mass of the world_body() does not contribute to the total mass
and each body only contributes to the total mass once, even if the
body has repeated occurrence (instance) in model_instances.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.CollectRegisteredGeometries">
<span class="sig-name descname"><span class="pre">CollectRegisteredGeometries</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">bodies</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody" title="pydrake.multibody.tree.RigidBody"><span class="pre">pydrake.multibody.tree.RigidBody</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.GeometrySet" title="pydrake.geometry.GeometrySet"><span class="pre">pydrake.geometry.GeometrySet</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.CollectRegisteredGeometries" title="Link to this definition"></a></dt>
<dd><p>For each of the provided <code class="docutils literal notranslate"><span class="pre">bodies</span></code>, collects up all geometries that
have been registered to that body. Intended to be used in conjunction
with CollisionFilterDeclaration and CollisionFilterManager::Apply() to
filter collisions between the geometries registered to the bodies.</p>
<p>For example:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Don&#39;t report on collisions between geometries affixed to `body1`,</span>
<span class="c1">// `body2`, or `body3`.</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">RigidBody</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*&gt;</span><span class="w"> </span><span class="n">bodies</span><span class="p">{</span><span class="o">&amp;</span><span class="n">body1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">body2</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">body3</span><span class="p">};</span>
<span class="n">geometry</span><span class="o">::</span><span class="n">GeometrySet</span><span class="w"> </span><span class="n">set</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">plant</span><span class="p">.</span><span class="n">CollectRegisteredGeometries</span><span class="p">(</span><span class="n">bodies</span><span class="p">);</span>
<span class="n">scene_graph</span><span class="p">.</span><span class="n">collision_filter_manager</span><span class="p">().</span><span class="n">Apply</span><span class="p">(</span>
<span class="w">    </span><span class="n">CollisionFilterDeclaration</span><span class="p">().</span><span class="n">ExcludeWithin</span><span class="p">(</span><span class="n">set</span><span class="p">));</span>
</pre></div>
</div>
</details><div class="admonition note">
<p class="admonition-title">Note</p>
<p>There is a <em>very</em> specific order of operations:</p>
</div>
<ol class="arabic simple">
<li><p>Bodies and geometries must be added to the MultibodyPlant.</p></li>
<li><p>Create GeometrySet instances from bodies (via this method).</p></li>
<li><p>Invoke SceneGraph::ExcludeCollisions*() to filter collisions.</p></li>
<li><p>Allocate context.</p></li>
</ol>
<p>Changing the order will cause exceptions to be thrown.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if this MultibodyPlant was not registered with a</strong> – </p></li>
<li><p><strong>SceneGraph.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.deformable_model">
<span class="sig-name descname"><span class="pre">deformable_model</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.multibody.plant.DeformableModel" title="pydrake.multibody.plant.DeformableModel"><span class="pre">pydrake.multibody.plant.DeformableModel</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.deformable_model" title="Link to this definition"></a></dt>
<dd><p>Returns the DeformableModel owned by this plant.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This feature is considered to be <strong>experimental</strong> and may change
or be removed at any time, without any deprecation notice ahead of
time.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.EvalBodyPoseInWorld">
<span class="sig-name descname"><span class="pre">EvalBodyPoseInWorld</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context" title="pydrake.systems.framework.Context"><span class="pre">pydrake.systems.framework.Context</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">body</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody" title="pydrake.multibody.tree.RigidBody"><span class="pre">pydrake.multibody.tree.RigidBody</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.math.html#pydrake.math.RigidTransform" title="pydrake.math.RigidTransform"><span class="pre">pydrake.math.RigidTransform</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.EvalBodyPoseInWorld" title="Link to this definition"></a></dt>
<dd><p>Evaluate the pose <code class="docutils literal notranslate"><span class="pre">X_WB</span></code> of a body B in the world frame W.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context storing the state of the model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body_B</span></code>:</dt><dd><p>The body B for which the pose is requested.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">X_WB</span></code>:</dt><dd><p>The pose of body frame B in the world frame W.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if Finalize</strong><strong>(</strong><strong>) </strong><strong>was not called on this model</strong><strong> or </strong><strong>if</strong> – </p></li>
<li><p><strong>body_B` does not belong to this model</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.EvalBodySpatialAccelerationInWorld">
<span class="sig-name descname"><span class="pre">EvalBodySpatialAccelerationInWorld</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context" title="pydrake.systems.framework.Context"><span class="pre">pydrake.systems.framework.Context</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">body</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody" title="pydrake.multibody.tree.RigidBody"><span class="pre">pydrake.multibody.tree.RigidBody</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.math.html#pydrake.multibody.math.SpatialAcceleration" title="pydrake.multibody.math.SpatialAcceleration"><span class="pre">pydrake.multibody.math.SpatialAcceleration</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.EvalBodySpatialAccelerationInWorld" title="Link to this definition"></a></dt>
<dd><p>Evaluates A_WB, body B’s spatial acceleration in the world frame W.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context storing the state of the model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body_B</span></code>:</dt><dd><p>The body for which spatial acceleration is requested.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">A_WB_W</span></code>:</dt><dd><p>RigidBody B’s spatial acceleration in the world frame W, expressed
in W (for point Bo, the body’s origin).</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if Finalize</strong><strong>(</strong><strong>) </strong><strong>was not called on this model</strong><strong> or </strong><strong>if</strong> – </p></li>
<li><p><strong>body_B` does not belong to this model</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When cached values are out of sync with the state stored in
context, this method performs an expensive forward dynamics
computation, whereas once evaluated, successive calls to this
method are inexpensive.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.EvalBodySpatialVelocityInWorld">
<span class="sig-name descname"><span class="pre">EvalBodySpatialVelocityInWorld</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context" title="pydrake.systems.framework.Context"><span class="pre">pydrake.systems.framework.Context</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">body</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody" title="pydrake.multibody.tree.RigidBody"><span class="pre">pydrake.multibody.tree.RigidBody</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.math.html#pydrake.multibody.math.SpatialVelocity" title="pydrake.multibody.math.SpatialVelocity"><span class="pre">pydrake.multibody.math.SpatialVelocity</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.EvalBodySpatialVelocityInWorld" title="Link to this definition"></a></dt>
<dd><p>Evaluates V_WB, body B’s spatial velocity in the world frame W.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context storing the state of the model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body_B</span></code>:</dt><dd><p>The body B for which the spatial velocity is requested.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">V_WB_W</span></code>:</dt><dd><p>RigidBody B’s spatial velocity in the world frame W, expressed in
W (for point Bo, the body’s origin).</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if Finalize</strong><strong>(</strong><strong>) </strong><strong>was not called on this model</strong><strong> or </strong><strong>if</strong> – </p></li>
<li><p><strong>body_B` does not belong to this model</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.EvalSceneGraphInspector">
<span class="sig-name descname"><span class="pre">EvalSceneGraphInspector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context" title="pydrake.systems.framework.Context"><span class="pre">pydrake.systems.framework.Context</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.SceneGraphInspector" title="pydrake.geometry.SceneGraphInspector"><span class="pre">pydrake.geometry.SceneGraphInspector</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.EvalSceneGraphInspector" title="Link to this definition"></a></dt>
<dd><p>Returns the inspector from the <code class="docutils literal notranslate"><span class="pre">context</span></code> for the SceneGraph
associated with this plant, via this plant’s “geometry_query” input
port. (In the future, the inspector might come from a different
context source that is more efficient than the “geometry_query” input
port.)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.Finalize">
<span class="sig-name descname"><span class="pre">Finalize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.Finalize" title="Link to this definition"></a></dt>
<dd><p>This method must be called after all elements in the model (joints,
bodies, force elements, constraints, etc.) are added and before any
computations are performed. It essentially compiles all the necessary
“topological information”, i.e. how bodies, joints and, any other
elements connect with each other, and performs all the required
pre-processing to enable computations at a later stage.</p>
<p>If the finalize stage is successful, the topology of this
MultibodyPlant is valid, meaning that the topology is up-to-date after
this call. No more multibody elements can be added after a call to
Finalize().</p>
<p>At Finalize(), state and input/output ports for <code class="docutils literal notranslate"><span class="pre">this</span></code> plant are
declared.</p>
<p>For a full account of the effects of Finalize(), see
mbp_finalize_stage “Finalize() stage”.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>is_finalized(), mbp_finalize_stage “Finalize() stage”.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if the MultibodyPlant has already been finalized.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.geometry_source_is_registered">
<span class="sig-name descname"><span class="pre">geometry_source_is_registered</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.geometry_source_is_registered" title="Link to this definition"></a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if <code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant was registered with a
SceneGraph. This method can be called at any time during the lifetime
of <code class="docutils literal notranslate"><span class="pre">this</span></code> plant to query if <code class="docutils literal notranslate"><span class="pre">this</span></code> plant has been registered with
a SceneGraph, either pre- or post-finalize, see Finalize().</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.get_actuation_input_port">
<span class="sig-name descname"><span class="pre">get_actuation_input_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.get_actuation_input_port" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>get_actuation_input_port(self: pydrake.multibody.plant.MultibodyPlant) -&gt; pydrake.systems.framework.InputPort</p></li>
</ol>
<p>Returns a constant reference to the input port for external actuation
for all actuated dofs. This input port is a vector valued port and can
be set with JointActuator::set_actuation_vector(). The actuation value
for a particular actuator can be found at offset
JointActuator::input_start() in this vector. Refer to mbp_actuation
“Actuation” for further details.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>Finalize() was already called on <code class="docutils literal notranslate"><span class="pre">this</span></code> plant.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called before Finalize</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>get_actuation_input_port(self: pydrake.multibody.plant.MultibodyPlant, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; pydrake.systems.framework.InputPort</p></li>
</ol>
<p>Returns a constant reference to the input port for external actuation
for a specific model instance. This is a vector valued port with
entries ordered by monotonically increasing JointActuatorIndex within
<code class="docutils literal notranslate"><span class="pre">model_instance</span></code>. Refer to mbp_actuation “Actuation” for further
details.</p>
<p>Every model instance in <code class="docutils literal notranslate"><span class="pre">this</span></code> plant model has an actuation input
port, even if zero sized (for model instance with no actuators).</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>GetJointActuatorIndices(), GetActuatedJointIndices().</p>
</div>
<dl class="simple">
<dt>Precondition:</dt><dd><p>Finalize() was already called on <code class="docutils literal notranslate"><span class="pre">this</span></code> plant.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if called before Finalize</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p></li>
<li><p><strong>RuntimeError if the model instance does not exist.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.get_adjacent_bodies_collision_filters">
<span class="sig-name descname"><span class="pre">get_adjacent_bodies_collision_filters</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.get_adjacent_bodies_collision_filters" title="Link to this definition"></a></dt>
<dd><p>Returns whether to apply collision filters to topologically adjacent
bodies at Finalize() time.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.get_applied_generalized_force_input_port">
<span class="sig-name descname"><span class="pre">get_applied_generalized_force_input_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.InputPort" title="pydrake.systems.framework.InputPort"><span class="pre">pydrake.systems.framework.InputPort</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.get_applied_generalized_force_input_port" title="Link to this definition"></a></dt>
<dd><p>Returns a constant reference to the vector-valued input port for
applied generalized forces, and the vector will be added directly into
<code class="docutils literal notranslate"><span class="pre">tau</span></code> (see mbp_equations_of_motion “System dynamics”). This vector
is ordered using the same convention as the plant velocities: you can
set the generalized forces that will be applied to model instance i
using, e.g., <code class="docutils literal notranslate"><span class="pre">SetVelocitiesInArray(i,</span> <span class="pre">model_forces,</span> <span class="pre">&amp;force_array)</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called before Finalize</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.get_applied_spatial_force_input_port">
<span class="sig-name descname"><span class="pre">get_applied_spatial_force_input_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.InputPort" title="pydrake.systems.framework.InputPort"><span class="pre">pydrake.systems.framework.InputPort</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.get_applied_spatial_force_input_port" title="Link to this definition"></a></dt>
<dd><p>Returns a constant reference to the input port for applying spatial
forces to bodies in the plant. The data type for the port is an
std::vector of ExternallyAppliedSpatialForce; any number of spatial
forces can be applied to any number of bodies in the plant.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.get_body">
<span class="sig-name descname"><span class="pre">get_body</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">body_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.BodyIndex" title="pydrake.multibody.tree.BodyIndex"><span class="pre">pydrake.multibody.tree.BodyIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody" title="pydrake.multibody.tree.RigidBody"><span class="pre">pydrake.multibody.tree.RigidBody</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.get_body" title="Link to this definition"></a></dt>
<dd><p>Returns a constant reference to the body with unique index
<code class="docutils literal notranslate"><span class="pre">body_index</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if body_index does not correspond to a body in</strong> – </p></li>
<li><p><strong>this model.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.get_body_poses_output_port">
<span class="sig-name descname"><span class="pre">get_body_poses_output_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.OutputPort" title="pydrake.systems.framework.OutputPort"><span class="pre">pydrake.systems.framework.OutputPort</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.get_body_poses_output_port" title="Link to this definition"></a></dt>
<dd><p>Returns the output port of all body poses in the world frame. You can
obtain the pose <code class="docutils literal notranslate"><span class="pre">X_WB</span></code> of a body B in the world frame W with:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">X_WB_all</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">plant</span><span class="p">.</span><span class="n">get_body_poses_output_port</span><span class="p">().</span>
<span class="w">      </span><span class="p">.</span><span class="n">Eval</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">math</span><span class="o">::</span><span class="n">RigidTransform</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">plant_context</span><span class="p">);</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">BodyIndex</span><span class="w"> </span><span class="n">arm_body_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">plant</span><span class="p">.</span><span class="n">GetBodyByName</span><span class="p">(</span><span class="s">&quot;arm&quot;</span><span class="p">).</span><span class="n">index</span><span class="p">();</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">math</span><span class="o">::</span><span class="n">RigidTransform</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">X_WArm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">X_WB_all</span><span class="p">[</span><span class="n">arm_body_index</span><span class="p">];</span>
</pre></div>
</div>
</details><p>As shown in the example above, the resulting <code class="docutils literal notranslate"><span class="pre">std::vector</span></code> of body
poses is indexed by BodyIndex, and it has size num_bodies(). BodyIndex
“zero” (0) always corresponds to the world body, with pose equal to
the identity at all times.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.get_body_spatial_accelerations_output_port">
<span class="sig-name descname"><span class="pre">get_body_spatial_accelerations_output_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.OutputPort" title="pydrake.systems.framework.OutputPort"><span class="pre">pydrake.systems.framework.OutputPort</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.get_body_spatial_accelerations_output_port" title="Link to this definition"></a></dt>
<dd><p>Returns the output port of all body spatial accelerations in the world
frame. You can obtain the spatial acceleration <code class="docutils literal notranslate"><span class="pre">A_WB</span></code> of a body B
(for point Bo, the body’s origin) in the world frame W with:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">A_WB_all</span><span class="w"> </span><span class="o">=</span>
<span class="w">  </span><span class="n">plant</span><span class="p">.</span><span class="n">get_body_spatial_accelerations_output_port</span><span class="p">().</span>
<span class="w">      </span><span class="p">.</span><span class="n">Eval</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SpatialAcceleration</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">plant_context</span><span class="p">);</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">BodyIndex</span><span class="w"> </span><span class="n">arm_body_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">plant</span><span class="p">.</span><span class="n">GetBodyByName</span><span class="p">(</span><span class="s">&quot;arm&quot;</span><span class="p">).</span><span class="n">index</span><span class="p">();</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">SpatialVelocity</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">A_WArm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A_WB_all</span><span class="p">[</span><span class="n">arm_body_index</span><span class="p">];</span>
</pre></div>
</div>
</details><p>As shown in the example above, the resulting <code class="docutils literal notranslate"><span class="pre">std::vector</span></code> of body
spatial accelerations is indexed by BodyIndex, and it has size
num_bodies(). BodyIndex “zero” (0) always corresponds to the world
body, with zero spatial acceleration at all times.</p>
<p>In a discrete-time plant, the use_sampled_output_ports setting affects
the output of this port. See output_port_sampling “Output port
sampling” for details. When sampling is enabled and the plant has not
yet taken a step, the output value will be all zeros.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.get_body_spatial_velocities_output_port">
<span class="sig-name descname"><span class="pre">get_body_spatial_velocities_output_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.OutputPort" title="pydrake.systems.framework.OutputPort"><span class="pre">pydrake.systems.framework.OutputPort</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.get_body_spatial_velocities_output_port" title="Link to this definition"></a></dt>
<dd><p>Returns the output port of all body spatial velocities in the world
frame. You can obtain the spatial velocity <code class="docutils literal notranslate"><span class="pre">V_WB</span></code> of a body B in the
world frame W with:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">V_WB_all</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">plant</span><span class="p">.</span><span class="n">get_body_spatial_velocities_output_port</span><span class="p">().</span>
<span class="w">      </span><span class="p">.</span><span class="n">Eval</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SpatialVelocity</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">plant_context</span><span class="p">);</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">BodyIndex</span><span class="w"> </span><span class="n">arm_body_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">plant</span><span class="p">.</span><span class="n">GetBodyByName</span><span class="p">(</span><span class="s">&quot;arm&quot;</span><span class="p">).</span><span class="n">index</span><span class="p">();</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">SpatialVelocity</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">V_WArm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">V_WB_all</span><span class="p">[</span><span class="n">arm_body_index</span><span class="p">];</span>
</pre></div>
</div>
</details><p>As shown in the example above, the resulting <code class="docutils literal notranslate"><span class="pre">std::vector</span></code> of body
spatial velocities is indexed by BodyIndex, and it has size
num_bodies(). BodyIndex “zero” (0) always corresponds to the world
body, with zero spatial velocity at all times.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.get_contact_model">
<span class="sig-name descname"><span class="pre">get_contact_model</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.multibody.plant.ContactModel" title="pydrake.multibody.plant.ContactModel"><span class="pre">pydrake.multibody.plant.ContactModel</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.get_contact_model" title="Link to this definition"></a></dt>
<dd><p>Returns the model used for contact. See documentation for
ContactModel.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.get_contact_penalty_method_time_scale">
<span class="sig-name descname"><span class="pre">get_contact_penalty_method_time_scale</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.get_contact_penalty_method_time_scale" title="Link to this definition"></a></dt>
<dd><p>Returns a time-scale estimate <code class="docutils literal notranslate"><span class="pre">tc</span></code> based on the requested
penetration allowance δ set with set_penetration_allowance(). For the
compliant contact model to enforce non-penetration, this time scale
relates to the time it takes the relative normal velocity between two
bodies to go to zero. This time scale <code class="docutils literal notranslate"><span class="pre">tc</span></code> is a global estimate of
the dynamics introduced by the compliant contact model and goes to
zero in the limit to ideal rigid contact. Since numerical integration
methods for continuum systems must be able to resolve a system’s
dynamics, the time step used by an integrator must in general be much
smaller than the time scale <code class="docutils literal notranslate"><span class="pre">tc</span></code>. How much smaller will depend on
the details of the problem and the convergence characteristics of the
integrator and should be tuned appropriately. Another factor to take
into account for setting up the simulation’s time step is the speed of
the objects in your simulation. If <code class="docutils literal notranslate"><span class="pre">vn</span></code> represents a reference
velocity scale for the normal relative velocity between bodies, the
new time scale <code class="docutils literal notranslate"><span class="pre">tn</span> <span class="pre">=</span> <span class="pre">δ</span> <span class="pre">/</span> <span class="pre">vn</span></code> represents the time it would take for
the distance between two bodies approaching with relative normal
velocity <code class="docutils literal notranslate"><span class="pre">vn</span></code> to decrease by the penetration_allowance δ. In this
case a user should choose a time step for simulation that can resolve
the smallest of the two time scales <code class="docutils literal notranslate"><span class="pre">tc</span></code> and <code class="docutils literal notranslate"><span class="pre">tn</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.get_contact_results_output_port">
<span class="sig-name descname"><span class="pre">get_contact_results_output_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.OutputPort" title="pydrake.systems.framework.OutputPort"><span class="pre">pydrake.systems.framework.OutputPort</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.get_contact_results_output_port" title="Link to this definition"></a></dt>
<dd><p>Returns a constant reference to the port that outputs ContactResults.</p>
<p>In a discrete-time plant, the use_sampled_output_ports setting affects
the output of this port. See output_port_sampling “Output port
sampling” for details. When sampling is enabled and the plant has not
yet taken a step, the output value will be empty (no contacts).</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize</strong><strong>, </strong><strong>see Finalize</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.get_contact_surface_representation">
<span class="sig-name descname"><span class="pre">get_contact_surface_representation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.HydroelasticContactRepresentation" title="pydrake.geometry.HydroelasticContactRepresentation"><span class="pre">pydrake.geometry.HydroelasticContactRepresentation</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.get_contact_surface_representation" title="Link to this definition"></a></dt>
<dd><p>Gets the current representation of contact surfaces used by <code class="docutils literal notranslate"><span class="pre">this</span></code>
MultibodyPlant.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.get_deformable_body_configuration_output_port">
<span class="sig-name descname"><span class="pre">get_deformable_body_configuration_output_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.OutputPort" title="pydrake.systems.framework.OutputPort"><span class="pre">pydrake.systems.framework.OutputPort</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.get_deformable_body_configuration_output_port" title="Link to this definition"></a></dt>
<dd><p>Returns the output port for vertex positions (configurations),
measured and expressed in the World frame, of the deformable bodies in
<code class="docutils literal notranslate"><span class="pre">this</span></code> plant as a GeometryConfigurationVector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.get_desired_state_input_port">
<span class="sig-name descname"><span class="pre">get_desired_state_input_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.InputPort" title="pydrake.systems.framework.InputPort"><span class="pre">pydrake.systems.framework.InputPort</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.get_desired_state_input_port" title="Link to this definition"></a></dt>
<dd><p>For models with PD controlled joint actuators, returns the port to
provide the desired state for the given <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>. Refer to
mbp_actuation “Actuation” for further details.</p>
<p>For consistency with get_actuation_input_port(), each model instance
in <code class="docutils literal notranslate"><span class="pre">this</span></code> plant model has a desired states input port, even if zero
sized (for model instance with no actuators.)</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This port always has size 2 * num_actuators(model_instance), where
we assume 1-DOF actuated joints. This port must provide one
desired position and one desired velocity per joint actuator,
packed as xd = [qd, vd], with positions and velocities in order of
increasing JointActuatorIndex. Only desired states corresponding
to PD-controlled actuators on non-locked joints
(Joint::is_locked()) are used, the rest are ignored. That is PD
control on just a subset of actuators is allowed.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The desired state input port for a given model instance is not
required to be connected. If disconnected, the controllers for
such model instance will be <em>disarmed</em>. Refer to
pd_controllers_and_ports for further details.</p>
</div>
<p>As an example of this structure, consider the following code to fix
desired states input values:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">plant</span><span class="p">;</span>
<span class="c1">// ... Load/parse plant model ...</span>
<span class="n">plant</span><span class="p">.</span><span class="n">Finalize</span><span class="p">();</span>
<span class="k">auto</span><span class="w"> </span><span class="n">context</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">plant</span><span class="p">.</span><span class="n">CreateDefaultContext</span><span class="p">();</span>
<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">num_u</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">plant</span><span class="p">.</span><span class="n">num_actuators</span><span class="p">(</span><span class="n">model_instance</span><span class="p">);</span>
<span class="k">const</span><span class="w"> </span><span class="n">VectorXd</span><span class="w"> </span><span class="nf">model_xd</span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">num_u</span><span class="p">);</span>
<span class="k">auto</span><span class="w"> </span><span class="n">model_qd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">model_xd</span><span class="p">.</span><span class="n">head</span><span class="p">(</span><span class="n">num_u</span><span class="p">);</span>
<span class="k">auto</span><span class="w"> </span><span class="n">model_vd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">model_xd</span><span class="p">.</span><span class="n">tail</span><span class="p">(</span><span class="n">num_u</span><span class="p">);</span>

<span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="c1">// Specify qd and vd in increasing order of JointActuatorIndex, as</span>
<span class="c1">// returned by GetJointActuatorIndices().</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">JointActuatorIndex</span><span class="w"> </span><span class="n">actuator_index</span><span class="w"> </span><span class="o">:</span>
<span class="w">    </span><span class="n">plant</span><span class="p">.</span><span class="n">GetJointActuatorIndices</span><span class="p">(</span><span class="n">model_instance</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">qd</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">....</span><span class="w"> </span><span class="n">desired</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">actuator_index</span>
<span class="w">  </span><span class="n">vd</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">....</span><span class="w"> </span><span class="n">desired</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">actuator_index</span>
<span class="w">  </span><span class="o">++</span><span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// As an example, fix values in the context.</span>
<span class="n">plant</span><span class="p">.</span><span class="n">get_desired_state_input_port</span><span class="p">(</span><span class="n">model_instance</span><span class="p">).</span><span class="n">FixValue</span><span class="p">(</span>
<span class="w">    </span><span class="o">&amp;</span><span class="n">plant_context</span><span class="p">,</span><span class="w"> </span><span class="n">model_xd</span><span class="p">);</span>
</pre></div>
</div>
</details></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.get_discrete_contact_approximation">
<span class="sig-name descname"><span class="pre">get_discrete_contact_approximation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.multibody.plant.DiscreteContactApproximation" title="pydrake.multibody.plant.DiscreteContactApproximation"><span class="pre">pydrake.multibody.plant.DiscreteContactApproximation</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.get_discrete_contact_approximation" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>the discrete contact solver approximation.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.get_discrete_contact_solver">
<span class="sig-name descname"><span class="pre">get_discrete_contact_solver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.multibody.plant.DiscreteContactSolver" title="pydrake.multibody.plant.DiscreteContactSolver"><span class="pre">pydrake.multibody.plant.DiscreteContactSolver</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.get_discrete_contact_solver" title="Link to this definition"></a></dt>
<dd><p>Returns the contact solver type used for discrete MultibodyPlant
models.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.get_force_element">
<span class="sig-name descname"><span class="pre">get_force_element</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">force_element_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ForceElementIndex" title="pydrake.multibody.tree.ForceElementIndex"><span class="pre">pydrake.multibody.tree.ForceElementIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ForceElement" title="pydrake.multibody.tree.ForceElement"><span class="pre">pydrake.multibody.tree.ForceElement</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.get_force_element" title="Link to this definition"></a></dt>
<dd><p>Returns a constant reference to the force element with unique index
<code class="docutils literal notranslate"><span class="pre">force_element_index</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError when force_element_index does not correspond to a</strong> – </p></li>
<li><p><strong>force element in this model.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.get_frame">
<span class="sig-name descname"><span class="pre">get_frame</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.FrameIndex" title="pydrake.multibody.tree.FrameIndex"><span class="pre">pydrake.multibody.tree.FrameIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame" title="pydrake.multibody.tree.Frame"><span class="pre">pydrake.multibody.tree.Frame</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.get_frame" title="Link to this definition"></a></dt>
<dd><p>Returns a constant reference to the frame with unique index
<code class="docutils literal notranslate"><span class="pre">frame_index</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if frame_index does not correspond to a frame in</strong> – </p></li>
<li><p><strong>this plant.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.get_generalized_acceleration_output_port">
<span class="sig-name descname"><span class="pre">get_generalized_acceleration_output_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.get_generalized_acceleration_output_port" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>get_generalized_acceleration_output_port(self: pydrake.multibody.plant.MultibodyPlant) -&gt; pydrake.systems.framework.OutputPort</p></li>
</ol>
<p>Returns a constant reference to the output port for generalized
accelerations v̇ of the model.</p>
<p>In a discrete-time plant, the use_sampled_output_ports setting affects
the output of this port. See output_port_sampling “Output port
sampling” for details. When sampling is enabled and the plant has not
yet taken a step, the output value will be all zeros.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>Finalize() was already called on <code class="docutils literal notranslate"><span class="pre">this</span></code> plant.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called before Finalize</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>get_generalized_acceleration_output_port(self: pydrake.multibody.plant.MultibodyPlant, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; pydrake.systems.framework.OutputPort</p></li>
</ol>
<p>Returns a constant reference to the output port for the generalized
accelerations v̇ᵢ ⊆ v̇ for model instance i.</p>
<p>In a discrete-time plant, the use_sampled_output_ports setting affects
the output of this port. See output_port_sampling “Output port
sampling” for details. When sampling is enabled and the plant has not
yet taken a step, the output value will be all zeros.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>Finalize() was already called on <code class="docutils literal notranslate"><span class="pre">this</span></code> plant.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if called before Finalize</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p></li>
<li><p><strong>RuntimeError if the model instance does not exist.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.get_generalized_contact_forces_output_port">
<span class="sig-name descname"><span class="pre">get_generalized_contact_forces_output_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.OutputPort" title="pydrake.systems.framework.OutputPort"><span class="pre">pydrake.systems.framework.OutputPort</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.get_generalized_contact_forces_output_port" title="Link to this definition"></a></dt>
<dd><p>Returns a constant reference to the output port of generalized contact
forces for a specific model instance.</p>
<p>In a discrete-time plant, the use_sampled_output_ports setting affects
the output of this port. See output_port_sampling “Output port
sampling” for details. When sampling is enabled and the plant has not
yet taken a step, the output value will be all zeros.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>Finalize() was already called on <code class="docutils literal notranslate"><span class="pre">this</span></code> plant.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if called before Finalize</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p></li>
<li><p><strong>RuntimeError if the model instance does not exist.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.get_geometry_pose_output_port">
<span class="sig-name descname"><span class="pre">get_geometry_pose_output_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.OutputPort" title="pydrake.systems.framework.OutputPort"><span class="pre">pydrake.systems.framework.OutputPort</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.get_geometry_pose_output_port" title="Link to this definition"></a></dt>
<dd><p>Returns the output port of frames’ poses to communicate with a
SceneGraph.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.get_geometry_query_input_port">
<span class="sig-name descname"><span class="pre">get_geometry_query_input_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.InputPort" title="pydrake.systems.framework.InputPort"><span class="pre">pydrake.systems.framework.InputPort</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.get_geometry_query_input_port" title="Link to this definition"></a></dt>
<dd><p>Returns a constant reference to the input port used to perform
geometric queries on a SceneGraph. See
SceneGraph::get_query_output_port(). Refer to section mbp_geometry
“Geometry” of this class’s documentation for further details on
collision geometry registration and connection with a SceneGraph.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.get_joint">
<span class="sig-name descname"><span class="pre">get_joint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">joint_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JointIndex" title="pydrake.multibody.tree.JointIndex"><span class="pre">pydrake.multibody.tree.JointIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Joint" title="pydrake.multibody.tree.Joint"><span class="pre">pydrake.multibody.tree.Joint</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.get_joint" title="Link to this definition"></a></dt>
<dd><p>Returns a constant reference to the joint with unique index
<code class="docutils literal notranslate"><span class="pre">joint_index</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError when joint_index does not correspond to a joint</strong> – </p></li>
<li><p><strong>in this model.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.get_joint_actuator">
<span class="sig-name descname"><span class="pre">get_joint_actuator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">actuator_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JointActuatorIndex" title="pydrake.multibody.tree.JointActuatorIndex"><span class="pre">pydrake.multibody.tree.JointActuatorIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JointActuator" title="pydrake.multibody.tree.JointActuator"><span class="pre">pydrake.multibody.tree.JointActuator</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.get_joint_actuator" title="Link to this definition"></a></dt>
<dd><p>Returns a constant reference to the joint actuator with unique index
<code class="docutils literal notranslate"><span class="pre">actuator_index</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if actuator_index does not correspond to a joint</strong> – </p></li>
<li><p><strong>actuator in this tree.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.get_mutable_joint">
<span class="sig-name descname"><span class="pre">get_mutable_joint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">joint_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JointIndex" title="pydrake.multibody.tree.JointIndex"><span class="pre">pydrake.multibody.tree.JointIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Joint" title="pydrake.multibody.tree.Joint"><span class="pre">pydrake.multibody.tree.Joint</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.get_mutable_joint" title="Link to this definition"></a></dt>
<dd><p>Returns a mutable reference to the joint with unique index
<code class="docutils literal notranslate"><span class="pre">joint_index</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError when joint_index does not correspond to a joint</strong> – </p></li>
<li><p><strong>in this model.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.get_mutable_joint_actuator">
<span class="sig-name descname"><span class="pre">get_mutable_joint_actuator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">actuator_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JointActuatorIndex" title="pydrake.multibody.tree.JointActuatorIndex"><span class="pre">pydrake.multibody.tree.JointActuatorIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JointActuator" title="pydrake.multibody.tree.JointActuator"><span class="pre">pydrake.multibody.tree.JointActuator</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.get_mutable_joint_actuator" title="Link to this definition"></a></dt>
<dd><p>Returns a mutable reference to the joint actuator with unique index
<code class="docutils literal notranslate"><span class="pre">actuator_index</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if actuator_index does not correspond to a joint</strong> – </p></li>
<li><p><strong>actuator in this tree.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.get_net_actuation_output_port">
<span class="sig-name descname"><span class="pre">get_net_actuation_output_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.get_net_actuation_output_port" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>get_net_actuation_output_port(self: pydrake.multibody.plant.MultibodyPlant) -&gt; pydrake.systems.framework.OutputPort</p></li>
</ol>
<p>Returns a constant reference to the output port that reports actuation
values applied through joint actuators. This output port is a vector
valued port. The actuation value for a particular actuator can be
found at offset JointActuator::input_start() in this vector. Models
that include PD controllers will include their contribution in this
port, refer to mbp_actuation “Actuation” for further details.</p>
<p>In a discrete-time plant, the use_sampled_output_ports setting affects
the output of this port. See output_port_sampling “Output port
sampling” for details. When sampling is enabled and the plant has not
yet taken a step, the output value will be all zeros.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>PD controllers are not considered for actuators on locked joints,
see Joint::Lock(). Therefore they do not contribute to this port.</p>
</div>
<dl class="simple">
<dt>Precondition:</dt><dd><p>Finalize() was already called on <code class="docutils literal notranslate"><span class="pre">this</span></code> plant.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called before Finalize</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>get_net_actuation_output_port(self: pydrake.multibody.plant.MultibodyPlant, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; pydrake.systems.framework.OutputPort</p></li>
</ol>
<p>Returns a constant reference to the output port that reports actuation
values applied through joint actuators, for a specific model instance.
Models that include PD controllers will include their contribution in
this port, refer to mbp_actuation “Actuation” for further details.
This is a vector valued port with entries ordered by monotonically
increasing JointActuatorIndex within <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>.</p>
<p>Every model instance in <code class="docutils literal notranslate"><span class="pre">this</span></code> plant model has a net actuation
output port, even if zero sized (for model instance with no
actuators).</p>
<p>In a discrete-time plant, the use_sampled_output_ports setting affects
the output of this port. See output_port_sampling “Output port
sampling” for details. When sampling is enabled and the plant has not
yet taken a step, the output value will be all zeros.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>PD controllers are not considered for actuators on locked joints,
see Joint::Lock(). Therefore they do not contribute to this port.</p>
</div>
<dl class="simple">
<dt>Precondition:</dt><dd><p>Finalize() was already called on <code class="docutils literal notranslate"><span class="pre">this</span></code> plant.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called before Finalize</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.get_reaction_forces_output_port">
<span class="sig-name descname"><span class="pre">get_reaction_forces_output_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.OutputPort" title="pydrake.systems.framework.OutputPort"><span class="pre">pydrake.systems.framework.OutputPort</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.get_reaction_forces_output_port" title="Link to this definition"></a></dt>
<dd><p>Returns the port for joint reaction forces. A Joint models the
kinematical relationship which characterizes the possible relative
motion between two bodies. In Drake, a joint connects a frame <code class="docutils literal notranslate"><span class="pre">Jp</span></code>
on <em>parent</em> body P with a frame <code class="docutils literal notranslate"><span class="pre">Jc</span></code> on a <em>child</em> body C. This usage
of the terms <em>parent</em> and <em>child</em> is just a convention and implies
nothing about the inboard-outboard relationship between the bodies.
Since a Joint imposes a kinematical relationship which characterizes
the possible relative motion between frames Jp and Jc, reaction forces
on each body are established. That is, we could cut the model at the
joint and replace it with equivalent forces equal to these reaction
forces in order to attain the same motions of the mechanical system.</p>
<p>This output port allows to evaluate the reaction force <code class="docutils literal notranslate"><span class="pre">F_CJc_Jc</span></code> on
the <em>child</em> body C, at <code class="docutils literal notranslate"><span class="pre">Jc</span></code>, and expressed in Jc for all joints in
the model. This port evaluates to a vector of type
std::vector&lt;SpatialForce&lt;T&gt;&gt; and size num_joints() indexed by
JointIndex, see Joint::index(). Each entry corresponds to the spatial
force <code class="docutils literal notranslate"><span class="pre">F_CJc_Jc</span></code> applied on the joint’s child body C
(Joint::child_body()), at the joint’s child frame <code class="docutils literal notranslate"><span class="pre">Jc</span></code>
(Joint::frame_on_child()) and expressed in frame <code class="docutils literal notranslate"><span class="pre">Jc</span></code>.</p>
<p>In a discrete-time plant, the use_sampled_output_ports setting affects
the output of this port. See output_port_sampling “Output port
sampling” for details. When sampling is enabled and the plant has not
yet taken a step, the output value will be all zeros.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.get_sap_near_rigid_threshold">
<span class="sig-name descname"><span class="pre">get_sap_near_rigid_threshold</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.get_sap_near_rigid_threshold" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>the SAP near rigid regime threshold.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>See set_sap_near_rigid_threshold().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.get_source_id">
<span class="sig-name descname"><span class="pre">get_source_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.SourceId" title="pydrake.geometry.SourceId"><span class="pre">pydrake.geometry.SourceId</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.get_source_id" title="Link to this definition"></a></dt>
<dd><p>Returns the unique id identifying <code class="docutils literal notranslate"><span class="pre">this</span></code> plant as a source for a
SceneGraph. Returns <code class="docutils literal notranslate"><span class="pre">nullopt</span></code> if <code class="docutils literal notranslate"><span class="pre">this</span></code> plant did not register any
geometry. This method can be called at any time during the lifetime of
<code class="docutils literal notranslate"><span class="pre">this</span></code> plant to query if <code class="docutils literal notranslate"><span class="pre">this</span></code> plant has been registered with a
SceneGraph, either pre- or post-finalize, see Finalize(). However, a
geometry::SourceId is only assigned once at the first call of any of
this plant’s geometry registration methods, and it does not change
after that. Post-finalize calls will always return the same value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.get_state_output_port">
<span class="sig-name descname"><span class="pre">get_state_output_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.get_state_output_port" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>get_state_output_port(self: pydrake.multibody.plant.MultibodyPlant) -&gt; pydrake.systems.framework.OutputPort</p></li>
</ol>
<p>Returns a constant reference to the output port for the multibody
state x = [q, v] of the model.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>Finalize() was already called on <code class="docutils literal notranslate"><span class="pre">this</span></code> plant.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called before Finalize</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>get_state_output_port(self: pydrake.multibody.plant.MultibodyPlant, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; pydrake.systems.framework.OutputPort</p></li>
</ol>
<p>Returns a constant reference to the output port for the state xᵢ = [qᵢ
vᵢ] of model instance i. (Here qᵢ ⊆ q and vᵢ ⊆ v.)</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>Finalize() was already called on <code class="docutils literal notranslate"><span class="pre">this</span></code> plant.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if called before Finalize</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p></li>
<li><p><strong>RuntimeError if the model instance does not exist.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetAccelerationLowerLimits">
<span class="sig-name descname"><span class="pre">GetAccelerationLowerLimits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetAccelerationLowerLimits" title="Link to this definition"></a></dt>
<dd><p>Returns a vector of size <code class="docutils literal notranslate"><span class="pre">num_velocities()</span></code> containing the lower
acceleration limits for every generalized velocity coordinate. These
include joint and free body coordinates. Any unbounded or unspecified
limits will be -infinity.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetAccelerationUpperLimits">
<span class="sig-name descname"><span class="pre">GetAccelerationUpperLimits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetAccelerationUpperLimits" title="Link to this definition"></a></dt>
<dd><p>Upper limit analog of GetAccelerationsLowerLimits(), where any
unbounded or unspecified limits will be +infinity.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>GetAccelerationLowerLimits() for more information.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetActuatedJointIndices">
<span class="sig-name descname"><span class="pre">GetActuatedJointIndices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JointIndex" title="pydrake.multibody.tree.JointIndex"><span class="pre">pydrake.multibody.tree.JointIndex</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetActuatedJointIndices" title="Link to this definition"></a></dt>
<dd><p>Returns a list of actuated joint indices associated with
<code class="docutils literal notranslate"><span class="pre">model_instance</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetActuationFromArray">
<span class="sig-name descname"><span class="pre">GetActuationFromArray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">u</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetActuationFromArray" title="Link to this definition"></a></dt>
<dd><p>Returns a vector of actuation values for <code class="docutils literal notranslate"><span class="pre">model_instance</span></code> from a
vector <code class="docutils literal notranslate"><span class="pre">u</span></code> of actuation values for the entire plant model. Refer to
mbp_actuation “Actuation” for further details.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">u</span></code>:</dt><dd><p>Actuation values for the entire model. The actuation value in
<code class="docutils literal notranslate"><span class="pre">u</span></code> for a particular actuator must be found at offset
JointActuator::input_start().</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Actuation values for <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>, ordered by monotonically
increasing JointActuatorIndex.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>RuntimeError if u is not</strong><strong> of </strong><strong>size</strong> – </p></li>
<li><p><strong>MultibodyPlant::num_actuated_dofs</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetActuatorNames">
<span class="sig-name descname"><span class="pre">GetActuatorNames</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetActuatorNames" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetActuatorNames(self: pydrake.multibody.plant.MultibodyPlant, add_model_instance_prefix: bool = True) -&gt; list[str]</p></li>
</ol>
<p>Returns a list of string names corresponding to each element of the
actuation vector. These strings take the form
<code class="docutils literal notranslate"><span class="pre">{model_instance_name}_{joint_actuator_name}</span></code>, but the prefix may
optionally be withheld using <code class="docutils literal notranslate"><span class="pre">add_model_instance_prefix</span></code>.</p>
<p>The returned names are guaranteed to be unique if
<code class="docutils literal notranslate"><span class="pre">add_model_instance_prefix</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code> (the default).</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if the plant is not finalized.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>GetActuatorNames(self: pydrake.multibody.plant.MultibodyPlant, model_instance: pydrake.multibody.tree.ModelInstanceIndex, add_model_instance_prefix: bool = False) -&gt; list[str]</p></li>
</ol>
<p>Returns a list of string names corresponding to each element of the
actuation vector. These strings take the form
<code class="docutils literal notranslate"><span class="pre">{model_instance_name}_{joint_actuator_name}</span></code>, but the prefix may
optionally be withheld using <code class="docutils literal notranslate"><span class="pre">add_model_instance_prefix</span></code>.</p>
<p>The returned names are guaranteed to be unique.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the plant is not finalized</strong><strong> or </strong><strong>if the</strong> – </p></li>
<li><p><strong>model_instance` is invalid</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetBodiesKinematicallyAffectedBy">
<span class="sig-name descname"><span class="pre">GetBodiesKinematicallyAffectedBy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">joint_indexes</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JointIndex" title="pydrake.multibody.tree.JointIndex"><span class="pre">pydrake.multibody.tree.JointIndex</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.BodyIndex" title="pydrake.multibody.tree.BodyIndex"><span class="pre">pydrake.multibody.tree.BodyIndex</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetBodiesKinematicallyAffectedBy" title="Link to this definition"></a></dt>
<dd><p>Returns all bodies whose kinematics are transitively affected by the
given vector of Joints. This is a <em>kinematic</em> relationship rather than
a dynamic one. It is is inherently a query on the topology of the
plant’s modeled tree. Constraints are likewise not considered.</p>
<p>The affected bodies are returned in increasing order of body indices.
A body is included in the output if that body’s spatial velocity is
affected by the generalized velocities v of one of the indicated
joints.</p>
<p>As such, there are some notable implications:</p>
<p>1. If a body has an inboard free (6 dof) joint, it will be
<em>kinematically</em> affected by joints further inboard, even though there
might not be any dynamic influence on that body. 2. If the set of
joints have no velocities (i.e., they are all weld (0 dof) joints),
then, by definition, no bodies will be affected.</p>
<p>This function can be only be called post-finalize, see Finalize().</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if any</strong><strong> of </strong><strong>the given joint has an invalid index</strong><strong>,</strong> – </p></li>
<li><p><strong>doesn't correspond to a mobilizer</strong><strong>, or </strong><strong>is welded.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetBodiesWeldedTo">
<span class="sig-name descname"><span class="pre">GetBodiesWeldedTo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">body</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody" title="pydrake.multibody.tree.RigidBody"><span class="pre">pydrake.multibody.tree.RigidBody</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody" title="pydrake.multibody.tree.RigidBody"><span class="pre">pydrake.multibody.tree.RigidBody</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetBodiesWeldedTo" title="Link to this definition"></a></dt>
<dd><p>Returns all bodies that are transitively welded, or rigidly affixed,
to <code class="docutils literal notranslate"><span class="pre">body</span></code>, per these two definitions:</p>
<ol class="arabic simple">
<li><p>A body is always considered welded to itself.</p></li>
</ol>
<p>2. Two unique bodies are considered welded together exclusively by the
presence of a weld joint, not by other constructs that prevent mobility
(e.g. constraints).</p>
<p>This method can be called at any time during the lifetime of <code class="docutils literal notranslate"><span class="pre">this</span></code>
plant, either pre- or post-finalize, see Finalize().</p>
<p>Meant to be used with <code class="docutils literal notranslate"><span class="pre">CollectRegisteredGeometries</span></code>.</p>
<p>The following example demonstrates filtering collisions between all
bodies rigidly affixed to a door (which could be moving) and all
bodies rigidly affixed to the world:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">GeometrySet</span><span class="w"> </span><span class="n">g_world</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">plant</span><span class="p">.</span><span class="n">CollectRegisteredGeometries</span><span class="p">(</span>
<span class="w">    </span><span class="n">plant</span><span class="p">.</span><span class="n">GetBodiesWeldedTo</span><span class="p">(</span><span class="n">plant</span><span class="p">.</span><span class="n">world_body</span><span class="p">()));</span>
<span class="n">GeometrySet</span><span class="w"> </span><span class="n">g_door</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">plant</span><span class="p">.</span><span class="n">CollectRegisteredGeometries</span><span class="p">(</span>
<span class="w">    </span><span class="n">plant</span><span class="p">.</span><span class="n">GetBodiesWeldedTo</span><span class="p">(</span><span class="n">plant</span><span class="p">.</span><span class="n">GetBodyByName</span><span class="p">(</span><span class="s">&quot;door&quot;</span><span class="p">)));</span>
<span class="n">scene_graph</span><span class="p">.</span><span class="n">ExcludeCollisionsBetweeen</span><span class="p">(</span><span class="n">g_world</span><span class="p">,</span><span class="w"> </span><span class="n">g_door</span><span class="p">);</span>
</pre></div>
</div>
</details><div class="admonition note">
<p class="admonition-title">Note</p>
<p>Usages akin to this example may introduce redundant collision
filtering; this will not have a functional impact, but may have a
minor performance impact.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>all bodies rigidly fixed to <code class="docutils literal notranslate"><span class="pre">body</span></code>. This does not return the
bodies in any prescribed order.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>RuntimeError if body is not part</strong><strong> of </strong><strong>this plant.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetBodyByName">
<span class="sig-name descname"><span class="pre">GetBodyByName</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetBodyByName" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetBodyByName(self: pydrake.multibody.plant.MultibodyPlant, name: str) -&gt; pydrake.multibody.tree.RigidBody</p></li>
</ol>
<p>Returns a constant reference to a body that is identified by the
string <code class="docutils literal notranslate"><span class="pre">name</span></code> in <code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if there is no body with the requested name.</strong> – </p></li>
<li><p><strong>RuntimeError if the body name occurs in multiple model instances.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>HasBodyNamed() to query if there exists a body in <code class="docutils literal notranslate"><span class="pre">this</span></code>
MultibodyPlant with a given specified name.</p>
</div>
<ol class="arabic simple" start="2">
<li><p>GetBodyByName(self: pydrake.multibody.plant.MultibodyPlant, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; pydrake.multibody.tree.RigidBody</p></li>
</ol>
<p>Returns a constant reference to the body that is uniquely identified
by the string <code class="docutils literal notranslate"><span class="pre">name</span></code> and <code class="docutils literal notranslate"><span class="pre">model_instance</span></code> in <code class="docutils literal notranslate"><span class="pre">this</span></code>
MultibodyPlant.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if there is no body with the requested name.</strong> – </p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>HasBodyNamed() to query if there exists a body in <code class="docutils literal notranslate"><span class="pre">this</span></code>
MultibodyPlant with a given specified name.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetBodyFrameIdIfExists">
<span class="sig-name descname"><span class="pre">GetBodyFrameIdIfExists</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">body_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.BodyIndex" title="pydrake.multibody.tree.BodyIndex"><span class="pre">pydrake.multibody.tree.BodyIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.FrameId" title="pydrake.geometry.FrameId"><span class="pre">pydrake.geometry.FrameId</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetBodyFrameIdIfExists" title="Link to this definition"></a></dt>
<dd><p>If the body with <code class="docutils literal notranslate"><span class="pre">body_index</span></code> belongs to the called plant, it
returns the geometry::FrameId associated with it. Otherwise, it
returns nullopt.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetBodyFrameIdOrThrow">
<span class="sig-name descname"><span class="pre">GetBodyFrameIdOrThrow</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">body_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.BodyIndex" title="pydrake.multibody.tree.BodyIndex"><span class="pre">pydrake.multibody.tree.BodyIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.FrameId" title="pydrake.geometry.FrameId"><span class="pre">pydrake.geometry.FrameId</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetBodyFrameIdOrThrow" title="Link to this definition"></a></dt>
<dd><p>If the body with <code class="docutils literal notranslate"><span class="pre">body_index</span></code> belongs to the called plant, it
returns the geometry::FrameId associated with it. Otherwise this
method throws an exception.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the called plant does not have the body indicated</strong> – </p></li>
<li><p><strong>by body_index.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetBodyFromFrameId">
<span class="sig-name descname"><span class="pre">GetBodyFromFrameId</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.FrameId" title="pydrake.geometry.FrameId"><span class="pre">pydrake.geometry.FrameId</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody" title="pydrake.multibody.tree.RigidBody"><span class="pre">pydrake.multibody.tree.RigidBody</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetBodyFromFrameId" title="Link to this definition"></a></dt>
<dd><p>Given a geometry frame identifier, returns a pointer to the body
associated with that id (nullptr if there is no such body).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetBodyIndices">
<span class="sig-name descname"><span class="pre">GetBodyIndices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.BodyIndex" title="pydrake.multibody.tree.BodyIndex"><span class="pre">pydrake.multibody.tree.BodyIndex</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetBodyIndices" title="Link to this definition"></a></dt>
<dd><p>Returns a list of body indices associated with <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetCollisionGeometriesForBody">
<span class="sig-name descname"><span class="pre">GetCollisionGeometriesForBody</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">body</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody" title="pydrake.multibody.tree.RigidBody"><span class="pre">pydrake.multibody.tree.RigidBody</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.GeometryId" title="pydrake.geometry.GeometryId"><span class="pre">pydrake.geometry.GeometryId</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetCollisionGeometriesForBody" title="Link to this definition"></a></dt>
<dd><p>Returns an array of GeometryId’s identifying the different contact
geometries for <code class="docutils literal notranslate"><span class="pre">body</span></code> previously registered with a SceneGraph.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method can be called at any time during the lifetime of
<code class="docutils literal notranslate"><span class="pre">this</span></code> plant, either pre- or post-finalize, see Finalize().
Post-finalize calls will always return the same value.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>RegisterCollisionGeometry(), Finalize()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetConstraintActiveStatus">
<span class="sig-name descname"><span class="pre">GetConstraintActiveStatus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context" title="pydrake.systems.framework.Context"><span class="pre">pydrake.systems.framework.Context</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">id</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.MultibodyConstraintId" title="pydrake.multibody.tree.MultibodyConstraintId"><span class="pre">pydrake.multibody.tree.MultibodyConstraintId</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetConstraintActiveStatus" title="Link to this definition"></a></dt>
<dd><p>Returns the active status of the constraint given by <code class="docutils literal notranslate"><span class="pre">id</span></code> in
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the MultibodyPlant has not been finalized.</strong> – </p></li>
<li><p><strong>RuntimeError if id does not belong to any multibody constraint</strong> – </p></li>
<li><p><strong>in context.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetConstraintIds">
<span class="sig-name descname"><span class="pre">GetConstraintIds</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.MultibodyConstraintId" title="pydrake.multibody.tree.MultibodyConstraintId"><span class="pre">pydrake.multibody.tree.MultibodyConstraintId</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetConstraintIds" title="Link to this definition"></a></dt>
<dd><p>Returns a list of all constraint identifiers. The returned vector
becomes invalid after any calls to Add*Constraint() or
RemoveConstraint().</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetDefaultContactSurfaceRepresentation">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">GetDefaultContactSurfaceRepresentation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">time_step</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.HydroelasticContactRepresentation" title="pydrake.geometry.HydroelasticContactRepresentation"><span class="pre">pydrake.geometry.HydroelasticContactRepresentation</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetDefaultContactSurfaceRepresentation" title="Link to this definition"></a></dt>
<dd><p>Return the default value for contact representation, given the desired
time step. Discrete systems default to use polygons; continuous
systems default to use triangles.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetDefaultDistanceConstraintParams">
<span class="sig-name descname"><span class="pre">GetDefaultDistanceConstraintParams</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">dict</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.MultibodyConstraintId" title="pydrake.multibody.tree.MultibodyConstraintId"><span class="pre">pydrake.multibody.tree.MultibodyConstraintId</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="#pydrake.multibody.plant.DistanceConstraintParams" title="pydrake.multibody.plant.DistanceConstraintParams"><span class="pre">pydrake.multibody.plant.DistanceConstraintParams</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetDefaultDistanceConstraintParams" title="Link to this definition"></a></dt>
<dd><p>Returns all default distance constraint parameters, as registered via
AddDistanceConstraint(). See GetDistanceConstraintParams() and
SetDistanceConstraintParams() for working with parameters stored in a
context.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetDefaultFloatingBaseBodyPose">
<span class="sig-name descname"><span class="pre">GetDefaultFloatingBaseBodyPose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">body</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody" title="pydrake.multibody.tree.RigidBody"><span class="pre">pydrake.multibody.tree.RigidBody</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.math.html#pydrake.math.RigidTransform" title="pydrake.math.RigidTransform"><span class="pre">pydrake.math.RigidTransform</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetDefaultFloatingBaseBodyPose" title="Link to this definition"></a></dt>
<dd><p>Gets the provisional default pose of <code class="docutils literal notranslate"><span class="pre">body</span></code> as set by
SetDefaultFloatingBaseBodyPose(). If no pose was specified for
<code class="docutils literal notranslate"><span class="pre">body</span></code>, returns the identity pose. This may be called pre- or
post-Finalize().</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This value is only meaningful for bodies that turn out to be
floating base bodies after Finalize(). If called on any other
body, the result simply echoes whatever provisional pose was set
in SetDefaultFloatingBaseBodyPose() but has no other effect. Use
the Joint API to get the default pose for any body that has an
explicitly-defined joint to its parent body.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Post-Finalize(), a floating base body’s default pose may be set
either by SetDefaultFloatingBaseBodyPose() or by setting the
default pose directly through the Joint API applied to the
automatically-added floating joint.
GetDefaultFloatingBaseBodyPose() will return the most-recent value
set by either method.</p>
</div>
<p>See mbp_working_with_free_bodies “above for details”.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body</span></code>:</dt><dd><p>RigidBody whose default pose will be retrieved.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">X_WB</span></code>:</dt><dd><p>The default pose of the floating base body B in World. Not
meaningful if <code class="docutils literal notranslate"><span class="pre">body</span></code> is not a floating base body.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetDefaultFreeBodyPose">
<span class="sig-name descname"><span class="pre">GetDefaultFreeBodyPose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">body</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody" title="pydrake.multibody.tree.RigidBody"><span class="pre">pydrake.multibody.tree.RigidBody</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.math.html#pydrake.math.RigidTransform" title="pydrake.math.RigidTransform"><span class="pre">pydrake.math.RigidTransform</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetDefaultFreeBodyPose" title="Link to this definition"></a></dt>
<dd><p>(Deprecated.)</p>
<dl class="simple">
<dt>Deprecated:</dt><dd><p>Use GetDefaultFloatingBaseBodyPose() instead. This will be removed
from Drake on or after 2026-06-01.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetDefaultPositions">
<span class="sig-name descname"><span class="pre">GetDefaultPositions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetDefaultPositions" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetDefaultPositions(self: pydrake.multibody.plant.MultibodyPlant) -&gt; numpy.ndarray[numpy.float64[m, 1]]</p></li>
</ol>
<p>Gets the default positions for the plant, which can be changed via
SetDefaultPositions().</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if the plant is not finalized.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>GetDefaultPositions(self: pydrake.multibody.plant.MultibodyPlant, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; numpy.ndarray[numpy.float64[m, 1]]</p></li>
</ol>
<p>Gets the default positions for the plant for a given model instance,
which can be changed via SetDefaultPositions().</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the plant is not finalized</strong><strong>, or </strong><strong>if the</strong> – </p></li>
<li><p><strong>model_instance is invalid</strong><strong>,</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetDistanceConstraintParams">
<span class="sig-name descname"><span class="pre">GetDistanceConstraintParams</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetDistanceConstraintParams" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetDistanceConstraintParams(self: pydrake.multibody.plant.MultibodyPlant, context: pydrake.systems.framework.Context) -&gt; dict[pydrake.multibody.tree.MultibodyConstraintId, pydrake.multibody.plant.DistanceConstraintParams]</p></li>
</ol>
<p>Returns all distance constraint parameters currently stored in
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<ol class="arabic simple" start="2">
<li><p>GetDistanceConstraintParams(self: pydrake.multibody.plant.MultibodyPlant, context: pydrake.systems.framework.Context, id: pydrake.multibody.tree.MultibodyConstraintId) -&gt; pydrake.multibody.plant.DistanceConstraintParams</p></li>
</ol>
<p>Returns a constant reference to the parameters for the distance
constraint that corresponds to identifier <code class="docutils literal notranslate"><span class="pre">id</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>if id is not a valid identifier for a distance constraint.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetEffortLowerLimits">
<span class="sig-name descname"><span class="pre">GetEffortLowerLimits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetEffortLowerLimits" title="Link to this definition"></a></dt>
<dd><p>Returns a vector of size <code class="docutils literal notranslate"><span class="pre">num_actuated_dofs()</span></code> containing the lower
effort limits for every actuator. Any unbounded or unspecified limits
will be -∞. The returned vector is indexed by JointActuatorIndex, see
JointActuator::index().</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>GetEffortUpperLimits()</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetEffortUpperLimits">
<span class="sig-name descname"><span class="pre">GetEffortUpperLimits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetEffortUpperLimits" title="Link to this definition"></a></dt>
<dd><p>Returns a vector of size <code class="docutils literal notranslate"><span class="pre">num_actuated_dofs()</span></code> containing the upper
effort limits for every actuator. Any unbounded or unspecified limits
will be +∞. The returned vector is indexed by JointActuatorIndex, see
JointActuator::index().</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>GetEffortLowerLimits()</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetFloatingBaseBodies">
<span class="sig-name descname"><span class="pre">GetFloatingBaseBodies</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">set</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.BodyIndex" title="pydrake.multibody.tree.BodyIndex"><span class="pre">pydrake.multibody.tree.BodyIndex</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetFloatingBaseBodies" title="Link to this definition"></a></dt>
<dd><p>Returns the set of body indices corresponding to the floating base
bodies in the model, in no particular order. See
mbp_working_with_free_bodies “above for details”.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize</strong><strong>, </strong><strong>see Finalize</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetFrameByName">
<span class="sig-name descname"><span class="pre">GetFrameByName</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetFrameByName" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetFrameByName(self: pydrake.multibody.plant.MultibodyPlant, name: str) -&gt; pydrake.multibody.tree.Frame</p></li>
</ol>
<p>Returns a constant reference to a frame that is identified by the
string <code class="docutils literal notranslate"><span class="pre">name</span></code> in <code class="docutils literal notranslate"><span class="pre">this</span></code> model.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if there is no frame with the requested name.</strong> – </p></li>
<li><p><strong>RuntimeError if the frame name occurs in multiple model instances.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>HasFrameNamed() to query if there exists a frame in <code class="docutils literal notranslate"><span class="pre">this</span></code> model
with a given specified name.</p>
</div>
<ol class="arabic simple" start="2">
<li><p>GetFrameByName(self: pydrake.multibody.plant.MultibodyPlant, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; pydrake.multibody.tree.Frame</p></li>
</ol>
<p>Returns a constant reference to the frame that is uniquely identified
by the string <code class="docutils literal notranslate"><span class="pre">name</span></code> in <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if there is no frame with the requested name.</strong> – </p></li>
<li><p><strong>RuntimeError if model_instance is not valid for this model.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>HasFrameNamed() to query if there exists a frame in <code class="docutils literal notranslate"><span class="pre">this</span></code> model
with a given specified name.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetFrameIndices">
<span class="sig-name descname"><span class="pre">GetFrameIndices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.FrameIndex" title="pydrake.multibody.tree.FrameIndex"><span class="pre">pydrake.multibody.tree.FrameIndex</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetFrameIndices" title="Link to this definition"></a></dt>
<dd><p>Returns a list of frame indices associated with <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetFreeBodyPose">
<span class="sig-name descname"><span class="pre">GetFreeBodyPose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context" title="pydrake.systems.framework.Context"><span class="pre">pydrake.systems.framework.Context</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">body</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody" title="pydrake.multibody.tree.RigidBody"><span class="pre">pydrake.multibody.tree.RigidBody</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.math.html#pydrake.math.RigidTransform" title="pydrake.math.RigidTransform"><span class="pre">pydrake.math.RigidTransform</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetFreeBodyPose" title="Link to this definition"></a></dt>
<dd><p>For any free body’s 6-dof joint, gets the pose X_JpJc of the child
frame Jc in its parent frame Jp.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Unless <code class="docutils literal notranslate"><span class="pre">body</span></code> is a floating base body, the parent frame Jp is
not necessarily the World frame W, and the child frame Jc is not
necessarily the body frame B.</p>
</div>
<p>See mbp_working_with_free_bodies “above for details”.</p>
<dl class="simple">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">X_JpJc</span></code>:</dt><dd><p>The current pose of child frame Jc in its parent frame Jp. Returns
X_WB if <code class="docutils literal notranslate"><span class="pre">body</span></code> B is a floating base body.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if called pre-finalize.</strong> – </p></li>
<li><p><strong>RuntimeError if body is not a free body.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetJointActuatorByName">
<span class="sig-name descname"><span class="pre">GetJointActuatorByName</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetJointActuatorByName" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetJointActuatorByName(self: pydrake.multibody.plant.MultibodyPlant, name: str) -&gt; pydrake.multibody.tree.JointActuator</p></li>
</ol>
<p>Returns a constant reference to an actuator that is identified by the
string <code class="docutils literal notranslate"><span class="pre">name</span></code> in <code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if there is no actuator with the requested name.</strong> – </p></li>
<li><p><strong>RuntimeError if the actuator name occurs in multiple model</strong> – </p></li>
<li><p><strong>instances.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>HasJointActuatorNamed() to query if there exists an actuator in
<code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant with a given specified name.</p>
</div>
<ol class="arabic simple" start="2">
<li><p>GetJointActuatorByName(self: pydrake.multibody.plant.MultibodyPlant, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; pydrake.multibody.tree.JointActuator</p></li>
</ol>
<p>Returns a constant reference to the actuator that is uniquely
identified by the string <code class="docutils literal notranslate"><span class="pre">name</span></code> and <code class="docutils literal notranslate"><span class="pre">model_instance</span></code> in <code class="docutils literal notranslate"><span class="pre">this</span></code>
MultibodyPlant.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if there is no actuator with the requested name.</strong> – </p></li>
<li><p><strong>RuntimeError if model_instance is not valid for this model.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>HasJointActuatorNamed() to query if there exists an actuator in
<code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant with a given specified name.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetJointActuatorIndices">
<span class="sig-name descname"><span class="pre">GetJointActuatorIndices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetJointActuatorIndices" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetJointActuatorIndices(self: pydrake.multibody.plant.MultibodyPlant) -&gt; list[pydrake.multibody.tree.JointActuatorIndex]</p></li>
</ol>
<p>Returns a list of all joint actuator indices. The vector is ordered by
monotonically increasing JointActuatorIndex, but the indices will in
general not be consecutive due to actuators that were removed.</p>
<ol class="arabic simple" start="2">
<li><p>GetJointActuatorIndices(self: pydrake.multibody.plant.MultibodyPlant, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; list[pydrake.multibody.tree.JointActuatorIndex]</p></li>
</ol>
<p>Returns a list of joint actuator indices associated with
<code class="docutils literal notranslate"><span class="pre">model_instance</span></code>. The vector is ordered by monotonically increasing
JointActuatorIndex.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetJointByName">
<span class="sig-name descname"><span class="pre">GetJointByName</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Joint" title="pydrake.multibody.tree.Joint"><span class="pre">pydrake.multibody.tree.Joint</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetJointByName" title="Link to this definition"></a></dt>
<dd><p>Returns a constant reference to a joint that is identified by the
string <code class="docutils literal notranslate"><span class="pre">name</span></code> in <code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant. If the optional template
argument is supplied, then the returned value is downcast to the
specified <code class="docutils literal notranslate"><span class="pre">JointType</span></code>.</p>
<dl class="simple">
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">JointType</span></code>:</dt><dd><p>The specific type of the Joint to be retrieved. It must be a
subclass of Joint.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the named joint is not</strong><strong> of </strong><strong>type JointType</strong><strong> or </strong><strong>if</strong> – </p></li>
<li><p><strong>there is no Joint with that name.</strong> – </p></li>
<li><p><strong>RuntimeError if model_instance is not valid for this model.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>HasJointNamed() to query if there exists a joint in <code class="docutils literal notranslate"><span class="pre">this</span></code>
MultibodyPlant with a given specified name.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetJointIndices">
<span class="sig-name descname"><span class="pre">GetJointIndices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetJointIndices" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetJointIndices(self: pydrake.multibody.plant.MultibodyPlant) -&gt; list[pydrake.multibody.tree.JointIndex]</p></li>
</ol>
<p>Returns a list of all joint indices. The vector is ordered by
monotonically increasing JointIndex, but the indices will in general
not be consecutive due to joints that were removed.</p>
<ol class="arabic simple" start="2">
<li><p>GetJointIndices(self: pydrake.multibody.plant.MultibodyPlant, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; list[pydrake.multibody.tree.JointIndex]</p></li>
</ol>
<p>Returns a list of joint indices associated with <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetModelInstanceByName">
<span class="sig-name descname"><span class="pre">GetModelInstanceByName</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetModelInstanceByName" title="Link to this definition"></a></dt>
<dd><p>Returns the index to the model instance that is uniquely identified by
the string <code class="docutils literal notranslate"><span class="pre">name</span></code> in <code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if there is no instance with the requested name.</strong> – </p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>HasModelInstanceNamed() to query if there exists an instance in
<code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant with a given specified name.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetModelInstanceName">
<span class="sig-name descname"><span class="pre">GetModelInstanceName</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">str</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetModelInstanceName" title="Link to this definition"></a></dt>
<dd><p>Returns the name of a <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError when model_instance does not correspond to a</strong> – </p></li>
<li><p><strong>model in this model.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetMutableJointByName">
<span class="sig-name descname"><span class="pre">GetMutableJointByName</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Joint" title="pydrake.multibody.tree.Joint"><span class="pre">pydrake.multibody.tree.Joint</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetMutableJointByName" title="Link to this definition"></a></dt>
<dd><p>Returns a constant reference to a joint that is identified by the
string <code class="docutils literal notranslate"><span class="pre">name</span></code> in <code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant. If the optional template
argument is supplied, then the returned value is downcast to the
specified <code class="docutils literal notranslate"><span class="pre">JointType</span></code>.</p>
<dl class="simple">
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">JointType</span></code>:</dt><dd><p>The specific type of the Joint to be retrieved. It must be a
subclass of Joint.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the named joint is not</strong><strong> of </strong><strong>type JointType</strong><strong> or </strong><strong>if</strong> – </p></li>
<li><p><strong>there is no Joint with that name.</strong> – </p></li>
<li><p><strong>RuntimeError if model_instance is not valid for this model.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>HasJointNamed() to query if there exists a joint in <code class="docutils literal notranslate"><span class="pre">this</span></code>
MultibodyPlant with a given specified name.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetPositionLowerLimits">
<span class="sig-name descname"><span class="pre">GetPositionLowerLimits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetPositionLowerLimits" title="Link to this definition"></a></dt>
<dd><p>Returns a vector of size <code class="docutils literal notranslate"><span class="pre">num_positions()</span></code> containing the lower
position limits for every generalized position coordinate. These
include joint and free body coordinates. Any unbounded or unspecified
limits will be -infinity.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetPositionNames">
<span class="sig-name descname"><span class="pre">GetPositionNames</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetPositionNames" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetPositionNames(self: pydrake.multibody.plant.MultibodyPlant, add_model_instance_prefix: bool = True, always_add_suffix: bool = True) -&gt; list[str]</p></li>
</ol>
<p>Returns a list of string names corresponding to each element of the
position vector. These strings take the form
<code class="docutils literal notranslate"><span class="pre">{model_instance_name}_{joint_name}_{joint_position_suffix}</span></code>, but
the prefix and suffix may optionally be withheld using
<code class="docutils literal notranslate"><span class="pre">add_model_instance_prefix</span></code> and <code class="docutils literal notranslate"><span class="pre">always_add_suffix</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">always_add_suffix</span></code>:</dt><dd><p>(optional). If true, then the suffix is always added. If false,
then the suffix is only added for joints that have more than one
position (in this case, not adding would lead to ambiguity).</p>
</dd>
</dl>
<p>The returned names are guaranteed to be unique if
<code class="docutils literal notranslate"><span class="pre">add_model_instance_prefix</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code> (the default).</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if the plant is not finalized.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>GetPositionNames(self: pydrake.multibody.plant.MultibodyPlant, model_instance: pydrake.multibody.tree.ModelInstanceIndex, add_model_instance_prefix: bool = False, always_add_suffix: bool = True) -&gt; list[str]</p></li>
</ol>
<p>Returns a list of string names corresponding to each element of the
position vector. These strings take the form
<code class="docutils literal notranslate"><span class="pre">{model_instance_name}_{joint_name}_{joint_position_suffix}</span></code>, but
the prefix and suffix may optionally be withheld using
<code class="docutils literal notranslate"><span class="pre">add_model_instance_prefix</span></code> and <code class="docutils literal notranslate"><span class="pre">always_add_suffix</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">always_add_suffix</span></code>:</dt><dd><p>(optional). If true, then the suffix is always added. If false,
then the suffix is only added for joints that have more than one
position (in this case, not adding would lead to ambiguity).</p>
</dd>
</dl>
<p>The returned names are guaranteed to be unique.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the plant is not finalized</strong><strong> or </strong><strong>if the</strong> – </p></li>
<li><p><strong>model_instance` is invalid</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetPositions">
<span class="sig-name descname"><span class="pre">GetPositions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetPositions" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetPositions(self: pydrake.multibody.plant.MultibodyPlant, context: pydrake.systems.framework.Context) -&gt; numpy.ndarray[numpy.float64[m, 1]]</p></li>
</ol>
<p>Returns a const vector reference to the vector of generalized
positions q in a given Context.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method returns a reference to existing data, exhibits
constant i.e., O(1) time complexity, and runs very quickly.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if context does not correspond to the Context for</strong> – </p></li>
<li><p><strong>a multibody model.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>GetPositions(self: pydrake.multibody.plant.MultibodyPlant, context: pydrake.systems.framework.Context, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; numpy.ndarray[numpy.float64[m, 1]]</p></li>
</ol>
<p>Returns a vector containing the generalized positions q of a specified
model instance in a given Context.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Returns a dense vector of dimension
<code class="docutils literal notranslate"><span class="pre">num_positions(model_instance)</span></code> associated with
<code class="docutils literal notranslate"><span class="pre">model_instance</span></code> by copying from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if context does not correspond to the Context for</strong> – </p></li>
<li><p><strong>a multibody model</strong><strong> or </strong><strong>model_instance is invalid.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetPositionsAndVelocities">
<span class="sig-name descname"><span class="pre">GetPositionsAndVelocities</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetPositionsAndVelocities" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetPositionsAndVelocities(self: pydrake.multibody.plant.MultibodyPlant, context: pydrake.systems.framework.Context) -&gt; numpy.ndarray[numpy.float64[m, 1]]</p></li>
</ol>
<p>Returns a const vector reference <code class="docutils literal notranslate"><span class="pre">[q;</span> <span class="pre">v]</span></code> to the generalized
positions q and generalized velocities v in a given Context.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method returns a reference to existing data, exhibits
constant i.e., O(1) time complexity, and runs very quickly.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if context does not correspond to the Context for</strong> – </p></li>
<li><p><strong>a multibody model.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>GetPositionsAndVelocities(self: pydrake.multibody.plant.MultibodyPlant, context: pydrake.systems.framework.Context, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; numpy.ndarray[numpy.float64[m, 1]]</p></li>
</ol>
<p>Returns a vector <code class="docutils literal notranslate"><span class="pre">[q;</span> <span class="pre">v]</span></code> containing the generalized positions q and
generalized velocities v of a specified model instance in a given
Context.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Returns a dense vector of dimension
<code class="docutils literal notranslate"><span class="pre">num_positions(model_instance)</span> <span class="pre">+</span> <span class="pre">num_velocities(model_instance)</span></code>
associated with <code class="docutils literal notranslate"><span class="pre">model_instance</span></code> by copying from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if context does not correspond to the Context for</strong> – </p></li>
<li><p><strong>a multibody model</strong><strong> or </strong><strong>model_instance is invalid.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetPositionsFromArray">
<span class="sig-name descname"><span class="pre">GetPositionsFromArray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetPositionsFromArray" title="Link to this definition"></a></dt>
<dd><p>Returns a vector of generalized positions for <code class="docutils literal notranslate"><span class="pre">model_instance</span></code> from
a vector <code class="docutils literal notranslate"><span class="pre">q_array</span></code> of generalized positions for the entire model
model. This method throws an exception if <code class="docutils literal notranslate"><span class="pre">q</span></code> is not of size
MultibodyPlant::num_positions().</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetPositionUpperLimits">
<span class="sig-name descname"><span class="pre">GetPositionUpperLimits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetPositionUpperLimits" title="Link to this definition"></a></dt>
<dd><p>Upper limit analog of GetPositionLowerLimits(), where any unbounded or
unspecified limits will be +infinity.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>GetPositionLowerLimits() for more information.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetRigidBodyByName">
<span class="sig-name descname"><span class="pre">GetRigidBodyByName</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetRigidBodyByName" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetRigidBodyByName(self: pydrake.multibody.plant.MultibodyPlant, name: str) -&gt; pydrake.multibody.tree.RigidBody</p></li>
</ol>
<p>Returns a constant reference to a rigid body that is identified by the
string <code class="docutils literal notranslate"><span class="pre">name</span></code> in <code class="docutils literal notranslate"><span class="pre">this</span></code> model.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if there is no body with the requested name.</strong> – </p></li>
<li><p><strong>RuntimeError if the body name occurs in multiple model instances.</strong> – </p></li>
<li><p><strong>RuntimeError if the requested body is not a RigidBody.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>HasBodyNamed() to query if there exists a body in <code class="docutils literal notranslate"><span class="pre">this</span></code> model
with a given specified name.</p>
</div>
<ol class="arabic simple" start="2">
<li><p>GetRigidBodyByName(self: pydrake.multibody.plant.MultibodyPlant, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; pydrake.multibody.tree.RigidBody</p></li>
</ol>
<p>Returns a constant reference to the rigid body that is uniquely
identified by the string <code class="docutils literal notranslate"><span class="pre">name</span></code> in <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if there is no body with the requested name.</strong> – </p></li>
<li><p><strong>RuntimeError if the requested body is not a RigidBody.</strong> – </p></li>
<li><p><strong>RuntimeError if model_instance is not valid for this model.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>HasBodyNamed() to query if there exists a body in <code class="docutils literal notranslate"><span class="pre">this</span></code> model
with a given specified name.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetStateNames">
<span class="sig-name descname"><span class="pre">GetStateNames</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetStateNames" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetStateNames(self: pydrake.multibody.plant.MultibodyPlant, add_model_instance_prefix: bool = True) -&gt; list[str]</p></li>
</ol>
<p>Returns a list of string names corresponding to each element of the
multibody state vector. These strings take the form
<code class="docutils literal notranslate"><span class="pre">{model_instance_name}_{joint_name}_{joint_position_suffix</span> <span class="pre">|</span>
<span class="pre">joint_velocity_suffix}</span></code>, but the prefix may optionally be withheld
using <code class="docutils literal notranslate"><span class="pre">add_model_instance_prefix</span></code>.</p>
<p>The returned names are guaranteed to be unique if
<code class="docutils literal notranslate"><span class="pre">add_model_instance_prefix</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code> (the default).</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if the plant is not finalized.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>GetStateNames(self: pydrake.multibody.plant.MultibodyPlant, model_instance: pydrake.multibody.tree.ModelInstanceIndex, add_model_instance_prefix: bool = False) -&gt; list[str]</p></li>
</ol>
<p>Returns a list of string names corresponding to each element of the
multibody state vector. These strings take the form
<code class="docutils literal notranslate"><span class="pre">{model_instance_name}_{joint_name}_{joint_position_suffix</span> <span class="pre">|</span>
<span class="pre">joint_velocity_suffix}</span></code>, but the prefix may optionally be withheld
using <code class="docutils literal notranslate"><span class="pre">add_model_instance_prefix</span></code>.</p>
<p>The returned names are guaranteed to be unique.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the plant is not finalized</strong><strong> or </strong><strong>if the</strong> – </p></li>
<li><p><strong>model_instance` is invalid</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetTopologyGraphvizString">
<span class="sig-name descname"><span class="pre">GetTopologyGraphvizString</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">str</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetTopologyGraphvizString" title="Link to this definition"></a></dt>
<dd><p>Returns a Graphviz string describing the topology of this plant. To
render the string, use the Graphviz tool, <code class="docutils literal notranslate"><span class="pre">dot</span></code>.
<a class="reference external" href="http://www.graphviz.org/">http://www.graphviz.org/</a></p>
<p>Note: this method can be called either before or after <code class="docutils literal notranslate"><span class="pre">Finalize()</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetUniqueFloatingBaseBodyOrThrow">
<span class="sig-name descname"><span class="pre">GetUniqueFloatingBaseBodyOrThrow</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody" title="pydrake.multibody.tree.RigidBody"><span class="pre">pydrake.multibody.tree.RigidBody</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetUniqueFloatingBaseBodyOrThrow" title="Link to this definition"></a></dt>
<dd><p>If there is a single base body in the model given by
<code class="docutils literal notranslate"><span class="pre">model_instance</span></code>, and that body is a floating base body, returns
that floating base body. Otherwise, throws an exception. Use
HasUniqueFloatingBaseBody() to check first.</p>
<p>See mbp_working_with_free_bodies “above for details”.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if called pre-finalize.</strong> – </p></li>
<li><p><strong>RuntimeError if model_instance is not valid.</strong> – </p></li>
<li><p><strong>RuntimeError if !HasUniqueFloatingBaseBody</strong><strong>(</strong><strong>model_instance</strong><strong>)</strong><strong>.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>HasUniqueFloatingBaseBody(), GetFloatingBaseBodies()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetUniqueFreeBaseBodyOrThrow">
<span class="sig-name descname"><span class="pre">GetUniqueFreeBaseBodyOrThrow</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody" title="pydrake.multibody.tree.RigidBody"><span class="pre">pydrake.multibody.tree.RigidBody</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetUniqueFreeBaseBodyOrThrow" title="Link to this definition"></a></dt>
<dd><p>(Deprecated.)</p>
<dl class="simple">
<dt>Deprecated:</dt><dd><p>Use GetUniqueFloatingBaseBodyOrThrow() instead. This will be
removed from Drake on or after 2026-06-01.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetVelocities">
<span class="sig-name descname"><span class="pre">GetVelocities</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetVelocities" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetVelocities(self: pydrake.multibody.plant.MultibodyPlant, context: pydrake.systems.framework.Context) -&gt; numpy.ndarray[numpy.float64[m, 1]]</p></li>
</ol>
<p>Returns a const vector reference to the generalized velocities v in a
given Context.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method returns a reference to existing data, exhibits
constant i.e., O(1) time complexity, and runs very quickly.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if context does not correspond to the Context for</strong> – </p></li>
<li><p><strong>a multibody model.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>GetVelocities(self: pydrake.multibody.plant.MultibodyPlant, context: pydrake.systems.framework.Context, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; numpy.ndarray[numpy.float64[m, 1]]</p></li>
</ol>
<p>Returns a vector containing the generalized velocities v of a
specified model instance in a given Context.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>returns a dense vector of dimension
<code class="docutils literal notranslate"><span class="pre">num_velocities(model_instance)</span></code> associated with
<code class="docutils literal notranslate"><span class="pre">model_instance</span></code> by copying from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if context does not correspond to the Context for</strong> – </p></li>
<li><p><strong>a multibody model</strong><strong> or </strong><strong>model_instance is invalid.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetVelocitiesFromArray">
<span class="sig-name descname"><span class="pre">GetVelocitiesFromArray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetVelocitiesFromArray" title="Link to this definition"></a></dt>
<dd><p>Returns a vector of generalized velocities for <code class="docutils literal notranslate"><span class="pre">model_instance</span></code> from
a vector <code class="docutils literal notranslate"><span class="pre">v</span></code> of generalized velocities for the entire MultibodyPlant
model. This method throws an exception if the input array is not of
size MultibodyPlant::num_velocities().</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetVelocityLowerLimits">
<span class="sig-name descname"><span class="pre">GetVelocityLowerLimits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetVelocityLowerLimits" title="Link to this definition"></a></dt>
<dd><p>Returns a vector of size <code class="docutils literal notranslate"><span class="pre">num_velocities()</span></code> containing the lower
velocity limits for every generalized velocity coordinate. These
include joint and free body coordinates. Any unbounded or unspecified
limits will be -infinity.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetVelocityNames">
<span class="sig-name descname"><span class="pre">GetVelocityNames</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetVelocityNames" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetVelocityNames(self: pydrake.multibody.plant.MultibodyPlant, add_model_instance_prefix: bool = True, always_add_suffix: bool = True) -&gt; list[str]</p></li>
</ol>
<p>Returns a list of string names corresponding to each element of the
velocity vector. These strings take the form
<code class="docutils literal notranslate"><span class="pre">{model_instance_name}_{joint_name}_{joint_velocity_suffix}</span></code>, but
the prefix and suffix may optionally be withheld using
<code class="docutils literal notranslate"><span class="pre">add_model_instance_prefix</span></code> and <code class="docutils literal notranslate"><span class="pre">always_add_suffix</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">always_add_suffix</span></code>:</dt><dd><p>(optional). If true, then the suffix is always added. If false,
then the suffix is only added for joints that have more than one
position (in this case, not adding would lead to ambiguity).</p>
</dd>
</dl>
<p>The returned names are guaranteed to be unique if
<code class="docutils literal notranslate"><span class="pre">add_model_instance_prefix</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code> (the default).</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if the plant is not finalized.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>GetVelocityNames(self: pydrake.multibody.plant.MultibodyPlant, model_instance: pydrake.multibody.tree.ModelInstanceIndex, add_model_instance_prefix: bool = False, always_add_suffix: bool = True) -&gt; list[str]</p></li>
</ol>
<p>Returns a list of string names corresponding to each element of the
velocity vector. These strings take the form
<code class="docutils literal notranslate"><span class="pre">{model_instance_name}_{joint_name}_{joint_velocity_suffix}</span></code>, but
the prefix and suffix may optionally be withheld using
<code class="docutils literal notranslate"><span class="pre">add_model_instance_prefix</span></code> and <code class="docutils literal notranslate"><span class="pre">always_add_suffix</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">always_add_suffix</span></code>:</dt><dd><p>(optional). If true, then the suffix is always added. If false,
then the suffix is only added for joints that have more than one
position (in this case, not adding would lead to ambiguity).</p>
</dd>
</dl>
<p>The returned names are guaranteed to be unique.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the plant is not finalized</strong><strong> or </strong><strong>if the</strong> – </p></li>
<li><p><strong>model_instance` is invalid</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetVelocityUpperLimits">
<span class="sig-name descname"><span class="pre">GetVelocityUpperLimits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetVelocityUpperLimits" title="Link to this definition"></a></dt>
<dd><p>Upper limit analog of GetVelocitysLowerLimits(), where any unbounded
or unspecified limits will be +infinity.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>GetVelocityLowerLimits() for more information.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetVisualGeometriesForBody">
<span class="sig-name descname"><span class="pre">GetVisualGeometriesForBody</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">body</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody" title="pydrake.multibody.tree.RigidBody"><span class="pre">pydrake.multibody.tree.RigidBody</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.GeometryId" title="pydrake.geometry.GeometryId"><span class="pre">pydrake.geometry.GeometryId</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetVisualGeometriesForBody" title="Link to this definition"></a></dt>
<dd><p>Returns an array of GeometryId’s identifying the different visual
geometries for <code class="docutils literal notranslate"><span class="pre">body</span></code> previously registered with a SceneGraph.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method can be called at any time during the lifetime of
<code class="docutils literal notranslate"><span class="pre">this</span></code> plant, either pre- or post-finalize, see Finalize().
Post-finalize calls will always return the same value.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>RegisterVisualGeometry(), Finalize()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.gravity_field">
<span class="sig-name descname"><span class="pre">gravity_field</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.UniformGravityFieldElement" title="pydrake.multibody.tree.UniformGravityFieldElement"><span class="pre">pydrake.multibody.tree.UniformGravityFieldElement</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.gravity_field" title="Link to this definition"></a></dt>
<dd><p>An accessor to the current gravity field.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.has_joint">
<span class="sig-name descname"><span class="pre">has_joint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">joint_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JointIndex" title="pydrake.multibody.tree.JointIndex"><span class="pre">pydrake.multibody.tree.JointIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.has_joint" title="Link to this definition"></a></dt>
<dd><p>Returns true if plant has a joint with unique index <code class="docutils literal notranslate"><span class="pre">joint_index</span></code>.
The value could be false if the joint was removed using RemoveJoint().</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.has_joint_actuator">
<span class="sig-name descname"><span class="pre">has_joint_actuator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">actuator_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JointActuatorIndex" title="pydrake.multibody.tree.JointActuatorIndex"><span class="pre">pydrake.multibody.tree.JointActuatorIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.has_joint_actuator" title="Link to this definition"></a></dt>
<dd><p>Returns true if plant has a joint actuator with unique index
<code class="docutils literal notranslate"><span class="pre">actuator_index</span></code>. The value could be false if the actuator was
removed using RemoveJointActuator().</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.has_sampled_output_ports">
<span class="sig-name descname"><span class="pre">has_sampled_output_ports</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.has_sampled_output_ports" title="Link to this definition"></a></dt>
<dd><p>(Advanced) If <code class="docutils literal notranslate"><span class="pre">this</span></code> plant is continuous (i.e., is_discrete() is
<code class="docutils literal notranslate"><span class="pre">False</span></code>), returns false. If <code class="docutils literal notranslate"><span class="pre">this</span></code> plant is discrete, returns
whether or not the output ports are sampled (change only at a time
step boundary) or live (instantaneously reflect changes to the input
ports). See output_port_sampling “Output port sampling” for details.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.HasBodyNamed">
<span class="sig-name descname"><span class="pre">HasBodyNamed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.HasBodyNamed" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>HasBodyNamed(self: pydrake.multibody.plant.MultibodyPlant, name: str) -&gt; bool</p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if a body named <code class="docutils literal notranslate"><span class="pre">name</span></code> was added to the MultibodyPlant.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddRigidBody().</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if the body name occurs in multiple model instances.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>HasBodyNamed(self: pydrake.multibody.plant.MultibodyPlant, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; bool</p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if a body named <code class="docutils literal notranslate"><span class="pre">name</span></code> was added to the MultibodyPlant
in <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddRigidBody().</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if model_instance is not valid for this model.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.HasFrameNamed">
<span class="sig-name descname"><span class="pre">HasFrameNamed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.HasFrameNamed" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>HasFrameNamed(self: pydrake.multibody.plant.MultibodyPlant, name: str) -&gt; bool</p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if a frame named <code class="docutils literal notranslate"><span class="pre">name</span></code> was added to the model.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddFrame().</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if the frame name occurs in multiple model instances.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>HasFrameNamed(self: pydrake.multibody.plant.MultibodyPlant, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; bool</p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if a frame named <code class="docutils literal notranslate"><span class="pre">name</span></code> was added to
<code class="docutils literal notranslate"><span class="pre">model_instance</span></code>.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddFrame().</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if model_instance is not valid for this model.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.HasJointActuatorNamed">
<span class="sig-name descname"><span class="pre">HasJointActuatorNamed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.HasJointActuatorNamed" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>HasJointActuatorNamed(self: pydrake.multibody.plant.MultibodyPlant, name: str) -&gt; bool</p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if an actuator named <code class="docutils literal notranslate"><span class="pre">name</span></code> was added to this model.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddJointActuator().</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the actuator name occurs in multiple model</strong> – </p></li>
<li><p><strong>instances.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>HasJointActuatorNamed(self: pydrake.multibody.plant.MultibodyPlant, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; bool</p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if an actuator named <code class="docutils literal notranslate"><span class="pre">name</span></code> was added to
<code class="docutils literal notranslate"><span class="pre">model_instance</span></code>.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddJointActuator().</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if model_instance is not valid for this model.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.HasJointNamed">
<span class="sig-name descname"><span class="pre">HasJointNamed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.HasJointNamed" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>HasJointNamed(self: pydrake.multibody.plant.MultibodyPlant, name: str) -&gt; bool</p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if a joint named <code class="docutils literal notranslate"><span class="pre">name</span></code> was added to this model.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddJoint().</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if the joint name occurs in multiple model instances.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>HasJointNamed(self: pydrake.multibody.plant.MultibodyPlant, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; bool</p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if a joint named <code class="docutils literal notranslate"><span class="pre">name</span></code> was added to
<code class="docutils literal notranslate"><span class="pre">model_instance</span></code>.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddJoint().</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if model_instance is not valid for this model.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.HasModelInstanceNamed">
<span class="sig-name descname"><span class="pre">HasModelInstanceNamed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.HasModelInstanceNamed" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if a model instance named <code class="docutils literal notranslate"><span class="pre">name</span></code> was added to this
model.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddModelInstance().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.HasUniqueFloatingBaseBody">
<span class="sig-name descname"><span class="pre">HasUniqueFloatingBaseBody</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.HasUniqueFloatingBaseBody" title="Link to this definition"></a></dt>
<dd><p>Returns true if there is a single base body in the model given by
<code class="docutils literal notranslate"><span class="pre">model_instance</span></code>, and that body is a floating base body.</p>
<p>See mbp_working_with_free_bodies “above for details”.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if called pre-finalize.</strong> – </p></li>
<li><p><strong>RuntimeError if model_instance is not valid.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>GetUniqueFloatingBaseBodyOrThrow()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.HasUniqueFreeBaseBody">
<span class="sig-name descname"><span class="pre">HasUniqueFreeBaseBody</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.HasUniqueFreeBaseBody" title="Link to this definition"></a></dt>
<dd><p>(Deprecated.)</p>
<dl class="simple">
<dt>Deprecated:</dt><dd><p>Use HasUniqueFloatingBaseBody() instead. This will be removed from
Drake on or after 2026-06-01.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.is_finalized">
<span class="sig-name descname"><span class="pre">is_finalized</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.is_finalized" title="Link to this definition"></a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if this MultibodyPlant was finalized with a call to
Finalize().</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>Finalize().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.is_gravity_enabled">
<span class="sig-name descname"><span class="pre">is_gravity_enabled</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.is_gravity_enabled" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> iff gravity is enabled for <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>set_gravity_enabled().</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if the model instance is invalid.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.IsAnchored">
<span class="sig-name descname"><span class="pre">IsAnchored</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">body</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody" title="pydrake.multibody.tree.RigidBody"><span class="pre">pydrake.multibody.tree.RigidBody</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.IsAnchored" title="Link to this definition"></a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if <code class="docutils literal notranslate"><span class="pre">body</span></code> is anchored (i.e. the kinematic path
between <code class="docutils literal notranslate"><span class="pre">body</span></code> and the world only contains weld joints.)</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.IsVelocityEqualToQDot">
<span class="sig-name descname"><span class="pre">IsVelocityEqualToQDot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.IsVelocityEqualToQDot" title="Link to this definition"></a></dt>
<dd><p>Returns true iff the generalized velocity v is exactly the time
derivative q̇ of the generalized coordinates q. In this case
MapQDotToVelocity() and MapVelocityToQDot() implement the identity
map. This method is, in the worst case, O(n), where n is the number of
joints.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.MakeActuationMatrix">
<span class="sig-name descname"><span class="pre">MakeActuationMatrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.MakeActuationMatrix" title="Link to this definition"></a></dt>
<dd><p>This method creates an actuation matrix B mapping a vector of
actuation values u into generalized forces <code class="docutils literal notranslate"><span class="pre">tau_u</span> <span class="pre">=</span> <span class="pre">B</span> <span class="pre">*</span> <span class="pre">u</span></code>, where B
is a matrix of size <code class="docutils literal notranslate"><span class="pre">nv</span> <span class="pre">x</span> <span class="pre">nu</span></code> with <code class="docutils literal notranslate"><span class="pre">nu</span></code> equal to
num_actuated_dofs() and <code class="docutils literal notranslate"><span class="pre">nv</span></code> equal to num_velocities(). The vector u
of actuation values is of size num_actuated_dofs(). For a given
JointActuator, <code class="docutils literal notranslate"><span class="pre">u[JointActuator::input_start()]</span></code> stores the value
for the external actuation corresponding to that actuator. <code class="docutils literal notranslate"><span class="pre">tau_u</span></code>
on the other hand is indexed by generalized velocity indices according
to <code class="docutils literal notranslate"><span class="pre">Joint::velocity_start()</span></code>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>B is a permutation matrix. While making a permutation has <code class="docutils literal notranslate"><span class="pre">O(n)</span></code>
complexity, making a full B matrix has <code class="docutils literal notranslate"><span class="pre">O(n²)</span></code> complexity. For
most applications this cost can be neglected but it could become
significant for very large systems.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.MakeActuationMatrixPseudoinverse">
<span class="sig-name descname"><span class="pre">MakeActuationMatrixPseudoinverse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">scipy.sparse.csc_matrix</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.MakeActuationMatrixPseudoinverse" title="Link to this definition"></a></dt>
<dd><p>Creates the pseudoinverse of the actuation matrix B directly (without
requiring an explicit inverse calculation). See MakeActuationMatrix().</p>
<p>Notably, when B is full row rank (the system is fully actuated), then
the pseudoinverse is a true inverse.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.MakeActuatorSelectorMatrix">
<span class="sig-name descname"><span class="pre">MakeActuatorSelectorMatrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.MakeActuatorSelectorMatrix" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>MakeActuatorSelectorMatrix(self: pydrake.multibody.plant.MultibodyPlant, user_to_actuator_index_map: list[pydrake.multibody.tree.JointActuatorIndex]) -&gt; numpy.ndarray[numpy.float64[m, n]]</p></li>
</ol>
<p>This method allows user to map a vector <code class="docutils literal notranslate"><span class="pre">uₛ</span></code> containing the
actuation for a set of selected actuators into the vector u containing
the actuation values for <code class="docutils literal notranslate"><span class="pre">this</span></code> full model. The mapping, or
selection, is returned in the form of a selector matrix Su such that
<code class="docutils literal notranslate"><span class="pre">u</span> <span class="pre">=</span> <span class="pre">Su⋅uₛ</span></code>. The size nₛ of uₛ is always smaller or equal than the
size of the full vector of actuation values u. That is, a user might
be interested in only a given subset of actuators in the model.</p>
<p>This selection matrix is particularly useful when adding PID control
on a portion of the state, see systems::controllers::PidController.</p>
<p>A user specifies the preferred order in uₛ via
<code class="docutils literal notranslate"><span class="pre">user_to_actuator_index_map</span></code>. The actuation values in uₛ are a
concatenation of the values for each actuator in the order they appear
in <code class="docutils literal notranslate"><span class="pre">user_to_actuator_index_map</span></code>. The actuation value in the full
vector of actuation values <code class="docutils literal notranslate"><span class="pre">u</span></code> for a particular actuator can be
found at offset JointActuator::input_start().</p>
<ol class="arabic simple" start="2">
<li><p>MakeActuatorSelectorMatrix(self: pydrake.multibody.plant.MultibodyPlant, user_to_joint_index_map: list[pydrake.multibody.tree.JointIndex]) -&gt; numpy.ndarray[numpy.float64[m, n]]</p></li>
</ol>
<p>Alternative signature to build an actuation selector matrix <code class="docutils literal notranslate"><span class="pre">Su</span></code>
such that <code class="docutils literal notranslate"><span class="pre">u</span> <span class="pre">=</span> <span class="pre">Su⋅uₛ</span></code>, where u is the vector of actuation values for
the full model (see get_actuation_input_port()) and uₛ is a vector of
actuation values for the actuators acting on the joints listed by
<code class="docutils literal notranslate"><span class="pre">user_to_joint_index_map</span></code>. It is assumed that all joints referenced
by <code class="docutils literal notranslate"><span class="pre">user_to_joint_index_map</span></code> are actuated. See
MakeActuatorSelectorMatrix(const std::vector&lt;JointActuatorIndex&gt;&amp;) for
details.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if any</strong><strong> of </strong><strong>the joints in user_to_joint_index_map</strong> – </p></li>
<li><p><strong>does not have an actuator.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.MakeQDotToVelocityMap">
<span class="sig-name descname"><span class="pre">MakeQDotToVelocityMap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context" title="pydrake.systems.framework.Context"><span class="pre">pydrake.systems.framework.Context</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">scipy.sparse.csc_matrix</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.MakeQDotToVelocityMap" title="Link to this definition"></a></dt>
<dd><p>Returns the matrix <code class="docutils literal notranslate"><span class="pre">N⁺(q)</span></code>, which maps <code class="docutils literal notranslate"><span class="pre">v</span> <span class="pre">=</span> <span class="pre">N⁺(q)⋅q̇</span></code>, as
described in MapQDotToVelocity(). Prefer calling MapQDotToVelocity()
directly; this entry point is provided to support callers that require
the explicit linear form (once q is given) of the relationship. This
method is, in the worst case, O(n), where n is the number of joints.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context containing the state of the model.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>MapVelocityToQDot()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.MakeStateSelectorMatrix">
<span class="sig-name descname"><span class="pre">MakeStateSelectorMatrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">user_to_joint_index_map</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JointIndex" title="pydrake.multibody.tree.JointIndex"><span class="pre">pydrake.multibody.tree.JointIndex</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.MakeStateSelectorMatrix" title="Link to this definition"></a></dt>
<dd><p>This method allows users to map the state of <code class="docutils literal notranslate"><span class="pre">this</span></code> model, x, into a
vector of selected state xₛ with a given preferred ordering. The
mapping, or selection, is returned in the form of a selector matrix Sx
such that <code class="docutils literal notranslate"><span class="pre">xₛ</span> <span class="pre">=</span> <span class="pre">Sx⋅x</span></code>. The size nₛ of xₛ is always smaller or equal
than the size of the full state x. That is, a user might be interested
in only a given portion of the full state x.</p>
<p>This selection matrix is particularly useful when adding PID control
on a portion of the state, see systems::controllers::PidController.</p>
<p>A user specifies the preferred order in xₛ via
<code class="docutils literal notranslate"><span class="pre">user_to_joint_index_map</span></code>. The selected state is built such that
selected positions are followed by selected velocities, as in <code class="docutils literal notranslate"><span class="pre">xₛ</span> <span class="pre">=</span>
<span class="pre">[qₛ,</span> <span class="pre">vₛ]</span></code>. The positions in qₛ are a concatenation of the positions
for each joint in the order they appear in
<code class="docutils literal notranslate"><span class="pre">user_to_joint_index_map</span></code>. That is, the positions for
<code class="docutils literal notranslate"><span class="pre">user_to_joint_index_map[0]</span></code> are first, followed by the positions
for <code class="docutils literal notranslate"><span class="pre">user_to_joint_index_map[1]</span></code>, etc. Similarly for the selected
velocities vₛ.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if there are repeated indices in</strong> – </p></li>
<li><p><strong>user_to_joint_index_map`</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.MakeVelocityToQDotMap">
<span class="sig-name descname"><span class="pre">MakeVelocityToQDotMap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context" title="pydrake.systems.framework.Context"><span class="pre">pydrake.systems.framework.Context</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">scipy.sparse.csc_matrix</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.MakeVelocityToQDotMap" title="Link to this definition"></a></dt>
<dd><p>Returns the matrix <code class="docutils literal notranslate"><span class="pre">N(q)</span></code>, which maps <code class="docutils literal notranslate"><span class="pre">q̇</span> <span class="pre">=</span> <span class="pre">N(q)⋅v</span></code>, as described
in MapVelocityToQDot(). Prefer calling MapVelocityToQDot() directly;
this entry point is provided to support callers that require the
explicit linear form (once q is given) of the relationship. Do not
take the (pseudo-)inverse of <code class="docutils literal notranslate"><span class="pre">N(q)</span></code>; call MakeQDotToVelocityMap
instead. This method is, in the worst case, O(n), where n is the
number of joints.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context containing the state of the model.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>MapVelocityToQDot()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.MapQDotToVelocity">
<span class="sig-name descname"><span class="pre">MapQDotToVelocity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context" title="pydrake.systems.framework.Context"><span class="pre">pydrake.systems.framework.Context</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">qdot</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.MapQDotToVelocity" title="Link to this definition"></a></dt>
<dd><p>Transforms the time derivative <code class="docutils literal notranslate"><span class="pre">qdot</span></code> of the generalized positions
vector <code class="docutils literal notranslate"><span class="pre">q</span></code> (stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>) to generalized velocities <code class="docutils literal notranslate"><span class="pre">v</span></code>.
<cite>v</cite> and <code class="docutils literal notranslate"><span class="pre">q̇</span></code> are related linearly by <code class="docutils literal notranslate"><span class="pre">q̇</span> <span class="pre">=</span> <span class="pre">N(q)⋅v</span></code>. Although
<code class="docutils literal notranslate"><span class="pre">N(q)</span></code> is not necessarily square, its left pseudo-inverse <code class="docutils literal notranslate"><span class="pre">N⁺(q)</span></code>
can be used to invert that relationship without residual error,
provided that <code class="docutils literal notranslate"><span class="pre">qdot</span></code> is in the range space of <code class="docutils literal notranslate"><span class="pre">N(q)</span></code> (that is, if
it <em>could</em> have been produced as <code class="docutils literal notranslate"><span class="pre">q̇</span> <span class="pre">=</span> <span class="pre">N(q)⋅v</span></code> for some <code class="docutils literal notranslate"><span class="pre">v</span></code>).
Using the configuration <code class="docutils literal notranslate"><span class="pre">q</span></code> stored in the given <code class="docutils literal notranslate"><span class="pre">context</span></code> this
method calculates <code class="docutils literal notranslate"><span class="pre">v</span> <span class="pre">=</span> <span class="pre">N⁺(q)⋅q̇</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context containing the state of the model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">qdot</span></code>:</dt><dd><p>A vector containing the time derivatives of the generalized
positions. This method aborts if <code class="docutils literal notranslate"><span class="pre">qdot</span></code> is not of size
num_positions().</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">v</span></code>:</dt><dd><p>A valid (non-null) pointer to a vector in <code class="docutils literal notranslate"><span class="pre">ℛⁿ</span></code> with n the number
of generalized velocities. This method aborts if v is nullptr or
if it is not of size num_velocities().</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>MapVelocityToQDot()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>Mobilizer::MapQDotToVelocity()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.MapVelocityToQDot">
<span class="sig-name descname"><span class="pre">MapVelocityToQDot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context" title="pydrake.systems.framework.Context"><span class="pre">pydrake.systems.framework.Context</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.MapVelocityToQDot" title="Link to this definition"></a></dt>
<dd><p>Transforms generalized velocities v to time derivatives <code class="docutils literal notranslate"><span class="pre">qdot</span></code> of
the generalized positions vector <code class="docutils literal notranslate"><span class="pre">q</span></code> (stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>). <cite>v</cite>
and <code class="docutils literal notranslate"><span class="pre">qdot</span></code> are related linearly by <code class="docutils literal notranslate"><span class="pre">q̇</span> <span class="pre">=</span> <span class="pre">N(q)⋅v</span></code>. Using the
configuration <code class="docutils literal notranslate"><span class="pre">q</span></code> stored in the given <code class="docutils literal notranslate"><span class="pre">context</span></code> this method
calculates <code class="docutils literal notranslate"><span class="pre">q̇</span> <span class="pre">=</span> <span class="pre">N(q)⋅v</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context containing the state of the model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">v</span></code>:</dt><dd><p>A vector of generalized velocities for this model. This method
aborts if v is not of size num_velocities().</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">qdot</span></code>:</dt><dd><p>A valid (non-null) pointer to a vector in <code class="docutils literal notranslate"><span class="pre">ℝⁿ</span></code> with n being the
number of generalized positions in this model, given by
<code class="docutils literal notranslate"><span class="pre">num_positions()</span></code>. This method aborts if <code class="docutils literal notranslate"><span class="pre">qdot</span></code> is nullptr or
if it is not of size num_positions().</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>MapQDotToVelocity()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>Mobilizer::MapVelocityToQDot()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.mutable_deformable_model">
<span class="sig-name descname"><span class="pre">mutable_deformable_model</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.multibody.plant.DeformableModel" title="pydrake.multibody.plant.DeformableModel"><span class="pre">pydrake.multibody.plant.DeformableModel</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.mutable_deformable_model" title="Link to this definition"></a></dt>
<dd><p>Returns a mutable reference to the DeformableModel owned by this
plant.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if the plant is finalized.</strong> – </p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This feature is considered to be <strong>experimental</strong> and may change
or be removed at any time, without any deprecation notice ahead of
time.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.mutable_gravity_field">
<span class="sig-name descname"><span class="pre">mutable_gravity_field</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.UniformGravityFieldElement" title="pydrake.multibody.tree.UniformGravityFieldElement"><span class="pre">pydrake.multibody.tree.UniformGravityFieldElement</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.mutable_gravity_field" title="Link to this definition"></a></dt>
<dd><p>A mutable accessor to the current gravity field.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.num_actuated_dofs">
<span class="sig-name descname"><span class="pre">num_actuated_dofs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.num_actuated_dofs" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>num_actuated_dofs(self: pydrake.multibody.plant.MultibodyPlant) -&gt; int</p></li>
</ol>
<p>Returns the total number of actuated degrees of freedom. That is, the
vector of actuation values u has this size. See AddJointActuator().</p>
<ol class="arabic simple" start="2">
<li><p>num_actuated_dofs(self: pydrake.multibody.plant.MultibodyPlant, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; int</p></li>
</ol>
<p>Returns the total number of actuated degrees of freedom for a specific
model instance. That is, the vector of actuation values u has this
size. See AddJointActuator().</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.num_actuators">
<span class="sig-name descname"><span class="pre">num_actuators</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.num_actuators" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>num_actuators(self: pydrake.multibody.plant.MultibodyPlant) -&gt; int</p></li>
</ol>
<p>Returns the number of joint actuators in the model.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddJointActuator().</p>
</div>
<ol class="arabic simple" start="2">
<li><p>num_actuators(self: pydrake.multibody.plant.MultibodyPlant, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; int</p></li>
</ol>
<p>Returns the number of actuators for a specific model instance.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.num_bodies">
<span class="sig-name descname"><span class="pre">num_bodies</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.num_bodies" title="Link to this definition"></a></dt>
<dd><p>Returns the number of RigidBody elements in the model, including the
“world” RigidBody, which is always part of the model.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddRigidBody().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.num_collision_geometries">
<span class="sig-name descname"><span class="pre">num_collision_geometries</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.num_collision_geometries" title="Link to this definition"></a></dt>
<dd><p>Returns the number of geometries registered for contact modeling. This
method can be called at any time during the lifetime of <code class="docutils literal notranslate"><span class="pre">this</span></code>
plant, either pre- or post-finalize, see Finalize(). Post-finalize
calls will always return the same value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.num_constraints">
<span class="sig-name descname"><span class="pre">num_constraints</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.num_constraints" title="Link to this definition"></a></dt>
<dd><p>Returns the total number of constraints specified by the user.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.num_force_elements">
<span class="sig-name descname"><span class="pre">num_force_elements</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.num_force_elements" title="Link to this definition"></a></dt>
<dd><p>Returns the number of ForceElement objects.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddForceElement().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.num_frames">
<span class="sig-name descname"><span class="pre">num_frames</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.num_frames" title="Link to this definition"></a></dt>
<dd><p>Returns the number of Frame objects in this model. Frames include body
frames associated with each of the bodies, including the <em>world</em> body.
This means the minimum number of frames is one.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.num_joints">
<span class="sig-name descname"><span class="pre">num_joints</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.num_joints" title="Link to this definition"></a></dt>
<dd><p>Returns the number of joints in the model.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddJoint().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.num_model_instances">
<span class="sig-name descname"><span class="pre">num_model_instances</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.num_model_instances" title="Link to this definition"></a></dt>
<dd><p>Returns the number of model instances in the model.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddModelInstance().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.num_multibody_states">
<span class="sig-name descname"><span class="pre">num_multibody_states</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.num_multibody_states" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>num_multibody_states(self: pydrake.multibody.plant.MultibodyPlant) -&gt; int</p></li>
</ol>
<p>Returns the size of the multibody system state vector x = [q v]. This
will be <code class="docutils literal notranslate"><span class="pre">num_positions()</span></code> plus <code class="docutils literal notranslate"><span class="pre">num_velocities()</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>num_multibody_states(self: pydrake.multibody.plant.MultibodyPlant, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; int</p></li>
</ol>
<p>Returns the size of the multibody system state vector xᵢ = [qᵢ vᵢ] for
model instance i. (Here qᵢ ⊆ q and vᵢ ⊆ v.) will be
<code class="docutils literal notranslate"><span class="pre">num_positions(model_instance)</span></code> plus
<code class="docutils literal notranslate"><span class="pre">num_velocities(model_instance)</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.num_positions">
<span class="sig-name descname"><span class="pre">num_positions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.num_positions" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>num_positions(self: pydrake.multibody.plant.MultibodyPlant) -&gt; int</p></li>
</ol>
<p>Returns the size of the generalized position vector q for this model.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>num_positions(self: pydrake.multibody.plant.MultibodyPlant, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; int</p></li>
</ol>
<p>Returns the size of the generalized position vector qᵢ for model
instance i.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.num_velocities">
<span class="sig-name descname"><span class="pre">num_velocities</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.num_velocities" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>num_velocities(self: pydrake.multibody.plant.MultibodyPlant) -&gt; int</p></li>
</ol>
<p>Returns the size of the generalized velocity vector v for this model.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>num_velocities(self: pydrake.multibody.plant.MultibodyPlant, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; int</p></li>
</ol>
<p>Returns the size of the generalized velocity vector vᵢ for model
instance i.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.NumBodiesWithName">
<span class="sig-name descname"><span class="pre">NumBodiesWithName</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.NumBodiesWithName" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The total number of bodies (across all model instances) with the
given name.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.RegisterAsSourceForSceneGraph">
<span class="sig-name descname"><span class="pre">RegisterAsSourceForSceneGraph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">scene_graph</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.SceneGraph" title="pydrake.geometry.SceneGraph"><span class="pre">pydrake.geometry.SceneGraph</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.SourceId" title="pydrake.geometry.SourceId"><span class="pre">pydrake.geometry.SourceId</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.RegisterAsSourceForSceneGraph" title="Link to this definition"></a></dt>
<dd><p>Registers <code class="docutils literal notranslate"><span class="pre">this</span></code> plant to serve as a source for an instance of
SceneGraph. This registration allows MultibodyPlant to register
geometry with <code class="docutils literal notranslate"><span class="pre">scene_graph</span></code> for visualization and/or collision
queries. The string returned by <code class="docutils literal notranslate"><span class="pre">this-&gt;get_name()</span></code> is passed to
SceneGraph’s RegisterSource, so it is highly recommended that you give
the plant a recognizable name before calling this. Successive
registration calls with SceneGraph <strong>must</strong> be performed on the same
instance to which the pointer argument <code class="docutils literal notranslate"><span class="pre">scene_graph</span></code> points to.
Failure to do so will result in runtime exceptions.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">scene_graph</span></code>:</dt><dd><p>A valid non nullptr to the SceneGraph instance for which <code class="docutils literal notranslate"><span class="pre">this</span></code>
plant will sever as a source, see SceneGraph documentation for
further details.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>the SourceId of <code class="docutils literal notranslate"><span class="pre">this</span></code> plant in <code class="docutils literal notranslate"><span class="pre">scene_graph</span></code>. It can also
later on be retrieved with get_source_id().</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>RuntimeError if called post-finalize.</strong> – </p></li>
<li><p><strong>RuntimeError if scene_graph is the nullptr.</strong> – </p></li>
<li><p><strong>RuntimeError if called more than once.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.RegisterCollisionGeometry">
<span class="sig-name descname"><span class="pre">RegisterCollisionGeometry</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.RegisterCollisionGeometry" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>RegisterCollisionGeometry(self: pydrake.multibody.plant.MultibodyPlant, body: pydrake.multibody.tree.RigidBody, X_BG: pydrake.math.RigidTransform, shape: pydrake.geometry.Shape, name: str, properties: pydrake.geometry.ProximityProperties) -&gt; pydrake.geometry.GeometryId</p></li>
</ol>
<p>Registers geometry in a SceneGraph with a given geometry::Shape to be
used for the contact modeling of a given <code class="docutils literal notranslate"><span class="pre">body</span></code>. More than one
geometry can be registered with a body, in which case the body’s
contact geometry is the union of all geometries registered to that
body.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body</span></code>:</dt><dd><p>The body for which geometry is being registered.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">X_BG</span></code>:</dt><dd><p>The fixed pose of the geometry frame G in the body frame B.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">shape</span></code>:</dt><dd><p>The geometry::Shape used for collision and contact. E.g.:
geometry::Sphere, geometry::Cylinder, etc.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">properties</span></code>:</dt><dd><p>The proximity properties associated with the collision geometry.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called post-finalize.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>RegisterCollisionGeometry(self: pydrake.multibody.plant.MultibodyPlant, body: pydrake.multibody.tree.RigidBody, X_BG: pydrake.math.RigidTransform, shape: pydrake.geometry.Shape, name: str, coulomb_friction: pydrake.multibody.plant.CoulombFriction) -&gt; pydrake.geometry.GeometryId</p></li>
</ol>
<p>Overload which specifies a single property: coulomb_friction.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.RegisterVisualGeometry">
<span class="sig-name descname"><span class="pre">RegisterVisualGeometry</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.RegisterVisualGeometry" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>RegisterVisualGeometry(self: pydrake.multibody.plant.MultibodyPlant, body: pydrake.multibody.tree.RigidBody, X_BG: pydrake.math.RigidTransform, shape: pydrake.geometry.Shape, name: str, diffuse_color: numpy.ndarray[numpy.float64[4, 1]]) -&gt; pydrake.geometry.GeometryId</p></li>
</ol>
<p>Overload for visual geometry registration. The following properties
are set: - (“phong”, “diffuse”) = <code class="docutils literal notranslate"><span class="pre">diffuse_color</span></code> in both sets of
properties. - (“label”, “id”) in perception properties as documented
above.</p>
<p>See mbp_geometry “the overview” for more details.</p>
<ol class="arabic simple" start="2">
<li><p>RegisterVisualGeometry(self: pydrake.multibody.plant.MultibodyPlant, body: pydrake.multibody.tree.RigidBody, geometry_instance: pydrake.geometry.GeometryInstance) -&gt; pydrake.geometry.GeometryId</p></li>
</ol>
<p>Registers the given <code class="docutils literal notranslate"><span class="pre">geometry_instance</span></code> in a SceneGraph to be used
for visualization of a given <code class="docutils literal notranslate"><span class="pre">body</span></code>.</p>
<p>The roles that <code class="docutils literal notranslate"><span class="pre">geometry_instance</span></code> gets assigned
(illustration/perception) in SceneGraph depend solely on the
properties that have <em>already</em> been assigned to <code class="docutils literal notranslate"><span class="pre">geometry_instance</span></code>.
If <em>any</em> visual roles have been assigned, those will be the only roles
used. If <em>no</em> visual roles have been assigned, then both roles will be
assigned using the default set of property values.</p>
<p>If the registered geometry has the perception role, it will have the
(“label”, “id”) property. Possibly assigned as documented above.</p>
<p>See mbp_geometry “the overview” for more details.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body</span></code>:</dt><dd><p>The body for which geometry is being registered.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">geometry_instance</span></code>:</dt><dd><p>The geometry to associate with the visual appearance of <code class="docutils literal notranslate"><span class="pre">body</span></code>.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if geometry_instance is null.</strong> – </p></li>
<li><p><strong>RuntimeError if called post-finalize.</strong> – </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>the id for the registered geometry.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.RemoveConstraint">
<span class="sig-name descname"><span class="pre">RemoveConstraint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">id</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.MultibodyConstraintId" title="pydrake.multibody.tree.MultibodyConstraintId"><span class="pre">pydrake.multibody.tree.MultibodyConstraintId</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.RemoveConstraint" title="Link to this definition"></a></dt>
<dd><p>Removes the constraint <code class="docutils literal notranslate"><span class="pre">id</span></code> from the plant. Note that this will
<em>not</em> remove constraints registered directly with DeformableModel.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the MultibodyPlant has already been finalized.</strong> – </p></li>
<li><p><strong>RuntimeError if id does not identify any multibody constraint</strong> – </p></li>
<li><p><strong>in this plant.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.RemoveJoint">
<span class="sig-name descname"><span class="pre">RemoveJoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">joint</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Joint" title="pydrake.multibody.tree.Joint"><span class="pre">pydrake.multibody.tree.Joint</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.RemoveJoint" title="Link to this definition"></a></dt>
<dd><p>Removes and deletes <code class="docutils literal notranslate"><span class="pre">joint</span></code> from this MultibodyPlant. Any existing
references to <code class="docutils literal notranslate"><span class="pre">joint</span></code> will become invalid, and future calls to
<code class="docutils literal notranslate"><span class="pre">get_joint(joint_index)</span></code> will throw an exception. Other elements of
the plant may depend on <code class="docutils literal notranslate"><span class="pre">joint</span></code> at the time of removal and should be
removed first. For example, a JointActuator that depends on <code class="docutils literal notranslate"><span class="pre">joint</span></code>
should be removed with RemoveJointActuator(). Currently, we do not
provide joint dependency tracking for force elements or constraints,
so this function will throw an exception if there are <em>any</em> user-added
force elements or constraints in the plant.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the plant is already finalized.</strong> – </p></li>
<li><p><strong>RuntimeError if the plant contains a non-zero number</strong><strong> of </strong><strong>user-added</strong> – </p></li>
<li><p><strong>force elements</strong><strong> or </strong><strong>user-added constraints.</strong> – </p></li>
<li><p><strong>RuntimeError if joint has a dependent JointActuator.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddJoint()</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is important to note that the JointIndex assigned to a joint is
immutable. New joint indices are assigned in increasing order,
even if a joint with a lower index has been removed. This has the
consequence that when a joint is removed from the plant, the
sequence <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">num_joints())</span></code> is not necessarily the correct set
of un-removed joint indices in the plant. Thus, it is important
<em>NOT</em> to loop over joint indices sequentially from <code class="docutils literal notranslate"><span class="pre">0</span></code> to
<code class="docutils literal notranslate"><span class="pre">num_joints()</span> <span class="pre">-</span> <span class="pre">1</span></code>. Instead users should use the provided
GetJointIndices() and GetJointIndices(ModelIndex) functions:</p>
</div>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">JointIndex</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">plant</span><span class="p">.</span><span class="n">GetJointIndices</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">Joint</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">joint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">plant</span><span class="p">.</span><span class="n">get_joint</span><span class="p">(</span><span class="n">index</span><span class="p">);</span>
<span class="w">  </span><span class="p">...</span>
<span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
</details></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.RemoveJointActuator">
<span class="sig-name descname"><span class="pre">RemoveJointActuator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">actuator</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JointActuator" title="pydrake.multibody.tree.JointActuator"><span class="pre">pydrake.multibody.tree.JointActuator</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.RemoveJointActuator" title="Link to this definition"></a></dt>
<dd><p>Removes and deletes <code class="docutils literal notranslate"><span class="pre">actuator</span></code> from this MultibodyPlant. Any
existing references to <code class="docutils literal notranslate"><span class="pre">actuator</span></code> will become invalid, and future
calls to <code class="docutils literal notranslate"><span class="pre">get_joint_actuator(actuator_index)</span></code> will throw an
exception.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if the plant is already finalized.</strong> – </p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddJointActuator()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.RenameModelInstance">
<span class="sig-name descname"><span class="pre">RenameModelInstance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.RenameModelInstance" title="Link to this definition"></a></dt>
<dd><p>Renames an existing model instance.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>:</dt><dd><p>The instance to rename.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">name</span></code>:</dt><dd><p>A string that uniquely identifies the instance within <code class="docutils literal notranslate"><span class="pre">this</span></code>
model.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if called after Finalize</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p></li>
<li><p><strong>RuntimeError if model_instance is not a valid index.</strong> – </p></li>
<li><p><strong>RuntimeError if HasModelInstanceNamed</strong><strong>(</strong><strong>name</strong><strong>) </strong><strong>is true.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.set_adjacent_bodies_collision_filters">
<span class="sig-name descname"><span class="pre">set_adjacent_bodies_collision_filters</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.set_adjacent_bodies_collision_filters" title="Link to this definition"></a></dt>
<dd><p>Sets whether to apply collision filters to topologically adjacent
bodies at Finalize() time. Filters are applied when there exists a
joint between bodies, except in the case of 6-dof joints or joints in
which the parent body is <code class="docutils literal notranslate"><span class="pre">world</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError iff called post-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.set_contact_model">
<span class="sig-name descname"><span class="pre">set_contact_model</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">model</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.ContactModel" title="pydrake.multibody.plant.ContactModel"><span class="pre">pydrake.multibody.plant.ContactModel</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.set_contact_model" title="Link to this definition"></a></dt>
<dd><p>Sets the contact model to be used by <code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant, see
ContactModel for available options. The default contact model is
ContactModel::kHydroelasticWithFallback.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError iff called post-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.set_contact_surface_representation">
<span class="sig-name descname"><span class="pre">set_contact_surface_representation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">surface_representation</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.HydroelasticContactRepresentation" title="pydrake.geometry.HydroelasticContactRepresentation"><span class="pre">pydrake.geometry.HydroelasticContactRepresentation</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.set_contact_surface_representation" title="Link to this definition"></a></dt>
<dd><p>Sets the representation of contact surfaces to be used by <code class="docutils literal notranslate"><span class="pre">this</span></code>
MultibodyPlant. See geometry::HydroelasticContactRepresentation for
available options. See GetDefaultContactSurfaceRepresentation() for
explanation of default values.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called post-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.set_discrete_contact_approximation">
<span class="sig-name descname"><span class="pre">set_discrete_contact_approximation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">approximation</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.DiscreteContactApproximation" title="pydrake.multibody.plant.DiscreteContactApproximation"><span class="pre">pydrake.multibody.plant.DiscreteContactApproximation</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.set_discrete_contact_approximation" title="Link to this definition"></a></dt>
<dd><p>Sets the discrete contact model approximation.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Calling this method also sets the contact solver type (see
get_discrete_contact_solver()) according to: -
DiscreteContactApproximation::kTamsi sets the solver to
DiscreteContactSolver::kTamsi. -
DiscreteContactApproximation::kSap,
DiscreteContactApproximation::kSimilar and
DiscreteContactApproximation::kLagged set the solver to
DiscreteContactSolver::kSap.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>iff this plant is continuous</strong><strong> (</strong><strong>i.e. is_discrete</strong><strong>(</strong><strong>) </strong><strong>is</strong> – </p></li>
<li><p><strong>False`.</strong> – </p></li>
<li><p><strong>RuntimeError iff called post-finalize.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.set_gravity_enabled">
<span class="sig-name descname"><span class="pre">set_gravity_enabled</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_enabled</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.set_gravity_enabled" title="Link to this definition"></a></dt>
<dd><p>Sets is_gravity_enabled() for <code class="docutils literal notranslate"><span class="pre">model_instance</span></code> to <code class="docutils literal notranslate"><span class="pre">is_enabled</span></code>.
The effect of <code class="docutils literal notranslate"><span class="pre">is_enabled</span> <span class="pre">=</span> <span class="pre">false</span></code> is effectively equivalent to
disabling (or making zero) gravity for all bodies in the specified
model instance. By default is_gravity_enabled() equals <code class="docutils literal notranslate"><span class="pre">True</span></code> for
all model instances.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if called post-finalize.</strong> – </p></li>
<li><p><strong>RuntimeError if the model instance is invalid.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.set_penetration_allowance">
<span class="sig-name descname"><span class="pre">set_penetration_allowance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">penetration_allowance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.001</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.set_penetration_allowance" title="Link to this definition"></a></dt>
<dd><p>Sets a penetration allowance used to estimate the point contact
stiffness and Hunt &amp; Crossley dissipation parameters. Refer to the
section point_contact_defaults “Point Contact Default Parameters” for
further details.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This will be deprecated. Prefer using defaults specified in
geometry::DefaultProximityProperties.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Values provided in geometry::DefaultProximityProperties have
precedence. If values estimated based on penetration allowance are
desired, set defaults in geometry::DefaultProximityProperties to
std::nullopt.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if penetration_allowance is not positive.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.set_sap_near_rigid_threshold">
<span class="sig-name descname"><span class="pre">set_sap_near_rigid_threshold</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">near_rigid_threshold</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.set_sap_near_rigid_threshold" title="Link to this definition"></a></dt>
<dd><p>Non-negative dimensionless number typically in the range [0.0, 1.0],
though larger values are allowed even if uncommon. This parameter
controls the “near rigid” regime of the SAP solver, β in section V.B
of [Castro et al., 2021]. It essentially controls a threshold value
for the maximum amount of stiffness SAP can handle robustly. Beyond
this value, stiffness saturates as explained in [Castro et al., 2021].
A value of 1.0 is a conservative choice to avoid ill-conditioning that
might lead to softer than expected contact. If this is your case,
consider turning off this approximation by setting this parameter to
zero. For difficult cases where ill-conditioning is a problem, a small
but non-zero number can be used, e.g. 1.0e-3.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if near_rigid_threshold is negative.</strong> – </p></li>
<li><p><strong>RuntimeError if called post-finalize.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.set_stiction_tolerance">
<span class="sig-name descname"><span class="pre">set_stiction_tolerance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">v_stiction</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.001</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.set_stiction_tolerance" title="Link to this definition"></a></dt>
<dd><p><a href="#id35"><span class="problematic" id="id36">**</span></a>** Stribeck model of friction</p>
<p>Currently MultibodyPlant uses the Stribeck approximation to model dry
friction. The Stribeck model of friction is an approximation to
Coulomb’s law of friction that allows using continuous time
integration without the need to specify complementarity constraints.
While this results in a simpler model immediately tractable with
standard numerical methods for integration of ODE’s, it often leads to
stiff dynamics that require an explicit integrator to take very small
time steps. It is therefore recommended to use error controlled
integrators when using this model or the discrete time stepping (see
multibody_simulation). See stribeck_approximation for a detailed
discussion of the Stribeck model.</p>
<p>Sets the stiction tolerance <code class="docutils literal notranslate"><span class="pre">v_stiction</span></code> for the Stribeck model,
where <code class="docutils literal notranslate"><span class="pre">v_stiction</span></code> must be specified in m/s (meters per second.)
<code class="docutils literal notranslate"><span class="pre">v_stiction</span></code> defaults to a value of 1 millimeter per second. In
selecting a value for <code class="docutils literal notranslate"><span class="pre">v_stiction</span></code>, you must ask yourself the
question, “When two objects are ostensibly in stiction, how much slip
am I willing to allow?” There are two opposing design issues in
picking a value for vₛ. On the one hand, small values of vₛ make the
problem numerically stiff during stiction, potentially increasing the
integration cost. On the other hand, it should be picked to be
appropriate for the scale of the problem. For example, a car
simulation could allow a “large” value for vₛ of 1 cm/s (1×10⁻² m/s),
but reasonable stiction for grasping a 10 cm box might require
limiting residual slip to 1×10⁻³ m/s or less. Ultimately, picking the
largest viable value will allow your simulation to run faster and more
robustly. Note that <code class="docutils literal notranslate"><span class="pre">v_stiction</span></code> is the slip velocity that we’d have
when we are at edge of the friction cone. For cases when the friction
force is well within the friction cone the slip velocity will always
be smaller than this value. See also stribeck_approximation.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if v_stiction is non-positive.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.SetActuationInArray">
<span class="sig-name descname"><span class="pre">SetActuationInArray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">u_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">u</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.writeable</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.SetActuationInArray" title="Link to this definition"></a></dt>
<dd><p>Given actuation values <code class="docutils literal notranslate"><span class="pre">u_instance</span></code> for the actuators in
<code class="docutils literal notranslate"><span class="pre">model_instance</span></code>, this function updates the actuation vector u for
the entire plant model to which this actuator belongs to. Refer to
mbp_actuation “Actuation” for further details.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">u_instance</span></code>:</dt><dd><p>Actuation values for the model instance. Values are ordered by
monotonically increasing JointActuatorIndex within the model
instance.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">u</span></code>:</dt><dd><p>Actuation values for the entire plant model. The actuation value
in <code class="docutils literal notranslate"><span class="pre">u</span></code> for a particular actuator must be found at offset
JointActuator::input_start(). Only values corresponding to
<code class="docutils literal notranslate"><span class="pre">model_instance</span></code> are changed.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the size</strong><strong> of </strong><strong>u_instance is not equal to the</strong> – </p></li>
<li><p><strong>number</strong><strong> of </strong><strong>actuation inputs for the joints</strong><strong> of </strong><strong>model_instance.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.SetConstraintActiveStatus">
<span class="sig-name descname"><span class="pre">SetConstraintActiveStatus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context" title="pydrake.systems.framework.Context"><span class="pre">pydrake.systems.framework.Context</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">id</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.MultibodyConstraintId" title="pydrake.multibody.tree.MultibodyConstraintId"><span class="pre">pydrake.multibody.tree.MultibodyConstraintId</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">status</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.SetConstraintActiveStatus" title="Link to this definition"></a></dt>
<dd><p>Sets the active status of the constraint given by <code class="docutils literal notranslate"><span class="pre">id</span></code> in
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the MultibodyPlant has not been finalized.</strong> – </p></li>
<li><p><strong>RuntimeError if context == nullptr</strong> – </p></li>
<li><p><strong>RuntimeError if id does not belong to any multibody constraint</strong> – </p></li>
<li><p><strong>in context.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.SetDefaultFloatingBaseBodyPose">
<span class="sig-name descname"><span class="pre">SetDefaultFloatingBaseBodyPose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">body</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody" title="pydrake.multibody.tree.RigidBody"><span class="pre">pydrake.multibody.tree.RigidBody</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">X_WB</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.math.html#pydrake.math.RigidTransform" title="pydrake.math.RigidTransform"><span class="pre">pydrake.math.RigidTransform</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.SetDefaultFloatingBaseBodyPose" title="Link to this definition"></a></dt>
<dd><p>Provisionally records a default World pose for <code class="docutils literal notranslate"><span class="pre">body</span></code>, to be used in
case <code class="docutils literal notranslate"><span class="pre">body</span></code> turns out to be a floating base body after Finalize().</p>
<p>This may be called pre- or post-Finalize(). Pre-Finalize() this is the
only way to set the default pose of a floating base body.
Post-Finalize(), a floating base body’s default pose may be set either
by this function or by setting the default pose directly through the
Joint API applied to the automatically-added floating joint. The most
recent value set by either method will be used to initialize the
floating joint’s coordinates in subsequently-created Contexts.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>If this is called on a <code class="docutils literal notranslate"><span class="pre">body</span></code> that does <em>not</em> turn out to be a
floating base body after Finalize(), it will have no effect other
than to be echoed back in GetDefaultFloatingBaseBodyPose(); in
particular it will not affect the initial state in a
subsequently-created Context. Use the Joint API to set the default
pose for any body that has an explicitly-defined joint to its
parent body.</p>
</div>
<p>See mbp_working_with_free_bodies “above for details”.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body</span></code>:</dt><dd><p>RigidBody whose default pose will be set if it turns out to be a
floating base body.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">X_WB</span></code>:</dt><dd><p>Default pose of the floating base body in the World frame.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.SetDefaultFreeBodyPose">
<span class="sig-name descname"><span class="pre">SetDefaultFreeBodyPose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">body</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody" title="pydrake.multibody.tree.RigidBody"><span class="pre">pydrake.multibody.tree.RigidBody</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">X_PB</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.math.html#pydrake.math.RigidTransform" title="pydrake.math.RigidTransform"><span class="pre">pydrake.math.RigidTransform</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.SetDefaultFreeBodyPose" title="Link to this definition"></a></dt>
<dd><p>(Deprecated.)</p>
<dl class="simple">
<dt>Deprecated:</dt><dd><p>Use SetDefaultFloatingBaseBodyPose() instead. This will be removed
from Drake on or after 2026-06-01.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.SetDefaultPositions">
<span class="sig-name descname"><span class="pre">SetDefaultPositions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.SetDefaultPositions" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>SetDefaultPositions(self: pydrake.multibody.plant.MultibodyPlant, q: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</p></li>
</ol>
<p>Sets the default positions for the plant. Calls to
CreateDefaultContext or SetDefaultContext/SetDefaultState will return
a Context populated with these position values. They have no other
effects on the dynamics of the system.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the plant is not finalized</strong><strong>, </strong><strong>if q is not</strong><strong> of </strong><strong>size</strong> – </p></li>
<li><p><strong>num_positions</strong><strong>(</strong><strong>)</strong><strong>, or </strong><strong>q contains non-finite values.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>SetDefaultPositions(self: pydrake.multibody.plant.MultibodyPlant, model_instance: pydrake.multibody.tree.ModelInstanceIndex, q_instance: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</p></li>
</ol>
<p>Sets the default positions for the model instance. Calls to
CreateDefaultContext or SetDefaultContext/SetDefaultState will return
a Context populated with these position values. They have no other
effects on the dynamics of the system.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the plant is not finalized</strong><strong>, </strong><strong>if the model_instance</strong> – </p></li>
<li><p><strong>is invalid</strong><strong>, </strong><strong>if the length</strong><strong> of </strong><strong>q_instance is not equal to</strong> – </p></li>
<li><p><strong>num_positions</strong><strong>(</strong><strong>model_instance</strong><strong>)</strong><strong>`</strong><strong>, or </strong><strong>if q_instance contain</strong> – </p></li>
<li><p><strong>non-finite values.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.SetDefaultState">
<span class="sig-name descname"><span class="pre">SetDefaultState</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context" title="pydrake.systems.framework.Context"><span class="pre">pydrake.systems.framework.Context</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">state</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.State" title="pydrake.systems.framework.State"><span class="pre">pydrake.systems.framework.State</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.SetDefaultState" title="Link to this definition"></a></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">state</span></code> according to defaults set by the user for joints (e.g.
RevoluteJoint::set_default_angle()) and free bodies
(SetDefaultFreeBodyPose()). If the user does not specify defaults, the
state corresponds to zero generalized positions and velocities.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize. See Finalize</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.SetDistanceConstraintParams">
<span class="sig-name descname"><span class="pre">SetDistanceConstraintParams</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context" title="pydrake.systems.framework.Context"><span class="pre">pydrake.systems.framework.Context</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">id</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.MultibodyConstraintId" title="pydrake.multibody.tree.MultibodyConstraintId"><span class="pre">pydrake.multibody.tree.MultibodyConstraintId</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.DistanceConstraintParams" title="pydrake.multibody.plant.DistanceConstraintParams"><span class="pre">pydrake.multibody.plant.DistanceConstraintParams</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.SetDistanceConstraintParams" title="Link to this definition"></a></dt>
<dd><p>Stores in <code class="docutils literal notranslate"><span class="pre">context</span></code> the parameters <code class="docutils literal notranslate"><span class="pre">params</span></code> for the distance
constraint with identifier <code class="docutils literal notranslate"><span class="pre">id</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">out</span></code>:</dt><dd><p>] context The plant’s context. On output it stores <code class="docutils literal notranslate"><span class="pre">params</span></code> for
the requested distance constraint.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">id</span></code>:</dt><dd><p>Unique identifier of the constraint.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">params</span></code>:</dt><dd><p>The new set of parameters to be stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>if id is not a valid identifier for a distance constraint.</strong> – </p></li>
<li><p><strong>if params.bodyA</strong><strong>(</strong><strong>) or </strong><strong>params.bodyB</strong><strong>(</strong><strong>) </strong><strong>do not correspond to rigid</strong> – </p></li>
<li><p><strong>bodies in this MultibodyPlant.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.SetFloatingBaseBodyPoseInAnchoredFrame">
<span class="sig-name descname"><span class="pre">SetFloatingBaseBodyPoseInAnchoredFrame</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context" title="pydrake.systems.framework.Context"><span class="pre">pydrake.systems.framework.Context</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_F</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame" title="pydrake.multibody.tree.Frame"><span class="pre">pydrake.multibody.tree.Frame</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">body</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody" title="pydrake.multibody.tree.RigidBody"><span class="pre">pydrake.multibody.tree.RigidBody</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">X_FB</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.math.html#pydrake.math.RigidTransform" title="pydrake.math.RigidTransform"><span class="pre">pydrake.math.RigidTransform</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.SetFloatingBaseBodyPoseInAnchoredFrame" title="Link to this definition"></a></dt>
<dd><p>Updates <code class="docutils literal notranslate"><span class="pre">context</span></code> to store the World-frame pose of floating base
body B, given its pose <code class="docutils literal notranslate"><span class="pre">X_FB</span></code> in an arbitrary anchored frame F.</p>
<p>Frame F must be <em>anchored</em>, meaning that it is either on a body which
is directly welded to a frame on the World body, or more generally,
that it is on a body for which there is a kinematic path between that
body and the world body that only includes weld joints.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The World-frame pose is calculated here and stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.
Moving F subsequently will not change the stored pose unless you
call this method again.</p>
</div>
<p>See mbp_working_with_free_bodies “above for details”.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if called pre-finalize.</strong> – </p></li>
<li><p><strong>RuntimeError if frame F is not anchored to the world.</strong> – </p></li>
<li><p><strong>RuntimeError if body is not a floating base body.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.SetFloatingBaseBodyPoseInWorldFrame">
<span class="sig-name descname"><span class="pre">SetFloatingBaseBodyPoseInWorldFrame</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context" title="pydrake.systems.framework.Context"><span class="pre">pydrake.systems.framework.Context</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">body</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody" title="pydrake.multibody.tree.RigidBody"><span class="pre">pydrake.multibody.tree.RigidBody</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">X_WB</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.math.html#pydrake.math.RigidTransform" title="pydrake.math.RigidTransform"><span class="pre">pydrake.math.RigidTransform</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.SetFloatingBaseBodyPoseInWorldFrame" title="Link to this definition"></a></dt>
<dd><p>Updates <code class="docutils literal notranslate"><span class="pre">context</span></code> to store the pose <code class="docutils literal notranslate"><span class="pre">X_WB</span></code> of a given floating
base body B’s body frame in the World frame W.</p>
<p>See mbp_working_with_free_bodies “above for details”.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if called pre-finalize.</strong> – </p></li>
<li><p><strong>RuntimeError if body is not a floating base body.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.SetFreeBodyPose">
<span class="sig-name descname"><span class="pre">SetFreeBodyPose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.SetFreeBodyPose" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>SetFreeBodyPose(self: pydrake.multibody.plant.MultibodyPlant, context: pydrake.systems.framework.Context, body: pydrake.multibody.tree.RigidBody, X_JpJc: pydrake.math.RigidTransform) -&gt; None</p></li>
</ol>
<p>For any free body’s 6-dof joint, sets <code class="docutils literal notranslate"><span class="pre">context</span></code> to store the pose
X_JpJc of child frame Jc in its parent frame Jp.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Unless <code class="docutils literal notranslate"><span class="pre">body</span></code> is a floating base body, the parent frame Jp is
not necessarily the World frame W, and the child frame Jc is not
necessarily the body frame B. For a floating base body B, this
method sets X_WB, the pose of body B in World.</p>
</div>
<p>See mbp_working_with_free_bodies “above for details”.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if called pre-finalize.</strong> – </p></li>
<li><p><strong>RuntimeError if body is not a free body.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>SetFreeBodyPose(self: pydrake.multibody.plant.MultibodyPlant, context: pydrake.systems.framework.Context, body: pydrake.multibody.tree.RigidBody, X_PB: pydrake.math.RigidTransform) -&gt; None</p></li>
</ol>
<p>X_PB parameter name for SetFreeBodyPose() is deprecated and will be removed 2026-06-01. Use X_JpJc instead.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.SetFreeBodySpatialVelocity">
<span class="sig-name descname"><span class="pre">SetFreeBodySpatialVelocity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.SetFreeBodySpatialVelocity" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>SetFreeBodySpatialVelocity(self: pydrake.multibody.plant.MultibodyPlant, context: pydrake.systems.framework.Context, body: pydrake.multibody.tree.RigidBody, V_JpJc: pydrake.multibody.math.SpatialVelocity) -&gt; None</p></li>
</ol>
<p>For any free body’s 6-dof joint, sets <code class="docutils literal notranslate"><span class="pre">context</span></code> to store the spatial
velocity V_JpJc of child frame Jc in its parent frame Jp.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Unless <code class="docutils literal notranslate"><span class="pre">body</span></code> is a floating base body, the parent frame Jp is
not necessarily the World frame W, and the child frame Jc is not
necessarily the body frame B. For a floating base body B, this
method sets V_WB, the spatial velocity of body B in World.</p>
</div>
<p>See mbp_working_with_free_bodies “above for details”.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if called pre-finalize.</strong> – </p></li>
<li><p><strong>RuntimeError if body is not a free body.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>SetFreeBodySpatialVelocity(self: pydrake.multibody.plant.MultibodyPlant, body: pydrake.multibody.tree.RigidBody, V_PB: pydrake.multibody.math.SpatialVelocity, context: pydrake.systems.framework.Context) -&gt; None</p></li>
</ol>
<p>The parameter order and V_PB parameter name for SetFreeBodySpatialVelocity() are deprecated and will be removed 2026-06-01. Use context, body, V_JpJc instead.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.SetPositions">
<span class="sig-name descname"><span class="pre">SetPositions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.SetPositions" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>SetPositions(self: pydrake.multibody.plant.MultibodyPlant, context: pydrake.systems.framework.Context, q: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</p></li>
</ol>
<p>Sets the generalized positions q in a given Context from a given
vector. Prefer this method over GetMutablePositions().</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if context is nullptr</strong><strong>, </strong><strong>if context does not</strong> – </p></li>
<li><p><strong>correspond to the Context for a multibody model</strong><strong>, </strong><strong>if the length of</strong> – </p></li>
<li><p><strong>q` is not equal to num_positions</strong><strong>(</strong><strong>)</strong><strong>, or </strong><strong>if q contain</strong> – </p></li>
<li><p><strong>non-finite values.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>SetPositions(self: pydrake.multibody.plant.MultibodyPlant, context: pydrake.systems.framework.Context, model_instance: pydrake.multibody.tree.ModelInstanceIndex, q: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</p></li>
</ol>
<p>Sets the generalized positions q in a given Context from a given
vector. Prefer this method over GetMutablePositions().</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if context is nullptr</strong><strong>, </strong><strong>if context does not</strong> – </p></li>
<li><p><strong>correspond to the Context for a multibody model</strong><strong>, </strong><strong>if the length of</strong> – </p></li>
<li><p><strong>q` is not equal to num_positions</strong><strong>(</strong><strong>)</strong><strong>, or </strong><strong>if q contain</strong> – </p></li>
<li><p><strong>non-finite values.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.SetPositionsAndVelocities">
<span class="sig-name descname"><span class="pre">SetPositionsAndVelocities</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.SetPositionsAndVelocities" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>SetPositionsAndVelocities(self: pydrake.multibody.plant.MultibodyPlant, context: pydrake.systems.framework.Context, q_v: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</p></li>
</ol>
<p>Sets generalized positions q and generalized velocities v in a given
Context from a given vector [q; v]. Prefer this method over
GetMutablePositionsAndVelocities().</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if context is nullptr</strong><strong>, </strong><strong>if context does not</strong> – </p></li>
<li><p><strong>correspond to the context for a multibody model</strong><strong>, </strong><strong>if the length of</strong> – </p></li>
<li><p><strong>q_v` is not equal to num_positions</strong><strong>(</strong><strong>) </strong><strong>+ num_velocities</strong><strong>(</strong><strong>)</strong><strong>, </strong><strong>o</strong> – </p></li>
<li><p><strong>if q_v contains non-finite values.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>SetPositionsAndVelocities(self: pydrake.multibody.plant.MultibodyPlant, context: pydrake.systems.framework.Context, model_instance: pydrake.multibody.tree.ModelInstanceIndex, q_v: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</p></li>
</ol>
<p>Sets generalized positions q and generalized velocities v from a given
vector [q; v] for a specified model instance in a given Context.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if context is nullptr</strong><strong>, </strong><strong>if context does not</strong> – </p></li>
<li><p><strong>correspond to the Context for a multibody model</strong><strong>, </strong><strong>if the model</strong> – </p></li>
<li><p><strong>instance index is invalid</strong><strong>, </strong><strong>if the length</strong><strong> of </strong><strong>q_v is not equal</strong> – </p></li>
<li><p><strong>to ``num_positions</strong><strong>(</strong><strong>model_instance</strong><strong>) </strong><strong>+</strong> – </p></li>
<li><p><strong>num_velocities</strong><strong>(</strong><strong>model_instance</strong><strong>)</strong><strong>``</strong><strong>, or </strong><strong>if q_v contains</strong> – </p></li>
<li><p><strong>non-finite values.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.SetPositionsInArray">
<span class="sig-name descname"><span class="pre">SetPositionsInArray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">q_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.writeable</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.SetPositionsInArray" title="Link to this definition"></a></dt>
<dd><p>Sets the vector of generalized positions for <code class="docutils literal notranslate"><span class="pre">model_instance</span></code> in
<code class="docutils literal notranslate"><span class="pre">q</span></code> using <code class="docutils literal notranslate"><span class="pre">q_instance</span></code>, leaving all other elements in the array
untouched. This method throws an exception if <code class="docutils literal notranslate"><span class="pre">q</span></code> is not of size
MultibodyPlant::num_positions() or <code class="docutils literal notranslate"><span class="pre">q_instance</span></code> is not of size
<code class="docutils literal notranslate"><span class="pre">MultibodyPlant::num_positions(model_instance)</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.SetUseSampledOutputPorts">
<span class="sig-name descname"><span class="pre">SetUseSampledOutputPorts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_sampled_output_ports</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.SetUseSampledOutputPorts" title="Link to this definition"></a></dt>
<dd><p>(Advanced) For a discrete-time plant, configures whether the output
ports are sampled (the default) or live (opt-in). See
output_port_sampling “Output port sampling” for details.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the plant is already finalized.</strong> – </p></li>
<li><p><strong>RuntimeError if use_sampled_output_ports is True but</strong> – </p></li>
<li><p><strong>this` MultibodyPlant is not a discrete model</strong><strong> (</strong><strong>is_discrete</strong><strong>(</strong><strong>) </strong><strong>=</strong> – </p></li>
<li><p><strong>false</strong><strong>)</strong><strong>.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.SetVelocities">
<span class="sig-name descname"><span class="pre">SetVelocities</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.SetVelocities" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>SetVelocities(self: pydrake.multibody.plant.MultibodyPlant, context: pydrake.systems.framework.Context, v: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</p></li>
</ol>
<p>Sets the generalized velocities v in a given Context from a given
vector. Prefer this method over GetMutableVelocities().</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the context is nullptr</strong><strong>, </strong><strong>if the context does</strong> – </p></li>
<li><p><strong>not correspond to the context for a multibody model</strong><strong>, </strong><strong>if the length</strong> – </p></li>
<li><p><strong>of v is not equal to num_velocities</strong><strong>(</strong><strong>)</strong><strong>, or </strong><strong>if v</strong> – </p></li>
<li><p><strong>contains non-finite values.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>SetVelocities(self: pydrake.multibody.plant.MultibodyPlant, context: pydrake.systems.framework.Context, model_instance: pydrake.multibody.tree.ModelInstanceIndex, v: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</p></li>
</ol>
<p>Sets the generalized velocities v for a particular model instance in a
given Context from a given vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the context is nullptr</strong><strong>, </strong><strong>if context does</strong> – </p></li>
<li><p><strong>not correspond to the Context for a multibody model</strong><strong>, </strong><strong>if the model</strong> – </p></li>
<li><p><strong>instance index is invalid</strong><strong>, </strong><strong>if the length</strong><strong> of </strong><strong>v_instance is not</strong> – </p></li>
<li><p><strong>equal to num_velocities</strong><strong>(</strong><strong>model_instance</strong><strong>)</strong><strong>, or </strong><strong>if v_instance</strong> – </p></li>
<li><p><strong>contains non-finite values.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.SetVelocitiesInArray">
<span class="sig-name descname"><span class="pre">SetVelocitiesInArray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">v_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.writeable</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.SetVelocitiesInArray" title="Link to this definition"></a></dt>
<dd><p>Sets the vector of generalized velocities for <code class="docutils literal notranslate"><span class="pre">model_instance</span></code> in
<code class="docutils literal notranslate"><span class="pre">v</span></code> using <code class="docutils literal notranslate"><span class="pre">v_instance</span></code>, leaving all other elements in the array
untouched. This method throws an exception if <code class="docutils literal notranslate"><span class="pre">v</span></code> is not of size
MultibodyPlant::num_velocities(), <code class="docutils literal notranslate"><span class="pre">v_instance</span></code> is not of size
<code class="docutils literal notranslate"><span class="pre">MultibodyPlant::num_positions(model_instance)</span></code>, or <code class="docutils literal notranslate"><span class="pre">v_instance</span></code>
contains non-finite values.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.time_step">
<span class="sig-name descname"><span class="pre">time_step</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.time_step" title="Link to this definition"></a></dt>
<dd><p>The time step (or period) used to model <code class="docutils literal notranslate"><span class="pre">this</span></code> plant as a discrete
system with periodic updates. Returns 0 (zero) if the plant is modeled
as a continuous system. This property of the plant is specified at
construction and therefore this query can be performed either pre- or
post-finalize, see Finalize().</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>MultibodyPlant::MultibodyPlant(double)</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.WeldFrames">
<span class="sig-name descname"><span class="pre">WeldFrames</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_on_parent_F</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame" title="pydrake.multibody.tree.Frame"><span class="pre">pydrake.multibody.tree.Frame</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_on_child_M</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame" title="pydrake.multibody.tree.Frame"><span class="pre">pydrake.multibody.tree.Frame</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">X_FM</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.math.html#pydrake.math.RigidTransform" title="pydrake.math.RigidTransform"><span class="pre">pydrake.math.RigidTransform</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">RigidTransform(R=RotationMatrix([[1.0,</span> <span class="pre">0.0,</span> <span class="pre">0.0],</span> <span class="pre">[0.0,</span> <span class="pre">1.0,</span> <span class="pre">0.0],</span> <span class="pre">[0.0,</span> <span class="pre">0.0,</span> <span class="pre">1.0]]),</span> <span class="pre">p=[0.0,</span> <span class="pre">0.0,</span> <span class="pre">0.0])</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.WeldJoint" title="pydrake.multibody.tree.WeldJoint"><span class="pre">pydrake.multibody.tree.WeldJoint</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.WeldFrames" title="Link to this definition"></a></dt>
<dd><p>Welds <code class="docutils literal notranslate"><span class="pre">frame_on_parent_F</span></code> and <code class="docutils literal notranslate"><span class="pre">frame_on_child_M</span></code> with relative
pose <code class="docutils literal notranslate"><span class="pre">X_FM</span></code>. That is, the pose of frame M in frame F is fixed, with
value <code class="docutils literal notranslate"><span class="pre">X_FM</span></code>. If <code class="docutils literal notranslate"><span class="pre">X_FM</span></code> is omitted, the identity transform will be
used. The call to this method creates and adds a new WeldJoint to the
model. The new WeldJoint is named as: frame_on_parent_F.name() +
“_welds_to_” + frame_on_child_M.name().</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a constant reference to the WeldJoint welding frames F and M.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>RuntimeError if the weld produces a duplicate joint name.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.world_body">
<span class="sig-name descname"><span class="pre">world_body</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody" title="pydrake.multibody.tree.RigidBody"><span class="pre">pydrake.multibody.tree.RigidBody</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.world_body" title="Link to this definition"></a></dt>
<dd><p>Returns a constant reference to the <em>world</em> body.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.world_frame">
<span class="sig-name descname"><span class="pre">world_frame</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBodyFrame" title="pydrake.multibody.tree.RigidBodyFrame"><span class="pre">pydrake.multibody.tree.RigidBodyFrame</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.world_frame" title="Link to this definition"></a></dt>
<dd><p>Returns a constant reference to the <em>world</em> frame.</p>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_">
<em class="property"><span class="pre">template</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">MultibodyPlant_</span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_" title="Link to this definition"></a></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">MultibodyPlant_[float]</span></code>, <a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd" title="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">MultibodyPlant_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_-Expression" title="pydrake.multibody.plant.MultibodyPlant_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">MultibodyPlant_[Expression]</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">MultibodyPlant_[AutoDiffXd]</span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.LeafSystem_-AutoDiffXd" title="pydrake.systems.framework.LeafSystem_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem_[AutoDiffXd]</span></code></a></p>
<p>MultibodyPlant is a Drake system framework representation (see
systems::System) for the model of a physical system consisting of a
collection of interconnected bodies. See multibody for an overview of
concepts/notation.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">actuation&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">applied_generalized_force&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">applied_spatial_force&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px"><em style="color:gray">model_instance_name[i]</em>_actuation&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px"><em style="color:gray">model_instance_name[i]</em>_desired_state&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px"><span style="color:green">geometry_query</span>&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>MultibodyPlant</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; state</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; body_poses</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; body_spatial_velocities</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; body_spatial_accelerations</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; generalized_acceleration</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; net_actuation</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; reaction_forces</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; contact_results</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; <em style="color:gray">model_instance_name[i]</em>_state</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; <em style="color:gray">model_instance_name[i]</em>_generalized_acceleration</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; <em style="color:gray">model_instance_name[i]</em>_generalized_contact_forces</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; <em style="color:gray">model_instance_name[i]</em>_net_actuation</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; <span style="color:green">geometry_pose</span></td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; <span style="color:green">deformable_body_configuration</span></td></tr></table></td></tr></table><p>The ports whose names begin with &lt;em style=”color:gray”&gt;
model_instance_name[i]&lt;/em&gt; represent groups of ports, one for each of
the model_instances “model instances”, with i ∈ {0, …, N-1} for the
N model instances. If a model instance does not contain any data of
the indicated type the port will still be present but its value will
be a zero-length vector. (Model instances <code class="docutils literal notranslate"><span class="pre">world_model_instance()</span></code>
and <code class="docutils literal notranslate"><span class="pre">default_model_instance()</span></code> always exist.)</p>
<p>The ports shown in &lt;span style=”color:green”&gt;green&lt;/span&gt; are for
communication with Drake’s geometry::SceneGraph “SceneGraph” system
for dealing with geometry.</p>
<p>MultibodyPlant provides a user-facing API for:</p>
<ul class="simple">
<li><p>mbp_input_and_output_ports “Ports”:</p></li>
</ul>
<p>Access input and output ports.
- mbp_construction “Construction”:
Add bodies, joints, frames, force elements, and actuators.
- mbp_geometry “Geometry”:
Register geometries to a provided SceneGraph instance.
- mbp_contact_modeling “Contact modeling”:
Select and parameterize contact models.
- mbp_state_accessors_and_mutators “State access and modification”:
Obtain and manipulate position and velocity state variables.
- mbp_parameters “Parameters”
Working with system parameters for various multibody elements.
- mbp_working_with_free_bodies “Free and floating base bodies”:
Work conveniently with free (floating) bodies.
- mbp_kinematic_and_dynamic_computations “Kinematics and dynamics”:
Perform systems::Context “Context”-dependent kinematic and dynamic
queries.
- mbp_system_matrix_computations “System matrices”:
Explicitly form matrices that appear in the equations of motion.
- mbp_introspection “Introspection”:
Perform introspection to find out what’s in the MultibodyPlant.</p>
<p><a href="#id39"><span class="problematic" id="id40">**</span></a>** Model Instances</p>
<p>A MultiBodyPlant may contain multiple model instances. Each model
instance corresponds to a set of bodies and their connections
(joints). Model instances provide methods to get or set the state of
the set of bodies (e.g., through GetPositionsAndVelocities() and
SetPositionsAndVelocities()), connecting controllers (through
get_state_output_port() and get_actuation_input_port()), and
organizing duplicate models (read through a parser). In fact, many
MultibodyPlant methods are overloaded to allow operating on the entire
plant or just the subset corresponding to the model instance; for
example, one GetPositions() method obtains the generalized positions
for the entire plant while another GetPositions() method obtains the
generalized positions for model instance.</p>
<p>Model instances are frequently defined through SDFormat files (using
the <code class="docutils literal notranslate"><span class="pre">model</span></code> tag) and are automatically created when SDFormat files
are parsed (by Parser). There are two special
multibody::ModelInstanceIndex values. The world body is always
multibody::ModelInstanceIndex 0. multibody::ModelInstanceIndex 1 is
reserved for all elements with no explicit model instance and is
generally only relevant for elements created programmatically (and
only when a model instance is not explicitly specified). Note that
Parser creates model instances (resulting in a
multibody::ModelInstanceIndex ≥ 2) as needed.</p>
<p>See num_model_instances(), num_positions(), num_velocities(),
num_actuated_dofs(), AddModelInstance() GetPositionsAndVelocities(),
GetPositions(), GetVelocities(), SetPositionsAndVelocities(),
SetPositions(), SetVelocities(), GetPositionsFromArray(),
GetVelocitiesFromArray(), SetPositionsInArray(),
SetVelocitiesInArray(), SetActuationInArray(),
HasModelInstanceNamed(), GetModelInstanceName(),
get_state_output_port(), get_actuation_input_port().</p>
<p><a href="#id41"><span class="problematic" id="id42">**</span></a>** System dynamics</p>
<p>The state of a multibody system <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">[q;</span> <span class="pre">v]</span></code> is given by its
generalized positions vector q, of size <code class="docutils literal notranslate"><span class="pre">nq</span></code> (see num_positions()),
and by its generalized velocities vector v, of size <code class="docutils literal notranslate"><span class="pre">nv</span></code> (see
num_velocities()).</p>
<p>A MultibodyPlant can be constructed to be either continuous or
discrete. The choice is indicated by the time_step passed to the
constructor – a non-zero time_step indicates a discrete plant, while
a zero time_step indicates continuous. A systems::Simulator
“Simulator” will step a discrete plant using the indicated time_step,
but will allow a numerical integrator to choose how to advance time
for a continuous MultibodyPlant.</p>
<p>We’ll discuss continuous plant dynamics in this section. Discrete
dynamics is more complicated and gets its own section below.</p>
<p>As a Drake systems::System “System”, MultibodyPlant implements the
governing equations for a multibody dynamical system in the form <code class="docutils literal notranslate"><span class="pre">ẋ</span>
<span class="pre">=</span> <span class="pre">f(t,</span> <span class="pre">x,</span> <span class="pre">u)</span></code> with t being time and u external inputs such as
actuation forces. The governing equations for the dynamics of a
multibody system modeled with MultibodyPlant are [Featherstone 2008,
Jain 2010]:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">q</span><span class="err">̇</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">N</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="n">v</span>
<span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w">    </span><span class="n">M</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="n">v</span><span class="err">̇</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">C</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">τ</span>
</pre></div>
</div>
</details><p>where <code class="docutils literal notranslate"><span class="pre">M(q)</span></code> is the mass matrix of the multibody system (including
rigid body mass properties and reflected_inertia “reflected
inertias”), <code class="docutils literal notranslate"><span class="pre">C(q,</span> <span class="pre">v)v</span></code> contains Coriolis, centripetal, and
gyroscopic terms and <code class="docutils literal notranslate"><span class="pre">N(q)</span></code> is the kinematic coupling matrix
describing the relationship between q̇ (the time derivatives of the
generalized positions) and the generalized velocities v, [Seth 2010].
<code class="docutils literal notranslate"><span class="pre">N(q)</span></code> is an <code class="docutils literal notranslate"><span class="pre">nq</span> <span class="pre">x</span> <span class="pre">nv</span></code> matrix. The vector <code class="docutils literal notranslate"><span class="pre">τ</span> <span class="pre">∈</span> <span class="pre">ℝⁿᵛ</span></code> on the right
hand side of Eq. (1) is the system’s generalized forces. These
incorporate gravity, springs, externally applied body forces,
constraint forces, and contact forces.</p>
<p><a href="#id43"><span class="problematic" id="id44">**</span></a>** Discrete system dynamics</p>
<p>We’ll start with the basic difference equation interpretation of a
discrete plant and then explain some Drake-specific subtleties.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>We use “kinematics” here to refer to quantities that involve only
position or velocity, and “dynamics” to refer to quantities that
also involve forces.</p>
</div>
<p>By default, a discrete MultibodyPlant has these update dynamics:</p>
<p>x[0] = initial kinematics state variables x (={q, v}), s s[0] = empty
(no sample yet)</p>
<p>s[n+1] = g(t[n], x[n], u[n]) record sample x[n+1] = f(t[n], x[n],
u[n]) update kinematics yd[n+1] = gd(s) dynamic outputs use sampled
values yk[n+1] = gk(x) kinematic outputs use current x</p>
<p>Optionally, output port sampling can be disabled. In that case we
have:</p>
<p>x[n+1] = f(t[n], x[n], u[n]) update kinematics yd[n+1] = gd(g(t, x,
u)) dynamic outputs use current values yk[n+1] = gk(x) kinematic
outputs use current x</p>
<p>We’re using <code class="docutils literal notranslate"><span class="pre">yd</span></code> and <code class="docutils literal notranslate"><span class="pre">yk</span></code> above to represent the calculated values
of dynamic and kinematic output ports, resp. Kinematic output ports
are those that depend only on position and velocity: <code class="docutils literal notranslate"><span class="pre">state</span></code>,
<cite>body_poses</cite>, <code class="docutils literal notranslate"><span class="pre">body_spatial_velocities</span></code>. Everything else depends on
forces so is a dynamic output port: <code class="docutils literal notranslate"><span class="pre">body_spatial_accelerations</span></code>,
<cite>generalized_acceleration</cite>, <code class="docutils literal notranslate"><span class="pre">net_actuation</span></code>, <cite>reaction_forces</cite>, and
<code class="docutils literal notranslate"><span class="pre">contact_results</span></code>.</p>
<p>Use the function SetUseSampledOutputPorts() to choose which dynamics
you prefer. The default behavior (output port sampling) is more
efficient for simulation, but use slightly-different kinematics for
the dynamic output port computations versus the kinematic output
ports. Disabling output port sampling provides “live” output port
results that are recalculated from the current state and inputs
whenever changes occur. It also eliminates the sampling state variable
(s above). Note that kinematic output ports (that is, those depending
only on position and velocity) are always “live” – they are
calculated as needed from the current (updated) state.</p>
<p>The reason that the default mode is more efficient for simulation is
that the sample variable s records expensive-to-compute results (such
as hydroelastic contact forces) that are needed to advance the state
x. Those results are thus available for free at the start of step n.
If instead we wait until after the state is updated to n+1, we would
have to recalculate those expensive results at the new state in order
to report them. Thus sampling means the output ports show the results
that were calculated using kinematics values x[n], although the
Context has been updated to kinematics values x[n+1]. If that isn’t
tolerable you should disable output port sampling. You can also force
an update to occur using ExecuteForcedEvents().</p>
<p>See output_port_sampling “Output port sampling” below for more
practical considerations.</p>
<p>Minor details most users won’t care about:</p>
<ul class="simple">
<li><p>The sample variable s is a Drake Abstract state variable. When it is</p></li>
</ul>
<p>present, the plant update is performed using an Unrestricted update; when it
is absent we are able to use a Discrete update. Some Drake features (e.g.
linearization of discrete systems) may be restricted to systems that use
only Discrete (numeric) state variables and Discrete update.
- The sample variable s is used only by output ports. It does not affect the
behavior of any MultibodyPlant “Calc” or “Eval” functions – those are
always calculated using the current values of time, kinematic state, and
input port values.</p>
<p><a href="#id45"><span class="problematic" id="id46">**</span></a>** Output port sampling</p>
<p>As described in mbp_discrete_dynamics “Discrete system dynamics”
above, the semantics of certain MultibodyPlant output ports depends on
whether the plant is configured to advance using continuous time
integration or discrete time steps (see is_discrete()). This section
explains the details, focusing on the practical aspects moreso than
the equations.</p>
<p>Output ports that only depend on the [q, v] kinematic state (such as
get_body_poses_output_port() or
get_body_spatial_velocities_output_port()) do <em>not</em> change semantics
for continuous vs discrete time. In all cases, the output value is a
function of the kinematic state in the context.</p>
<p>Output ports that incorporate dynamics (i.e., forces) <em>do</em> change
semantics based on the plant mode. Imagine that the
get_applied_spatial_force_input_port() provides a continuously
time-varying input force. The
get_body_spatial_accelerations_output_port() output is dependent on
that force. We could return a snapshot of the acceleration that was
used in the last time step, or we could recalculate the acceleration
to immediately reflect the changing forces. We call the former a
“sampled” port and the latter a “live” port.</p>
<p>For a continuous-time plant, there is no distinction – the output
port is always live – it immediately reflects the instantaneous input
value. It is a “direct feedthrough” output port (see
SystemBase::GetDirectFeedthroughs()).</p>
<p>For a discrete-time plant, the user can choose whether the output
should be sampled or live: Use the function SetUseSampledOutputPorts()
to change whether output ports are sampled or not, and
has_sampled_output_ports() to check the current setting. When sampling
is disabled, the only state in the context is the kinematic [q, v], so
dynamics output ports will always reflect the instantaneous answer
(i.e., direct feedthrough). When sampling is enabled (the default),
the plant state incorporates a snapshot of the most recent step’s
kinematics and dynamics, and the output ports will reflect that
sampled state (i.e., not direct feedthrough). For a detailed
discussion, see mbp_discrete_dynamics “Discrete system dynamics”.</p>
<p>For a discrete-time plant, the sampled outputs are generally <em>much</em>
faster to calculate than the feedthrough outputs when any inputs ports
are changing values faster than the discrete time step, e.g., during a
simulation. When input ports are fixed, or change at the time step
rate (e.g., during motion planning), sampled vs feedthrough will have
similar computational performance.</p>
<p>Direct plant API function calls (e.g.,
EvalBodySpatialAccelerationInWorld()) that depend on forces always use
the instantaneous (not sampled) accelerations.</p>
<p>Here are some practical tips that might help inform your particular
situation:</p>
<p>(1) If you need a minimal-state representation for motion planning,
mathematical optimization, or similar, then you can either use a
continuous-time plant or set the config option
<code class="docutils literal notranslate"><span class="pre">use_sampled_output_ports=false</span></code> on a discrete-time plant.</p>
<p>(2) By default, setting the positions of a discrete-time plant in the
Context will not have any effect on the dynamics-related output ports,
e.g., the contact results will not change. If you need to see changes
to outputs without running the plant in a Simulator, then you can
either use a continuous-time plant, set the config option
<code class="docutils literal notranslate"><span class="pre">use_sampled_output_ports=false</span></code>, or use ExecuteForcedEvents() to
force a dynamics step and then the outputs (and positions) will
change.</p>
<p><a href="#id47"><span class="problematic" id="id48">**</span></a>** Actuation</p>
<p>In a MultibodyPlant model an actuator can be added as a JointActuator,
see AddJointActuator(). The plant declares actuation input ports to
provide feedforward actuation, both for the MultibodyPlant as a whole
(see get_actuation_input_port()) and for each individual
model_instances “model instance” in the MultibodyPlant (see
get_actuation_input_port(ModelInstanceIndex)const
“get_actuation_input_port(ModelInstanceIndex)”). - Actuation inputs
and actuation effort limits are taken to be in joint coordinates (they
are not affected by the actuator gear ratio). - Any actuation input
ports not connected are assumed to be zero. - Actuation values from
the full MultibodyPlant model port (get_actuation_input_port()) and
from the per model-instance ports (
get_actuation_input_port(ModelInstanceIndex)const
“get_actuation_input_port(ModelInstanceIndex)”) are summed up.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A JointActuator’s index into the vector data supplied to
MultibodyPlant’s actuation input port for all actuators
(get_actuation_input_port()) is given by
JointActuator::input_start(), NOT by its JointActuatorIndex. That
is, the vector element data for a JointActuator at index
JointActuatorIndex(i) in the full input port vector is found at
index:
MultibodyPlant::get_joint_actuator(JointActuatorIndex(i)).input_start().
For the get_actuation_input_port(ModelInstanceIndex)const
“get_actuation_input_port(ModelInstanceIndex)” specific to a model
index, the vector data is ordered by monotonically increasing
JointActuatorIndex for the actuators within that model instance:
the 0ᵗʰ vector element corresponds to the lowest-numbered
JointActuatorIndex of that instance, the 1ˢᵗ vector element
corresponds to the second-lowest-numbered JointActuatorIndex of
that instance, etc.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The following snippet shows how per model instance actuation can
be set:</p>
</div>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">ModelInstanceIndex</span><span class="w"> </span><span class="n">model_instance_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...;</span>
<span class="n">VectorX</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">u_instance</span><span class="p">(</span><span class="n">plant</span><span class="p">.</span><span class="n">num_actuated_dofs</span><span class="p">(</span><span class="n">model_instance_index</span><span class="p">));</span>
<span class="kt">int</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">JointActuatorIndex</span><span class="w"> </span><span class="n">joint_actuator_index</span><span class="w"> </span><span class="o">:</span>
<span class="n">plant</span><span class="p">.</span><span class="n">GetJointActuatorIndices</span><span class="p">(</span><span class="n">model_instance_index</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="k">const</span><span class="w"> </span><span class="n">JointActuator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">actuator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">plant</span><span class="p">.</span><span class="n">get_joint_actuator</span><span class="p">(</span>
<span class="n">joint_actuator_index</span><span class="p">);</span>
<span class="k">const</span><span class="w"> </span><span class="n">Joint</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">joint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">actuator</span><span class="p">.</span><span class="n">joint</span><span class="p">();</span>
<span class="n">VectorX</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">u_joint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="n">my_actuation_logic_for</span><span class="p">(</span><span class="n">joint</span><span class="p">)</span><span class="w"> </span><span class="p">...;</span>
<span class="n">ASSERT</span><span class="p">(</span><span class="n">u_joint</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">joint_actuator</span><span class="p">.</span><span class="n">num_inputs</span><span class="p">());</span>
<span class="n">u_instance</span><span class="p">.</span><span class="n">segment</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="n">u_joint</span><span class="p">.</span><span class="n">size</span><span class="p">())</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">u_joint</span><span class="p">;</span>
<span class="n">offset</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">u_joint</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
<span class="p">}</span>
<span class="n">plant</span><span class="p">.</span><span class="n">get_actuation_input_port</span><span class="p">(</span><span class="n">model_instance_index</span><span class="p">).</span><span class="n">FixValue</span><span class="p">(</span>
<span class="n">plant_context</span><span class="p">,</span><span class="w"> </span><span class="n">u_instance</span><span class="p">);</span>
</pre></div>
</div>
</details><div class="admonition note">
<p class="admonition-title">Note</p>
<p>To inter-operate between the whole plant actuation vector and sets
of per-model instance actuation vectors, see SetActuationInArray()
to gather the model instance vectors into a whole plant vector and
GetActuationFromArray() to scatter the whole plant vector into
per-model instance vectors.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Effort limits (JointActuator::effort_limit()) are not enforced,
unless PD controllers are defined. See pd_controllers “Using PD
controlled actuators”.</p>
</div>
<p>** Using PD controlled actuators</p>
<p>While PD controllers can be modeled externally and be connected to the
MultibodyPlant model via the get_actuation_input_port(), simulation
stability at discrete-time steps can be compromised for high
controller gains. For such cases, simulation stability and robustness
can be improved significantly by moving your PD controller into the
plant where the discrete solver can strongly couple controller and
model dynamics.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Currently, this feature is only supported for discrete models
(is_discrete() is true) using the SAP solver
(get_discrete_contact_solver() returns
DiscreteContactSolver::kSap.)</p>
</div>
<p>PD controlled joint actuators can be defined by setting PD gains for
each joint actuator, see JointActuator::set_controller_gains(). Unless
these gains are specified, joint actuators will not be PD controlled
and JointActuator::has_controller() will return <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
<p>For models with PD controllers, the actuation torque per actuator is
computed according to:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">u</span><span class="err">̃</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">Kp</span><span class="err">⋅</span><span class="p">(</span><span class="n">q</span><span class="w"> </span><span class="err">−</span><span class="w"> </span><span class="n">qd</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">Kd</span><span class="err">⋅</span><span class="p">(</span><span class="n">v</span><span class="w"> </span><span class="err">−</span><span class="w"> </span><span class="n">vd</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">u_ff</span>
<span class="n">u</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="err">−</span><span class="n">e</span><span class="p">,</span><span class="w"> </span><span class="n">min</span><span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="w"> </span><span class="n">u</span><span class="err">̃</span><span class="p">))</span>
</pre></div>
</div>
</details><p>where qd and vd are desired configuration and velocity (see
get_desired_state_input_port()) for the actuated joint (see
JointActuator::joint()), Kp and Kd are the proportional and derivative
gains of the actuator (see JointActuator::get_controller_gains()),
<code class="docutils literal notranslate"><span class="pre">u_ff</span></code> is the feed-forward actuation specified with
get_actuation_input_port(), and <code class="docutils literal notranslate"><span class="pre">e</span></code> corresponds to effort limit (see
JointActuator::effort_limit()).</p>
<p>Notice that actuation through get_actuation_input_port() and PD
control are not mutually exclusive, and they can be used together.
This is better explained through examples: 1. <strong>PD controlled
gripper</strong>. In this case, only PD control is used to drive the opening
and closing of the fingers. The feed-forward term is assumed to be
zero and the actuation input port is not required to be connected. 2.
<strong>Robot arm</strong>. A typical configuration consists on applying gravity
compensation in the feed-forward term plus PD control to drive the
robot to a given desired state.</p>
<p>** Actuation input ports requirements</p>
<p>Actuation input ports and desired state input ports need not be
connected: - Unconnected actuation inputs default to zero, simplifying
diagram wiring for models relying solely on PD controllers. - PD
controllers are disarmed when their model instance’s desired state
input port is disconnected. In this state, they have no effect on
dynamics, behaving as if no PD controller exists. This allows a
MultibodyPlant model to be used outside simulation (e.g., for
visualization).</p>
<p>Note that both ports are always created but will be zero-sized for
model instances without actuation.</p>
<p>** Net actuation</p>
<p>The total joint actuation applied via the actuation input port
(get_actuation_input_port()) and applied by the PD controllers is
reported by the net actuation port (get_net_actuation_output_port()).
That is, the net actuation port reports the total actuation applied by
a given actuator.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>PD controllers are ignored when a joint is locked (see
Joint::Lock()), and thus they have no effect on the actuation
output.</p>
</div>
<p><a href="#id49"><span class="problematic" id="id50">**</span></a>** Loading models from SDFormat files</p>
<p>Drake has the capability to load multibody models from SDFormat and
URDF files. Consider the example below which loads an acrobot model:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">acrobot</span><span class="p">;</span>
<span class="n">SceneGraph</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">scene_graph</span><span class="p">;</span>
<span class="n">Parser</span><span class="w"> </span><span class="nf">parser</span><span class="p">(</span><span class="o">&amp;</span><span class="n">acrobot</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">scene_graph</span><span class="p">);</span>
<span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">url</span><span class="w"> </span><span class="o">=</span>
<span class="s">&quot;package://drake/multibody/benchmarks/acrobot/acrobot.sdf&quot;</span><span class="p">;</span>
<span class="n">parser</span><span class="p">.</span><span class="n">AddModelsFromUrl</span><span class="p">(</span><span class="n">url</span><span class="p">);</span>
</pre></div>
</div>
</details><p>As in the example above, for models including visual geometry,
collision geometry or both, the user must specify a SceneGraph for
geometry handling. You can find a full example of the LQR controlled
acrobot in examples/multibody/acrobot/run_lqr.cc.</p>
<p>AddModelFromFile() can be invoked multiple times on the same plant in
order to load multiple model instances. Other methods are available on
Parser such as AddModels() which allows creating model instances per
each <code class="docutils literal notranslate"><span class="pre">&lt;model&gt;</span></code> tag found in the file. Please refer to each of these
methods’ documentation for further details.</p>
<p><a href="#id51"><span class="problematic" id="id52">**</span></a>** Working with SceneGraph</p>
<p>** Adding a MultibodyPlant connected to a SceneGraph to your Diagram</p>
<p>Probably the simplest way to add and wire up a MultibodyPlant with a
SceneGraph in your Diagram is using AddMultibodyPlantSceneGraph().</p>
<p>Recommended usages:</p>
<p>Assign to a MultibodyPlant reference (ignoring the SceneGraph):</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">plant</span><span class="w"> </span><span class="o">=</span>
<span class="n">AddMultibodyPlantSceneGraph</span><span class="p">(</span><span class="o">&amp;</span><span class="n">builder</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="o">/+</span><span class="w"> </span><span class="n">time_step</span><span class="w"> </span><span class="o">+/</span><span class="p">);</span>
<span class="n">plant</span><span class="p">.</span><span class="n">DoFoo</span><span class="p">(...);</span>
</pre></div>
</div>
</details><p>This flavor is the simplest, when the SceneGraph is not explicitly
needed. (It can always be retrieved later via
GetSubsystemByName(“scene_graph”).)</p>
<p>Assign to auto, and use the named public fields:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="n">items</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AddMultibodyPlantSceneGraph</span><span class="p">(</span><span class="o">&amp;</span><span class="n">builder</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="o">/+</span><span class="w"> </span><span class="n">time_step</span><span class="w"> </span><span class="o">+/</span><span class="p">);</span>
<span class="n">items</span><span class="p">.</span><span class="n">plant</span><span class="p">.</span><span class="n">DoFoo</span><span class="p">(...);</span>
<span class="n">items</span><span class="p">.</span><span class="n">scene_graph</span><span class="p">.</span><span class="n">DoBar</span><span class="p">(...);</span>
</pre></div>
</div>
</details><p>or taking advantage of C++’s structured binding:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="p">[</span><span class="n">plant</span><span class="p">,</span><span class="w"> </span><span class="n">scene_graph</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AddMultibodyPlantSceneGraph</span><span class="p">(</span><span class="o">&amp;</span><span class="n">builder</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">);</span>
<span class="p">...</span>
<span class="n">plant</span><span class="p">.</span><span class="n">DoFoo</span><span class="p">(...);</span>
<span class="n">scene_graph</span><span class="p">.</span><span class="n">DoBar</span><span class="p">(...);</span>
</pre></div>
</div>
</details><p>This is the easiest way to use both the plant and scene_graph.</p>
<p>Assign to already-declared pointer variables:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;*</span><span class="w"> </span><span class="n">plant</span><span class="p">{};</span>
<span class="n">SceneGraph</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;*</span><span class="w"> </span><span class="n">scene_graph</span><span class="p">{};</span>
<span class="n">std</span><span class="o">::</span><span class="n">tie</span><span class="p">(</span><span class="n">plant</span><span class="p">,</span><span class="w"> </span><span class="n">scene_graph</span><span class="p">)</span><span class="w"> </span><span class="o">=</span>
<span class="n">AddMultibodyPlantSceneGraph</span><span class="p">(</span><span class="o">&amp;</span><span class="n">builder</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="o">/+</span><span class="w"> </span><span class="n">time_step</span><span class="w"> </span><span class="o">+/</span><span class="p">);</span>
<span class="n">plant</span><span class="o">-&gt;</span><span class="n">DoFoo</span><span class="p">(...);</span>
<span class="n">scene_graph</span><span class="o">-&gt;</span><span class="n">DoBar</span><span class="p">(...);</span>
</pre></div>
</div>
</details><p>This flavor is most useful when the pointers are class member fields
(and so perhaps cannot be references).</p>
<p>** Registering geometry with a SceneGraph</p>
<p>MultibodyPlant users can register geometry with a SceneGraph for
essentially two purposes; a) visualization and, b) contact modeling.</p>
<p>Before any geometry registration takes place, a user <strong>must</strong> first
make a call to RegisterAsSourceForSceneGraph() in order to register
the MultibodyPlant as a client of a SceneGraph instance, point at
which the plant will have assigned a valid geometry::SourceId. At
Finalize(), MultibodyPlant will declare input/output ports as
appropriate to communicate with the SceneGraph instance on which
registrations took place. All geometry registration <strong>must</strong> be
performed pre-finalize.</p>
<p>Multibodyplant declares an input port for geometric queries, see
get_geometry_query_input_port(). If MultibodyPlant registers geometry
with a SceneGraph via calls to RegisterCollisionGeometry(), users may
use this port for geometric queries. The port must be connected to the
same SceneGraph used for registration. The preferred mechanism is to
use AddMultibodyPlantSceneGraph() as documented above.</p>
<p>In extraordinary circumstances, this can be done by hand and the setup
process will include:</p>
<ol class="arabic simple">
<li><p>Call to RegisterAsSourceForSceneGraph().</p></li>
<li><p>Calls to RegisterCollisionGeometry(), as many as needed.</p></li>
<li><p>Call to Finalize(), user is done specifying the model.</p></li>
</ol>
<p>4. Connect geometry::SceneGraph::get_query_output_port() to
get_geometry_query_input_port().
5. Connect get_geometry_pose_output_port() to
geometry::SceneGraph::get_source_pose_port()</p>
<p>Refer to the documentation provided in each of the methods above for
further details.</p>
<p>** Accessing point contact parameters MultibodyPlant’s point contact
model looks for model parameters stored as
geometry::ProximityProperties by geometry::SceneGraph. These
properties can be obtained before or after context creation through
geometry::SceneGraphInspector APIs as outlined below. MultibodyPlant
expects the following properties for point contact modeling:</p>
<p><a href="#id123"><span class="problematic" id="id124">|Group name|Property Name|Required|Property Type|Property Description|</span></a>
<a href="#id125"><span class="problematic" id="id126">|:--------:|</span></a>:———–:<a href="#id127"><span class="problematic" id="id128">|:------:|</span></a>:—————-:<a href="#id129"><span class="problematic" id="id130">|:-------------------|</span></a>
<a href="#id131"><span class="problematic" id="id132">|material|coulomb_friction|yes¹|CoulombFriction&lt;T&gt;|Static and Dynamic
friction.|</span></a> <a href="#id133"><span class="problematic" id="id134">|material|point_contact_stiffness|no²|T|</span></a> Compliant point
contact stiffness.| <a href="#id135"><span class="problematic" id="id136">|material|hunt_crossley_dissipation |no²⁴|T|</span></a>
Compliant contact dissipation.|
<a href="#id137"><span class="problematic" id="id138">|material|relaxation_time|yes³⁴|T|Linear Kelvin–Voigt model
parameter.|</span></a></p>
<p>¹ Collision geometry is required to be registered with a
geometry::ProximityProperties object that contains the (“material”,
“coulomb_friction”) property. If the property is missing,
MultibodyPlant will throw an exception.</p>
<p>² If the property is missing, MultibodyPlant will use a heuristic
value as the default. Refer to the section point_contact_defaults
“Point Contact Default Parameters” for further details.</p>
<p>³ When using a linear Kelvin–Voigt model of dissipation (for instance
when selecting the SAP solver), collision geometry is required to be
registered with a geometry::ProximityProperties object that contains
the (“material”, “relaxation_time”) property. If the property is
missing, an exception will be thrown.</p>
<p>⁴ We allow to specify both hunt_crossley_dissipation and
relaxation_time for a given geometry. However only one of these will
get used, depending on the configuration of the MultibodyPlant. As an
example, if the SAP contact approximation is specified (see
set_discrete_contact_approximation()) only the relaxation_time is used
while hunt_crossley_dissipation is ignored. Conversely, if the TAMSI,
Similar or Lagged approximation is used (see
set_discrete_contact_approximation()) only hunt_crossley_dissipation
is used while relaxation_time is ignored. Currently, a continuous
MultibodyPlant model will always use the Hunt &amp; Crossley model and
relaxation_time will be ignored.</p>
<p>Accessing and modifying contact properties requires interfacing with
geometry::SceneGraph’s model inspector. Interfacing with a model
inspector obtained from geometry::SceneGraph will provide the default
registered values for a given parameter. These are the values that
will initially appear in a systems::Context created by
CreateDefaultContext(). Subsequently, true system parameters can be
accessed and changed through a systems::Context once available. For
both of the above cases, proximity properties are accessed through
geometry::SceneGraphInspector APIs.</p>
<p>Before context creation an inspector can be retrieved directly from
SceneGraph as:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// For a SceneGraph&lt;T&gt; instance called scene_graph.</span>
<span class="k">const</span><span class="w"> </span><span class="n">geometry</span><span class="o">::</span><span class="n">SceneGraphInspector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">inspector</span><span class="w"> </span><span class="o">=</span>
<span class="n">scene_graph</span><span class="p">.</span><span class="n">model_inspector</span><span class="p">();</span>
</pre></div>
</div>
</details><p>After context creation, an inspector can be retrieved from the state
stored in the context:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// For a MultibodyPlant&lt;T&gt; instance called mbp and a Context&lt;T&gt; called</span>
<span class="c1">// context.</span>
<span class="k">const</span><span class="w"> </span><span class="n">geometry</span><span class="o">::</span><span class="n">SceneGraphInspector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">inspector</span><span class="w"> </span><span class="o">=</span>
<span class="n">mbp</span><span class="p">.</span><span class="n">EvalSceneGraphInspector</span><span class="p">(</span><span class="n">context</span><span class="p">);</span>
</pre></div>
</div>
</details><p>Once an inspector is available, proximity properties can be retrieved
as:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// For a body with GeometryId called geometry_id</span>
<span class="k">const</span><span class="w"> </span><span class="n">geometry</span><span class="o">::</span><span class="n">ProximityProperties</span><span class="o">*</span><span class="w"> </span><span class="n">props</span><span class="w"> </span><span class="o">=</span>
<span class="n">inspector</span><span class="p">.</span><span class="n">GetProximityProperties</span><span class="p">(</span><span class="n">geometry_id</span><span class="p">);</span>
<span class="k">const</span><span class="w"> </span><span class="n">CoulombFriction</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">geometry_friction</span><span class="w"> </span><span class="o">=</span>
<span class="n">props</span><span class="o">-&gt;</span><span class="n">GetProperty</span><span class="o">&lt;</span><span class="n">CoulombFriction</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="s">&quot;material&quot;</span><span class="p">,</span>
<span class="s">&quot;coulomb_friction&quot;</span><span class="p">);</span>
</pre></div>
</div>
</details><p><a href="#id53"><span class="problematic" id="id54">**</span></a>** Working with MultibodyElement parameters Several
MultibodyElements expose parameters, allowing the user flexible
modification of some aspects of the plant’s model, post
systems::Context creation. For details, refer to the documentation for
the MultibodyElement whose parameters you are trying to modify/access
(e.g. RigidBody, FixedOffsetFrame, etc.)</p>
<p>As an example, here is how to access and modify rigid body mass
parameters:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">plant</span><span class="p">;</span>
<span class="c1">// ... Code to add bodies, finalize plant, and to obtain a context.</span>
<span class="k">const</span><span class="w"> </span><span class="n">RigidBody</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">body</span><span class="w"> </span><span class="o">=</span>
<span class="n">plant</span><span class="p">.</span><span class="n">GetRigidBodyByName</span><span class="p">(</span><span class="s">&quot;BodyName&quot;</span><span class="p">);</span>
<span class="k">const</span><span class="w"> </span><span class="n">SpatialInertia</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">M_BBo_B</span><span class="w"> </span><span class="o">=</span>
<span class="n">body</span><span class="p">.</span><span class="n">GetSpatialInertiaInBodyFrame</span><span class="p">(</span><span class="n">context</span><span class="p">);</span>
<span class="c1">// .. logic to determine a new SpatialInertia parameter for body.</span>
<span class="k">const</span><span class="w"> </span><span class="n">SpatialInertia</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">M_BBo_B_new</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">....</span>

<span class="c1">// Modify the body parameter for spatial inertia.</span>
<span class="n">body</span><span class="p">.</span><span class="n">SetSpatialInertiaInBodyFrame</span><span class="p">(</span><span class="o">&amp;</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="n">M_BBo_B_new</span><span class="p">);</span>
</pre></div>
</div>
</details><p>Another example, working with automatic differentiation in order to
take derivatives with respect to one of the bodies’ masses:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">plant</span><span class="p">;</span>
<span class="c1">// ... Code to add bodies, finalize plant, and to obtain a</span>
<span class="c1">// context and a body&#39;s spatial inertia M_BBo_B.</span>

<span class="c1">// Scalar convert the plant.</span>
<span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="n">AutoDiffXd</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">plant_autodiff</span><span class="w"> </span><span class="o">=</span>
<span class="n">systems</span><span class="o">::</span><span class="n">System</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">ToAutoDiffXd</span><span class="p">(</span><span class="n">plant</span><span class="p">);</span>
<span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Context</span><span class="o">&lt;</span><span class="n">AutoDiffXd</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">context_autodiff</span><span class="w"> </span><span class="o">=</span>
<span class="n">plant_autodiff</span><span class="o">-&gt;</span><span class="n">CreateDefaultContext</span><span class="p">();</span>
<span class="n">context_autodiff</span><span class="o">-&gt;</span><span class="n">SetTimeStateAndParametersFrom</span><span class="p">(</span><span class="n">context</span><span class="p">);</span>

<span class="k">const</span><span class="w"> </span><span class="n">RigidBody</span><span class="o">&lt;</span><span class="n">AutoDiffXd</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">body</span><span class="w"> </span><span class="o">=</span>
<span class="n">plant_autodiff</span><span class="o">-&gt;</span><span class="n">GetRigidBodyByName</span><span class="p">(</span><span class="s">&quot;BodyName&quot;</span><span class="p">);</span>

<span class="c1">// Modify the body parameter for mass.</span>
<span class="k">const</span><span class="w"> </span><span class="n">AutoDiffXd</span><span class="w"> </span><span class="nf">mass_autodiff</span><span class="p">(</span><span class="n">mass</span><span class="p">,</span><span class="w"> </span><span class="n">Vector1d</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
<span class="n">body</span><span class="p">.</span><span class="n">SetMass</span><span class="p">(</span><span class="n">context_autodiff</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span><span class="w"> </span><span class="n">mass_autodiff</span><span class="p">);</span>

<span class="c1">// M_autodiff(i, j).derivatives()(0), contains the derivatives of</span>
<span class="c1">// M(i, j) with respect to the body&#39;s mass.</span>
<span class="n">MatrixX</span><span class="o">&lt;</span><span class="n">AutoDiffXd</span><span class="o">&gt;</span><span class="w"> </span><span class="n">M_autodiff</span><span class="p">(</span><span class="n">plant_autodiff</span><span class="o">-&gt;</span><span class="n">num_velocities</span><span class="p">(),</span>
<span class="n">plant_autodiff</span><span class="o">-&gt;</span><span class="n">num_velocities</span><span class="p">());</span>
<span class="n">plant_autodiff</span><span class="o">-&gt;</span><span class="n">CalcMassMatrix</span><span class="p">(</span><span class="o">*</span><span class="n">context_autodiff</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">M_autodiff</span><span class="p">);</span>
</pre></div>
</div>
</details><p><a href="#id55"><span class="problematic" id="id56">**</span></a>** Adding modeling elements</p>
<p>Add multibody elements to a MultibodyPlant with methods like:</p>
<ul class="simple">
<li><p>Bodies: AddRigidBody()</p></li>
<li><p>Joints: AddJoint()</p></li>
<li><p>see mbp_construction “Construction” for more.</p></li>
</ul>
<p>All modeling elements <strong>must</strong> be added before Finalize() is called.
See mbp_finalize_stage “Finalize stage” for a discussion.</p>
<p><a href="#id57"><span class="problematic" id="id58">**</span></a>** Modeling contact</p>
<p>Please refer to drake_contacts “Contact Modeling in Drake” for details
on the available approximations, setup, and considerations for a
multibody simulation with frictional contact.</p>
<p><a href="#id59"><span class="problematic" id="id60">**</span></a>** Energy and Power</p>
<p>MultibodyPlant implements the System energy and power methods, with
some limitations. - Kinetic energy: fully implemented. - Potential
energy and conservative power: currently include only gravity and
contributions from ForceElement objects; potential energy from
compliant contact and joint limits are not included. - Nonconservative
power: currently includes only contributions from ForceElement
objects; actuation and input port forces, joint damping, and
dissipation from joint limits, friction, and contact dissipation are
not included.</p>
<p>See Drake issue #12942 for more discussion.</p>
<p><a href="#id61"><span class="problematic" id="id62">**</span></a>** Finalize() stage</p>
<p>Once the user is done adding modeling elements and registering
geometry, a call to Finalize() must be performed. This call will: -
Build the underlying tree structure of the multibody model, - declare
the plant’s state, - declare the plant’s input and output ports, -
declare collision filters to ignore collisions among rigid bodies: -
between rigid bodies connected by a joint, - within subgraphs of
welded rigid bodies.</p>
<p>Note that MultibodyPlant will <em>not</em> introduce any automatic collision
filters on deformable bodies. Collision filters for deformable bodies
can be explicitly applied via
ExcludeCollisionGeometriesWithCollisionFilterGroupPair() or during
parsing.</p>
<p><a href="#id63"><span class="problematic" id="id64">**</span></a>** References</p>
<ul class="simple">
<li><p>[Featherstone 2008] Featherstone, R., 2008.</p></li>
</ul>
<p>Rigid body dynamics algorithms. Springer.
- [Jain 2010] Jain, A., 2010.
Robot and multibody dynamics: analysis and algorithms.
Springer Science &amp; Business Media.
- [Seth 2010] Seth, A., Sherman, M., Eastman, P. and Delp, S., 2010.
Minimal formulation of joint motion for biomechanisms.
Nonlinear dynamics, 62(1), pp.291-303.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_step</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.__init__" title="Link to this definition"></a></dt>
<dd><p>This constructor creates a plant with a single “world” body.
Therefore, right after creation, num_bodies() returns one.</p>
<p>MultibodyPlant offers two different modalities to model mechanical
systems in time. These are: 1. As a discrete system with periodic
updates, <code class="docutils literal notranslate"><span class="pre">time_step</span></code> is strictly greater than zero. 2. As a
continuous system, <code class="docutils literal notranslate"><span class="pre">time_step</span></code> equals exactly zero.</p>
<p>Currently the discrete model is preferred for simulation given its
robustness and speed in problems with frictional contact. However this
might change as we work towards developing better strategies to model
contact. See multibody_simulation for further details.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Users should be aware of current limitations in either modeling
modality. While the discrete model is often the preferred option
for problems with frictional contact given its robustness and
speed, it might become unstable when using large feedback gains,
high damping or large external forcing. MultibodyPlant will throw
an exception whenever the discrete solver is detected to fail.
Conversely, the continuous modality has the potential to leverage
the robustness and accuracy control provide by Drake’s
integrators. However thus far this has proved difficult in
practice and especially due to poor performance.</p>
</div>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">time_step</span></code>:</dt><dd><p>Indicates whether <code class="docutils literal notranslate"><span class="pre">this</span></code> plant is modeled as a continuous system
(<code class="docutils literal notranslate"><span class="pre">time_step</span> <span class="pre">=</span> <span class="pre">0</span></code>) or as a discrete system with periodic updates
of period <code class="docutils literal notranslate"><span class="pre">time_step</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>. See multibody_simulation for further
details.</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Currently the continuous modality with <code class="docutils literal notranslate"><span class="pre">time_step</span> <span class="pre">=</span> <span class="pre">0</span></code> does not
support joint limits for simulation, these are ignored.
MultibodyPlant prints a warning to console if joint limits are
provided. If your simulation requires joint limits currently you
must use a discrete MultibodyPlant model.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if time_step is negative.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.AddBallConstraint">
<span class="sig-name descname"><span class="pre">AddBallConstraint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body_A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.RigidBody_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_AP</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.RigidBody_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_BQ</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.MultibodyConstraintId" title="pydrake.multibody.tree.MultibodyConstraintId"><span class="pre">pydrake.multibody.tree.MultibodyConstraintId</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.AddBallConstraint" title="Link to this definition"></a></dt>
<dd><p>Defines a constraint such that point P affixed to body A is coincident
at all times with point Q affixed to body B, effectively modeling a
ball-and-socket joint.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body_A</span></code>:</dt><dd><p>RigidBody to which point P is rigidly attached.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_AP</span></code>:</dt><dd><p>Position of point P in body A’s frame.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body_B</span></code>:</dt><dd><p>RigidBody to which point Q is rigidly attached.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BQ</span></code>:</dt><dd><p>(optional) Position of point Q in body B’s frame. If p_BQ is
std::nullopt, then p_BQ will be computed so that the constraint is
satisfied for the default configuration at Finalize() time;
subsequent changes to the default configuration will not change
the computed p_BQ.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>the id of the newly added constraint.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>RuntimeError if bodies A and B are the same body.</strong> – </p></li>
<li><p><strong>RuntimeError if the MultibodyPlant has already been finalized.</strong> – </p></li>
<li><p><strong>RuntimeError if this MultibodyPlant is not a discrete model</strong> – </p></li>
<li><p><strong>(</strong><strong>is_discrete</strong><strong>(</strong><strong>) </strong><strong>== false</strong><strong>)</strong> – </p></li>
<li><p><strong>RuntimeError if this MultibodyPlant's underlying contact</strong> – </p></li>
<li><p><strong>solver is not SAP.</strong><strong> (</strong><strong>i.e. get_discrete_contact_solver</strong><strong>(</strong><strong>) </strong><strong>!=</strong> – </p></li>
<li><p><strong>DiscreteContactSolver::kSap</strong><strong>)</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.AddCouplerConstraint">
<span class="sig-name descname"><span class="pre">AddCouplerConstraint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">joint0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.Joint_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">joint1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.Joint_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gear_ratio</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.0</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.MultibodyConstraintId" title="pydrake.multibody.tree.MultibodyConstraintId"><span class="pre">pydrake.multibody.tree.MultibodyConstraintId</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.AddCouplerConstraint" title="Link to this definition"></a></dt>
<dd><p>Defines a holonomic constraint between two single-dof joints
<code class="docutils literal notranslate"><span class="pre">joint0</span></code> and <code class="docutils literal notranslate"><span class="pre">joint1</span></code> with positions q₀ and q₁, respectively, such
that q₀ = ρ⋅q₁ + Δq, where ρ is the gear ratio and Δq is a fixed
offset. The gear ratio can have units if the units of q₀ and q₁ are
different. For instance, between a prismatic and a revolute joint the
gear ratio will specify the “pitch” of the resulting mechanism. As
defined, <code class="docutils literal notranslate"><span class="pre">offset</span></code> has units of <code class="docutils literal notranslate"><span class="pre">q₀</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>joint0 and/or joint1 can still be actuated, regardless of whether
we have coupler constraint among them. That is, one or both of
these joints can have external actuation applied to them.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Generally, to couple (q0, q1, q2), the user would define a coupler
between (q0, q1) and a second coupler between (q1, q2), or any
combination therein.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>if joint0 and joint1 are not both single-dof joints.</strong> – </p></li>
<li><p><strong>RuntimeError if the MultibodyPlant has already been finalized.</strong> – </p></li>
<li><p><strong>RuntimeError if this MultibodyPlant is not a discrete model</strong> – </p></li>
<li><p><strong>(</strong><strong>is_discrete</strong><strong>(</strong><strong>) </strong><strong>== false</strong><strong>)</strong> – </p></li>
<li><p><strong>RuntimeError if this MultibodyPlant's underlying contact</strong> – </p></li>
<li><p><strong>solver is not SAP.</strong><strong> (</strong><strong>i.e. get_discrete_contact_solver</strong><strong>(</strong><strong>) </strong><strong>!=</strong> – </p></li>
<li><p><strong>DiscreteContactSolver::kSap</strong><strong>)</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.AddDistanceConstraint">
<span class="sig-name descname"><span class="pre">AddDistanceConstraint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body_A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.RigidBody_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_AP</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.RigidBody_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_BQ</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stiffness</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">inf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">damping</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.0</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.MultibodyConstraintId" title="pydrake.multibody.tree.MultibodyConstraintId"><span class="pre">pydrake.multibody.tree.MultibodyConstraintId</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.AddDistanceConstraint" title="Link to this definition"></a></dt>
<dd><p>Defines a distance constraint between a point P on a body A and a
point Q on a body B.</p>
<p>This constraint can be compliant, modeling a spring with free length
<code class="docutils literal notranslate"><span class="pre">distance</span></code> and given <code class="docutils literal notranslate"><span class="pre">stiffness</span></code> and <code class="docutils literal notranslate"><span class="pre">damping</span></code> parameters
between points P and Q. For d = ‖p_PQ‖, then a compliant distance
constraint models a spring with force along p_PQ given by:</p>
<p>f = −stiffness ⋅ d − damping ⋅ ḋ</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body_A</span></code>:</dt><dd><p>RigidBody to which point P is rigidly attached.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_AP</span></code>:</dt><dd><p>Position of point P in body A’s frame.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body_B</span></code>:</dt><dd><p>RigidBody to which point Q is rigidly attached.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BQ</span></code>:</dt><dd><p>Position of point Q in body B’s frame.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">distance</span></code>:</dt><dd><p>Fixed length of the distance constraint, in meters. It must be
strictly positive.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">stiffness</span></code>:</dt><dd><p>For modeling a spring with free length equal to <code class="docutils literal notranslate"><span class="pre">distance</span></code>, the
stiffness parameter in N/m. Optional, with its default value being
infinite to model a rigid massless rod of length <code class="docutils literal notranslate"><span class="pre">distance</span></code>
connecting points A and B.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">damping</span></code>:</dt><dd><p>For modeling a spring with free length equal to <code class="docutils literal notranslate"><span class="pre">distance</span></code>,
damping parameter in N⋅s/m. Optional, with its default value being
zero for a non-dissipative constraint.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>the id of the newly added constraint.</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Currently, it is the user’s responsibility to initialize the
model’s context in a configuration compatible with the newly added
constraint.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>A distance constraint is the wrong modeling choice if the distance
needs to go through zero. To constrain two points to be coincident
we need a 3-dof ball constraint, the 1-dof distance constraint is
singular in this case. Therefore we require the distance parameter
to be strictly positive.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When a new context is created, a DistanceConstraintParams is
initialized to store the parameters passed to this function.
Parameters in the context can be modified with calls to
SetDistanceConstraintParams().</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if bodies A and B are the same body.</strong> – </p></li>
<li><p><strong>RuntimeError if distance is not strictly positive.</strong> – </p></li>
<li><p><strong>RuntimeError if stiffness is not positive</strong><strong> or </strong><strong>zero.</strong> – </p></li>
<li><p><strong>RuntimeError if damping is not positive</strong><strong> or </strong><strong>zero.</strong> – </p></li>
<li><p><strong>RuntimeError if the MultibodyPlant has already been finalized.</strong> – </p></li>
<li><p><strong>RuntimeError if this MultibodyPlant is not a discrete model</strong> – </p></li>
<li><p><strong>(</strong><strong>is_discrete</strong><strong>(</strong><strong>) </strong><strong>== false</strong><strong>)</strong> – </p></li>
<li><p><strong>RuntimeError if this MultibodyPlant's underlying contact</strong> – </p></li>
<li><p><strong>solver is not SAP.</strong><strong> (</strong><strong>i.e. get_discrete_contact_solver</strong><strong>(</strong><strong>) </strong><strong>!=</strong> – </p></li>
<li><p><strong>DiscreteContactSolver::kSap</strong><strong>)</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.AddForceElement">
<span class="sig-name descname"><span class="pre">AddForceElement</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">force_element</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.ForceElement_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.multibody.tree.ForceElement_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.AddForceElement" title="Link to this definition"></a></dt>
<dd><p>Adds a new force element model of type <code class="docutils literal notranslate"><span class="pre">ForceElementType</span></code> to
<code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant. The arguments to this method <code class="docutils literal notranslate"><span class="pre">args</span></code> are
forwarded to <a href="#id65"><span class="problematic" id="id66">``</span></a>ForceElementType`’s constructor.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">args</span></code>:</dt><dd><p>Zero or more parameters provided to the constructor of the new
force element. It must be the case that
<cite>ForceElementType&lt;T&gt;(args)`</cite> is a valid constructor.</p>
</dd>
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">ForceElementType</span></code>:</dt><dd><p>The type of the ForceElement to add. As there is always a
UniformGravityFieldElement present (accessible through
gravity_field()), an exception will be thrown if this function is
called to add another UniformGravityFieldElement.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A constant reference to the new ForceElement just added, of type
<code class="docutils literal notranslate"><span class="pre">ForceElementType&lt;T&gt;</span></code> specialized on the scalar type T of
<code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant. It will remain valid for the lifetime of
<code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>The ForceElement class’s documentation for further details on how
a force element is defined.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.AddFrame">
<span class="sig-name descname"><span class="pre">AddFrame</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.Frame_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.multibody.tree.Frame_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.AddFrame" title="Link to this definition"></a></dt>
<dd><p>This method adds a Frame of type <code class="docutils literal notranslate"><span class="pre">FrameType&lt;T&gt;</span></code>. For more
information, please see the corresponding constructor of
<code class="docutils literal notranslate"><span class="pre">FrameType</span></code>.</p>
<dl class="simple">
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">FrameType</span></code>:</dt><dd><p>Template which will be instantiated on <code class="docutils literal notranslate"><span class="pre">T</span></code>.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame</span></code>:</dt><dd><p>Unique pointer frame instance.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A constant reference to the new Frame just added, which will
remain valid for the lifetime of <code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.AddJoint">
<span class="sig-name descname"><span class="pre">AddJoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">joint</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.Joint_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.multibody.tree.Joint_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.AddJoint" title="Link to this definition"></a></dt>
<dd><p>This method adds a Joint of type <code class="docutils literal notranslate"><span class="pre">JointType</span></code> between two bodies. For
more information, see the below overload of <code class="docutils literal notranslate"><span class="pre">AddJoint&lt;&gt;</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.AddJointActuator">
<span class="sig-name descname"><span class="pre">AddJointActuator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">joint</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.Joint_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">effort_limit</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">inf</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.multibody.tree.JointActuator_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.AddJointActuator" title="Link to this definition"></a></dt>
<dd><p>Creates and adds a JointActuator model for an actuator acting on a
given <code class="docutils literal notranslate"><span class="pre">joint</span></code>. This method returns a constant reference to the
actuator just added, which will remain valid for the lifetime of
<code class="docutils literal notranslate"><span class="pre">this</span></code> plant.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">name</span></code>:</dt><dd><p>A string that uniquely identifies the new actuator to be added to
<code class="docutils literal notranslate"><span class="pre">this</span></code> model. A RuntimeError is thrown if an actuator with the
same name already exists in the model. See
HasJointActuatorNamed().</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">joint</span></code>:</dt><dd><p>The Joint to be actuated by the new JointActuator.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">effort_limit</span></code>:</dt><dd><p>The maximum effort for the actuator. It must be strictly positive,
otherwise an RuntimeError is thrown. If +∞, the actuator has no
limit, which is the default. The effort limit has physical units
in accordance to the joint type it actuates. For instance, it will
have units of N⋅m (torque) for revolute joints while it will have
units of N (force) for prismatic joints.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The effort limit is unused by MultibodyPlant and is simply
provided here for bookkeeping purposes. It will not, for instance,
saturate external actuation inputs based on this value. If, for
example, a user intends to saturate the force/torque that is
applied to the MultibodyPlant via this actuator, the user-level
code (e.g., a controller) should query this effort limit and
impose the saturation there.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A constant reference to the new JointActuator just added, which
will remain valid for the lifetime of <code class="docutils literal notranslate"><span class="pre">this</span></code> plant or until the
JointActuator has been removed from the plant with
RemoveJointActuator().</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>RuntimeError if joint.num_velocities</strong><strong>(</strong><strong>) </strong><strong>&gt; 1 since for now we</strong> – </p></li>
<li><p><strong>only support actuators for single dof joints.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>RemoveJointActuator()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.AddModelInstance">
<span class="sig-name descname"><span class="pre">AddModelInstance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.AddModelInstance" title="Link to this definition"></a></dt>
<dd><p>Creates a new model instance. Returns the index for the model
instance.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">name</span></code>:</dt><dd><p>A string that uniquely identifies the new instance to be added to
<code class="docutils literal notranslate"><span class="pre">this</span></code> model. An exception is thrown if an instance with the
same name already exists in the model. See
HasModelInstanceNamed().</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.AddRigidBody">
<span class="sig-name descname"><span class="pre">AddRigidBody</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.AddRigidBody" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>AddRigidBody(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], name: str, M_BBo_B: pydrake.multibody.tree.SpatialInertia = SpatialInertia.Zero()) -&gt; pydrake.multibody.tree.RigidBody_[AutoDiffXd]</p></li>
</ol>
<p>Creates a rigid body with the provided name and spatial inertia. This
method returns a constant reference to the body just added, which will
remain valid for the lifetime of <code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant. The body
will use the default model instance (model_instance “more on model
instances”).</p>
<p>Example of usage:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">plant</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// ... Code to define spatial_inertia, a SpatialInertia&lt;T&gt; object ...</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">RigidBody</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">body</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="n">plant</span><span class="p">.</span><span class="n">AddRigidBody</span><span class="p">(</span><span class="s">&quot;BodyName&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">spatial_inertia</span><span class="p">);</span>
</pre></div>
</div>
</details><dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">name</span></code>:</dt><dd><p>A string that identifies the new body to be added to <code class="docutils literal notranslate"><span class="pre">this</span></code>
model. A RuntimeError is thrown if a body named <code class="docutils literal notranslate"><span class="pre">name</span></code> already
is part of the model in the default model instance. See
HasBodyNamed(), RigidBody::name().</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">M_BBo_B</span></code>:</dt><dd><p>The SpatialInertia of the new rigid body to be added to <code class="docutils literal notranslate"><span class="pre">this</span></code>
MultibodyPlant, computed about the body frame origin <code class="docutils literal notranslate"><span class="pre">Bo</span></code> and
expressed in the body frame B. When not provided, defaults to
zero.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A constant reference to the new RigidBody just added, which will
remain valid for the lifetime of <code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>RuntimeError if additional model instances have been created</strong> – </p></li>
<li><p><strong>beyond the world and default instances.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>AddRigidBody(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex, M_BBo_B: pydrake.multibody.tree.SpatialInertia = SpatialInertia.Zero()) -&gt; pydrake.multibody.tree.RigidBody_[AutoDiffXd]</p></li>
</ol>
<p>Creates a rigid body with the provided name and spatial inertia. This
method returns a constant reference to the body just added, which will
remain valid for the lifetime of <code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant.</p>
<p>Example of usage:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">plant</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// ... Code to define spatial_inertia, a SpatialInertia&lt;T&gt; object ...</span>
<span class="w">  </span><span class="n">ModelInstanceIndex</span><span class="w"> </span><span class="n">model_instance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">plant</span><span class="p">.</span><span class="n">AddModelInstance</span><span class="p">(</span><span class="s">&quot;instance&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">RigidBody</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">body</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="n">plant</span><span class="p">.</span><span class="n">AddRigidBody</span><span class="p">(</span><span class="s">&quot;BodyName&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">model_instance</span><span class="p">,</span><span class="w"> </span><span class="n">spatial_inertia</span><span class="p">);</span>
</pre></div>
</div>
</details><dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">name</span></code>:</dt><dd><p>A string that identifies the new body to be added to <code class="docutils literal notranslate"><span class="pre">this</span></code>
model. A RuntimeError is thrown if a body named <code class="docutils literal notranslate"><span class="pre">name</span></code> already
is part of <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>. See HasBodyNamed(),
RigidBody::name().</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>:</dt><dd><p>A model instance index which this body is part of.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">M_BBo_B</span></code>:</dt><dd><p>The SpatialInertia of the new rigid body to be added to <code class="docutils literal notranslate"><span class="pre">this</span></code>
MultibodyPlant, computed about the body frame origin <code class="docutils literal notranslate"><span class="pre">Bo</span></code> and
expressed in the body frame B. When not provided, defaults to
zero.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A constant reference to the new RigidBody just added, which will
remain valid for the lifetime of <code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.AddWeldConstraint">
<span class="sig-name descname"><span class="pre">AddWeldConstraint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body_A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.RigidBody_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X_AP</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.math.html#pydrake.math.RigidTransform" title="pydrake.math.RigidTransform"><span class="pre">pydrake.math.RigidTransform</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">body_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.RigidBody_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X_BQ</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.math.html#pydrake.math.RigidTransform" title="pydrake.math.RigidTransform"><span class="pre">pydrake.math.RigidTransform</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.MultibodyConstraintId" title="pydrake.multibody.tree.MultibodyConstraintId"><span class="pre">pydrake.multibody.tree.MultibodyConstraintId</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.AddWeldConstraint" title="Link to this definition"></a></dt>
<dd><p>Defines a constraint such that frame P affixed to body A is coincident
at all times with frame Q affixed to body B, effectively modeling a
weld joint.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body_A</span></code>:</dt><dd><p>RigidBody to which frame P is rigidly attached.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">X_AP</span></code>:</dt><dd><p>Pose of frame P in body A’s frame.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body_B</span></code>:</dt><dd><p>RigidBody to which frame Q is rigidly attached.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">X_BQ</span></code>:</dt><dd><p>Pose of frame Q in body B’s frame.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>the id of the newly added constraint.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>RuntimeError if bodies A and B are the same body.</strong> – </p></li>
<li><p><strong>RuntimeError if the MultibodyPlant has already been finalized.</strong> – </p></li>
<li><p><strong>RuntimeError if this MultibodyPlant is not a discrete model</strong> – </p></li>
<li><p><strong>(</strong><strong>is_discrete</strong><strong>(</strong><strong>) </strong><strong>== false</strong><strong>)</strong> – </p></li>
<li><p><strong>RuntimeError if this MultibodyPlant's underlying contact</strong> – </p></li>
<li><p><strong>solver is not SAP.</strong><strong> (</strong><strong>i.e. get_discrete_contact_solver</strong><strong>(</strong><strong>) </strong><strong>!=</strong> – </p></li>
<li><p><strong>DiscreteContactSolver::kSap</strong><strong>)</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcBiasCenterOfMassTranslationalAcceleration">
<span class="sig-name descname"><span class="pre">CalcBiasCenterOfMassTranslationalAcceleration</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcBiasCenterOfMassTranslationalAcceleration" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>CalcBiasCenterOfMassTranslationalAcceleration(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_A: pydrake.multibody.tree.Frame_[AutoDiffXd], frame_E: pydrake.multibody.tree.Frame_[AutoDiffXd]) -&gt; numpy.ndarray[object[3, 1]]</p></li>
</ol>
<p>For the system S of all bodies other than the world body, calculates
a𝑠Bias_AScm_E, Scm’s translational acceleration bias in frame A with
respect to “speeds” 𝑠, expressed in frame E, where Scm is the center
of mass of S and speeds 𝑠 is either q̇ or v.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>Contains the state of the multibody system.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">with_respect_to</span></code>:</dt><dd><p>Enum equal to JacobianWrtVariable::kQDot or
JacobianWrtVariable::kV, indicating whether the accceleration bias
is with respect to 𝑠 = q̇ or 𝑠 = v. Currently, an exception is
thrown if with_respect_to is JacobianWrtVariable::kQDot.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_A</span></code>:</dt><dd><p>The frame in which a𝑠Bias_AScm is measured.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_E</span></code>:</dt><dd><p>The frame in which a𝑠Bias_AScm is expressed on output.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a𝑠Bias_AScm_E Point Scm’s translational acceleration bias in frame
A with respect to speeds 𝑠 (𝑠 = q̇ or 𝑠 = v), expressed in frame
E.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>RuntimeError if this has no body except world_body</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p></li>
<li><p><strong>RuntimeError if mₛ ≤ 0</strong><strong>, </strong><strong>where mₛ is the mass</strong><strong> of </strong><strong>system S.</strong> – </p></li>
<li><p><strong>RuntimeError if with_respect_to is JacobianWrtVariable::kQDot.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcJacobianCenterOfMassTranslationalVelocity() to compute
J𝑠_v_Scm, point Scm’s translational velocity Jacobian in frame A
with respect to 𝑠.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The world_body() is ignored. asBias_AScm_E = ∑ (mᵢ aᵢ) / mₛ, where
mₛ = ∑ mᵢ is the mass of system S, mᵢ is the mass of the iᵗʰ body,
and aᵢ is the translational bias acceleration of Bᵢcm in frame A
expressed in frame E for speeds 𝑠 (Bᵢcm is the center of mass of
the iᵗʰ body).</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>See bias_acceleration_functions “Bias acceleration functions” for
theory and details.</p>
</div>
<ol class="arabic simple" start="2">
<li><p>CalcBiasCenterOfMassTranslationalAcceleration(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], model_instances: list[pydrake.multibody.tree.ModelInstanceIndex], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_A: pydrake.multibody.tree.Frame_[AutoDiffXd], frame_E: pydrake.multibody.tree.Frame_[AutoDiffXd]) -&gt; numpy.ndarray[object[3, 1]]</p></li>
</ol>
<p>For the system S containing the selected model instances, calculates
a𝑠Bias_AScm_E, Scm’s translational acceleration bias in frame A with
respect to “speeds” 𝑠, expressed in frame E, where Scm is the center
of mass of S and speeds 𝑠 is either q̇ or v.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>Contains the state of the multibody system.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">model_instances</span></code>:</dt><dd><p>Vector of selected model instances. If a model instance is
repeated in the vector (unusual), it is only counted once.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">with_respect_to</span></code>:</dt><dd><p>Enum equal to JacobianWrtVariable::kQDot or
JacobianWrtVariable::kV, indicating whether the accceleration bias
is with respect to 𝑠 = q̇ or 𝑠 = v. Currently, an exception is
thrown if with_respect_to is JacobianWrtVariable::kQDot.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_A</span></code>:</dt><dd><p>The frame in which a𝑠Bias_AScm is measured.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_E</span></code>:</dt><dd><p>The frame in which a𝑠Bias_AScm is expressed on output.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a𝑠Bias_AScm_E Point Scm’s translational acceleration bias in frame
A with respect to speeds 𝑠 (𝑠 = q̇ or 𝑠 = v), expressed in frame
E.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>RuntimeError if this has no body except world_body</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p></li>
<li><p><strong>RuntimeError if mₛ ≤ 0</strong><strong>, </strong><strong>where mₛ is the mass</strong><strong> of </strong><strong>system S.</strong> – </p></li>
<li><p><strong>RuntimeError if with_respect_to is JacobianWrtVariable::kQDot.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcJacobianCenterOfMassTranslationalVelocity() to compute
J𝑠_v_Scm, point Scm’s translational velocity Jacobian in frame A
with respect to 𝑠.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The world_body() is ignored. asBias_AScm_E = ∑ (mᵢ aᵢ) / mₛ, where
mₛ = ∑ mᵢ is the mass of system S, mᵢ is the mass of the iᵗʰ body,
and aᵢ is the translational bias acceleration of Bᵢcm in frame A
expressed in frame E for speeds 𝑠 (Bᵢcm is the center of mass of
the iᵗʰ body).</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>See bias_acceleration_functions “Bias acceleration functions” for
theory and details.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcBiasSpatialAcceleration">
<span class="sig-name descname"><span class="pre">CalcBiasSpatialAcceleration</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.systems.framework.Context_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_respect_to</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JacobianWrtVariable" title="pydrake.multibody.tree.JacobianWrtVariable"><span class="pre">pydrake.multibody.tree.JacobianWrtVariable</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.Frame_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_BoBp_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.Frame_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_E</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.Frame_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.multibody.math.SpatialAcceleration_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcBiasSpatialAcceleration" title="Link to this definition"></a></dt>
<dd><p>For one point Bp affixed/welded to a frame B, calculates A𝑠Bias_ABp,
Bp’s spatial acceleration bias in frame A with respect to “speeds” 𝑠,
expressed in frame E, where speeds 𝑠 is either q̇ or v.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>Contains the state of the multibody system.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">with_respect_to</span></code>:</dt><dd><p>Enum equal to JacobianWrtVariable::kQDot or
JacobianWrtVariable::kV, indicating whether the spatial
accceleration bias is with respect to 𝑠 = q̇ or 𝑠 = v. Currently,
an exception is thrown if with_respect_to is
JacobianWrtVariable::kQDot.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_B</span></code>:</dt><dd><p>The frame on which point Bp is affixed/welded.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BoBp_B</span></code>:</dt><dd><p>Position vector from Bo (frame_B’s origin) to point Bp (regarded
as affixed/welded to B), expressed in frame_B.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_A</span></code>:</dt><dd><p>The frame in which A𝑠Bias_ABp is measured.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_E</span></code>:</dt><dd><p>The frame in which A𝑠Bias_ABp is expressed on output.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A𝑠Bias_ABp_E Point Bp’s spatial acceleration bias in frame A with
respect to speeds 𝑠 (𝑠 = q̇ or 𝑠 = v), expressed in frame E.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcJacobianSpatialVelocity() to compute J𝑠_V_ABp, point Bp’s
spatial velocity Jacobian in frame A with respect to 𝑠.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if with_respect_to is JacobianWrtVariable::kQDot.</strong> – </p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Use CalcBiasTranslationalAcceleration() to efficiently calculate
bias translational accelerations for a list of points (each fixed
to frame B). This function returns only one bias spatial
acceleration, which contains both frame B’s bias angular
acceleration and point Bp’s bias translational acceleration.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>See bias_acceleration_functions “Bias acceleration functions” for
theory and details.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcBiasTerm">
<span class="sig-name descname"><span class="pre">CalcBiasTerm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.systems.framework.Context_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcBiasTerm" title="Link to this definition"></a></dt>
<dd><p>Computes the bias term <code class="docutils literal notranslate"><span class="pre">C(q,</span> <span class="pre">v)</span> <span class="pre">v</span></code> containing Coriolis, centripetal,
and gyroscopic effects in the multibody equations of motion:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">M</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="w"> </span><span class="n">v</span><span class="err">̇</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">C</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tau_app</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="err">∑</span><span class="w"> </span><span class="p">(</span><span class="n">Jv_V_WBᵀ</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="w"> </span><span class="err">⋅</span><span class="w"> </span><span class="n">Fapp_Bo_W</span><span class="p">)</span>
</pre></div>
</div>
</details><p>where <code class="docutils literal notranslate"><span class="pre">M(q)</span></code> is the multibody model’s mass matrix (including rigid
body mass properties and reflected_inertia “reflected inertias”) and
<code class="docutils literal notranslate"><span class="pre">tau_app</span></code> is a vector of applied generalized forces. The last term
is a summation over all bodies of the dot-product of <code class="docutils literal notranslate"><span class="pre">Fapp_Bo_W</span></code>
(applied spatial force on body B at Bo) with <code class="docutils literal notranslate"><span class="pre">Jv_V_WB(q)</span></code> (B’s
spatial Jacobian in world W with respect to generalized velocities v).
Note: B’s spatial velocity in W can be written <code class="docutils literal notranslate"><span class="pre">V_WB</span> <span class="pre">=</span> <span class="pre">Jv_V_WB</span> <span class="pre">*</span> <span class="pre">v</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>Contains the state of the multibody system, including the
generalized positions q and the generalized velocities v.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">Cv</span></code>:</dt><dd><p>On output, <code class="docutils literal notranslate"><span class="pre">Cv</span></code> will contain the product <code class="docutils literal notranslate"><span class="pre">C(q,</span> <span class="pre">v)v</span></code>. It must
be a valid (non-null) pointer to a column vector in <code class="docutils literal notranslate"><span class="pre">ℛⁿ</span></code> with n
the number of generalized velocities (num_velocities()) of the
model. This method aborts if Cv is nullptr or if it does not have
the proper size.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcBiasTranslationalAcceleration">
<span class="sig-name descname"><span class="pre">CalcBiasTranslationalAcceleration</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.systems.framework.Context_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_respect_to</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JacobianWrtVariable" title="pydrake.multibody.tree.JacobianWrtVariable"><span class="pre">pydrake.multibody.tree.JacobianWrtVariable</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.Frame_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_BoBi_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.f_contiguous</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.Frame_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_E</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.Frame_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcBiasTranslationalAcceleration" title="Link to this definition"></a></dt>
<dd><p>For each point Bi affixed/welded to a frame B, calculates a𝑠Bias_ABi,
Bi’s translational acceleration bias in frame A with respect to
“speeds” 𝑠, expressed in frame E, where speeds 𝑠 is either q̇ or v.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>Contains the state of the multibody system.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">with_respect_to</span></code>:</dt><dd><p>Enum equal to JacobianWrtVariable::kQDot or
JacobianWrtVariable::kV, indicating whether the translational
acceleration bias is with respect to 𝑠 = q̇ or 𝑠 = v. Currently,
an exception is thrown if with_respect_to is
JacobianWrtVariable::kQDot.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_B</span></code>:</dt><dd><p>The frame on which points Bi are affixed/welded.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BoBi_B</span></code>:</dt><dd><p>A position vector or list of p position vectors from Bo (frame_B’s
origin) to points Bi (regarded as affixed to B), where each
position vector is expressed in frame_B. Each column in the <code class="docutils literal notranslate"><span class="pre">3</span> <span class="pre">x</span>
<span class="pre">p</span></code> matrix p_BoBi_B corresponds to a position vector.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_A</span></code>:</dt><dd><p>The frame in which a𝑠Bias_ABi is measured.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_E</span></code>:</dt><dd><p>The frame in which a𝑠Bias_ABi is expressed on output.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a𝑠Bias_ABi_E Point Bi’s translational acceleration bias in frame A
with respect to speeds 𝑠 (𝑠 = q̇ or 𝑠 = v), expressed in frame E.
a𝑠Bias_ABi_E is a <code class="docutils literal notranslate"><span class="pre">3</span> <span class="pre">x</span> <span class="pre">p</span></code> matrix, where p is the number of
points Bi.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcJacobianTranslationalVelocity() to compute J𝑠_v_ABi, point
Bi’s translational velocity Jacobian in frame A with respect to 𝑠.</p>
</div>
<dl class="simple">
<dt>Precondition:</dt><dd><p>p_BoBi_B must have 3 rows.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if with_respect_to is JacobianWrtVariable::kQDot.</strong> – </p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>See bias_acceleration_functions “Bias acceleration functions” for
theory and details.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcCenterOfMassPositionInWorld">
<span class="sig-name descname"><span class="pre">CalcCenterOfMassPositionInWorld</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcCenterOfMassPositionInWorld" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>CalcCenterOfMassPositionInWorld(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd]) -&gt; numpy.ndarray[object[3, 1]]</p></li>
</ol>
<p>Calculates the position vector from the world origin Wo to the center
of mass of all bodies in this MultibodyPlant, expressed in the world
frame W.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>Contains the state of the model.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">p_WoScm_W</span></code>:</dt><dd><p>position vector from Wo to Scm expressed in world frame W, where
Scm is the center of mass of the system S stored by <code class="docutils literal notranslate"><span class="pre">this</span></code>
plant.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if this has no body except world_body</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p></li>
<li><p><strong>RuntimeError if mₛ ≤ 0</strong><strong> (</strong><strong>where mₛ is the mass</strong><strong> of </strong><strong>system S</strong><strong>)</strong><strong>.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The world_body() is ignored. p_WoScm_W = ∑ (mᵢ pᵢ) / mₛ, where mₛ
= ∑ mᵢ, mᵢ is the mass of the iᵗʰ body, and pᵢ is Bᵢcm’s position
from Wo expressed in frame W (Bᵢcm is the center of mass of the
iᵗʰ body).</p>
</div>
<ol class="arabic simple" start="2">
<li><p>CalcCenterOfMassPositionInWorld(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], model_instances: list[pydrake.multibody.tree.ModelInstanceIndex]) -&gt; numpy.ndarray[object[3, 1]]</p></li>
</ol>
<p>Calculates the position vector from the world origin Wo to the center
of mass of all non-world bodies contained in model_instances,
expressed in the world frame W.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>Contains the state of the model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">model_instances</span></code>:</dt><dd><p>Vector of selected model instances. If a model instance is
repeated in the vector (unusual), it is only counted once.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">p_WoScm_W</span></code>:</dt><dd><p>position vector from world origin Wo to Scm expressed in the world
frame W, where Scm is the center of mass of the system S of
non-world bodies contained in model_instances.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if model_instances is empty</strong><strong> or </strong><strong>only has world body.</strong> – </p></li>
<li><p><strong>RuntimeError if mₛ ≤ 0</strong><strong> (</strong><strong>where mₛ is the mass</strong><strong> of </strong><strong>system S</strong><strong>)</strong><strong>.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The world_body() is ignored. p_WoScm_W = ∑ (mᵢ pᵢ) / mₛ, where mₛ
= ∑ mᵢ, mᵢ is the mass of the iᵗʰ body contained in
model_instances, and pᵢ is Bᵢcm’s position vector from Wo
expressed in frame W (Bᵢcm is the center of mass of the iᵗʰ body).</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcCenterOfMassTranslationalAccelerationInWorld">
<span class="sig-name descname"><span class="pre">CalcCenterOfMassTranslationalAccelerationInWorld</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcCenterOfMassTranslationalAccelerationInWorld" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>CalcCenterOfMassTranslationalAccelerationInWorld(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd]) -&gt; numpy.ndarray[object[3, 1]]</p></li>
</ol>
<p>For the system S contained in this MultibodyPlant, calculates Scm’s
translational acceleration in the world frame W expressed in W, where
Scm is the center of mass of S.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context contains the state of the model.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">a_WScm_W</span></code>:</dt><dd><p>Scm’s translational acceleration in the world frame W expressed in
the world frame W.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if this has no body except world_body</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p></li>
<li><p><strong>RuntimeError if mₛ ≤ 0</strong><strong>, </strong><strong>where mₛ is the mass</strong><strong> of </strong><strong>system S.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The world_body() is ignored. a_WScm_W = ∑ (mᵢ aᵢ) / mₛ, where mₛ =
∑ mᵢ is the mass of system S, mᵢ is the mass of the iᵗʰ body, and
aᵢ is the translational acceleration of Bᵢcm in world W expressed
in W (Bᵢcm is the center of mass of the iᵗʰ body).</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When cached values are out of sync with the state stored in
context, this method performs an expensive forward dynamics
computation, whereas once evaluated, successive calls to this
method are inexpensive.</p>
</div>
<ol class="arabic simple" start="2">
<li><p>CalcCenterOfMassTranslationalAccelerationInWorld(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], model_instances: list[pydrake.multibody.tree.ModelInstanceIndex]) -&gt; numpy.ndarray[object[3, 1]]</p></li>
</ol>
<p>For the system S containing the selected model instances, calculates
Scm’s translational acceleration in the world frame W expressed in W,
where Scm is the center of mass of S.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context contains the state of the model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">model_instances</span></code>:</dt><dd><p>Vector of selected model instances. If a model instance is
repeated in the vector (unusual), it is only counted once.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">a_WScm_W</span></code>:</dt><dd><p>Scm’s translational acceleration in the world frame W expressed in
the world frame W.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if model_instances is empty</strong><strong> or </strong><strong>only has world body.</strong> – </p></li>
<li><p><strong>RuntimeError if mₛ ≤ 0</strong><strong>, </strong><strong>where mₛ is the mass</strong><strong> of </strong><strong>system S.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The world_body() is ignored. a_WScm_W = ∑ (mᵢ aᵢ) / mₛ, where mₛ =
∑ mᵢ is the mass of system S, mᵢ is the mass of the iᵗʰ body in
model_instances, and aᵢ is the translational acceleration of Bᵢcm
in world W expressed in W (Bᵢcm is the center of mass of the iᵗʰ
body).</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When cached values are out of sync with the state stored in
context, this method performs an expensive forward dynamics
computation, whereas once evaluated, successive calls to this
method are inexpensive.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcCenterOfMassTranslationalVelocityInWorld">
<span class="sig-name descname"><span class="pre">CalcCenterOfMassTranslationalVelocityInWorld</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcCenterOfMassTranslationalVelocityInWorld" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>CalcCenterOfMassTranslationalVelocityInWorld(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd]) -&gt; numpy.ndarray[object[3, 1]]</p></li>
</ol>
<p>Calculates system center of mass translational velocity in world frame
W.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context contains the state of the model.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">v_WScm_W</span></code>:</dt><dd><p>Scm’s translational velocity in frame W, expressed in W, where Scm
is the center of mass of the system S stored by <code class="docutils literal notranslate"><span class="pre">this</span></code> plant.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if this has no body except world_body</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p></li>
<li><p><strong>RuntimeError if mₛ ≤ 0</strong><strong> (</strong><strong>where mₛ is the mass</strong><strong> of </strong><strong>system S</strong><strong>)</strong><strong>.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The world_body() is ignored. v_WScm_W = ∑ (mᵢ vᵢ) / mₛ, where mₛ =
∑ mᵢ, mᵢ is the mass of the iᵗʰ body, and vᵢ is Bᵢcm’s velocity in
world W (Bᵢcm is the center of mass of the iᵗʰ body).</p>
</div>
<ol class="arabic simple" start="2">
<li><p>CalcCenterOfMassTranslationalVelocityInWorld(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], model_instances: list[pydrake.multibody.tree.ModelInstanceIndex]) -&gt; numpy.ndarray[object[3, 1]]</p></li>
</ol>
<p>Calculates system center of mass translational velocity in world frame
W.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context contains the state of the model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">model_instances</span></code>:</dt><dd><p>Vector of selected model instances. If a model instance is
repeated in the vector (unusual), it is only counted once.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">v_WScm_W</span></code>:</dt><dd><p>Scm’s translational velocity in frame W, expressed in W, where Scm
is the center of mass of the system S of non-world bodies
contained in model_instances.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if model_instances is empty</strong><strong> or </strong><strong>only has world body.</strong> – </p></li>
<li><p><strong>RuntimeError if mₛ ≤ 0</strong><strong> (</strong><strong>where mₛ is the mass</strong><strong> of </strong><strong>system S</strong><strong>)</strong><strong>.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The world_body() is ignored. v_WScm_W = ∑ (mᵢ vᵢ) / mₛ, where mₛ =
∑ mᵢ, mᵢ is the mass of the iᵗʰ body contained in model_instances,
and vᵢ is Bᵢcm’s velocity in world W expressed in frame W (Bᵢcm is
the center of mass of the iᵗʰ body).</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcForceElementsContribution">
<span class="sig-name descname"><span class="pre">CalcForceElementsContribution</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.systems.framework.Context_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">forces</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.MultibodyForces_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcForceElementsContribution" title="Link to this definition"></a></dt>
<dd><p>Computes the combined force contribution of ForceElement objects in
the model. A ForceElement can apply forces as a spatial force per body
or as generalized forces, depending on the ForceElement model.
ForceElement contributions are a function of the state and time only.
The output from this method can immediately be used as input to
CalcInverseDynamics() to include the effect of applied forces by force
elements.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context containing the state of this model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">forces</span></code>:</dt><dd><p>A pointer to a valid, non nullptr, multibody forces object. On
output <code class="docutils literal notranslate"><span class="pre">forces</span></code> will store the forces exerted by all the
ForceElement objects in the model.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if forces is null</strong><strong> or </strong><strong>not compatible with this</strong> – </p></li>
<li><p><strong>model</strong><strong>, </strong><strong>per MultibodyForces::CheckInvariants</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcGeneralizedForces">
<span class="sig-name descname"><span class="pre">CalcGeneralizedForces</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.systems.framework.Context_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">forces</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.MultibodyForces_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcGeneralizedForces" title="Link to this definition"></a></dt>
<dd><p>Computes the generalized forces result of a set of MultibodyForces
applied to this model.</p>
<p>MultibodyForces stores applied forces as both generalized forces τ and
spatial forces F on each body, refer to documentation in
MultibodyForces for details. Users of MultibodyForces will use
MultibodyForces::mutable_generalized_forces() to mutate the stored
generalized forces directly and will use
RigidBody::AddInForceInWorld() to append spatial forces.</p>
<p>For a given set of forces stored as MultibodyForces, this method will
compute the total generalized forces on this model. More precisely, if
J_WBo is the Jacobian (with respect to velocities) for this model,
including all bodies, then this method computes:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">τᵣₑₛᵤₗₜ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">τ</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">J_WBo</span><span class="err">⋅</span><span class="n">F</span>
</pre></div>
</div>
</details><dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>Context that stores the state of the model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">forces</span></code>:</dt><dd><p>Set of multibody forces, including both generalized forces and
per-body spatial forces.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">generalized_forces</span></code>:</dt><dd><p>The total generalized forces on the model that would result from
applying <code class="docutils literal notranslate"><span class="pre">forces</span></code>. In other words, <code class="docutils literal notranslate"><span class="pre">forces</span></code> can be replaced by
the equivalent <code class="docutils literal notranslate"><span class="pre">generalized_forces</span></code>. On output,
<code class="docutils literal notranslate"><span class="pre">generalized_forces</span></code> is resized to num_velocities().</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if forces is null</strong><strong> or </strong><strong>not compatible with this</strong> – </p></li>
<li><p><strong>model.</strong> – </p></li>
<li><p><strong>RuntimeError if generalized_forces is not a valid non-null</strong> – </p></li>
<li><p><strong>pointer.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcGravityGeneralizedForces">
<span class="sig-name descname"><span class="pre">CalcGravityGeneralizedForces</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.systems.framework.Context_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcGravityGeneralizedForces" title="Link to this definition"></a></dt>
<dd><p>Computes the generalized forces <code class="docutils literal notranslate"><span class="pre">tau_g(q)</span></code> due to gravity as a
function of the generalized positions <code class="docutils literal notranslate"><span class="pre">q</span></code> stored in the input
<code class="docutils literal notranslate"><span class="pre">context</span></code>. The vector of generalized forces due to gravity
<code class="docutils literal notranslate"><span class="pre">tau_g(q)</span></code> is defined such that it appears on the right hand side of
the equations of motion together with any other generalized forces,
like so:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Mv</span><span class="err">̇</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">C</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tau_g</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">tau_app</span>
</pre></div>
</div>
</details><p>where <code class="docutils literal notranslate"><span class="pre">tau_app</span></code> includes any other generalized forces applied on the
system.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context storing the state of the model.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>tau_g A vector containing the generalized forces due to gravity.
The generalized forces are consistent with the vector of
generalized velocities <code class="docutils literal notranslate"><span class="pre">v</span></code> for <code class="docutils literal notranslate"><span class="pre">this</span></code> so that the inner
product <code class="docutils literal notranslate"><span class="pre">v⋅tau_g</span></code> corresponds to the power applied by the
gravity forces on the mechanical system. That is, <code class="docutils literal notranslate"><span class="pre">v⋅tau_g</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>
corresponds to potential energy going into the system, as either
mechanical kinetic energy, some other potential energy, or heat,
and therefore to a decrease of the gravitational potential energy.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcInverseDynamics">
<span class="sig-name descname"><span class="pre">CalcInverseDynamics</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.systems.framework.Context_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">known_vdot</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">external_forces</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.MultibodyForces_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcInverseDynamics" title="Link to this definition"></a></dt>
<dd><p>Given the state of this model in <code class="docutils literal notranslate"><span class="pre">context</span></code> and a known vector of
generalized accelerations <code class="docutils literal notranslate"><span class="pre">vdot</span></code>, this method computes the set of
generalized forces <code class="docutils literal notranslate"><span class="pre">tau</span></code> that would need to be applied in order to
attain the specified generalized accelerations. Mathematically, this
method computes:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">tau</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">M</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="n">v</span><span class="err">̇</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">C</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="n">v</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">tau_app</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="err">∑</span><span class="w"> </span><span class="n">J_WBᵀ</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="w"> </span><span class="n">Fapp_Bo_W</span>
</pre></div>
</div>
</details><p>where <code class="docutils literal notranslate"><span class="pre">M(q)</span></code> is the model’s mass matrix (including rigid body mass
properties and reflected_inertia “reflected inertias”), <code class="docutils literal notranslate"><span class="pre">C(q,</span> <span class="pre">v)v</span></code>
is the bias term for Coriolis and gyroscopic effects and <code class="docutils literal notranslate"><span class="pre">tau_app</span></code>
consists of a vector applied generalized forces. The last term is a
summation over all bodies in the model where <code class="docutils literal notranslate"><span class="pre">Fapp_Bo_W</span></code> is an
applied spatial force on body B at <code class="docutils literal notranslate"><span class="pre">Bo</span></code> which gets projected into
the space of generalized forces with the transpose of <code class="docutils literal notranslate"><span class="pre">Jv_V_WB(q)</span></code>
(where <code class="docutils literal notranslate"><span class="pre">Jv_V_WB</span></code> is B’s spatial velocity Jacobian in W with respect
to generalized velocities v). Note: B’s spatial velocity in W can be
written as <code class="docutils literal notranslate"><span class="pre">V_WB</span> <span class="pre">=</span> <span class="pre">Jv_V_WB</span> <span class="pre">*</span> <span class="pre">v</span></code>.</p>
<p>This method does not compute explicit expressions for the mass matrix
nor for the bias term, which would be of at least <code class="docutils literal notranslate"><span class="pre">O(n²)</span></code>
complexity, but it implements an <code class="docutils literal notranslate"><span class="pre">O(n)</span></code> Newton-Euler recursive
algorithm, where n is the number of bodies in the model. The explicit
formation of the mass matrix <code class="docutils literal notranslate"><span class="pre">M(q)</span></code> would require the calculation of
<code class="docutils literal notranslate"><span class="pre">O(n²)</span></code> entries while explicitly forming the product <code class="docutils literal notranslate"><span class="pre">C(q,</span> <span class="pre">v)</span> <span class="pre">*</span> <span class="pre">v</span></code>
could require up to <code class="docutils literal notranslate"><span class="pre">O(n³)</span></code> operations (see [Featherstone 1987,
§4]), depending on the implementation. The recursive Newton-Euler
algorithm is the most efficient currently known general method for
solving inverse dynamics [Featherstone 2008].</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context containing the state of the model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">known_vdot</span></code>:</dt><dd><p>A vector with the known generalized accelerations <code class="docutils literal notranslate"><span class="pre">vdot</span></code> for the
full model. Use the provided Joint APIs in order to access entries
into this array.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">external_forces</span></code>:</dt><dd><p>A set of forces to be applied to the system either as body spatial
forces <code class="docutils literal notranslate"><span class="pre">Fapp_Bo_W</span></code> or generalized forces <code class="docutils literal notranslate"><span class="pre">tau_app</span></code>, see
MultibodyForces for details.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>the vector of generalized forces that would need to be applied to
the mechanical system in order to achieve the desired acceleration
given by <code class="docutils literal notranslate"><span class="pre">known_vdot</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcJacobianAngularVelocity">
<span class="sig-name descname"><span class="pre">CalcJacobianAngularVelocity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.systems.framework.Context_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_respect_to</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JacobianWrtVariable" title="pydrake.multibody.tree.JacobianWrtVariable"><span class="pre">pydrake.multibody.tree.JacobianWrtVariable</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.Frame_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.Frame_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_E</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.Frame_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcJacobianAngularVelocity" title="Link to this definition"></a></dt>
<dd><p>Calculates J𝑠_w_AB, a frame B’s angular velocity Jacobian in a frame A
with respect to “speeds” 𝑠.</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">J𝑠_w_AB</span><span class="w"> </span><span class="err">≜</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="err">∂</span><span class="p">(</span><span class="n">w_AB</span><span class="p">)</span><span class="o">/</span><span class="err">∂</span><span class="n">𝑠₁</span><span class="p">,</span><span class="w">  </span><span class="p">...</span><span class="w">  </span><span class="err">∂</span><span class="p">(</span><span class="n">w_AB</span><span class="p">)</span><span class="o">/</span><span class="err">∂</span><span class="n">𝑠ₙ</span><span class="w"> </span><span class="p">]</span><span class="w">    </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="k">or</span><span class="w"> </span><span class="n">k</span><span class="p">)</span>
<span class="w">     </span><span class="n">w_AB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">J𝑠_w_AB</span><span class="w"> </span><span class="err">⋅</span><span class="w"> </span><span class="n">𝑠</span><span class="w">          </span><span class="n">w_AB</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">linear</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">𝑠</span><span class="w"> </span><span class="err">≜</span><span class="w"> </span><span class="p">[</span><span class="n">𝑠₁</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="n">𝑠ₙ</span><span class="p">]</span><span class="n">ᵀ</span>
</pre></div>
</div>
</details><p><code class="docutils literal notranslate"><span class="pre">w_AB</span></code> is B’s angular velocity in frame A and “speeds” 𝑠 is either
q̇ ≜ [q̇₁ … q̇ⱼ]ᵀ (time-derivatives of j generalized positions) or v
≜ [v₁ … vₖ]ᵀ (k generalized velocities).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The state of the multibody system.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">with_respect_to</span></code>:</dt><dd><p>Enum equal to JacobianWrtVariable::kQDot or
JacobianWrtVariable::kV, indicating whether the Jacobian
<code class="docutils literal notranslate"><span class="pre">J𝑠_w_AB</span></code> is partial derivatives with respect to 𝑠 = q̇
(time-derivatives of generalized positions) or with respect to 𝑠 =
v (generalized velocities).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_B</span></code>:</dt><dd><p>The frame B in <code class="docutils literal notranslate"><span class="pre">w_AB</span></code> (B’s angular velocity in A).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_A</span></code>:</dt><dd><p>The frame A in <code class="docutils literal notranslate"><span class="pre">w_AB</span></code> (B’s angular velocity in A).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_E</span></code>:</dt><dd><p>The frame in which <code class="docutils literal notranslate"><span class="pre">w_AB</span></code> is expressed on input and the frame in
which the Jacobian <code class="docutils literal notranslate"><span class="pre">J𝑠_w_AB</span></code> is expressed on output.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">Js_w_AB_E</span></code>:</dt><dd><p>Frame B’s angular velocity Jacobian in frame A with respect to
speeds 𝑠 (which is either q̇ or v), expressed in frame E. The
Jacobian is a function of only generalized positions q (which are
pulled from the context). The previous definition shows
<code class="docutils literal notranslate"><span class="pre">J𝑠_w_AB_E</span></code> is a matrix of size <code class="docutils literal notranslate"><span class="pre">3</span> <span class="pre">x</span> <span class="pre">n</span></code>, where n is the number
of elements in 𝑠.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>See Jacobian_functions “Jacobian functions” for related functions.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if J𝑠_w_AB_E is nullptr</strong><strong> or </strong><strong>not</strong><strong> of </strong><strong>size 3 x n.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcJacobianCenterOfMassTranslationalVelocity">
<span class="sig-name descname"><span class="pre">CalcJacobianCenterOfMassTranslationalVelocity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcJacobianCenterOfMassTranslationalVelocity" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>CalcJacobianCenterOfMassTranslationalVelocity(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_A: pydrake.multibody.tree.Frame_[AutoDiffXd], frame_E: pydrake.multibody.tree.Frame_[AutoDiffXd]) -&gt; numpy.ndarray[object[3, n]]</p></li>
</ol>
<p>Calculates J𝑠_v_AScm_E, point Scm’s translational velocity Jacobian in
frame A with respect to “speeds” 𝑠, expressed in frame E, where point
Scm is the center of mass of the system S of all non-world bodies
contained in <code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>contains the state of the model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">with_respect_to</span></code>:</dt><dd><p>Enum equal to JacobianWrtVariable::kQDot or
JacobianWrtVariable::kV, indicating whether the Jacobian
<code class="docutils literal notranslate"><span class="pre">J𝑠_v_AScm_E</span></code> is partial derivatives with respect to 𝑠 = q̇
(time-derivatives of generalized positions) or with respect to 𝑠 =
v (generalized velocities).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_A</span></code>:</dt><dd><p>The frame in which the translational velocity v_AScm and its
Jacobian J𝑠_v_AScm are measured.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_E</span></code>:</dt><dd><p>The frame in which the Jacobian J𝑠_v_AScm is expressed on output.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">Js_v_AScm_E</span></code>:</dt><dd><p>Point Scm’s translational velocity Jacobian in frame A with
respect to speeds 𝑠 (𝑠 = q̇ or 𝑠 = v), expressed in frame E.
J𝑠_v_AScm_E is a 3 x n matrix, where n is the number of elements
in 𝑠. The Jacobian is a function of only generalized positions q
(which are pulled from the context).</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if Scm does not exist</strong><strong>, </strong><strong>which occurs if there are no</strong> – </p></li>
<li><p><strong>massive bodies in MultibodyPlant</strong><strong> (</strong><strong>except world_body</strong><strong>(</strong><strong>)</strong><strong>)</strong><strong>.</strong> – </p></li>
<li><p><strong>RuntimeError if mₛ ≤ 0</strong><strong> (</strong><strong>where mₛ is the mass</strong><strong> of </strong><strong>all non-world</strong> – </p></li>
<li><p><strong>bodies contained in this MultibodyPlant</strong><strong>)</strong><strong>.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>See Jacobian_functions “Jacobian functions” for related functions.</p>
</div>
<ol class="arabic simple" start="2">
<li><p>CalcJacobianCenterOfMassTranslationalVelocity(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], model_instances: list[pydrake.multibody.tree.ModelInstanceIndex], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_A: pydrake.multibody.tree.Frame_[AutoDiffXd], frame_E: pydrake.multibody.tree.Frame_[AutoDiffXd]) -&gt; numpy.ndarray[object[3, n]]</p></li>
</ol>
<p>Calculates J𝑠_v_AScm_E, point Scm’s translational velocity Jacobian in
frame A with respect to “speeds” 𝑠, expressed in frame E, where point
Scm is the center of mass of the system S of all non-world bodies
contained in model_instances.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>contains the state of the model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">model_instances</span></code>:</dt><dd><p>Vector of selected model instances. If a model instance is
repeated in the vector (unusual), it is only counted once.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">with_respect_to</span></code>:</dt><dd><p>Enum equal to JacobianWrtVariable::kQDot or
JacobianWrtVariable::kV, indicating whether the Jacobian
<code class="docutils literal notranslate"><span class="pre">J𝑠_v_AScm_E</span></code> is partial derivatives with respect to 𝑠 = q̇
(time-derivatives of generalized positions) or with respect to 𝑠 =
v (generalized velocities).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_A</span></code>:</dt><dd><p>The frame in which the translational velocity v_AScm and its
Jacobian J𝑠_v_AScm are measured.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_E</span></code>:</dt><dd><p>The frame in which the Jacobian J𝑠_v_AScm is expressed on output.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">Js_v_AScm_E</span></code>:</dt><dd><p>Point Scm’s translational velocity Jacobian in frame A with
respect to speeds 𝑠 (𝑠 = q̇ or 𝑠 = v), expressed in frame E.
J𝑠_v_AScm_E is a 3 x n matrix, where n is the number of elements
in 𝑠. The Jacobian is a function of only generalized positions q
(which are pulled from the context).</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if mₛ ≤ 0</strong><strong> (</strong><strong>where mₛ is the mass</strong><strong> of </strong><strong>all non-world</strong> – </p></li>
<li><p><strong>bodies contained in model_instances</strong><strong>)</strong><strong>.</strong> – </p></li>
<li><p><strong>RuntimeError if model_instances is empty</strong><strong> or </strong><strong>only has world body.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The world_body() is ignored. <a href="#id157"><span class="problematic" id="id158">J𝑠_v_AScm_</span></a> = ∑ (mᵢ Jᵢ) / mₛ, where mₛ
= ∑ mᵢ, mᵢ is the mass of the iᵗʰ body contained in
model_instances, and Jᵢ is Bᵢcm’s translational velocity Jacobian
in frame A, expressed in frame E (Bᵢcm is the center of mass of
the iᵗʰ body).</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>See Jacobian_functions “Jacobian functions” for related functions.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcJacobianPositionVector">
<span class="sig-name descname"><span class="pre">CalcJacobianPositionVector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.systems.framework.Context_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.Frame_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_BoBi_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.f_contiguous</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.Frame_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_E</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.Frame_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcJacobianPositionVector" title="Link to this definition"></a></dt>
<dd><p>For each point Bi affixed/welded to a frame B, calculates Jq_p_AoBi,
Bi’s position vector Jacobian in frame A with respect to the
generalized positions q ≜ [q₁ … qₙ]ᵀ as</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Jq_p_AoBi</span><span class="w"> </span><span class="err">≜</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="n">ᴬ</span><span class="err">∂</span><span class="p">(</span><span class="n">p_AoBi</span><span class="p">)</span><span class="o">/</span><span class="err">∂</span><span class="n">q₁</span><span class="p">,</span><span class="w">  </span><span class="p">...</span><span class="w">  </span><span class="n">ᴬ</span><span class="err">∂</span><span class="p">(</span><span class="n">p_AoBi</span><span class="p">)</span><span class="o">/</span><span class="err">∂</span><span class="n">qₙ</span><span class="w"> </span><span class="p">]</span>
</pre></div>
</div>
</details><p>where p_AoBi is Bi’s position vector from point Ao (frame A’s origin)
and ᴬ∂(p_AoBi)/∂qᵣ denotes the partial derivative in frame A of p_AoBi
with respect to the generalized position qᵣ, where qᵣ is one of q₁ …
qₙ.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The state of the multibody system.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_B</span></code>:</dt><dd><p>The frame on which point Bi is affixed/welded.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BoBi_B</span></code>:</dt><dd><p>A position vector or list of k position vectors from Bo (frame_B’s
origin) to points Bi (Bi is regarded as affixed to B), where each
position vector is expressed in frame_B.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_A</span></code>:</dt><dd><p>The frame in which partial derivatives are calculated and the
frame in which point Ao is affixed.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_E</span></code>:</dt><dd><p>The frame in which the Jacobian Jq_p_AoBi is expressed on output.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">Jq_p_AoBi_E</span></code>:</dt><dd><p>Point Bi’s position vector Jacobian in frame A with generalized
positions q, expressed in frame E. Jq_p_AoBi_E is a <code class="docutils literal notranslate"><span class="pre">3*k</span> <span class="pre">x</span> <span class="pre">n</span></code>
matrix, where k is the number of points Bi and n is the number of
elements in q. The Jacobian is a function of only generalized
positions q (which are pulled from the context).</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if Jq_p_AoBi_E is nullptr</strong><strong> or </strong><strong>not sized 3*k x n.</strong> – </p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Jq̇_v_ABi = Jq_p_AoBi. In other words, point Bi’s velocity
Jacobian in frame A with respect to q̇ is equal to point Bi’s
position vector Jacobian in frame A with respect to q.</p>
</div>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="err">∂</span><span class="p">(</span><span class="n">v_ABi</span><span class="p">)</span><span class="o">/</span><span class="err">∂</span><span class="n">q</span><span class="err">̇</span><span class="n">₁</span><span class="p">,</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="err">∂</span><span class="p">(</span><span class="n">v_ABi</span><span class="p">)</span><span class="o">/</span><span class="err">∂</span><span class="n">q</span><span class="err">̇</span><span class="n">ₙ</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">ᴬ</span><span class="err">∂</span><span class="p">(</span><span class="n">p_AoBi</span><span class="p">)</span><span class="o">/</span><span class="err">∂</span><span class="n">q₁</span><span class="p">,</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="n">ᴬ</span><span class="err">∂</span><span class="p">(</span><span class="n">p_AoBi</span><span class="p">)</span><span class="o">/</span><span class="err">∂</span><span class="n">qₙ</span><span class="p">]</span>
</pre></div>
</div>
</details><div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcJacobianTranslationalVelocity() for details on Jq̇_v_ABi.
Note: Jq_p_AaBi = Jq_p_AoBi, where point Aa is <em>any</em> point
fixed/welded to frame A, i.e., this calculation’s result is the
same if point Ao is replaced with any point fixed on frame A.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>See Jacobian_functions “Jacobian functions” for related functions.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcJacobianSpatialVelocity">
<span class="sig-name descname"><span class="pre">CalcJacobianSpatialVelocity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.systems.framework.Context_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_respect_to</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JacobianWrtVariable" title="pydrake.multibody.tree.JacobianWrtVariable"><span class="pre">pydrake.multibody.tree.JacobianWrtVariable</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.Frame_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_BoBp_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.Frame_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_E</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.Frame_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcJacobianSpatialVelocity" title="Link to this definition"></a></dt>
<dd><p>For one point Bp fixed/welded to a frame B, calculates J𝑠_V_ABp, Bp’s
spatial velocity Jacobian in frame A with respect to “speeds” 𝑠.</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">J𝑠_V_ABp</span><span class="w"> </span><span class="err">≜</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="err">∂</span><span class="p">(</span><span class="n">V_ABp</span><span class="p">)</span><span class="o">/</span><span class="err">∂</span><span class="n">𝑠₁</span><span class="p">,</span><span class="w">  </span><span class="p">...</span><span class="w">  </span><span class="err">∂</span><span class="p">(</span><span class="n">V_ABp</span><span class="p">)</span><span class="o">/</span><span class="err">∂</span><span class="n">𝑠ₙ</span><span class="w"> </span><span class="p">]</span><span class="w">    </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="k">or</span><span class="w"> </span><span class="n">k</span><span class="p">)</span>
<span class="w">     </span><span class="n">V_ABp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">J𝑠_V_ABp</span><span class="w"> </span><span class="err">⋅</span><span class="w"> </span><span class="n">𝑠</span><span class="w">          </span><span class="n">V_ABp</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">linear</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">𝑠</span><span class="w"> </span><span class="err">≜</span><span class="w"> </span><span class="p">[</span><span class="n">𝑠₁</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="n">𝑠ₙ</span><span class="p">]</span><span class="n">ᵀ</span>
</pre></div>
</div>
</details><p><code class="docutils literal notranslate"><span class="pre">V_ABp</span></code> is Bp’s spatial velocity in frame A and “speeds” 𝑠 is either
q̇ ≜ [q̇₁ … q̇ⱼ]ᵀ (time-derivatives of j generalized positions) or v
≜ [v₁ … vₖ]ᵀ (k generalized velocities).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The state of the multibody system.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">with_respect_to</span></code>:</dt><dd><p>Enum equal to JacobianWrtVariable::kQDot or
JacobianWrtVariable::kV, indicating whether the Jacobian
<code class="docutils literal notranslate"><span class="pre">J𝑠_V_ABp</span></code> is partial derivatives with respect to 𝑠 = q̇
(time-derivatives of generalized positions) or with respect to 𝑠 =
v (generalized velocities).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_B</span></code>:</dt><dd><p>The frame on which point Bp is fixed/welded.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BoBp_B</span></code>:</dt><dd><p>A position vector from Bo (frame_B’s origin) to point Bp (regarded
as fixed/welded to B), expressed in frame_B.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_A</span></code>:</dt><dd><p>The frame that measures <code class="docutils literal notranslate"><span class="pre">v_ABp</span></code> (Bp’s velocity in A). Note: It
is natural to wonder why there is no parameter p_AoAp_A (similar
to the parameter p_BoBp_B for frame_B). There is no need for
p_AoAp_A because Bp’s velocity in A is defined as the derivative
in frame A of Bp’s position vector from <em>any</em> point fixed to A.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_E</span></code>:</dt><dd><p>The frame in which <code class="docutils literal notranslate"><span class="pre">v_ABp</span></code> is expressed on input and the frame
in which the Jacobian <code class="docutils literal notranslate"><span class="pre">J𝑠_V_ABp</span></code> is expressed on output.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">Js_V_ABp_E</span></code>:</dt><dd><p>Point Bp’s spatial velocity Jacobian in frame A with respect to
speeds 𝑠 (which is either q̇ or v), expressed in frame E.
<code class="docutils literal notranslate"><span class="pre">J𝑠_V_ABp_E</span></code> is a <code class="docutils literal notranslate"><span class="pre">6</span> <span class="pre">x</span> <span class="pre">n</span></code> matrix, where n is the number of
elements in 𝑠. The Jacobian is a function of only generalized
positions q (which are pulled from the context).</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The returned <code class="docutils literal notranslate"><span class="pre">6</span> <span class="pre">x</span> <span class="pre">n</span></code> matrix stores frame B’s angular velocity
Jacobian in A in rows 1-3 and stores point Bp’s translational
velocity Jacobian in A in rows 4-6, i.e.,</p>
</div>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">J𝑠_w_AB_E</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">J𝑠_V_ABp_E</span><span class="p">.</span><span class="n">topRows</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">();</span>
<span class="w">    </span><span class="n">J𝑠_v_ABp_E</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">J𝑠_V_ABp_E</span><span class="p">.</span><span class="n">bottomRows</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">();</span>
</pre></div>
</div>
</details><div class="admonition note">
<p class="admonition-title">Note</p>
<p>Consider CalcJacobianTranslationalVelocity() for multiple points
fixed to frame B and consider CalcJacobianAngularVelocity() to
calculate frame B’s angular velocity Jacobian.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>See Jacobian_functions “Jacobian functions” for related functions.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if J𝑠_V_ABp_E is nullptr</strong><strong> or </strong><strong>not sized 6 x n.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcJacobianTranslationalVelocity">
<span class="sig-name descname"><span class="pre">CalcJacobianTranslationalVelocity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.systems.framework.Context_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_respect_to</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JacobianWrtVariable" title="pydrake.multibody.tree.JacobianWrtVariable"><span class="pre">pydrake.multibody.tree.JacobianWrtVariable</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.Frame_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_BoBi_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.f_contiguous</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.Frame_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_E</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.Frame_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcJacobianTranslationalVelocity" title="Link to this definition"></a></dt>
<dd><p>For each point Bi affixed/welded to a frame B, calculates J𝑠_v_ABi,
Bi’s translational velocity Jacobian in frame A with respect to
“speeds” 𝑠.</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">J𝑠_v_ABi</span><span class="w"> </span><span class="err">≜</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="err">∂</span><span class="p">(</span><span class="n">v_ABi</span><span class="p">)</span><span class="o">/</span><span class="err">∂</span><span class="n">𝑠₁</span><span class="p">,</span><span class="w">  </span><span class="p">...</span><span class="w">  </span><span class="err">∂</span><span class="p">(</span><span class="n">v_ABi</span><span class="p">)</span><span class="o">/</span><span class="err">∂</span><span class="n">𝑠ₙ</span><span class="w"> </span><span class="p">]</span><span class="w">    </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="k">or</span><span class="w"> </span><span class="n">k</span><span class="p">)</span>
<span class="w">     </span><span class="n">v_ABi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">J𝑠_v_ABi</span><span class="w"> </span><span class="err">⋅</span><span class="w"> </span><span class="n">𝑠</span><span class="w">          </span><span class="n">v_ABi</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">linear</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">𝑠</span><span class="w"> </span><span class="err">≜</span><span class="w"> </span><span class="p">[</span><span class="n">𝑠₁</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="n">𝑠ₙ</span><span class="p">]</span><span class="n">ᵀ</span>
</pre></div>
</div>
</details><p><code class="docutils literal notranslate"><span class="pre">v_ABi</span></code> is Bi’s translational velocity in frame A and “speeds” 𝑠 is
either q̇ ≜ [q̇₁ … q̇ⱼ]ᵀ (time-derivatives of j generalized
positions) or v ≜ [v₁ … vₖ]ᵀ (k generalized velocities).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The state of the multibody system.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">with_respect_to</span></code>:</dt><dd><p>Enum equal to JacobianWrtVariable::kQDot or
JacobianWrtVariable::kV, indicating whether the Jacobian
<code class="docutils literal notranslate"><span class="pre">J𝑠_v_ABi</span></code> is partial derivatives with respect to 𝑠 = q̇
(time-derivatives of generalized positions) or with respect to 𝑠 =
v (generalized velocities).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_B</span></code>:</dt><dd><p>The frame on which point Bi is affixed/welded.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BoBi_B</span></code>:</dt><dd><p>A position vector or list of p position vectors from Bo (frame_B’s
origin) to points Bi (regarded as affixed to B), where each
position vector is expressed in frame_B.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_A</span></code>:</dt><dd><p>The frame that measures <code class="docutils literal notranslate"><span class="pre">v_ABi</span></code> (Bi’s velocity in A). Note: It
is natural to wonder why there is no parameter p_AoAi_A (similar
to the parameter p_BoBi_B for frame_B). There is no need for
p_AoAi_A because Bi’s velocity in A is defined as the derivative
in frame A of Bi’s position vector from <em>any</em> point affixed to A.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_E</span></code>:</dt><dd><p>The frame in which <code class="docutils literal notranslate"><span class="pre">v_ABi</span></code> is expressed on input and the frame
in which the Jacobian <code class="docutils literal notranslate"><span class="pre">J𝑠_v_ABi</span></code> is expressed on output.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">Js_v_ABi_E</span></code>:</dt><dd><p>Point Bi’s velocity Jacobian in frame A with respect to speeds 𝑠
(which is either q̇ or v), expressed in frame E. <code class="docutils literal notranslate"><span class="pre">J𝑠_v_ABi_E</span></code> is
a <code class="docutils literal notranslate"><span class="pre">3*p</span> <span class="pre">x</span> <span class="pre">n</span></code> matrix, where p is the number of points Bi and n is
the number of elements in 𝑠. The Jacobian is a function of only
generalized positions q (which are pulled from the context).</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if J𝑠_v_ABi_E is nullptr</strong><strong> or </strong><strong>not sized ``3*p x</strong> – </p></li>
<li><p><strong>n``.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When 𝑠 = q̇, <code class="docutils literal notranslate"><span class="pre">Jq̇_v_ABi</span> <span class="pre">=</span> <span class="pre">Jq_p_AoBi</span></code>. In other words, point Bi’s
velocity Jacobian in frame A with respect to q̇ is equal to point
Bi’s position Jacobian from Ao (A’s origin) in frame A with
respect to q.</p>
</div>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="err">∂</span><span class="p">(</span><span class="n">v_ABi</span><span class="p">)</span><span class="o">/</span><span class="err">∂</span><span class="n">q</span><span class="err">̇</span><span class="n">₁</span><span class="p">,</span><span class="w">  </span><span class="p">...</span><span class="w">  </span><span class="err">∂</span><span class="p">(</span><span class="n">v_ABi</span><span class="p">)</span><span class="o">/</span><span class="err">∂</span><span class="n">q</span><span class="err">̇</span><span class="n">ⱼ</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="err">∂</span><span class="p">(</span><span class="n">p_AoBi</span><span class="p">)</span><span class="o">/</span><span class="err">∂</span><span class="n">q₁</span><span class="p">,</span><span class="w">  </span><span class="p">...</span><span class="w">  </span><span class="err">∂</span><span class="p">(</span><span class="n">p_AoBi</span><span class="p">)</span><span class="o">/</span><span class="err">∂</span><span class="n">qⱼ</span><span class="p">]</span>
</pre></div>
</div>
</details><p>Note: Each partial derivative of p_AoBi is taken in frame A.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcJacobianPositionVector() for details on Jq_p_AoBi.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>See Jacobian_functions “Jacobian functions” for related functions.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcMassMatrix">
<span class="sig-name descname"><span class="pre">CalcMassMatrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.systems.framework.Context_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcMassMatrix" title="Link to this definition"></a></dt>
<dd><p>Efficiently computes the mass matrix <code class="docutils literal notranslate"><span class="pre">M(q)</span></code> of the model. The
generalized positions q are taken from the given <code class="docutils literal notranslate"><span class="pre">context</span></code>. M
includes the mass properties of rigid bodies and reflected_inertia
“reflected inertias” as provided with JointActuator specifications.</p>
<p>This method employs the Composite Body Algorithm, which we believe to
be the fastest O(n²) algorithm to compute the mass matrix of a
multibody system.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The Context containing the state of the model from which
generalized coordinates q are extracted.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">M</span></code>:</dt><dd><p>A pointer to a square matrix in <code class="docutils literal notranslate"><span class="pre">ℛⁿˣⁿ</span></code> with n the number of
generalized velocities (num_velocities()) of the model. Although
symmetric, the matrix is filled in completely on return.</p>
</dd>
<dt>Precondition:</dt><dd><p>M is non-null and has the right size.</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This is an O(n²) algorithm. Avoid the explicit computation of the
mass matrix whenever possible.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcMassMatrixViaInverseDynamics() (slower)</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcMassMatrixViaInverseDynamics">
<span class="sig-name descname"><span class="pre">CalcMassMatrixViaInverseDynamics</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.systems.framework.Context_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcMassMatrixViaInverseDynamics" title="Link to this definition"></a></dt>
<dd><p>Computes the mass matrix <code class="docutils literal notranslate"><span class="pre">M(q)</span></code> of the model using a slow method
(inverse dynamics). The generalized positions q are taken from the
given <code class="docutils literal notranslate"><span class="pre">context</span></code>. M includes the mass properties of rigid bodies and
reflected_inertia “reflected inertias” as provided with JointActuator
specifications.</p>
<p>Use CalcMassMatrix() for a faster implementation using the Composite
Body Algorithm.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The Context containing the state of the model from which
generalized coordinates q are extracted.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">M</span></code>:</dt><dd><p>A pointer to a square matrix in <code class="docutils literal notranslate"><span class="pre">ℛⁿˣⁿ</span></code> with n the number of
generalized velocities (num_velocities()) of the model. Although
symmetric, the matrix is filled in completely on return.</p>
</dd>
<dt>Precondition:</dt><dd><p>M is non-null and has the right size.</p>
</dd>
</dl>
<p>The algorithm used to build <code class="docutils literal notranslate"><span class="pre">M(q)</span></code> consists in computing one column
of <code class="docutils literal notranslate"><span class="pre">M(q)</span></code> at a time using inverse dynamics. The result from inverse
dynamics, with no applied forces, is the vector of generalized forces:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">tau</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">M</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="n">v</span><span class="err">̇</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">C</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="n">v</span>
</pre></div>
</div>
</details><p>where q and v are the generalized positions and velocities,
respectively. When <code class="docutils literal notranslate"><span class="pre">v</span> <span class="pre">=</span> <span class="pre">0</span></code> the Coriolis and gyroscopic forces term
<code class="docutils literal notranslate"><span class="pre">C(q,</span> <span class="pre">v)v</span></code> is zero. Therefore the <code class="docutils literal notranslate"><span class="pre">i-th</span></code> column of <code class="docutils literal notranslate"><span class="pre">M(q)</span></code> can be
obtained performing inverse dynamics with an acceleration vector <code class="docutils literal notranslate"><span class="pre">v̇</span>
<span class="pre">=</span> <span class="pre">eᵢ</span></code>, with <code class="docutils literal notranslate"><span class="pre">eᵢ</span></code> the standard (or natural) basis of <code class="docutils literal notranslate"><span class="pre">ℛⁿ</span></code> with n
the number of generalized velocities. We write this as:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">M</span><span class="p">.</span><span class="n">ᵢ</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">M</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">e_i</span>
</pre></div>
</div>
</details><p>where <code class="docutils literal notranslate"><span class="pre">M.ᵢ(q)</span></code> (notice the dot for the rows index) denotes the
<code class="docutils literal notranslate"><span class="pre">i-th</span></code> column in M(q).</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This is an O(n²) algorithm. Avoid the explicit computation of the
mass matrix whenever possible.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcMassMatrix(), CalcInverseDynamics()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcPointsPositions">
<span class="sig-name descname"><span class="pre">CalcPointsPositions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.systems.framework.Context_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.Frame_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_BQi</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.f_contiguous</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.Frame_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcPointsPositions" title="Link to this definition"></a></dt>
<dd><p>Given the positions <code class="docutils literal notranslate"><span class="pre">p_BQi</span></code> for a set of points <code class="docutils literal notranslate"><span class="pre">Qi</span></code> measured and
expressed in a frame B, this method computes the positions
<code class="docutils literal notranslate"><span class="pre">p_AQi(q)</span></code> of each point <code class="docutils literal notranslate"><span class="pre">Qi</span></code> in the set as measured and expressed
in another frame A, as a function of the generalized positions q of
the model.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context containing the state of the model. It stores the
generalized positions q of the model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_B</span></code>:</dt><dd><p>The frame B in which the positions <code class="docutils literal notranslate"><span class="pre">p_BQi</span></code> of a set of points
<code class="docutils literal notranslate"><span class="pre">Qi</span></code> are given.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BQi</span></code>:</dt><dd><p>The input positions of each point <code class="docutils literal notranslate"><span class="pre">Qi</span></code> in frame B. <code class="docutils literal notranslate"><span class="pre">p_BQi</span> <span class="pre">∈</span>
<span class="pre">ℝ³ˣⁿᵖ</span></code> with <code class="docutils literal notranslate"><span class="pre">np</span></code> the number of points in the set. Each column
of <code class="docutils literal notranslate"><span class="pre">p_BQi</span></code> corresponds to a vector in ℝ³ holding the position of
one of the points in the set as measured and expressed in frame B.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_A</span></code>:</dt><dd><p>The frame A in which it is desired to compute the positions
<code class="docutils literal notranslate"><span class="pre">p_AQi</span></code> of each point <code class="docutils literal notranslate"><span class="pre">Qi</span></code> in the set.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_AQi</span></code>:</dt><dd><p>The output positions of each point <code class="docutils literal notranslate"><span class="pre">Qi</span></code> now computed as measured
and expressed in frame A. The output <code class="docutils literal notranslate"><span class="pre">p_AQi</span></code> <strong>must</strong> have the
same size as the input <code class="docutils literal notranslate"><span class="pre">p_BQi</span></code> or otherwise this method aborts.
That is <code class="docutils literal notranslate"><span class="pre">p_AQi</span></code> <strong>must</strong> be in <code class="docutils literal notranslate"><span class="pre">ℝ³ˣⁿᵖ</span></code>.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Both <code class="docutils literal notranslate"><span class="pre">p_BQi</span></code> and <code class="docutils literal notranslate"><span class="pre">p_AQi</span></code> must have three rows. Otherwise this
method will throw a RuntimeError. This method also throws a
RuntimeError if <code class="docutils literal notranslate"><span class="pre">p_BQi</span></code> and <code class="docutils literal notranslate"><span class="pre">p_AQi</span></code> differ in the number of
columns.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcRelativeRotationMatrix">
<span class="sig-name descname"><span class="pre">CalcRelativeRotationMatrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.systems.framework.Context_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.Frame_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.Frame_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.math.RotationMatrix_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcRelativeRotationMatrix" title="Link to this definition"></a></dt>
<dd><p>Calculates the rotation matrix <code class="docutils literal notranslate"><span class="pre">R_AB</span></code> relating frame A and frame B.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The state of the multibody system, which includes the system’s
generalized positions q. Note: <code class="docutils literal notranslate"><span class="pre">R_AB</span></code> is a function of q.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_A</span></code>:</dt><dd><p>The frame A designated in the rigid transform <code class="docutils literal notranslate"><span class="pre">R_AB</span></code>.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_B</span></code>:</dt><dd><p>The frame G designated in the rigid transform <code class="docutils literal notranslate"><span class="pre">R_AB</span></code>.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">R_AB</span></code>:</dt><dd><p>The RigidTransform relating frame A and frame B.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcRelativeTransform">
<span class="sig-name descname"><span class="pre">CalcRelativeTransform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.systems.framework.Context_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.Frame_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.Frame_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.math.RigidTransform_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcRelativeTransform" title="Link to this definition"></a></dt>
<dd><p>Calculates the rigid transform (pose) <code class="docutils literal notranslate"><span class="pre">X_AB</span></code> relating frame A and
frame B.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The state of the multibody system, which includes the system’s
generalized positions q. Note: <code class="docutils literal notranslate"><span class="pre">X_AB</span></code> is a function of q.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_A</span></code>:</dt><dd><p>The frame A designated in the rigid transform <code class="docutils literal notranslate"><span class="pre">X_AB</span></code>.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_B</span></code>:</dt><dd><p>The frame G designated in the rigid transform <code class="docutils literal notranslate"><span class="pre">X_AB</span></code>.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">X_AB</span></code>:</dt><dd><p>The RigidTransform relating frame A and frame B.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcSpatialAccelerationsFromVdot">
<span class="sig-name descname"><span class="pre">CalcSpatialAccelerationsFromVdot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.systems.framework.Context_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">known_vdot</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">pydrake.multibody.math.SpatialAcceleration_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcSpatialAccelerationsFromVdot" title="Link to this definition"></a></dt>
<dd><p>Given the state of this model in <code class="docutils literal notranslate"><span class="pre">context</span></code> and a known vector of
generalized accelerations <code class="docutils literal notranslate"><span class="pre">known_vdot</span></code>, this method computes the
spatial acceleration <code class="docutils literal notranslate"><span class="pre">A_WB</span></code> for each body as measured and expressed
in the world frame W.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context containing the state of this model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">known_vdot</span></code>:</dt><dd><p>A vector with the generalized accelerations for the full model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">A_WB_array</span></code>:</dt><dd><p>A pointer to a valid, non nullptr, vector of spatial accelerations
containing the spatial acceleration <code class="docutils literal notranslate"><span class="pre">A_WB</span></code> for each body. It
must be of size equal to the number of bodies in the model. On
output, entries will be ordered by BodyIndex.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if A_WB_array is not</strong><strong> of </strong><strong>size num_bodies</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcSpatialInertia">
<span class="sig-name descname"><span class="pre">CalcSpatialInertia</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.systems.framework.Context_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_F</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.Frame_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body_indexes</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.BodyIndex" title="pydrake.multibody.tree.BodyIndex"><span class="pre">pydrake.multibody.tree.BodyIndex</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.multibody.tree.SpatialInertia_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcSpatialInertia" title="Link to this definition"></a></dt>
<dd><p>Returns M_SFo_F, the spatial inertia of a set S of bodies about point
Fo (the origin of a frame F), expressed in frame F. You may regard
M_SFo_F as measuring spatial inertia as if the set S of bodies were
welded into a single composite body at the configuration specified in
the <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>Contains the configuration of the set S of bodies.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_F</span></code>:</dt><dd><p>specifies the about-point Fo (frame_F’s origin) and the
expressed-in frame for the returned spatial inertia.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body_indexes</span></code>:</dt><dd><p>Array of selected bodies. This method does not distinguish between
welded bodies, joint-connected bodies, etc.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if body_indexes contains an invalid BodyIndex</strong><strong> or </strong><strong>if</strong> – </p></li>
<li><p><strong>there is a repeated BodyIndex.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The mass and inertia of the world_body() does not contribute to
the the returned spatial inertia.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcSpatialMomentumInWorldAboutPoint">
<span class="sig-name descname"><span class="pre">CalcSpatialMomentumInWorldAboutPoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcSpatialMomentumInWorldAboutPoint" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>CalcSpatialMomentumInWorldAboutPoint(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], p_WoP_W: numpy.ndarray[object[3, 1]]) -&gt; pydrake.multibody.math.SpatialMomentum_[AutoDiffXd]</p></li>
</ol>
<p>This method returns the spatial momentum of <code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant in
the world frame W, about a designated point P, expressed in the world
frame W.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>Contains the state of the model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_WoP_W</span></code>:</dt><dd><p>Position from Wo (origin of the world frame W) to an arbitrary
point P, expressed in the world frame W.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">L_WSP_W</span></code>:</dt><dd><p>, spatial momentum of the system S represented by <code class="docutils literal notranslate"><span class="pre">this</span></code> plant,
measured in the world frame W, about point P, expressed in W.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>To calculate the spatial momentum of this system S in W about Scm
(the system’s center of mass), use something like:</p>
</div>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">plant</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// ... code to load a model ....</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">Vector3</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">p_WoScm_W</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="n">plant</span><span class="p">.</span><span class="n">CalcCenterOfMassPositionInWorld</span><span class="p">(</span><span class="n">context</span><span class="p">);</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">SpatialMomentum</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">L_WScm_W</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="n">plant</span><span class="p">.</span><span class="n">CalcSpatialMomentumInWorldAboutPoint</span><span class="p">(</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="n">p_WoScm_W</span><span class="p">);</span>
</pre></div>
</div>
</details><ol class="arabic simple" start="2">
<li><p>CalcSpatialMomentumInWorldAboutPoint(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], model_instances: list[pydrake.multibody.tree.ModelInstanceIndex], p_WoP_W: numpy.ndarray[object[3, 1]]) -&gt; pydrake.multibody.math.SpatialMomentum_[AutoDiffXd]</p></li>
</ol>
<p>This method returns the spatial momentum of a set of model instances
in the world frame W, about a designated point P, expressed in frame
W.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>Contains the state of the model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">model_instances</span></code>:</dt><dd><p>Set of selected model instances.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_WoP_W</span></code>:</dt><dd><p>Position from Wo (origin of the world frame W) to an arbitrary
point P, expressed in the world frame W.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">L_WSP_W</span></code>:</dt><dd><p>, spatial momentum of the system S represented by the
model_instances, measured in world frame W, about point P,
expressed in W.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>To calculate the spatial momentum of this system S in W about Scm
(the system’s center of mass), use something like:</p>
</div>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">plant</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// ... code to create a set of selected model instances, e.g., ...</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">ModelInstanceIndex</span><span class="w"> </span><span class="n">gripper_model_instance</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="n">plant</span><span class="p">.</span><span class="n">GetModelInstanceByName</span><span class="p">(</span><span class="s">&quot;gripper&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">ModelInstanceIndex</span><span class="w"> </span><span class="n">robot_model_instance</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="n">plant</span><span class="p">.</span><span class="n">GetBodyByName</span><span class="p">(</span><span class="s">&quot;end_effector&quot;</span><span class="p">).</span><span class="n">model_instance</span><span class="p">();</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ModelInstanceIndex</span><span class="o">&gt;</span><span class="w"> </span><span class="n">model_instances</span><span class="p">{</span>
<span class="w">    </span><span class="n">gripper_model_instance</span><span class="p">,</span><span class="w"> </span><span class="n">robot_model_instance</span><span class="p">};</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">Vector3</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">p_WoScm_W</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="n">plant</span><span class="p">.</span><span class="n">CalcCenterOfMassPositionInWorld</span><span class="p">(</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="n">model_instances</span><span class="p">);</span>
<span class="w">  </span><span class="n">SpatialMomentum</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">L_WScm_W</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="n">plant</span><span class="p">.</span><span class="n">CalcSpatialMomentumInWorldAboutPoint</span><span class="p">(</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="n">model_instances</span><span class="p">,</span>
<span class="w">                                               </span><span class="n">p_WoScm_W</span><span class="p">);</span>
</pre></div>
</div>
</details><dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if model_instances contains an invalid</strong> – </p></li>
<li><p><strong>ModelInstanceIndex.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcTotalMass">
<span class="sig-name descname"><span class="pre">CalcTotalMass</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcTotalMass" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>CalcTotalMass(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd]) -&gt; pydrake.autodiffutils.AutoDiffXd</p></li>
</ol>
<p>Calculates the total mass of all bodies in this MultibodyPlant.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>Contains the state of the model.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">The</span></code>:</dt><dd><p>total mass of all bodies or 0 if there are none.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The mass of the world_body() does not contribute to the total
mass.</p>
</div>
<ol class="arabic simple" start="2">
<li><p>CalcTotalMass(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], model_instances: list[pydrake.multibody.tree.ModelInstanceIndex]) -&gt; pydrake.autodiffutils.AutoDiffXd</p></li>
</ol>
<p>Calculates the total mass of all bodies contained in model_instances.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>Contains the state of the model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">model_instances</span></code>:</dt><dd><p>Vector of selected model instances. This method does not
distinguish between welded, joint connected, or floating bodies.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">The</span></code>:</dt><dd><p>total mass of all bodies belonging to a model instance in
model_instances or 0 if model_instances is empty.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The mass of the world_body() does not contribute to the total mass
and each body only contributes to the total mass once, even if the
body has repeated occurrence (instance) in model_instances.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CollectRegisteredGeometries">
<span class="sig-name descname"><span class="pre">CollectRegisteredGeometries</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bodies</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">pydrake.multibody.tree.RigidBody_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.GeometrySet" title="pydrake.geometry.GeometrySet"><span class="pre">pydrake.geometry.GeometrySet</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CollectRegisteredGeometries" title="Link to this definition"></a></dt>
<dd><p>For each of the provided <code class="docutils literal notranslate"><span class="pre">bodies</span></code>, collects up all geometries that
have been registered to that body. Intended to be used in conjunction
with CollisionFilterDeclaration and CollisionFilterManager::Apply() to
filter collisions between the geometries registered to the bodies.</p>
<p>For example:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Don&#39;t report on collisions between geometries affixed to `body1`,</span>
<span class="c1">// `body2`, or `body3`.</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">RigidBody</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*&gt;</span><span class="w"> </span><span class="n">bodies</span><span class="p">{</span><span class="o">&amp;</span><span class="n">body1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">body2</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">body3</span><span class="p">};</span>
<span class="n">geometry</span><span class="o">::</span><span class="n">GeometrySet</span><span class="w"> </span><span class="n">set</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">plant</span><span class="p">.</span><span class="n">CollectRegisteredGeometries</span><span class="p">(</span><span class="n">bodies</span><span class="p">);</span>
<span class="n">scene_graph</span><span class="p">.</span><span class="n">collision_filter_manager</span><span class="p">().</span><span class="n">Apply</span><span class="p">(</span>
<span class="w">    </span><span class="n">CollisionFilterDeclaration</span><span class="p">().</span><span class="n">ExcludeWithin</span><span class="p">(</span><span class="n">set</span><span class="p">));</span>
</pre></div>
</div>
</details><div class="admonition note">
<p class="admonition-title">Note</p>
<p>There is a <em>very</em> specific order of operations:</p>
</div>
<ol class="arabic simple">
<li><p>Bodies and geometries must be added to the MultibodyPlant.</p></li>
<li><p>Create GeometrySet instances from bodies (via this method).</p></li>
<li><p>Invoke SceneGraph::ExcludeCollisions*() to filter collisions.</p></li>
<li><p>Allocate context.</p></li>
</ol>
<p>Changing the order will cause exceptions to be thrown.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if this MultibodyPlant was not registered with a</strong> – </p></li>
<li><p><strong>SceneGraph.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.deformable_model">
<span class="sig-name descname"><span class="pre">deformable_model</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">drake::multibody::DeformableModel&lt;Eigen::AutoDiffScalar&lt;Eigen::Matrix&lt;double,</span> <span class="pre">-1,</span> <span class="pre">1,</span> <span class="pre">0,</span> <span class="pre">-1,</span> <span class="pre">1&gt;</span> <span class="pre">&gt;</span> <span class="pre">&gt;</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.deformable_model" title="Link to this definition"></a></dt>
<dd><p>Returns the DeformableModel owned by this plant.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This feature is considered to be <strong>experimental</strong> and may change
or be removed at any time, without any deprecation notice ahead of
time.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.EvalBodyPoseInWorld">
<span class="sig-name descname"><span class="pre">EvalBodyPoseInWorld</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.systems.framework.Context_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.RigidBody_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.math.RigidTransform_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.EvalBodyPoseInWorld" title="Link to this definition"></a></dt>
<dd><p>Evaluate the pose <code class="docutils literal notranslate"><span class="pre">X_WB</span></code> of a body B in the world frame W.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context storing the state of the model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body_B</span></code>:</dt><dd><p>The body B for which the pose is requested.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">X_WB</span></code>:</dt><dd><p>The pose of body frame B in the world frame W.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if Finalize</strong><strong>(</strong><strong>) </strong><strong>was not called on this model</strong><strong> or </strong><strong>if</strong> – </p></li>
<li><p><strong>body_B` does not belong to this model</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.EvalBodySpatialAccelerationInWorld">
<span class="sig-name descname"><span class="pre">EvalBodySpatialAccelerationInWorld</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.systems.framework.Context_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.RigidBody_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.multibody.math.SpatialAcceleration_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.EvalBodySpatialAccelerationInWorld" title="Link to this definition"></a></dt>
<dd><p>Evaluates A_WB, body B’s spatial acceleration in the world frame W.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context storing the state of the model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body_B</span></code>:</dt><dd><p>The body for which spatial acceleration is requested.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">A_WB_W</span></code>:</dt><dd><p>RigidBody B’s spatial acceleration in the world frame W, expressed
in W (for point Bo, the body’s origin).</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if Finalize</strong><strong>(</strong><strong>) </strong><strong>was not called on this model</strong><strong> or </strong><strong>if</strong> – </p></li>
<li><p><strong>body_B` does not belong to this model</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When cached values are out of sync with the state stored in
context, this method performs an expensive forward dynamics
computation, whereas once evaluated, successive calls to this
method are inexpensive.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.EvalBodySpatialVelocityInWorld">
<span class="sig-name descname"><span class="pre">EvalBodySpatialVelocityInWorld</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.systems.framework.Context_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.RigidBody_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.multibody.math.SpatialVelocity_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.EvalBodySpatialVelocityInWorld" title="Link to this definition"></a></dt>
<dd><p>Evaluates V_WB, body B’s spatial velocity in the world frame W.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context storing the state of the model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body_B</span></code>:</dt><dd><p>The body B for which the spatial velocity is requested.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">V_WB_W</span></code>:</dt><dd><p>RigidBody B’s spatial velocity in the world frame W, expressed in
W (for point Bo, the body’s origin).</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if Finalize</strong><strong>(</strong><strong>) </strong><strong>was not called on this model</strong><strong> or </strong><strong>if</strong> – </p></li>
<li><p><strong>body_B` does not belong to this model</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.EvalSceneGraphInspector">
<span class="sig-name descname"><span class="pre">EvalSceneGraphInspector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.systems.framework.Context_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.geometry.SceneGraphInspector_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.EvalSceneGraphInspector" title="Link to this definition"></a></dt>
<dd><p>Returns the inspector from the <code class="docutils literal notranslate"><span class="pre">context</span></code> for the SceneGraph
associated with this plant, via this plant’s “geometry_query” input
port. (In the future, the inspector might come from a different
context source that is more efficient than the “geometry_query” input
port.)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.Finalize">
<span class="sig-name descname"><span class="pre">Finalize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.Finalize" title="Link to this definition"></a></dt>
<dd><p>This method must be called after all elements in the model (joints,
bodies, force elements, constraints, etc.) are added and before any
computations are performed. It essentially compiles all the necessary
“topological information”, i.e. how bodies, joints and, any other
elements connect with each other, and performs all the required
pre-processing to enable computations at a later stage.</p>
<p>If the finalize stage is successful, the topology of this
MultibodyPlant is valid, meaning that the topology is up-to-date after
this call. No more multibody elements can be added after a call to
Finalize().</p>
<p>At Finalize(), state and input/output ports for <code class="docutils literal notranslate"><span class="pre">this</span></code> plant are
declared.</p>
<p>For a full account of the effects of Finalize(), see
mbp_finalize_stage “Finalize() stage”.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>is_finalized(), mbp_finalize_stage “Finalize() stage”.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if the MultibodyPlant has already been finalized.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.geometry_source_is_registered">
<span class="sig-name descname"><span class="pre">geometry_source_is_registered</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.geometry_source_is_registered" title="Link to this definition"></a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if <code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant was registered with a
SceneGraph. This method can be called at any time during the lifetime
of <code class="docutils literal notranslate"><span class="pre">this</span></code> plant to query if <code class="docutils literal notranslate"><span class="pre">this</span></code> plant has been registered with
a SceneGraph, either pre- or post-finalize, see Finalize().</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_actuation_input_port">
<span class="sig-name descname"><span class="pre">get_actuation_input_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_actuation_input_port" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>get_actuation_input_port(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd]) -&gt; pydrake.systems.framework.InputPort_[AutoDiffXd]</p></li>
</ol>
<p>Returns a constant reference to the input port for external actuation
for all actuated dofs. This input port is a vector valued port and can
be set with JointActuator::set_actuation_vector(). The actuation value
for a particular actuator can be found at offset
JointActuator::input_start() in this vector. Refer to mbp_actuation
“Actuation” for further details.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>Finalize() was already called on <code class="docutils literal notranslate"><span class="pre">this</span></code> plant.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called before Finalize</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>get_actuation_input_port(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; pydrake.systems.framework.InputPort_[AutoDiffXd]</p></li>
</ol>
<p>Returns a constant reference to the input port for external actuation
for a specific model instance. This is a vector valued port with
entries ordered by monotonically increasing JointActuatorIndex within
<code class="docutils literal notranslate"><span class="pre">model_instance</span></code>. Refer to mbp_actuation “Actuation” for further
details.</p>
<p>Every model instance in <code class="docutils literal notranslate"><span class="pre">this</span></code> plant model has an actuation input
port, even if zero sized (for model instance with no actuators).</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>GetJointActuatorIndices(), GetActuatedJointIndices().</p>
</div>
<dl class="simple">
<dt>Precondition:</dt><dd><p>Finalize() was already called on <code class="docutils literal notranslate"><span class="pre">this</span></code> plant.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if called before Finalize</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p></li>
<li><p><strong>RuntimeError if the model instance does not exist.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_adjacent_bodies_collision_filters">
<span class="sig-name descname"><span class="pre">get_adjacent_bodies_collision_filters</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_adjacent_bodies_collision_filters" title="Link to this definition"></a></dt>
<dd><p>Returns whether to apply collision filters to topologically adjacent
bodies at Finalize() time.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_applied_generalized_force_input_port">
<span class="sig-name descname"><span class="pre">get_applied_generalized_force_input_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.systems.framework.InputPort_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_applied_generalized_force_input_port" title="Link to this definition"></a></dt>
<dd><p>Returns a constant reference to the vector-valued input port for
applied generalized forces, and the vector will be added directly into
<code class="docutils literal notranslate"><span class="pre">tau</span></code> (see mbp_equations_of_motion “System dynamics”). This vector
is ordered using the same convention as the plant velocities: you can
set the generalized forces that will be applied to model instance i
using, e.g., <code class="docutils literal notranslate"><span class="pre">SetVelocitiesInArray(i,</span> <span class="pre">model_forces,</span> <span class="pre">&amp;force_array)</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called before Finalize</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_applied_spatial_force_input_port">
<span class="sig-name descname"><span class="pre">get_applied_spatial_force_input_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.systems.framework.InputPort_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_applied_spatial_force_input_port" title="Link to this definition"></a></dt>
<dd><p>Returns a constant reference to the input port for applying spatial
forces to bodies in the plant. The data type for the port is an
std::vector of ExternallyAppliedSpatialForce; any number of spatial
forces can be applied to any number of bodies in the plant.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_body">
<span class="sig-name descname"><span class="pre">get_body</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.BodyIndex" title="pydrake.multibody.tree.BodyIndex"><span class="pre">pydrake.multibody.tree.BodyIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.multibody.tree.RigidBody_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_body" title="Link to this definition"></a></dt>
<dd><p>Returns a constant reference to the body with unique index
<code class="docutils literal notranslate"><span class="pre">body_index</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if body_index does not correspond to a body in</strong> – </p></li>
<li><p><strong>this model.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_body_poses_output_port">
<span class="sig-name descname"><span class="pre">get_body_poses_output_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.systems.framework.OutputPort_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_body_poses_output_port" title="Link to this definition"></a></dt>
<dd><p>Returns the output port of all body poses in the world frame. You can
obtain the pose <code class="docutils literal notranslate"><span class="pre">X_WB</span></code> of a body B in the world frame W with:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">X_WB_all</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">plant</span><span class="p">.</span><span class="n">get_body_poses_output_port</span><span class="p">().</span>
<span class="w">      </span><span class="p">.</span><span class="n">Eval</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">math</span><span class="o">::</span><span class="n">RigidTransform</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">plant_context</span><span class="p">);</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">BodyIndex</span><span class="w"> </span><span class="n">arm_body_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">plant</span><span class="p">.</span><span class="n">GetBodyByName</span><span class="p">(</span><span class="s">&quot;arm&quot;</span><span class="p">).</span><span class="n">index</span><span class="p">();</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">math</span><span class="o">::</span><span class="n">RigidTransform</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">X_WArm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">X_WB_all</span><span class="p">[</span><span class="n">arm_body_index</span><span class="p">];</span>
</pre></div>
</div>
</details><p>As shown in the example above, the resulting <code class="docutils literal notranslate"><span class="pre">std::vector</span></code> of body
poses is indexed by BodyIndex, and it has size num_bodies(). BodyIndex
“zero” (0) always corresponds to the world body, with pose equal to
the identity at all times.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_body_spatial_accelerations_output_port">
<span class="sig-name descname"><span class="pre">get_body_spatial_accelerations_output_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.systems.framework.OutputPort_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_body_spatial_accelerations_output_port" title="Link to this definition"></a></dt>
<dd><p>Returns the output port of all body spatial accelerations in the world
frame. You can obtain the spatial acceleration <code class="docutils literal notranslate"><span class="pre">A_WB</span></code> of a body B
(for point Bo, the body’s origin) in the world frame W with:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">A_WB_all</span><span class="w"> </span><span class="o">=</span>
<span class="w">  </span><span class="n">plant</span><span class="p">.</span><span class="n">get_body_spatial_accelerations_output_port</span><span class="p">().</span>
<span class="w">      </span><span class="p">.</span><span class="n">Eval</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SpatialAcceleration</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">plant_context</span><span class="p">);</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">BodyIndex</span><span class="w"> </span><span class="n">arm_body_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">plant</span><span class="p">.</span><span class="n">GetBodyByName</span><span class="p">(</span><span class="s">&quot;arm&quot;</span><span class="p">).</span><span class="n">index</span><span class="p">();</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">SpatialVelocity</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">A_WArm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A_WB_all</span><span class="p">[</span><span class="n">arm_body_index</span><span class="p">];</span>
</pre></div>
</div>
</details><p>As shown in the example above, the resulting <code class="docutils literal notranslate"><span class="pre">std::vector</span></code> of body
spatial accelerations is indexed by BodyIndex, and it has size
num_bodies(). BodyIndex “zero” (0) always corresponds to the world
body, with zero spatial acceleration at all times.</p>
<p>In a discrete-time plant, the use_sampled_output_ports setting affects
the output of this port. See output_port_sampling “Output port
sampling” for details. When sampling is enabled and the plant has not
yet taken a step, the output value will be all zeros.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_body_spatial_velocities_output_port">
<span class="sig-name descname"><span class="pre">get_body_spatial_velocities_output_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.systems.framework.OutputPort_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_body_spatial_velocities_output_port" title="Link to this definition"></a></dt>
<dd><p>Returns the output port of all body spatial velocities in the world
frame. You can obtain the spatial velocity <code class="docutils literal notranslate"><span class="pre">V_WB</span></code> of a body B in the
world frame W with:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">V_WB_all</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">plant</span><span class="p">.</span><span class="n">get_body_spatial_velocities_output_port</span><span class="p">().</span>
<span class="w">      </span><span class="p">.</span><span class="n">Eval</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SpatialVelocity</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">plant_context</span><span class="p">);</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">BodyIndex</span><span class="w"> </span><span class="n">arm_body_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">plant</span><span class="p">.</span><span class="n">GetBodyByName</span><span class="p">(</span><span class="s">&quot;arm&quot;</span><span class="p">).</span><span class="n">index</span><span class="p">();</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">SpatialVelocity</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">V_WArm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">V_WB_all</span><span class="p">[</span><span class="n">arm_body_index</span><span class="p">];</span>
</pre></div>
</div>
</details><p>As shown in the example above, the resulting <code class="docutils literal notranslate"><span class="pre">std::vector</span></code> of body
spatial velocities is indexed by BodyIndex, and it has size
num_bodies(). BodyIndex “zero” (0) always corresponds to the world
body, with zero spatial velocity at all times.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_contact_model">
<span class="sig-name descname"><span class="pre">get_contact_model</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.multibody.plant.ContactModel" title="pydrake.multibody.plant.ContactModel"><span class="pre">pydrake.multibody.plant.ContactModel</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_contact_model" title="Link to this definition"></a></dt>
<dd><p>Returns the model used for contact. See documentation for
ContactModel.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_contact_penalty_method_time_scale">
<span class="sig-name descname"><span class="pre">get_contact_penalty_method_time_scale</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_contact_penalty_method_time_scale" title="Link to this definition"></a></dt>
<dd><p>Returns a time-scale estimate <code class="docutils literal notranslate"><span class="pre">tc</span></code> based on the requested
penetration allowance δ set with set_penetration_allowance(). For the
compliant contact model to enforce non-penetration, this time scale
relates to the time it takes the relative normal velocity between two
bodies to go to zero. This time scale <code class="docutils literal notranslate"><span class="pre">tc</span></code> is a global estimate of
the dynamics introduced by the compliant contact model and goes to
zero in the limit to ideal rigid contact. Since numerical integration
methods for continuum systems must be able to resolve a system’s
dynamics, the time step used by an integrator must in general be much
smaller than the time scale <code class="docutils literal notranslate"><span class="pre">tc</span></code>. How much smaller will depend on
the details of the problem and the convergence characteristics of the
integrator and should be tuned appropriately. Another factor to take
into account for setting up the simulation’s time step is the speed of
the objects in your simulation. If <code class="docutils literal notranslate"><span class="pre">vn</span></code> represents a reference
velocity scale for the normal relative velocity between bodies, the
new time scale <code class="docutils literal notranslate"><span class="pre">tn</span> <span class="pre">=</span> <span class="pre">δ</span> <span class="pre">/</span> <span class="pre">vn</span></code> represents the time it would take for
the distance between two bodies approaching with relative normal
velocity <code class="docutils literal notranslate"><span class="pre">vn</span></code> to decrease by the penetration_allowance δ. In this
case a user should choose a time step for simulation that can resolve
the smallest of the two time scales <code class="docutils literal notranslate"><span class="pre">tc</span></code> and <code class="docutils literal notranslate"><span class="pre">tn</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_contact_results_output_port">
<span class="sig-name descname"><span class="pre">get_contact_results_output_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.systems.framework.OutputPort_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_contact_results_output_port" title="Link to this definition"></a></dt>
<dd><p>Returns a constant reference to the port that outputs ContactResults.</p>
<p>In a discrete-time plant, the use_sampled_output_ports setting affects
the output of this port. See output_port_sampling “Output port
sampling” for details. When sampling is enabled and the plant has not
yet taken a step, the output value will be empty (no contacts).</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize</strong><strong>, </strong><strong>see Finalize</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_contact_surface_representation">
<span class="sig-name descname"><span class="pre">get_contact_surface_representation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.HydroelasticContactRepresentation" title="pydrake.geometry.HydroelasticContactRepresentation"><span class="pre">pydrake.geometry.HydroelasticContactRepresentation</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_contact_surface_representation" title="Link to this definition"></a></dt>
<dd><p>Gets the current representation of contact surfaces used by <code class="docutils literal notranslate"><span class="pre">this</span></code>
MultibodyPlant.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_deformable_body_configuration_output_port">
<span class="sig-name descname"><span class="pre">get_deformable_body_configuration_output_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.systems.framework.OutputPort_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_deformable_body_configuration_output_port" title="Link to this definition"></a></dt>
<dd><p>Returns the output port for vertex positions (configurations),
measured and expressed in the World frame, of the deformable bodies in
<code class="docutils literal notranslate"><span class="pre">this</span></code> plant as a GeometryConfigurationVector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_desired_state_input_port">
<span class="sig-name descname"><span class="pre">get_desired_state_input_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.systems.framework.InputPort_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_desired_state_input_port" title="Link to this definition"></a></dt>
<dd><p>For models with PD controlled joint actuators, returns the port to
provide the desired state for the given <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>. Refer to
mbp_actuation “Actuation” for further details.</p>
<p>For consistency with get_actuation_input_port(), each model instance
in <code class="docutils literal notranslate"><span class="pre">this</span></code> plant model has a desired states input port, even if zero
sized (for model instance with no actuators.)</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This port always has size 2 * num_actuators(model_instance), where
we assume 1-DOF actuated joints. This port must provide one
desired position and one desired velocity per joint actuator,
packed as xd = [qd, vd], with positions and velocities in order of
increasing JointActuatorIndex. Only desired states corresponding
to PD-controlled actuators on non-locked joints
(Joint::is_locked()) are used, the rest are ignored. That is PD
control on just a subset of actuators is allowed.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The desired state input port for a given model instance is not
required to be connected. If disconnected, the controllers for
such model instance will be <em>disarmed</em>. Refer to
pd_controllers_and_ports for further details.</p>
</div>
<p>As an example of this structure, consider the following code to fix
desired states input values:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">plant</span><span class="p">;</span>
<span class="c1">// ... Load/parse plant model ...</span>
<span class="n">plant</span><span class="p">.</span><span class="n">Finalize</span><span class="p">();</span>
<span class="k">auto</span><span class="w"> </span><span class="n">context</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">plant</span><span class="p">.</span><span class="n">CreateDefaultContext</span><span class="p">();</span>
<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">num_u</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">plant</span><span class="p">.</span><span class="n">num_actuators</span><span class="p">(</span><span class="n">model_instance</span><span class="p">);</span>
<span class="k">const</span><span class="w"> </span><span class="n">VectorXd</span><span class="w"> </span><span class="nf">model_xd</span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">num_u</span><span class="p">);</span>
<span class="k">auto</span><span class="w"> </span><span class="n">model_qd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">model_xd</span><span class="p">.</span><span class="n">head</span><span class="p">(</span><span class="n">num_u</span><span class="p">);</span>
<span class="k">auto</span><span class="w"> </span><span class="n">model_vd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">model_xd</span><span class="p">.</span><span class="n">tail</span><span class="p">(</span><span class="n">num_u</span><span class="p">);</span>

<span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="c1">// Specify qd and vd in increasing order of JointActuatorIndex, as</span>
<span class="c1">// returned by GetJointActuatorIndices().</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">JointActuatorIndex</span><span class="w"> </span><span class="n">actuator_index</span><span class="w"> </span><span class="o">:</span>
<span class="w">    </span><span class="n">plant</span><span class="p">.</span><span class="n">GetJointActuatorIndices</span><span class="p">(</span><span class="n">model_instance</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">qd</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">....</span><span class="w"> </span><span class="n">desired</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">actuator_index</span>
<span class="w">  </span><span class="n">vd</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">....</span><span class="w"> </span><span class="n">desired</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">actuator_index</span>
<span class="w">  </span><span class="o">++</span><span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// As an example, fix values in the context.</span>
<span class="n">plant</span><span class="p">.</span><span class="n">get_desired_state_input_port</span><span class="p">(</span><span class="n">model_instance</span><span class="p">).</span><span class="n">FixValue</span><span class="p">(</span>
<span class="w">    </span><span class="o">&amp;</span><span class="n">plant_context</span><span class="p">,</span><span class="w"> </span><span class="n">model_xd</span><span class="p">);</span>
</pre></div>
</div>
</details></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_discrete_contact_approximation">
<span class="sig-name descname"><span class="pre">get_discrete_contact_approximation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.multibody.plant.DiscreteContactApproximation" title="pydrake.multibody.plant.DiscreteContactApproximation"><span class="pre">pydrake.multibody.plant.DiscreteContactApproximation</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_discrete_contact_approximation" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>the discrete contact solver approximation.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_discrete_contact_solver">
<span class="sig-name descname"><span class="pre">get_discrete_contact_solver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.multibody.plant.DiscreteContactSolver" title="pydrake.multibody.plant.DiscreteContactSolver"><span class="pre">pydrake.multibody.plant.DiscreteContactSolver</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_discrete_contact_solver" title="Link to this definition"></a></dt>
<dd><p>Returns the contact solver type used for discrete MultibodyPlant
models.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_force_element">
<span class="sig-name descname"><span class="pre">get_force_element</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">force_element_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ForceElementIndex" title="pydrake.multibody.tree.ForceElementIndex"><span class="pre">pydrake.multibody.tree.ForceElementIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.multibody.tree.ForceElement_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_force_element" title="Link to this definition"></a></dt>
<dd><p>Returns a constant reference to the force element with unique index
<code class="docutils literal notranslate"><span class="pre">force_element_index</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError when force_element_index does not correspond to a</strong> – </p></li>
<li><p><strong>force element in this model.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_frame">
<span class="sig-name descname"><span class="pre">get_frame</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.FrameIndex" title="pydrake.multibody.tree.FrameIndex"><span class="pre">pydrake.multibody.tree.FrameIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.multibody.tree.Frame_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_frame" title="Link to this definition"></a></dt>
<dd><p>Returns a constant reference to the frame with unique index
<code class="docutils literal notranslate"><span class="pre">frame_index</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if frame_index does not correspond to a frame in</strong> – </p></li>
<li><p><strong>this plant.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_generalized_acceleration_output_port">
<span class="sig-name descname"><span class="pre">get_generalized_acceleration_output_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_generalized_acceleration_output_port" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>get_generalized_acceleration_output_port(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd]) -&gt; pydrake.systems.framework.OutputPort_[AutoDiffXd]</p></li>
</ol>
<p>Returns a constant reference to the output port for generalized
accelerations v̇ of the model.</p>
<p>In a discrete-time plant, the use_sampled_output_ports setting affects
the output of this port. See output_port_sampling “Output port
sampling” for details. When sampling is enabled and the plant has not
yet taken a step, the output value will be all zeros.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>Finalize() was already called on <code class="docutils literal notranslate"><span class="pre">this</span></code> plant.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called before Finalize</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>get_generalized_acceleration_output_port(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; pydrake.systems.framework.OutputPort_[AutoDiffXd]</p></li>
</ol>
<p>Returns a constant reference to the output port for the generalized
accelerations v̇ᵢ ⊆ v̇ for model instance i.</p>
<p>In a discrete-time plant, the use_sampled_output_ports setting affects
the output of this port. See output_port_sampling “Output port
sampling” for details. When sampling is enabled and the plant has not
yet taken a step, the output value will be all zeros.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>Finalize() was already called on <code class="docutils literal notranslate"><span class="pre">this</span></code> plant.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if called before Finalize</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p></li>
<li><p><strong>RuntimeError if the model instance does not exist.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_generalized_contact_forces_output_port">
<span class="sig-name descname"><span class="pre">get_generalized_contact_forces_output_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.systems.framework.OutputPort_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_generalized_contact_forces_output_port" title="Link to this definition"></a></dt>
<dd><p>Returns a constant reference to the output port of generalized contact
forces for a specific model instance.</p>
<p>In a discrete-time plant, the use_sampled_output_ports setting affects
the output of this port. See output_port_sampling “Output port
sampling” for details. When sampling is enabled and the plant has not
yet taken a step, the output value will be all zeros.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>Finalize() was already called on <code class="docutils literal notranslate"><span class="pre">this</span></code> plant.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if called before Finalize</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p></li>
<li><p><strong>RuntimeError if the model instance does not exist.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_geometry_pose_output_port">
<span class="sig-name descname"><span class="pre">get_geometry_pose_output_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.systems.framework.OutputPort_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_geometry_pose_output_port" title="Link to this definition"></a></dt>
<dd><p>Returns the output port of frames’ poses to communicate with a
SceneGraph.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_geometry_query_input_port">
<span class="sig-name descname"><span class="pre">get_geometry_query_input_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.systems.framework.InputPort_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_geometry_query_input_port" title="Link to this definition"></a></dt>
<dd><p>Returns a constant reference to the input port used to perform
geometric queries on a SceneGraph. See
SceneGraph::get_query_output_port(). Refer to section mbp_geometry
“Geometry” of this class’s documentation for further details on
collision geometry registration and connection with a SceneGraph.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_joint">
<span class="sig-name descname"><span class="pre">get_joint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">joint_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JointIndex" title="pydrake.multibody.tree.JointIndex"><span class="pre">pydrake.multibody.tree.JointIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.multibody.tree.Joint_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_joint" title="Link to this definition"></a></dt>
<dd><p>Returns a constant reference to the joint with unique index
<code class="docutils literal notranslate"><span class="pre">joint_index</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError when joint_index does not correspond to a joint</strong> – </p></li>
<li><p><strong>in this model.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_joint_actuator">
<span class="sig-name descname"><span class="pre">get_joint_actuator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">actuator_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JointActuatorIndex" title="pydrake.multibody.tree.JointActuatorIndex"><span class="pre">pydrake.multibody.tree.JointActuatorIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.multibody.tree.JointActuator_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_joint_actuator" title="Link to this definition"></a></dt>
<dd><p>Returns a constant reference to the joint actuator with unique index
<code class="docutils literal notranslate"><span class="pre">actuator_index</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if actuator_index does not correspond to a joint</strong> – </p></li>
<li><p><strong>actuator in this tree.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_mutable_joint">
<span class="sig-name descname"><span class="pre">get_mutable_joint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">joint_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JointIndex" title="pydrake.multibody.tree.JointIndex"><span class="pre">pydrake.multibody.tree.JointIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.multibody.tree.Joint_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_mutable_joint" title="Link to this definition"></a></dt>
<dd><p>Returns a mutable reference to the joint with unique index
<code class="docutils literal notranslate"><span class="pre">joint_index</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError when joint_index does not correspond to a joint</strong> – </p></li>
<li><p><strong>in this model.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_mutable_joint_actuator">
<span class="sig-name descname"><span class="pre">get_mutable_joint_actuator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">actuator_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JointActuatorIndex" title="pydrake.multibody.tree.JointActuatorIndex"><span class="pre">pydrake.multibody.tree.JointActuatorIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.multibody.tree.JointActuator_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_mutable_joint_actuator" title="Link to this definition"></a></dt>
<dd><p>Returns a mutable reference to the joint actuator with unique index
<code class="docutils literal notranslate"><span class="pre">actuator_index</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if actuator_index does not correspond to a joint</strong> – </p></li>
<li><p><strong>actuator in this tree.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_net_actuation_output_port">
<span class="sig-name descname"><span class="pre">get_net_actuation_output_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_net_actuation_output_port" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>get_net_actuation_output_port(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd]) -&gt; pydrake.systems.framework.OutputPort_[AutoDiffXd]</p></li>
</ol>
<p>Returns a constant reference to the output port that reports actuation
values applied through joint actuators. This output port is a vector
valued port. The actuation value for a particular actuator can be
found at offset JointActuator::input_start() in this vector. Models
that include PD controllers will include their contribution in this
port, refer to mbp_actuation “Actuation” for further details.</p>
<p>In a discrete-time plant, the use_sampled_output_ports setting affects
the output of this port. See output_port_sampling “Output port
sampling” for details. When sampling is enabled and the plant has not
yet taken a step, the output value will be all zeros.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>PD controllers are not considered for actuators on locked joints,
see Joint::Lock(). Therefore they do not contribute to this port.</p>
</div>
<dl class="simple">
<dt>Precondition:</dt><dd><p>Finalize() was already called on <code class="docutils literal notranslate"><span class="pre">this</span></code> plant.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called before Finalize</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>get_net_actuation_output_port(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; pydrake.systems.framework.OutputPort_[AutoDiffXd]</p></li>
</ol>
<p>Returns a constant reference to the output port that reports actuation
values applied through joint actuators, for a specific model instance.
Models that include PD controllers will include their contribution in
this port, refer to mbp_actuation “Actuation” for further details.
This is a vector valued port with entries ordered by monotonically
increasing JointActuatorIndex within <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>.</p>
<p>Every model instance in <code class="docutils literal notranslate"><span class="pre">this</span></code> plant model has a net actuation
output port, even if zero sized (for model instance with no
actuators).</p>
<p>In a discrete-time plant, the use_sampled_output_ports setting affects
the output of this port. See output_port_sampling “Output port
sampling” for details. When sampling is enabled and the plant has not
yet taken a step, the output value will be all zeros.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>PD controllers are not considered for actuators on locked joints,
see Joint::Lock(). Therefore they do not contribute to this port.</p>
</div>
<dl class="simple">
<dt>Precondition:</dt><dd><p>Finalize() was already called on <code class="docutils literal notranslate"><span class="pre">this</span></code> plant.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called before Finalize</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_reaction_forces_output_port">
<span class="sig-name descname"><span class="pre">get_reaction_forces_output_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.systems.framework.OutputPort_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_reaction_forces_output_port" title="Link to this definition"></a></dt>
<dd><p>Returns the port for joint reaction forces. A Joint models the
kinematical relationship which characterizes the possible relative
motion between two bodies. In Drake, a joint connects a frame <code class="docutils literal notranslate"><span class="pre">Jp</span></code>
on <em>parent</em> body P with a frame <code class="docutils literal notranslate"><span class="pre">Jc</span></code> on a <em>child</em> body C. This usage
of the terms <em>parent</em> and <em>child</em> is just a convention and implies
nothing about the inboard-outboard relationship between the bodies.
Since a Joint imposes a kinematical relationship which characterizes
the possible relative motion between frames Jp and Jc, reaction forces
on each body are established. That is, we could cut the model at the
joint and replace it with equivalent forces equal to these reaction
forces in order to attain the same motions of the mechanical system.</p>
<p>This output port allows to evaluate the reaction force <code class="docutils literal notranslate"><span class="pre">F_CJc_Jc</span></code> on
the <em>child</em> body C, at <code class="docutils literal notranslate"><span class="pre">Jc</span></code>, and expressed in Jc for all joints in
the model. This port evaluates to a vector of type
std::vector&lt;SpatialForce&lt;T&gt;&gt; and size num_joints() indexed by
JointIndex, see Joint::index(). Each entry corresponds to the spatial
force <code class="docutils literal notranslate"><span class="pre">F_CJc_Jc</span></code> applied on the joint’s child body C
(Joint::child_body()), at the joint’s child frame <code class="docutils literal notranslate"><span class="pre">Jc</span></code>
(Joint::frame_on_child()) and expressed in frame <code class="docutils literal notranslate"><span class="pre">Jc</span></code>.</p>
<p>In a discrete-time plant, the use_sampled_output_ports setting affects
the output of this port. See output_port_sampling “Output port
sampling” for details. When sampling is enabled and the plant has not
yet taken a step, the output value will be all zeros.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_sap_near_rigid_threshold">
<span class="sig-name descname"><span class="pre">get_sap_near_rigid_threshold</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_sap_near_rigid_threshold" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>the SAP near rigid regime threshold.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>See set_sap_near_rigid_threshold().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_source_id">
<span class="sig-name descname"><span class="pre">get_source_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.SourceId" title="pydrake.geometry.SourceId"><span class="pre">pydrake.geometry.SourceId</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_source_id" title="Link to this definition"></a></dt>
<dd><p>Returns the unique id identifying <code class="docutils literal notranslate"><span class="pre">this</span></code> plant as a source for a
SceneGraph. Returns <code class="docutils literal notranslate"><span class="pre">nullopt</span></code> if <code class="docutils literal notranslate"><span class="pre">this</span></code> plant did not register any
geometry. This method can be called at any time during the lifetime of
<code class="docutils literal notranslate"><span class="pre">this</span></code> plant to query if <code class="docutils literal notranslate"><span class="pre">this</span></code> plant has been registered with a
SceneGraph, either pre- or post-finalize, see Finalize(). However, a
geometry::SourceId is only assigned once at the first call of any of
this plant’s geometry registration methods, and it does not change
after that. Post-finalize calls will always return the same value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_state_output_port">
<span class="sig-name descname"><span class="pre">get_state_output_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_state_output_port" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>get_state_output_port(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd]) -&gt; pydrake.systems.framework.OutputPort_[AutoDiffXd]</p></li>
</ol>
<p>Returns a constant reference to the output port for the multibody
state x = [q, v] of the model.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>Finalize() was already called on <code class="docutils literal notranslate"><span class="pre">this</span></code> plant.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called before Finalize</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>get_state_output_port(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; pydrake.systems.framework.OutputPort_[AutoDiffXd]</p></li>
</ol>
<p>Returns a constant reference to the output port for the state xᵢ = [qᵢ
vᵢ] of model instance i. (Here qᵢ ⊆ q and vᵢ ⊆ v.)</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>Finalize() was already called on <code class="docutils literal notranslate"><span class="pre">this</span></code> plant.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if called before Finalize</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p></li>
<li><p><strong>RuntimeError if the model instance does not exist.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetAccelerationLowerLimits">
<span class="sig-name descname"><span class="pre">GetAccelerationLowerLimits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetAccelerationLowerLimits" title="Link to this definition"></a></dt>
<dd><p>Returns a vector of size <code class="docutils literal notranslate"><span class="pre">num_velocities()</span></code> containing the lower
acceleration limits for every generalized velocity coordinate. These
include joint and free body coordinates. Any unbounded or unspecified
limits will be -infinity.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetAccelerationUpperLimits">
<span class="sig-name descname"><span class="pre">GetAccelerationUpperLimits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetAccelerationUpperLimits" title="Link to this definition"></a></dt>
<dd><p>Upper limit analog of GetAccelerationsLowerLimits(), where any
unbounded or unspecified limits will be +infinity.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>GetAccelerationLowerLimits() for more information.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetActuatedJointIndices">
<span class="sig-name descname"><span class="pre">GetActuatedJointIndices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JointIndex" title="pydrake.multibody.tree.JointIndex"><span class="pre">pydrake.multibody.tree.JointIndex</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetActuatedJointIndices" title="Link to this definition"></a></dt>
<dd><p>Returns a list of actuated joint indices associated with
<code class="docutils literal notranslate"><span class="pre">model_instance</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetActuationFromArray">
<span class="sig-name descname"><span class="pre">GetActuationFromArray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">u</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetActuationFromArray" title="Link to this definition"></a></dt>
<dd><p>Returns a vector of actuation values for <code class="docutils literal notranslate"><span class="pre">model_instance</span></code> from a
vector <code class="docutils literal notranslate"><span class="pre">u</span></code> of actuation values for the entire plant model. Refer to
mbp_actuation “Actuation” for further details.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">u</span></code>:</dt><dd><p>Actuation values for the entire model. The actuation value in
<code class="docutils literal notranslate"><span class="pre">u</span></code> for a particular actuator must be found at offset
JointActuator::input_start().</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Actuation values for <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>, ordered by monotonically
increasing JointActuatorIndex.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>RuntimeError if u is not</strong><strong> of </strong><strong>size</strong> – </p></li>
<li><p><strong>MultibodyPlant::num_actuated_dofs</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetActuatorNames">
<span class="sig-name descname"><span class="pre">GetActuatorNames</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetActuatorNames" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetActuatorNames(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], add_model_instance_prefix: bool = True) -&gt; list[str]</p></li>
</ol>
<p>Returns a list of string names corresponding to each element of the
actuation vector. These strings take the form
<code class="docutils literal notranslate"><span class="pre">{model_instance_name}_{joint_actuator_name}</span></code>, but the prefix may
optionally be withheld using <code class="docutils literal notranslate"><span class="pre">add_model_instance_prefix</span></code>.</p>
<p>The returned names are guaranteed to be unique if
<code class="docutils literal notranslate"><span class="pre">add_model_instance_prefix</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code> (the default).</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if the plant is not finalized.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>GetActuatorNames(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], model_instance: pydrake.multibody.tree.ModelInstanceIndex, add_model_instance_prefix: bool = False) -&gt; list[str]</p></li>
</ol>
<p>Returns a list of string names corresponding to each element of the
actuation vector. These strings take the form
<code class="docutils literal notranslate"><span class="pre">{model_instance_name}_{joint_actuator_name}</span></code>, but the prefix may
optionally be withheld using <code class="docutils literal notranslate"><span class="pre">add_model_instance_prefix</span></code>.</p>
<p>The returned names are guaranteed to be unique.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the plant is not finalized</strong><strong> or </strong><strong>if the</strong> – </p></li>
<li><p><strong>model_instance` is invalid</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetBodiesKinematicallyAffectedBy">
<span class="sig-name descname"><span class="pre">GetBodiesKinematicallyAffectedBy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">joint_indexes</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JointIndex" title="pydrake.multibody.tree.JointIndex"><span class="pre">pydrake.multibody.tree.JointIndex</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.BodyIndex" title="pydrake.multibody.tree.BodyIndex"><span class="pre">pydrake.multibody.tree.BodyIndex</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetBodiesKinematicallyAffectedBy" title="Link to this definition"></a></dt>
<dd><p>Returns all bodies whose kinematics are transitively affected by the
given vector of Joints. This is a <em>kinematic</em> relationship rather than
a dynamic one. It is is inherently a query on the topology of the
plant’s modeled tree. Constraints are likewise not considered.</p>
<p>The affected bodies are returned in increasing order of body indices.
A body is included in the output if that body’s spatial velocity is
affected by the generalized velocities v of one of the indicated
joints.</p>
<p>As such, there are some notable implications:</p>
<p>1. If a body has an inboard free (6 dof) joint, it will be
<em>kinematically</em> affected by joints further inboard, even though there
might not be any dynamic influence on that body. 2. If the set of
joints have no velocities (i.e., they are all weld (0 dof) joints),
then, by definition, no bodies will be affected.</p>
<p>This function can be only be called post-finalize, see Finalize().</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if any</strong><strong> of </strong><strong>the given joint has an invalid index</strong><strong>,</strong> – </p></li>
<li><p><strong>doesn't correspond to a mobilizer</strong><strong>, or </strong><strong>is welded.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetBodiesWeldedTo">
<span class="sig-name descname"><span class="pre">GetBodiesWeldedTo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.RigidBody_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">pydrake.multibody.tree.RigidBody_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetBodiesWeldedTo" title="Link to this definition"></a></dt>
<dd><p>Returns all bodies that are transitively welded, or rigidly affixed,
to <code class="docutils literal notranslate"><span class="pre">body</span></code>, per these two definitions:</p>
<ol class="arabic simple">
<li><p>A body is always considered welded to itself.</p></li>
</ol>
<p>2. Two unique bodies are considered welded together exclusively by the
presence of a weld joint, not by other constructs that prevent mobility
(e.g. constraints).</p>
<p>This method can be called at any time during the lifetime of <code class="docutils literal notranslate"><span class="pre">this</span></code>
plant, either pre- or post-finalize, see Finalize().</p>
<p>Meant to be used with <code class="docutils literal notranslate"><span class="pre">CollectRegisteredGeometries</span></code>.</p>
<p>The following example demonstrates filtering collisions between all
bodies rigidly affixed to a door (which could be moving) and all
bodies rigidly affixed to the world:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">GeometrySet</span><span class="w"> </span><span class="n">g_world</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">plant</span><span class="p">.</span><span class="n">CollectRegisteredGeometries</span><span class="p">(</span>
<span class="w">    </span><span class="n">plant</span><span class="p">.</span><span class="n">GetBodiesWeldedTo</span><span class="p">(</span><span class="n">plant</span><span class="p">.</span><span class="n">world_body</span><span class="p">()));</span>
<span class="n">GeometrySet</span><span class="w"> </span><span class="n">g_door</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">plant</span><span class="p">.</span><span class="n">CollectRegisteredGeometries</span><span class="p">(</span>
<span class="w">    </span><span class="n">plant</span><span class="p">.</span><span class="n">GetBodiesWeldedTo</span><span class="p">(</span><span class="n">plant</span><span class="p">.</span><span class="n">GetBodyByName</span><span class="p">(</span><span class="s">&quot;door&quot;</span><span class="p">)));</span>
<span class="n">scene_graph</span><span class="p">.</span><span class="n">ExcludeCollisionsBetweeen</span><span class="p">(</span><span class="n">g_world</span><span class="p">,</span><span class="w"> </span><span class="n">g_door</span><span class="p">);</span>
</pre></div>
</div>
</details><div class="admonition note">
<p class="admonition-title">Note</p>
<p>Usages akin to this example may introduce redundant collision
filtering; this will not have a functional impact, but may have a
minor performance impact.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>all bodies rigidly fixed to <code class="docutils literal notranslate"><span class="pre">body</span></code>. This does not return the
bodies in any prescribed order.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>RuntimeError if body is not part</strong><strong> of </strong><strong>this plant.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetBodyByName">
<span class="sig-name descname"><span class="pre">GetBodyByName</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetBodyByName" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetBodyByName(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], name: str) -&gt; pydrake.multibody.tree.RigidBody_[AutoDiffXd]</p></li>
</ol>
<p>Returns a constant reference to a body that is identified by the
string <code class="docutils literal notranslate"><span class="pre">name</span></code> in <code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if there is no body with the requested name.</strong> – </p></li>
<li><p><strong>RuntimeError if the body name occurs in multiple model instances.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>HasBodyNamed() to query if there exists a body in <code class="docutils literal notranslate"><span class="pre">this</span></code>
MultibodyPlant with a given specified name.</p>
</div>
<ol class="arabic simple" start="2">
<li><p>GetBodyByName(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; pydrake.multibody.tree.RigidBody_[AutoDiffXd]</p></li>
</ol>
<p>Returns a constant reference to the body that is uniquely identified
by the string <code class="docutils literal notranslate"><span class="pre">name</span></code> and <code class="docutils literal notranslate"><span class="pre">model_instance</span></code> in <code class="docutils literal notranslate"><span class="pre">this</span></code>
MultibodyPlant.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if there is no body with the requested name.</strong> – </p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>HasBodyNamed() to query if there exists a body in <code class="docutils literal notranslate"><span class="pre">this</span></code>
MultibodyPlant with a given specified name.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetBodyFrameIdIfExists">
<span class="sig-name descname"><span class="pre">GetBodyFrameIdIfExists</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.BodyIndex" title="pydrake.multibody.tree.BodyIndex"><span class="pre">pydrake.multibody.tree.BodyIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.FrameId" title="pydrake.geometry.FrameId"><span class="pre">pydrake.geometry.FrameId</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetBodyFrameIdIfExists" title="Link to this definition"></a></dt>
<dd><p>If the body with <code class="docutils literal notranslate"><span class="pre">body_index</span></code> belongs to the called plant, it
returns the geometry::FrameId associated with it. Otherwise, it
returns nullopt.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetBodyFrameIdOrThrow">
<span class="sig-name descname"><span class="pre">GetBodyFrameIdOrThrow</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.BodyIndex" title="pydrake.multibody.tree.BodyIndex"><span class="pre">pydrake.multibody.tree.BodyIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.FrameId" title="pydrake.geometry.FrameId"><span class="pre">pydrake.geometry.FrameId</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetBodyFrameIdOrThrow" title="Link to this definition"></a></dt>
<dd><p>If the body with <code class="docutils literal notranslate"><span class="pre">body_index</span></code> belongs to the called plant, it
returns the geometry::FrameId associated with it. Otherwise this
method throws an exception.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the called plant does not have the body indicated</strong> – </p></li>
<li><p><strong>by body_index.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetBodyFromFrameId">
<span class="sig-name descname"><span class="pre">GetBodyFromFrameId</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.FrameId" title="pydrake.geometry.FrameId"><span class="pre">pydrake.geometry.FrameId</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.multibody.tree.RigidBody_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetBodyFromFrameId" title="Link to this definition"></a></dt>
<dd><p>Given a geometry frame identifier, returns a pointer to the body
associated with that id (nullptr if there is no such body).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetBodyIndices">
<span class="sig-name descname"><span class="pre">GetBodyIndices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.BodyIndex" title="pydrake.multibody.tree.BodyIndex"><span class="pre">pydrake.multibody.tree.BodyIndex</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetBodyIndices" title="Link to this definition"></a></dt>
<dd><p>Returns a list of body indices associated with <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetCollisionGeometriesForBody">
<span class="sig-name descname"><span class="pre">GetCollisionGeometriesForBody</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.RigidBody_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.GeometryId" title="pydrake.geometry.GeometryId"><span class="pre">pydrake.geometry.GeometryId</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetCollisionGeometriesForBody" title="Link to this definition"></a></dt>
<dd><p>Returns an array of GeometryId’s identifying the different contact
geometries for <code class="docutils literal notranslate"><span class="pre">body</span></code> previously registered with a SceneGraph.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method can be called at any time during the lifetime of
<code class="docutils literal notranslate"><span class="pre">this</span></code> plant, either pre- or post-finalize, see Finalize().
Post-finalize calls will always return the same value.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>RegisterCollisionGeometry(), Finalize()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetConstraintActiveStatus">
<span class="sig-name descname"><span class="pre">GetConstraintActiveStatus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.systems.framework.Context_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">id</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.MultibodyConstraintId" title="pydrake.multibody.tree.MultibodyConstraintId"><span class="pre">pydrake.multibody.tree.MultibodyConstraintId</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetConstraintActiveStatus" title="Link to this definition"></a></dt>
<dd><p>Returns the active status of the constraint given by <code class="docutils literal notranslate"><span class="pre">id</span></code> in
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the MultibodyPlant has not been finalized.</strong> – </p></li>
<li><p><strong>RuntimeError if id does not belong to any multibody constraint</strong> – </p></li>
<li><p><strong>in context.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetConstraintIds">
<span class="sig-name descname"><span class="pre">GetConstraintIds</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.MultibodyConstraintId" title="pydrake.multibody.tree.MultibodyConstraintId"><span class="pre">pydrake.multibody.tree.MultibodyConstraintId</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetConstraintIds" title="Link to this definition"></a></dt>
<dd><p>Returns a list of all constraint identifiers. The returned vector
becomes invalid after any calls to Add*Constraint() or
RemoveConstraint().</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetDefaultContactSurfaceRepresentation">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">GetDefaultContactSurfaceRepresentation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">time_step</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.HydroelasticContactRepresentation" title="pydrake.geometry.HydroelasticContactRepresentation"><span class="pre">pydrake.geometry.HydroelasticContactRepresentation</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetDefaultContactSurfaceRepresentation" title="Link to this definition"></a></dt>
<dd><p>Return the default value for contact representation, given the desired
time step. Discrete systems default to use polygons; continuous
systems default to use triangles.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetDefaultDistanceConstraintParams">
<span class="sig-name descname"><span class="pre">GetDefaultDistanceConstraintParams</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">dict</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.MultibodyConstraintId" title="pydrake.multibody.tree.MultibodyConstraintId"><span class="pre">pydrake.multibody.tree.MultibodyConstraintId</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="#pydrake.multibody.plant.DistanceConstraintParams" title="pydrake.multibody.plant.DistanceConstraintParams"><span class="pre">pydrake.multibody.plant.DistanceConstraintParams</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetDefaultDistanceConstraintParams" title="Link to this definition"></a></dt>
<dd><p>Returns all default distance constraint parameters, as registered via
AddDistanceConstraint(). See GetDistanceConstraintParams() and
SetDistanceConstraintParams() for working with parameters stored in a
context.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetDefaultFloatingBaseBodyPose">
<span class="sig-name descname"><span class="pre">GetDefaultFloatingBaseBodyPose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.RigidBody_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.math.html#pydrake.math.RigidTransform" title="pydrake.math.RigidTransform"><span class="pre">pydrake.math.RigidTransform</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetDefaultFloatingBaseBodyPose" title="Link to this definition"></a></dt>
<dd><p>Gets the provisional default pose of <code class="docutils literal notranslate"><span class="pre">body</span></code> as set by
SetDefaultFloatingBaseBodyPose(). If no pose was specified for
<code class="docutils literal notranslate"><span class="pre">body</span></code>, returns the identity pose. This may be called pre- or
post-Finalize().</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This value is only meaningful for bodies that turn out to be
floating base bodies after Finalize(). If called on any other
body, the result simply echoes whatever provisional pose was set
in SetDefaultFloatingBaseBodyPose() but has no other effect. Use
the Joint API to get the default pose for any body that has an
explicitly-defined joint to its parent body.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Post-Finalize(), a floating base body’s default pose may be set
either by SetDefaultFloatingBaseBodyPose() or by setting the
default pose directly through the Joint API applied to the
automatically-added floating joint.
GetDefaultFloatingBaseBodyPose() will return the most-recent value
set by either method.</p>
</div>
<p>See mbp_working_with_free_bodies “above for details”.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body</span></code>:</dt><dd><p>RigidBody whose default pose will be retrieved.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">X_WB</span></code>:</dt><dd><p>The default pose of the floating base body B in World. Not
meaningful if <code class="docutils literal notranslate"><span class="pre">body</span></code> is not a floating base body.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetDefaultFreeBodyPose">
<span class="sig-name descname"><span class="pre">GetDefaultFreeBodyPose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.RigidBody_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.math.html#pydrake.math.RigidTransform" title="pydrake.math.RigidTransform"><span class="pre">pydrake.math.RigidTransform</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetDefaultFreeBodyPose" title="Link to this definition"></a></dt>
<dd><p>(Deprecated.)</p>
<dl class="simple">
<dt>Deprecated:</dt><dd><p>Use GetDefaultFloatingBaseBodyPose() instead. This will be removed
from Drake on or after 2026-06-01.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetDefaultPositions">
<span class="sig-name descname"><span class="pre">GetDefaultPositions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetDefaultPositions" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetDefaultPositions(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd]) -&gt; numpy.ndarray[object[m, 1]]</p></li>
</ol>
<p>Gets the default positions for the plant, which can be changed via
SetDefaultPositions().</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if the plant is not finalized.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>GetDefaultPositions(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; numpy.ndarray[object[m, 1]]</p></li>
</ol>
<p>Gets the default positions for the plant for a given model instance,
which can be changed via SetDefaultPositions().</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the plant is not finalized</strong><strong>, or </strong><strong>if the</strong> – </p></li>
<li><p><strong>model_instance is invalid</strong><strong>,</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetDistanceConstraintParams">
<span class="sig-name descname"><span class="pre">GetDistanceConstraintParams</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetDistanceConstraintParams" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetDistanceConstraintParams(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd]) -&gt; dict[pydrake.multibody.tree.MultibodyConstraintId, pydrake.multibody.plant.DistanceConstraintParams]</p></li>
</ol>
<p>Returns all distance constraint parameters currently stored in
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<ol class="arabic simple" start="2">
<li><p>GetDistanceConstraintParams(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], id: pydrake.multibody.tree.MultibodyConstraintId) -&gt; pydrake.multibody.plant.DistanceConstraintParams</p></li>
</ol>
<p>Returns a constant reference to the parameters for the distance
constraint that corresponds to identifier <code class="docutils literal notranslate"><span class="pre">id</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>if id is not a valid identifier for a distance constraint.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetEffortLowerLimits">
<span class="sig-name descname"><span class="pre">GetEffortLowerLimits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetEffortLowerLimits" title="Link to this definition"></a></dt>
<dd><p>Returns a vector of size <code class="docutils literal notranslate"><span class="pre">num_actuated_dofs()</span></code> containing the lower
effort limits for every actuator. Any unbounded or unspecified limits
will be -∞. The returned vector is indexed by JointActuatorIndex, see
JointActuator::index().</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>GetEffortUpperLimits()</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetEffortUpperLimits">
<span class="sig-name descname"><span class="pre">GetEffortUpperLimits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetEffortUpperLimits" title="Link to this definition"></a></dt>
<dd><p>Returns a vector of size <code class="docutils literal notranslate"><span class="pre">num_actuated_dofs()</span></code> containing the upper
effort limits for every actuator. Any unbounded or unspecified limits
will be +∞. The returned vector is indexed by JointActuatorIndex, see
JointActuator::index().</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>GetEffortLowerLimits()</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetFloatingBaseBodies">
<span class="sig-name descname"><span class="pre">GetFloatingBaseBodies</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">set</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.BodyIndex" title="pydrake.multibody.tree.BodyIndex"><span class="pre">pydrake.multibody.tree.BodyIndex</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetFloatingBaseBodies" title="Link to this definition"></a></dt>
<dd><p>Returns the set of body indices corresponding to the floating base
bodies in the model, in no particular order. See
mbp_working_with_free_bodies “above for details”.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize</strong><strong>, </strong><strong>see Finalize</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetFrameByName">
<span class="sig-name descname"><span class="pre">GetFrameByName</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetFrameByName" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetFrameByName(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], name: str) -&gt; pydrake.multibody.tree.Frame_[AutoDiffXd]</p></li>
</ol>
<p>Returns a constant reference to a frame that is identified by the
string <code class="docutils literal notranslate"><span class="pre">name</span></code> in <code class="docutils literal notranslate"><span class="pre">this</span></code> model.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if there is no frame with the requested name.</strong> – </p></li>
<li><p><strong>RuntimeError if the frame name occurs in multiple model instances.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>HasFrameNamed() to query if there exists a frame in <code class="docutils literal notranslate"><span class="pre">this</span></code> model
with a given specified name.</p>
</div>
<ol class="arabic simple" start="2">
<li><p>GetFrameByName(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; pydrake.multibody.tree.Frame_[AutoDiffXd]</p></li>
</ol>
<p>Returns a constant reference to the frame that is uniquely identified
by the string <code class="docutils literal notranslate"><span class="pre">name</span></code> in <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if there is no frame with the requested name.</strong> – </p></li>
<li><p><strong>RuntimeError if model_instance is not valid for this model.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>HasFrameNamed() to query if there exists a frame in <code class="docutils literal notranslate"><span class="pre">this</span></code> model
with a given specified name.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetFrameIndices">
<span class="sig-name descname"><span class="pre">GetFrameIndices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.FrameIndex" title="pydrake.multibody.tree.FrameIndex"><span class="pre">pydrake.multibody.tree.FrameIndex</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetFrameIndices" title="Link to this definition"></a></dt>
<dd><p>Returns a list of frame indices associated with <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetFreeBodyPose">
<span class="sig-name descname"><span class="pre">GetFreeBodyPose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.systems.framework.Context_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.RigidBody_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.math.RigidTransform_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetFreeBodyPose" title="Link to this definition"></a></dt>
<dd><p>For any free body’s 6-dof joint, gets the pose X_JpJc of the child
frame Jc in its parent frame Jp.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Unless <code class="docutils literal notranslate"><span class="pre">body</span></code> is a floating base body, the parent frame Jp is
not necessarily the World frame W, and the child frame Jc is not
necessarily the body frame B.</p>
</div>
<p>See mbp_working_with_free_bodies “above for details”.</p>
<dl class="simple">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">X_JpJc</span></code>:</dt><dd><p>The current pose of child frame Jc in its parent frame Jp. Returns
X_WB if <code class="docutils literal notranslate"><span class="pre">body</span></code> B is a floating base body.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if called pre-finalize.</strong> – </p></li>
<li><p><strong>RuntimeError if body is not a free body.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetJointActuatorByName">
<span class="sig-name descname"><span class="pre">GetJointActuatorByName</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetJointActuatorByName" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetJointActuatorByName(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], name: str) -&gt; pydrake.multibody.tree.JointActuator_[AutoDiffXd]</p></li>
</ol>
<p>Returns a constant reference to an actuator that is identified by the
string <code class="docutils literal notranslate"><span class="pre">name</span></code> in <code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if there is no actuator with the requested name.</strong> – </p></li>
<li><p><strong>RuntimeError if the actuator name occurs in multiple model</strong> – </p></li>
<li><p><strong>instances.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>HasJointActuatorNamed() to query if there exists an actuator in
<code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant with a given specified name.</p>
</div>
<ol class="arabic simple" start="2">
<li><p>GetJointActuatorByName(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; pydrake.multibody.tree.JointActuator_[AutoDiffXd]</p></li>
</ol>
<p>Returns a constant reference to the actuator that is uniquely
identified by the string <code class="docutils literal notranslate"><span class="pre">name</span></code> and <code class="docutils literal notranslate"><span class="pre">model_instance</span></code> in <code class="docutils literal notranslate"><span class="pre">this</span></code>
MultibodyPlant.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if there is no actuator with the requested name.</strong> – </p></li>
<li><p><strong>RuntimeError if model_instance is not valid for this model.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>HasJointActuatorNamed() to query if there exists an actuator in
<code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant with a given specified name.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetJointActuatorIndices">
<span class="sig-name descname"><span class="pre">GetJointActuatorIndices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetJointActuatorIndices" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetJointActuatorIndices(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd]) -&gt; list[pydrake.multibody.tree.JointActuatorIndex]</p></li>
</ol>
<p>Returns a list of all joint actuator indices. The vector is ordered by
monotonically increasing JointActuatorIndex, but the indices will in
general not be consecutive due to actuators that were removed.</p>
<ol class="arabic simple" start="2">
<li><p>GetJointActuatorIndices(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; list[pydrake.multibody.tree.JointActuatorIndex]</p></li>
</ol>
<p>Returns a list of joint actuator indices associated with
<code class="docutils literal notranslate"><span class="pre">model_instance</span></code>. The vector is ordered by monotonically increasing
JointActuatorIndex.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetJointByName">
<span class="sig-name descname"><span class="pre">GetJointByName</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.multibody.tree.Joint_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetJointByName" title="Link to this definition"></a></dt>
<dd><p>Returns a constant reference to a joint that is identified by the
string <code class="docutils literal notranslate"><span class="pre">name</span></code> in <code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant. If the optional template
argument is supplied, then the returned value is downcast to the
specified <code class="docutils literal notranslate"><span class="pre">JointType</span></code>.</p>
<dl class="simple">
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">JointType</span></code>:</dt><dd><p>The specific type of the Joint to be retrieved. It must be a
subclass of Joint.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the named joint is not</strong><strong> of </strong><strong>type JointType</strong><strong> or </strong><strong>if</strong> – </p></li>
<li><p><strong>there is no Joint with that name.</strong> – </p></li>
<li><p><strong>RuntimeError if model_instance is not valid for this model.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>HasJointNamed() to query if there exists a joint in <code class="docutils literal notranslate"><span class="pre">this</span></code>
MultibodyPlant with a given specified name.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetJointIndices">
<span class="sig-name descname"><span class="pre">GetJointIndices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetJointIndices" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetJointIndices(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd]) -&gt; list[pydrake.multibody.tree.JointIndex]</p></li>
</ol>
<p>Returns a list of all joint indices. The vector is ordered by
monotonically increasing JointIndex, but the indices will in general
not be consecutive due to joints that were removed.</p>
<ol class="arabic simple" start="2">
<li><p>GetJointIndices(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; list[pydrake.multibody.tree.JointIndex]</p></li>
</ol>
<p>Returns a list of joint indices associated with <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetModelInstanceByName">
<span class="sig-name descname"><span class="pre">GetModelInstanceByName</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetModelInstanceByName" title="Link to this definition"></a></dt>
<dd><p>Returns the index to the model instance that is uniquely identified by
the string <code class="docutils literal notranslate"><span class="pre">name</span></code> in <code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if there is no instance with the requested name.</strong> – </p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>HasModelInstanceNamed() to query if there exists an instance in
<code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant with a given specified name.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetModelInstanceName">
<span class="sig-name descname"><span class="pre">GetModelInstanceName</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">str</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetModelInstanceName" title="Link to this definition"></a></dt>
<dd><p>Returns the name of a <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError when model_instance does not correspond to a</strong> – </p></li>
<li><p><strong>model in this model.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetMutableJointByName">
<span class="sig-name descname"><span class="pre">GetMutableJointByName</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.multibody.tree.Joint_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetMutableJointByName" title="Link to this definition"></a></dt>
<dd><p>Returns a constant reference to a joint that is identified by the
string <code class="docutils literal notranslate"><span class="pre">name</span></code> in <code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant. If the optional template
argument is supplied, then the returned value is downcast to the
specified <code class="docutils literal notranslate"><span class="pre">JointType</span></code>.</p>
<dl class="simple">
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">JointType</span></code>:</dt><dd><p>The specific type of the Joint to be retrieved. It must be a
subclass of Joint.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the named joint is not</strong><strong> of </strong><strong>type JointType</strong><strong> or </strong><strong>if</strong> – </p></li>
<li><p><strong>there is no Joint with that name.</strong> – </p></li>
<li><p><strong>RuntimeError if model_instance is not valid for this model.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>HasJointNamed() to query if there exists a joint in <code class="docutils literal notranslate"><span class="pre">this</span></code>
MultibodyPlant with a given specified name.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetPositionLowerLimits">
<span class="sig-name descname"><span class="pre">GetPositionLowerLimits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetPositionLowerLimits" title="Link to this definition"></a></dt>
<dd><p>Returns a vector of size <code class="docutils literal notranslate"><span class="pre">num_positions()</span></code> containing the lower
position limits for every generalized position coordinate. These
include joint and free body coordinates. Any unbounded or unspecified
limits will be -infinity.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetPositionNames">
<span class="sig-name descname"><span class="pre">GetPositionNames</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetPositionNames" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetPositionNames(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], add_model_instance_prefix: bool = True, always_add_suffix: bool = True) -&gt; list[str]</p></li>
</ol>
<p>Returns a list of string names corresponding to each element of the
position vector. These strings take the form
<code class="docutils literal notranslate"><span class="pre">{model_instance_name}_{joint_name}_{joint_position_suffix}</span></code>, but
the prefix and suffix may optionally be withheld using
<code class="docutils literal notranslate"><span class="pre">add_model_instance_prefix</span></code> and <code class="docutils literal notranslate"><span class="pre">always_add_suffix</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">always_add_suffix</span></code>:</dt><dd><p>(optional). If true, then the suffix is always added. If false,
then the suffix is only added for joints that have more than one
position (in this case, not adding would lead to ambiguity).</p>
</dd>
</dl>
<p>The returned names are guaranteed to be unique if
<code class="docutils literal notranslate"><span class="pre">add_model_instance_prefix</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code> (the default).</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if the plant is not finalized.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>GetPositionNames(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], model_instance: pydrake.multibody.tree.ModelInstanceIndex, add_model_instance_prefix: bool = False, always_add_suffix: bool = True) -&gt; list[str]</p></li>
</ol>
<p>Returns a list of string names corresponding to each element of the
position vector. These strings take the form
<code class="docutils literal notranslate"><span class="pre">{model_instance_name}_{joint_name}_{joint_position_suffix}</span></code>, but
the prefix and suffix may optionally be withheld using
<code class="docutils literal notranslate"><span class="pre">add_model_instance_prefix</span></code> and <code class="docutils literal notranslate"><span class="pre">always_add_suffix</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">always_add_suffix</span></code>:</dt><dd><p>(optional). If true, then the suffix is always added. If false,
then the suffix is only added for joints that have more than one
position (in this case, not adding would lead to ambiguity).</p>
</dd>
</dl>
<p>The returned names are guaranteed to be unique.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the plant is not finalized</strong><strong> or </strong><strong>if the</strong> – </p></li>
<li><p><strong>model_instance` is invalid</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetPositions">
<span class="sig-name descname"><span class="pre">GetPositions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetPositions" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetPositions(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd]) -&gt; numpy.ndarray[object[m, 1]]</p></li>
</ol>
<p>Returns a const vector reference to the vector of generalized
positions q in a given Context.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method returns a reference to existing data, exhibits
constant i.e., O(1) time complexity, and runs very quickly.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if context does not correspond to the Context for</strong> – </p></li>
<li><p><strong>a multibody model.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>GetPositions(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; numpy.ndarray[object[m, 1]]</p></li>
</ol>
<p>Returns a vector containing the generalized positions q of a specified
model instance in a given Context.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Returns a dense vector of dimension
<code class="docutils literal notranslate"><span class="pre">num_positions(model_instance)</span></code> associated with
<code class="docutils literal notranslate"><span class="pre">model_instance</span></code> by copying from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if context does not correspond to the Context for</strong> – </p></li>
<li><p><strong>a multibody model</strong><strong> or </strong><strong>model_instance is invalid.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetPositionsAndVelocities">
<span class="sig-name descname"><span class="pre">GetPositionsAndVelocities</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetPositionsAndVelocities" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetPositionsAndVelocities(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd]) -&gt; numpy.ndarray[object[m, 1]]</p></li>
</ol>
<p>Returns a const vector reference <code class="docutils literal notranslate"><span class="pre">[q;</span> <span class="pre">v]</span></code> to the generalized
positions q and generalized velocities v in a given Context.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method returns a reference to existing data, exhibits
constant i.e., O(1) time complexity, and runs very quickly.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if context does not correspond to the Context for</strong> – </p></li>
<li><p><strong>a multibody model.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>GetPositionsAndVelocities(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; numpy.ndarray[object[m, 1]]</p></li>
</ol>
<p>Returns a vector <code class="docutils literal notranslate"><span class="pre">[q;</span> <span class="pre">v]</span></code> containing the generalized positions q and
generalized velocities v of a specified model instance in a given
Context.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Returns a dense vector of dimension
<code class="docutils literal notranslate"><span class="pre">num_positions(model_instance)</span> <span class="pre">+</span> <span class="pre">num_velocities(model_instance)</span></code>
associated with <code class="docutils literal notranslate"><span class="pre">model_instance</span></code> by copying from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if context does not correspond to the Context for</strong> – </p></li>
<li><p><strong>a multibody model</strong><strong> or </strong><strong>model_instance is invalid.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetPositionsFromArray">
<span class="sig-name descname"><span class="pre">GetPositionsFromArray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetPositionsFromArray" title="Link to this definition"></a></dt>
<dd><p>Returns a vector of generalized positions for <code class="docutils literal notranslate"><span class="pre">model_instance</span></code> from
a vector <code class="docutils literal notranslate"><span class="pre">q_array</span></code> of generalized positions for the entire model
model. This method throws an exception if <code class="docutils literal notranslate"><span class="pre">q</span></code> is not of size
MultibodyPlant::num_positions().</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetPositionUpperLimits">
<span class="sig-name descname"><span class="pre">GetPositionUpperLimits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetPositionUpperLimits" title="Link to this definition"></a></dt>
<dd><p>Upper limit analog of GetPositionLowerLimits(), where any unbounded or
unspecified limits will be +infinity.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>GetPositionLowerLimits() for more information.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetRigidBodyByName">
<span class="sig-name descname"><span class="pre">GetRigidBodyByName</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetRigidBodyByName" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetRigidBodyByName(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], name: str) -&gt; pydrake.multibody.tree.RigidBody_[AutoDiffXd]</p></li>
</ol>
<p>Returns a constant reference to a rigid body that is identified by the
string <code class="docutils literal notranslate"><span class="pre">name</span></code> in <code class="docutils literal notranslate"><span class="pre">this</span></code> model.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if there is no body with the requested name.</strong> – </p></li>
<li><p><strong>RuntimeError if the body name occurs in multiple model instances.</strong> – </p></li>
<li><p><strong>RuntimeError if the requested body is not a RigidBody.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>HasBodyNamed() to query if there exists a body in <code class="docutils literal notranslate"><span class="pre">this</span></code> model
with a given specified name.</p>
</div>
<ol class="arabic simple" start="2">
<li><p>GetRigidBodyByName(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; pydrake.multibody.tree.RigidBody_[AutoDiffXd]</p></li>
</ol>
<p>Returns a constant reference to the rigid body that is uniquely
identified by the string <code class="docutils literal notranslate"><span class="pre">name</span></code> in <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if there is no body with the requested name.</strong> – </p></li>
<li><p><strong>RuntimeError if the requested body is not a RigidBody.</strong> – </p></li>
<li><p><strong>RuntimeError if model_instance is not valid for this model.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>HasBodyNamed() to query if there exists a body in <code class="docutils literal notranslate"><span class="pre">this</span></code> model
with a given specified name.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetStateNames">
<span class="sig-name descname"><span class="pre">GetStateNames</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetStateNames" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetStateNames(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], add_model_instance_prefix: bool = True) -&gt; list[str]</p></li>
</ol>
<p>Returns a list of string names corresponding to each element of the
multibody state vector. These strings take the form
<code class="docutils literal notranslate"><span class="pre">{model_instance_name}_{joint_name}_{joint_position_suffix</span> <span class="pre">|</span>
<span class="pre">joint_velocity_suffix}</span></code>, but the prefix may optionally be withheld
using <code class="docutils literal notranslate"><span class="pre">add_model_instance_prefix</span></code>.</p>
<p>The returned names are guaranteed to be unique if
<code class="docutils literal notranslate"><span class="pre">add_model_instance_prefix</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code> (the default).</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if the plant is not finalized.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>GetStateNames(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], model_instance: pydrake.multibody.tree.ModelInstanceIndex, add_model_instance_prefix: bool = False) -&gt; list[str]</p></li>
</ol>
<p>Returns a list of string names corresponding to each element of the
multibody state vector. These strings take the form
<code class="docutils literal notranslate"><span class="pre">{model_instance_name}_{joint_name}_{joint_position_suffix</span> <span class="pre">|</span>
<span class="pre">joint_velocity_suffix}</span></code>, but the prefix may optionally be withheld
using <code class="docutils literal notranslate"><span class="pre">add_model_instance_prefix</span></code>.</p>
<p>The returned names are guaranteed to be unique.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the plant is not finalized</strong><strong> or </strong><strong>if the</strong> – </p></li>
<li><p><strong>model_instance` is invalid</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetTopologyGraphvizString">
<span class="sig-name descname"><span class="pre">GetTopologyGraphvizString</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">str</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetTopologyGraphvizString" title="Link to this definition"></a></dt>
<dd><p>Returns a Graphviz string describing the topology of this plant. To
render the string, use the Graphviz tool, <code class="docutils literal notranslate"><span class="pre">dot</span></code>.
<a class="reference external" href="http://www.graphviz.org/">http://www.graphviz.org/</a></p>
<p>Note: this method can be called either before or after <code class="docutils literal notranslate"><span class="pre">Finalize()</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetUniqueFloatingBaseBodyOrThrow">
<span class="sig-name descname"><span class="pre">GetUniqueFloatingBaseBodyOrThrow</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.multibody.tree.RigidBody_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetUniqueFloatingBaseBodyOrThrow" title="Link to this definition"></a></dt>
<dd><p>If there is a single base body in the model given by
<code class="docutils literal notranslate"><span class="pre">model_instance</span></code>, and that body is a floating base body, returns
that floating base body. Otherwise, throws an exception. Use
HasUniqueFloatingBaseBody() to check first.</p>
<p>See mbp_working_with_free_bodies “above for details”.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if called pre-finalize.</strong> – </p></li>
<li><p><strong>RuntimeError if model_instance is not valid.</strong> – </p></li>
<li><p><strong>RuntimeError if !HasUniqueFloatingBaseBody</strong><strong>(</strong><strong>model_instance</strong><strong>)</strong><strong>.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>HasUniqueFloatingBaseBody(), GetFloatingBaseBodies()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetUniqueFreeBaseBodyOrThrow">
<span class="sig-name descname"><span class="pre">GetUniqueFreeBaseBodyOrThrow</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.multibody.tree.RigidBody_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetUniqueFreeBaseBodyOrThrow" title="Link to this definition"></a></dt>
<dd><p>(Deprecated.)</p>
<dl class="simple">
<dt>Deprecated:</dt><dd><p>Use GetUniqueFloatingBaseBodyOrThrow() instead. This will be
removed from Drake on or after 2026-06-01.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetVelocities">
<span class="sig-name descname"><span class="pre">GetVelocities</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetVelocities" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetVelocities(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd]) -&gt; numpy.ndarray[object[m, 1]]</p></li>
</ol>
<p>Returns a const vector reference to the generalized velocities v in a
given Context.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method returns a reference to existing data, exhibits
constant i.e., O(1) time complexity, and runs very quickly.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if context does not correspond to the Context for</strong> – </p></li>
<li><p><strong>a multibody model.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>GetVelocities(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; numpy.ndarray[object[m, 1]]</p></li>
</ol>
<p>Returns a vector containing the generalized velocities v of a
specified model instance in a given Context.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>returns a dense vector of dimension
<code class="docutils literal notranslate"><span class="pre">num_velocities(model_instance)</span></code> associated with
<code class="docutils literal notranslate"><span class="pre">model_instance</span></code> by copying from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if context does not correspond to the Context for</strong> – </p></li>
<li><p><strong>a multibody model</strong><strong> or </strong><strong>model_instance is invalid.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetVelocitiesFromArray">
<span class="sig-name descname"><span class="pre">GetVelocitiesFromArray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetVelocitiesFromArray" title="Link to this definition"></a></dt>
<dd><p>Returns a vector of generalized velocities for <code class="docutils literal notranslate"><span class="pre">model_instance</span></code> from
a vector <code class="docutils literal notranslate"><span class="pre">v</span></code> of generalized velocities for the entire MultibodyPlant
model. This method throws an exception if the input array is not of
size MultibodyPlant::num_velocities().</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetVelocityLowerLimits">
<span class="sig-name descname"><span class="pre">GetVelocityLowerLimits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetVelocityLowerLimits" title="Link to this definition"></a></dt>
<dd><p>Returns a vector of size <code class="docutils literal notranslate"><span class="pre">num_velocities()</span></code> containing the lower
velocity limits for every generalized velocity coordinate. These
include joint and free body coordinates. Any unbounded or unspecified
limits will be -infinity.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetVelocityNames">
<span class="sig-name descname"><span class="pre">GetVelocityNames</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetVelocityNames" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetVelocityNames(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], add_model_instance_prefix: bool = True, always_add_suffix: bool = True) -&gt; list[str]</p></li>
</ol>
<p>Returns a list of string names corresponding to each element of the
velocity vector. These strings take the form
<code class="docutils literal notranslate"><span class="pre">{model_instance_name}_{joint_name}_{joint_velocity_suffix}</span></code>, but
the prefix and suffix may optionally be withheld using
<code class="docutils literal notranslate"><span class="pre">add_model_instance_prefix</span></code> and <code class="docutils literal notranslate"><span class="pre">always_add_suffix</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">always_add_suffix</span></code>:</dt><dd><p>(optional). If true, then the suffix is always added. If false,
then the suffix is only added for joints that have more than one
position (in this case, not adding would lead to ambiguity).</p>
</dd>
</dl>
<p>The returned names are guaranteed to be unique if
<code class="docutils literal notranslate"><span class="pre">add_model_instance_prefix</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code> (the default).</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if the plant is not finalized.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>GetVelocityNames(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], model_instance: pydrake.multibody.tree.ModelInstanceIndex, add_model_instance_prefix: bool = False, always_add_suffix: bool = True) -&gt; list[str]</p></li>
</ol>
<p>Returns a list of string names corresponding to each element of the
velocity vector. These strings take the form
<code class="docutils literal notranslate"><span class="pre">{model_instance_name}_{joint_name}_{joint_velocity_suffix}</span></code>, but
the prefix and suffix may optionally be withheld using
<code class="docutils literal notranslate"><span class="pre">add_model_instance_prefix</span></code> and <code class="docutils literal notranslate"><span class="pre">always_add_suffix</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">always_add_suffix</span></code>:</dt><dd><p>(optional). If true, then the suffix is always added. If false,
then the suffix is only added for joints that have more than one
position (in this case, not adding would lead to ambiguity).</p>
</dd>
</dl>
<p>The returned names are guaranteed to be unique.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the plant is not finalized</strong><strong> or </strong><strong>if the</strong> – </p></li>
<li><p><strong>model_instance` is invalid</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetVelocityUpperLimits">
<span class="sig-name descname"><span class="pre">GetVelocityUpperLimits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetVelocityUpperLimits" title="Link to this definition"></a></dt>
<dd><p>Upper limit analog of GetVelocitysLowerLimits(), where any unbounded
or unspecified limits will be +infinity.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>GetVelocityLowerLimits() for more information.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetVisualGeometriesForBody">
<span class="sig-name descname"><span class="pre">GetVisualGeometriesForBody</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.RigidBody_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.GeometryId" title="pydrake.geometry.GeometryId"><span class="pre">pydrake.geometry.GeometryId</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetVisualGeometriesForBody" title="Link to this definition"></a></dt>
<dd><p>Returns an array of GeometryId’s identifying the different visual
geometries for <code class="docutils literal notranslate"><span class="pre">body</span></code> previously registered with a SceneGraph.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method can be called at any time during the lifetime of
<code class="docutils literal notranslate"><span class="pre">this</span></code> plant, either pre- or post-finalize, see Finalize().
Post-finalize calls will always return the same value.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>RegisterVisualGeometry(), Finalize()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.gravity_field">
<span class="sig-name descname"><span class="pre">gravity_field</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.multibody.tree.UniformGravityFieldElement_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.gravity_field" title="Link to this definition"></a></dt>
<dd><p>An accessor to the current gravity field.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.has_joint">
<span class="sig-name descname"><span class="pre">has_joint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">joint_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JointIndex" title="pydrake.multibody.tree.JointIndex"><span class="pre">pydrake.multibody.tree.JointIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.has_joint" title="Link to this definition"></a></dt>
<dd><p>Returns true if plant has a joint with unique index <code class="docutils literal notranslate"><span class="pre">joint_index</span></code>.
The value could be false if the joint was removed using RemoveJoint().</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.has_joint_actuator">
<span class="sig-name descname"><span class="pre">has_joint_actuator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">actuator_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JointActuatorIndex" title="pydrake.multibody.tree.JointActuatorIndex"><span class="pre">pydrake.multibody.tree.JointActuatorIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.has_joint_actuator" title="Link to this definition"></a></dt>
<dd><p>Returns true if plant has a joint actuator with unique index
<code class="docutils literal notranslate"><span class="pre">actuator_index</span></code>. The value could be false if the actuator was
removed using RemoveJointActuator().</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.has_sampled_output_ports">
<span class="sig-name descname"><span class="pre">has_sampled_output_ports</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.has_sampled_output_ports" title="Link to this definition"></a></dt>
<dd><p>(Advanced) If <code class="docutils literal notranslate"><span class="pre">this</span></code> plant is continuous (i.e., is_discrete() is
<code class="docutils literal notranslate"><span class="pre">False</span></code>), returns false. If <code class="docutils literal notranslate"><span class="pre">this</span></code> plant is discrete, returns
whether or not the output ports are sampled (change only at a time
step boundary) or live (instantaneously reflect changes to the input
ports). See output_port_sampling “Output port sampling” for details.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.HasBodyNamed">
<span class="sig-name descname"><span class="pre">HasBodyNamed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.HasBodyNamed" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>HasBodyNamed(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], name: str) -&gt; bool</p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if a body named <code class="docutils literal notranslate"><span class="pre">name</span></code> was added to the MultibodyPlant.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddRigidBody().</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if the body name occurs in multiple model instances.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>HasBodyNamed(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; bool</p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if a body named <code class="docutils literal notranslate"><span class="pre">name</span></code> was added to the MultibodyPlant
in <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddRigidBody().</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if model_instance is not valid for this model.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.HasFrameNamed">
<span class="sig-name descname"><span class="pre">HasFrameNamed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.HasFrameNamed" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>HasFrameNamed(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], name: str) -&gt; bool</p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if a frame named <code class="docutils literal notranslate"><span class="pre">name</span></code> was added to the model.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddFrame().</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if the frame name occurs in multiple model instances.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>HasFrameNamed(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; bool</p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if a frame named <code class="docutils literal notranslate"><span class="pre">name</span></code> was added to
<code class="docutils literal notranslate"><span class="pre">model_instance</span></code>.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddFrame().</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if model_instance is not valid for this model.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.HasJointActuatorNamed">
<span class="sig-name descname"><span class="pre">HasJointActuatorNamed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.HasJointActuatorNamed" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>HasJointActuatorNamed(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], name: str) -&gt; bool</p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if an actuator named <code class="docutils literal notranslate"><span class="pre">name</span></code> was added to this model.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddJointActuator().</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the actuator name occurs in multiple model</strong> – </p></li>
<li><p><strong>instances.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>HasJointActuatorNamed(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; bool</p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if an actuator named <code class="docutils literal notranslate"><span class="pre">name</span></code> was added to
<code class="docutils literal notranslate"><span class="pre">model_instance</span></code>.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddJointActuator().</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if model_instance is not valid for this model.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.HasJointNamed">
<span class="sig-name descname"><span class="pre">HasJointNamed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.HasJointNamed" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>HasJointNamed(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], name: str) -&gt; bool</p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if a joint named <code class="docutils literal notranslate"><span class="pre">name</span></code> was added to this model.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddJoint().</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if the joint name occurs in multiple model instances.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>HasJointNamed(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; bool</p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if a joint named <code class="docutils literal notranslate"><span class="pre">name</span></code> was added to
<code class="docutils literal notranslate"><span class="pre">model_instance</span></code>.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddJoint().</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if model_instance is not valid for this model.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.HasModelInstanceNamed">
<span class="sig-name descname"><span class="pre">HasModelInstanceNamed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.HasModelInstanceNamed" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if a model instance named <code class="docutils literal notranslate"><span class="pre">name</span></code> was added to this
model.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddModelInstance().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.HasUniqueFloatingBaseBody">
<span class="sig-name descname"><span class="pre">HasUniqueFloatingBaseBody</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.HasUniqueFloatingBaseBody" title="Link to this definition"></a></dt>
<dd><p>Returns true if there is a single base body in the model given by
<code class="docutils literal notranslate"><span class="pre">model_instance</span></code>, and that body is a floating base body.</p>
<p>See mbp_working_with_free_bodies “above for details”.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if called pre-finalize.</strong> – </p></li>
<li><p><strong>RuntimeError if model_instance is not valid.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>GetUniqueFloatingBaseBodyOrThrow()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.HasUniqueFreeBaseBody">
<span class="sig-name descname"><span class="pre">HasUniqueFreeBaseBody</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.HasUniqueFreeBaseBody" title="Link to this definition"></a></dt>
<dd><p>(Deprecated.)</p>
<dl class="simple">
<dt>Deprecated:</dt><dd><p>Use HasUniqueFloatingBaseBody() instead. This will be removed from
Drake on or after 2026-06-01.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.is_finalized">
<span class="sig-name descname"><span class="pre">is_finalized</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.is_finalized" title="Link to this definition"></a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if this MultibodyPlant was finalized with a call to
Finalize().</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>Finalize().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.is_gravity_enabled">
<span class="sig-name descname"><span class="pre">is_gravity_enabled</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.is_gravity_enabled" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> iff gravity is enabled for <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>set_gravity_enabled().</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if the model instance is invalid.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.IsAnchored">
<span class="sig-name descname"><span class="pre">IsAnchored</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.RigidBody_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.IsAnchored" title="Link to this definition"></a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if <code class="docutils literal notranslate"><span class="pre">body</span></code> is anchored (i.e. the kinematic path
between <code class="docutils literal notranslate"><span class="pre">body</span></code> and the world only contains weld joints.)</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.IsVelocityEqualToQDot">
<span class="sig-name descname"><span class="pre">IsVelocityEqualToQDot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.IsVelocityEqualToQDot" title="Link to this definition"></a></dt>
<dd><p>Returns true iff the generalized velocity v is exactly the time
derivative q̇ of the generalized coordinates q. In this case
MapQDotToVelocity() and MapVelocityToQDot() implement the identity
map. This method is, in the worst case, O(n), where n is the number of
joints.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.MakeActuationMatrix">
<span class="sig-name descname"><span class="pre">MakeActuationMatrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.MakeActuationMatrix" title="Link to this definition"></a></dt>
<dd><p>This method creates an actuation matrix B mapping a vector of
actuation values u into generalized forces <code class="docutils literal notranslate"><span class="pre">tau_u</span> <span class="pre">=</span> <span class="pre">B</span> <span class="pre">*</span> <span class="pre">u</span></code>, where B
is a matrix of size <code class="docutils literal notranslate"><span class="pre">nv</span> <span class="pre">x</span> <span class="pre">nu</span></code> with <code class="docutils literal notranslate"><span class="pre">nu</span></code> equal to
num_actuated_dofs() and <code class="docutils literal notranslate"><span class="pre">nv</span></code> equal to num_velocities(). The vector u
of actuation values is of size num_actuated_dofs(). For a given
JointActuator, <code class="docutils literal notranslate"><span class="pre">u[JointActuator::input_start()]</span></code> stores the value
for the external actuation corresponding to that actuator. <code class="docutils literal notranslate"><span class="pre">tau_u</span></code>
on the other hand is indexed by generalized velocity indices according
to <code class="docutils literal notranslate"><span class="pre">Joint::velocity_start()</span></code>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>B is a permutation matrix. While making a permutation has <code class="docutils literal notranslate"><span class="pre">O(n)</span></code>
complexity, making a full B matrix has <code class="docutils literal notranslate"><span class="pre">O(n²)</span></code> complexity. For
most applications this cost can be neglected but it could become
significant for very large systems.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.MakeActuationMatrixPseudoinverse">
<span class="sig-name descname"><span class="pre">MakeActuationMatrixPseudoinverse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">scipy.sparse.csc_matrix</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.MakeActuationMatrixPseudoinverse" title="Link to this definition"></a></dt>
<dd><p>Creates the pseudoinverse of the actuation matrix B directly (without
requiring an explicit inverse calculation). See MakeActuationMatrix().</p>
<p>Notably, when B is full row rank (the system is fully actuated), then
the pseudoinverse is a true inverse.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.MakeActuatorSelectorMatrix">
<span class="sig-name descname"><span class="pre">MakeActuatorSelectorMatrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.MakeActuatorSelectorMatrix" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>MakeActuatorSelectorMatrix(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], user_to_actuator_index_map: list[pydrake.multibody.tree.JointActuatorIndex]) -&gt; numpy.ndarray[numpy.float64[m, n]]</p></li>
</ol>
<p>This method allows user to map a vector <code class="docutils literal notranslate"><span class="pre">uₛ</span></code> containing the
actuation for a set of selected actuators into the vector u containing
the actuation values for <code class="docutils literal notranslate"><span class="pre">this</span></code> full model. The mapping, or
selection, is returned in the form of a selector matrix Su such that
<code class="docutils literal notranslate"><span class="pre">u</span> <span class="pre">=</span> <span class="pre">Su⋅uₛ</span></code>. The size nₛ of uₛ is always smaller or equal than the
size of the full vector of actuation values u. That is, a user might
be interested in only a given subset of actuators in the model.</p>
<p>This selection matrix is particularly useful when adding PID control
on a portion of the state, see systems::controllers::PidController.</p>
<p>A user specifies the preferred order in uₛ via
<code class="docutils literal notranslate"><span class="pre">user_to_actuator_index_map</span></code>. The actuation values in uₛ are a
concatenation of the values for each actuator in the order they appear
in <code class="docutils literal notranslate"><span class="pre">user_to_actuator_index_map</span></code>. The actuation value in the full
vector of actuation values <code class="docutils literal notranslate"><span class="pre">u</span></code> for a particular actuator can be
found at offset JointActuator::input_start().</p>
<ol class="arabic simple" start="2">
<li><p>MakeActuatorSelectorMatrix(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], user_to_joint_index_map: list[pydrake.multibody.tree.JointIndex]) -&gt; numpy.ndarray[numpy.float64[m, n]]</p></li>
</ol>
<p>Alternative signature to build an actuation selector matrix <code class="docutils literal notranslate"><span class="pre">Su</span></code>
such that <code class="docutils literal notranslate"><span class="pre">u</span> <span class="pre">=</span> <span class="pre">Su⋅uₛ</span></code>, where u is the vector of actuation values for
the full model (see get_actuation_input_port()) and uₛ is a vector of
actuation values for the actuators acting on the joints listed by
<code class="docutils literal notranslate"><span class="pre">user_to_joint_index_map</span></code>. It is assumed that all joints referenced
by <code class="docutils literal notranslate"><span class="pre">user_to_joint_index_map</span></code> are actuated. See
MakeActuatorSelectorMatrix(const std::vector&lt;JointActuatorIndex&gt;&amp;) for
details.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if any</strong><strong> of </strong><strong>the joints in user_to_joint_index_map</strong> – </p></li>
<li><p><strong>does not have an actuator.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.MakeStateSelectorMatrix">
<span class="sig-name descname"><span class="pre">MakeStateSelectorMatrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">user_to_joint_index_map</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JointIndex" title="pydrake.multibody.tree.JointIndex"><span class="pre">pydrake.multibody.tree.JointIndex</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.MakeStateSelectorMatrix" title="Link to this definition"></a></dt>
<dd><p>This method allows users to map the state of <code class="docutils literal notranslate"><span class="pre">this</span></code> model, x, into a
vector of selected state xₛ with a given preferred ordering. The
mapping, or selection, is returned in the form of a selector matrix Sx
such that <code class="docutils literal notranslate"><span class="pre">xₛ</span> <span class="pre">=</span> <span class="pre">Sx⋅x</span></code>. The size nₛ of xₛ is always smaller or equal
than the size of the full state x. That is, a user might be interested
in only a given portion of the full state x.</p>
<p>This selection matrix is particularly useful when adding PID control
on a portion of the state, see systems::controllers::PidController.</p>
<p>A user specifies the preferred order in xₛ via
<code class="docutils literal notranslate"><span class="pre">user_to_joint_index_map</span></code>. The selected state is built such that
selected positions are followed by selected velocities, as in <code class="docutils literal notranslate"><span class="pre">xₛ</span> <span class="pre">=</span>
<span class="pre">[qₛ,</span> <span class="pre">vₛ]</span></code>. The positions in qₛ are a concatenation of the positions
for each joint in the order they appear in
<code class="docutils literal notranslate"><span class="pre">user_to_joint_index_map</span></code>. That is, the positions for
<code class="docutils literal notranslate"><span class="pre">user_to_joint_index_map[0]</span></code> are first, followed by the positions
for <code class="docutils literal notranslate"><span class="pre">user_to_joint_index_map[1]</span></code>, etc. Similarly for the selected
velocities vₛ.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if there are repeated indices in</strong> – </p></li>
<li><p><strong>user_to_joint_index_map`</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.MapQDotToVelocity">
<span class="sig-name descname"><span class="pre">MapQDotToVelocity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.systems.framework.Context_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qdot</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.MapQDotToVelocity" title="Link to this definition"></a></dt>
<dd><p>Transforms the time derivative <code class="docutils literal notranslate"><span class="pre">qdot</span></code> of the generalized positions
vector <code class="docutils literal notranslate"><span class="pre">q</span></code> (stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>) to generalized velocities <code class="docutils literal notranslate"><span class="pre">v</span></code>.
<cite>v</cite> and <code class="docutils literal notranslate"><span class="pre">q̇</span></code> are related linearly by <code class="docutils literal notranslate"><span class="pre">q̇</span> <span class="pre">=</span> <span class="pre">N(q)⋅v</span></code>. Although
<code class="docutils literal notranslate"><span class="pre">N(q)</span></code> is not necessarily square, its left pseudo-inverse <code class="docutils literal notranslate"><span class="pre">N⁺(q)</span></code>
can be used to invert that relationship without residual error,
provided that <code class="docutils literal notranslate"><span class="pre">qdot</span></code> is in the range space of <code class="docutils literal notranslate"><span class="pre">N(q)</span></code> (that is, if
it <em>could</em> have been produced as <code class="docutils literal notranslate"><span class="pre">q̇</span> <span class="pre">=</span> <span class="pre">N(q)⋅v</span></code> for some <code class="docutils literal notranslate"><span class="pre">v</span></code>).
Using the configuration <code class="docutils literal notranslate"><span class="pre">q</span></code> stored in the given <code class="docutils literal notranslate"><span class="pre">context</span></code> this
method calculates <code class="docutils literal notranslate"><span class="pre">v</span> <span class="pre">=</span> <span class="pre">N⁺(q)⋅q̇</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context containing the state of the model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">qdot</span></code>:</dt><dd><p>A vector containing the time derivatives of the generalized
positions. This method aborts if <code class="docutils literal notranslate"><span class="pre">qdot</span></code> is not of size
num_positions().</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">v</span></code>:</dt><dd><p>A valid (non-null) pointer to a vector in <code class="docutils literal notranslate"><span class="pre">ℛⁿ</span></code> with n the number
of generalized velocities. This method aborts if v is nullptr or
if it is not of size num_velocities().</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>MapVelocityToQDot()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>Mobilizer::MapQDotToVelocity()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.MapVelocityToQDot">
<span class="sig-name descname"><span class="pre">MapVelocityToQDot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.systems.framework.Context_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.MapVelocityToQDot" title="Link to this definition"></a></dt>
<dd><p>Transforms generalized velocities v to time derivatives <code class="docutils literal notranslate"><span class="pre">qdot</span></code> of
the generalized positions vector <code class="docutils literal notranslate"><span class="pre">q</span></code> (stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>). <cite>v</cite>
and <code class="docutils literal notranslate"><span class="pre">qdot</span></code> are related linearly by <code class="docutils literal notranslate"><span class="pre">q̇</span> <span class="pre">=</span> <span class="pre">N(q)⋅v</span></code>. Using the
configuration <code class="docutils literal notranslate"><span class="pre">q</span></code> stored in the given <code class="docutils literal notranslate"><span class="pre">context</span></code> this method
calculates <code class="docutils literal notranslate"><span class="pre">q̇</span> <span class="pre">=</span> <span class="pre">N(q)⋅v</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context containing the state of the model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">v</span></code>:</dt><dd><p>A vector of generalized velocities for this model. This method
aborts if v is not of size num_velocities().</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">qdot</span></code>:</dt><dd><p>A valid (non-null) pointer to a vector in <code class="docutils literal notranslate"><span class="pre">ℝⁿ</span></code> with n being the
number of generalized positions in this model, given by
<code class="docutils literal notranslate"><span class="pre">num_positions()</span></code>. This method aborts if <code class="docutils literal notranslate"><span class="pre">qdot</span></code> is nullptr or
if it is not of size num_positions().</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>MapQDotToVelocity()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>Mobilizer::MapVelocityToQDot()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.mutable_deformable_model">
<span class="sig-name descname"><span class="pre">mutable_deformable_model</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">drake::multibody::DeformableModel&lt;Eigen::AutoDiffScalar&lt;Eigen::Matrix&lt;double,</span> <span class="pre">-1,</span> <span class="pre">1,</span> <span class="pre">0,</span> <span class="pre">-1,</span> <span class="pre">1&gt;</span> <span class="pre">&gt;</span> <span class="pre">&gt;</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.mutable_deformable_model" title="Link to this definition"></a></dt>
<dd><p>Returns a mutable reference to the DeformableModel owned by this
plant.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if the plant is finalized.</strong> – </p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This feature is considered to be <strong>experimental</strong> and may change
or be removed at any time, without any deprecation notice ahead of
time.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.mutable_gravity_field">
<span class="sig-name descname"><span class="pre">mutable_gravity_field</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.multibody.tree.UniformGravityFieldElement_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.mutable_gravity_field" title="Link to this definition"></a></dt>
<dd><p>A mutable accessor to the current gravity field.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.num_actuated_dofs">
<span class="sig-name descname"><span class="pre">num_actuated_dofs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.num_actuated_dofs" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>num_actuated_dofs(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd]) -&gt; int</p></li>
</ol>
<p>Returns the total number of actuated degrees of freedom. That is, the
vector of actuation values u has this size. See AddJointActuator().</p>
<ol class="arabic simple" start="2">
<li><p>num_actuated_dofs(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; int</p></li>
</ol>
<p>Returns the total number of actuated degrees of freedom for a specific
model instance. That is, the vector of actuation values u has this
size. See AddJointActuator().</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.num_actuators">
<span class="sig-name descname"><span class="pre">num_actuators</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.num_actuators" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>num_actuators(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd]) -&gt; int</p></li>
</ol>
<p>Returns the number of joint actuators in the model.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddJointActuator().</p>
</div>
<ol class="arabic simple" start="2">
<li><p>num_actuators(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; int</p></li>
</ol>
<p>Returns the number of actuators for a specific model instance.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.num_bodies">
<span class="sig-name descname"><span class="pre">num_bodies</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.num_bodies" title="Link to this definition"></a></dt>
<dd><p>Returns the number of RigidBody elements in the model, including the
“world” RigidBody, which is always part of the model.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddRigidBody().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.num_collision_geometries">
<span class="sig-name descname"><span class="pre">num_collision_geometries</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.num_collision_geometries" title="Link to this definition"></a></dt>
<dd><p>Returns the number of geometries registered for contact modeling. This
method can be called at any time during the lifetime of <code class="docutils literal notranslate"><span class="pre">this</span></code>
plant, either pre- or post-finalize, see Finalize(). Post-finalize
calls will always return the same value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.num_constraints">
<span class="sig-name descname"><span class="pre">num_constraints</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.num_constraints" title="Link to this definition"></a></dt>
<dd><p>Returns the total number of constraints specified by the user.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.num_force_elements">
<span class="sig-name descname"><span class="pre">num_force_elements</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.num_force_elements" title="Link to this definition"></a></dt>
<dd><p>Returns the number of ForceElement objects.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddForceElement().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.num_frames">
<span class="sig-name descname"><span class="pre">num_frames</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.num_frames" title="Link to this definition"></a></dt>
<dd><p>Returns the number of Frame objects in this model. Frames include body
frames associated with each of the bodies, including the <em>world</em> body.
This means the minimum number of frames is one.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.num_joints">
<span class="sig-name descname"><span class="pre">num_joints</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.num_joints" title="Link to this definition"></a></dt>
<dd><p>Returns the number of joints in the model.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddJoint().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.num_model_instances">
<span class="sig-name descname"><span class="pre">num_model_instances</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.num_model_instances" title="Link to this definition"></a></dt>
<dd><p>Returns the number of model instances in the model.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddModelInstance().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.num_multibody_states">
<span class="sig-name descname"><span class="pre">num_multibody_states</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.num_multibody_states" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>num_multibody_states(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd]) -&gt; int</p></li>
</ol>
<p>Returns the size of the multibody system state vector x = [q v]. This
will be <code class="docutils literal notranslate"><span class="pre">num_positions()</span></code> plus <code class="docutils literal notranslate"><span class="pre">num_velocities()</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>num_multibody_states(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; int</p></li>
</ol>
<p>Returns the size of the multibody system state vector xᵢ = [qᵢ vᵢ] for
model instance i. (Here qᵢ ⊆ q and vᵢ ⊆ v.) will be
<code class="docutils literal notranslate"><span class="pre">num_positions(model_instance)</span></code> plus
<code class="docutils literal notranslate"><span class="pre">num_velocities(model_instance)</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.num_positions">
<span class="sig-name descname"><span class="pre">num_positions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.num_positions" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>num_positions(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd]) -&gt; int</p></li>
</ol>
<p>Returns the size of the generalized position vector q for this model.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>num_positions(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; int</p></li>
</ol>
<p>Returns the size of the generalized position vector qᵢ for model
instance i.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.num_velocities">
<span class="sig-name descname"><span class="pre">num_velocities</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.num_velocities" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>num_velocities(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd]) -&gt; int</p></li>
</ol>
<p>Returns the size of the generalized velocity vector v for this model.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>num_velocities(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; int</p></li>
</ol>
<p>Returns the size of the generalized velocity vector vᵢ for model
instance i.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.NumBodiesWithName">
<span class="sig-name descname"><span class="pre">NumBodiesWithName</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.NumBodiesWithName" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The total number of bodies (across all model instances) with the
given name.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.RegisterAsSourceForSceneGraph">
<span class="sig-name descname"><span class="pre">RegisterAsSourceForSceneGraph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scene_graph</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.geometry.SceneGraph_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.SourceId" title="pydrake.geometry.SourceId"><span class="pre">pydrake.geometry.SourceId</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.RegisterAsSourceForSceneGraph" title="Link to this definition"></a></dt>
<dd><p>Registers <code class="docutils literal notranslate"><span class="pre">this</span></code> plant to serve as a source for an instance of
SceneGraph. This registration allows MultibodyPlant to register
geometry with <code class="docutils literal notranslate"><span class="pre">scene_graph</span></code> for visualization and/or collision
queries. The string returned by <code class="docutils literal notranslate"><span class="pre">this-&gt;get_name()</span></code> is passed to
SceneGraph’s RegisterSource, so it is highly recommended that you give
the plant a recognizable name before calling this. Successive
registration calls with SceneGraph <strong>must</strong> be performed on the same
instance to which the pointer argument <code class="docutils literal notranslate"><span class="pre">scene_graph</span></code> points to.
Failure to do so will result in runtime exceptions.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">scene_graph</span></code>:</dt><dd><p>A valid non nullptr to the SceneGraph instance for which <code class="docutils literal notranslate"><span class="pre">this</span></code>
plant will sever as a source, see SceneGraph documentation for
further details.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>the SourceId of <code class="docutils literal notranslate"><span class="pre">this</span></code> plant in <code class="docutils literal notranslate"><span class="pre">scene_graph</span></code>. It can also
later on be retrieved with get_source_id().</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>RuntimeError if called post-finalize.</strong> – </p></li>
<li><p><strong>RuntimeError if scene_graph is the nullptr.</strong> – </p></li>
<li><p><strong>RuntimeError if called more than once.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.RegisterCollisionGeometry">
<span class="sig-name descname"><span class="pre">RegisterCollisionGeometry</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.RegisterCollisionGeometry" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>RegisterCollisionGeometry(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], body: pydrake.multibody.tree.RigidBody_[AutoDiffXd], X_BG: pydrake.math.RigidTransform, shape: pydrake.geometry.Shape, name: str, properties: pydrake.geometry.ProximityProperties) -&gt; pydrake.geometry.GeometryId</p></li>
</ol>
<p>Registers geometry in a SceneGraph with a given geometry::Shape to be
used for the contact modeling of a given <code class="docutils literal notranslate"><span class="pre">body</span></code>. More than one
geometry can be registered with a body, in which case the body’s
contact geometry is the union of all geometries registered to that
body.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body</span></code>:</dt><dd><p>The body for which geometry is being registered.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">X_BG</span></code>:</dt><dd><p>The fixed pose of the geometry frame G in the body frame B.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">shape</span></code>:</dt><dd><p>The geometry::Shape used for collision and contact. E.g.:
geometry::Sphere, geometry::Cylinder, etc.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">properties</span></code>:</dt><dd><p>The proximity properties associated with the collision geometry.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called post-finalize.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>RegisterCollisionGeometry(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], body: pydrake.multibody.tree.RigidBody_[AutoDiffXd], X_BG: pydrake.math.RigidTransform, shape: pydrake.geometry.Shape, name: str, coulomb_friction: pydrake.multibody.plant.CoulombFriction) -&gt; pydrake.geometry.GeometryId</p></li>
</ol>
<p>Overload which specifies a single property: coulomb_friction.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.RegisterVisualGeometry">
<span class="sig-name descname"><span class="pre">RegisterVisualGeometry</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.RegisterVisualGeometry" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>RegisterVisualGeometry(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], body: pydrake.multibody.tree.RigidBody_[AutoDiffXd], X_BG: pydrake.math.RigidTransform, shape: pydrake.geometry.Shape, name: str, diffuse_color: numpy.ndarray[numpy.float64[4, 1]]) -&gt; pydrake.geometry.GeometryId</p></li>
</ol>
<p>Overload for visual geometry registration. The following properties
are set: - (“phong”, “diffuse”) = <code class="docutils literal notranslate"><span class="pre">diffuse_color</span></code> in both sets of
properties. - (“label”, “id”) in perception properties as documented
above.</p>
<p>See mbp_geometry “the overview” for more details.</p>
<ol class="arabic simple" start="2">
<li><p>RegisterVisualGeometry(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], body: pydrake.multibody.tree.RigidBody_[AutoDiffXd], geometry_instance: pydrake.geometry.GeometryInstance) -&gt; pydrake.geometry.GeometryId</p></li>
</ol>
<p>Registers the given <code class="docutils literal notranslate"><span class="pre">geometry_instance</span></code> in a SceneGraph to be used
for visualization of a given <code class="docutils literal notranslate"><span class="pre">body</span></code>.</p>
<p>The roles that <code class="docutils literal notranslate"><span class="pre">geometry_instance</span></code> gets assigned
(illustration/perception) in SceneGraph depend solely on the
properties that have <em>already</em> been assigned to <code class="docutils literal notranslate"><span class="pre">geometry_instance</span></code>.
If <em>any</em> visual roles have been assigned, those will be the only roles
used. If <em>no</em> visual roles have been assigned, then both roles will be
assigned using the default set of property values.</p>
<p>If the registered geometry has the perception role, it will have the
(“label”, “id”) property. Possibly assigned as documented above.</p>
<p>See mbp_geometry “the overview” for more details.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body</span></code>:</dt><dd><p>The body for which geometry is being registered.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">geometry_instance</span></code>:</dt><dd><p>The geometry to associate with the visual appearance of <code class="docutils literal notranslate"><span class="pre">body</span></code>.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if geometry_instance is null.</strong> – </p></li>
<li><p><strong>RuntimeError if called post-finalize.</strong> – </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>the id for the registered geometry.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.RemoveConstraint">
<span class="sig-name descname"><span class="pre">RemoveConstraint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">id</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.MultibodyConstraintId" title="pydrake.multibody.tree.MultibodyConstraintId"><span class="pre">pydrake.multibody.tree.MultibodyConstraintId</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.RemoveConstraint" title="Link to this definition"></a></dt>
<dd><p>Removes the constraint <code class="docutils literal notranslate"><span class="pre">id</span></code> from the plant. Note that this will
<em>not</em> remove constraints registered directly with DeformableModel.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the MultibodyPlant has already been finalized.</strong> – </p></li>
<li><p><strong>RuntimeError if id does not identify any multibody constraint</strong> – </p></li>
<li><p><strong>in this plant.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.RemoveJoint">
<span class="sig-name descname"><span class="pre">RemoveJoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">joint</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.Joint_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.RemoveJoint" title="Link to this definition"></a></dt>
<dd><p>Removes and deletes <code class="docutils literal notranslate"><span class="pre">joint</span></code> from this MultibodyPlant. Any existing
references to <code class="docutils literal notranslate"><span class="pre">joint</span></code> will become invalid, and future calls to
<code class="docutils literal notranslate"><span class="pre">get_joint(joint_index)</span></code> will throw an exception. Other elements of
the plant may depend on <code class="docutils literal notranslate"><span class="pre">joint</span></code> at the time of removal and should be
removed first. For example, a JointActuator that depends on <code class="docutils literal notranslate"><span class="pre">joint</span></code>
should be removed with RemoveJointActuator(). Currently, we do not
provide joint dependency tracking for force elements or constraints,
so this function will throw an exception if there are <em>any</em> user-added
force elements or constraints in the plant.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the plant is already finalized.</strong> – </p></li>
<li><p><strong>RuntimeError if the plant contains a non-zero number</strong><strong> of </strong><strong>user-added</strong> – </p></li>
<li><p><strong>force elements</strong><strong> or </strong><strong>user-added constraints.</strong> – </p></li>
<li><p><strong>RuntimeError if joint has a dependent JointActuator.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddJoint()</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is important to note that the JointIndex assigned to a joint is
immutable. New joint indices are assigned in increasing order,
even if a joint with a lower index has been removed. This has the
consequence that when a joint is removed from the plant, the
sequence <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">num_joints())</span></code> is not necessarily the correct set
of un-removed joint indices in the plant. Thus, it is important
<em>NOT</em> to loop over joint indices sequentially from <code class="docutils literal notranslate"><span class="pre">0</span></code> to
<code class="docutils literal notranslate"><span class="pre">num_joints()</span> <span class="pre">-</span> <span class="pre">1</span></code>. Instead users should use the provided
GetJointIndices() and GetJointIndices(ModelIndex) functions:</p>
</div>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">JointIndex</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">plant</span><span class="p">.</span><span class="n">GetJointIndices</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">Joint</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">joint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">plant</span><span class="p">.</span><span class="n">get_joint</span><span class="p">(</span><span class="n">index</span><span class="p">);</span>
<span class="w">  </span><span class="p">...</span>
<span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
</details></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.RemoveJointActuator">
<span class="sig-name descname"><span class="pre">RemoveJointActuator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">actuator</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.JointActuator_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.RemoveJointActuator" title="Link to this definition"></a></dt>
<dd><p>Removes and deletes <code class="docutils literal notranslate"><span class="pre">actuator</span></code> from this MultibodyPlant. Any
existing references to <code class="docutils literal notranslate"><span class="pre">actuator</span></code> will become invalid, and future
calls to <code class="docutils literal notranslate"><span class="pre">get_joint_actuator(actuator_index)</span></code> will throw an
exception.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if the plant is already finalized.</strong> – </p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddJointActuator()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.RenameModelInstance">
<span class="sig-name descname"><span class="pre">RenameModelInstance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.RenameModelInstance" title="Link to this definition"></a></dt>
<dd><p>Renames an existing model instance.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>:</dt><dd><p>The instance to rename.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">name</span></code>:</dt><dd><p>A string that uniquely identifies the instance within <code class="docutils literal notranslate"><span class="pre">this</span></code>
model.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if called after Finalize</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p></li>
<li><p><strong>RuntimeError if model_instance is not a valid index.</strong> – </p></li>
<li><p><strong>RuntimeError if HasModelInstanceNamed</strong><strong>(</strong><strong>name</strong><strong>) </strong><strong>is true.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.set_adjacent_bodies_collision_filters">
<span class="sig-name descname"><span class="pre">set_adjacent_bodies_collision_filters</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.set_adjacent_bodies_collision_filters" title="Link to this definition"></a></dt>
<dd><p>Sets whether to apply collision filters to topologically adjacent
bodies at Finalize() time. Filters are applied when there exists a
joint between bodies, except in the case of 6-dof joints or joints in
which the parent body is <code class="docutils literal notranslate"><span class="pre">world</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError iff called post-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.set_contact_model">
<span class="sig-name descname"><span class="pre">set_contact_model</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.ContactModel" title="pydrake.multibody.plant.ContactModel"><span class="pre">pydrake.multibody.plant.ContactModel</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.set_contact_model" title="Link to this definition"></a></dt>
<dd><p>Sets the contact model to be used by <code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant, see
ContactModel for available options. The default contact model is
ContactModel::kHydroelasticWithFallback.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError iff called post-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.set_contact_surface_representation">
<span class="sig-name descname"><span class="pre">set_contact_surface_representation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">surface_representation</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.HydroelasticContactRepresentation" title="pydrake.geometry.HydroelasticContactRepresentation"><span class="pre">pydrake.geometry.HydroelasticContactRepresentation</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.set_contact_surface_representation" title="Link to this definition"></a></dt>
<dd><p>Sets the representation of contact surfaces to be used by <code class="docutils literal notranslate"><span class="pre">this</span></code>
MultibodyPlant. See geometry::HydroelasticContactRepresentation for
available options. See GetDefaultContactSurfaceRepresentation() for
explanation of default values.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called post-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.set_discrete_contact_approximation">
<span class="sig-name descname"><span class="pre">set_discrete_contact_approximation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">approximation</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.DiscreteContactApproximation" title="pydrake.multibody.plant.DiscreteContactApproximation"><span class="pre">pydrake.multibody.plant.DiscreteContactApproximation</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.set_discrete_contact_approximation" title="Link to this definition"></a></dt>
<dd><p>Sets the discrete contact model approximation.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Calling this method also sets the contact solver type (see
get_discrete_contact_solver()) according to: -
DiscreteContactApproximation::kTamsi sets the solver to
DiscreteContactSolver::kTamsi. -
DiscreteContactApproximation::kSap,
DiscreteContactApproximation::kSimilar and
DiscreteContactApproximation::kLagged set the solver to
DiscreteContactSolver::kSap.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>iff this plant is continuous</strong><strong> (</strong><strong>i.e. is_discrete</strong><strong>(</strong><strong>) </strong><strong>is</strong> – </p></li>
<li><p><strong>False`.</strong> – </p></li>
<li><p><strong>RuntimeError iff called post-finalize.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.set_gravity_enabled">
<span class="sig-name descname"><span class="pre">set_gravity_enabled</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_enabled</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.set_gravity_enabled" title="Link to this definition"></a></dt>
<dd><p>Sets is_gravity_enabled() for <code class="docutils literal notranslate"><span class="pre">model_instance</span></code> to <code class="docutils literal notranslate"><span class="pre">is_enabled</span></code>.
The effect of <code class="docutils literal notranslate"><span class="pre">is_enabled</span> <span class="pre">=</span> <span class="pre">false</span></code> is effectively equivalent to
disabling (or making zero) gravity for all bodies in the specified
model instance. By default is_gravity_enabled() equals <code class="docutils literal notranslate"><span class="pre">True</span></code> for
all model instances.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if called post-finalize.</strong> – </p></li>
<li><p><strong>RuntimeError if the model instance is invalid.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.set_penetration_allowance">
<span class="sig-name descname"><span class="pre">set_penetration_allowance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">penetration_allowance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.001</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.set_penetration_allowance" title="Link to this definition"></a></dt>
<dd><p>Sets a penetration allowance used to estimate the point contact
stiffness and Hunt &amp; Crossley dissipation parameters. Refer to the
section point_contact_defaults “Point Contact Default Parameters” for
further details.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This will be deprecated. Prefer using defaults specified in
geometry::DefaultProximityProperties.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Values provided in geometry::DefaultProximityProperties have
precedence. If values estimated based on penetration allowance are
desired, set defaults in geometry::DefaultProximityProperties to
std::nullopt.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if penetration_allowance is not positive.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.set_sap_near_rigid_threshold">
<span class="sig-name descname"><span class="pre">set_sap_near_rigid_threshold</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">near_rigid_threshold</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.set_sap_near_rigid_threshold" title="Link to this definition"></a></dt>
<dd><p>Non-negative dimensionless number typically in the range [0.0, 1.0],
though larger values are allowed even if uncommon. This parameter
controls the “near rigid” regime of the SAP solver, β in section V.B
of [Castro et al., 2021]. It essentially controls a threshold value
for the maximum amount of stiffness SAP can handle robustly. Beyond
this value, stiffness saturates as explained in [Castro et al., 2021].
A value of 1.0 is a conservative choice to avoid ill-conditioning that
might lead to softer than expected contact. If this is your case,
consider turning off this approximation by setting this parameter to
zero. For difficult cases where ill-conditioning is a problem, a small
but non-zero number can be used, e.g. 1.0e-3.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if near_rigid_threshold is negative.</strong> – </p></li>
<li><p><strong>RuntimeError if called post-finalize.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.set_stiction_tolerance">
<span class="sig-name descname"><span class="pre">set_stiction_tolerance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v_stiction</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.001</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.set_stiction_tolerance" title="Link to this definition"></a></dt>
<dd><p><a href="#id69"><span class="problematic" id="id70">**</span></a>** Stribeck model of friction</p>
<p>Currently MultibodyPlant uses the Stribeck approximation to model dry
friction. The Stribeck model of friction is an approximation to
Coulomb’s law of friction that allows using continuous time
integration without the need to specify complementarity constraints.
While this results in a simpler model immediately tractable with
standard numerical methods for integration of ODE’s, it often leads to
stiff dynamics that require an explicit integrator to take very small
time steps. It is therefore recommended to use error controlled
integrators when using this model or the discrete time stepping (see
multibody_simulation). See stribeck_approximation for a detailed
discussion of the Stribeck model.</p>
<p>Sets the stiction tolerance <code class="docutils literal notranslate"><span class="pre">v_stiction</span></code> for the Stribeck model,
where <code class="docutils literal notranslate"><span class="pre">v_stiction</span></code> must be specified in m/s (meters per second.)
<code class="docutils literal notranslate"><span class="pre">v_stiction</span></code> defaults to a value of 1 millimeter per second. In
selecting a value for <code class="docutils literal notranslate"><span class="pre">v_stiction</span></code>, you must ask yourself the
question, “When two objects are ostensibly in stiction, how much slip
am I willing to allow?” There are two opposing design issues in
picking a value for vₛ. On the one hand, small values of vₛ make the
problem numerically stiff during stiction, potentially increasing the
integration cost. On the other hand, it should be picked to be
appropriate for the scale of the problem. For example, a car
simulation could allow a “large” value for vₛ of 1 cm/s (1×10⁻² m/s),
but reasonable stiction for grasping a 10 cm box might require
limiting residual slip to 1×10⁻³ m/s or less. Ultimately, picking the
largest viable value will allow your simulation to run faster and more
robustly. Note that <code class="docutils literal notranslate"><span class="pre">v_stiction</span></code> is the slip velocity that we’d have
when we are at edge of the friction cone. For cases when the friction
force is well within the friction cone the slip velocity will always
be smaller than this value. See also stribeck_approximation.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if v_stiction is non-positive.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.SetActuationInArray">
<span class="sig-name descname"><span class="pre">SetActuationInArray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">u_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">u</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.writeable</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.SetActuationInArray" title="Link to this definition"></a></dt>
<dd><p>Given actuation values <code class="docutils literal notranslate"><span class="pre">u_instance</span></code> for the actuators in
<code class="docutils literal notranslate"><span class="pre">model_instance</span></code>, this function updates the actuation vector u for
the entire plant model to which this actuator belongs to. Refer to
mbp_actuation “Actuation” for further details.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">u_instance</span></code>:</dt><dd><p>Actuation values for the model instance. Values are ordered by
monotonically increasing JointActuatorIndex within the model
instance.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">u</span></code>:</dt><dd><p>Actuation values for the entire plant model. The actuation value
in <code class="docutils literal notranslate"><span class="pre">u</span></code> for a particular actuator must be found at offset
JointActuator::input_start(). Only values corresponding to
<code class="docutils literal notranslate"><span class="pre">model_instance</span></code> are changed.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the size</strong><strong> of </strong><strong>u_instance is not equal to the</strong> – </p></li>
<li><p><strong>number</strong><strong> of </strong><strong>actuation inputs for the joints</strong><strong> of </strong><strong>model_instance.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.SetConstraintActiveStatus">
<span class="sig-name descname"><span class="pre">SetConstraintActiveStatus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.systems.framework.Context_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">id</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.MultibodyConstraintId" title="pydrake.multibody.tree.MultibodyConstraintId"><span class="pre">pydrake.multibody.tree.MultibodyConstraintId</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">status</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.SetConstraintActiveStatus" title="Link to this definition"></a></dt>
<dd><p>Sets the active status of the constraint given by <code class="docutils literal notranslate"><span class="pre">id</span></code> in
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the MultibodyPlant has not been finalized.</strong> – </p></li>
<li><p><strong>RuntimeError if context == nullptr</strong> – </p></li>
<li><p><strong>RuntimeError if id does not belong to any multibody constraint</strong> – </p></li>
<li><p><strong>in context.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.SetDefaultFloatingBaseBodyPose">
<span class="sig-name descname"><span class="pre">SetDefaultFloatingBaseBodyPose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.RigidBody_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X_WB</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.math.html#pydrake.math.RigidTransform" title="pydrake.math.RigidTransform"><span class="pre">pydrake.math.RigidTransform</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.SetDefaultFloatingBaseBodyPose" title="Link to this definition"></a></dt>
<dd><p>Provisionally records a default World pose for <code class="docutils literal notranslate"><span class="pre">body</span></code>, to be used in
case <code class="docutils literal notranslate"><span class="pre">body</span></code> turns out to be a floating base body after Finalize().</p>
<p>This may be called pre- or post-Finalize(). Pre-Finalize() this is the
only way to set the default pose of a floating base body.
Post-Finalize(), a floating base body’s default pose may be set either
by this function or by setting the default pose directly through the
Joint API applied to the automatically-added floating joint. The most
recent value set by either method will be used to initialize the
floating joint’s coordinates in subsequently-created Contexts.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>If this is called on a <code class="docutils literal notranslate"><span class="pre">body</span></code> that does <em>not</em> turn out to be a
floating base body after Finalize(), it will have no effect other
than to be echoed back in GetDefaultFloatingBaseBodyPose(); in
particular it will not affect the initial state in a
subsequently-created Context. Use the Joint API to set the default
pose for any body that has an explicitly-defined joint to its
parent body.</p>
</div>
<p>See mbp_working_with_free_bodies “above for details”.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body</span></code>:</dt><dd><p>RigidBody whose default pose will be set if it turns out to be a
floating base body.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">X_WB</span></code>:</dt><dd><p>Default pose of the floating base body in the World frame.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.SetDefaultFreeBodyPose">
<span class="sig-name descname"><span class="pre">SetDefaultFreeBodyPose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.RigidBody_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X_PB</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.math.html#pydrake.math.RigidTransform" title="pydrake.math.RigidTransform"><span class="pre">pydrake.math.RigidTransform</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.SetDefaultFreeBodyPose" title="Link to this definition"></a></dt>
<dd><p>(Deprecated.)</p>
<dl class="simple">
<dt>Deprecated:</dt><dd><p>Use SetDefaultFloatingBaseBodyPose() instead. This will be removed
from Drake on or after 2026-06-01.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.SetDefaultPositions">
<span class="sig-name descname"><span class="pre">SetDefaultPositions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.SetDefaultPositions" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>SetDefaultPositions(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], q: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</p></li>
</ol>
<p>Sets the default positions for the plant. Calls to
CreateDefaultContext or SetDefaultContext/SetDefaultState will return
a Context populated with these position values. They have no other
effects on the dynamics of the system.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the plant is not finalized</strong><strong>, </strong><strong>if q is not</strong><strong> of </strong><strong>size</strong> – </p></li>
<li><p><strong>num_positions</strong><strong>(</strong><strong>)</strong><strong>, or </strong><strong>q contains non-finite values.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>SetDefaultPositions(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], model_instance: pydrake.multibody.tree.ModelInstanceIndex, q_instance: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</p></li>
</ol>
<p>Sets the default positions for the model instance. Calls to
CreateDefaultContext or SetDefaultContext/SetDefaultState will return
a Context populated with these position values. They have no other
effects on the dynamics of the system.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the plant is not finalized</strong><strong>, </strong><strong>if the model_instance</strong> – </p></li>
<li><p><strong>is invalid</strong><strong>, </strong><strong>if the length</strong><strong> of </strong><strong>q_instance is not equal to</strong> – </p></li>
<li><p><strong>num_positions</strong><strong>(</strong><strong>model_instance</strong><strong>)</strong><strong>`</strong><strong>, or </strong><strong>if q_instance contain</strong> – </p></li>
<li><p><strong>non-finite values.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.SetDefaultState">
<span class="sig-name descname"><span class="pre">SetDefaultState</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.systems.framework.Context_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">state</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.systems.framework.State_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.SetDefaultState" title="Link to this definition"></a></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">state</span></code> according to defaults set by the user for joints (e.g.
RevoluteJoint::set_default_angle()) and free bodies
(SetDefaultFreeBodyPose()). If the user does not specify defaults, the
state corresponds to zero generalized positions and velocities.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize. See Finalize</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.SetDistanceConstraintParams">
<span class="sig-name descname"><span class="pre">SetDistanceConstraintParams</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.systems.framework.Context_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">id</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.MultibodyConstraintId" title="pydrake.multibody.tree.MultibodyConstraintId"><span class="pre">pydrake.multibody.tree.MultibodyConstraintId</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.DistanceConstraintParams" title="pydrake.multibody.plant.DistanceConstraintParams"><span class="pre">pydrake.multibody.plant.DistanceConstraintParams</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.SetDistanceConstraintParams" title="Link to this definition"></a></dt>
<dd><p>Stores in <code class="docutils literal notranslate"><span class="pre">context</span></code> the parameters <code class="docutils literal notranslate"><span class="pre">params</span></code> for the distance
constraint with identifier <code class="docutils literal notranslate"><span class="pre">id</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">out</span></code>:</dt><dd><p>] context The plant’s context. On output it stores <code class="docutils literal notranslate"><span class="pre">params</span></code> for
the requested distance constraint.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">id</span></code>:</dt><dd><p>Unique identifier of the constraint.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">params</span></code>:</dt><dd><p>The new set of parameters to be stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>if id is not a valid identifier for a distance constraint.</strong> – </p></li>
<li><p><strong>if params.bodyA</strong><strong>(</strong><strong>) or </strong><strong>params.bodyB</strong><strong>(</strong><strong>) </strong><strong>do not correspond to rigid</strong> – </p></li>
<li><p><strong>bodies in this MultibodyPlant.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.SetFloatingBaseBodyPoseInAnchoredFrame">
<span class="sig-name descname"><span class="pre">SetFloatingBaseBodyPoseInAnchoredFrame</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.systems.framework.Context_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_F</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.Frame_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.RigidBody_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X_FB</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.math.RigidTransform_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.SetFloatingBaseBodyPoseInAnchoredFrame" title="Link to this definition"></a></dt>
<dd><p>Updates <code class="docutils literal notranslate"><span class="pre">context</span></code> to store the World-frame pose of floating base
body B, given its pose <code class="docutils literal notranslate"><span class="pre">X_FB</span></code> in an arbitrary anchored frame F.</p>
<p>Frame F must be <em>anchored</em>, meaning that it is either on a body which
is directly welded to a frame on the World body, or more generally,
that it is on a body for which there is a kinematic path between that
body and the world body that only includes weld joints.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The World-frame pose is calculated here and stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.
Moving F subsequently will not change the stored pose unless you
call this method again.</p>
</div>
<p>See mbp_working_with_free_bodies “above for details”.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if called pre-finalize.</strong> – </p></li>
<li><p><strong>RuntimeError if frame F is not anchored to the world.</strong> – </p></li>
<li><p><strong>RuntimeError if body is not a floating base body.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.SetFloatingBaseBodyPoseInWorldFrame">
<span class="sig-name descname"><span class="pre">SetFloatingBaseBodyPoseInWorldFrame</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.systems.framework.Context_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.RigidBody_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X_WB</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.math.RigidTransform_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.SetFloatingBaseBodyPoseInWorldFrame" title="Link to this definition"></a></dt>
<dd><p>Updates <code class="docutils literal notranslate"><span class="pre">context</span></code> to store the pose <code class="docutils literal notranslate"><span class="pre">X_WB</span></code> of a given floating
base body B’s body frame in the World frame W.</p>
<p>See mbp_working_with_free_bodies “above for details”.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if called pre-finalize.</strong> – </p></li>
<li><p><strong>RuntimeError if body is not a floating base body.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.SetFreeBodyPose">
<span class="sig-name descname"><span class="pre">SetFreeBodyPose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.SetFreeBodyPose" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>SetFreeBodyPose(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], body: pydrake.multibody.tree.RigidBody_[AutoDiffXd], X_JpJc: pydrake.math.RigidTransform_[AutoDiffXd]) -&gt; None</p></li>
</ol>
<p>For any free body’s 6-dof joint, sets <code class="docutils literal notranslate"><span class="pre">context</span></code> to store the pose
X_JpJc of child frame Jc in its parent frame Jp.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Unless <code class="docutils literal notranslate"><span class="pre">body</span></code> is a floating base body, the parent frame Jp is
not necessarily the World frame W, and the child frame Jc is not
necessarily the body frame B. For a floating base body B, this
method sets X_WB, the pose of body B in World.</p>
</div>
<p>See mbp_working_with_free_bodies “above for details”.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if called pre-finalize.</strong> – </p></li>
<li><p><strong>RuntimeError if body is not a free body.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>SetFreeBodyPose(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], body: pydrake.multibody.tree.RigidBody_[AutoDiffXd], X_PB: pydrake.math.RigidTransform_[AutoDiffXd]) -&gt; None</p></li>
</ol>
<p>X_PB parameter name for SetFreeBodyPose() is deprecated and will be removed 2026-06-01. Use X_JpJc instead.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.SetFreeBodySpatialVelocity">
<span class="sig-name descname"><span class="pre">SetFreeBodySpatialVelocity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.SetFreeBodySpatialVelocity" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>SetFreeBodySpatialVelocity(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], body: pydrake.multibody.tree.RigidBody_[AutoDiffXd], V_JpJc: pydrake.multibody.math.SpatialVelocity_[AutoDiffXd]) -&gt; None</p></li>
</ol>
<p>For any free body’s 6-dof joint, sets <code class="docutils literal notranslate"><span class="pre">context</span></code> to store the spatial
velocity V_JpJc of child frame Jc in its parent frame Jp.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Unless <code class="docutils literal notranslate"><span class="pre">body</span></code> is a floating base body, the parent frame Jp is
not necessarily the World frame W, and the child frame Jc is not
necessarily the body frame B. For a floating base body B, this
method sets V_WB, the spatial velocity of body B in World.</p>
</div>
<p>See mbp_working_with_free_bodies “above for details”.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if called pre-finalize.</strong> – </p></li>
<li><p><strong>RuntimeError if body is not a free body.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>SetFreeBodySpatialVelocity(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], body: pydrake.multibody.tree.RigidBody_[AutoDiffXd], V_PB: pydrake.multibody.math.SpatialVelocity_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd]) -&gt; None</p></li>
</ol>
<p>The parameter order and V_PB parameter name for SetFreeBodySpatialVelocity() are deprecated and will be removed 2026-06-01. Use context, body, V_JpJc instead.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.SetPositions">
<span class="sig-name descname"><span class="pre">SetPositions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.SetPositions" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>SetPositions(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], q: numpy.ndarray[object[m, 1]]) -&gt; None</p></li>
</ol>
<p>Sets the generalized positions q in a given Context from a given
vector. Prefer this method over GetMutablePositions().</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if context is nullptr</strong><strong>, </strong><strong>if context does not</strong> – </p></li>
<li><p><strong>correspond to the Context for a multibody model</strong><strong>, </strong><strong>if the length of</strong> – </p></li>
<li><p><strong>q` is not equal to num_positions</strong><strong>(</strong><strong>)</strong><strong>, or </strong><strong>if q contain</strong> – </p></li>
<li><p><strong>non-finite values.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>SetPositions(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], model_instance: pydrake.multibody.tree.ModelInstanceIndex, q: numpy.ndarray[object[m, 1]]) -&gt; None</p></li>
</ol>
<p>Sets the generalized positions q in a given Context from a given
vector. Prefer this method over GetMutablePositions().</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if context is nullptr</strong><strong>, </strong><strong>if context does not</strong> – </p></li>
<li><p><strong>correspond to the Context for a multibody model</strong><strong>, </strong><strong>if the length of</strong> – </p></li>
<li><p><strong>q` is not equal to num_positions</strong><strong>(</strong><strong>)</strong><strong>, or </strong><strong>if q contain</strong> – </p></li>
<li><p><strong>non-finite values.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.SetPositionsAndVelocities">
<span class="sig-name descname"><span class="pre">SetPositionsAndVelocities</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.SetPositionsAndVelocities" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>SetPositionsAndVelocities(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], q_v: numpy.ndarray[object[m, 1]]) -&gt; None</p></li>
</ol>
<p>Sets generalized positions q and generalized velocities v in a given
Context from a given vector [q; v]. Prefer this method over
GetMutablePositionsAndVelocities().</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if context is nullptr</strong><strong>, </strong><strong>if context does not</strong> – </p></li>
<li><p><strong>correspond to the context for a multibody model</strong><strong>, </strong><strong>if the length of</strong> – </p></li>
<li><p><strong>q_v` is not equal to num_positions</strong><strong>(</strong><strong>) </strong><strong>+ num_velocities</strong><strong>(</strong><strong>)</strong><strong>, </strong><strong>o</strong> – </p></li>
<li><p><strong>if q_v contains non-finite values.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>SetPositionsAndVelocities(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], model_instance: pydrake.multibody.tree.ModelInstanceIndex, q_v: numpy.ndarray[object[m, 1]]) -&gt; None</p></li>
</ol>
<p>Sets generalized positions q and generalized velocities v from a given
vector [q; v] for a specified model instance in a given Context.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if context is nullptr</strong><strong>, </strong><strong>if context does not</strong> – </p></li>
<li><p><strong>correspond to the Context for a multibody model</strong><strong>, </strong><strong>if the model</strong> – </p></li>
<li><p><strong>instance index is invalid</strong><strong>, </strong><strong>if the length</strong><strong> of </strong><strong>q_v is not equal</strong> – </p></li>
<li><p><strong>to ``num_positions</strong><strong>(</strong><strong>model_instance</strong><strong>) </strong><strong>+</strong> – </p></li>
<li><p><strong>num_velocities</strong><strong>(</strong><strong>model_instance</strong><strong>)</strong><strong>``</strong><strong>, or </strong><strong>if q_v contains</strong> – </p></li>
<li><p><strong>non-finite values.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.SetPositionsInArray">
<span class="sig-name descname"><span class="pre">SetPositionsInArray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">q_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.writeable</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.SetPositionsInArray" title="Link to this definition"></a></dt>
<dd><p>Sets the vector of generalized positions for <code class="docutils literal notranslate"><span class="pre">model_instance</span></code> in
<code class="docutils literal notranslate"><span class="pre">q</span></code> using <code class="docutils literal notranslate"><span class="pre">q_instance</span></code>, leaving all other elements in the array
untouched. This method throws an exception if <code class="docutils literal notranslate"><span class="pre">q</span></code> is not of size
MultibodyPlant::num_positions() or <code class="docutils literal notranslate"><span class="pre">q_instance</span></code> is not of size
<code class="docutils literal notranslate"><span class="pre">MultibodyPlant::num_positions(model_instance)</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.SetUseSampledOutputPorts">
<span class="sig-name descname"><span class="pre">SetUseSampledOutputPorts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_sampled_output_ports</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.SetUseSampledOutputPorts" title="Link to this definition"></a></dt>
<dd><p>(Advanced) For a discrete-time plant, configures whether the output
ports are sampled (the default) or live (opt-in). See
output_port_sampling “Output port sampling” for details.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the plant is already finalized.</strong> – </p></li>
<li><p><strong>RuntimeError if use_sampled_output_ports is True but</strong> – </p></li>
<li><p><strong>this` MultibodyPlant is not a discrete model</strong><strong> (</strong><strong>is_discrete</strong><strong>(</strong><strong>) </strong><strong>=</strong> – </p></li>
<li><p><strong>false</strong><strong>)</strong><strong>.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.SetVelocities">
<span class="sig-name descname"><span class="pre">SetVelocities</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.SetVelocities" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>SetVelocities(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], v: numpy.ndarray[object[m, 1]]) -&gt; None</p></li>
</ol>
<p>Sets the generalized velocities v in a given Context from a given
vector. Prefer this method over GetMutableVelocities().</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the context is nullptr</strong><strong>, </strong><strong>if the context does</strong> – </p></li>
<li><p><strong>not correspond to the context for a multibody model</strong><strong>, </strong><strong>if the length</strong> – </p></li>
<li><p><strong>of v is not equal to num_velocities</strong><strong>(</strong><strong>)</strong><strong>, or </strong><strong>if v</strong> – </p></li>
<li><p><strong>contains non-finite values.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>SetVelocities(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], model_instance: pydrake.multibody.tree.ModelInstanceIndex, v: numpy.ndarray[object[m, 1]]) -&gt; None</p></li>
</ol>
<p>Sets the generalized velocities v for a particular model instance in a
given Context from a given vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the context is nullptr</strong><strong>, </strong><strong>if context does</strong> – </p></li>
<li><p><strong>not correspond to the Context for a multibody model</strong><strong>, </strong><strong>if the model</strong> – </p></li>
<li><p><strong>instance index is invalid</strong><strong>, </strong><strong>if the length</strong><strong> of </strong><strong>v_instance is not</strong> – </p></li>
<li><p><strong>equal to num_velocities</strong><strong>(</strong><strong>model_instance</strong><strong>)</strong><strong>, or </strong><strong>if v_instance</strong> – </p></li>
<li><p><strong>contains non-finite values.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.SetVelocitiesInArray">
<span class="sig-name descname"><span class="pre">SetVelocitiesInArray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">v_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.writeable</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.SetVelocitiesInArray" title="Link to this definition"></a></dt>
<dd><p>Sets the vector of generalized velocities for <code class="docutils literal notranslate"><span class="pre">model_instance</span></code> in
<code class="docutils literal notranslate"><span class="pre">v</span></code> using <code class="docutils literal notranslate"><span class="pre">v_instance</span></code>, leaving all other elements in the array
untouched. This method throws an exception if <code class="docutils literal notranslate"><span class="pre">v</span></code> is not of size
MultibodyPlant::num_velocities(), <code class="docutils literal notranslate"><span class="pre">v_instance</span></code> is not of size
<code class="docutils literal notranslate"><span class="pre">MultibodyPlant::num_positions(model_instance)</span></code>, or <code class="docutils literal notranslate"><span class="pre">v_instance</span></code>
contains non-finite values.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.time_step">
<span class="sig-name descname"><span class="pre">time_step</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.time_step" title="Link to this definition"></a></dt>
<dd><p>The time step (or period) used to model <code class="docutils literal notranslate"><span class="pre">this</span></code> plant as a discrete
system with periodic updates. Returns 0 (zero) if the plant is modeled
as a continuous system. This property of the plant is specified at
construction and therefore this query can be performed either pre- or
post-finalize, see Finalize().</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>MultibodyPlant::MultibodyPlant(double)</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.WeldFrames">
<span class="sig-name descname"><span class="pre">WeldFrames</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_on_parent_F</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.Frame_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_on_child_M</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.Frame_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X_FM</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.math.html#pydrake.math.RigidTransform" title="pydrake.math.RigidTransform"><span class="pre">pydrake.math.RigidTransform</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">RigidTransform(R=RotationMatrix([[1.0,</span> <span class="pre">0.0,</span> <span class="pre">0.0],</span> <span class="pre">[0.0,</span> <span class="pre">1.0,</span> <span class="pre">0.0],</span> <span class="pre">[0.0,</span> <span class="pre">0.0,</span> <span class="pre">1.0]]),</span> <span class="pre">p=[0.0,</span> <span class="pre">0.0,</span> <span class="pre">0.0])</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.multibody.tree.WeldJoint_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.WeldFrames" title="Link to this definition"></a></dt>
<dd><p>Welds <code class="docutils literal notranslate"><span class="pre">frame_on_parent_F</span></code> and <code class="docutils literal notranslate"><span class="pre">frame_on_child_M</span></code> with relative
pose <code class="docutils literal notranslate"><span class="pre">X_FM</span></code>. That is, the pose of frame M in frame F is fixed, with
value <code class="docutils literal notranslate"><span class="pre">X_FM</span></code>. If <code class="docutils literal notranslate"><span class="pre">X_FM</span></code> is omitted, the identity transform will be
used. The call to this method creates and adds a new WeldJoint to the
model. The new WeldJoint is named as: frame_on_parent_F.name() +
“_welds_to_” + frame_on_child_M.name().</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a constant reference to the WeldJoint welding frames F and M.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>RuntimeError if the weld produces a duplicate joint name.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.world_body">
<span class="sig-name descname"><span class="pre">world_body</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.multibody.tree.RigidBody_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.world_body" title="Link to this definition"></a></dt>
<dd><p>Returns a constant reference to the <em>world</em> body.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.world_frame">
<span class="sig-name descname"><span class="pre">world_frame</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.multibody.tree.RigidBodyFrame_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.world_frame" title="Link to this definition"></a></dt>
<dd><p>Returns a constant reference to the <em>world</em> frame.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">MultibodyPlant_[Expression]</span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.LeafSystem_-Expression" title="pydrake.systems.framework.LeafSystem_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem_[Expression]</span></code></a></p>
<p>MultibodyPlant is a Drake system framework representation (see
systems::System) for the model of a physical system consisting of a
collection of interconnected bodies. See multibody for an overview of
concepts/notation.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">actuation&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">applied_generalized_force&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">applied_spatial_force&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px"><em style="color:gray">model_instance_name[i]</em>_actuation&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px"><em style="color:gray">model_instance_name[i]</em>_desired_state&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px"><span style="color:green">geometry_query</span>&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>MultibodyPlant</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; state</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; body_poses</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; body_spatial_velocities</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; body_spatial_accelerations</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; generalized_acceleration</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; net_actuation</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; reaction_forces</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; contact_results</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; <em style="color:gray">model_instance_name[i]</em>_state</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; <em style="color:gray">model_instance_name[i]</em>_generalized_acceleration</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; <em style="color:gray">model_instance_name[i]</em>_generalized_contact_forces</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; <em style="color:gray">model_instance_name[i]</em>_net_actuation</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; <span style="color:green">geometry_pose</span></td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; <span style="color:green">deformable_body_configuration</span></td></tr></table></td></tr></table><p>The ports whose names begin with &lt;em style=”color:gray”&gt;
model_instance_name[i]&lt;/em&gt; represent groups of ports, one for each of
the model_instances “model instances”, with i ∈ {0, …, N-1} for the
N model instances. If a model instance does not contain any data of
the indicated type the port will still be present but its value will
be a zero-length vector. (Model instances <code class="docutils literal notranslate"><span class="pre">world_model_instance()</span></code>
and <code class="docutils literal notranslate"><span class="pre">default_model_instance()</span></code> always exist.)</p>
<p>The ports shown in &lt;span style=”color:green”&gt;green&lt;/span&gt; are for
communication with Drake’s geometry::SceneGraph “SceneGraph” system
for dealing with geometry.</p>
<p>MultibodyPlant provides a user-facing API for:</p>
<ul class="simple">
<li><p>mbp_input_and_output_ports “Ports”:</p></li>
</ul>
<p>Access input and output ports.
- mbp_construction “Construction”:
Add bodies, joints, frames, force elements, and actuators.
- mbp_geometry “Geometry”:
Register geometries to a provided SceneGraph instance.
- mbp_contact_modeling “Contact modeling”:
Select and parameterize contact models.
- mbp_state_accessors_and_mutators “State access and modification”:
Obtain and manipulate position and velocity state variables.
- mbp_parameters “Parameters”
Working with system parameters for various multibody elements.
- mbp_working_with_free_bodies “Free and floating base bodies”:
Work conveniently with free (floating) bodies.
- mbp_kinematic_and_dynamic_computations “Kinematics and dynamics”:
Perform systems::Context “Context”-dependent kinematic and dynamic
queries.
- mbp_system_matrix_computations “System matrices”:
Explicitly form matrices that appear in the equations of motion.
- mbp_introspection “Introspection”:
Perform introspection to find out what’s in the MultibodyPlant.</p>
<p><a href="#id73"><span class="problematic" id="id74">**</span></a>** Model Instances</p>
<p>A MultiBodyPlant may contain multiple model instances. Each model
instance corresponds to a set of bodies and their connections
(joints). Model instances provide methods to get or set the state of
the set of bodies (e.g., through GetPositionsAndVelocities() and
SetPositionsAndVelocities()), connecting controllers (through
get_state_output_port() and get_actuation_input_port()), and
organizing duplicate models (read through a parser). In fact, many
MultibodyPlant methods are overloaded to allow operating on the entire
plant or just the subset corresponding to the model instance; for
example, one GetPositions() method obtains the generalized positions
for the entire plant while another GetPositions() method obtains the
generalized positions for model instance.</p>
<p>Model instances are frequently defined through SDFormat files (using
the <code class="docutils literal notranslate"><span class="pre">model</span></code> tag) and are automatically created when SDFormat files
are parsed (by Parser). There are two special
multibody::ModelInstanceIndex values. The world body is always
multibody::ModelInstanceIndex 0. multibody::ModelInstanceIndex 1 is
reserved for all elements with no explicit model instance and is
generally only relevant for elements created programmatically (and
only when a model instance is not explicitly specified). Note that
Parser creates model instances (resulting in a
multibody::ModelInstanceIndex ≥ 2) as needed.</p>
<p>See num_model_instances(), num_positions(), num_velocities(),
num_actuated_dofs(), AddModelInstance() GetPositionsAndVelocities(),
GetPositions(), GetVelocities(), SetPositionsAndVelocities(),
SetPositions(), SetVelocities(), GetPositionsFromArray(),
GetVelocitiesFromArray(), SetPositionsInArray(),
SetVelocitiesInArray(), SetActuationInArray(),
HasModelInstanceNamed(), GetModelInstanceName(),
get_state_output_port(), get_actuation_input_port().</p>
<p><a href="#id75"><span class="problematic" id="id76">**</span></a>** System dynamics</p>
<p>The state of a multibody system <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">[q;</span> <span class="pre">v]</span></code> is given by its
generalized positions vector q, of size <code class="docutils literal notranslate"><span class="pre">nq</span></code> (see num_positions()),
and by its generalized velocities vector v, of size <code class="docutils literal notranslate"><span class="pre">nv</span></code> (see
num_velocities()).</p>
<p>A MultibodyPlant can be constructed to be either continuous or
discrete. The choice is indicated by the time_step passed to the
constructor – a non-zero time_step indicates a discrete plant, while
a zero time_step indicates continuous. A systems::Simulator
“Simulator” will step a discrete plant using the indicated time_step,
but will allow a numerical integrator to choose how to advance time
for a continuous MultibodyPlant.</p>
<p>We’ll discuss continuous plant dynamics in this section. Discrete
dynamics is more complicated and gets its own section below.</p>
<p>As a Drake systems::System “System”, MultibodyPlant implements the
governing equations for a multibody dynamical system in the form <code class="docutils literal notranslate"><span class="pre">ẋ</span>
<span class="pre">=</span> <span class="pre">f(t,</span> <span class="pre">x,</span> <span class="pre">u)</span></code> with t being time and u external inputs such as
actuation forces. The governing equations for the dynamics of a
multibody system modeled with MultibodyPlant are [Featherstone 2008,
Jain 2010]:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">q</span><span class="err">̇</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">N</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="n">v</span>
<span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w">    </span><span class="n">M</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="n">v</span><span class="err">̇</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">C</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">τ</span>
</pre></div>
</div>
</details><p>where <code class="docutils literal notranslate"><span class="pre">M(q)</span></code> is the mass matrix of the multibody system (including
rigid body mass properties and reflected_inertia “reflected
inertias”), <code class="docutils literal notranslate"><span class="pre">C(q,</span> <span class="pre">v)v</span></code> contains Coriolis, centripetal, and
gyroscopic terms and <code class="docutils literal notranslate"><span class="pre">N(q)</span></code> is the kinematic coupling matrix
describing the relationship between q̇ (the time derivatives of the
generalized positions) and the generalized velocities v, [Seth 2010].
<code class="docutils literal notranslate"><span class="pre">N(q)</span></code> is an <code class="docutils literal notranslate"><span class="pre">nq</span> <span class="pre">x</span> <span class="pre">nv</span></code> matrix. The vector <code class="docutils literal notranslate"><span class="pre">τ</span> <span class="pre">∈</span> <span class="pre">ℝⁿᵛ</span></code> on the right
hand side of Eq. (1) is the system’s generalized forces. These
incorporate gravity, springs, externally applied body forces,
constraint forces, and contact forces.</p>
<p><a href="#id77"><span class="problematic" id="id78">**</span></a>** Discrete system dynamics</p>
<p>We’ll start with the basic difference equation interpretation of a
discrete plant and then explain some Drake-specific subtleties.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>We use “kinematics” here to refer to quantities that involve only
position or velocity, and “dynamics” to refer to quantities that
also involve forces.</p>
</div>
<p>By default, a discrete MultibodyPlant has these update dynamics:</p>
<p>x[0] = initial kinematics state variables x (={q, v}), s s[0] = empty
(no sample yet)</p>
<p>s[n+1] = g(t[n], x[n], u[n]) record sample x[n+1] = f(t[n], x[n],
u[n]) update kinematics yd[n+1] = gd(s) dynamic outputs use sampled
values yk[n+1] = gk(x) kinematic outputs use current x</p>
<p>Optionally, output port sampling can be disabled. In that case we
have:</p>
<p>x[n+1] = f(t[n], x[n], u[n]) update kinematics yd[n+1] = gd(g(t, x,
u)) dynamic outputs use current values yk[n+1] = gk(x) kinematic
outputs use current x</p>
<p>We’re using <code class="docutils literal notranslate"><span class="pre">yd</span></code> and <code class="docutils literal notranslate"><span class="pre">yk</span></code> above to represent the calculated values
of dynamic and kinematic output ports, resp. Kinematic output ports
are those that depend only on position and velocity: <code class="docutils literal notranslate"><span class="pre">state</span></code>,
<cite>body_poses</cite>, <code class="docutils literal notranslate"><span class="pre">body_spatial_velocities</span></code>. Everything else depends on
forces so is a dynamic output port: <code class="docutils literal notranslate"><span class="pre">body_spatial_accelerations</span></code>,
<cite>generalized_acceleration</cite>, <code class="docutils literal notranslate"><span class="pre">net_actuation</span></code>, <cite>reaction_forces</cite>, and
<code class="docutils literal notranslate"><span class="pre">contact_results</span></code>.</p>
<p>Use the function SetUseSampledOutputPorts() to choose which dynamics
you prefer. The default behavior (output port sampling) is more
efficient for simulation, but use slightly-different kinematics for
the dynamic output port computations versus the kinematic output
ports. Disabling output port sampling provides “live” output port
results that are recalculated from the current state and inputs
whenever changes occur. It also eliminates the sampling state variable
(s above). Note that kinematic output ports (that is, those depending
only on position and velocity) are always “live” – they are
calculated as needed from the current (updated) state.</p>
<p>The reason that the default mode is more efficient for simulation is
that the sample variable s records expensive-to-compute results (such
as hydroelastic contact forces) that are needed to advance the state
x. Those results are thus available for free at the start of step n.
If instead we wait until after the state is updated to n+1, we would
have to recalculate those expensive results at the new state in order
to report them. Thus sampling means the output ports show the results
that were calculated using kinematics values x[n], although the
Context has been updated to kinematics values x[n+1]. If that isn’t
tolerable you should disable output port sampling. You can also force
an update to occur using ExecuteForcedEvents().</p>
<p>See output_port_sampling “Output port sampling” below for more
practical considerations.</p>
<p>Minor details most users won’t care about:</p>
<ul class="simple">
<li><p>The sample variable s is a Drake Abstract state variable. When it is</p></li>
</ul>
<p>present, the plant update is performed using an Unrestricted update; when it
is absent we are able to use a Discrete update. Some Drake features (e.g.
linearization of discrete systems) may be restricted to systems that use
only Discrete (numeric) state variables and Discrete update.
- The sample variable s is used only by output ports. It does not affect the
behavior of any MultibodyPlant “Calc” or “Eval” functions – those are
always calculated using the current values of time, kinematic state, and
input port values.</p>
<p><a href="#id79"><span class="problematic" id="id80">**</span></a>** Output port sampling</p>
<p>As described in mbp_discrete_dynamics “Discrete system dynamics”
above, the semantics of certain MultibodyPlant output ports depends on
whether the plant is configured to advance using continuous time
integration or discrete time steps (see is_discrete()). This section
explains the details, focusing on the practical aspects moreso than
the equations.</p>
<p>Output ports that only depend on the [q, v] kinematic state (such as
get_body_poses_output_port() or
get_body_spatial_velocities_output_port()) do <em>not</em> change semantics
for continuous vs discrete time. In all cases, the output value is a
function of the kinematic state in the context.</p>
<p>Output ports that incorporate dynamics (i.e., forces) <em>do</em> change
semantics based on the plant mode. Imagine that the
get_applied_spatial_force_input_port() provides a continuously
time-varying input force. The
get_body_spatial_accelerations_output_port() output is dependent on
that force. We could return a snapshot of the acceleration that was
used in the last time step, or we could recalculate the acceleration
to immediately reflect the changing forces. We call the former a
“sampled” port and the latter a “live” port.</p>
<p>For a continuous-time plant, there is no distinction – the output
port is always live – it immediately reflects the instantaneous input
value. It is a “direct feedthrough” output port (see
SystemBase::GetDirectFeedthroughs()).</p>
<p>For a discrete-time plant, the user can choose whether the output
should be sampled or live: Use the function SetUseSampledOutputPorts()
to change whether output ports are sampled or not, and
has_sampled_output_ports() to check the current setting. When sampling
is disabled, the only state in the context is the kinematic [q, v], so
dynamics output ports will always reflect the instantaneous answer
(i.e., direct feedthrough). When sampling is enabled (the default),
the plant state incorporates a snapshot of the most recent step’s
kinematics and dynamics, and the output ports will reflect that
sampled state (i.e., not direct feedthrough). For a detailed
discussion, see mbp_discrete_dynamics “Discrete system dynamics”.</p>
<p>For a discrete-time plant, the sampled outputs are generally <em>much</em>
faster to calculate than the feedthrough outputs when any inputs ports
are changing values faster than the discrete time step, e.g., during a
simulation. When input ports are fixed, or change at the time step
rate (e.g., during motion planning), sampled vs feedthrough will have
similar computational performance.</p>
<p>Direct plant API function calls (e.g.,
EvalBodySpatialAccelerationInWorld()) that depend on forces always use
the instantaneous (not sampled) accelerations.</p>
<p>Here are some practical tips that might help inform your particular
situation:</p>
<p>(1) If you need a minimal-state representation for motion planning,
mathematical optimization, or similar, then you can either use a
continuous-time plant or set the config option
<code class="docutils literal notranslate"><span class="pre">use_sampled_output_ports=false</span></code> on a discrete-time plant.</p>
<p>(2) By default, setting the positions of a discrete-time plant in the
Context will not have any effect on the dynamics-related output ports,
e.g., the contact results will not change. If you need to see changes
to outputs without running the plant in a Simulator, then you can
either use a continuous-time plant, set the config option
<code class="docutils literal notranslate"><span class="pre">use_sampled_output_ports=false</span></code>, or use ExecuteForcedEvents() to
force a dynamics step and then the outputs (and positions) will
change.</p>
<p><a href="#id81"><span class="problematic" id="id82">**</span></a>** Actuation</p>
<p>In a MultibodyPlant model an actuator can be added as a JointActuator,
see AddJointActuator(). The plant declares actuation input ports to
provide feedforward actuation, both for the MultibodyPlant as a whole
(see get_actuation_input_port()) and for each individual
model_instances “model instance” in the MultibodyPlant (see
get_actuation_input_port(ModelInstanceIndex)const
“get_actuation_input_port(ModelInstanceIndex)”). - Actuation inputs
and actuation effort limits are taken to be in joint coordinates (they
are not affected by the actuator gear ratio). - Any actuation input
ports not connected are assumed to be zero. - Actuation values from
the full MultibodyPlant model port (get_actuation_input_port()) and
from the per model-instance ports (
get_actuation_input_port(ModelInstanceIndex)const
“get_actuation_input_port(ModelInstanceIndex)”) are summed up.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A JointActuator’s index into the vector data supplied to
MultibodyPlant’s actuation input port for all actuators
(get_actuation_input_port()) is given by
JointActuator::input_start(), NOT by its JointActuatorIndex. That
is, the vector element data for a JointActuator at index
JointActuatorIndex(i) in the full input port vector is found at
index:
MultibodyPlant::get_joint_actuator(JointActuatorIndex(i)).input_start().
For the get_actuation_input_port(ModelInstanceIndex)const
“get_actuation_input_port(ModelInstanceIndex)” specific to a model
index, the vector data is ordered by monotonically increasing
JointActuatorIndex for the actuators within that model instance:
the 0ᵗʰ vector element corresponds to the lowest-numbered
JointActuatorIndex of that instance, the 1ˢᵗ vector element
corresponds to the second-lowest-numbered JointActuatorIndex of
that instance, etc.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The following snippet shows how per model instance actuation can
be set:</p>
</div>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">ModelInstanceIndex</span><span class="w"> </span><span class="n">model_instance_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...;</span>
<span class="n">VectorX</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">u_instance</span><span class="p">(</span><span class="n">plant</span><span class="p">.</span><span class="n">num_actuated_dofs</span><span class="p">(</span><span class="n">model_instance_index</span><span class="p">));</span>
<span class="kt">int</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">JointActuatorIndex</span><span class="w"> </span><span class="n">joint_actuator_index</span><span class="w"> </span><span class="o">:</span>
<span class="n">plant</span><span class="p">.</span><span class="n">GetJointActuatorIndices</span><span class="p">(</span><span class="n">model_instance_index</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="k">const</span><span class="w"> </span><span class="n">JointActuator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">actuator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">plant</span><span class="p">.</span><span class="n">get_joint_actuator</span><span class="p">(</span>
<span class="n">joint_actuator_index</span><span class="p">);</span>
<span class="k">const</span><span class="w"> </span><span class="n">Joint</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">joint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">actuator</span><span class="p">.</span><span class="n">joint</span><span class="p">();</span>
<span class="n">VectorX</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">u_joint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="n">my_actuation_logic_for</span><span class="p">(</span><span class="n">joint</span><span class="p">)</span><span class="w"> </span><span class="p">...;</span>
<span class="n">ASSERT</span><span class="p">(</span><span class="n">u_joint</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">joint_actuator</span><span class="p">.</span><span class="n">num_inputs</span><span class="p">());</span>
<span class="n">u_instance</span><span class="p">.</span><span class="n">segment</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="n">u_joint</span><span class="p">.</span><span class="n">size</span><span class="p">())</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">u_joint</span><span class="p">;</span>
<span class="n">offset</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">u_joint</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
<span class="p">}</span>
<span class="n">plant</span><span class="p">.</span><span class="n">get_actuation_input_port</span><span class="p">(</span><span class="n">model_instance_index</span><span class="p">).</span><span class="n">FixValue</span><span class="p">(</span>
<span class="n">plant_context</span><span class="p">,</span><span class="w"> </span><span class="n">u_instance</span><span class="p">);</span>
</pre></div>
</div>
</details><div class="admonition note">
<p class="admonition-title">Note</p>
<p>To inter-operate between the whole plant actuation vector and sets
of per-model instance actuation vectors, see SetActuationInArray()
to gather the model instance vectors into a whole plant vector and
GetActuationFromArray() to scatter the whole plant vector into
per-model instance vectors.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Effort limits (JointActuator::effort_limit()) are not enforced,
unless PD controllers are defined. See pd_controllers “Using PD
controlled actuators”.</p>
</div>
<p>** Using PD controlled actuators</p>
<p>While PD controllers can be modeled externally and be connected to the
MultibodyPlant model via the get_actuation_input_port(), simulation
stability at discrete-time steps can be compromised for high
controller gains. For such cases, simulation stability and robustness
can be improved significantly by moving your PD controller into the
plant where the discrete solver can strongly couple controller and
model dynamics.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Currently, this feature is only supported for discrete models
(is_discrete() is true) using the SAP solver
(get_discrete_contact_solver() returns
DiscreteContactSolver::kSap.)</p>
</div>
<p>PD controlled joint actuators can be defined by setting PD gains for
each joint actuator, see JointActuator::set_controller_gains(). Unless
these gains are specified, joint actuators will not be PD controlled
and JointActuator::has_controller() will return <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
<p>For models with PD controllers, the actuation torque per actuator is
computed according to:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">u</span><span class="err">̃</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">Kp</span><span class="err">⋅</span><span class="p">(</span><span class="n">q</span><span class="w"> </span><span class="err">−</span><span class="w"> </span><span class="n">qd</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">Kd</span><span class="err">⋅</span><span class="p">(</span><span class="n">v</span><span class="w"> </span><span class="err">−</span><span class="w"> </span><span class="n">vd</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">u_ff</span>
<span class="n">u</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="err">−</span><span class="n">e</span><span class="p">,</span><span class="w"> </span><span class="n">min</span><span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="w"> </span><span class="n">u</span><span class="err">̃</span><span class="p">))</span>
</pre></div>
</div>
</details><p>where qd and vd are desired configuration and velocity (see
get_desired_state_input_port()) for the actuated joint (see
JointActuator::joint()), Kp and Kd are the proportional and derivative
gains of the actuator (see JointActuator::get_controller_gains()),
<code class="docutils literal notranslate"><span class="pre">u_ff</span></code> is the feed-forward actuation specified with
get_actuation_input_port(), and <code class="docutils literal notranslate"><span class="pre">e</span></code> corresponds to effort limit (see
JointActuator::effort_limit()).</p>
<p>Notice that actuation through get_actuation_input_port() and PD
control are not mutually exclusive, and they can be used together.
This is better explained through examples: 1. <strong>PD controlled
gripper</strong>. In this case, only PD control is used to drive the opening
and closing of the fingers. The feed-forward term is assumed to be
zero and the actuation input port is not required to be connected. 2.
<strong>Robot arm</strong>. A typical configuration consists on applying gravity
compensation in the feed-forward term plus PD control to drive the
robot to a given desired state.</p>
<p>** Actuation input ports requirements</p>
<p>Actuation input ports and desired state input ports need not be
connected: - Unconnected actuation inputs default to zero, simplifying
diagram wiring for models relying solely on PD controllers. - PD
controllers are disarmed when their model instance’s desired state
input port is disconnected. In this state, they have no effect on
dynamics, behaving as if no PD controller exists. This allows a
MultibodyPlant model to be used outside simulation (e.g., for
visualization).</p>
<p>Note that both ports are always created but will be zero-sized for
model instances without actuation.</p>
<p>** Net actuation</p>
<p>The total joint actuation applied via the actuation input port
(get_actuation_input_port()) and applied by the PD controllers is
reported by the net actuation port (get_net_actuation_output_port()).
That is, the net actuation port reports the total actuation applied by
a given actuator.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>PD controllers are ignored when a joint is locked (see
Joint::Lock()), and thus they have no effect on the actuation
output.</p>
</div>
<p><a href="#id83"><span class="problematic" id="id84">**</span></a>** Loading models from SDFormat files</p>
<p>Drake has the capability to load multibody models from SDFormat and
URDF files. Consider the example below which loads an acrobot model:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">acrobot</span><span class="p">;</span>
<span class="n">SceneGraph</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">scene_graph</span><span class="p">;</span>
<span class="n">Parser</span><span class="w"> </span><span class="nf">parser</span><span class="p">(</span><span class="o">&amp;</span><span class="n">acrobot</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">scene_graph</span><span class="p">);</span>
<span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">url</span><span class="w"> </span><span class="o">=</span>
<span class="s">&quot;package://drake/multibody/benchmarks/acrobot/acrobot.sdf&quot;</span><span class="p">;</span>
<span class="n">parser</span><span class="p">.</span><span class="n">AddModelsFromUrl</span><span class="p">(</span><span class="n">url</span><span class="p">);</span>
</pre></div>
</div>
</details><p>As in the example above, for models including visual geometry,
collision geometry or both, the user must specify a SceneGraph for
geometry handling. You can find a full example of the LQR controlled
acrobot in examples/multibody/acrobot/run_lqr.cc.</p>
<p>AddModelFromFile() can be invoked multiple times on the same plant in
order to load multiple model instances. Other methods are available on
Parser such as AddModels() which allows creating model instances per
each <code class="docutils literal notranslate"><span class="pre">&lt;model&gt;</span></code> tag found in the file. Please refer to each of these
methods’ documentation for further details.</p>
<p><a href="#id85"><span class="problematic" id="id86">**</span></a>** Working with SceneGraph</p>
<p>** Adding a MultibodyPlant connected to a SceneGraph to your Diagram</p>
<p>Probably the simplest way to add and wire up a MultibodyPlant with a
SceneGraph in your Diagram is using AddMultibodyPlantSceneGraph().</p>
<p>Recommended usages:</p>
<p>Assign to a MultibodyPlant reference (ignoring the SceneGraph):</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">plant</span><span class="w"> </span><span class="o">=</span>
<span class="n">AddMultibodyPlantSceneGraph</span><span class="p">(</span><span class="o">&amp;</span><span class="n">builder</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="o">/+</span><span class="w"> </span><span class="n">time_step</span><span class="w"> </span><span class="o">+/</span><span class="p">);</span>
<span class="n">plant</span><span class="p">.</span><span class="n">DoFoo</span><span class="p">(...);</span>
</pre></div>
</div>
</details><p>This flavor is the simplest, when the SceneGraph is not explicitly
needed. (It can always be retrieved later via
GetSubsystemByName(“scene_graph”).)</p>
<p>Assign to auto, and use the named public fields:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="n">items</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AddMultibodyPlantSceneGraph</span><span class="p">(</span><span class="o">&amp;</span><span class="n">builder</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="o">/+</span><span class="w"> </span><span class="n">time_step</span><span class="w"> </span><span class="o">+/</span><span class="p">);</span>
<span class="n">items</span><span class="p">.</span><span class="n">plant</span><span class="p">.</span><span class="n">DoFoo</span><span class="p">(...);</span>
<span class="n">items</span><span class="p">.</span><span class="n">scene_graph</span><span class="p">.</span><span class="n">DoBar</span><span class="p">(...);</span>
</pre></div>
</div>
</details><p>or taking advantage of C++’s structured binding:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="p">[</span><span class="n">plant</span><span class="p">,</span><span class="w"> </span><span class="n">scene_graph</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AddMultibodyPlantSceneGraph</span><span class="p">(</span><span class="o">&amp;</span><span class="n">builder</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">);</span>
<span class="p">...</span>
<span class="n">plant</span><span class="p">.</span><span class="n">DoFoo</span><span class="p">(...);</span>
<span class="n">scene_graph</span><span class="p">.</span><span class="n">DoBar</span><span class="p">(...);</span>
</pre></div>
</div>
</details><p>This is the easiest way to use both the plant and scene_graph.</p>
<p>Assign to already-declared pointer variables:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;*</span><span class="w"> </span><span class="n">plant</span><span class="p">{};</span>
<span class="n">SceneGraph</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;*</span><span class="w"> </span><span class="n">scene_graph</span><span class="p">{};</span>
<span class="n">std</span><span class="o">::</span><span class="n">tie</span><span class="p">(</span><span class="n">plant</span><span class="p">,</span><span class="w"> </span><span class="n">scene_graph</span><span class="p">)</span><span class="w"> </span><span class="o">=</span>
<span class="n">AddMultibodyPlantSceneGraph</span><span class="p">(</span><span class="o">&amp;</span><span class="n">builder</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="o">/+</span><span class="w"> </span><span class="n">time_step</span><span class="w"> </span><span class="o">+/</span><span class="p">);</span>
<span class="n">plant</span><span class="o">-&gt;</span><span class="n">DoFoo</span><span class="p">(...);</span>
<span class="n">scene_graph</span><span class="o">-&gt;</span><span class="n">DoBar</span><span class="p">(...);</span>
</pre></div>
</div>
</details><p>This flavor is most useful when the pointers are class member fields
(and so perhaps cannot be references).</p>
<p>** Registering geometry with a SceneGraph</p>
<p>MultibodyPlant users can register geometry with a SceneGraph for
essentially two purposes; a) visualization and, b) contact modeling.</p>
<p>Before any geometry registration takes place, a user <strong>must</strong> first
make a call to RegisterAsSourceForSceneGraph() in order to register
the MultibodyPlant as a client of a SceneGraph instance, point at
which the plant will have assigned a valid geometry::SourceId. At
Finalize(), MultibodyPlant will declare input/output ports as
appropriate to communicate with the SceneGraph instance on which
registrations took place. All geometry registration <strong>must</strong> be
performed pre-finalize.</p>
<p>Multibodyplant declares an input port for geometric queries, see
get_geometry_query_input_port(). If MultibodyPlant registers geometry
with a SceneGraph via calls to RegisterCollisionGeometry(), users may
use this port for geometric queries. The port must be connected to the
same SceneGraph used for registration. The preferred mechanism is to
use AddMultibodyPlantSceneGraph() as documented above.</p>
<p>In extraordinary circumstances, this can be done by hand and the setup
process will include:</p>
<ol class="arabic simple">
<li><p>Call to RegisterAsSourceForSceneGraph().</p></li>
<li><p>Calls to RegisterCollisionGeometry(), as many as needed.</p></li>
<li><p>Call to Finalize(), user is done specifying the model.</p></li>
</ol>
<p>4. Connect geometry::SceneGraph::get_query_output_port() to
get_geometry_query_input_port().
5. Connect get_geometry_pose_output_port() to
geometry::SceneGraph::get_source_pose_port()</p>
<p>Refer to the documentation provided in each of the methods above for
further details.</p>
<p>** Accessing point contact parameters MultibodyPlant’s point contact
model looks for model parameters stored as
geometry::ProximityProperties by geometry::SceneGraph. These
properties can be obtained before or after context creation through
geometry::SceneGraphInspector APIs as outlined below. MultibodyPlant
expects the following properties for point contact modeling:</p>
<p><a href="#id139"><span class="problematic" id="id140">|Group name|Property Name|Required|Property Type|Property Description|</span></a>
<a href="#id141"><span class="problematic" id="id142">|:--------:|</span></a>:———–:<a href="#id143"><span class="problematic" id="id144">|:------:|</span></a>:—————-:<a href="#id145"><span class="problematic" id="id146">|:-------------------|</span></a>
<a href="#id147"><span class="problematic" id="id148">|material|coulomb_friction|yes¹|CoulombFriction&lt;T&gt;|Static and Dynamic
friction.|</span></a> <a href="#id149"><span class="problematic" id="id150">|material|point_contact_stiffness|no²|T|</span></a> Compliant point
contact stiffness.| <a href="#id151"><span class="problematic" id="id152">|material|hunt_crossley_dissipation |no²⁴|T|</span></a>
Compliant contact dissipation.|
<a href="#id153"><span class="problematic" id="id154">|material|relaxation_time|yes³⁴|T|Linear Kelvin–Voigt model
parameter.|</span></a></p>
<p>¹ Collision geometry is required to be registered with a
geometry::ProximityProperties object that contains the (“material”,
“coulomb_friction”) property. If the property is missing,
MultibodyPlant will throw an exception.</p>
<p>² If the property is missing, MultibodyPlant will use a heuristic
value as the default. Refer to the section point_contact_defaults
“Point Contact Default Parameters” for further details.</p>
<p>³ When using a linear Kelvin–Voigt model of dissipation (for instance
when selecting the SAP solver), collision geometry is required to be
registered with a geometry::ProximityProperties object that contains
the (“material”, “relaxation_time”) property. If the property is
missing, an exception will be thrown.</p>
<p>⁴ We allow to specify both hunt_crossley_dissipation and
relaxation_time for a given geometry. However only one of these will
get used, depending on the configuration of the MultibodyPlant. As an
example, if the SAP contact approximation is specified (see
set_discrete_contact_approximation()) only the relaxation_time is used
while hunt_crossley_dissipation is ignored. Conversely, if the TAMSI,
Similar or Lagged approximation is used (see
set_discrete_contact_approximation()) only hunt_crossley_dissipation
is used while relaxation_time is ignored. Currently, a continuous
MultibodyPlant model will always use the Hunt &amp; Crossley model and
relaxation_time will be ignored.</p>
<p>Accessing and modifying contact properties requires interfacing with
geometry::SceneGraph’s model inspector. Interfacing with a model
inspector obtained from geometry::SceneGraph will provide the default
registered values for a given parameter. These are the values that
will initially appear in a systems::Context created by
CreateDefaultContext(). Subsequently, true system parameters can be
accessed and changed through a systems::Context once available. For
both of the above cases, proximity properties are accessed through
geometry::SceneGraphInspector APIs.</p>
<p>Before context creation an inspector can be retrieved directly from
SceneGraph as:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// For a SceneGraph&lt;T&gt; instance called scene_graph.</span>
<span class="k">const</span><span class="w"> </span><span class="n">geometry</span><span class="o">::</span><span class="n">SceneGraphInspector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">inspector</span><span class="w"> </span><span class="o">=</span>
<span class="n">scene_graph</span><span class="p">.</span><span class="n">model_inspector</span><span class="p">();</span>
</pre></div>
</div>
</details><p>After context creation, an inspector can be retrieved from the state
stored in the context:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// For a MultibodyPlant&lt;T&gt; instance called mbp and a Context&lt;T&gt; called</span>
<span class="c1">// context.</span>
<span class="k">const</span><span class="w"> </span><span class="n">geometry</span><span class="o">::</span><span class="n">SceneGraphInspector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">inspector</span><span class="w"> </span><span class="o">=</span>
<span class="n">mbp</span><span class="p">.</span><span class="n">EvalSceneGraphInspector</span><span class="p">(</span><span class="n">context</span><span class="p">);</span>
</pre></div>
</div>
</details><p>Once an inspector is available, proximity properties can be retrieved
as:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// For a body with GeometryId called geometry_id</span>
<span class="k">const</span><span class="w"> </span><span class="n">geometry</span><span class="o">::</span><span class="n">ProximityProperties</span><span class="o">*</span><span class="w"> </span><span class="n">props</span><span class="w"> </span><span class="o">=</span>
<span class="n">inspector</span><span class="p">.</span><span class="n">GetProximityProperties</span><span class="p">(</span><span class="n">geometry_id</span><span class="p">);</span>
<span class="k">const</span><span class="w"> </span><span class="n">CoulombFriction</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">geometry_friction</span><span class="w"> </span><span class="o">=</span>
<span class="n">props</span><span class="o">-&gt;</span><span class="n">GetProperty</span><span class="o">&lt;</span><span class="n">CoulombFriction</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="s">&quot;material&quot;</span><span class="p">,</span>
<span class="s">&quot;coulomb_friction&quot;</span><span class="p">);</span>
</pre></div>
</div>
</details><p><a href="#id87"><span class="problematic" id="id88">**</span></a>** Working with MultibodyElement parameters Several
MultibodyElements expose parameters, allowing the user flexible
modification of some aspects of the plant’s model, post
systems::Context creation. For details, refer to the documentation for
the MultibodyElement whose parameters you are trying to modify/access
(e.g. RigidBody, FixedOffsetFrame, etc.)</p>
<p>As an example, here is how to access and modify rigid body mass
parameters:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">plant</span><span class="p">;</span>
<span class="c1">// ... Code to add bodies, finalize plant, and to obtain a context.</span>
<span class="k">const</span><span class="w"> </span><span class="n">RigidBody</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">body</span><span class="w"> </span><span class="o">=</span>
<span class="n">plant</span><span class="p">.</span><span class="n">GetRigidBodyByName</span><span class="p">(</span><span class="s">&quot;BodyName&quot;</span><span class="p">);</span>
<span class="k">const</span><span class="w"> </span><span class="n">SpatialInertia</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">M_BBo_B</span><span class="w"> </span><span class="o">=</span>
<span class="n">body</span><span class="p">.</span><span class="n">GetSpatialInertiaInBodyFrame</span><span class="p">(</span><span class="n">context</span><span class="p">);</span>
<span class="c1">// .. logic to determine a new SpatialInertia parameter for body.</span>
<span class="k">const</span><span class="w"> </span><span class="n">SpatialInertia</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">M_BBo_B_new</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">....</span>

<span class="c1">// Modify the body parameter for spatial inertia.</span>
<span class="n">body</span><span class="p">.</span><span class="n">SetSpatialInertiaInBodyFrame</span><span class="p">(</span><span class="o">&amp;</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="n">M_BBo_B_new</span><span class="p">);</span>
</pre></div>
</div>
</details><p>Another example, working with automatic differentiation in order to
take derivatives with respect to one of the bodies’ masses:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">plant</span><span class="p">;</span>
<span class="c1">// ... Code to add bodies, finalize plant, and to obtain a</span>
<span class="c1">// context and a body&#39;s spatial inertia M_BBo_B.</span>

<span class="c1">// Scalar convert the plant.</span>
<span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="n">AutoDiffXd</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">plant_autodiff</span><span class="w"> </span><span class="o">=</span>
<span class="n">systems</span><span class="o">::</span><span class="n">System</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">ToAutoDiffXd</span><span class="p">(</span><span class="n">plant</span><span class="p">);</span>
<span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Context</span><span class="o">&lt;</span><span class="n">AutoDiffXd</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">context_autodiff</span><span class="w"> </span><span class="o">=</span>
<span class="n">plant_autodiff</span><span class="o">-&gt;</span><span class="n">CreateDefaultContext</span><span class="p">();</span>
<span class="n">context_autodiff</span><span class="o">-&gt;</span><span class="n">SetTimeStateAndParametersFrom</span><span class="p">(</span><span class="n">context</span><span class="p">);</span>

<span class="k">const</span><span class="w"> </span><span class="n">RigidBody</span><span class="o">&lt;</span><span class="n">AutoDiffXd</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">body</span><span class="w"> </span><span class="o">=</span>
<span class="n">plant_autodiff</span><span class="o">-&gt;</span><span class="n">GetRigidBodyByName</span><span class="p">(</span><span class="s">&quot;BodyName&quot;</span><span class="p">);</span>

<span class="c1">// Modify the body parameter for mass.</span>
<span class="k">const</span><span class="w"> </span><span class="n">AutoDiffXd</span><span class="w"> </span><span class="nf">mass_autodiff</span><span class="p">(</span><span class="n">mass</span><span class="p">,</span><span class="w"> </span><span class="n">Vector1d</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
<span class="n">body</span><span class="p">.</span><span class="n">SetMass</span><span class="p">(</span><span class="n">context_autodiff</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span><span class="w"> </span><span class="n">mass_autodiff</span><span class="p">);</span>

<span class="c1">// M_autodiff(i, j).derivatives()(0), contains the derivatives of</span>
<span class="c1">// M(i, j) with respect to the body&#39;s mass.</span>
<span class="n">MatrixX</span><span class="o">&lt;</span><span class="n">AutoDiffXd</span><span class="o">&gt;</span><span class="w"> </span><span class="n">M_autodiff</span><span class="p">(</span><span class="n">plant_autodiff</span><span class="o">-&gt;</span><span class="n">num_velocities</span><span class="p">(),</span>
<span class="n">plant_autodiff</span><span class="o">-&gt;</span><span class="n">num_velocities</span><span class="p">());</span>
<span class="n">plant_autodiff</span><span class="o">-&gt;</span><span class="n">CalcMassMatrix</span><span class="p">(</span><span class="o">*</span><span class="n">context_autodiff</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">M_autodiff</span><span class="p">);</span>
</pre></div>
</div>
</details><p><a href="#id89"><span class="problematic" id="id90">**</span></a>** Adding modeling elements</p>
<p>Add multibody elements to a MultibodyPlant with methods like:</p>
<ul class="simple">
<li><p>Bodies: AddRigidBody()</p></li>
<li><p>Joints: AddJoint()</p></li>
<li><p>see mbp_construction “Construction” for more.</p></li>
</ul>
<p>All modeling elements <strong>must</strong> be added before Finalize() is called.
See mbp_finalize_stage “Finalize stage” for a discussion.</p>
<p><a href="#id91"><span class="problematic" id="id92">**</span></a>** Modeling contact</p>
<p>Please refer to drake_contacts “Contact Modeling in Drake” for details
on the available approximations, setup, and considerations for a
multibody simulation with frictional contact.</p>
<p><a href="#id93"><span class="problematic" id="id94">**</span></a>** Energy and Power</p>
<p>MultibodyPlant implements the System energy and power methods, with
some limitations. - Kinetic energy: fully implemented. - Potential
energy and conservative power: currently include only gravity and
contributions from ForceElement objects; potential energy from
compliant contact and joint limits are not included. - Nonconservative
power: currently includes only contributions from ForceElement
objects; actuation and input port forces, joint damping, and
dissipation from joint limits, friction, and contact dissipation are
not included.</p>
<p>See Drake issue #12942 for more discussion.</p>
<p><a href="#id95"><span class="problematic" id="id96">**</span></a>** Finalize() stage</p>
<p>Once the user is done adding modeling elements and registering
geometry, a call to Finalize() must be performed. This call will: -
Build the underlying tree structure of the multibody model, - declare
the plant’s state, - declare the plant’s input and output ports, -
declare collision filters to ignore collisions among rigid bodies: -
between rigid bodies connected by a joint, - within subgraphs of
welded rigid bodies.</p>
<p>Note that MultibodyPlant will <em>not</em> introduce any automatic collision
filters on deformable bodies. Collision filters for deformable bodies
can be explicitly applied via
ExcludeCollisionGeometriesWithCollisionFilterGroupPair() or during
parsing.</p>
<p><a href="#id97"><span class="problematic" id="id98">**</span></a>** References</p>
<ul class="simple">
<li><p>[Featherstone 2008] Featherstone, R., 2008.</p></li>
</ul>
<p>Rigid body dynamics algorithms. Springer.
- [Jain 2010] Jain, A., 2010.
Robot and multibody dynamics: analysis and algorithms.
Springer Science &amp; Business Media.
- [Seth 2010] Seth, A., Sherman, M., Eastman, P. and Delp, S., 2010.
Minimal formulation of joint motion for biomechanisms.
Nonlinear dynamics, 62(1), pp.291-303.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_step</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.__init__" title="Link to this definition"></a></dt>
<dd><p>This constructor creates a plant with a single “world” body.
Therefore, right after creation, num_bodies() returns one.</p>
<p>MultibodyPlant offers two different modalities to model mechanical
systems in time. These are: 1. As a discrete system with periodic
updates, <code class="docutils literal notranslate"><span class="pre">time_step</span></code> is strictly greater than zero. 2. As a
continuous system, <code class="docutils literal notranslate"><span class="pre">time_step</span></code> equals exactly zero.</p>
<p>Currently the discrete model is preferred for simulation given its
robustness and speed in problems with frictional contact. However this
might change as we work towards developing better strategies to model
contact. See multibody_simulation for further details.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Users should be aware of current limitations in either modeling
modality. While the discrete model is often the preferred option
for problems with frictional contact given its robustness and
speed, it might become unstable when using large feedback gains,
high damping or large external forcing. MultibodyPlant will throw
an exception whenever the discrete solver is detected to fail.
Conversely, the continuous modality has the potential to leverage
the robustness and accuracy control provide by Drake’s
integrators. However thus far this has proved difficult in
practice and especially due to poor performance.</p>
</div>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">time_step</span></code>:</dt><dd><p>Indicates whether <code class="docutils literal notranslate"><span class="pre">this</span></code> plant is modeled as a continuous system
(<code class="docutils literal notranslate"><span class="pre">time_step</span> <span class="pre">=</span> <span class="pre">0</span></code>) or as a discrete system with periodic updates
of period <code class="docutils literal notranslate"><span class="pre">time_step</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>. See multibody_simulation for further
details.</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Currently the continuous modality with <code class="docutils literal notranslate"><span class="pre">time_step</span> <span class="pre">=</span> <span class="pre">0</span></code> does not
support joint limits for simulation, these are ignored.
MultibodyPlant prints a warning to console if joint limits are
provided. If your simulation requires joint limits currently you
must use a discrete MultibodyPlant model.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if time_step is negative.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.AddBallConstraint">
<span class="sig-name descname"><span class="pre">AddBallConstraint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body_A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.RigidBody_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_AP</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.RigidBody_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_BQ</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.MultibodyConstraintId" title="pydrake.multibody.tree.MultibodyConstraintId"><span class="pre">pydrake.multibody.tree.MultibodyConstraintId</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.AddBallConstraint" title="Link to this definition"></a></dt>
<dd><p>Defines a constraint such that point P affixed to body A is coincident
at all times with point Q affixed to body B, effectively modeling a
ball-and-socket joint.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body_A</span></code>:</dt><dd><p>RigidBody to which point P is rigidly attached.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_AP</span></code>:</dt><dd><p>Position of point P in body A’s frame.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body_B</span></code>:</dt><dd><p>RigidBody to which point Q is rigidly attached.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BQ</span></code>:</dt><dd><p>(optional) Position of point Q in body B’s frame. If p_BQ is
std::nullopt, then p_BQ will be computed so that the constraint is
satisfied for the default configuration at Finalize() time;
subsequent changes to the default configuration will not change
the computed p_BQ.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>the id of the newly added constraint.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>RuntimeError if bodies A and B are the same body.</strong> – </p></li>
<li><p><strong>RuntimeError if the MultibodyPlant has already been finalized.</strong> – </p></li>
<li><p><strong>RuntimeError if this MultibodyPlant is not a discrete model</strong> – </p></li>
<li><p><strong>(</strong><strong>is_discrete</strong><strong>(</strong><strong>) </strong><strong>== false</strong><strong>)</strong> – </p></li>
<li><p><strong>RuntimeError if this MultibodyPlant's underlying contact</strong> – </p></li>
<li><p><strong>solver is not SAP.</strong><strong> (</strong><strong>i.e. get_discrete_contact_solver</strong><strong>(</strong><strong>) </strong><strong>!=</strong> – </p></li>
<li><p><strong>DiscreteContactSolver::kSap</strong><strong>)</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.AddCouplerConstraint">
<span class="sig-name descname"><span class="pre">AddCouplerConstraint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">joint0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.Joint_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">joint1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.Joint_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gear_ratio</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.0</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.MultibodyConstraintId" title="pydrake.multibody.tree.MultibodyConstraintId"><span class="pre">pydrake.multibody.tree.MultibodyConstraintId</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.AddCouplerConstraint" title="Link to this definition"></a></dt>
<dd><p>Defines a holonomic constraint between two single-dof joints
<code class="docutils literal notranslate"><span class="pre">joint0</span></code> and <code class="docutils literal notranslate"><span class="pre">joint1</span></code> with positions q₀ and q₁, respectively, such
that q₀ = ρ⋅q₁ + Δq, where ρ is the gear ratio and Δq is a fixed
offset. The gear ratio can have units if the units of q₀ and q₁ are
different. For instance, between a prismatic and a revolute joint the
gear ratio will specify the “pitch” of the resulting mechanism. As
defined, <code class="docutils literal notranslate"><span class="pre">offset</span></code> has units of <code class="docutils literal notranslate"><span class="pre">q₀</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>joint0 and/or joint1 can still be actuated, regardless of whether
we have coupler constraint among them. That is, one or both of
these joints can have external actuation applied to them.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Generally, to couple (q0, q1, q2), the user would define a coupler
between (q0, q1) and a second coupler between (q1, q2), or any
combination therein.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>if joint0 and joint1 are not both single-dof joints.</strong> – </p></li>
<li><p><strong>RuntimeError if the MultibodyPlant has already been finalized.</strong> – </p></li>
<li><p><strong>RuntimeError if this MultibodyPlant is not a discrete model</strong> – </p></li>
<li><p><strong>(</strong><strong>is_discrete</strong><strong>(</strong><strong>) </strong><strong>== false</strong><strong>)</strong> – </p></li>
<li><p><strong>RuntimeError if this MultibodyPlant's underlying contact</strong> – </p></li>
<li><p><strong>solver is not SAP.</strong><strong> (</strong><strong>i.e. get_discrete_contact_solver</strong><strong>(</strong><strong>) </strong><strong>!=</strong> – </p></li>
<li><p><strong>DiscreteContactSolver::kSap</strong><strong>)</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.AddDistanceConstraint">
<span class="sig-name descname"><span class="pre">AddDistanceConstraint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body_A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.RigidBody_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_AP</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.RigidBody_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_BQ</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stiffness</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">inf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">damping</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.0</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.MultibodyConstraintId" title="pydrake.multibody.tree.MultibodyConstraintId"><span class="pre">pydrake.multibody.tree.MultibodyConstraintId</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.AddDistanceConstraint" title="Link to this definition"></a></dt>
<dd><p>Defines a distance constraint between a point P on a body A and a
point Q on a body B.</p>
<p>This constraint can be compliant, modeling a spring with free length
<code class="docutils literal notranslate"><span class="pre">distance</span></code> and given <code class="docutils literal notranslate"><span class="pre">stiffness</span></code> and <code class="docutils literal notranslate"><span class="pre">damping</span></code> parameters
between points P and Q. For d = ‖p_PQ‖, then a compliant distance
constraint models a spring with force along p_PQ given by:</p>
<p>f = −stiffness ⋅ d − damping ⋅ ḋ</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body_A</span></code>:</dt><dd><p>RigidBody to which point P is rigidly attached.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_AP</span></code>:</dt><dd><p>Position of point P in body A’s frame.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body_B</span></code>:</dt><dd><p>RigidBody to which point Q is rigidly attached.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BQ</span></code>:</dt><dd><p>Position of point Q in body B’s frame.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">distance</span></code>:</dt><dd><p>Fixed length of the distance constraint, in meters. It must be
strictly positive.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">stiffness</span></code>:</dt><dd><p>For modeling a spring with free length equal to <code class="docutils literal notranslate"><span class="pre">distance</span></code>, the
stiffness parameter in N/m. Optional, with its default value being
infinite to model a rigid massless rod of length <code class="docutils literal notranslate"><span class="pre">distance</span></code>
connecting points A and B.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">damping</span></code>:</dt><dd><p>For modeling a spring with free length equal to <code class="docutils literal notranslate"><span class="pre">distance</span></code>,
damping parameter in N⋅s/m. Optional, with its default value being
zero for a non-dissipative constraint.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>the id of the newly added constraint.</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Currently, it is the user’s responsibility to initialize the
model’s context in a configuration compatible with the newly added
constraint.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>A distance constraint is the wrong modeling choice if the distance
needs to go through zero. To constrain two points to be coincident
we need a 3-dof ball constraint, the 1-dof distance constraint is
singular in this case. Therefore we require the distance parameter
to be strictly positive.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When a new context is created, a DistanceConstraintParams is
initialized to store the parameters passed to this function.
Parameters in the context can be modified with calls to
SetDistanceConstraintParams().</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if bodies A and B are the same body.</strong> – </p></li>
<li><p><strong>RuntimeError if distance is not strictly positive.</strong> – </p></li>
<li><p><strong>RuntimeError if stiffness is not positive</strong><strong> or </strong><strong>zero.</strong> – </p></li>
<li><p><strong>RuntimeError if damping is not positive</strong><strong> or </strong><strong>zero.</strong> – </p></li>
<li><p><strong>RuntimeError if the MultibodyPlant has already been finalized.</strong> – </p></li>
<li><p><strong>RuntimeError if this MultibodyPlant is not a discrete model</strong> – </p></li>
<li><p><strong>(</strong><strong>is_discrete</strong><strong>(</strong><strong>) </strong><strong>== false</strong><strong>)</strong> – </p></li>
<li><p><strong>RuntimeError if this MultibodyPlant's underlying contact</strong> – </p></li>
<li><p><strong>solver is not SAP.</strong><strong> (</strong><strong>i.e. get_discrete_contact_solver</strong><strong>(</strong><strong>) </strong><strong>!=</strong> – </p></li>
<li><p><strong>DiscreteContactSolver::kSap</strong><strong>)</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.AddForceElement">
<span class="sig-name descname"><span class="pre">AddForceElement</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">force_element</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.ForceElement_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.multibody.tree.ForceElement_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.AddForceElement" title="Link to this definition"></a></dt>
<dd><p>Adds a new force element model of type <code class="docutils literal notranslate"><span class="pre">ForceElementType</span></code> to
<code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant. The arguments to this method <code class="docutils literal notranslate"><span class="pre">args</span></code> are
forwarded to <a href="#id99"><span class="problematic" id="id100">``</span></a>ForceElementType`’s constructor.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">args</span></code>:</dt><dd><p>Zero or more parameters provided to the constructor of the new
force element. It must be the case that
<cite>ForceElementType&lt;T&gt;(args)`</cite> is a valid constructor.</p>
</dd>
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">ForceElementType</span></code>:</dt><dd><p>The type of the ForceElement to add. As there is always a
UniformGravityFieldElement present (accessible through
gravity_field()), an exception will be thrown if this function is
called to add another UniformGravityFieldElement.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A constant reference to the new ForceElement just added, of type
<code class="docutils literal notranslate"><span class="pre">ForceElementType&lt;T&gt;</span></code> specialized on the scalar type T of
<code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant. It will remain valid for the lifetime of
<code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>The ForceElement class’s documentation for further details on how
a force element is defined.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.AddFrame">
<span class="sig-name descname"><span class="pre">AddFrame</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.Frame_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.multibody.tree.Frame_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.AddFrame" title="Link to this definition"></a></dt>
<dd><p>This method adds a Frame of type <code class="docutils literal notranslate"><span class="pre">FrameType&lt;T&gt;</span></code>. For more
information, please see the corresponding constructor of
<code class="docutils literal notranslate"><span class="pre">FrameType</span></code>.</p>
<dl class="simple">
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">FrameType</span></code>:</dt><dd><p>Template which will be instantiated on <code class="docutils literal notranslate"><span class="pre">T</span></code>.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame</span></code>:</dt><dd><p>Unique pointer frame instance.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A constant reference to the new Frame just added, which will
remain valid for the lifetime of <code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.AddJoint">
<span class="sig-name descname"><span class="pre">AddJoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">joint</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.Joint_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.multibody.tree.Joint_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.AddJoint" title="Link to this definition"></a></dt>
<dd><p>This method adds a Joint of type <code class="docutils literal notranslate"><span class="pre">JointType</span></code> between two bodies. For
more information, see the below overload of <code class="docutils literal notranslate"><span class="pre">AddJoint&lt;&gt;</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.AddJointActuator">
<span class="sig-name descname"><span class="pre">AddJointActuator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">joint</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.Joint_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">effort_limit</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">inf</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.multibody.tree.JointActuator_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.AddJointActuator" title="Link to this definition"></a></dt>
<dd><p>Creates and adds a JointActuator model for an actuator acting on a
given <code class="docutils literal notranslate"><span class="pre">joint</span></code>. This method returns a constant reference to the
actuator just added, which will remain valid for the lifetime of
<code class="docutils literal notranslate"><span class="pre">this</span></code> plant.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">name</span></code>:</dt><dd><p>A string that uniquely identifies the new actuator to be added to
<code class="docutils literal notranslate"><span class="pre">this</span></code> model. A RuntimeError is thrown if an actuator with the
same name already exists in the model. See
HasJointActuatorNamed().</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">joint</span></code>:</dt><dd><p>The Joint to be actuated by the new JointActuator.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">effort_limit</span></code>:</dt><dd><p>The maximum effort for the actuator. It must be strictly positive,
otherwise an RuntimeError is thrown. If +∞, the actuator has no
limit, which is the default. The effort limit has physical units
in accordance to the joint type it actuates. For instance, it will
have units of N⋅m (torque) for revolute joints while it will have
units of N (force) for prismatic joints.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The effort limit is unused by MultibodyPlant and is simply
provided here for bookkeeping purposes. It will not, for instance,
saturate external actuation inputs based on this value. If, for
example, a user intends to saturate the force/torque that is
applied to the MultibodyPlant via this actuator, the user-level
code (e.g., a controller) should query this effort limit and
impose the saturation there.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A constant reference to the new JointActuator just added, which
will remain valid for the lifetime of <code class="docutils literal notranslate"><span class="pre">this</span></code> plant or until the
JointActuator has been removed from the plant with
RemoveJointActuator().</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>RuntimeError if joint.num_velocities</strong><strong>(</strong><strong>) </strong><strong>&gt; 1 since for now we</strong> – </p></li>
<li><p><strong>only support actuators for single dof joints.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>RemoveJointActuator()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.AddModelInstance">
<span class="sig-name descname"><span class="pre">AddModelInstance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.AddModelInstance" title="Link to this definition"></a></dt>
<dd><p>Creates a new model instance. Returns the index for the model
instance.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">name</span></code>:</dt><dd><p>A string that uniquely identifies the new instance to be added to
<code class="docutils literal notranslate"><span class="pre">this</span></code> model. An exception is thrown if an instance with the
same name already exists in the model. See
HasModelInstanceNamed().</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.AddRigidBody">
<span class="sig-name descname"><span class="pre">AddRigidBody</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.AddRigidBody" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>AddRigidBody(self: pydrake.multibody.plant.MultibodyPlant_[Expression], name: str, M_BBo_B: pydrake.multibody.tree.SpatialInertia = SpatialInertia.Zero()) -&gt; pydrake.multibody.tree.RigidBody_[Expression]</p></li>
</ol>
<p>Creates a rigid body with the provided name and spatial inertia. This
method returns a constant reference to the body just added, which will
remain valid for the lifetime of <code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant. The body
will use the default model instance (model_instance “more on model
instances”).</p>
<p>Example of usage:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">plant</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// ... Code to define spatial_inertia, a SpatialInertia&lt;T&gt; object ...</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">RigidBody</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">body</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="n">plant</span><span class="p">.</span><span class="n">AddRigidBody</span><span class="p">(</span><span class="s">&quot;BodyName&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">spatial_inertia</span><span class="p">);</span>
</pre></div>
</div>
</details><dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">name</span></code>:</dt><dd><p>A string that identifies the new body to be added to <code class="docutils literal notranslate"><span class="pre">this</span></code>
model. A RuntimeError is thrown if a body named <code class="docutils literal notranslate"><span class="pre">name</span></code> already
is part of the model in the default model instance. See
HasBodyNamed(), RigidBody::name().</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">M_BBo_B</span></code>:</dt><dd><p>The SpatialInertia of the new rigid body to be added to <code class="docutils literal notranslate"><span class="pre">this</span></code>
MultibodyPlant, computed about the body frame origin <code class="docutils literal notranslate"><span class="pre">Bo</span></code> and
expressed in the body frame B. When not provided, defaults to
zero.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A constant reference to the new RigidBody just added, which will
remain valid for the lifetime of <code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>RuntimeError if additional model instances have been created</strong> – </p></li>
<li><p><strong>beyond the world and default instances.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>AddRigidBody(self: pydrake.multibody.plant.MultibodyPlant_[Expression], name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex, M_BBo_B: pydrake.multibody.tree.SpatialInertia = SpatialInertia.Zero()) -&gt; pydrake.multibody.tree.RigidBody_[Expression]</p></li>
</ol>
<p>Creates a rigid body with the provided name and spatial inertia. This
method returns a constant reference to the body just added, which will
remain valid for the lifetime of <code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant.</p>
<p>Example of usage:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">plant</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// ... Code to define spatial_inertia, a SpatialInertia&lt;T&gt; object ...</span>
<span class="w">  </span><span class="n">ModelInstanceIndex</span><span class="w"> </span><span class="n">model_instance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">plant</span><span class="p">.</span><span class="n">AddModelInstance</span><span class="p">(</span><span class="s">&quot;instance&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">RigidBody</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">body</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="n">plant</span><span class="p">.</span><span class="n">AddRigidBody</span><span class="p">(</span><span class="s">&quot;BodyName&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">model_instance</span><span class="p">,</span><span class="w"> </span><span class="n">spatial_inertia</span><span class="p">);</span>
</pre></div>
</div>
</details><dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">name</span></code>:</dt><dd><p>A string that identifies the new body to be added to <code class="docutils literal notranslate"><span class="pre">this</span></code>
model. A RuntimeError is thrown if a body named <code class="docutils literal notranslate"><span class="pre">name</span></code> already
is part of <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>. See HasBodyNamed(),
RigidBody::name().</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>:</dt><dd><p>A model instance index which this body is part of.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">M_BBo_B</span></code>:</dt><dd><p>The SpatialInertia of the new rigid body to be added to <code class="docutils literal notranslate"><span class="pre">this</span></code>
MultibodyPlant, computed about the body frame origin <code class="docutils literal notranslate"><span class="pre">Bo</span></code> and
expressed in the body frame B. When not provided, defaults to
zero.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A constant reference to the new RigidBody just added, which will
remain valid for the lifetime of <code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.AddWeldConstraint">
<span class="sig-name descname"><span class="pre">AddWeldConstraint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body_A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.RigidBody_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X_AP</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.math.html#pydrake.math.RigidTransform" title="pydrake.math.RigidTransform"><span class="pre">pydrake.math.RigidTransform</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">body_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.RigidBody_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X_BQ</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.math.html#pydrake.math.RigidTransform" title="pydrake.math.RigidTransform"><span class="pre">pydrake.math.RigidTransform</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.MultibodyConstraintId" title="pydrake.multibody.tree.MultibodyConstraintId"><span class="pre">pydrake.multibody.tree.MultibodyConstraintId</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.AddWeldConstraint" title="Link to this definition"></a></dt>
<dd><p>Defines a constraint such that frame P affixed to body A is coincident
at all times with frame Q affixed to body B, effectively modeling a
weld joint.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body_A</span></code>:</dt><dd><p>RigidBody to which frame P is rigidly attached.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">X_AP</span></code>:</dt><dd><p>Pose of frame P in body A’s frame.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body_B</span></code>:</dt><dd><p>RigidBody to which frame Q is rigidly attached.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">X_BQ</span></code>:</dt><dd><p>Pose of frame Q in body B’s frame.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>the id of the newly added constraint.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>RuntimeError if bodies A and B are the same body.</strong> – </p></li>
<li><p><strong>RuntimeError if the MultibodyPlant has already been finalized.</strong> – </p></li>
<li><p><strong>RuntimeError if this MultibodyPlant is not a discrete model</strong> – </p></li>
<li><p><strong>(</strong><strong>is_discrete</strong><strong>(</strong><strong>) </strong><strong>== false</strong><strong>)</strong> – </p></li>
<li><p><strong>RuntimeError if this MultibodyPlant's underlying contact</strong> – </p></li>
<li><p><strong>solver is not SAP.</strong><strong> (</strong><strong>i.e. get_discrete_contact_solver</strong><strong>(</strong><strong>) </strong><strong>!=</strong> – </p></li>
<li><p><strong>DiscreteContactSolver::kSap</strong><strong>)</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcBiasCenterOfMassTranslationalAcceleration">
<span class="sig-name descname"><span class="pre">CalcBiasCenterOfMassTranslationalAcceleration</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcBiasCenterOfMassTranslationalAcceleration" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>CalcBiasCenterOfMassTranslationalAcceleration(self: pydrake.multibody.plant.MultibodyPlant_[Expression], context: pydrake.systems.framework.Context_[Expression], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_A: pydrake.multibody.tree.Frame_[Expression], frame_E: pydrake.multibody.tree.Frame_[Expression]) -&gt; numpy.ndarray[object[3, 1]]</p></li>
</ol>
<p>For the system S of all bodies other than the world body, calculates
a𝑠Bias_AScm_E, Scm’s translational acceleration bias in frame A with
respect to “speeds” 𝑠, expressed in frame E, where Scm is the center
of mass of S and speeds 𝑠 is either q̇ or v.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>Contains the state of the multibody system.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">with_respect_to</span></code>:</dt><dd><p>Enum equal to JacobianWrtVariable::kQDot or
JacobianWrtVariable::kV, indicating whether the accceleration bias
is with respect to 𝑠 = q̇ or 𝑠 = v. Currently, an exception is
thrown if with_respect_to is JacobianWrtVariable::kQDot.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_A</span></code>:</dt><dd><p>The frame in which a𝑠Bias_AScm is measured.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_E</span></code>:</dt><dd><p>The frame in which a𝑠Bias_AScm is expressed on output.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a𝑠Bias_AScm_E Point Scm’s translational acceleration bias in frame
A with respect to speeds 𝑠 (𝑠 = q̇ or 𝑠 = v), expressed in frame
E.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>RuntimeError if this has no body except world_body</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p></li>
<li><p><strong>RuntimeError if mₛ ≤ 0</strong><strong>, </strong><strong>where mₛ is the mass</strong><strong> of </strong><strong>system S.</strong> – </p></li>
<li><p><strong>RuntimeError if with_respect_to is JacobianWrtVariable::kQDot.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcJacobianCenterOfMassTranslationalVelocity() to compute
J𝑠_v_Scm, point Scm’s translational velocity Jacobian in frame A
with respect to 𝑠.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The world_body() is ignored. asBias_AScm_E = ∑ (mᵢ aᵢ) / mₛ, where
mₛ = ∑ mᵢ is the mass of system S, mᵢ is the mass of the iᵗʰ body,
and aᵢ is the translational bias acceleration of Bᵢcm in frame A
expressed in frame E for speeds 𝑠 (Bᵢcm is the center of mass of
the iᵗʰ body).</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>See bias_acceleration_functions “Bias acceleration functions” for
theory and details.</p>
</div>
<ol class="arabic simple" start="2">
<li><p>CalcBiasCenterOfMassTranslationalAcceleration(self: pydrake.multibody.plant.MultibodyPlant_[Expression], context: pydrake.systems.framework.Context_[Expression], model_instances: list[pydrake.multibody.tree.ModelInstanceIndex], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_A: pydrake.multibody.tree.Frame_[Expression], frame_E: pydrake.multibody.tree.Frame_[Expression]) -&gt; numpy.ndarray[object[3, 1]]</p></li>
</ol>
<p>For the system S containing the selected model instances, calculates
a𝑠Bias_AScm_E, Scm’s translational acceleration bias in frame A with
respect to “speeds” 𝑠, expressed in frame E, where Scm is the center
of mass of S and speeds 𝑠 is either q̇ or v.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>Contains the state of the multibody system.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">model_instances</span></code>:</dt><dd><p>Vector of selected model instances. If a model instance is
repeated in the vector (unusual), it is only counted once.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">with_respect_to</span></code>:</dt><dd><p>Enum equal to JacobianWrtVariable::kQDot or
JacobianWrtVariable::kV, indicating whether the accceleration bias
is with respect to 𝑠 = q̇ or 𝑠 = v. Currently, an exception is
thrown if with_respect_to is JacobianWrtVariable::kQDot.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_A</span></code>:</dt><dd><p>The frame in which a𝑠Bias_AScm is measured.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_E</span></code>:</dt><dd><p>The frame in which a𝑠Bias_AScm is expressed on output.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a𝑠Bias_AScm_E Point Scm’s translational acceleration bias in frame
A with respect to speeds 𝑠 (𝑠 = q̇ or 𝑠 = v), expressed in frame
E.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>RuntimeError if this has no body except world_body</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p></li>
<li><p><strong>RuntimeError if mₛ ≤ 0</strong><strong>, </strong><strong>where mₛ is the mass</strong><strong> of </strong><strong>system S.</strong> – </p></li>
<li><p><strong>RuntimeError if with_respect_to is JacobianWrtVariable::kQDot.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcJacobianCenterOfMassTranslationalVelocity() to compute
J𝑠_v_Scm, point Scm’s translational velocity Jacobian in frame A
with respect to 𝑠.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The world_body() is ignored. asBias_AScm_E = ∑ (mᵢ aᵢ) / mₛ, where
mₛ = ∑ mᵢ is the mass of system S, mᵢ is the mass of the iᵗʰ body,
and aᵢ is the translational bias acceleration of Bᵢcm in frame A
expressed in frame E for speeds 𝑠 (Bᵢcm is the center of mass of
the iᵗʰ body).</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>See bias_acceleration_functions “Bias acceleration functions” for
theory and details.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcBiasSpatialAcceleration">
<span class="sig-name descname"><span class="pre">CalcBiasSpatialAcceleration</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.systems.framework.Context_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_respect_to</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JacobianWrtVariable" title="pydrake.multibody.tree.JacobianWrtVariable"><span class="pre">pydrake.multibody.tree.JacobianWrtVariable</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.Frame_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_BoBp_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.Frame_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_E</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.Frame_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.multibody.math.SpatialAcceleration_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcBiasSpatialAcceleration" title="Link to this definition"></a></dt>
<dd><p>For one point Bp affixed/welded to a frame B, calculates A𝑠Bias_ABp,
Bp’s spatial acceleration bias in frame A with respect to “speeds” 𝑠,
expressed in frame E, where speeds 𝑠 is either q̇ or v.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>Contains the state of the multibody system.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">with_respect_to</span></code>:</dt><dd><p>Enum equal to JacobianWrtVariable::kQDot or
JacobianWrtVariable::kV, indicating whether the spatial
accceleration bias is with respect to 𝑠 = q̇ or 𝑠 = v. Currently,
an exception is thrown if with_respect_to is
JacobianWrtVariable::kQDot.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_B</span></code>:</dt><dd><p>The frame on which point Bp is affixed/welded.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BoBp_B</span></code>:</dt><dd><p>Position vector from Bo (frame_B’s origin) to point Bp (regarded
as affixed/welded to B), expressed in frame_B.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_A</span></code>:</dt><dd><p>The frame in which A𝑠Bias_ABp is measured.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_E</span></code>:</dt><dd><p>The frame in which A𝑠Bias_ABp is expressed on output.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A𝑠Bias_ABp_E Point Bp’s spatial acceleration bias in frame A with
respect to speeds 𝑠 (𝑠 = q̇ or 𝑠 = v), expressed in frame E.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcJacobianSpatialVelocity() to compute J𝑠_V_ABp, point Bp’s
spatial velocity Jacobian in frame A with respect to 𝑠.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if with_respect_to is JacobianWrtVariable::kQDot.</strong> – </p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Use CalcBiasTranslationalAcceleration() to efficiently calculate
bias translational accelerations for a list of points (each fixed
to frame B). This function returns only one bias spatial
acceleration, which contains both frame B’s bias angular
acceleration and point Bp’s bias translational acceleration.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>See bias_acceleration_functions “Bias acceleration functions” for
theory and details.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcBiasTerm">
<span class="sig-name descname"><span class="pre">CalcBiasTerm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.systems.framework.Context_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcBiasTerm" title="Link to this definition"></a></dt>
<dd><p>Computes the bias term <code class="docutils literal notranslate"><span class="pre">C(q,</span> <span class="pre">v)</span> <span class="pre">v</span></code> containing Coriolis, centripetal,
and gyroscopic effects in the multibody equations of motion:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">M</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="w"> </span><span class="n">v</span><span class="err">̇</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">C</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tau_app</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="err">∑</span><span class="w"> </span><span class="p">(</span><span class="n">Jv_V_WBᵀ</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="w"> </span><span class="err">⋅</span><span class="w"> </span><span class="n">Fapp_Bo_W</span><span class="p">)</span>
</pre></div>
</div>
</details><p>where <code class="docutils literal notranslate"><span class="pre">M(q)</span></code> is the multibody model’s mass matrix (including rigid
body mass properties and reflected_inertia “reflected inertias”) and
<code class="docutils literal notranslate"><span class="pre">tau_app</span></code> is a vector of applied generalized forces. The last term
is a summation over all bodies of the dot-product of <code class="docutils literal notranslate"><span class="pre">Fapp_Bo_W</span></code>
(applied spatial force on body B at Bo) with <code class="docutils literal notranslate"><span class="pre">Jv_V_WB(q)</span></code> (B’s
spatial Jacobian in world W with respect to generalized velocities v).
Note: B’s spatial velocity in W can be written <code class="docutils literal notranslate"><span class="pre">V_WB</span> <span class="pre">=</span> <span class="pre">Jv_V_WB</span> <span class="pre">*</span> <span class="pre">v</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>Contains the state of the multibody system, including the
generalized positions q and the generalized velocities v.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">Cv</span></code>:</dt><dd><p>On output, <code class="docutils literal notranslate"><span class="pre">Cv</span></code> will contain the product <code class="docutils literal notranslate"><span class="pre">C(q,</span> <span class="pre">v)v</span></code>. It must
be a valid (non-null) pointer to a column vector in <code class="docutils literal notranslate"><span class="pre">ℛⁿ</span></code> with n
the number of generalized velocities (num_velocities()) of the
model. This method aborts if Cv is nullptr or if it does not have
the proper size.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcBiasTranslationalAcceleration">
<span class="sig-name descname"><span class="pre">CalcBiasTranslationalAcceleration</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.systems.framework.Context_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_respect_to</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JacobianWrtVariable" title="pydrake.multibody.tree.JacobianWrtVariable"><span class="pre">pydrake.multibody.tree.JacobianWrtVariable</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.Frame_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_BoBi_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.f_contiguous</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.Frame_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_E</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.Frame_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcBiasTranslationalAcceleration" title="Link to this definition"></a></dt>
<dd><p>For each point Bi affixed/welded to a frame B, calculates a𝑠Bias_ABi,
Bi’s translational acceleration bias in frame A with respect to
“speeds” 𝑠, expressed in frame E, where speeds 𝑠 is either q̇ or v.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>Contains the state of the multibody system.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">with_respect_to</span></code>:</dt><dd><p>Enum equal to JacobianWrtVariable::kQDot or
JacobianWrtVariable::kV, indicating whether the translational
acceleration bias is with respect to 𝑠 = q̇ or 𝑠 = v. Currently,
an exception is thrown if with_respect_to is
JacobianWrtVariable::kQDot.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_B</span></code>:</dt><dd><p>The frame on which points Bi are affixed/welded.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BoBi_B</span></code>:</dt><dd><p>A position vector or list of p position vectors from Bo (frame_B’s
origin) to points Bi (regarded as affixed to B), where each
position vector is expressed in frame_B. Each column in the <code class="docutils literal notranslate"><span class="pre">3</span> <span class="pre">x</span>
<span class="pre">p</span></code> matrix p_BoBi_B corresponds to a position vector.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_A</span></code>:</dt><dd><p>The frame in which a𝑠Bias_ABi is measured.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_E</span></code>:</dt><dd><p>The frame in which a𝑠Bias_ABi is expressed on output.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a𝑠Bias_ABi_E Point Bi’s translational acceleration bias in frame A
with respect to speeds 𝑠 (𝑠 = q̇ or 𝑠 = v), expressed in frame E.
a𝑠Bias_ABi_E is a <code class="docutils literal notranslate"><span class="pre">3</span> <span class="pre">x</span> <span class="pre">p</span></code> matrix, where p is the number of
points Bi.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcJacobianTranslationalVelocity() to compute J𝑠_v_ABi, point
Bi’s translational velocity Jacobian in frame A with respect to 𝑠.</p>
</div>
<dl class="simple">
<dt>Precondition:</dt><dd><p>p_BoBi_B must have 3 rows.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if with_respect_to is JacobianWrtVariable::kQDot.</strong> – </p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>See bias_acceleration_functions “Bias acceleration functions” for
theory and details.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcCenterOfMassPositionInWorld">
<span class="sig-name descname"><span class="pre">CalcCenterOfMassPositionInWorld</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcCenterOfMassPositionInWorld" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>CalcCenterOfMassPositionInWorld(self: pydrake.multibody.plant.MultibodyPlant_[Expression], context: pydrake.systems.framework.Context_[Expression]) -&gt; numpy.ndarray[object[3, 1]]</p></li>
</ol>
<p>Calculates the position vector from the world origin Wo to the center
of mass of all bodies in this MultibodyPlant, expressed in the world
frame W.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>Contains the state of the model.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">p_WoScm_W</span></code>:</dt><dd><p>position vector from Wo to Scm expressed in world frame W, where
Scm is the center of mass of the system S stored by <code class="docutils literal notranslate"><span class="pre">this</span></code>
plant.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if this has no body except world_body</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p></li>
<li><p><strong>RuntimeError if mₛ ≤ 0</strong><strong> (</strong><strong>where mₛ is the mass</strong><strong> of </strong><strong>system S</strong><strong>)</strong><strong>.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The world_body() is ignored. p_WoScm_W = ∑ (mᵢ pᵢ) / mₛ, where mₛ
= ∑ mᵢ, mᵢ is the mass of the iᵗʰ body, and pᵢ is Bᵢcm’s position
from Wo expressed in frame W (Bᵢcm is the center of mass of the
iᵗʰ body).</p>
</div>
<ol class="arabic simple" start="2">
<li><p>CalcCenterOfMassPositionInWorld(self: pydrake.multibody.plant.MultibodyPlant_[Expression], context: pydrake.systems.framework.Context_[Expression], model_instances: list[pydrake.multibody.tree.ModelInstanceIndex]) -&gt; numpy.ndarray[object[3, 1]]</p></li>
</ol>
<p>Calculates the position vector from the world origin Wo to the center
of mass of all non-world bodies contained in model_instances,
expressed in the world frame W.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>Contains the state of the model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">model_instances</span></code>:</dt><dd><p>Vector of selected model instances. If a model instance is
repeated in the vector (unusual), it is only counted once.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">p_WoScm_W</span></code>:</dt><dd><p>position vector from world origin Wo to Scm expressed in the world
frame W, where Scm is the center of mass of the system S of
non-world bodies contained in model_instances.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if model_instances is empty</strong><strong> or </strong><strong>only has world body.</strong> – </p></li>
<li><p><strong>RuntimeError if mₛ ≤ 0</strong><strong> (</strong><strong>where mₛ is the mass</strong><strong> of </strong><strong>system S</strong><strong>)</strong><strong>.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The world_body() is ignored. p_WoScm_W = ∑ (mᵢ pᵢ) / mₛ, where mₛ
= ∑ mᵢ, mᵢ is the mass of the iᵗʰ body contained in
model_instances, and pᵢ is Bᵢcm’s position vector from Wo
expressed in frame W (Bᵢcm is the center of mass of the iᵗʰ body).</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcCenterOfMassTranslationalAccelerationInWorld">
<span class="sig-name descname"><span class="pre">CalcCenterOfMassTranslationalAccelerationInWorld</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcCenterOfMassTranslationalAccelerationInWorld" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>CalcCenterOfMassTranslationalAccelerationInWorld(self: pydrake.multibody.plant.MultibodyPlant_[Expression], context: pydrake.systems.framework.Context_[Expression]) -&gt; numpy.ndarray[object[3, 1]]</p></li>
</ol>
<p>For the system S contained in this MultibodyPlant, calculates Scm’s
translational acceleration in the world frame W expressed in W, where
Scm is the center of mass of S.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context contains the state of the model.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">a_WScm_W</span></code>:</dt><dd><p>Scm’s translational acceleration in the world frame W expressed in
the world frame W.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if this has no body except world_body</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p></li>
<li><p><strong>RuntimeError if mₛ ≤ 0</strong><strong>, </strong><strong>where mₛ is the mass</strong><strong> of </strong><strong>system S.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The world_body() is ignored. a_WScm_W = ∑ (mᵢ aᵢ) / mₛ, where mₛ =
∑ mᵢ is the mass of system S, mᵢ is the mass of the iᵗʰ body, and
aᵢ is the translational acceleration of Bᵢcm in world W expressed
in W (Bᵢcm is the center of mass of the iᵗʰ body).</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When cached values are out of sync with the state stored in
context, this method performs an expensive forward dynamics
computation, whereas once evaluated, successive calls to this
method are inexpensive.</p>
</div>
<ol class="arabic simple" start="2">
<li><p>CalcCenterOfMassTranslationalAccelerationInWorld(self: pydrake.multibody.plant.MultibodyPlant_[Expression], context: pydrake.systems.framework.Context_[Expression], model_instances: list[pydrake.multibody.tree.ModelInstanceIndex]) -&gt; numpy.ndarray[object[3, 1]]</p></li>
</ol>
<p>For the system S containing the selected model instances, calculates
Scm’s translational acceleration in the world frame W expressed in W,
where Scm is the center of mass of S.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context contains the state of the model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">model_instances</span></code>:</dt><dd><p>Vector of selected model instances. If a model instance is
repeated in the vector (unusual), it is only counted once.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">a_WScm_W</span></code>:</dt><dd><p>Scm’s translational acceleration in the world frame W expressed in
the world frame W.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if model_instances is empty</strong><strong> or </strong><strong>only has world body.</strong> – </p></li>
<li><p><strong>RuntimeError if mₛ ≤ 0</strong><strong>, </strong><strong>where mₛ is the mass</strong><strong> of </strong><strong>system S.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The world_body() is ignored. a_WScm_W = ∑ (mᵢ aᵢ) / mₛ, where mₛ =
∑ mᵢ is the mass of system S, mᵢ is the mass of the iᵗʰ body in
model_instances, and aᵢ is the translational acceleration of Bᵢcm
in world W expressed in W (Bᵢcm is the center of mass of the iᵗʰ
body).</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When cached values are out of sync with the state stored in
context, this method performs an expensive forward dynamics
computation, whereas once evaluated, successive calls to this
method are inexpensive.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcCenterOfMassTranslationalVelocityInWorld">
<span class="sig-name descname"><span class="pre">CalcCenterOfMassTranslationalVelocityInWorld</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcCenterOfMassTranslationalVelocityInWorld" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>CalcCenterOfMassTranslationalVelocityInWorld(self: pydrake.multibody.plant.MultibodyPlant_[Expression], context: pydrake.systems.framework.Context_[Expression]) -&gt; numpy.ndarray[object[3, 1]]</p></li>
</ol>
<p>Calculates system center of mass translational velocity in world frame
W.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context contains the state of the model.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">v_WScm_W</span></code>:</dt><dd><p>Scm’s translational velocity in frame W, expressed in W, where Scm
is the center of mass of the system S stored by <code class="docutils literal notranslate"><span class="pre">this</span></code> plant.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if this has no body except world_body</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p></li>
<li><p><strong>RuntimeError if mₛ ≤ 0</strong><strong> (</strong><strong>where mₛ is the mass</strong><strong> of </strong><strong>system S</strong><strong>)</strong><strong>.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The world_body() is ignored. v_WScm_W = ∑ (mᵢ vᵢ) / mₛ, where mₛ =
∑ mᵢ, mᵢ is the mass of the iᵗʰ body, and vᵢ is Bᵢcm’s velocity in
world W (Bᵢcm is the center of mass of the iᵗʰ body).</p>
</div>
<ol class="arabic simple" start="2">
<li><p>CalcCenterOfMassTranslationalVelocityInWorld(self: pydrake.multibody.plant.MultibodyPlant_[Expression], context: pydrake.systems.framework.Context_[Expression], model_instances: list[pydrake.multibody.tree.ModelInstanceIndex]) -&gt; numpy.ndarray[object[3, 1]]</p></li>
</ol>
<p>Calculates system center of mass translational velocity in world frame
W.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context contains the state of the model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">model_instances</span></code>:</dt><dd><p>Vector of selected model instances. If a model instance is
repeated in the vector (unusual), it is only counted once.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">v_WScm_W</span></code>:</dt><dd><p>Scm’s translational velocity in frame W, expressed in W, where Scm
is the center of mass of the system S of non-world bodies
contained in model_instances.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if model_instances is empty</strong><strong> or </strong><strong>only has world body.</strong> – </p></li>
<li><p><strong>RuntimeError if mₛ ≤ 0</strong><strong> (</strong><strong>where mₛ is the mass</strong><strong> of </strong><strong>system S</strong><strong>)</strong><strong>.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The world_body() is ignored. v_WScm_W = ∑ (mᵢ vᵢ) / mₛ, where mₛ =
∑ mᵢ, mᵢ is the mass of the iᵗʰ body contained in model_instances,
and vᵢ is Bᵢcm’s velocity in world W expressed in frame W (Bᵢcm is
the center of mass of the iᵗʰ body).</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcForceElementsContribution">
<span class="sig-name descname"><span class="pre">CalcForceElementsContribution</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.systems.framework.Context_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">forces</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.MultibodyForces_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcForceElementsContribution" title="Link to this definition"></a></dt>
<dd><p>Computes the combined force contribution of ForceElement objects in
the model. A ForceElement can apply forces as a spatial force per body
or as generalized forces, depending on the ForceElement model.
ForceElement contributions are a function of the state and time only.
The output from this method can immediately be used as input to
CalcInverseDynamics() to include the effect of applied forces by force
elements.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context containing the state of this model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">forces</span></code>:</dt><dd><p>A pointer to a valid, non nullptr, multibody forces object. On
output <code class="docutils literal notranslate"><span class="pre">forces</span></code> will store the forces exerted by all the
ForceElement objects in the model.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if forces is null</strong><strong> or </strong><strong>not compatible with this</strong> – </p></li>
<li><p><strong>model</strong><strong>, </strong><strong>per MultibodyForces::CheckInvariants</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcGeneralizedForces">
<span class="sig-name descname"><span class="pre">CalcGeneralizedForces</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.systems.framework.Context_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">forces</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.MultibodyForces_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcGeneralizedForces" title="Link to this definition"></a></dt>
<dd><p>Computes the generalized forces result of a set of MultibodyForces
applied to this model.</p>
<p>MultibodyForces stores applied forces as both generalized forces τ and
spatial forces F on each body, refer to documentation in
MultibodyForces for details. Users of MultibodyForces will use
MultibodyForces::mutable_generalized_forces() to mutate the stored
generalized forces directly and will use
RigidBody::AddInForceInWorld() to append spatial forces.</p>
<p>For a given set of forces stored as MultibodyForces, this method will
compute the total generalized forces on this model. More precisely, if
J_WBo is the Jacobian (with respect to velocities) for this model,
including all bodies, then this method computes:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">τᵣₑₛᵤₗₜ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">τ</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">J_WBo</span><span class="err">⋅</span><span class="n">F</span>
</pre></div>
</div>
</details><dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>Context that stores the state of the model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">forces</span></code>:</dt><dd><p>Set of multibody forces, including both generalized forces and
per-body spatial forces.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">generalized_forces</span></code>:</dt><dd><p>The total generalized forces on the model that would result from
applying <code class="docutils literal notranslate"><span class="pre">forces</span></code>. In other words, <code class="docutils literal notranslate"><span class="pre">forces</span></code> can be replaced by
the equivalent <code class="docutils literal notranslate"><span class="pre">generalized_forces</span></code>. On output,
<code class="docutils literal notranslate"><span class="pre">generalized_forces</span></code> is resized to num_velocities().</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if forces is null</strong><strong> or </strong><strong>not compatible with this</strong> – </p></li>
<li><p><strong>model.</strong> – </p></li>
<li><p><strong>RuntimeError if generalized_forces is not a valid non-null</strong> – </p></li>
<li><p><strong>pointer.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcGravityGeneralizedForces">
<span class="sig-name descname"><span class="pre">CalcGravityGeneralizedForces</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.systems.framework.Context_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcGravityGeneralizedForces" title="Link to this definition"></a></dt>
<dd><p>Computes the generalized forces <code class="docutils literal notranslate"><span class="pre">tau_g(q)</span></code> due to gravity as a
function of the generalized positions <code class="docutils literal notranslate"><span class="pre">q</span></code> stored in the input
<code class="docutils literal notranslate"><span class="pre">context</span></code>. The vector of generalized forces due to gravity
<code class="docutils literal notranslate"><span class="pre">tau_g(q)</span></code> is defined such that it appears on the right hand side of
the equations of motion together with any other generalized forces,
like so:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Mv</span><span class="err">̇</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">C</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tau_g</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">tau_app</span>
</pre></div>
</div>
</details><p>where <code class="docutils literal notranslate"><span class="pre">tau_app</span></code> includes any other generalized forces applied on the
system.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context storing the state of the model.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>tau_g A vector containing the generalized forces due to gravity.
The generalized forces are consistent with the vector of
generalized velocities <code class="docutils literal notranslate"><span class="pre">v</span></code> for <code class="docutils literal notranslate"><span class="pre">this</span></code> so that the inner
product <code class="docutils literal notranslate"><span class="pre">v⋅tau_g</span></code> corresponds to the power applied by the
gravity forces on the mechanical system. That is, <code class="docutils literal notranslate"><span class="pre">v⋅tau_g</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>
corresponds to potential energy going into the system, as either
mechanical kinetic energy, some other potential energy, or heat,
and therefore to a decrease of the gravitational potential energy.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcInverseDynamics">
<span class="sig-name descname"><span class="pre">CalcInverseDynamics</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.systems.framework.Context_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">known_vdot</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">external_forces</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.MultibodyForces_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcInverseDynamics" title="Link to this definition"></a></dt>
<dd><p>Given the state of this model in <code class="docutils literal notranslate"><span class="pre">context</span></code> and a known vector of
generalized accelerations <code class="docutils literal notranslate"><span class="pre">vdot</span></code>, this method computes the set of
generalized forces <code class="docutils literal notranslate"><span class="pre">tau</span></code> that would need to be applied in order to
attain the specified generalized accelerations. Mathematically, this
method computes:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">tau</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">M</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="n">v</span><span class="err">̇</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">C</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="n">v</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">tau_app</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="err">∑</span><span class="w"> </span><span class="n">J_WBᵀ</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="w"> </span><span class="n">Fapp_Bo_W</span>
</pre></div>
</div>
</details><p>where <code class="docutils literal notranslate"><span class="pre">M(q)</span></code> is the model’s mass matrix (including rigid body mass
properties and reflected_inertia “reflected inertias”), <code class="docutils literal notranslate"><span class="pre">C(q,</span> <span class="pre">v)v</span></code>
is the bias term for Coriolis and gyroscopic effects and <code class="docutils literal notranslate"><span class="pre">tau_app</span></code>
consists of a vector applied generalized forces. The last term is a
summation over all bodies in the model where <code class="docutils literal notranslate"><span class="pre">Fapp_Bo_W</span></code> is an
applied spatial force on body B at <code class="docutils literal notranslate"><span class="pre">Bo</span></code> which gets projected into
the space of generalized forces with the transpose of <code class="docutils literal notranslate"><span class="pre">Jv_V_WB(q)</span></code>
(where <code class="docutils literal notranslate"><span class="pre">Jv_V_WB</span></code> is B’s spatial velocity Jacobian in W with respect
to generalized velocities v). Note: B’s spatial velocity in W can be
written as <code class="docutils literal notranslate"><span class="pre">V_WB</span> <span class="pre">=</span> <span class="pre">Jv_V_WB</span> <span class="pre">*</span> <span class="pre">v</span></code>.</p>
<p>This method does not compute explicit expressions for the mass matrix
nor for the bias term, which would be of at least <code class="docutils literal notranslate"><span class="pre">O(n²)</span></code>
complexity, but it implements an <code class="docutils literal notranslate"><span class="pre">O(n)</span></code> Newton-Euler recursive
algorithm, where n is the number of bodies in the model. The explicit
formation of the mass matrix <code class="docutils literal notranslate"><span class="pre">M(q)</span></code> would require the calculation of
<code class="docutils literal notranslate"><span class="pre">O(n²)</span></code> entries while explicitly forming the product <code class="docutils literal notranslate"><span class="pre">C(q,</span> <span class="pre">v)</span> <span class="pre">*</span> <span class="pre">v</span></code>
could require up to <code class="docutils literal notranslate"><span class="pre">O(n³)</span></code> operations (see [Featherstone 1987,
§4]), depending on the implementation. The recursive Newton-Euler
algorithm is the most efficient currently known general method for
solving inverse dynamics [Featherstone 2008].</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context containing the state of the model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">known_vdot</span></code>:</dt><dd><p>A vector with the known generalized accelerations <code class="docutils literal notranslate"><span class="pre">vdot</span></code> for the
full model. Use the provided Joint APIs in order to access entries
into this array.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">external_forces</span></code>:</dt><dd><p>A set of forces to be applied to the system either as body spatial
forces <code class="docutils literal notranslate"><span class="pre">Fapp_Bo_W</span></code> or generalized forces <code class="docutils literal notranslate"><span class="pre">tau_app</span></code>, see
MultibodyForces for details.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>the vector of generalized forces that would need to be applied to
the mechanical system in order to achieve the desired acceleration
given by <code class="docutils literal notranslate"><span class="pre">known_vdot</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcJacobianAngularVelocity">
<span class="sig-name descname"><span class="pre">CalcJacobianAngularVelocity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.systems.framework.Context_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_respect_to</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JacobianWrtVariable" title="pydrake.multibody.tree.JacobianWrtVariable"><span class="pre">pydrake.multibody.tree.JacobianWrtVariable</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.Frame_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.Frame_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_E</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.Frame_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcJacobianAngularVelocity" title="Link to this definition"></a></dt>
<dd><p>Calculates J𝑠_w_AB, a frame B’s angular velocity Jacobian in a frame A
with respect to “speeds” 𝑠.</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">J𝑠_w_AB</span><span class="w"> </span><span class="err">≜</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="err">∂</span><span class="p">(</span><span class="n">w_AB</span><span class="p">)</span><span class="o">/</span><span class="err">∂</span><span class="n">𝑠₁</span><span class="p">,</span><span class="w">  </span><span class="p">...</span><span class="w">  </span><span class="err">∂</span><span class="p">(</span><span class="n">w_AB</span><span class="p">)</span><span class="o">/</span><span class="err">∂</span><span class="n">𝑠ₙ</span><span class="w"> </span><span class="p">]</span><span class="w">    </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="k">or</span><span class="w"> </span><span class="n">k</span><span class="p">)</span>
<span class="w">     </span><span class="n">w_AB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">J𝑠_w_AB</span><span class="w"> </span><span class="err">⋅</span><span class="w"> </span><span class="n">𝑠</span><span class="w">          </span><span class="n">w_AB</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">linear</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">𝑠</span><span class="w"> </span><span class="err">≜</span><span class="w"> </span><span class="p">[</span><span class="n">𝑠₁</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="n">𝑠ₙ</span><span class="p">]</span><span class="n">ᵀ</span>
</pre></div>
</div>
</details><p><code class="docutils literal notranslate"><span class="pre">w_AB</span></code> is B’s angular velocity in frame A and “speeds” 𝑠 is either
q̇ ≜ [q̇₁ … q̇ⱼ]ᵀ (time-derivatives of j generalized positions) or v
≜ [v₁ … vₖ]ᵀ (k generalized velocities).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The state of the multibody system.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">with_respect_to</span></code>:</dt><dd><p>Enum equal to JacobianWrtVariable::kQDot or
JacobianWrtVariable::kV, indicating whether the Jacobian
<code class="docutils literal notranslate"><span class="pre">J𝑠_w_AB</span></code> is partial derivatives with respect to 𝑠 = q̇
(time-derivatives of generalized positions) or with respect to 𝑠 =
v (generalized velocities).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_B</span></code>:</dt><dd><p>The frame B in <code class="docutils literal notranslate"><span class="pre">w_AB</span></code> (B’s angular velocity in A).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_A</span></code>:</dt><dd><p>The frame A in <code class="docutils literal notranslate"><span class="pre">w_AB</span></code> (B’s angular velocity in A).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_E</span></code>:</dt><dd><p>The frame in which <code class="docutils literal notranslate"><span class="pre">w_AB</span></code> is expressed on input and the frame in
which the Jacobian <code class="docutils literal notranslate"><span class="pre">J𝑠_w_AB</span></code> is expressed on output.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">Js_w_AB_E</span></code>:</dt><dd><p>Frame B’s angular velocity Jacobian in frame A with respect to
speeds 𝑠 (which is either q̇ or v), expressed in frame E. The
Jacobian is a function of only generalized positions q (which are
pulled from the context). The previous definition shows
<code class="docutils literal notranslate"><span class="pre">J𝑠_w_AB_E</span></code> is a matrix of size <code class="docutils literal notranslate"><span class="pre">3</span> <span class="pre">x</span> <span class="pre">n</span></code>, where n is the number
of elements in 𝑠.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>See Jacobian_functions “Jacobian functions” for related functions.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if J𝑠_w_AB_E is nullptr</strong><strong> or </strong><strong>not</strong><strong> of </strong><strong>size 3 x n.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcJacobianCenterOfMassTranslationalVelocity">
<span class="sig-name descname"><span class="pre">CalcJacobianCenterOfMassTranslationalVelocity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcJacobianCenterOfMassTranslationalVelocity" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>CalcJacobianCenterOfMassTranslationalVelocity(self: pydrake.multibody.plant.MultibodyPlant_[Expression], context: pydrake.systems.framework.Context_[Expression], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_A: pydrake.multibody.tree.Frame_[Expression], frame_E: pydrake.multibody.tree.Frame_[Expression]) -&gt; numpy.ndarray[object[3, n]]</p></li>
</ol>
<p>Calculates J𝑠_v_AScm_E, point Scm’s translational velocity Jacobian in
frame A with respect to “speeds” 𝑠, expressed in frame E, where point
Scm is the center of mass of the system S of all non-world bodies
contained in <code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>contains the state of the model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">with_respect_to</span></code>:</dt><dd><p>Enum equal to JacobianWrtVariable::kQDot or
JacobianWrtVariable::kV, indicating whether the Jacobian
<code class="docutils literal notranslate"><span class="pre">J𝑠_v_AScm_E</span></code> is partial derivatives with respect to 𝑠 = q̇
(time-derivatives of generalized positions) or with respect to 𝑠 =
v (generalized velocities).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_A</span></code>:</dt><dd><p>The frame in which the translational velocity v_AScm and its
Jacobian J𝑠_v_AScm are measured.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_E</span></code>:</dt><dd><p>The frame in which the Jacobian J𝑠_v_AScm is expressed on output.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">Js_v_AScm_E</span></code>:</dt><dd><p>Point Scm’s translational velocity Jacobian in frame A with
respect to speeds 𝑠 (𝑠 = q̇ or 𝑠 = v), expressed in frame E.
J𝑠_v_AScm_E is a 3 x n matrix, where n is the number of elements
in 𝑠. The Jacobian is a function of only generalized positions q
(which are pulled from the context).</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if Scm does not exist</strong><strong>, </strong><strong>which occurs if there are no</strong> – </p></li>
<li><p><strong>massive bodies in MultibodyPlant</strong><strong> (</strong><strong>except world_body</strong><strong>(</strong><strong>)</strong><strong>)</strong><strong>.</strong> – </p></li>
<li><p><strong>RuntimeError if mₛ ≤ 0</strong><strong> (</strong><strong>where mₛ is the mass</strong><strong> of </strong><strong>all non-world</strong> – </p></li>
<li><p><strong>bodies contained in this MultibodyPlant</strong><strong>)</strong><strong>.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>See Jacobian_functions “Jacobian functions” for related functions.</p>
</div>
<ol class="arabic simple" start="2">
<li><p>CalcJacobianCenterOfMassTranslationalVelocity(self: pydrake.multibody.plant.MultibodyPlant_[Expression], context: pydrake.systems.framework.Context_[Expression], model_instances: list[pydrake.multibody.tree.ModelInstanceIndex], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_A: pydrake.multibody.tree.Frame_[Expression], frame_E: pydrake.multibody.tree.Frame_[Expression]) -&gt; numpy.ndarray[object[3, n]]</p></li>
</ol>
<p>Calculates J𝑠_v_AScm_E, point Scm’s translational velocity Jacobian in
frame A with respect to “speeds” 𝑠, expressed in frame E, where point
Scm is the center of mass of the system S of all non-world bodies
contained in model_instances.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>contains the state of the model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">model_instances</span></code>:</dt><dd><p>Vector of selected model instances. If a model instance is
repeated in the vector (unusual), it is only counted once.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">with_respect_to</span></code>:</dt><dd><p>Enum equal to JacobianWrtVariable::kQDot or
JacobianWrtVariable::kV, indicating whether the Jacobian
<code class="docutils literal notranslate"><span class="pre">J𝑠_v_AScm_E</span></code> is partial derivatives with respect to 𝑠 = q̇
(time-derivatives of generalized positions) or with respect to 𝑠 =
v (generalized velocities).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_A</span></code>:</dt><dd><p>The frame in which the translational velocity v_AScm and its
Jacobian J𝑠_v_AScm are measured.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_E</span></code>:</dt><dd><p>The frame in which the Jacobian J𝑠_v_AScm is expressed on output.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">Js_v_AScm_E</span></code>:</dt><dd><p>Point Scm’s translational velocity Jacobian in frame A with
respect to speeds 𝑠 (𝑠 = q̇ or 𝑠 = v), expressed in frame E.
J𝑠_v_AScm_E is a 3 x n matrix, where n is the number of elements
in 𝑠. The Jacobian is a function of only generalized positions q
(which are pulled from the context).</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if mₛ ≤ 0</strong><strong> (</strong><strong>where mₛ is the mass</strong><strong> of </strong><strong>all non-world</strong> – </p></li>
<li><p><strong>bodies contained in model_instances</strong><strong>)</strong><strong>.</strong> – </p></li>
<li><p><strong>RuntimeError if model_instances is empty</strong><strong> or </strong><strong>only has world body.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The world_body() is ignored. <a href="#id159"><span class="problematic" id="id160">J𝑠_v_AScm_</span></a> = ∑ (mᵢ Jᵢ) / mₛ, where mₛ
= ∑ mᵢ, mᵢ is the mass of the iᵗʰ body contained in
model_instances, and Jᵢ is Bᵢcm’s translational velocity Jacobian
in frame A, expressed in frame E (Bᵢcm is the center of mass of
the iᵗʰ body).</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>See Jacobian_functions “Jacobian functions” for related functions.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcJacobianPositionVector">
<span class="sig-name descname"><span class="pre">CalcJacobianPositionVector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.systems.framework.Context_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.Frame_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_BoBi_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.f_contiguous</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.Frame_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_E</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.Frame_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcJacobianPositionVector" title="Link to this definition"></a></dt>
<dd><p>For each point Bi affixed/welded to a frame B, calculates Jq_p_AoBi,
Bi’s position vector Jacobian in frame A with respect to the
generalized positions q ≜ [q₁ … qₙ]ᵀ as</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Jq_p_AoBi</span><span class="w"> </span><span class="err">≜</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="n">ᴬ</span><span class="err">∂</span><span class="p">(</span><span class="n">p_AoBi</span><span class="p">)</span><span class="o">/</span><span class="err">∂</span><span class="n">q₁</span><span class="p">,</span><span class="w">  </span><span class="p">...</span><span class="w">  </span><span class="n">ᴬ</span><span class="err">∂</span><span class="p">(</span><span class="n">p_AoBi</span><span class="p">)</span><span class="o">/</span><span class="err">∂</span><span class="n">qₙ</span><span class="w"> </span><span class="p">]</span>
</pre></div>
</div>
</details><p>where p_AoBi is Bi’s position vector from point Ao (frame A’s origin)
and ᴬ∂(p_AoBi)/∂qᵣ denotes the partial derivative in frame A of p_AoBi
with respect to the generalized position qᵣ, where qᵣ is one of q₁ …
qₙ.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The state of the multibody system.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_B</span></code>:</dt><dd><p>The frame on which point Bi is affixed/welded.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BoBi_B</span></code>:</dt><dd><p>A position vector or list of k position vectors from Bo (frame_B’s
origin) to points Bi (Bi is regarded as affixed to B), where each
position vector is expressed in frame_B.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_A</span></code>:</dt><dd><p>The frame in which partial derivatives are calculated and the
frame in which point Ao is affixed.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_E</span></code>:</dt><dd><p>The frame in which the Jacobian Jq_p_AoBi is expressed on output.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">Jq_p_AoBi_E</span></code>:</dt><dd><p>Point Bi’s position vector Jacobian in frame A with generalized
positions q, expressed in frame E. Jq_p_AoBi_E is a <code class="docutils literal notranslate"><span class="pre">3*k</span> <span class="pre">x</span> <span class="pre">n</span></code>
matrix, where k is the number of points Bi and n is the number of
elements in q. The Jacobian is a function of only generalized
positions q (which are pulled from the context).</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if Jq_p_AoBi_E is nullptr</strong><strong> or </strong><strong>not sized 3*k x n.</strong> – </p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Jq̇_v_ABi = Jq_p_AoBi. In other words, point Bi’s velocity
Jacobian in frame A with respect to q̇ is equal to point Bi’s
position vector Jacobian in frame A with respect to q.</p>
</div>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="err">∂</span><span class="p">(</span><span class="n">v_ABi</span><span class="p">)</span><span class="o">/</span><span class="err">∂</span><span class="n">q</span><span class="err">̇</span><span class="n">₁</span><span class="p">,</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="err">∂</span><span class="p">(</span><span class="n">v_ABi</span><span class="p">)</span><span class="o">/</span><span class="err">∂</span><span class="n">q</span><span class="err">̇</span><span class="n">ₙ</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">ᴬ</span><span class="err">∂</span><span class="p">(</span><span class="n">p_AoBi</span><span class="p">)</span><span class="o">/</span><span class="err">∂</span><span class="n">q₁</span><span class="p">,</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="n">ᴬ</span><span class="err">∂</span><span class="p">(</span><span class="n">p_AoBi</span><span class="p">)</span><span class="o">/</span><span class="err">∂</span><span class="n">qₙ</span><span class="p">]</span>
</pre></div>
</div>
</details><div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcJacobianTranslationalVelocity() for details on Jq̇_v_ABi.
Note: Jq_p_AaBi = Jq_p_AoBi, where point Aa is <em>any</em> point
fixed/welded to frame A, i.e., this calculation’s result is the
same if point Ao is replaced with any point fixed on frame A.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>See Jacobian_functions “Jacobian functions” for related functions.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcJacobianSpatialVelocity">
<span class="sig-name descname"><span class="pre">CalcJacobianSpatialVelocity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.systems.framework.Context_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_respect_to</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JacobianWrtVariable" title="pydrake.multibody.tree.JacobianWrtVariable"><span class="pre">pydrake.multibody.tree.JacobianWrtVariable</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.Frame_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_BoBp_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.Frame_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_E</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.Frame_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcJacobianSpatialVelocity" title="Link to this definition"></a></dt>
<dd><p>For one point Bp fixed/welded to a frame B, calculates J𝑠_V_ABp, Bp’s
spatial velocity Jacobian in frame A with respect to “speeds” 𝑠.</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">J𝑠_V_ABp</span><span class="w"> </span><span class="err">≜</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="err">∂</span><span class="p">(</span><span class="n">V_ABp</span><span class="p">)</span><span class="o">/</span><span class="err">∂</span><span class="n">𝑠₁</span><span class="p">,</span><span class="w">  </span><span class="p">...</span><span class="w">  </span><span class="err">∂</span><span class="p">(</span><span class="n">V_ABp</span><span class="p">)</span><span class="o">/</span><span class="err">∂</span><span class="n">𝑠ₙ</span><span class="w"> </span><span class="p">]</span><span class="w">    </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="k">or</span><span class="w"> </span><span class="n">k</span><span class="p">)</span>
<span class="w">     </span><span class="n">V_ABp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">J𝑠_V_ABp</span><span class="w"> </span><span class="err">⋅</span><span class="w"> </span><span class="n">𝑠</span><span class="w">          </span><span class="n">V_ABp</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">linear</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">𝑠</span><span class="w"> </span><span class="err">≜</span><span class="w"> </span><span class="p">[</span><span class="n">𝑠₁</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="n">𝑠ₙ</span><span class="p">]</span><span class="n">ᵀ</span>
</pre></div>
</div>
</details><p><code class="docutils literal notranslate"><span class="pre">V_ABp</span></code> is Bp’s spatial velocity in frame A and “speeds” 𝑠 is either
q̇ ≜ [q̇₁ … q̇ⱼ]ᵀ (time-derivatives of j generalized positions) or v
≜ [v₁ … vₖ]ᵀ (k generalized velocities).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The state of the multibody system.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">with_respect_to</span></code>:</dt><dd><p>Enum equal to JacobianWrtVariable::kQDot or
JacobianWrtVariable::kV, indicating whether the Jacobian
<code class="docutils literal notranslate"><span class="pre">J𝑠_V_ABp</span></code> is partial derivatives with respect to 𝑠 = q̇
(time-derivatives of generalized positions) or with respect to 𝑠 =
v (generalized velocities).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_B</span></code>:</dt><dd><p>The frame on which point Bp is fixed/welded.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BoBp_B</span></code>:</dt><dd><p>A position vector from Bo (frame_B’s origin) to point Bp (regarded
as fixed/welded to B), expressed in frame_B.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_A</span></code>:</dt><dd><p>The frame that measures <code class="docutils literal notranslate"><span class="pre">v_ABp</span></code> (Bp’s velocity in A). Note: It
is natural to wonder why there is no parameter p_AoAp_A (similar
to the parameter p_BoBp_B for frame_B). There is no need for
p_AoAp_A because Bp’s velocity in A is defined as the derivative
in frame A of Bp’s position vector from <em>any</em> point fixed to A.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_E</span></code>:</dt><dd><p>The frame in which <code class="docutils literal notranslate"><span class="pre">v_ABp</span></code> is expressed on input and the frame
in which the Jacobian <code class="docutils literal notranslate"><span class="pre">J𝑠_V_ABp</span></code> is expressed on output.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">Js_V_ABp_E</span></code>:</dt><dd><p>Point Bp’s spatial velocity Jacobian in frame A with respect to
speeds 𝑠 (which is either q̇ or v), expressed in frame E.
<code class="docutils literal notranslate"><span class="pre">J𝑠_V_ABp_E</span></code> is a <code class="docutils literal notranslate"><span class="pre">6</span> <span class="pre">x</span> <span class="pre">n</span></code> matrix, where n is the number of
elements in 𝑠. The Jacobian is a function of only generalized
positions q (which are pulled from the context).</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The returned <code class="docutils literal notranslate"><span class="pre">6</span> <span class="pre">x</span> <span class="pre">n</span></code> matrix stores frame B’s angular velocity
Jacobian in A in rows 1-3 and stores point Bp’s translational
velocity Jacobian in A in rows 4-6, i.e.,</p>
</div>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">J𝑠_w_AB_E</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">J𝑠_V_ABp_E</span><span class="p">.</span><span class="n">topRows</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">();</span>
<span class="w">    </span><span class="n">J𝑠_v_ABp_E</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">J𝑠_V_ABp_E</span><span class="p">.</span><span class="n">bottomRows</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">();</span>
</pre></div>
</div>
</details><div class="admonition note">
<p class="admonition-title">Note</p>
<p>Consider CalcJacobianTranslationalVelocity() for multiple points
fixed to frame B and consider CalcJacobianAngularVelocity() to
calculate frame B’s angular velocity Jacobian.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>See Jacobian_functions “Jacobian functions” for related functions.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if J𝑠_V_ABp_E is nullptr</strong><strong> or </strong><strong>not sized 6 x n.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcJacobianTranslationalVelocity">
<span class="sig-name descname"><span class="pre">CalcJacobianTranslationalVelocity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.systems.framework.Context_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_respect_to</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JacobianWrtVariable" title="pydrake.multibody.tree.JacobianWrtVariable"><span class="pre">pydrake.multibody.tree.JacobianWrtVariable</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.Frame_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_BoBi_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.f_contiguous</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.Frame_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_E</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.Frame_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcJacobianTranslationalVelocity" title="Link to this definition"></a></dt>
<dd><p>For each point Bi affixed/welded to a frame B, calculates J𝑠_v_ABi,
Bi’s translational velocity Jacobian in frame A with respect to
“speeds” 𝑠.</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">J𝑠_v_ABi</span><span class="w"> </span><span class="err">≜</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="err">∂</span><span class="p">(</span><span class="n">v_ABi</span><span class="p">)</span><span class="o">/</span><span class="err">∂</span><span class="n">𝑠₁</span><span class="p">,</span><span class="w">  </span><span class="p">...</span><span class="w">  </span><span class="err">∂</span><span class="p">(</span><span class="n">v_ABi</span><span class="p">)</span><span class="o">/</span><span class="err">∂</span><span class="n">𝑠ₙ</span><span class="w"> </span><span class="p">]</span><span class="w">    </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="k">or</span><span class="w"> </span><span class="n">k</span><span class="p">)</span>
<span class="w">     </span><span class="n">v_ABi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">J𝑠_v_ABi</span><span class="w"> </span><span class="err">⋅</span><span class="w"> </span><span class="n">𝑠</span><span class="w">          </span><span class="n">v_ABi</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">linear</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">𝑠</span><span class="w"> </span><span class="err">≜</span><span class="w"> </span><span class="p">[</span><span class="n">𝑠₁</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="n">𝑠ₙ</span><span class="p">]</span><span class="n">ᵀ</span>
</pre></div>
</div>
</details><p><code class="docutils literal notranslate"><span class="pre">v_ABi</span></code> is Bi’s translational velocity in frame A and “speeds” 𝑠 is
either q̇ ≜ [q̇₁ … q̇ⱼ]ᵀ (time-derivatives of j generalized
positions) or v ≜ [v₁ … vₖ]ᵀ (k generalized velocities).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The state of the multibody system.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">with_respect_to</span></code>:</dt><dd><p>Enum equal to JacobianWrtVariable::kQDot or
JacobianWrtVariable::kV, indicating whether the Jacobian
<code class="docutils literal notranslate"><span class="pre">J𝑠_v_ABi</span></code> is partial derivatives with respect to 𝑠 = q̇
(time-derivatives of generalized positions) or with respect to 𝑠 =
v (generalized velocities).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_B</span></code>:</dt><dd><p>The frame on which point Bi is affixed/welded.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BoBi_B</span></code>:</dt><dd><p>A position vector or list of p position vectors from Bo (frame_B’s
origin) to points Bi (regarded as affixed to B), where each
position vector is expressed in frame_B.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_A</span></code>:</dt><dd><p>The frame that measures <code class="docutils literal notranslate"><span class="pre">v_ABi</span></code> (Bi’s velocity in A). Note: It
is natural to wonder why there is no parameter p_AoAi_A (similar
to the parameter p_BoBi_B for frame_B). There is no need for
p_AoAi_A because Bi’s velocity in A is defined as the derivative
in frame A of Bi’s position vector from <em>any</em> point affixed to A.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_E</span></code>:</dt><dd><p>The frame in which <code class="docutils literal notranslate"><span class="pre">v_ABi</span></code> is expressed on input and the frame
in which the Jacobian <code class="docutils literal notranslate"><span class="pre">J𝑠_v_ABi</span></code> is expressed on output.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">Js_v_ABi_E</span></code>:</dt><dd><p>Point Bi’s velocity Jacobian in frame A with respect to speeds 𝑠
(which is either q̇ or v), expressed in frame E. <code class="docutils literal notranslate"><span class="pre">J𝑠_v_ABi_E</span></code> is
a <code class="docutils literal notranslate"><span class="pre">3*p</span> <span class="pre">x</span> <span class="pre">n</span></code> matrix, where p is the number of points Bi and n is
the number of elements in 𝑠. The Jacobian is a function of only
generalized positions q (which are pulled from the context).</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if J𝑠_v_ABi_E is nullptr</strong><strong> or </strong><strong>not sized ``3*p x</strong> – </p></li>
<li><p><strong>n``.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When 𝑠 = q̇, <code class="docutils literal notranslate"><span class="pre">Jq̇_v_ABi</span> <span class="pre">=</span> <span class="pre">Jq_p_AoBi</span></code>. In other words, point Bi’s
velocity Jacobian in frame A with respect to q̇ is equal to point
Bi’s position Jacobian from Ao (A’s origin) in frame A with
respect to q.</p>
</div>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="err">∂</span><span class="p">(</span><span class="n">v_ABi</span><span class="p">)</span><span class="o">/</span><span class="err">∂</span><span class="n">q</span><span class="err">̇</span><span class="n">₁</span><span class="p">,</span><span class="w">  </span><span class="p">...</span><span class="w">  </span><span class="err">∂</span><span class="p">(</span><span class="n">v_ABi</span><span class="p">)</span><span class="o">/</span><span class="err">∂</span><span class="n">q</span><span class="err">̇</span><span class="n">ⱼ</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="err">∂</span><span class="p">(</span><span class="n">p_AoBi</span><span class="p">)</span><span class="o">/</span><span class="err">∂</span><span class="n">q₁</span><span class="p">,</span><span class="w">  </span><span class="p">...</span><span class="w">  </span><span class="err">∂</span><span class="p">(</span><span class="n">p_AoBi</span><span class="p">)</span><span class="o">/</span><span class="err">∂</span><span class="n">qⱼ</span><span class="p">]</span>
</pre></div>
</div>
</details><p>Note: Each partial derivative of p_AoBi is taken in frame A.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcJacobianPositionVector() for details on Jq_p_AoBi.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>See Jacobian_functions “Jacobian functions” for related functions.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcMassMatrix">
<span class="sig-name descname"><span class="pre">CalcMassMatrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.systems.framework.Context_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcMassMatrix" title="Link to this definition"></a></dt>
<dd><p>Efficiently computes the mass matrix <code class="docutils literal notranslate"><span class="pre">M(q)</span></code> of the model. The
generalized positions q are taken from the given <code class="docutils literal notranslate"><span class="pre">context</span></code>. M
includes the mass properties of rigid bodies and reflected_inertia
“reflected inertias” as provided with JointActuator specifications.</p>
<p>This method employs the Composite Body Algorithm, which we believe to
be the fastest O(n²) algorithm to compute the mass matrix of a
multibody system.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The Context containing the state of the model from which
generalized coordinates q are extracted.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">M</span></code>:</dt><dd><p>A pointer to a square matrix in <code class="docutils literal notranslate"><span class="pre">ℛⁿˣⁿ</span></code> with n the number of
generalized velocities (num_velocities()) of the model. Although
symmetric, the matrix is filled in completely on return.</p>
</dd>
<dt>Precondition:</dt><dd><p>M is non-null and has the right size.</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This is an O(n²) algorithm. Avoid the explicit computation of the
mass matrix whenever possible.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcMassMatrixViaInverseDynamics() (slower)</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcMassMatrixViaInverseDynamics">
<span class="sig-name descname"><span class="pre">CalcMassMatrixViaInverseDynamics</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.systems.framework.Context_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcMassMatrixViaInverseDynamics" title="Link to this definition"></a></dt>
<dd><p>Computes the mass matrix <code class="docutils literal notranslate"><span class="pre">M(q)</span></code> of the model using a slow method
(inverse dynamics). The generalized positions q are taken from the
given <code class="docutils literal notranslate"><span class="pre">context</span></code>. M includes the mass properties of rigid bodies and
reflected_inertia “reflected inertias” as provided with JointActuator
specifications.</p>
<p>Use CalcMassMatrix() for a faster implementation using the Composite
Body Algorithm.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The Context containing the state of the model from which
generalized coordinates q are extracted.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">M</span></code>:</dt><dd><p>A pointer to a square matrix in <code class="docutils literal notranslate"><span class="pre">ℛⁿˣⁿ</span></code> with n the number of
generalized velocities (num_velocities()) of the model. Although
symmetric, the matrix is filled in completely on return.</p>
</dd>
<dt>Precondition:</dt><dd><p>M is non-null and has the right size.</p>
</dd>
</dl>
<p>The algorithm used to build <code class="docutils literal notranslate"><span class="pre">M(q)</span></code> consists in computing one column
of <code class="docutils literal notranslate"><span class="pre">M(q)</span></code> at a time using inverse dynamics. The result from inverse
dynamics, with no applied forces, is the vector of generalized forces:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">tau</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">M</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="n">v</span><span class="err">̇</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">C</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="n">v</span>
</pre></div>
</div>
</details><p>where q and v are the generalized positions and velocities,
respectively. When <code class="docutils literal notranslate"><span class="pre">v</span> <span class="pre">=</span> <span class="pre">0</span></code> the Coriolis and gyroscopic forces term
<code class="docutils literal notranslate"><span class="pre">C(q,</span> <span class="pre">v)v</span></code> is zero. Therefore the <code class="docutils literal notranslate"><span class="pre">i-th</span></code> column of <code class="docutils literal notranslate"><span class="pre">M(q)</span></code> can be
obtained performing inverse dynamics with an acceleration vector <code class="docutils literal notranslate"><span class="pre">v̇</span>
<span class="pre">=</span> <span class="pre">eᵢ</span></code>, with <code class="docutils literal notranslate"><span class="pre">eᵢ</span></code> the standard (or natural) basis of <code class="docutils literal notranslate"><span class="pre">ℛⁿ</span></code> with n
the number of generalized velocities. We write this as:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">M</span><span class="p">.</span><span class="n">ᵢ</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">M</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">e_i</span>
</pre></div>
</div>
</details><p>where <code class="docutils literal notranslate"><span class="pre">M.ᵢ(q)</span></code> (notice the dot for the rows index) denotes the
<code class="docutils literal notranslate"><span class="pre">i-th</span></code> column in M(q).</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This is an O(n²) algorithm. Avoid the explicit computation of the
mass matrix whenever possible.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcMassMatrix(), CalcInverseDynamics()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcPointsPositions">
<span class="sig-name descname"><span class="pre">CalcPointsPositions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.systems.framework.Context_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.Frame_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_BQi</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.f_contiguous</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.Frame_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcPointsPositions" title="Link to this definition"></a></dt>
<dd><p>Given the positions <code class="docutils literal notranslate"><span class="pre">p_BQi</span></code> for a set of points <code class="docutils literal notranslate"><span class="pre">Qi</span></code> measured and
expressed in a frame B, this method computes the positions
<code class="docutils literal notranslate"><span class="pre">p_AQi(q)</span></code> of each point <code class="docutils literal notranslate"><span class="pre">Qi</span></code> in the set as measured and expressed
in another frame A, as a function of the generalized positions q of
the model.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context containing the state of the model. It stores the
generalized positions q of the model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_B</span></code>:</dt><dd><p>The frame B in which the positions <code class="docutils literal notranslate"><span class="pre">p_BQi</span></code> of a set of points
<code class="docutils literal notranslate"><span class="pre">Qi</span></code> are given.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BQi</span></code>:</dt><dd><p>The input positions of each point <code class="docutils literal notranslate"><span class="pre">Qi</span></code> in frame B. <code class="docutils literal notranslate"><span class="pre">p_BQi</span> <span class="pre">∈</span>
<span class="pre">ℝ³ˣⁿᵖ</span></code> with <code class="docutils literal notranslate"><span class="pre">np</span></code> the number of points in the set. Each column
of <code class="docutils literal notranslate"><span class="pre">p_BQi</span></code> corresponds to a vector in ℝ³ holding the position of
one of the points in the set as measured and expressed in frame B.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_A</span></code>:</dt><dd><p>The frame A in which it is desired to compute the positions
<code class="docutils literal notranslate"><span class="pre">p_AQi</span></code> of each point <code class="docutils literal notranslate"><span class="pre">Qi</span></code> in the set.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_AQi</span></code>:</dt><dd><p>The output positions of each point <code class="docutils literal notranslate"><span class="pre">Qi</span></code> now computed as measured
and expressed in frame A. The output <code class="docutils literal notranslate"><span class="pre">p_AQi</span></code> <strong>must</strong> have the
same size as the input <code class="docutils literal notranslate"><span class="pre">p_BQi</span></code> or otherwise this method aborts.
That is <code class="docutils literal notranslate"><span class="pre">p_AQi</span></code> <strong>must</strong> be in <code class="docutils literal notranslate"><span class="pre">ℝ³ˣⁿᵖ</span></code>.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Both <code class="docutils literal notranslate"><span class="pre">p_BQi</span></code> and <code class="docutils literal notranslate"><span class="pre">p_AQi</span></code> must have three rows. Otherwise this
method will throw a RuntimeError. This method also throws a
RuntimeError if <code class="docutils literal notranslate"><span class="pre">p_BQi</span></code> and <code class="docutils literal notranslate"><span class="pre">p_AQi</span></code> differ in the number of
columns.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcRelativeRotationMatrix">
<span class="sig-name descname"><span class="pre">CalcRelativeRotationMatrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.systems.framework.Context_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.Frame_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.Frame_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.math.RotationMatrix_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcRelativeRotationMatrix" title="Link to this definition"></a></dt>
<dd><p>Calculates the rotation matrix <code class="docutils literal notranslate"><span class="pre">R_AB</span></code> relating frame A and frame B.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The state of the multibody system, which includes the system’s
generalized positions q. Note: <code class="docutils literal notranslate"><span class="pre">R_AB</span></code> is a function of q.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_A</span></code>:</dt><dd><p>The frame A designated in the rigid transform <code class="docutils literal notranslate"><span class="pre">R_AB</span></code>.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_B</span></code>:</dt><dd><p>The frame G designated in the rigid transform <code class="docutils literal notranslate"><span class="pre">R_AB</span></code>.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">R_AB</span></code>:</dt><dd><p>The RigidTransform relating frame A and frame B.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcRelativeTransform">
<span class="sig-name descname"><span class="pre">CalcRelativeTransform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.systems.framework.Context_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.Frame_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.Frame_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.math.RigidTransform_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcRelativeTransform" title="Link to this definition"></a></dt>
<dd><p>Calculates the rigid transform (pose) <code class="docutils literal notranslate"><span class="pre">X_AB</span></code> relating frame A and
frame B.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The state of the multibody system, which includes the system’s
generalized positions q. Note: <code class="docutils literal notranslate"><span class="pre">X_AB</span></code> is a function of q.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_A</span></code>:</dt><dd><p>The frame A designated in the rigid transform <code class="docutils literal notranslate"><span class="pre">X_AB</span></code>.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_B</span></code>:</dt><dd><p>The frame G designated in the rigid transform <code class="docutils literal notranslate"><span class="pre">X_AB</span></code>.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">X_AB</span></code>:</dt><dd><p>The RigidTransform relating frame A and frame B.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcSpatialAccelerationsFromVdot">
<span class="sig-name descname"><span class="pre">CalcSpatialAccelerationsFromVdot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.systems.framework.Context_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">known_vdot</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">pydrake.multibody.math.SpatialAcceleration_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcSpatialAccelerationsFromVdot" title="Link to this definition"></a></dt>
<dd><p>Given the state of this model in <code class="docutils literal notranslate"><span class="pre">context</span></code> and a known vector of
generalized accelerations <code class="docutils literal notranslate"><span class="pre">known_vdot</span></code>, this method computes the
spatial acceleration <code class="docutils literal notranslate"><span class="pre">A_WB</span></code> for each body as measured and expressed
in the world frame W.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context containing the state of this model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">known_vdot</span></code>:</dt><dd><p>A vector with the generalized accelerations for the full model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">A_WB_array</span></code>:</dt><dd><p>A pointer to a valid, non nullptr, vector of spatial accelerations
containing the spatial acceleration <code class="docutils literal notranslate"><span class="pre">A_WB</span></code> for each body. It
must be of size equal to the number of bodies in the model. On
output, entries will be ordered by BodyIndex.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if A_WB_array is not</strong><strong> of </strong><strong>size num_bodies</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcSpatialInertia">
<span class="sig-name descname"><span class="pre">CalcSpatialInertia</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.systems.framework.Context_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_F</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.Frame_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body_indexes</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.BodyIndex" title="pydrake.multibody.tree.BodyIndex"><span class="pre">pydrake.multibody.tree.BodyIndex</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.multibody.tree.SpatialInertia_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcSpatialInertia" title="Link to this definition"></a></dt>
<dd><p>Returns M_SFo_F, the spatial inertia of a set S of bodies about point
Fo (the origin of a frame F), expressed in frame F. You may regard
M_SFo_F as measuring spatial inertia as if the set S of bodies were
welded into a single composite body at the configuration specified in
the <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>Contains the configuration of the set S of bodies.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_F</span></code>:</dt><dd><p>specifies the about-point Fo (frame_F’s origin) and the
expressed-in frame for the returned spatial inertia.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body_indexes</span></code>:</dt><dd><p>Array of selected bodies. This method does not distinguish between
welded bodies, joint-connected bodies, etc.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if body_indexes contains an invalid BodyIndex</strong><strong> or </strong><strong>if</strong> – </p></li>
<li><p><strong>there is a repeated BodyIndex.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The mass and inertia of the world_body() does not contribute to
the the returned spatial inertia.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcSpatialMomentumInWorldAboutPoint">
<span class="sig-name descname"><span class="pre">CalcSpatialMomentumInWorldAboutPoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcSpatialMomentumInWorldAboutPoint" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>CalcSpatialMomentumInWorldAboutPoint(self: pydrake.multibody.plant.MultibodyPlant_[Expression], context: pydrake.systems.framework.Context_[Expression], p_WoP_W: numpy.ndarray[object[3, 1]]) -&gt; pydrake.multibody.math.SpatialMomentum_[Expression]</p></li>
</ol>
<p>This method returns the spatial momentum of <code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant in
the world frame W, about a designated point P, expressed in the world
frame W.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>Contains the state of the model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_WoP_W</span></code>:</dt><dd><p>Position from Wo (origin of the world frame W) to an arbitrary
point P, expressed in the world frame W.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">L_WSP_W</span></code>:</dt><dd><p>, spatial momentum of the system S represented by <code class="docutils literal notranslate"><span class="pre">this</span></code> plant,
measured in the world frame W, about point P, expressed in W.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>To calculate the spatial momentum of this system S in W about Scm
(the system’s center of mass), use something like:</p>
</div>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">plant</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// ... code to load a model ....</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">Vector3</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">p_WoScm_W</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="n">plant</span><span class="p">.</span><span class="n">CalcCenterOfMassPositionInWorld</span><span class="p">(</span><span class="n">context</span><span class="p">);</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">SpatialMomentum</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">L_WScm_W</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="n">plant</span><span class="p">.</span><span class="n">CalcSpatialMomentumInWorldAboutPoint</span><span class="p">(</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="n">p_WoScm_W</span><span class="p">);</span>
</pre></div>
</div>
</details><ol class="arabic simple" start="2">
<li><p>CalcSpatialMomentumInWorldAboutPoint(self: pydrake.multibody.plant.MultibodyPlant_[Expression], context: pydrake.systems.framework.Context_[Expression], model_instances: list[pydrake.multibody.tree.ModelInstanceIndex], p_WoP_W: numpy.ndarray[object[3, 1]]) -&gt; pydrake.multibody.math.SpatialMomentum_[Expression]</p></li>
</ol>
<p>This method returns the spatial momentum of a set of model instances
in the world frame W, about a designated point P, expressed in frame
W.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>Contains the state of the model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">model_instances</span></code>:</dt><dd><p>Set of selected model instances.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_WoP_W</span></code>:</dt><dd><p>Position from Wo (origin of the world frame W) to an arbitrary
point P, expressed in the world frame W.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">L_WSP_W</span></code>:</dt><dd><p>, spatial momentum of the system S represented by the
model_instances, measured in world frame W, about point P,
expressed in W.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>To calculate the spatial momentum of this system S in W about Scm
(the system’s center of mass), use something like:</p>
</div>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">plant</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// ... code to create a set of selected model instances, e.g., ...</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">ModelInstanceIndex</span><span class="w"> </span><span class="n">gripper_model_instance</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="n">plant</span><span class="p">.</span><span class="n">GetModelInstanceByName</span><span class="p">(</span><span class="s">&quot;gripper&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">ModelInstanceIndex</span><span class="w"> </span><span class="n">robot_model_instance</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="n">plant</span><span class="p">.</span><span class="n">GetBodyByName</span><span class="p">(</span><span class="s">&quot;end_effector&quot;</span><span class="p">).</span><span class="n">model_instance</span><span class="p">();</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ModelInstanceIndex</span><span class="o">&gt;</span><span class="w"> </span><span class="n">model_instances</span><span class="p">{</span>
<span class="w">    </span><span class="n">gripper_model_instance</span><span class="p">,</span><span class="w"> </span><span class="n">robot_model_instance</span><span class="p">};</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">Vector3</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">p_WoScm_W</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="n">plant</span><span class="p">.</span><span class="n">CalcCenterOfMassPositionInWorld</span><span class="p">(</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="n">model_instances</span><span class="p">);</span>
<span class="w">  </span><span class="n">SpatialMomentum</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">L_WScm_W</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="n">plant</span><span class="p">.</span><span class="n">CalcSpatialMomentumInWorldAboutPoint</span><span class="p">(</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="n">model_instances</span><span class="p">,</span>
<span class="w">                                               </span><span class="n">p_WoScm_W</span><span class="p">);</span>
</pre></div>
</div>
</details><dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if model_instances contains an invalid</strong> – </p></li>
<li><p><strong>ModelInstanceIndex.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcTotalMass">
<span class="sig-name descname"><span class="pre">CalcTotalMass</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcTotalMass" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>CalcTotalMass(self: pydrake.multibody.plant.MultibodyPlant_[Expression], context: pydrake.systems.framework.Context_[Expression]) -&gt; pydrake.symbolic.Expression</p></li>
</ol>
<p>Calculates the total mass of all bodies in this MultibodyPlant.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>Contains the state of the model.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">The</span></code>:</dt><dd><p>total mass of all bodies or 0 if there are none.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The mass of the world_body() does not contribute to the total
mass.</p>
</div>
<ol class="arabic simple" start="2">
<li><p>CalcTotalMass(self: pydrake.multibody.plant.MultibodyPlant_[Expression], context: pydrake.systems.framework.Context_[Expression], model_instances: list[pydrake.multibody.tree.ModelInstanceIndex]) -&gt; pydrake.symbolic.Expression</p></li>
</ol>
<p>Calculates the total mass of all bodies contained in model_instances.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>Contains the state of the model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">model_instances</span></code>:</dt><dd><p>Vector of selected model instances. This method does not
distinguish between welded, joint connected, or floating bodies.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">The</span></code>:</dt><dd><p>total mass of all bodies belonging to a model instance in
model_instances or 0 if model_instances is empty.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The mass of the world_body() does not contribute to the total mass
and each body only contributes to the total mass once, even if the
body has repeated occurrence (instance) in model_instances.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.CollectRegisteredGeometries">
<span class="sig-name descname"><span class="pre">CollectRegisteredGeometries</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bodies</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">pydrake.multibody.tree.RigidBody_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.GeometrySet" title="pydrake.geometry.GeometrySet"><span class="pre">pydrake.geometry.GeometrySet</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.CollectRegisteredGeometries" title="Link to this definition"></a></dt>
<dd><p>For each of the provided <code class="docutils literal notranslate"><span class="pre">bodies</span></code>, collects up all geometries that
have been registered to that body. Intended to be used in conjunction
with CollisionFilterDeclaration and CollisionFilterManager::Apply() to
filter collisions between the geometries registered to the bodies.</p>
<p>For example:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Don&#39;t report on collisions between geometries affixed to `body1`,</span>
<span class="c1">// `body2`, or `body3`.</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">RigidBody</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*&gt;</span><span class="w"> </span><span class="n">bodies</span><span class="p">{</span><span class="o">&amp;</span><span class="n">body1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">body2</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">body3</span><span class="p">};</span>
<span class="n">geometry</span><span class="o">::</span><span class="n">GeometrySet</span><span class="w"> </span><span class="n">set</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">plant</span><span class="p">.</span><span class="n">CollectRegisteredGeometries</span><span class="p">(</span><span class="n">bodies</span><span class="p">);</span>
<span class="n">scene_graph</span><span class="p">.</span><span class="n">collision_filter_manager</span><span class="p">().</span><span class="n">Apply</span><span class="p">(</span>
<span class="w">    </span><span class="n">CollisionFilterDeclaration</span><span class="p">().</span><span class="n">ExcludeWithin</span><span class="p">(</span><span class="n">set</span><span class="p">));</span>
</pre></div>
</div>
</details><div class="admonition note">
<p class="admonition-title">Note</p>
<p>There is a <em>very</em> specific order of operations:</p>
</div>
<ol class="arabic simple">
<li><p>Bodies and geometries must be added to the MultibodyPlant.</p></li>
<li><p>Create GeometrySet instances from bodies (via this method).</p></li>
<li><p>Invoke SceneGraph::ExcludeCollisions*() to filter collisions.</p></li>
<li><p>Allocate context.</p></li>
</ol>
<p>Changing the order will cause exceptions to be thrown.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if this MultibodyPlant was not registered with a</strong> – </p></li>
<li><p><strong>SceneGraph.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.deformable_model">
<span class="sig-name descname"><span class="pre">deformable_model</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">drake::multibody::DeformableModel&lt;drake::symbolic::Expression&gt;</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.deformable_model" title="Link to this definition"></a></dt>
<dd><p>Returns the DeformableModel owned by this plant.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This feature is considered to be <strong>experimental</strong> and may change
or be removed at any time, without any deprecation notice ahead of
time.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.EvalBodyPoseInWorld">
<span class="sig-name descname"><span class="pre">EvalBodyPoseInWorld</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.systems.framework.Context_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.RigidBody_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.math.RigidTransform_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.EvalBodyPoseInWorld" title="Link to this definition"></a></dt>
<dd><p>Evaluate the pose <code class="docutils literal notranslate"><span class="pre">X_WB</span></code> of a body B in the world frame W.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context storing the state of the model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body_B</span></code>:</dt><dd><p>The body B for which the pose is requested.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">X_WB</span></code>:</dt><dd><p>The pose of body frame B in the world frame W.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if Finalize</strong><strong>(</strong><strong>) </strong><strong>was not called on this model</strong><strong> or </strong><strong>if</strong> – </p></li>
<li><p><strong>body_B` does not belong to this model</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.EvalBodySpatialAccelerationInWorld">
<span class="sig-name descname"><span class="pre">EvalBodySpatialAccelerationInWorld</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.systems.framework.Context_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.RigidBody_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.multibody.math.SpatialAcceleration_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.EvalBodySpatialAccelerationInWorld" title="Link to this definition"></a></dt>
<dd><p>Evaluates A_WB, body B’s spatial acceleration in the world frame W.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context storing the state of the model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body_B</span></code>:</dt><dd><p>The body for which spatial acceleration is requested.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">A_WB_W</span></code>:</dt><dd><p>RigidBody B’s spatial acceleration in the world frame W, expressed
in W (for point Bo, the body’s origin).</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if Finalize</strong><strong>(</strong><strong>) </strong><strong>was not called on this model</strong><strong> or </strong><strong>if</strong> – </p></li>
<li><p><strong>body_B` does not belong to this model</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When cached values are out of sync with the state stored in
context, this method performs an expensive forward dynamics
computation, whereas once evaluated, successive calls to this
method are inexpensive.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.EvalBodySpatialVelocityInWorld">
<span class="sig-name descname"><span class="pre">EvalBodySpatialVelocityInWorld</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.systems.framework.Context_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.RigidBody_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.multibody.math.SpatialVelocity_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.EvalBodySpatialVelocityInWorld" title="Link to this definition"></a></dt>
<dd><p>Evaluates V_WB, body B’s spatial velocity in the world frame W.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context storing the state of the model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body_B</span></code>:</dt><dd><p>The body B for which the spatial velocity is requested.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">V_WB_W</span></code>:</dt><dd><p>RigidBody B’s spatial velocity in the world frame W, expressed in
W (for point Bo, the body’s origin).</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if Finalize</strong><strong>(</strong><strong>) </strong><strong>was not called on this model</strong><strong> or </strong><strong>if</strong> – </p></li>
<li><p><strong>body_B` does not belong to this model</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.EvalSceneGraphInspector">
<span class="sig-name descname"><span class="pre">EvalSceneGraphInspector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.systems.framework.Context_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.geometry.SceneGraphInspector_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.EvalSceneGraphInspector" title="Link to this definition"></a></dt>
<dd><p>Returns the inspector from the <code class="docutils literal notranslate"><span class="pre">context</span></code> for the SceneGraph
associated with this plant, via this plant’s “geometry_query” input
port. (In the future, the inspector might come from a different
context source that is more efficient than the “geometry_query” input
port.)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.Finalize">
<span class="sig-name descname"><span class="pre">Finalize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.Finalize" title="Link to this definition"></a></dt>
<dd><p>This method must be called after all elements in the model (joints,
bodies, force elements, constraints, etc.) are added and before any
computations are performed. It essentially compiles all the necessary
“topological information”, i.e. how bodies, joints and, any other
elements connect with each other, and performs all the required
pre-processing to enable computations at a later stage.</p>
<p>If the finalize stage is successful, the topology of this
MultibodyPlant is valid, meaning that the topology is up-to-date after
this call. No more multibody elements can be added after a call to
Finalize().</p>
<p>At Finalize(), state and input/output ports for <code class="docutils literal notranslate"><span class="pre">this</span></code> plant are
declared.</p>
<p>For a full account of the effects of Finalize(), see
mbp_finalize_stage “Finalize() stage”.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>is_finalized(), mbp_finalize_stage “Finalize() stage”.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if the MultibodyPlant has already been finalized.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.geometry_source_is_registered">
<span class="sig-name descname"><span class="pre">geometry_source_is_registered</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.geometry_source_is_registered" title="Link to this definition"></a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if <code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant was registered with a
SceneGraph. This method can be called at any time during the lifetime
of <code class="docutils literal notranslate"><span class="pre">this</span></code> plant to query if <code class="docutils literal notranslate"><span class="pre">this</span></code> plant has been registered with
a SceneGraph, either pre- or post-finalize, see Finalize().</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.get_actuation_input_port">
<span class="sig-name descname"><span class="pre">get_actuation_input_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.get_actuation_input_port" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>get_actuation_input_port(self: pydrake.multibody.plant.MultibodyPlant_[Expression]) -&gt; pydrake.systems.framework.InputPort_[Expression]</p></li>
</ol>
<p>Returns a constant reference to the input port for external actuation
for all actuated dofs. This input port is a vector valued port and can
be set with JointActuator::set_actuation_vector(). The actuation value
for a particular actuator can be found at offset
JointActuator::input_start() in this vector. Refer to mbp_actuation
“Actuation” for further details.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>Finalize() was already called on <code class="docutils literal notranslate"><span class="pre">this</span></code> plant.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called before Finalize</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>get_actuation_input_port(self: pydrake.multibody.plant.MultibodyPlant_[Expression], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; pydrake.systems.framework.InputPort_[Expression]</p></li>
</ol>
<p>Returns a constant reference to the input port for external actuation
for a specific model instance. This is a vector valued port with
entries ordered by monotonically increasing JointActuatorIndex within
<code class="docutils literal notranslate"><span class="pre">model_instance</span></code>. Refer to mbp_actuation “Actuation” for further
details.</p>
<p>Every model instance in <code class="docutils literal notranslate"><span class="pre">this</span></code> plant model has an actuation input
port, even if zero sized (for model instance with no actuators).</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>GetJointActuatorIndices(), GetActuatedJointIndices().</p>
</div>
<dl class="simple">
<dt>Precondition:</dt><dd><p>Finalize() was already called on <code class="docutils literal notranslate"><span class="pre">this</span></code> plant.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if called before Finalize</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p></li>
<li><p><strong>RuntimeError if the model instance does not exist.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.get_adjacent_bodies_collision_filters">
<span class="sig-name descname"><span class="pre">get_adjacent_bodies_collision_filters</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.get_adjacent_bodies_collision_filters" title="Link to this definition"></a></dt>
<dd><p>Returns whether to apply collision filters to topologically adjacent
bodies at Finalize() time.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.get_applied_generalized_force_input_port">
<span class="sig-name descname"><span class="pre">get_applied_generalized_force_input_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.systems.framework.InputPort_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.get_applied_generalized_force_input_port" title="Link to this definition"></a></dt>
<dd><p>Returns a constant reference to the vector-valued input port for
applied generalized forces, and the vector will be added directly into
<code class="docutils literal notranslate"><span class="pre">tau</span></code> (see mbp_equations_of_motion “System dynamics”). This vector
is ordered using the same convention as the plant velocities: you can
set the generalized forces that will be applied to model instance i
using, e.g., <code class="docutils literal notranslate"><span class="pre">SetVelocitiesInArray(i,</span> <span class="pre">model_forces,</span> <span class="pre">&amp;force_array)</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called before Finalize</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.get_applied_spatial_force_input_port">
<span class="sig-name descname"><span class="pre">get_applied_spatial_force_input_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.systems.framework.InputPort_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.get_applied_spatial_force_input_port" title="Link to this definition"></a></dt>
<dd><p>Returns a constant reference to the input port for applying spatial
forces to bodies in the plant. The data type for the port is an
std::vector of ExternallyAppliedSpatialForce; any number of spatial
forces can be applied to any number of bodies in the plant.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.get_body">
<span class="sig-name descname"><span class="pre">get_body</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.BodyIndex" title="pydrake.multibody.tree.BodyIndex"><span class="pre">pydrake.multibody.tree.BodyIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.multibody.tree.RigidBody_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.get_body" title="Link to this definition"></a></dt>
<dd><p>Returns a constant reference to the body with unique index
<code class="docutils literal notranslate"><span class="pre">body_index</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if body_index does not correspond to a body in</strong> – </p></li>
<li><p><strong>this model.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.get_body_poses_output_port">
<span class="sig-name descname"><span class="pre">get_body_poses_output_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.systems.framework.OutputPort_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.get_body_poses_output_port" title="Link to this definition"></a></dt>
<dd><p>Returns the output port of all body poses in the world frame. You can
obtain the pose <code class="docutils literal notranslate"><span class="pre">X_WB</span></code> of a body B in the world frame W with:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">X_WB_all</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">plant</span><span class="p">.</span><span class="n">get_body_poses_output_port</span><span class="p">().</span>
<span class="w">      </span><span class="p">.</span><span class="n">Eval</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">math</span><span class="o">::</span><span class="n">RigidTransform</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">plant_context</span><span class="p">);</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">BodyIndex</span><span class="w"> </span><span class="n">arm_body_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">plant</span><span class="p">.</span><span class="n">GetBodyByName</span><span class="p">(</span><span class="s">&quot;arm&quot;</span><span class="p">).</span><span class="n">index</span><span class="p">();</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">math</span><span class="o">::</span><span class="n">RigidTransform</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">X_WArm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">X_WB_all</span><span class="p">[</span><span class="n">arm_body_index</span><span class="p">];</span>
</pre></div>
</div>
</details><p>As shown in the example above, the resulting <code class="docutils literal notranslate"><span class="pre">std::vector</span></code> of body
poses is indexed by BodyIndex, and it has size num_bodies(). BodyIndex
“zero” (0) always corresponds to the world body, with pose equal to
the identity at all times.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.get_body_spatial_accelerations_output_port">
<span class="sig-name descname"><span class="pre">get_body_spatial_accelerations_output_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.systems.framework.OutputPort_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.get_body_spatial_accelerations_output_port" title="Link to this definition"></a></dt>
<dd><p>Returns the output port of all body spatial accelerations in the world
frame. You can obtain the spatial acceleration <code class="docutils literal notranslate"><span class="pre">A_WB</span></code> of a body B
(for point Bo, the body’s origin) in the world frame W with:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">A_WB_all</span><span class="w"> </span><span class="o">=</span>
<span class="w">  </span><span class="n">plant</span><span class="p">.</span><span class="n">get_body_spatial_accelerations_output_port</span><span class="p">().</span>
<span class="w">      </span><span class="p">.</span><span class="n">Eval</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SpatialAcceleration</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">plant_context</span><span class="p">);</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">BodyIndex</span><span class="w"> </span><span class="n">arm_body_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">plant</span><span class="p">.</span><span class="n">GetBodyByName</span><span class="p">(</span><span class="s">&quot;arm&quot;</span><span class="p">).</span><span class="n">index</span><span class="p">();</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">SpatialVelocity</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">A_WArm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A_WB_all</span><span class="p">[</span><span class="n">arm_body_index</span><span class="p">];</span>
</pre></div>
</div>
</details><p>As shown in the example above, the resulting <code class="docutils literal notranslate"><span class="pre">std::vector</span></code> of body
spatial accelerations is indexed by BodyIndex, and it has size
num_bodies(). BodyIndex “zero” (0) always corresponds to the world
body, with zero spatial acceleration at all times.</p>
<p>In a discrete-time plant, the use_sampled_output_ports setting affects
the output of this port. See output_port_sampling “Output port
sampling” for details. When sampling is enabled and the plant has not
yet taken a step, the output value will be all zeros.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.get_body_spatial_velocities_output_port">
<span class="sig-name descname"><span class="pre">get_body_spatial_velocities_output_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.systems.framework.OutputPort_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.get_body_spatial_velocities_output_port" title="Link to this definition"></a></dt>
<dd><p>Returns the output port of all body spatial velocities in the world
frame. You can obtain the spatial velocity <code class="docutils literal notranslate"><span class="pre">V_WB</span></code> of a body B in the
world frame W with:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">V_WB_all</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">plant</span><span class="p">.</span><span class="n">get_body_spatial_velocities_output_port</span><span class="p">().</span>
<span class="w">      </span><span class="p">.</span><span class="n">Eval</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SpatialVelocity</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">plant_context</span><span class="p">);</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">BodyIndex</span><span class="w"> </span><span class="n">arm_body_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">plant</span><span class="p">.</span><span class="n">GetBodyByName</span><span class="p">(</span><span class="s">&quot;arm&quot;</span><span class="p">).</span><span class="n">index</span><span class="p">();</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">SpatialVelocity</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">V_WArm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">V_WB_all</span><span class="p">[</span><span class="n">arm_body_index</span><span class="p">];</span>
</pre></div>
</div>
</details><p>As shown in the example above, the resulting <code class="docutils literal notranslate"><span class="pre">std::vector</span></code> of body
spatial velocities is indexed by BodyIndex, and it has size
num_bodies(). BodyIndex “zero” (0) always corresponds to the world
body, with zero spatial velocity at all times.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.get_contact_model">
<span class="sig-name descname"><span class="pre">get_contact_model</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.multibody.plant.ContactModel" title="pydrake.multibody.plant.ContactModel"><span class="pre">pydrake.multibody.plant.ContactModel</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.get_contact_model" title="Link to this definition"></a></dt>
<dd><p>Returns the model used for contact. See documentation for
ContactModel.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.get_contact_penalty_method_time_scale">
<span class="sig-name descname"><span class="pre">get_contact_penalty_method_time_scale</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.get_contact_penalty_method_time_scale" title="Link to this definition"></a></dt>
<dd><p>Returns a time-scale estimate <code class="docutils literal notranslate"><span class="pre">tc</span></code> based on the requested
penetration allowance δ set with set_penetration_allowance(). For the
compliant contact model to enforce non-penetration, this time scale
relates to the time it takes the relative normal velocity between two
bodies to go to zero. This time scale <code class="docutils literal notranslate"><span class="pre">tc</span></code> is a global estimate of
the dynamics introduced by the compliant contact model and goes to
zero in the limit to ideal rigid contact. Since numerical integration
methods for continuum systems must be able to resolve a system’s
dynamics, the time step used by an integrator must in general be much
smaller than the time scale <code class="docutils literal notranslate"><span class="pre">tc</span></code>. How much smaller will depend on
the details of the problem and the convergence characteristics of the
integrator and should be tuned appropriately. Another factor to take
into account for setting up the simulation’s time step is the speed of
the objects in your simulation. If <code class="docutils literal notranslate"><span class="pre">vn</span></code> represents a reference
velocity scale for the normal relative velocity between bodies, the
new time scale <code class="docutils literal notranslate"><span class="pre">tn</span> <span class="pre">=</span> <span class="pre">δ</span> <span class="pre">/</span> <span class="pre">vn</span></code> represents the time it would take for
the distance between two bodies approaching with relative normal
velocity <code class="docutils literal notranslate"><span class="pre">vn</span></code> to decrease by the penetration_allowance δ. In this
case a user should choose a time step for simulation that can resolve
the smallest of the two time scales <code class="docutils literal notranslate"><span class="pre">tc</span></code> and <code class="docutils literal notranslate"><span class="pre">tn</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.get_contact_results_output_port">
<span class="sig-name descname"><span class="pre">get_contact_results_output_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.systems.framework.OutputPort_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.get_contact_results_output_port" title="Link to this definition"></a></dt>
<dd><p>Returns a constant reference to the port that outputs ContactResults.</p>
<p>In a discrete-time plant, the use_sampled_output_ports setting affects
the output of this port. See output_port_sampling “Output port
sampling” for details. When sampling is enabled and the plant has not
yet taken a step, the output value will be empty (no contacts).</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize</strong><strong>, </strong><strong>see Finalize</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.get_contact_surface_representation">
<span class="sig-name descname"><span class="pre">get_contact_surface_representation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.HydroelasticContactRepresentation" title="pydrake.geometry.HydroelasticContactRepresentation"><span class="pre">pydrake.geometry.HydroelasticContactRepresentation</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.get_contact_surface_representation" title="Link to this definition"></a></dt>
<dd><p>Gets the current representation of contact surfaces used by <code class="docutils literal notranslate"><span class="pre">this</span></code>
MultibodyPlant.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.get_deformable_body_configuration_output_port">
<span class="sig-name descname"><span class="pre">get_deformable_body_configuration_output_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.systems.framework.OutputPort_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.get_deformable_body_configuration_output_port" title="Link to this definition"></a></dt>
<dd><p>Returns the output port for vertex positions (configurations),
measured and expressed in the World frame, of the deformable bodies in
<code class="docutils literal notranslate"><span class="pre">this</span></code> plant as a GeometryConfigurationVector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.get_desired_state_input_port">
<span class="sig-name descname"><span class="pre">get_desired_state_input_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.systems.framework.InputPort_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.get_desired_state_input_port" title="Link to this definition"></a></dt>
<dd><p>For models with PD controlled joint actuators, returns the port to
provide the desired state for the given <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>. Refer to
mbp_actuation “Actuation” for further details.</p>
<p>For consistency with get_actuation_input_port(), each model instance
in <code class="docutils literal notranslate"><span class="pre">this</span></code> plant model has a desired states input port, even if zero
sized (for model instance with no actuators.)</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This port always has size 2 * num_actuators(model_instance), where
we assume 1-DOF actuated joints. This port must provide one
desired position and one desired velocity per joint actuator,
packed as xd = [qd, vd], with positions and velocities in order of
increasing JointActuatorIndex. Only desired states corresponding
to PD-controlled actuators on non-locked joints
(Joint::is_locked()) are used, the rest are ignored. That is PD
control on just a subset of actuators is allowed.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The desired state input port for a given model instance is not
required to be connected. If disconnected, the controllers for
such model instance will be <em>disarmed</em>. Refer to
pd_controllers_and_ports for further details.</p>
</div>
<p>As an example of this structure, consider the following code to fix
desired states input values:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">plant</span><span class="p">;</span>
<span class="c1">// ... Load/parse plant model ...</span>
<span class="n">plant</span><span class="p">.</span><span class="n">Finalize</span><span class="p">();</span>
<span class="k">auto</span><span class="w"> </span><span class="n">context</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">plant</span><span class="p">.</span><span class="n">CreateDefaultContext</span><span class="p">();</span>
<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">num_u</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">plant</span><span class="p">.</span><span class="n">num_actuators</span><span class="p">(</span><span class="n">model_instance</span><span class="p">);</span>
<span class="k">const</span><span class="w"> </span><span class="n">VectorXd</span><span class="w"> </span><span class="nf">model_xd</span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">num_u</span><span class="p">);</span>
<span class="k">auto</span><span class="w"> </span><span class="n">model_qd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">model_xd</span><span class="p">.</span><span class="n">head</span><span class="p">(</span><span class="n">num_u</span><span class="p">);</span>
<span class="k">auto</span><span class="w"> </span><span class="n">model_vd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">model_xd</span><span class="p">.</span><span class="n">tail</span><span class="p">(</span><span class="n">num_u</span><span class="p">);</span>

<span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="c1">// Specify qd and vd in increasing order of JointActuatorIndex, as</span>
<span class="c1">// returned by GetJointActuatorIndices().</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">JointActuatorIndex</span><span class="w"> </span><span class="n">actuator_index</span><span class="w"> </span><span class="o">:</span>
<span class="w">    </span><span class="n">plant</span><span class="p">.</span><span class="n">GetJointActuatorIndices</span><span class="p">(</span><span class="n">model_instance</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">qd</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">....</span><span class="w"> </span><span class="n">desired</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">actuator_index</span>
<span class="w">  </span><span class="n">vd</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">....</span><span class="w"> </span><span class="n">desired</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">actuator_index</span>
<span class="w">  </span><span class="o">++</span><span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// As an example, fix values in the context.</span>
<span class="n">plant</span><span class="p">.</span><span class="n">get_desired_state_input_port</span><span class="p">(</span><span class="n">model_instance</span><span class="p">).</span><span class="n">FixValue</span><span class="p">(</span>
<span class="w">    </span><span class="o">&amp;</span><span class="n">plant_context</span><span class="p">,</span><span class="w"> </span><span class="n">model_xd</span><span class="p">);</span>
</pre></div>
</div>
</details></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.get_discrete_contact_approximation">
<span class="sig-name descname"><span class="pre">get_discrete_contact_approximation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.multibody.plant.DiscreteContactApproximation" title="pydrake.multibody.plant.DiscreteContactApproximation"><span class="pre">pydrake.multibody.plant.DiscreteContactApproximation</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.get_discrete_contact_approximation" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>the discrete contact solver approximation.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.get_discrete_contact_solver">
<span class="sig-name descname"><span class="pre">get_discrete_contact_solver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.multibody.plant.DiscreteContactSolver" title="pydrake.multibody.plant.DiscreteContactSolver"><span class="pre">pydrake.multibody.plant.DiscreteContactSolver</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.get_discrete_contact_solver" title="Link to this definition"></a></dt>
<dd><p>Returns the contact solver type used for discrete MultibodyPlant
models.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.get_force_element">
<span class="sig-name descname"><span class="pre">get_force_element</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">force_element_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ForceElementIndex" title="pydrake.multibody.tree.ForceElementIndex"><span class="pre">pydrake.multibody.tree.ForceElementIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.multibody.tree.ForceElement_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.get_force_element" title="Link to this definition"></a></dt>
<dd><p>Returns a constant reference to the force element with unique index
<code class="docutils literal notranslate"><span class="pre">force_element_index</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError when force_element_index does not correspond to a</strong> – </p></li>
<li><p><strong>force element in this model.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.get_frame">
<span class="sig-name descname"><span class="pre">get_frame</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.FrameIndex" title="pydrake.multibody.tree.FrameIndex"><span class="pre">pydrake.multibody.tree.FrameIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.multibody.tree.Frame_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.get_frame" title="Link to this definition"></a></dt>
<dd><p>Returns a constant reference to the frame with unique index
<code class="docutils literal notranslate"><span class="pre">frame_index</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if frame_index does not correspond to a frame in</strong> – </p></li>
<li><p><strong>this plant.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.get_generalized_acceleration_output_port">
<span class="sig-name descname"><span class="pre">get_generalized_acceleration_output_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.get_generalized_acceleration_output_port" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>get_generalized_acceleration_output_port(self: pydrake.multibody.plant.MultibodyPlant_[Expression]) -&gt; pydrake.systems.framework.OutputPort_[Expression]</p></li>
</ol>
<p>Returns a constant reference to the output port for generalized
accelerations v̇ of the model.</p>
<p>In a discrete-time plant, the use_sampled_output_ports setting affects
the output of this port. See output_port_sampling “Output port
sampling” for details. When sampling is enabled and the plant has not
yet taken a step, the output value will be all zeros.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>Finalize() was already called on <code class="docutils literal notranslate"><span class="pre">this</span></code> plant.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called before Finalize</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>get_generalized_acceleration_output_port(self: pydrake.multibody.plant.MultibodyPlant_[Expression], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; pydrake.systems.framework.OutputPort_[Expression]</p></li>
</ol>
<p>Returns a constant reference to the output port for the generalized
accelerations v̇ᵢ ⊆ v̇ for model instance i.</p>
<p>In a discrete-time plant, the use_sampled_output_ports setting affects
the output of this port. See output_port_sampling “Output port
sampling” for details. When sampling is enabled and the plant has not
yet taken a step, the output value will be all zeros.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>Finalize() was already called on <code class="docutils literal notranslate"><span class="pre">this</span></code> plant.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if called before Finalize</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p></li>
<li><p><strong>RuntimeError if the model instance does not exist.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.get_generalized_contact_forces_output_port">
<span class="sig-name descname"><span class="pre">get_generalized_contact_forces_output_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.systems.framework.OutputPort_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.get_generalized_contact_forces_output_port" title="Link to this definition"></a></dt>
<dd><p>Returns a constant reference to the output port of generalized contact
forces for a specific model instance.</p>
<p>In a discrete-time plant, the use_sampled_output_ports setting affects
the output of this port. See output_port_sampling “Output port
sampling” for details. When sampling is enabled and the plant has not
yet taken a step, the output value will be all zeros.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>Finalize() was already called on <code class="docutils literal notranslate"><span class="pre">this</span></code> plant.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if called before Finalize</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p></li>
<li><p><strong>RuntimeError if the model instance does not exist.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.get_geometry_pose_output_port">
<span class="sig-name descname"><span class="pre">get_geometry_pose_output_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.systems.framework.OutputPort_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.get_geometry_pose_output_port" title="Link to this definition"></a></dt>
<dd><p>Returns the output port of frames’ poses to communicate with a
SceneGraph.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.get_geometry_query_input_port">
<span class="sig-name descname"><span class="pre">get_geometry_query_input_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.systems.framework.InputPort_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.get_geometry_query_input_port" title="Link to this definition"></a></dt>
<dd><p>Returns a constant reference to the input port used to perform
geometric queries on a SceneGraph. See
SceneGraph::get_query_output_port(). Refer to section mbp_geometry
“Geometry” of this class’s documentation for further details on
collision geometry registration and connection with a SceneGraph.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.get_joint">
<span class="sig-name descname"><span class="pre">get_joint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">joint_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JointIndex" title="pydrake.multibody.tree.JointIndex"><span class="pre">pydrake.multibody.tree.JointIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.multibody.tree.Joint_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.get_joint" title="Link to this definition"></a></dt>
<dd><p>Returns a constant reference to the joint with unique index
<code class="docutils literal notranslate"><span class="pre">joint_index</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError when joint_index does not correspond to a joint</strong> – </p></li>
<li><p><strong>in this model.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.get_joint_actuator">
<span class="sig-name descname"><span class="pre">get_joint_actuator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">actuator_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JointActuatorIndex" title="pydrake.multibody.tree.JointActuatorIndex"><span class="pre">pydrake.multibody.tree.JointActuatorIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.multibody.tree.JointActuator_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.get_joint_actuator" title="Link to this definition"></a></dt>
<dd><p>Returns a constant reference to the joint actuator with unique index
<code class="docutils literal notranslate"><span class="pre">actuator_index</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if actuator_index does not correspond to a joint</strong> – </p></li>
<li><p><strong>actuator in this tree.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.get_mutable_joint">
<span class="sig-name descname"><span class="pre">get_mutable_joint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">joint_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JointIndex" title="pydrake.multibody.tree.JointIndex"><span class="pre">pydrake.multibody.tree.JointIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.multibody.tree.Joint_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.get_mutable_joint" title="Link to this definition"></a></dt>
<dd><p>Returns a mutable reference to the joint with unique index
<code class="docutils literal notranslate"><span class="pre">joint_index</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError when joint_index does not correspond to a joint</strong> – </p></li>
<li><p><strong>in this model.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.get_mutable_joint_actuator">
<span class="sig-name descname"><span class="pre">get_mutable_joint_actuator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">actuator_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JointActuatorIndex" title="pydrake.multibody.tree.JointActuatorIndex"><span class="pre">pydrake.multibody.tree.JointActuatorIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.multibody.tree.JointActuator_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.get_mutable_joint_actuator" title="Link to this definition"></a></dt>
<dd><p>Returns a mutable reference to the joint actuator with unique index
<code class="docutils literal notranslate"><span class="pre">actuator_index</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if actuator_index does not correspond to a joint</strong> – </p></li>
<li><p><strong>actuator in this tree.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.get_net_actuation_output_port">
<span class="sig-name descname"><span class="pre">get_net_actuation_output_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.get_net_actuation_output_port" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>get_net_actuation_output_port(self: pydrake.multibody.plant.MultibodyPlant_[Expression]) -&gt; pydrake.systems.framework.OutputPort_[Expression]</p></li>
</ol>
<p>Returns a constant reference to the output port that reports actuation
values applied through joint actuators. This output port is a vector
valued port. The actuation value for a particular actuator can be
found at offset JointActuator::input_start() in this vector. Models
that include PD controllers will include their contribution in this
port, refer to mbp_actuation “Actuation” for further details.</p>
<p>In a discrete-time plant, the use_sampled_output_ports setting affects
the output of this port. See output_port_sampling “Output port
sampling” for details. When sampling is enabled and the plant has not
yet taken a step, the output value will be all zeros.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>PD controllers are not considered for actuators on locked joints,
see Joint::Lock(). Therefore they do not contribute to this port.</p>
</div>
<dl class="simple">
<dt>Precondition:</dt><dd><p>Finalize() was already called on <code class="docutils literal notranslate"><span class="pre">this</span></code> plant.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called before Finalize</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>get_net_actuation_output_port(self: pydrake.multibody.plant.MultibodyPlant_[Expression], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; pydrake.systems.framework.OutputPort_[Expression]</p></li>
</ol>
<p>Returns a constant reference to the output port that reports actuation
values applied through joint actuators, for a specific model instance.
Models that include PD controllers will include their contribution in
this port, refer to mbp_actuation “Actuation” for further details.
This is a vector valued port with entries ordered by monotonically
increasing JointActuatorIndex within <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>.</p>
<p>Every model instance in <code class="docutils literal notranslate"><span class="pre">this</span></code> plant model has a net actuation
output port, even if zero sized (for model instance with no
actuators).</p>
<p>In a discrete-time plant, the use_sampled_output_ports setting affects
the output of this port. See output_port_sampling “Output port
sampling” for details. When sampling is enabled and the plant has not
yet taken a step, the output value will be all zeros.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>PD controllers are not considered for actuators on locked joints,
see Joint::Lock(). Therefore they do not contribute to this port.</p>
</div>
<dl class="simple">
<dt>Precondition:</dt><dd><p>Finalize() was already called on <code class="docutils literal notranslate"><span class="pre">this</span></code> plant.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called before Finalize</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.get_reaction_forces_output_port">
<span class="sig-name descname"><span class="pre">get_reaction_forces_output_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.systems.framework.OutputPort_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.get_reaction_forces_output_port" title="Link to this definition"></a></dt>
<dd><p>Returns the port for joint reaction forces. A Joint models the
kinematical relationship which characterizes the possible relative
motion between two bodies. In Drake, a joint connects a frame <code class="docutils literal notranslate"><span class="pre">Jp</span></code>
on <em>parent</em> body P with a frame <code class="docutils literal notranslate"><span class="pre">Jc</span></code> on a <em>child</em> body C. This usage
of the terms <em>parent</em> and <em>child</em> is just a convention and implies
nothing about the inboard-outboard relationship between the bodies.
Since a Joint imposes a kinematical relationship which characterizes
the possible relative motion between frames Jp and Jc, reaction forces
on each body are established. That is, we could cut the model at the
joint and replace it with equivalent forces equal to these reaction
forces in order to attain the same motions of the mechanical system.</p>
<p>This output port allows to evaluate the reaction force <code class="docutils literal notranslate"><span class="pre">F_CJc_Jc</span></code> on
the <em>child</em> body C, at <code class="docutils literal notranslate"><span class="pre">Jc</span></code>, and expressed in Jc for all joints in
the model. This port evaluates to a vector of type
std::vector&lt;SpatialForce&lt;T&gt;&gt; and size num_joints() indexed by
JointIndex, see Joint::index(). Each entry corresponds to the spatial
force <code class="docutils literal notranslate"><span class="pre">F_CJc_Jc</span></code> applied on the joint’s child body C
(Joint::child_body()), at the joint’s child frame <code class="docutils literal notranslate"><span class="pre">Jc</span></code>
(Joint::frame_on_child()) and expressed in frame <code class="docutils literal notranslate"><span class="pre">Jc</span></code>.</p>
<p>In a discrete-time plant, the use_sampled_output_ports setting affects
the output of this port. See output_port_sampling “Output port
sampling” for details. When sampling is enabled and the plant has not
yet taken a step, the output value will be all zeros.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.get_sap_near_rigid_threshold">
<span class="sig-name descname"><span class="pre">get_sap_near_rigid_threshold</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.get_sap_near_rigid_threshold" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>the SAP near rigid regime threshold.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>See set_sap_near_rigid_threshold().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.get_source_id">
<span class="sig-name descname"><span class="pre">get_source_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.SourceId" title="pydrake.geometry.SourceId"><span class="pre">pydrake.geometry.SourceId</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.get_source_id" title="Link to this definition"></a></dt>
<dd><p>Returns the unique id identifying <code class="docutils literal notranslate"><span class="pre">this</span></code> plant as a source for a
SceneGraph. Returns <code class="docutils literal notranslate"><span class="pre">nullopt</span></code> if <code class="docutils literal notranslate"><span class="pre">this</span></code> plant did not register any
geometry. This method can be called at any time during the lifetime of
<code class="docutils literal notranslate"><span class="pre">this</span></code> plant to query if <code class="docutils literal notranslate"><span class="pre">this</span></code> plant has been registered with a
SceneGraph, either pre- or post-finalize, see Finalize(). However, a
geometry::SourceId is only assigned once at the first call of any of
this plant’s geometry registration methods, and it does not change
after that. Post-finalize calls will always return the same value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.get_state_output_port">
<span class="sig-name descname"><span class="pre">get_state_output_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.get_state_output_port" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>get_state_output_port(self: pydrake.multibody.plant.MultibodyPlant_[Expression]) -&gt; pydrake.systems.framework.OutputPort_[Expression]</p></li>
</ol>
<p>Returns a constant reference to the output port for the multibody
state x = [q, v] of the model.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>Finalize() was already called on <code class="docutils literal notranslate"><span class="pre">this</span></code> plant.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called before Finalize</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>get_state_output_port(self: pydrake.multibody.plant.MultibodyPlant_[Expression], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; pydrake.systems.framework.OutputPort_[Expression]</p></li>
</ol>
<p>Returns a constant reference to the output port for the state xᵢ = [qᵢ
vᵢ] of model instance i. (Here qᵢ ⊆ q and vᵢ ⊆ v.)</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>Finalize() was already called on <code class="docutils literal notranslate"><span class="pre">this</span></code> plant.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if called before Finalize</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p></li>
<li><p><strong>RuntimeError if the model instance does not exist.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetAccelerationLowerLimits">
<span class="sig-name descname"><span class="pre">GetAccelerationLowerLimits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetAccelerationLowerLimits" title="Link to this definition"></a></dt>
<dd><p>Returns a vector of size <code class="docutils literal notranslate"><span class="pre">num_velocities()</span></code> containing the lower
acceleration limits for every generalized velocity coordinate. These
include joint and free body coordinates. Any unbounded or unspecified
limits will be -infinity.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetAccelerationUpperLimits">
<span class="sig-name descname"><span class="pre">GetAccelerationUpperLimits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetAccelerationUpperLimits" title="Link to this definition"></a></dt>
<dd><p>Upper limit analog of GetAccelerationsLowerLimits(), where any
unbounded or unspecified limits will be +infinity.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>GetAccelerationLowerLimits() for more information.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetActuatedJointIndices">
<span class="sig-name descname"><span class="pre">GetActuatedJointIndices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JointIndex" title="pydrake.multibody.tree.JointIndex"><span class="pre">pydrake.multibody.tree.JointIndex</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetActuatedJointIndices" title="Link to this definition"></a></dt>
<dd><p>Returns a list of actuated joint indices associated with
<code class="docutils literal notranslate"><span class="pre">model_instance</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetActuationFromArray">
<span class="sig-name descname"><span class="pre">GetActuationFromArray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">u</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetActuationFromArray" title="Link to this definition"></a></dt>
<dd><p>Returns a vector of actuation values for <code class="docutils literal notranslate"><span class="pre">model_instance</span></code> from a
vector <code class="docutils literal notranslate"><span class="pre">u</span></code> of actuation values for the entire plant model. Refer to
mbp_actuation “Actuation” for further details.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">u</span></code>:</dt><dd><p>Actuation values for the entire model. The actuation value in
<code class="docutils literal notranslate"><span class="pre">u</span></code> for a particular actuator must be found at offset
JointActuator::input_start().</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Actuation values for <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>, ordered by monotonically
increasing JointActuatorIndex.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>RuntimeError if u is not</strong><strong> of </strong><strong>size</strong> – </p></li>
<li><p><strong>MultibodyPlant::num_actuated_dofs</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetActuatorNames">
<span class="sig-name descname"><span class="pre">GetActuatorNames</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetActuatorNames" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetActuatorNames(self: pydrake.multibody.plant.MultibodyPlant_[Expression], add_model_instance_prefix: bool = True) -&gt; list[str]</p></li>
</ol>
<p>Returns a list of string names corresponding to each element of the
actuation vector. These strings take the form
<code class="docutils literal notranslate"><span class="pre">{model_instance_name}_{joint_actuator_name}</span></code>, but the prefix may
optionally be withheld using <code class="docutils literal notranslate"><span class="pre">add_model_instance_prefix</span></code>.</p>
<p>The returned names are guaranteed to be unique if
<code class="docutils literal notranslate"><span class="pre">add_model_instance_prefix</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code> (the default).</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if the plant is not finalized.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>GetActuatorNames(self: pydrake.multibody.plant.MultibodyPlant_[Expression], model_instance: pydrake.multibody.tree.ModelInstanceIndex, add_model_instance_prefix: bool = False) -&gt; list[str]</p></li>
</ol>
<p>Returns a list of string names corresponding to each element of the
actuation vector. These strings take the form
<code class="docutils literal notranslate"><span class="pre">{model_instance_name}_{joint_actuator_name}</span></code>, but the prefix may
optionally be withheld using <code class="docutils literal notranslate"><span class="pre">add_model_instance_prefix</span></code>.</p>
<p>The returned names are guaranteed to be unique.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the plant is not finalized</strong><strong> or </strong><strong>if the</strong> – </p></li>
<li><p><strong>model_instance` is invalid</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetBodiesKinematicallyAffectedBy">
<span class="sig-name descname"><span class="pre">GetBodiesKinematicallyAffectedBy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">joint_indexes</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JointIndex" title="pydrake.multibody.tree.JointIndex"><span class="pre">pydrake.multibody.tree.JointIndex</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.BodyIndex" title="pydrake.multibody.tree.BodyIndex"><span class="pre">pydrake.multibody.tree.BodyIndex</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetBodiesKinematicallyAffectedBy" title="Link to this definition"></a></dt>
<dd><p>Returns all bodies whose kinematics are transitively affected by the
given vector of Joints. This is a <em>kinematic</em> relationship rather than
a dynamic one. It is is inherently a query on the topology of the
plant’s modeled tree. Constraints are likewise not considered.</p>
<p>The affected bodies are returned in increasing order of body indices.
A body is included in the output if that body’s spatial velocity is
affected by the generalized velocities v of one of the indicated
joints.</p>
<p>As such, there are some notable implications:</p>
<p>1. If a body has an inboard free (6 dof) joint, it will be
<em>kinematically</em> affected by joints further inboard, even though there
might not be any dynamic influence on that body. 2. If the set of
joints have no velocities (i.e., they are all weld (0 dof) joints),
then, by definition, no bodies will be affected.</p>
<p>This function can be only be called post-finalize, see Finalize().</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if any</strong><strong> of </strong><strong>the given joint has an invalid index</strong><strong>,</strong> – </p></li>
<li><p><strong>doesn't correspond to a mobilizer</strong><strong>, or </strong><strong>is welded.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetBodiesWeldedTo">
<span class="sig-name descname"><span class="pre">GetBodiesWeldedTo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.RigidBody_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">pydrake.multibody.tree.RigidBody_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetBodiesWeldedTo" title="Link to this definition"></a></dt>
<dd><p>Returns all bodies that are transitively welded, or rigidly affixed,
to <code class="docutils literal notranslate"><span class="pre">body</span></code>, per these two definitions:</p>
<ol class="arabic simple">
<li><p>A body is always considered welded to itself.</p></li>
</ol>
<p>2. Two unique bodies are considered welded together exclusively by the
presence of a weld joint, not by other constructs that prevent mobility
(e.g. constraints).</p>
<p>This method can be called at any time during the lifetime of <code class="docutils literal notranslate"><span class="pre">this</span></code>
plant, either pre- or post-finalize, see Finalize().</p>
<p>Meant to be used with <code class="docutils literal notranslate"><span class="pre">CollectRegisteredGeometries</span></code>.</p>
<p>The following example demonstrates filtering collisions between all
bodies rigidly affixed to a door (which could be moving) and all
bodies rigidly affixed to the world:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">GeometrySet</span><span class="w"> </span><span class="n">g_world</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">plant</span><span class="p">.</span><span class="n">CollectRegisteredGeometries</span><span class="p">(</span>
<span class="w">    </span><span class="n">plant</span><span class="p">.</span><span class="n">GetBodiesWeldedTo</span><span class="p">(</span><span class="n">plant</span><span class="p">.</span><span class="n">world_body</span><span class="p">()));</span>
<span class="n">GeometrySet</span><span class="w"> </span><span class="n">g_door</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">plant</span><span class="p">.</span><span class="n">CollectRegisteredGeometries</span><span class="p">(</span>
<span class="w">    </span><span class="n">plant</span><span class="p">.</span><span class="n">GetBodiesWeldedTo</span><span class="p">(</span><span class="n">plant</span><span class="p">.</span><span class="n">GetBodyByName</span><span class="p">(</span><span class="s">&quot;door&quot;</span><span class="p">)));</span>
<span class="n">scene_graph</span><span class="p">.</span><span class="n">ExcludeCollisionsBetweeen</span><span class="p">(</span><span class="n">g_world</span><span class="p">,</span><span class="w"> </span><span class="n">g_door</span><span class="p">);</span>
</pre></div>
</div>
</details><div class="admonition note">
<p class="admonition-title">Note</p>
<p>Usages akin to this example may introduce redundant collision
filtering; this will not have a functional impact, but may have a
minor performance impact.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>all bodies rigidly fixed to <code class="docutils literal notranslate"><span class="pre">body</span></code>. This does not return the
bodies in any prescribed order.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>RuntimeError if body is not part</strong><strong> of </strong><strong>this plant.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetBodyByName">
<span class="sig-name descname"><span class="pre">GetBodyByName</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetBodyByName" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetBodyByName(self: pydrake.multibody.plant.MultibodyPlant_[Expression], name: str) -&gt; pydrake.multibody.tree.RigidBody_[Expression]</p></li>
</ol>
<p>Returns a constant reference to a body that is identified by the
string <code class="docutils literal notranslate"><span class="pre">name</span></code> in <code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if there is no body with the requested name.</strong> – </p></li>
<li><p><strong>RuntimeError if the body name occurs in multiple model instances.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>HasBodyNamed() to query if there exists a body in <code class="docutils literal notranslate"><span class="pre">this</span></code>
MultibodyPlant with a given specified name.</p>
</div>
<ol class="arabic simple" start="2">
<li><p>GetBodyByName(self: pydrake.multibody.plant.MultibodyPlant_[Expression], name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; pydrake.multibody.tree.RigidBody_[Expression]</p></li>
</ol>
<p>Returns a constant reference to the body that is uniquely identified
by the string <code class="docutils literal notranslate"><span class="pre">name</span></code> and <code class="docutils literal notranslate"><span class="pre">model_instance</span></code> in <code class="docutils literal notranslate"><span class="pre">this</span></code>
MultibodyPlant.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if there is no body with the requested name.</strong> – </p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>HasBodyNamed() to query if there exists a body in <code class="docutils literal notranslate"><span class="pre">this</span></code>
MultibodyPlant with a given specified name.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetBodyFrameIdIfExists">
<span class="sig-name descname"><span class="pre">GetBodyFrameIdIfExists</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.BodyIndex" title="pydrake.multibody.tree.BodyIndex"><span class="pre">pydrake.multibody.tree.BodyIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.FrameId" title="pydrake.geometry.FrameId"><span class="pre">pydrake.geometry.FrameId</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetBodyFrameIdIfExists" title="Link to this definition"></a></dt>
<dd><p>If the body with <code class="docutils literal notranslate"><span class="pre">body_index</span></code> belongs to the called plant, it
returns the geometry::FrameId associated with it. Otherwise, it
returns nullopt.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetBodyFrameIdOrThrow">
<span class="sig-name descname"><span class="pre">GetBodyFrameIdOrThrow</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.BodyIndex" title="pydrake.multibody.tree.BodyIndex"><span class="pre">pydrake.multibody.tree.BodyIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.FrameId" title="pydrake.geometry.FrameId"><span class="pre">pydrake.geometry.FrameId</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetBodyFrameIdOrThrow" title="Link to this definition"></a></dt>
<dd><p>If the body with <code class="docutils literal notranslate"><span class="pre">body_index</span></code> belongs to the called plant, it
returns the geometry::FrameId associated with it. Otherwise this
method throws an exception.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the called plant does not have the body indicated</strong> – </p></li>
<li><p><strong>by body_index.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetBodyFromFrameId">
<span class="sig-name descname"><span class="pre">GetBodyFromFrameId</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.FrameId" title="pydrake.geometry.FrameId"><span class="pre">pydrake.geometry.FrameId</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.multibody.tree.RigidBody_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetBodyFromFrameId" title="Link to this definition"></a></dt>
<dd><p>Given a geometry frame identifier, returns a pointer to the body
associated with that id (nullptr if there is no such body).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetBodyIndices">
<span class="sig-name descname"><span class="pre">GetBodyIndices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.BodyIndex" title="pydrake.multibody.tree.BodyIndex"><span class="pre">pydrake.multibody.tree.BodyIndex</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetBodyIndices" title="Link to this definition"></a></dt>
<dd><p>Returns a list of body indices associated with <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetCollisionGeometriesForBody">
<span class="sig-name descname"><span class="pre">GetCollisionGeometriesForBody</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.RigidBody_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.GeometryId" title="pydrake.geometry.GeometryId"><span class="pre">pydrake.geometry.GeometryId</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetCollisionGeometriesForBody" title="Link to this definition"></a></dt>
<dd><p>Returns an array of GeometryId’s identifying the different contact
geometries for <code class="docutils literal notranslate"><span class="pre">body</span></code> previously registered with a SceneGraph.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method can be called at any time during the lifetime of
<code class="docutils literal notranslate"><span class="pre">this</span></code> plant, either pre- or post-finalize, see Finalize().
Post-finalize calls will always return the same value.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>RegisterCollisionGeometry(), Finalize()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetConstraintActiveStatus">
<span class="sig-name descname"><span class="pre">GetConstraintActiveStatus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.systems.framework.Context_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">id</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.MultibodyConstraintId" title="pydrake.multibody.tree.MultibodyConstraintId"><span class="pre">pydrake.multibody.tree.MultibodyConstraintId</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetConstraintActiveStatus" title="Link to this definition"></a></dt>
<dd><p>Returns the active status of the constraint given by <code class="docutils literal notranslate"><span class="pre">id</span></code> in
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the MultibodyPlant has not been finalized.</strong> – </p></li>
<li><p><strong>RuntimeError if id does not belong to any multibody constraint</strong> – </p></li>
<li><p><strong>in context.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetConstraintIds">
<span class="sig-name descname"><span class="pre">GetConstraintIds</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.MultibodyConstraintId" title="pydrake.multibody.tree.MultibodyConstraintId"><span class="pre">pydrake.multibody.tree.MultibodyConstraintId</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetConstraintIds" title="Link to this definition"></a></dt>
<dd><p>Returns a list of all constraint identifiers. The returned vector
becomes invalid after any calls to Add*Constraint() or
RemoveConstraint().</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetDefaultContactSurfaceRepresentation">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">GetDefaultContactSurfaceRepresentation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">time_step</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.HydroelasticContactRepresentation" title="pydrake.geometry.HydroelasticContactRepresentation"><span class="pre">pydrake.geometry.HydroelasticContactRepresentation</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetDefaultContactSurfaceRepresentation" title="Link to this definition"></a></dt>
<dd><p>Return the default value for contact representation, given the desired
time step. Discrete systems default to use polygons; continuous
systems default to use triangles.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetDefaultDistanceConstraintParams">
<span class="sig-name descname"><span class="pre">GetDefaultDistanceConstraintParams</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">dict</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.MultibodyConstraintId" title="pydrake.multibody.tree.MultibodyConstraintId"><span class="pre">pydrake.multibody.tree.MultibodyConstraintId</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="#pydrake.multibody.plant.DistanceConstraintParams" title="pydrake.multibody.plant.DistanceConstraintParams"><span class="pre">pydrake.multibody.plant.DistanceConstraintParams</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetDefaultDistanceConstraintParams" title="Link to this definition"></a></dt>
<dd><p>Returns all default distance constraint parameters, as registered via
AddDistanceConstraint(). See GetDistanceConstraintParams() and
SetDistanceConstraintParams() for working with parameters stored in a
context.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetDefaultFloatingBaseBodyPose">
<span class="sig-name descname"><span class="pre">GetDefaultFloatingBaseBodyPose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.RigidBody_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.math.html#pydrake.math.RigidTransform" title="pydrake.math.RigidTransform"><span class="pre">pydrake.math.RigidTransform</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetDefaultFloatingBaseBodyPose" title="Link to this definition"></a></dt>
<dd><p>Gets the provisional default pose of <code class="docutils literal notranslate"><span class="pre">body</span></code> as set by
SetDefaultFloatingBaseBodyPose(). If no pose was specified for
<code class="docutils literal notranslate"><span class="pre">body</span></code>, returns the identity pose. This may be called pre- or
post-Finalize().</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This value is only meaningful for bodies that turn out to be
floating base bodies after Finalize(). If called on any other
body, the result simply echoes whatever provisional pose was set
in SetDefaultFloatingBaseBodyPose() but has no other effect. Use
the Joint API to get the default pose for any body that has an
explicitly-defined joint to its parent body.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Post-Finalize(), a floating base body’s default pose may be set
either by SetDefaultFloatingBaseBodyPose() or by setting the
default pose directly through the Joint API applied to the
automatically-added floating joint.
GetDefaultFloatingBaseBodyPose() will return the most-recent value
set by either method.</p>
</div>
<p>See mbp_working_with_free_bodies “above for details”.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body</span></code>:</dt><dd><p>RigidBody whose default pose will be retrieved.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">X_WB</span></code>:</dt><dd><p>The default pose of the floating base body B in World. Not
meaningful if <code class="docutils literal notranslate"><span class="pre">body</span></code> is not a floating base body.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetDefaultFreeBodyPose">
<span class="sig-name descname"><span class="pre">GetDefaultFreeBodyPose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.RigidBody_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.math.html#pydrake.math.RigidTransform" title="pydrake.math.RigidTransform"><span class="pre">pydrake.math.RigidTransform</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetDefaultFreeBodyPose" title="Link to this definition"></a></dt>
<dd><p>(Deprecated.)</p>
<dl class="simple">
<dt>Deprecated:</dt><dd><p>Use GetDefaultFloatingBaseBodyPose() instead. This will be removed
from Drake on or after 2026-06-01.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetDefaultPositions">
<span class="sig-name descname"><span class="pre">GetDefaultPositions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetDefaultPositions" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetDefaultPositions(self: pydrake.multibody.plant.MultibodyPlant_[Expression]) -&gt; numpy.ndarray[object[m, 1]]</p></li>
</ol>
<p>Gets the default positions for the plant, which can be changed via
SetDefaultPositions().</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if the plant is not finalized.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>GetDefaultPositions(self: pydrake.multibody.plant.MultibodyPlant_[Expression], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; numpy.ndarray[object[m, 1]]</p></li>
</ol>
<p>Gets the default positions for the plant for a given model instance,
which can be changed via SetDefaultPositions().</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the plant is not finalized</strong><strong>, or </strong><strong>if the</strong> – </p></li>
<li><p><strong>model_instance is invalid</strong><strong>,</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetDistanceConstraintParams">
<span class="sig-name descname"><span class="pre">GetDistanceConstraintParams</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetDistanceConstraintParams" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetDistanceConstraintParams(self: pydrake.multibody.plant.MultibodyPlant_[Expression], context: pydrake.systems.framework.Context_[Expression]) -&gt; dict[pydrake.multibody.tree.MultibodyConstraintId, pydrake.multibody.plant.DistanceConstraintParams]</p></li>
</ol>
<p>Returns all distance constraint parameters currently stored in
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<ol class="arabic simple" start="2">
<li><p>GetDistanceConstraintParams(self: pydrake.multibody.plant.MultibodyPlant_[Expression], context: pydrake.systems.framework.Context_[Expression], id: pydrake.multibody.tree.MultibodyConstraintId) -&gt; pydrake.multibody.plant.DistanceConstraintParams</p></li>
</ol>
<p>Returns a constant reference to the parameters for the distance
constraint that corresponds to identifier <code class="docutils literal notranslate"><span class="pre">id</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>if id is not a valid identifier for a distance constraint.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetEffortLowerLimits">
<span class="sig-name descname"><span class="pre">GetEffortLowerLimits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetEffortLowerLimits" title="Link to this definition"></a></dt>
<dd><p>Returns a vector of size <code class="docutils literal notranslate"><span class="pre">num_actuated_dofs()</span></code> containing the lower
effort limits for every actuator. Any unbounded or unspecified limits
will be -∞. The returned vector is indexed by JointActuatorIndex, see
JointActuator::index().</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>GetEffortUpperLimits()</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetEffortUpperLimits">
<span class="sig-name descname"><span class="pre">GetEffortUpperLimits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetEffortUpperLimits" title="Link to this definition"></a></dt>
<dd><p>Returns a vector of size <code class="docutils literal notranslate"><span class="pre">num_actuated_dofs()</span></code> containing the upper
effort limits for every actuator. Any unbounded or unspecified limits
will be +∞. The returned vector is indexed by JointActuatorIndex, see
JointActuator::index().</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>GetEffortLowerLimits()</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetFloatingBaseBodies">
<span class="sig-name descname"><span class="pre">GetFloatingBaseBodies</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">set</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.BodyIndex" title="pydrake.multibody.tree.BodyIndex"><span class="pre">pydrake.multibody.tree.BodyIndex</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetFloatingBaseBodies" title="Link to this definition"></a></dt>
<dd><p>Returns the set of body indices corresponding to the floating base
bodies in the model, in no particular order. See
mbp_working_with_free_bodies “above for details”.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize</strong><strong>, </strong><strong>see Finalize</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetFrameByName">
<span class="sig-name descname"><span class="pre">GetFrameByName</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetFrameByName" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetFrameByName(self: pydrake.multibody.plant.MultibodyPlant_[Expression], name: str) -&gt; pydrake.multibody.tree.Frame_[Expression]</p></li>
</ol>
<p>Returns a constant reference to a frame that is identified by the
string <code class="docutils literal notranslate"><span class="pre">name</span></code> in <code class="docutils literal notranslate"><span class="pre">this</span></code> model.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if there is no frame with the requested name.</strong> – </p></li>
<li><p><strong>RuntimeError if the frame name occurs in multiple model instances.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>HasFrameNamed() to query if there exists a frame in <code class="docutils literal notranslate"><span class="pre">this</span></code> model
with a given specified name.</p>
</div>
<ol class="arabic simple" start="2">
<li><p>GetFrameByName(self: pydrake.multibody.plant.MultibodyPlant_[Expression], name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; pydrake.multibody.tree.Frame_[Expression]</p></li>
</ol>
<p>Returns a constant reference to the frame that is uniquely identified
by the string <code class="docutils literal notranslate"><span class="pre">name</span></code> in <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if there is no frame with the requested name.</strong> – </p></li>
<li><p><strong>RuntimeError if model_instance is not valid for this model.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>HasFrameNamed() to query if there exists a frame in <code class="docutils literal notranslate"><span class="pre">this</span></code> model
with a given specified name.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetFrameIndices">
<span class="sig-name descname"><span class="pre">GetFrameIndices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.FrameIndex" title="pydrake.multibody.tree.FrameIndex"><span class="pre">pydrake.multibody.tree.FrameIndex</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetFrameIndices" title="Link to this definition"></a></dt>
<dd><p>Returns a list of frame indices associated with <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetFreeBodyPose">
<span class="sig-name descname"><span class="pre">GetFreeBodyPose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.systems.framework.Context_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.RigidBody_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.math.RigidTransform_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetFreeBodyPose" title="Link to this definition"></a></dt>
<dd><p>For any free body’s 6-dof joint, gets the pose X_JpJc of the child
frame Jc in its parent frame Jp.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Unless <code class="docutils literal notranslate"><span class="pre">body</span></code> is a floating base body, the parent frame Jp is
not necessarily the World frame W, and the child frame Jc is not
necessarily the body frame B.</p>
</div>
<p>See mbp_working_with_free_bodies “above for details”.</p>
<dl class="simple">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">X_JpJc</span></code>:</dt><dd><p>The current pose of child frame Jc in its parent frame Jp. Returns
X_WB if <code class="docutils literal notranslate"><span class="pre">body</span></code> B is a floating base body.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if called pre-finalize.</strong> – </p></li>
<li><p><strong>RuntimeError if body is not a free body.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetJointActuatorByName">
<span class="sig-name descname"><span class="pre">GetJointActuatorByName</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetJointActuatorByName" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetJointActuatorByName(self: pydrake.multibody.plant.MultibodyPlant_[Expression], name: str) -&gt; pydrake.multibody.tree.JointActuator_[Expression]</p></li>
</ol>
<p>Returns a constant reference to an actuator that is identified by the
string <code class="docutils literal notranslate"><span class="pre">name</span></code> in <code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if there is no actuator with the requested name.</strong> – </p></li>
<li><p><strong>RuntimeError if the actuator name occurs in multiple model</strong> – </p></li>
<li><p><strong>instances.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>HasJointActuatorNamed() to query if there exists an actuator in
<code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant with a given specified name.</p>
</div>
<ol class="arabic simple" start="2">
<li><p>GetJointActuatorByName(self: pydrake.multibody.plant.MultibodyPlant_[Expression], name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; pydrake.multibody.tree.JointActuator_[Expression]</p></li>
</ol>
<p>Returns a constant reference to the actuator that is uniquely
identified by the string <code class="docutils literal notranslate"><span class="pre">name</span></code> and <code class="docutils literal notranslate"><span class="pre">model_instance</span></code> in <code class="docutils literal notranslate"><span class="pre">this</span></code>
MultibodyPlant.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if there is no actuator with the requested name.</strong> – </p></li>
<li><p><strong>RuntimeError if model_instance is not valid for this model.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>HasJointActuatorNamed() to query if there exists an actuator in
<code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant with a given specified name.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetJointActuatorIndices">
<span class="sig-name descname"><span class="pre">GetJointActuatorIndices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetJointActuatorIndices" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetJointActuatorIndices(self: pydrake.multibody.plant.MultibodyPlant_[Expression]) -&gt; list[pydrake.multibody.tree.JointActuatorIndex]</p></li>
</ol>
<p>Returns a list of all joint actuator indices. The vector is ordered by
monotonically increasing JointActuatorIndex, but the indices will in
general not be consecutive due to actuators that were removed.</p>
<ol class="arabic simple" start="2">
<li><p>GetJointActuatorIndices(self: pydrake.multibody.plant.MultibodyPlant_[Expression], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; list[pydrake.multibody.tree.JointActuatorIndex]</p></li>
</ol>
<p>Returns a list of joint actuator indices associated with
<code class="docutils literal notranslate"><span class="pre">model_instance</span></code>. The vector is ordered by monotonically increasing
JointActuatorIndex.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetJointByName">
<span class="sig-name descname"><span class="pre">GetJointByName</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.multibody.tree.Joint_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetJointByName" title="Link to this definition"></a></dt>
<dd><p>Returns a constant reference to a joint that is identified by the
string <code class="docutils literal notranslate"><span class="pre">name</span></code> in <code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant. If the optional template
argument is supplied, then the returned value is downcast to the
specified <code class="docutils literal notranslate"><span class="pre">JointType</span></code>.</p>
<dl class="simple">
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">JointType</span></code>:</dt><dd><p>The specific type of the Joint to be retrieved. It must be a
subclass of Joint.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the named joint is not</strong><strong> of </strong><strong>type JointType</strong><strong> or </strong><strong>if</strong> – </p></li>
<li><p><strong>there is no Joint with that name.</strong> – </p></li>
<li><p><strong>RuntimeError if model_instance is not valid for this model.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>HasJointNamed() to query if there exists a joint in <code class="docutils literal notranslate"><span class="pre">this</span></code>
MultibodyPlant with a given specified name.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetJointIndices">
<span class="sig-name descname"><span class="pre">GetJointIndices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetJointIndices" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetJointIndices(self: pydrake.multibody.plant.MultibodyPlant_[Expression]) -&gt; list[pydrake.multibody.tree.JointIndex]</p></li>
</ol>
<p>Returns a list of all joint indices. The vector is ordered by
monotonically increasing JointIndex, but the indices will in general
not be consecutive due to joints that were removed.</p>
<ol class="arabic simple" start="2">
<li><p>GetJointIndices(self: pydrake.multibody.plant.MultibodyPlant_[Expression], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; list[pydrake.multibody.tree.JointIndex]</p></li>
</ol>
<p>Returns a list of joint indices associated with <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetModelInstanceByName">
<span class="sig-name descname"><span class="pre">GetModelInstanceByName</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetModelInstanceByName" title="Link to this definition"></a></dt>
<dd><p>Returns the index to the model instance that is uniquely identified by
the string <code class="docutils literal notranslate"><span class="pre">name</span></code> in <code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if there is no instance with the requested name.</strong> – </p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>HasModelInstanceNamed() to query if there exists an instance in
<code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant with a given specified name.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetModelInstanceName">
<span class="sig-name descname"><span class="pre">GetModelInstanceName</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">str</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetModelInstanceName" title="Link to this definition"></a></dt>
<dd><p>Returns the name of a <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError when model_instance does not correspond to a</strong> – </p></li>
<li><p><strong>model in this model.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetMutableJointByName">
<span class="sig-name descname"><span class="pre">GetMutableJointByName</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.multibody.tree.Joint_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetMutableJointByName" title="Link to this definition"></a></dt>
<dd><p>Returns a constant reference to a joint that is identified by the
string <code class="docutils literal notranslate"><span class="pre">name</span></code> in <code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant. If the optional template
argument is supplied, then the returned value is downcast to the
specified <code class="docutils literal notranslate"><span class="pre">JointType</span></code>.</p>
<dl class="simple">
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">JointType</span></code>:</dt><dd><p>The specific type of the Joint to be retrieved. It must be a
subclass of Joint.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the named joint is not</strong><strong> of </strong><strong>type JointType</strong><strong> or </strong><strong>if</strong> – </p></li>
<li><p><strong>there is no Joint with that name.</strong> – </p></li>
<li><p><strong>RuntimeError if model_instance is not valid for this model.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>HasJointNamed() to query if there exists a joint in <code class="docutils literal notranslate"><span class="pre">this</span></code>
MultibodyPlant with a given specified name.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetPositionLowerLimits">
<span class="sig-name descname"><span class="pre">GetPositionLowerLimits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetPositionLowerLimits" title="Link to this definition"></a></dt>
<dd><p>Returns a vector of size <code class="docutils literal notranslate"><span class="pre">num_positions()</span></code> containing the lower
position limits for every generalized position coordinate. These
include joint and free body coordinates. Any unbounded or unspecified
limits will be -infinity.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetPositionNames">
<span class="sig-name descname"><span class="pre">GetPositionNames</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetPositionNames" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetPositionNames(self: pydrake.multibody.plant.MultibodyPlant_[Expression], add_model_instance_prefix: bool = True, always_add_suffix: bool = True) -&gt; list[str]</p></li>
</ol>
<p>Returns a list of string names corresponding to each element of the
position vector. These strings take the form
<code class="docutils literal notranslate"><span class="pre">{model_instance_name}_{joint_name}_{joint_position_suffix}</span></code>, but
the prefix and suffix may optionally be withheld using
<code class="docutils literal notranslate"><span class="pre">add_model_instance_prefix</span></code> and <code class="docutils literal notranslate"><span class="pre">always_add_suffix</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">always_add_suffix</span></code>:</dt><dd><p>(optional). If true, then the suffix is always added. If false,
then the suffix is only added for joints that have more than one
position (in this case, not adding would lead to ambiguity).</p>
</dd>
</dl>
<p>The returned names are guaranteed to be unique if
<code class="docutils literal notranslate"><span class="pre">add_model_instance_prefix</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code> (the default).</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if the plant is not finalized.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>GetPositionNames(self: pydrake.multibody.plant.MultibodyPlant_[Expression], model_instance: pydrake.multibody.tree.ModelInstanceIndex, add_model_instance_prefix: bool = False, always_add_suffix: bool = True) -&gt; list[str]</p></li>
</ol>
<p>Returns a list of string names corresponding to each element of the
position vector. These strings take the form
<code class="docutils literal notranslate"><span class="pre">{model_instance_name}_{joint_name}_{joint_position_suffix}</span></code>, but
the prefix and suffix may optionally be withheld using
<code class="docutils literal notranslate"><span class="pre">add_model_instance_prefix</span></code> and <code class="docutils literal notranslate"><span class="pre">always_add_suffix</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">always_add_suffix</span></code>:</dt><dd><p>(optional). If true, then the suffix is always added. If false,
then the suffix is only added for joints that have more than one
position (in this case, not adding would lead to ambiguity).</p>
</dd>
</dl>
<p>The returned names are guaranteed to be unique.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the plant is not finalized</strong><strong> or </strong><strong>if the</strong> – </p></li>
<li><p><strong>model_instance` is invalid</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetPositions">
<span class="sig-name descname"><span class="pre">GetPositions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetPositions" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetPositions(self: pydrake.multibody.plant.MultibodyPlant_[Expression], context: pydrake.systems.framework.Context_[Expression]) -&gt; numpy.ndarray[object[m, 1]]</p></li>
</ol>
<p>Returns a const vector reference to the vector of generalized
positions q in a given Context.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method returns a reference to existing data, exhibits
constant i.e., O(1) time complexity, and runs very quickly.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if context does not correspond to the Context for</strong> – </p></li>
<li><p><strong>a multibody model.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>GetPositions(self: pydrake.multibody.plant.MultibodyPlant_[Expression], context: pydrake.systems.framework.Context_[Expression], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; numpy.ndarray[object[m, 1]]</p></li>
</ol>
<p>Returns a vector containing the generalized positions q of a specified
model instance in a given Context.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Returns a dense vector of dimension
<code class="docutils literal notranslate"><span class="pre">num_positions(model_instance)</span></code> associated with
<code class="docutils literal notranslate"><span class="pre">model_instance</span></code> by copying from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if context does not correspond to the Context for</strong> – </p></li>
<li><p><strong>a multibody model</strong><strong> or </strong><strong>model_instance is invalid.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetPositionsAndVelocities">
<span class="sig-name descname"><span class="pre">GetPositionsAndVelocities</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetPositionsAndVelocities" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetPositionsAndVelocities(self: pydrake.multibody.plant.MultibodyPlant_[Expression], context: pydrake.systems.framework.Context_[Expression]) -&gt; numpy.ndarray[object[m, 1]]</p></li>
</ol>
<p>Returns a const vector reference <code class="docutils literal notranslate"><span class="pre">[q;</span> <span class="pre">v]</span></code> to the generalized
positions q and generalized velocities v in a given Context.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method returns a reference to existing data, exhibits
constant i.e., O(1) time complexity, and runs very quickly.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if context does not correspond to the Context for</strong> – </p></li>
<li><p><strong>a multibody model.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>GetPositionsAndVelocities(self: pydrake.multibody.plant.MultibodyPlant_[Expression], context: pydrake.systems.framework.Context_[Expression], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; numpy.ndarray[object[m, 1]]</p></li>
</ol>
<p>Returns a vector <code class="docutils literal notranslate"><span class="pre">[q;</span> <span class="pre">v]</span></code> containing the generalized positions q and
generalized velocities v of a specified model instance in a given
Context.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Returns a dense vector of dimension
<code class="docutils literal notranslate"><span class="pre">num_positions(model_instance)</span> <span class="pre">+</span> <span class="pre">num_velocities(model_instance)</span></code>
associated with <code class="docutils literal notranslate"><span class="pre">model_instance</span></code> by copying from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if context does not correspond to the Context for</strong> – </p></li>
<li><p><strong>a multibody model</strong><strong> or </strong><strong>model_instance is invalid.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetPositionsFromArray">
<span class="sig-name descname"><span class="pre">GetPositionsFromArray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetPositionsFromArray" title="Link to this definition"></a></dt>
<dd><p>Returns a vector of generalized positions for <code class="docutils literal notranslate"><span class="pre">model_instance</span></code> from
a vector <code class="docutils literal notranslate"><span class="pre">q_array</span></code> of generalized positions for the entire model
model. This method throws an exception if <code class="docutils literal notranslate"><span class="pre">q</span></code> is not of size
MultibodyPlant::num_positions().</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetPositionUpperLimits">
<span class="sig-name descname"><span class="pre">GetPositionUpperLimits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetPositionUpperLimits" title="Link to this definition"></a></dt>
<dd><p>Upper limit analog of GetPositionLowerLimits(), where any unbounded or
unspecified limits will be +infinity.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>GetPositionLowerLimits() for more information.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetRigidBodyByName">
<span class="sig-name descname"><span class="pre">GetRigidBodyByName</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetRigidBodyByName" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetRigidBodyByName(self: pydrake.multibody.plant.MultibodyPlant_[Expression], name: str) -&gt; pydrake.multibody.tree.RigidBody_[Expression]</p></li>
</ol>
<p>Returns a constant reference to a rigid body that is identified by the
string <code class="docutils literal notranslate"><span class="pre">name</span></code> in <code class="docutils literal notranslate"><span class="pre">this</span></code> model.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if there is no body with the requested name.</strong> – </p></li>
<li><p><strong>RuntimeError if the body name occurs in multiple model instances.</strong> – </p></li>
<li><p><strong>RuntimeError if the requested body is not a RigidBody.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>HasBodyNamed() to query if there exists a body in <code class="docutils literal notranslate"><span class="pre">this</span></code> model
with a given specified name.</p>
</div>
<ol class="arabic simple" start="2">
<li><p>GetRigidBodyByName(self: pydrake.multibody.plant.MultibodyPlant_[Expression], name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; pydrake.multibody.tree.RigidBody_[Expression]</p></li>
</ol>
<p>Returns a constant reference to the rigid body that is uniquely
identified by the string <code class="docutils literal notranslate"><span class="pre">name</span></code> in <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if there is no body with the requested name.</strong> – </p></li>
<li><p><strong>RuntimeError if the requested body is not a RigidBody.</strong> – </p></li>
<li><p><strong>RuntimeError if model_instance is not valid for this model.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>HasBodyNamed() to query if there exists a body in <code class="docutils literal notranslate"><span class="pre">this</span></code> model
with a given specified name.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetStateNames">
<span class="sig-name descname"><span class="pre">GetStateNames</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetStateNames" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetStateNames(self: pydrake.multibody.plant.MultibodyPlant_[Expression], add_model_instance_prefix: bool = True) -&gt; list[str]</p></li>
</ol>
<p>Returns a list of string names corresponding to each element of the
multibody state vector. These strings take the form
<code class="docutils literal notranslate"><span class="pre">{model_instance_name}_{joint_name}_{joint_position_suffix</span> <span class="pre">|</span>
<span class="pre">joint_velocity_suffix}</span></code>, but the prefix may optionally be withheld
using <code class="docutils literal notranslate"><span class="pre">add_model_instance_prefix</span></code>.</p>
<p>The returned names are guaranteed to be unique if
<code class="docutils literal notranslate"><span class="pre">add_model_instance_prefix</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code> (the default).</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if the plant is not finalized.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>GetStateNames(self: pydrake.multibody.plant.MultibodyPlant_[Expression], model_instance: pydrake.multibody.tree.ModelInstanceIndex, add_model_instance_prefix: bool = False) -&gt; list[str]</p></li>
</ol>
<p>Returns a list of string names corresponding to each element of the
multibody state vector. These strings take the form
<code class="docutils literal notranslate"><span class="pre">{model_instance_name}_{joint_name}_{joint_position_suffix</span> <span class="pre">|</span>
<span class="pre">joint_velocity_suffix}</span></code>, but the prefix may optionally be withheld
using <code class="docutils literal notranslate"><span class="pre">add_model_instance_prefix</span></code>.</p>
<p>The returned names are guaranteed to be unique.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the plant is not finalized</strong><strong> or </strong><strong>if the</strong> – </p></li>
<li><p><strong>model_instance` is invalid</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetTopologyGraphvizString">
<span class="sig-name descname"><span class="pre">GetTopologyGraphvizString</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">str</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetTopologyGraphvizString" title="Link to this definition"></a></dt>
<dd><p>Returns a Graphviz string describing the topology of this plant. To
render the string, use the Graphviz tool, <code class="docutils literal notranslate"><span class="pre">dot</span></code>.
<a class="reference external" href="http://www.graphviz.org/">http://www.graphviz.org/</a></p>
<p>Note: this method can be called either before or after <code class="docutils literal notranslate"><span class="pre">Finalize()</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetUniqueFloatingBaseBodyOrThrow">
<span class="sig-name descname"><span class="pre">GetUniqueFloatingBaseBodyOrThrow</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.multibody.tree.RigidBody_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetUniqueFloatingBaseBodyOrThrow" title="Link to this definition"></a></dt>
<dd><p>If there is a single base body in the model given by
<code class="docutils literal notranslate"><span class="pre">model_instance</span></code>, and that body is a floating base body, returns
that floating base body. Otherwise, throws an exception. Use
HasUniqueFloatingBaseBody() to check first.</p>
<p>See mbp_working_with_free_bodies “above for details”.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if called pre-finalize.</strong> – </p></li>
<li><p><strong>RuntimeError if model_instance is not valid.</strong> – </p></li>
<li><p><strong>RuntimeError if !HasUniqueFloatingBaseBody</strong><strong>(</strong><strong>model_instance</strong><strong>)</strong><strong>.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>HasUniqueFloatingBaseBody(), GetFloatingBaseBodies()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetUniqueFreeBaseBodyOrThrow">
<span class="sig-name descname"><span class="pre">GetUniqueFreeBaseBodyOrThrow</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.multibody.tree.RigidBody_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetUniqueFreeBaseBodyOrThrow" title="Link to this definition"></a></dt>
<dd><p>(Deprecated.)</p>
<dl class="simple">
<dt>Deprecated:</dt><dd><p>Use GetUniqueFloatingBaseBodyOrThrow() instead. This will be
removed from Drake on or after 2026-06-01.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetVelocities">
<span class="sig-name descname"><span class="pre">GetVelocities</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetVelocities" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetVelocities(self: pydrake.multibody.plant.MultibodyPlant_[Expression], context: pydrake.systems.framework.Context_[Expression]) -&gt; numpy.ndarray[object[m, 1]]</p></li>
</ol>
<p>Returns a const vector reference to the generalized velocities v in a
given Context.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method returns a reference to existing data, exhibits
constant i.e., O(1) time complexity, and runs very quickly.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if context does not correspond to the Context for</strong> – </p></li>
<li><p><strong>a multibody model.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>GetVelocities(self: pydrake.multibody.plant.MultibodyPlant_[Expression], context: pydrake.systems.framework.Context_[Expression], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; numpy.ndarray[object[m, 1]]</p></li>
</ol>
<p>Returns a vector containing the generalized velocities v of a
specified model instance in a given Context.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>returns a dense vector of dimension
<code class="docutils literal notranslate"><span class="pre">num_velocities(model_instance)</span></code> associated with
<code class="docutils literal notranslate"><span class="pre">model_instance</span></code> by copying from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if context does not correspond to the Context for</strong> – </p></li>
<li><p><strong>a multibody model</strong><strong> or </strong><strong>model_instance is invalid.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetVelocitiesFromArray">
<span class="sig-name descname"><span class="pre">GetVelocitiesFromArray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetVelocitiesFromArray" title="Link to this definition"></a></dt>
<dd><p>Returns a vector of generalized velocities for <code class="docutils literal notranslate"><span class="pre">model_instance</span></code> from
a vector <code class="docutils literal notranslate"><span class="pre">v</span></code> of generalized velocities for the entire MultibodyPlant
model. This method throws an exception if the input array is not of
size MultibodyPlant::num_velocities().</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetVelocityLowerLimits">
<span class="sig-name descname"><span class="pre">GetVelocityLowerLimits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetVelocityLowerLimits" title="Link to this definition"></a></dt>
<dd><p>Returns a vector of size <code class="docutils literal notranslate"><span class="pre">num_velocities()</span></code> containing the lower
velocity limits for every generalized velocity coordinate. These
include joint and free body coordinates. Any unbounded or unspecified
limits will be -infinity.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetVelocityNames">
<span class="sig-name descname"><span class="pre">GetVelocityNames</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetVelocityNames" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetVelocityNames(self: pydrake.multibody.plant.MultibodyPlant_[Expression], add_model_instance_prefix: bool = True, always_add_suffix: bool = True) -&gt; list[str]</p></li>
</ol>
<p>Returns a list of string names corresponding to each element of the
velocity vector. These strings take the form
<code class="docutils literal notranslate"><span class="pre">{model_instance_name}_{joint_name}_{joint_velocity_suffix}</span></code>, but
the prefix and suffix may optionally be withheld using
<code class="docutils literal notranslate"><span class="pre">add_model_instance_prefix</span></code> and <code class="docutils literal notranslate"><span class="pre">always_add_suffix</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">always_add_suffix</span></code>:</dt><dd><p>(optional). If true, then the suffix is always added. If false,
then the suffix is only added for joints that have more than one
position (in this case, not adding would lead to ambiguity).</p>
</dd>
</dl>
<p>The returned names are guaranteed to be unique if
<code class="docutils literal notranslate"><span class="pre">add_model_instance_prefix</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code> (the default).</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if the plant is not finalized.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>GetVelocityNames(self: pydrake.multibody.plant.MultibodyPlant_[Expression], model_instance: pydrake.multibody.tree.ModelInstanceIndex, add_model_instance_prefix: bool = False, always_add_suffix: bool = True) -&gt; list[str]</p></li>
</ol>
<p>Returns a list of string names corresponding to each element of the
velocity vector. These strings take the form
<code class="docutils literal notranslate"><span class="pre">{model_instance_name}_{joint_name}_{joint_velocity_suffix}</span></code>, but
the prefix and suffix may optionally be withheld using
<code class="docutils literal notranslate"><span class="pre">add_model_instance_prefix</span></code> and <code class="docutils literal notranslate"><span class="pre">always_add_suffix</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">always_add_suffix</span></code>:</dt><dd><p>(optional). If true, then the suffix is always added. If false,
then the suffix is only added for joints that have more than one
position (in this case, not adding would lead to ambiguity).</p>
</dd>
</dl>
<p>The returned names are guaranteed to be unique.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the plant is not finalized</strong><strong> or </strong><strong>if the</strong> – </p></li>
<li><p><strong>model_instance` is invalid</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetVelocityUpperLimits">
<span class="sig-name descname"><span class="pre">GetVelocityUpperLimits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetVelocityUpperLimits" title="Link to this definition"></a></dt>
<dd><p>Upper limit analog of GetVelocitysLowerLimits(), where any unbounded
or unspecified limits will be +infinity.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>GetVelocityLowerLimits() for more information.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetVisualGeometriesForBody">
<span class="sig-name descname"><span class="pre">GetVisualGeometriesForBody</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.RigidBody_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.GeometryId" title="pydrake.geometry.GeometryId"><span class="pre">pydrake.geometry.GeometryId</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetVisualGeometriesForBody" title="Link to this definition"></a></dt>
<dd><p>Returns an array of GeometryId’s identifying the different visual
geometries for <code class="docutils literal notranslate"><span class="pre">body</span></code> previously registered with a SceneGraph.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method can be called at any time during the lifetime of
<code class="docutils literal notranslate"><span class="pre">this</span></code> plant, either pre- or post-finalize, see Finalize().
Post-finalize calls will always return the same value.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>RegisterVisualGeometry(), Finalize()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.gravity_field">
<span class="sig-name descname"><span class="pre">gravity_field</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.multibody.tree.UniformGravityFieldElement_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.gravity_field" title="Link to this definition"></a></dt>
<dd><p>An accessor to the current gravity field.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.has_joint">
<span class="sig-name descname"><span class="pre">has_joint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">joint_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JointIndex" title="pydrake.multibody.tree.JointIndex"><span class="pre">pydrake.multibody.tree.JointIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.has_joint" title="Link to this definition"></a></dt>
<dd><p>Returns true if plant has a joint with unique index <code class="docutils literal notranslate"><span class="pre">joint_index</span></code>.
The value could be false if the joint was removed using RemoveJoint().</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.has_joint_actuator">
<span class="sig-name descname"><span class="pre">has_joint_actuator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">actuator_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JointActuatorIndex" title="pydrake.multibody.tree.JointActuatorIndex"><span class="pre">pydrake.multibody.tree.JointActuatorIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.has_joint_actuator" title="Link to this definition"></a></dt>
<dd><p>Returns true if plant has a joint actuator with unique index
<code class="docutils literal notranslate"><span class="pre">actuator_index</span></code>. The value could be false if the actuator was
removed using RemoveJointActuator().</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.has_sampled_output_ports">
<span class="sig-name descname"><span class="pre">has_sampled_output_ports</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.has_sampled_output_ports" title="Link to this definition"></a></dt>
<dd><p>(Advanced) If <code class="docutils literal notranslate"><span class="pre">this</span></code> plant is continuous (i.e., is_discrete() is
<code class="docutils literal notranslate"><span class="pre">False</span></code>), returns false. If <code class="docutils literal notranslate"><span class="pre">this</span></code> plant is discrete, returns
whether or not the output ports are sampled (change only at a time
step boundary) or live (instantaneously reflect changes to the input
ports). See output_port_sampling “Output port sampling” for details.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.HasBodyNamed">
<span class="sig-name descname"><span class="pre">HasBodyNamed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.HasBodyNamed" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>HasBodyNamed(self: pydrake.multibody.plant.MultibodyPlant_[Expression], name: str) -&gt; bool</p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if a body named <code class="docutils literal notranslate"><span class="pre">name</span></code> was added to the MultibodyPlant.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddRigidBody().</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if the body name occurs in multiple model instances.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>HasBodyNamed(self: pydrake.multibody.plant.MultibodyPlant_[Expression], name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; bool</p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if a body named <code class="docutils literal notranslate"><span class="pre">name</span></code> was added to the MultibodyPlant
in <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddRigidBody().</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if model_instance is not valid for this model.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.HasFrameNamed">
<span class="sig-name descname"><span class="pre">HasFrameNamed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.HasFrameNamed" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>HasFrameNamed(self: pydrake.multibody.plant.MultibodyPlant_[Expression], name: str) -&gt; bool</p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if a frame named <code class="docutils literal notranslate"><span class="pre">name</span></code> was added to the model.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddFrame().</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if the frame name occurs in multiple model instances.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>HasFrameNamed(self: pydrake.multibody.plant.MultibodyPlant_[Expression], name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; bool</p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if a frame named <code class="docutils literal notranslate"><span class="pre">name</span></code> was added to
<code class="docutils literal notranslate"><span class="pre">model_instance</span></code>.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddFrame().</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if model_instance is not valid for this model.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.HasJointActuatorNamed">
<span class="sig-name descname"><span class="pre">HasJointActuatorNamed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.HasJointActuatorNamed" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>HasJointActuatorNamed(self: pydrake.multibody.plant.MultibodyPlant_[Expression], name: str) -&gt; bool</p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if an actuator named <code class="docutils literal notranslate"><span class="pre">name</span></code> was added to this model.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddJointActuator().</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the actuator name occurs in multiple model</strong> – </p></li>
<li><p><strong>instances.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>HasJointActuatorNamed(self: pydrake.multibody.plant.MultibodyPlant_[Expression], name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; bool</p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if an actuator named <code class="docutils literal notranslate"><span class="pre">name</span></code> was added to
<code class="docutils literal notranslate"><span class="pre">model_instance</span></code>.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddJointActuator().</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if model_instance is not valid for this model.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.HasJointNamed">
<span class="sig-name descname"><span class="pre">HasJointNamed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.HasJointNamed" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>HasJointNamed(self: pydrake.multibody.plant.MultibodyPlant_[Expression], name: str) -&gt; bool</p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if a joint named <code class="docutils literal notranslate"><span class="pre">name</span></code> was added to this model.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddJoint().</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if the joint name occurs in multiple model instances.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>HasJointNamed(self: pydrake.multibody.plant.MultibodyPlant_[Expression], name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; bool</p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if a joint named <code class="docutils literal notranslate"><span class="pre">name</span></code> was added to
<code class="docutils literal notranslate"><span class="pre">model_instance</span></code>.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddJoint().</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if model_instance is not valid for this model.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.HasModelInstanceNamed">
<span class="sig-name descname"><span class="pre">HasModelInstanceNamed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.HasModelInstanceNamed" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if a model instance named <code class="docutils literal notranslate"><span class="pre">name</span></code> was added to this
model.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddModelInstance().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.HasUniqueFloatingBaseBody">
<span class="sig-name descname"><span class="pre">HasUniqueFloatingBaseBody</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.HasUniqueFloatingBaseBody" title="Link to this definition"></a></dt>
<dd><p>Returns true if there is a single base body in the model given by
<code class="docutils literal notranslate"><span class="pre">model_instance</span></code>, and that body is a floating base body.</p>
<p>See mbp_working_with_free_bodies “above for details”.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if called pre-finalize.</strong> – </p></li>
<li><p><strong>RuntimeError if model_instance is not valid.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>GetUniqueFloatingBaseBodyOrThrow()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.HasUniqueFreeBaseBody">
<span class="sig-name descname"><span class="pre">HasUniqueFreeBaseBody</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.HasUniqueFreeBaseBody" title="Link to this definition"></a></dt>
<dd><p>(Deprecated.)</p>
<dl class="simple">
<dt>Deprecated:</dt><dd><p>Use HasUniqueFloatingBaseBody() instead. This will be removed from
Drake on or after 2026-06-01.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.is_finalized">
<span class="sig-name descname"><span class="pre">is_finalized</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.is_finalized" title="Link to this definition"></a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if this MultibodyPlant was finalized with a call to
Finalize().</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>Finalize().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.is_gravity_enabled">
<span class="sig-name descname"><span class="pre">is_gravity_enabled</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.is_gravity_enabled" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> iff gravity is enabled for <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>set_gravity_enabled().</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if the model instance is invalid.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.IsAnchored">
<span class="sig-name descname"><span class="pre">IsAnchored</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.RigidBody_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.IsAnchored" title="Link to this definition"></a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if <code class="docutils literal notranslate"><span class="pre">body</span></code> is anchored (i.e. the kinematic path
between <code class="docutils literal notranslate"><span class="pre">body</span></code> and the world only contains weld joints.)</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.IsVelocityEqualToQDot">
<span class="sig-name descname"><span class="pre">IsVelocityEqualToQDot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.IsVelocityEqualToQDot" title="Link to this definition"></a></dt>
<dd><p>Returns true iff the generalized velocity v is exactly the time
derivative q̇ of the generalized coordinates q. In this case
MapQDotToVelocity() and MapVelocityToQDot() implement the identity
map. This method is, in the worst case, O(n), where n is the number of
joints.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.MakeActuationMatrix">
<span class="sig-name descname"><span class="pre">MakeActuationMatrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.MakeActuationMatrix" title="Link to this definition"></a></dt>
<dd><p>This method creates an actuation matrix B mapping a vector of
actuation values u into generalized forces <code class="docutils literal notranslate"><span class="pre">tau_u</span> <span class="pre">=</span> <span class="pre">B</span> <span class="pre">*</span> <span class="pre">u</span></code>, where B
is a matrix of size <code class="docutils literal notranslate"><span class="pre">nv</span> <span class="pre">x</span> <span class="pre">nu</span></code> with <code class="docutils literal notranslate"><span class="pre">nu</span></code> equal to
num_actuated_dofs() and <code class="docutils literal notranslate"><span class="pre">nv</span></code> equal to num_velocities(). The vector u
of actuation values is of size num_actuated_dofs(). For a given
JointActuator, <code class="docutils literal notranslate"><span class="pre">u[JointActuator::input_start()]</span></code> stores the value
for the external actuation corresponding to that actuator. <code class="docutils literal notranslate"><span class="pre">tau_u</span></code>
on the other hand is indexed by generalized velocity indices according
to <code class="docutils literal notranslate"><span class="pre">Joint::velocity_start()</span></code>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>B is a permutation matrix. While making a permutation has <code class="docutils literal notranslate"><span class="pre">O(n)</span></code>
complexity, making a full B matrix has <code class="docutils literal notranslate"><span class="pre">O(n²)</span></code> complexity. For
most applications this cost can be neglected but it could become
significant for very large systems.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.MakeActuationMatrixPseudoinverse">
<span class="sig-name descname"><span class="pre">MakeActuationMatrixPseudoinverse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">scipy.sparse.csc_matrix</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.MakeActuationMatrixPseudoinverse" title="Link to this definition"></a></dt>
<dd><p>Creates the pseudoinverse of the actuation matrix B directly (without
requiring an explicit inverse calculation). See MakeActuationMatrix().</p>
<p>Notably, when B is full row rank (the system is fully actuated), then
the pseudoinverse is a true inverse.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.MakeActuatorSelectorMatrix">
<span class="sig-name descname"><span class="pre">MakeActuatorSelectorMatrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.MakeActuatorSelectorMatrix" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>MakeActuatorSelectorMatrix(self: pydrake.multibody.plant.MultibodyPlant_[Expression], user_to_actuator_index_map: list[pydrake.multibody.tree.JointActuatorIndex]) -&gt; numpy.ndarray[numpy.float64[m, n]]</p></li>
</ol>
<p>This method allows user to map a vector <code class="docutils literal notranslate"><span class="pre">uₛ</span></code> containing the
actuation for a set of selected actuators into the vector u containing
the actuation values for <code class="docutils literal notranslate"><span class="pre">this</span></code> full model. The mapping, or
selection, is returned in the form of a selector matrix Su such that
<code class="docutils literal notranslate"><span class="pre">u</span> <span class="pre">=</span> <span class="pre">Su⋅uₛ</span></code>. The size nₛ of uₛ is always smaller or equal than the
size of the full vector of actuation values u. That is, a user might
be interested in only a given subset of actuators in the model.</p>
<p>This selection matrix is particularly useful when adding PID control
on a portion of the state, see systems::controllers::PidController.</p>
<p>A user specifies the preferred order in uₛ via
<code class="docutils literal notranslate"><span class="pre">user_to_actuator_index_map</span></code>. The actuation values in uₛ are a
concatenation of the values for each actuator in the order they appear
in <code class="docutils literal notranslate"><span class="pre">user_to_actuator_index_map</span></code>. The actuation value in the full
vector of actuation values <code class="docutils literal notranslate"><span class="pre">u</span></code> for a particular actuator can be
found at offset JointActuator::input_start().</p>
<ol class="arabic simple" start="2">
<li><p>MakeActuatorSelectorMatrix(self: pydrake.multibody.plant.MultibodyPlant_[Expression], user_to_joint_index_map: list[pydrake.multibody.tree.JointIndex]) -&gt; numpy.ndarray[numpy.float64[m, n]]</p></li>
</ol>
<p>Alternative signature to build an actuation selector matrix <code class="docutils literal notranslate"><span class="pre">Su</span></code>
such that <code class="docutils literal notranslate"><span class="pre">u</span> <span class="pre">=</span> <span class="pre">Su⋅uₛ</span></code>, where u is the vector of actuation values for
the full model (see get_actuation_input_port()) and uₛ is a vector of
actuation values for the actuators acting on the joints listed by
<code class="docutils literal notranslate"><span class="pre">user_to_joint_index_map</span></code>. It is assumed that all joints referenced
by <code class="docutils literal notranslate"><span class="pre">user_to_joint_index_map</span></code> are actuated. See
MakeActuatorSelectorMatrix(const std::vector&lt;JointActuatorIndex&gt;&amp;) for
details.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if any</strong><strong> of </strong><strong>the joints in user_to_joint_index_map</strong> – </p></li>
<li><p><strong>does not have an actuator.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.MakeStateSelectorMatrix">
<span class="sig-name descname"><span class="pre">MakeStateSelectorMatrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">user_to_joint_index_map</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JointIndex" title="pydrake.multibody.tree.JointIndex"><span class="pre">pydrake.multibody.tree.JointIndex</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.MakeStateSelectorMatrix" title="Link to this definition"></a></dt>
<dd><p>This method allows users to map the state of <code class="docutils literal notranslate"><span class="pre">this</span></code> model, x, into a
vector of selected state xₛ with a given preferred ordering. The
mapping, or selection, is returned in the form of a selector matrix Sx
such that <code class="docutils literal notranslate"><span class="pre">xₛ</span> <span class="pre">=</span> <span class="pre">Sx⋅x</span></code>. The size nₛ of xₛ is always smaller or equal
than the size of the full state x. That is, a user might be interested
in only a given portion of the full state x.</p>
<p>This selection matrix is particularly useful when adding PID control
on a portion of the state, see systems::controllers::PidController.</p>
<p>A user specifies the preferred order in xₛ via
<code class="docutils literal notranslate"><span class="pre">user_to_joint_index_map</span></code>. The selected state is built such that
selected positions are followed by selected velocities, as in <code class="docutils literal notranslate"><span class="pre">xₛ</span> <span class="pre">=</span>
<span class="pre">[qₛ,</span> <span class="pre">vₛ]</span></code>. The positions in qₛ are a concatenation of the positions
for each joint in the order they appear in
<code class="docutils literal notranslate"><span class="pre">user_to_joint_index_map</span></code>. That is, the positions for
<code class="docutils literal notranslate"><span class="pre">user_to_joint_index_map[0]</span></code> are first, followed by the positions
for <code class="docutils literal notranslate"><span class="pre">user_to_joint_index_map[1]</span></code>, etc. Similarly for the selected
velocities vₛ.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if there are repeated indices in</strong> – </p></li>
<li><p><strong>user_to_joint_index_map`</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.MapQDotToVelocity">
<span class="sig-name descname"><span class="pre">MapQDotToVelocity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.systems.framework.Context_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qdot</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.MapQDotToVelocity" title="Link to this definition"></a></dt>
<dd><p>Transforms the time derivative <code class="docutils literal notranslate"><span class="pre">qdot</span></code> of the generalized positions
vector <code class="docutils literal notranslate"><span class="pre">q</span></code> (stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>) to generalized velocities <code class="docutils literal notranslate"><span class="pre">v</span></code>.
<cite>v</cite> and <code class="docutils literal notranslate"><span class="pre">q̇</span></code> are related linearly by <code class="docutils literal notranslate"><span class="pre">q̇</span> <span class="pre">=</span> <span class="pre">N(q)⋅v</span></code>. Although
<code class="docutils literal notranslate"><span class="pre">N(q)</span></code> is not necessarily square, its left pseudo-inverse <code class="docutils literal notranslate"><span class="pre">N⁺(q)</span></code>
can be used to invert that relationship without residual error,
provided that <code class="docutils literal notranslate"><span class="pre">qdot</span></code> is in the range space of <code class="docutils literal notranslate"><span class="pre">N(q)</span></code> (that is, if
it <em>could</em> have been produced as <code class="docutils literal notranslate"><span class="pre">q̇</span> <span class="pre">=</span> <span class="pre">N(q)⋅v</span></code> for some <code class="docutils literal notranslate"><span class="pre">v</span></code>).
Using the configuration <code class="docutils literal notranslate"><span class="pre">q</span></code> stored in the given <code class="docutils literal notranslate"><span class="pre">context</span></code> this
method calculates <code class="docutils literal notranslate"><span class="pre">v</span> <span class="pre">=</span> <span class="pre">N⁺(q)⋅q̇</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context containing the state of the model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">qdot</span></code>:</dt><dd><p>A vector containing the time derivatives of the generalized
positions. This method aborts if <code class="docutils literal notranslate"><span class="pre">qdot</span></code> is not of size
num_positions().</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">v</span></code>:</dt><dd><p>A valid (non-null) pointer to a vector in <code class="docutils literal notranslate"><span class="pre">ℛⁿ</span></code> with n the number
of generalized velocities. This method aborts if v is nullptr or
if it is not of size num_velocities().</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>MapVelocityToQDot()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>Mobilizer::MapQDotToVelocity()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.MapVelocityToQDot">
<span class="sig-name descname"><span class="pre">MapVelocityToQDot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.systems.framework.Context_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.MapVelocityToQDot" title="Link to this definition"></a></dt>
<dd><p>Transforms generalized velocities v to time derivatives <code class="docutils literal notranslate"><span class="pre">qdot</span></code> of
the generalized positions vector <code class="docutils literal notranslate"><span class="pre">q</span></code> (stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>). <cite>v</cite>
and <code class="docutils literal notranslate"><span class="pre">qdot</span></code> are related linearly by <code class="docutils literal notranslate"><span class="pre">q̇</span> <span class="pre">=</span> <span class="pre">N(q)⋅v</span></code>. Using the
configuration <code class="docutils literal notranslate"><span class="pre">q</span></code> stored in the given <code class="docutils literal notranslate"><span class="pre">context</span></code> this method
calculates <code class="docutils literal notranslate"><span class="pre">q̇</span> <span class="pre">=</span> <span class="pre">N(q)⋅v</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context containing the state of the model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">v</span></code>:</dt><dd><p>A vector of generalized velocities for this model. This method
aborts if v is not of size num_velocities().</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">qdot</span></code>:</dt><dd><p>A valid (non-null) pointer to a vector in <code class="docutils literal notranslate"><span class="pre">ℝⁿ</span></code> with n being the
number of generalized positions in this model, given by
<code class="docutils literal notranslate"><span class="pre">num_positions()</span></code>. This method aborts if <code class="docutils literal notranslate"><span class="pre">qdot</span></code> is nullptr or
if it is not of size num_positions().</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>MapQDotToVelocity()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>Mobilizer::MapVelocityToQDot()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.mutable_deformable_model">
<span class="sig-name descname"><span class="pre">mutable_deformable_model</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">drake::multibody::DeformableModel&lt;drake::symbolic::Expression&gt;</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.mutable_deformable_model" title="Link to this definition"></a></dt>
<dd><p>Returns a mutable reference to the DeformableModel owned by this
plant.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if the plant is finalized.</strong> – </p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This feature is considered to be <strong>experimental</strong> and may change
or be removed at any time, without any deprecation notice ahead of
time.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.mutable_gravity_field">
<span class="sig-name descname"><span class="pre">mutable_gravity_field</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.multibody.tree.UniformGravityFieldElement_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.mutable_gravity_field" title="Link to this definition"></a></dt>
<dd><p>A mutable accessor to the current gravity field.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.num_actuated_dofs">
<span class="sig-name descname"><span class="pre">num_actuated_dofs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.num_actuated_dofs" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>num_actuated_dofs(self: pydrake.multibody.plant.MultibodyPlant_[Expression]) -&gt; int</p></li>
</ol>
<p>Returns the total number of actuated degrees of freedom. That is, the
vector of actuation values u has this size. See AddJointActuator().</p>
<ol class="arabic simple" start="2">
<li><p>num_actuated_dofs(self: pydrake.multibody.plant.MultibodyPlant_[Expression], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; int</p></li>
</ol>
<p>Returns the total number of actuated degrees of freedom for a specific
model instance. That is, the vector of actuation values u has this
size. See AddJointActuator().</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.num_actuators">
<span class="sig-name descname"><span class="pre">num_actuators</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.num_actuators" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>num_actuators(self: pydrake.multibody.plant.MultibodyPlant_[Expression]) -&gt; int</p></li>
</ol>
<p>Returns the number of joint actuators in the model.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddJointActuator().</p>
</div>
<ol class="arabic simple" start="2">
<li><p>num_actuators(self: pydrake.multibody.plant.MultibodyPlant_[Expression], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; int</p></li>
</ol>
<p>Returns the number of actuators for a specific model instance.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.num_bodies">
<span class="sig-name descname"><span class="pre">num_bodies</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.num_bodies" title="Link to this definition"></a></dt>
<dd><p>Returns the number of RigidBody elements in the model, including the
“world” RigidBody, which is always part of the model.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddRigidBody().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.num_collision_geometries">
<span class="sig-name descname"><span class="pre">num_collision_geometries</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.num_collision_geometries" title="Link to this definition"></a></dt>
<dd><p>Returns the number of geometries registered for contact modeling. This
method can be called at any time during the lifetime of <code class="docutils literal notranslate"><span class="pre">this</span></code>
plant, either pre- or post-finalize, see Finalize(). Post-finalize
calls will always return the same value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.num_constraints">
<span class="sig-name descname"><span class="pre">num_constraints</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.num_constraints" title="Link to this definition"></a></dt>
<dd><p>Returns the total number of constraints specified by the user.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.num_force_elements">
<span class="sig-name descname"><span class="pre">num_force_elements</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.num_force_elements" title="Link to this definition"></a></dt>
<dd><p>Returns the number of ForceElement objects.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddForceElement().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.num_frames">
<span class="sig-name descname"><span class="pre">num_frames</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.num_frames" title="Link to this definition"></a></dt>
<dd><p>Returns the number of Frame objects in this model. Frames include body
frames associated with each of the bodies, including the <em>world</em> body.
This means the minimum number of frames is one.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.num_joints">
<span class="sig-name descname"><span class="pre">num_joints</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.num_joints" title="Link to this definition"></a></dt>
<dd><p>Returns the number of joints in the model.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddJoint().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.num_model_instances">
<span class="sig-name descname"><span class="pre">num_model_instances</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.num_model_instances" title="Link to this definition"></a></dt>
<dd><p>Returns the number of model instances in the model.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddModelInstance().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.num_multibody_states">
<span class="sig-name descname"><span class="pre">num_multibody_states</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.num_multibody_states" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>num_multibody_states(self: pydrake.multibody.plant.MultibodyPlant_[Expression]) -&gt; int</p></li>
</ol>
<p>Returns the size of the multibody system state vector x = [q v]. This
will be <code class="docutils literal notranslate"><span class="pre">num_positions()</span></code> plus <code class="docutils literal notranslate"><span class="pre">num_velocities()</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>num_multibody_states(self: pydrake.multibody.plant.MultibodyPlant_[Expression], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; int</p></li>
</ol>
<p>Returns the size of the multibody system state vector xᵢ = [qᵢ vᵢ] for
model instance i. (Here qᵢ ⊆ q and vᵢ ⊆ v.) will be
<code class="docutils literal notranslate"><span class="pre">num_positions(model_instance)</span></code> plus
<code class="docutils literal notranslate"><span class="pre">num_velocities(model_instance)</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.num_positions">
<span class="sig-name descname"><span class="pre">num_positions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.num_positions" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>num_positions(self: pydrake.multibody.plant.MultibodyPlant_[Expression]) -&gt; int</p></li>
</ol>
<p>Returns the size of the generalized position vector q for this model.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>num_positions(self: pydrake.multibody.plant.MultibodyPlant_[Expression], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; int</p></li>
</ol>
<p>Returns the size of the generalized position vector qᵢ for model
instance i.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.num_velocities">
<span class="sig-name descname"><span class="pre">num_velocities</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.num_velocities" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>num_velocities(self: pydrake.multibody.plant.MultibodyPlant_[Expression]) -&gt; int</p></li>
</ol>
<p>Returns the size of the generalized velocity vector v for this model.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>num_velocities(self: pydrake.multibody.plant.MultibodyPlant_[Expression], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; int</p></li>
</ol>
<p>Returns the size of the generalized velocity vector vᵢ for model
instance i.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.NumBodiesWithName">
<span class="sig-name descname"><span class="pre">NumBodiesWithName</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.NumBodiesWithName" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The total number of bodies (across all model instances) with the
given name.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.RegisterAsSourceForSceneGraph">
<span class="sig-name descname"><span class="pre">RegisterAsSourceForSceneGraph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scene_graph</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.geometry.SceneGraph_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.SourceId" title="pydrake.geometry.SourceId"><span class="pre">pydrake.geometry.SourceId</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.RegisterAsSourceForSceneGraph" title="Link to this definition"></a></dt>
<dd><p>Registers <code class="docutils literal notranslate"><span class="pre">this</span></code> plant to serve as a source for an instance of
SceneGraph. This registration allows MultibodyPlant to register
geometry with <code class="docutils literal notranslate"><span class="pre">scene_graph</span></code> for visualization and/or collision
queries. The string returned by <code class="docutils literal notranslate"><span class="pre">this-&gt;get_name()</span></code> is passed to
SceneGraph’s RegisterSource, so it is highly recommended that you give
the plant a recognizable name before calling this. Successive
registration calls with SceneGraph <strong>must</strong> be performed on the same
instance to which the pointer argument <code class="docutils literal notranslate"><span class="pre">scene_graph</span></code> points to.
Failure to do so will result in runtime exceptions.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">scene_graph</span></code>:</dt><dd><p>A valid non nullptr to the SceneGraph instance for which <code class="docutils literal notranslate"><span class="pre">this</span></code>
plant will sever as a source, see SceneGraph documentation for
further details.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>the SourceId of <code class="docutils literal notranslate"><span class="pre">this</span></code> plant in <code class="docutils literal notranslate"><span class="pre">scene_graph</span></code>. It can also
later on be retrieved with get_source_id().</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>RuntimeError if called post-finalize.</strong> – </p></li>
<li><p><strong>RuntimeError if scene_graph is the nullptr.</strong> – </p></li>
<li><p><strong>RuntimeError if called more than once.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.RegisterCollisionGeometry">
<span class="sig-name descname"><span class="pre">RegisterCollisionGeometry</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.RegisterCollisionGeometry" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>RegisterCollisionGeometry(self: pydrake.multibody.plant.MultibodyPlant_[Expression], body: pydrake.multibody.tree.RigidBody_[Expression], X_BG: pydrake.math.RigidTransform, shape: pydrake.geometry.Shape, name: str, properties: pydrake.geometry.ProximityProperties) -&gt; pydrake.geometry.GeometryId</p></li>
</ol>
<p>Registers geometry in a SceneGraph with a given geometry::Shape to be
used for the contact modeling of a given <code class="docutils literal notranslate"><span class="pre">body</span></code>. More than one
geometry can be registered with a body, in which case the body’s
contact geometry is the union of all geometries registered to that
body.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body</span></code>:</dt><dd><p>The body for which geometry is being registered.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">X_BG</span></code>:</dt><dd><p>The fixed pose of the geometry frame G in the body frame B.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">shape</span></code>:</dt><dd><p>The geometry::Shape used for collision and contact. E.g.:
geometry::Sphere, geometry::Cylinder, etc.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">properties</span></code>:</dt><dd><p>The proximity properties associated with the collision geometry.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called post-finalize.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>RegisterCollisionGeometry(self: pydrake.multibody.plant.MultibodyPlant_[Expression], body: pydrake.multibody.tree.RigidBody_[Expression], X_BG: pydrake.math.RigidTransform, shape: pydrake.geometry.Shape, name: str, coulomb_friction: pydrake.multibody.plant.CoulombFriction) -&gt; pydrake.geometry.GeometryId</p></li>
</ol>
<p>Overload which specifies a single property: coulomb_friction.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.RegisterVisualGeometry">
<span class="sig-name descname"><span class="pre">RegisterVisualGeometry</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.RegisterVisualGeometry" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>RegisterVisualGeometry(self: pydrake.multibody.plant.MultibodyPlant_[Expression], body: pydrake.multibody.tree.RigidBody_[Expression], X_BG: pydrake.math.RigidTransform, shape: pydrake.geometry.Shape, name: str, diffuse_color: numpy.ndarray[numpy.float64[4, 1]]) -&gt; pydrake.geometry.GeometryId</p></li>
</ol>
<p>Overload for visual geometry registration. The following properties
are set: - (“phong”, “diffuse”) = <code class="docutils literal notranslate"><span class="pre">diffuse_color</span></code> in both sets of
properties. - (“label”, “id”) in perception properties as documented
above.</p>
<p>See mbp_geometry “the overview” for more details.</p>
<ol class="arabic simple" start="2">
<li><p>RegisterVisualGeometry(self: pydrake.multibody.plant.MultibodyPlant_[Expression], body: pydrake.multibody.tree.RigidBody_[Expression], geometry_instance: pydrake.geometry.GeometryInstance) -&gt; pydrake.geometry.GeometryId</p></li>
</ol>
<p>Registers the given <code class="docutils literal notranslate"><span class="pre">geometry_instance</span></code> in a SceneGraph to be used
for visualization of a given <code class="docutils literal notranslate"><span class="pre">body</span></code>.</p>
<p>The roles that <code class="docutils literal notranslate"><span class="pre">geometry_instance</span></code> gets assigned
(illustration/perception) in SceneGraph depend solely on the
properties that have <em>already</em> been assigned to <code class="docutils literal notranslate"><span class="pre">geometry_instance</span></code>.
If <em>any</em> visual roles have been assigned, those will be the only roles
used. If <em>no</em> visual roles have been assigned, then both roles will be
assigned using the default set of property values.</p>
<p>If the registered geometry has the perception role, it will have the
(“label”, “id”) property. Possibly assigned as documented above.</p>
<p>See mbp_geometry “the overview” for more details.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body</span></code>:</dt><dd><p>The body for which geometry is being registered.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">geometry_instance</span></code>:</dt><dd><p>The geometry to associate with the visual appearance of <code class="docutils literal notranslate"><span class="pre">body</span></code>.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if geometry_instance is null.</strong> – </p></li>
<li><p><strong>RuntimeError if called post-finalize.</strong> – </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>the id for the registered geometry.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.RemoveConstraint">
<span class="sig-name descname"><span class="pre">RemoveConstraint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">id</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.MultibodyConstraintId" title="pydrake.multibody.tree.MultibodyConstraintId"><span class="pre">pydrake.multibody.tree.MultibodyConstraintId</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.RemoveConstraint" title="Link to this definition"></a></dt>
<dd><p>Removes the constraint <code class="docutils literal notranslate"><span class="pre">id</span></code> from the plant. Note that this will
<em>not</em> remove constraints registered directly with DeformableModel.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the MultibodyPlant has already been finalized.</strong> – </p></li>
<li><p><strong>RuntimeError if id does not identify any multibody constraint</strong> – </p></li>
<li><p><strong>in this plant.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.RemoveJoint">
<span class="sig-name descname"><span class="pre">RemoveJoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">joint</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.Joint_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.RemoveJoint" title="Link to this definition"></a></dt>
<dd><p>Removes and deletes <code class="docutils literal notranslate"><span class="pre">joint</span></code> from this MultibodyPlant. Any existing
references to <code class="docutils literal notranslate"><span class="pre">joint</span></code> will become invalid, and future calls to
<code class="docutils literal notranslate"><span class="pre">get_joint(joint_index)</span></code> will throw an exception. Other elements of
the plant may depend on <code class="docutils literal notranslate"><span class="pre">joint</span></code> at the time of removal and should be
removed first. For example, a JointActuator that depends on <code class="docutils literal notranslate"><span class="pre">joint</span></code>
should be removed with RemoveJointActuator(). Currently, we do not
provide joint dependency tracking for force elements or constraints,
so this function will throw an exception if there are <em>any</em> user-added
force elements or constraints in the plant.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the plant is already finalized.</strong> – </p></li>
<li><p><strong>RuntimeError if the plant contains a non-zero number</strong><strong> of </strong><strong>user-added</strong> – </p></li>
<li><p><strong>force elements</strong><strong> or </strong><strong>user-added constraints.</strong> – </p></li>
<li><p><strong>RuntimeError if joint has a dependent JointActuator.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddJoint()</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is important to note that the JointIndex assigned to a joint is
immutable. New joint indices are assigned in increasing order,
even if a joint with a lower index has been removed. This has the
consequence that when a joint is removed from the plant, the
sequence <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">num_joints())</span></code> is not necessarily the correct set
of un-removed joint indices in the plant. Thus, it is important
<em>NOT</em> to loop over joint indices sequentially from <code class="docutils literal notranslate"><span class="pre">0</span></code> to
<code class="docutils literal notranslate"><span class="pre">num_joints()</span> <span class="pre">-</span> <span class="pre">1</span></code>. Instead users should use the provided
GetJointIndices() and GetJointIndices(ModelIndex) functions:</p>
</div>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">JointIndex</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">plant</span><span class="p">.</span><span class="n">GetJointIndices</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">Joint</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">joint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">plant</span><span class="p">.</span><span class="n">get_joint</span><span class="p">(</span><span class="n">index</span><span class="p">);</span>
<span class="w">  </span><span class="p">...</span>
<span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
</details></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.RemoveJointActuator">
<span class="sig-name descname"><span class="pre">RemoveJointActuator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">actuator</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.JointActuator_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.RemoveJointActuator" title="Link to this definition"></a></dt>
<dd><p>Removes and deletes <code class="docutils literal notranslate"><span class="pre">actuator</span></code> from this MultibodyPlant. Any
existing references to <code class="docutils literal notranslate"><span class="pre">actuator</span></code> will become invalid, and future
calls to <code class="docutils literal notranslate"><span class="pre">get_joint_actuator(actuator_index)</span></code> will throw an
exception.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if the plant is already finalized.</strong> – </p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddJointActuator()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.RenameModelInstance">
<span class="sig-name descname"><span class="pre">RenameModelInstance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.RenameModelInstance" title="Link to this definition"></a></dt>
<dd><p>Renames an existing model instance.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>:</dt><dd><p>The instance to rename.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">name</span></code>:</dt><dd><p>A string that uniquely identifies the instance within <code class="docutils literal notranslate"><span class="pre">this</span></code>
model.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if called after Finalize</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p></li>
<li><p><strong>RuntimeError if model_instance is not a valid index.</strong> – </p></li>
<li><p><strong>RuntimeError if HasModelInstanceNamed</strong><strong>(</strong><strong>name</strong><strong>) </strong><strong>is true.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.set_adjacent_bodies_collision_filters">
<span class="sig-name descname"><span class="pre">set_adjacent_bodies_collision_filters</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.set_adjacent_bodies_collision_filters" title="Link to this definition"></a></dt>
<dd><p>Sets whether to apply collision filters to topologically adjacent
bodies at Finalize() time. Filters are applied when there exists a
joint between bodies, except in the case of 6-dof joints or joints in
which the parent body is <code class="docutils literal notranslate"><span class="pre">world</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError iff called post-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.set_contact_model">
<span class="sig-name descname"><span class="pre">set_contact_model</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.ContactModel" title="pydrake.multibody.plant.ContactModel"><span class="pre">pydrake.multibody.plant.ContactModel</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.set_contact_model" title="Link to this definition"></a></dt>
<dd><p>Sets the contact model to be used by <code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant, see
ContactModel for available options. The default contact model is
ContactModel::kHydroelasticWithFallback.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError iff called post-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.set_contact_surface_representation">
<span class="sig-name descname"><span class="pre">set_contact_surface_representation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">surface_representation</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.HydroelasticContactRepresentation" title="pydrake.geometry.HydroelasticContactRepresentation"><span class="pre">pydrake.geometry.HydroelasticContactRepresentation</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.set_contact_surface_representation" title="Link to this definition"></a></dt>
<dd><p>Sets the representation of contact surfaces to be used by <code class="docutils literal notranslate"><span class="pre">this</span></code>
MultibodyPlant. See geometry::HydroelasticContactRepresentation for
available options. See GetDefaultContactSurfaceRepresentation() for
explanation of default values.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called post-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.set_discrete_contact_approximation">
<span class="sig-name descname"><span class="pre">set_discrete_contact_approximation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">approximation</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.DiscreteContactApproximation" title="pydrake.multibody.plant.DiscreteContactApproximation"><span class="pre">pydrake.multibody.plant.DiscreteContactApproximation</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.set_discrete_contact_approximation" title="Link to this definition"></a></dt>
<dd><p>Sets the discrete contact model approximation.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Calling this method also sets the contact solver type (see
get_discrete_contact_solver()) according to: -
DiscreteContactApproximation::kTamsi sets the solver to
DiscreteContactSolver::kTamsi. -
DiscreteContactApproximation::kSap,
DiscreteContactApproximation::kSimilar and
DiscreteContactApproximation::kLagged set the solver to
DiscreteContactSolver::kSap.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>iff this plant is continuous</strong><strong> (</strong><strong>i.e. is_discrete</strong><strong>(</strong><strong>) </strong><strong>is</strong> – </p></li>
<li><p><strong>False`.</strong> – </p></li>
<li><p><strong>RuntimeError iff called post-finalize.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.set_gravity_enabled">
<span class="sig-name descname"><span class="pre">set_gravity_enabled</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_enabled</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.set_gravity_enabled" title="Link to this definition"></a></dt>
<dd><p>Sets is_gravity_enabled() for <code class="docutils literal notranslate"><span class="pre">model_instance</span></code> to <code class="docutils literal notranslate"><span class="pre">is_enabled</span></code>.
The effect of <code class="docutils literal notranslate"><span class="pre">is_enabled</span> <span class="pre">=</span> <span class="pre">false</span></code> is effectively equivalent to
disabling (or making zero) gravity for all bodies in the specified
model instance. By default is_gravity_enabled() equals <code class="docutils literal notranslate"><span class="pre">True</span></code> for
all model instances.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if called post-finalize.</strong> – </p></li>
<li><p><strong>RuntimeError if the model instance is invalid.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.set_penetration_allowance">
<span class="sig-name descname"><span class="pre">set_penetration_allowance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">penetration_allowance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.001</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.set_penetration_allowance" title="Link to this definition"></a></dt>
<dd><p>Sets a penetration allowance used to estimate the point contact
stiffness and Hunt &amp; Crossley dissipation parameters. Refer to the
section point_contact_defaults “Point Contact Default Parameters” for
further details.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This will be deprecated. Prefer using defaults specified in
geometry::DefaultProximityProperties.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Values provided in geometry::DefaultProximityProperties have
precedence. If values estimated based on penetration allowance are
desired, set defaults in geometry::DefaultProximityProperties to
std::nullopt.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if penetration_allowance is not positive.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.set_sap_near_rigid_threshold">
<span class="sig-name descname"><span class="pre">set_sap_near_rigid_threshold</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">near_rigid_threshold</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.set_sap_near_rigid_threshold" title="Link to this definition"></a></dt>
<dd><p>Non-negative dimensionless number typically in the range [0.0, 1.0],
though larger values are allowed even if uncommon. This parameter
controls the “near rigid” regime of the SAP solver, β in section V.B
of [Castro et al., 2021]. It essentially controls a threshold value
for the maximum amount of stiffness SAP can handle robustly. Beyond
this value, stiffness saturates as explained in [Castro et al., 2021].
A value of 1.0 is a conservative choice to avoid ill-conditioning that
might lead to softer than expected contact. If this is your case,
consider turning off this approximation by setting this parameter to
zero. For difficult cases where ill-conditioning is a problem, a small
but non-zero number can be used, e.g. 1.0e-3.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if near_rigid_threshold is negative.</strong> – </p></li>
<li><p><strong>RuntimeError if called post-finalize.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.set_stiction_tolerance">
<span class="sig-name descname"><span class="pre">set_stiction_tolerance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v_stiction</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.001</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.set_stiction_tolerance" title="Link to this definition"></a></dt>
<dd><p><a href="#id103"><span class="problematic" id="id104">**</span></a>** Stribeck model of friction</p>
<p>Currently MultibodyPlant uses the Stribeck approximation to model dry
friction. The Stribeck model of friction is an approximation to
Coulomb’s law of friction that allows using continuous time
integration without the need to specify complementarity constraints.
While this results in a simpler model immediately tractable with
standard numerical methods for integration of ODE’s, it often leads to
stiff dynamics that require an explicit integrator to take very small
time steps. It is therefore recommended to use error controlled
integrators when using this model or the discrete time stepping (see
multibody_simulation). See stribeck_approximation for a detailed
discussion of the Stribeck model.</p>
<p>Sets the stiction tolerance <code class="docutils literal notranslate"><span class="pre">v_stiction</span></code> for the Stribeck model,
where <code class="docutils literal notranslate"><span class="pre">v_stiction</span></code> must be specified in m/s (meters per second.)
<code class="docutils literal notranslate"><span class="pre">v_stiction</span></code> defaults to a value of 1 millimeter per second. In
selecting a value for <code class="docutils literal notranslate"><span class="pre">v_stiction</span></code>, you must ask yourself the
question, “When two objects are ostensibly in stiction, how much slip
am I willing to allow?” There are two opposing design issues in
picking a value for vₛ. On the one hand, small values of vₛ make the
problem numerically stiff during stiction, potentially increasing the
integration cost. On the other hand, it should be picked to be
appropriate for the scale of the problem. For example, a car
simulation could allow a “large” value for vₛ of 1 cm/s (1×10⁻² m/s),
but reasonable stiction for grasping a 10 cm box might require
limiting residual slip to 1×10⁻³ m/s or less. Ultimately, picking the
largest viable value will allow your simulation to run faster and more
robustly. Note that <code class="docutils literal notranslate"><span class="pre">v_stiction</span></code> is the slip velocity that we’d have
when we are at edge of the friction cone. For cases when the friction
force is well within the friction cone the slip velocity will always
be smaller than this value. See also stribeck_approximation.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if v_stiction is non-positive.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.SetActuationInArray">
<span class="sig-name descname"><span class="pre">SetActuationInArray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">u_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">u</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.writeable</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.SetActuationInArray" title="Link to this definition"></a></dt>
<dd><p>Given actuation values <code class="docutils literal notranslate"><span class="pre">u_instance</span></code> for the actuators in
<code class="docutils literal notranslate"><span class="pre">model_instance</span></code>, this function updates the actuation vector u for
the entire plant model to which this actuator belongs to. Refer to
mbp_actuation “Actuation” for further details.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">u_instance</span></code>:</dt><dd><p>Actuation values for the model instance. Values are ordered by
monotonically increasing JointActuatorIndex within the model
instance.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">u</span></code>:</dt><dd><p>Actuation values for the entire plant model. The actuation value
in <code class="docutils literal notranslate"><span class="pre">u</span></code> for a particular actuator must be found at offset
JointActuator::input_start(). Only values corresponding to
<code class="docutils literal notranslate"><span class="pre">model_instance</span></code> are changed.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the size</strong><strong> of </strong><strong>u_instance is not equal to the</strong> – </p></li>
<li><p><strong>number</strong><strong> of </strong><strong>actuation inputs for the joints</strong><strong> of </strong><strong>model_instance.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.SetConstraintActiveStatus">
<span class="sig-name descname"><span class="pre">SetConstraintActiveStatus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.systems.framework.Context_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">id</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.MultibodyConstraintId" title="pydrake.multibody.tree.MultibodyConstraintId"><span class="pre">pydrake.multibody.tree.MultibodyConstraintId</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">status</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.SetConstraintActiveStatus" title="Link to this definition"></a></dt>
<dd><p>Sets the active status of the constraint given by <code class="docutils literal notranslate"><span class="pre">id</span></code> in
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the MultibodyPlant has not been finalized.</strong> – </p></li>
<li><p><strong>RuntimeError if context == nullptr</strong> – </p></li>
<li><p><strong>RuntimeError if id does not belong to any multibody constraint</strong> – </p></li>
<li><p><strong>in context.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.SetDefaultFloatingBaseBodyPose">
<span class="sig-name descname"><span class="pre">SetDefaultFloatingBaseBodyPose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.RigidBody_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X_WB</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.math.html#pydrake.math.RigidTransform" title="pydrake.math.RigidTransform"><span class="pre">pydrake.math.RigidTransform</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.SetDefaultFloatingBaseBodyPose" title="Link to this definition"></a></dt>
<dd><p>Provisionally records a default World pose for <code class="docutils literal notranslate"><span class="pre">body</span></code>, to be used in
case <code class="docutils literal notranslate"><span class="pre">body</span></code> turns out to be a floating base body after Finalize().</p>
<p>This may be called pre- or post-Finalize(). Pre-Finalize() this is the
only way to set the default pose of a floating base body.
Post-Finalize(), a floating base body’s default pose may be set either
by this function or by setting the default pose directly through the
Joint API applied to the automatically-added floating joint. The most
recent value set by either method will be used to initialize the
floating joint’s coordinates in subsequently-created Contexts.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>If this is called on a <code class="docutils literal notranslate"><span class="pre">body</span></code> that does <em>not</em> turn out to be a
floating base body after Finalize(), it will have no effect other
than to be echoed back in GetDefaultFloatingBaseBodyPose(); in
particular it will not affect the initial state in a
subsequently-created Context. Use the Joint API to set the default
pose for any body that has an explicitly-defined joint to its
parent body.</p>
</div>
<p>See mbp_working_with_free_bodies “above for details”.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body</span></code>:</dt><dd><p>RigidBody whose default pose will be set if it turns out to be a
floating base body.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">X_WB</span></code>:</dt><dd><p>Default pose of the floating base body in the World frame.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.SetDefaultFreeBodyPose">
<span class="sig-name descname"><span class="pre">SetDefaultFreeBodyPose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.RigidBody_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X_PB</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.math.html#pydrake.math.RigidTransform" title="pydrake.math.RigidTransform"><span class="pre">pydrake.math.RigidTransform</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.SetDefaultFreeBodyPose" title="Link to this definition"></a></dt>
<dd><p>(Deprecated.)</p>
<dl class="simple">
<dt>Deprecated:</dt><dd><p>Use SetDefaultFloatingBaseBodyPose() instead. This will be removed
from Drake on or after 2026-06-01.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.SetDefaultPositions">
<span class="sig-name descname"><span class="pre">SetDefaultPositions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.SetDefaultPositions" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>SetDefaultPositions(self: pydrake.multibody.plant.MultibodyPlant_[Expression], q: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</p></li>
</ol>
<p>Sets the default positions for the plant. Calls to
CreateDefaultContext or SetDefaultContext/SetDefaultState will return
a Context populated with these position values. They have no other
effects on the dynamics of the system.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the plant is not finalized</strong><strong>, </strong><strong>if q is not</strong><strong> of </strong><strong>size</strong> – </p></li>
<li><p><strong>num_positions</strong><strong>(</strong><strong>)</strong><strong>, or </strong><strong>q contains non-finite values.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>SetDefaultPositions(self: pydrake.multibody.plant.MultibodyPlant_[Expression], model_instance: pydrake.multibody.tree.ModelInstanceIndex, q_instance: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</p></li>
</ol>
<p>Sets the default positions for the model instance. Calls to
CreateDefaultContext or SetDefaultContext/SetDefaultState will return
a Context populated with these position values. They have no other
effects on the dynamics of the system.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the plant is not finalized</strong><strong>, </strong><strong>if the model_instance</strong> – </p></li>
<li><p><strong>is invalid</strong><strong>, </strong><strong>if the length</strong><strong> of </strong><strong>q_instance is not equal to</strong> – </p></li>
<li><p><strong>num_positions</strong><strong>(</strong><strong>model_instance</strong><strong>)</strong><strong>`</strong><strong>, or </strong><strong>if q_instance contain</strong> – </p></li>
<li><p><strong>non-finite values.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.SetDefaultState">
<span class="sig-name descname"><span class="pre">SetDefaultState</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.systems.framework.Context_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">state</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.systems.framework.State_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.SetDefaultState" title="Link to this definition"></a></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">state</span></code> according to defaults set by the user for joints (e.g.
RevoluteJoint::set_default_angle()) and free bodies
(SetDefaultFreeBodyPose()). If the user does not specify defaults, the
state corresponds to zero generalized positions and velocities.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize. See Finalize</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.SetDistanceConstraintParams">
<span class="sig-name descname"><span class="pre">SetDistanceConstraintParams</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.systems.framework.Context_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">id</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.MultibodyConstraintId" title="pydrake.multibody.tree.MultibodyConstraintId"><span class="pre">pydrake.multibody.tree.MultibodyConstraintId</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.DistanceConstraintParams" title="pydrake.multibody.plant.DistanceConstraintParams"><span class="pre">pydrake.multibody.plant.DistanceConstraintParams</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.SetDistanceConstraintParams" title="Link to this definition"></a></dt>
<dd><p>Stores in <code class="docutils literal notranslate"><span class="pre">context</span></code> the parameters <code class="docutils literal notranslate"><span class="pre">params</span></code> for the distance
constraint with identifier <code class="docutils literal notranslate"><span class="pre">id</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">out</span></code>:</dt><dd><p>] context The plant’s context. On output it stores <code class="docutils literal notranslate"><span class="pre">params</span></code> for
the requested distance constraint.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">id</span></code>:</dt><dd><p>Unique identifier of the constraint.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">params</span></code>:</dt><dd><p>The new set of parameters to be stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>if id is not a valid identifier for a distance constraint.</strong> – </p></li>
<li><p><strong>if params.bodyA</strong><strong>(</strong><strong>) or </strong><strong>params.bodyB</strong><strong>(</strong><strong>) </strong><strong>do not correspond to rigid</strong> – </p></li>
<li><p><strong>bodies in this MultibodyPlant.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.SetFloatingBaseBodyPoseInAnchoredFrame">
<span class="sig-name descname"><span class="pre">SetFloatingBaseBodyPoseInAnchoredFrame</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.systems.framework.Context_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_F</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.Frame_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.RigidBody_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X_FB</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.math.RigidTransform_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.SetFloatingBaseBodyPoseInAnchoredFrame" title="Link to this definition"></a></dt>
<dd><p>Updates <code class="docutils literal notranslate"><span class="pre">context</span></code> to store the World-frame pose of floating base
body B, given its pose <code class="docutils literal notranslate"><span class="pre">X_FB</span></code> in an arbitrary anchored frame F.</p>
<p>Frame F must be <em>anchored</em>, meaning that it is either on a body which
is directly welded to a frame on the World body, or more generally,
that it is on a body for which there is a kinematic path between that
body and the world body that only includes weld joints.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The World-frame pose is calculated here and stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.
Moving F subsequently will not change the stored pose unless you
call this method again.</p>
</div>
<p>See mbp_working_with_free_bodies “above for details”.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if called pre-finalize.</strong> – </p></li>
<li><p><strong>RuntimeError if frame F is not anchored to the world.</strong> – </p></li>
<li><p><strong>RuntimeError if body is not a floating base body.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.SetFloatingBaseBodyPoseInWorldFrame">
<span class="sig-name descname"><span class="pre">SetFloatingBaseBodyPoseInWorldFrame</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.systems.framework.Context_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.RigidBody_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X_WB</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.math.RigidTransform_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.SetFloatingBaseBodyPoseInWorldFrame" title="Link to this definition"></a></dt>
<dd><p>Updates <code class="docutils literal notranslate"><span class="pre">context</span></code> to store the pose <code class="docutils literal notranslate"><span class="pre">X_WB</span></code> of a given floating
base body B’s body frame in the World frame W.</p>
<p>See mbp_working_with_free_bodies “above for details”.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if called pre-finalize.</strong> – </p></li>
<li><p><strong>RuntimeError if body is not a floating base body.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.SetFreeBodyPose">
<span class="sig-name descname"><span class="pre">SetFreeBodyPose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.SetFreeBodyPose" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>SetFreeBodyPose(self: pydrake.multibody.plant.MultibodyPlant_[Expression], context: pydrake.systems.framework.Context_[Expression], body: pydrake.multibody.tree.RigidBody_[Expression], X_JpJc: pydrake.math.RigidTransform_[Expression]) -&gt; None</p></li>
</ol>
<p>For any free body’s 6-dof joint, sets <code class="docutils literal notranslate"><span class="pre">context</span></code> to store the pose
X_JpJc of child frame Jc in its parent frame Jp.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Unless <code class="docutils literal notranslate"><span class="pre">body</span></code> is a floating base body, the parent frame Jp is
not necessarily the World frame W, and the child frame Jc is not
necessarily the body frame B. For a floating base body B, this
method sets X_WB, the pose of body B in World.</p>
</div>
<p>See mbp_working_with_free_bodies “above for details”.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if called pre-finalize.</strong> – </p></li>
<li><p><strong>RuntimeError if body is not a free body.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>SetFreeBodyPose(self: pydrake.multibody.plant.MultibodyPlant_[Expression], context: pydrake.systems.framework.Context_[Expression], body: pydrake.multibody.tree.RigidBody_[Expression], X_PB: pydrake.math.RigidTransform_[Expression]) -&gt; None</p></li>
</ol>
<p>X_PB parameter name for SetFreeBodyPose() is deprecated and will be removed 2026-06-01. Use X_JpJc instead.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.SetFreeBodySpatialVelocity">
<span class="sig-name descname"><span class="pre">SetFreeBodySpatialVelocity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.SetFreeBodySpatialVelocity" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>SetFreeBodySpatialVelocity(self: pydrake.multibody.plant.MultibodyPlant_[Expression], context: pydrake.systems.framework.Context_[Expression], body: pydrake.multibody.tree.RigidBody_[Expression], V_JpJc: pydrake.multibody.math.SpatialVelocity_[Expression]) -&gt; None</p></li>
</ol>
<p>For any free body’s 6-dof joint, sets <code class="docutils literal notranslate"><span class="pre">context</span></code> to store the spatial
velocity V_JpJc of child frame Jc in its parent frame Jp.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Unless <code class="docutils literal notranslate"><span class="pre">body</span></code> is a floating base body, the parent frame Jp is
not necessarily the World frame W, and the child frame Jc is not
necessarily the body frame B. For a floating base body B, this
method sets V_WB, the spatial velocity of body B in World.</p>
</div>
<p>See mbp_working_with_free_bodies “above for details”.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if called pre-finalize.</strong> – </p></li>
<li><p><strong>RuntimeError if body is not a free body.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>SetFreeBodySpatialVelocity(self: pydrake.multibody.plant.MultibodyPlant_[Expression], body: pydrake.multibody.tree.RigidBody_[Expression], V_PB: pydrake.multibody.math.SpatialVelocity_[Expression], context: pydrake.systems.framework.Context_[Expression]) -&gt; None</p></li>
</ol>
<p>The parameter order and V_PB parameter name for SetFreeBodySpatialVelocity() are deprecated and will be removed 2026-06-01. Use context, body, V_JpJc instead.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.SetPositions">
<span class="sig-name descname"><span class="pre">SetPositions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.SetPositions" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>SetPositions(self: pydrake.multibody.plant.MultibodyPlant_[Expression], context: pydrake.systems.framework.Context_[Expression], q: numpy.ndarray[object[m, 1]]) -&gt; None</p></li>
</ol>
<p>Sets the generalized positions q in a given Context from a given
vector. Prefer this method over GetMutablePositions().</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if context is nullptr</strong><strong>, </strong><strong>if context does not</strong> – </p></li>
<li><p><strong>correspond to the Context for a multibody model</strong><strong>, </strong><strong>if the length of</strong> – </p></li>
<li><p><strong>q` is not equal to num_positions</strong><strong>(</strong><strong>)</strong><strong>, or </strong><strong>if q contain</strong> – </p></li>
<li><p><strong>non-finite values.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>SetPositions(self: pydrake.multibody.plant.MultibodyPlant_[Expression], context: pydrake.systems.framework.Context_[Expression], model_instance: pydrake.multibody.tree.ModelInstanceIndex, q: numpy.ndarray[object[m, 1]]) -&gt; None</p></li>
</ol>
<p>Sets the generalized positions q in a given Context from a given
vector. Prefer this method over GetMutablePositions().</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if context is nullptr</strong><strong>, </strong><strong>if context does not</strong> – </p></li>
<li><p><strong>correspond to the Context for a multibody model</strong><strong>, </strong><strong>if the length of</strong> – </p></li>
<li><p><strong>q` is not equal to num_positions</strong><strong>(</strong><strong>)</strong><strong>, or </strong><strong>if q contain</strong> – </p></li>
<li><p><strong>non-finite values.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.SetPositionsAndVelocities">
<span class="sig-name descname"><span class="pre">SetPositionsAndVelocities</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.SetPositionsAndVelocities" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>SetPositionsAndVelocities(self: pydrake.multibody.plant.MultibodyPlant_[Expression], context: pydrake.systems.framework.Context_[Expression], q_v: numpy.ndarray[object[m, 1]]) -&gt; None</p></li>
</ol>
<p>Sets generalized positions q and generalized velocities v in a given
Context from a given vector [q; v]. Prefer this method over
GetMutablePositionsAndVelocities().</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if context is nullptr</strong><strong>, </strong><strong>if context does not</strong> – </p></li>
<li><p><strong>correspond to the context for a multibody model</strong><strong>, </strong><strong>if the length of</strong> – </p></li>
<li><p><strong>q_v` is not equal to num_positions</strong><strong>(</strong><strong>) </strong><strong>+ num_velocities</strong><strong>(</strong><strong>)</strong><strong>, </strong><strong>o</strong> – </p></li>
<li><p><strong>if q_v contains non-finite values.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>SetPositionsAndVelocities(self: pydrake.multibody.plant.MultibodyPlant_[Expression], context: pydrake.systems.framework.Context_[Expression], model_instance: pydrake.multibody.tree.ModelInstanceIndex, q_v: numpy.ndarray[object[m, 1]]) -&gt; None</p></li>
</ol>
<p>Sets generalized positions q and generalized velocities v from a given
vector [q; v] for a specified model instance in a given Context.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if context is nullptr</strong><strong>, </strong><strong>if context does not</strong> – </p></li>
<li><p><strong>correspond to the Context for a multibody model</strong><strong>, </strong><strong>if the model</strong> – </p></li>
<li><p><strong>instance index is invalid</strong><strong>, </strong><strong>if the length</strong><strong> of </strong><strong>q_v is not equal</strong> – </p></li>
<li><p><strong>to ``num_positions</strong><strong>(</strong><strong>model_instance</strong><strong>) </strong><strong>+</strong> – </p></li>
<li><p><strong>num_velocities</strong><strong>(</strong><strong>model_instance</strong><strong>)</strong><strong>``</strong><strong>, or </strong><strong>if q_v contains</strong> – </p></li>
<li><p><strong>non-finite values.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.SetPositionsInArray">
<span class="sig-name descname"><span class="pre">SetPositionsInArray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">q_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.writeable</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.SetPositionsInArray" title="Link to this definition"></a></dt>
<dd><p>Sets the vector of generalized positions for <code class="docutils literal notranslate"><span class="pre">model_instance</span></code> in
<code class="docutils literal notranslate"><span class="pre">q</span></code> using <code class="docutils literal notranslate"><span class="pre">q_instance</span></code>, leaving all other elements in the array
untouched. This method throws an exception if <code class="docutils literal notranslate"><span class="pre">q</span></code> is not of size
MultibodyPlant::num_positions() or <code class="docutils literal notranslate"><span class="pre">q_instance</span></code> is not of size
<code class="docutils literal notranslate"><span class="pre">MultibodyPlant::num_positions(model_instance)</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.SetUseSampledOutputPorts">
<span class="sig-name descname"><span class="pre">SetUseSampledOutputPorts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_sampled_output_ports</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.SetUseSampledOutputPorts" title="Link to this definition"></a></dt>
<dd><p>(Advanced) For a discrete-time plant, configures whether the output
ports are sampled (the default) or live (opt-in). See
output_port_sampling “Output port sampling” for details.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the plant is already finalized.</strong> – </p></li>
<li><p><strong>RuntimeError if use_sampled_output_ports is True but</strong> – </p></li>
<li><p><strong>this` MultibodyPlant is not a discrete model</strong><strong> (</strong><strong>is_discrete</strong><strong>(</strong><strong>) </strong><strong>=</strong> – </p></li>
<li><p><strong>false</strong><strong>)</strong><strong>.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.SetVelocities">
<span class="sig-name descname"><span class="pre">SetVelocities</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.SetVelocities" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>SetVelocities(self: pydrake.multibody.plant.MultibodyPlant_[Expression], context: pydrake.systems.framework.Context_[Expression], v: numpy.ndarray[object[m, 1]]) -&gt; None</p></li>
</ol>
<p>Sets the generalized velocities v in a given Context from a given
vector. Prefer this method over GetMutableVelocities().</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the context is nullptr</strong><strong>, </strong><strong>if the context does</strong> – </p></li>
<li><p><strong>not correspond to the context for a multibody model</strong><strong>, </strong><strong>if the length</strong> – </p></li>
<li><p><strong>of v is not equal to num_velocities</strong><strong>(</strong><strong>)</strong><strong>, or </strong><strong>if v</strong> – </p></li>
<li><p><strong>contains non-finite values.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>SetVelocities(self: pydrake.multibody.plant.MultibodyPlant_[Expression], context: pydrake.systems.framework.Context_[Expression], model_instance: pydrake.multibody.tree.ModelInstanceIndex, v: numpy.ndarray[object[m, 1]]) -&gt; None</p></li>
</ol>
<p>Sets the generalized velocities v for a particular model instance in a
given Context from a given vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the context is nullptr</strong><strong>, </strong><strong>if context does</strong> – </p></li>
<li><p><strong>not correspond to the Context for a multibody model</strong><strong>, </strong><strong>if the model</strong> – </p></li>
<li><p><strong>instance index is invalid</strong><strong>, </strong><strong>if the length</strong><strong> of </strong><strong>v_instance is not</strong> – </p></li>
<li><p><strong>equal to num_velocities</strong><strong>(</strong><strong>model_instance</strong><strong>)</strong><strong>, or </strong><strong>if v_instance</strong> – </p></li>
<li><p><strong>contains non-finite values.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.SetVelocitiesInArray">
<span class="sig-name descname"><span class="pre">SetVelocitiesInArray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">v_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.writeable</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.SetVelocitiesInArray" title="Link to this definition"></a></dt>
<dd><p>Sets the vector of generalized velocities for <code class="docutils literal notranslate"><span class="pre">model_instance</span></code> in
<code class="docutils literal notranslate"><span class="pre">v</span></code> using <code class="docutils literal notranslate"><span class="pre">v_instance</span></code>, leaving all other elements in the array
untouched. This method throws an exception if <code class="docutils literal notranslate"><span class="pre">v</span></code> is not of size
MultibodyPlant::num_velocities(), <code class="docutils literal notranslate"><span class="pre">v_instance</span></code> is not of size
<code class="docutils literal notranslate"><span class="pre">MultibodyPlant::num_positions(model_instance)</span></code>, or <code class="docutils literal notranslate"><span class="pre">v_instance</span></code>
contains non-finite values.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.time_step">
<span class="sig-name descname"><span class="pre">time_step</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.time_step" title="Link to this definition"></a></dt>
<dd><p>The time step (or period) used to model <code class="docutils literal notranslate"><span class="pre">this</span></code> plant as a discrete
system with periodic updates. Returns 0 (zero) if the plant is modeled
as a continuous system. This property of the plant is specified at
construction and therefore this query can be performed either pre- or
post-finalize, see Finalize().</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>MultibodyPlant::MultibodyPlant(double)</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.WeldFrames">
<span class="sig-name descname"><span class="pre">WeldFrames</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_on_parent_F</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.Frame_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_on_child_M</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.tree.Frame_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X_FM</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.math.html#pydrake.math.RigidTransform" title="pydrake.math.RigidTransform"><span class="pre">pydrake.math.RigidTransform</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">RigidTransform(R=RotationMatrix([[1.0,</span> <span class="pre">0.0,</span> <span class="pre">0.0],</span> <span class="pre">[0.0,</span> <span class="pre">1.0,</span> <span class="pre">0.0],</span> <span class="pre">[0.0,</span> <span class="pre">0.0,</span> <span class="pre">1.0]]),</span> <span class="pre">p=[0.0,</span> <span class="pre">0.0,</span> <span class="pre">0.0])</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.multibody.tree.WeldJoint_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.WeldFrames" title="Link to this definition"></a></dt>
<dd><p>Welds <code class="docutils literal notranslate"><span class="pre">frame_on_parent_F</span></code> and <code class="docutils literal notranslate"><span class="pre">frame_on_child_M</span></code> with relative
pose <code class="docutils literal notranslate"><span class="pre">X_FM</span></code>. That is, the pose of frame M in frame F is fixed, with
value <code class="docutils literal notranslate"><span class="pre">X_FM</span></code>. If <code class="docutils literal notranslate"><span class="pre">X_FM</span></code> is omitted, the identity transform will be
used. The call to this method creates and adds a new WeldJoint to the
model. The new WeldJoint is named as: frame_on_parent_F.name() +
“_welds_to_” + frame_on_child_M.name().</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a constant reference to the WeldJoint welding frames F and M.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>RuntimeError if the weld produces a duplicate joint name.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.world_body">
<span class="sig-name descname"><span class="pre">world_body</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.multibody.tree.RigidBody_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.world_body" title="Link to this definition"></a></dt>
<dd><p>Returns a constant reference to the <em>world</em> body.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.world_frame">
<span class="sig-name descname"><span class="pre">world_frame</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.multibody.tree.RigidBodyFrame_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.world_frame" title="Link to this definition"></a></dt>
<dd><p>Returns a constant reference to the <em>world</em> frame.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlantConfig">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">MultibodyPlantConfig</span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlantConfig" title="Link to this definition"></a></dt>
<dd><p>The set of configurable properties on a MultibodyPlant.</p>
<p>The field names and defaults here match MultibodyPlant’s defaults
exactly, with the exception of time_step.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlantConfig.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlantConfig" title="pydrake.multibody.plant.MultibodyPlantConfig"><span class="pre">pydrake.multibody.plant.MultibodyPlantConfig</span></a></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlantConfig.__init__" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlantConfig.adjacent_bodies_collision_filters">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">adjacent_bodies_collision_filters</span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlantConfig.adjacent_bodies_collision_filters" title="Link to this definition"></a></dt>
<dd><p>Configures the
MultibodyPlant::set_adjacent_bodies_collision_filters().</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlantConfig.contact_model">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">contact_model</span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlantConfig.contact_model" title="Link to this definition"></a></dt>
<dd><p>Configures the MultibodyPlant::set_contact_model(). Refer to
drake::multibody::ContactModel for details. Valid strings are: -
“point” - “hydroelastic” - “hydroelastic_with_fallback”</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlantConfig.contact_surface_representation">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">contact_surface_representation</span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlantConfig.contact_surface_representation" title="Link to this definition"></a></dt>
<dd><p>Configures the MultibodyPlant::set_contact_surface_representation().
Refer to drake::geometry::HydroelasticContactRepresentation for
details. Valid strings are: - “triangle” - “polygon”</p>
<p>The default value used here is consistent with the default time_step
chosen above; keep this consistent with
MultibodyPlant::GetDefaultContactSurfaceRepresentation().</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlantConfig.discrete_contact_approximation">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">discrete_contact_approximation</span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlantConfig.discrete_contact_approximation" title="Link to this definition"></a></dt>
<dd><p>Configures the MultibodyPlant::set_discrete_contact_approximation().
Refer to drake::multibody::DiscreteContactApproximation for details.
Valid strings are: - “tamsi” - “sap” - “similar” - “lagged”</p>
<p>Refer to MultibodyPlant::set_discrete_contact_approximation() and the
references therein for further details.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlantConfig.penetration_allowance">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">penetration_allowance</span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlantConfig.penetration_allowance" title="Link to this definition"></a></dt>
<dd><p>Configures the MultibodyPlant::set_penetration_allowance().</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlantConfig.sap_near_rigid_threshold">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">sap_near_rigid_threshold</span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlantConfig.sap_near_rigid_threshold" title="Link to this definition"></a></dt>
<dd><p>Non-negative dimensionless number typically in the range [0.0, 1.0],
though larger values are allowed even if uncommon. This parameter
controls the “near rigid” regime of the SAP solver, β in section V.B
of [Castro et al., 2021]. It essentially controls a threshold value
for the maximum amount of stiffness SAP can handle robustly. Beyond
this value, stiffness saturates as explained in [Castro et al., 2021].
A value of 1.0 is a conservative choice to avoid numerical
ill-conditioning. However, this might introduce artificial softening
of the contact constraints. If this is your case try: 1. Set this
parameter to zero. 2. For difficult problems (hundreds of contacts for
instance), you might need to use a low value if the solver fails to
converge. For instance, set values in the range (1e-3, 1e-2).</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlantConfig.stiction_tolerance">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">stiction_tolerance</span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlantConfig.stiction_tolerance" title="Link to this definition"></a></dt>
<dd><p>Configures the MultibodyPlant::set_stiction_tolerance().</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlantConfig.time_step">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">time_step</span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlantConfig.time_step" title="Link to this definition"></a></dt>
<dd><p>Configures the MultibodyPlant::MultibodyPlant() constructor time_step.</p>
<p>There is no default value for this within MultibodyPlant itself, so
here we choose a nominal value (a discrete system, with a 1ms periodic
update) as a reasonably conservative estimate that works in many
cases.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlantConfig.use_sampled_output_ports">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">use_sampled_output_ports</span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlantConfig.use_sampled_output_ports" title="Link to this definition"></a></dt>
<dd><p>Configures the MultibodyPlant::SetUseSampledOutputPorts(). Ignored
when the time_step is zero.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.multibody.plant.PhysicalModel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">PhysicalModel</span></span><a class="headerlink" href="#pydrake.multibody.plant.PhysicalModel" title="Link to this definition"></a></dt>
<dd><p>(Internal) PhysicalModel provides the functionalities to extend the
type of physical model of MultibodyPlant. Developers can derive from
this PhysicalModel to incorporate additional model elements coupled
with the rigid body dynamics. For instance, simulation of deformable
objects requires additional state and ports to interact with externals
systems such as visualization.</p>
<p>Similar to the routine of adding multiple model elements in
MultibodyPlant, users should add all the model elements they wish to
add to a PhysicalModel before the owning MultibodyPlant calls
<code class="docutils literal notranslate"><span class="pre">Finalize()</span></code>. When <code class="docutils literal notranslate"><span class="pre">Finalize()</span></code> is invoked, MultibodyPlant will
allocate the system level context resources for each PhysicalModel it
owns. After the system resources are allocated, model mutation in the
PhysicalModels owned by MultibodyPlant is not allowed.</p>
<p>This class is for internal use only. Use derived concrete models (e.g.
DeformableModel) instead.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.PhysicalModel.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.PhysicalModel.__init__" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.multibody.plant.PointPairContactInfo">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">PointPairContactInfo</span></span><a class="headerlink" href="#pydrake.multibody.plant.PointPairContactInfo" title="Link to this definition"></a></dt>
<dd><p>A class containing information regarding contact response between two
bodies including:</p>
<ul class="simple">
<li><p>The pair of bodies that are contacting, referenced by their BodyIndex.</p></li>
<li><p>A resultant contact force.</p></li>
<li><p>A contact point.</p></li>
<li><p>Separation speed.</p></li>
<li><p>Slip speed.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <a class="reference internal" href="#pydrake.multibody.plant.PointPairContactInfo_" title="pydrake.multibody.plant.PointPairContactInfo_"><code class="xref py py-class docutils literal notranslate"><span class="pre">PointPairContactInfo_</span></code></a>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.PointPairContactInfo.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.PointPairContactInfo" title="pydrake.multibody.plant.PointPairContactInfo"><span class="pre">pydrake.multibody.plant.PointPairContactInfo</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">bodyA_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.BodyIndex" title="pydrake.multibody.tree.BodyIndex"><span class="pre">pydrake.multibody.tree.BodyIndex</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">bodyB_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.BodyIndex" title="pydrake.multibody.tree.BodyIndex"><span class="pre">pydrake.multibody.tree.BodyIndex</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">f_Bc_W</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_WC</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">separation_speed</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slip_speed</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_pair</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.PenetrationAsPointPair" title="pydrake.geometry.PenetrationAsPointPair"><span class="pre">pydrake.geometry.PenetrationAsPointPair</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.PointPairContactInfo.__init__" title="Link to this definition"></a></dt>
<dd><p>Constructs the contact information for a given pair of two colliding
bodies.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">bodyA_index</span></code>:</dt><dd><p>Index that references body A in <code class="docutils literal notranslate"><span class="pre">this</span></code> contact pair.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">bodyB_index</span></code>:</dt><dd><p>Index that references body B in <code class="docutils literal notranslate"><span class="pre">this</span></code> contact pair.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">f_Bc_W</span></code>:</dt><dd><p>Force on body B applied at contact point C, expressed in the world
frame W.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_WC</span></code>:</dt><dd><p>Position of the contact point C in the world frame W.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">separation_speed</span></code>:</dt><dd><p>Separation speed along the normal direction between body A and
body B, in meters per second. A positive value indicates bodies
are moving apart. A negative value indicates bodies are moving
towards each other.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">slip_speed</span></code>:</dt><dd><p>Slip speed, that is, the magnitude of the relative tangential
velocity at the contact point in meters per second. A non-negative
value always.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">point_pair</span></code>:</dt><dd><p>Additional point pair information for <code class="docutils literal notranslate"><span class="pre">this</span></code> contact info. Refer
to the documentation for PenetrationAsPointPair for further
details. It is expected that the body indexed by <code class="docutils literal notranslate"><span class="pre">bodyA_index</span></code>
is the same body that contains the geometry indexed by
<code class="docutils literal notranslate"><span class="pre">point_pair.id_A</span></code>. Likewise for the body indexed by
<code class="docutils literal notranslate"><span class="pre">bodyB_index</span></code> and the body contining geometry with id
<code class="docutils literal notranslate"><span class="pre">point_pair.id_B</span></code>.</p>
</dd>
<dt>Precondition:</dt><dd><p>The two body indexes must reference bodies from the same
MultibodyPlant. Contact values should likewise be generated by the
same MultibodyPlant.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.PointPairContactInfo.bodyA_index">
<span class="sig-name descname"><span class="pre">bodyA_index</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.PointPairContactInfo" title="pydrake.multibody.plant.PointPairContactInfo"><span class="pre">pydrake.multibody.plant.PointPairContactInfo</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.BodyIndex" title="pydrake.multibody.tree.BodyIndex"><span class="pre">pydrake.multibody.tree.BodyIndex</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.PointPairContactInfo.bodyA_index" title="Link to this definition"></a></dt>
<dd><p>Returns the index of body A in the contact pair.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.PointPairContactInfo.bodyB_index">
<span class="sig-name descname"><span class="pre">bodyB_index</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.PointPairContactInfo" title="pydrake.multibody.plant.PointPairContactInfo"><span class="pre">pydrake.multibody.plant.PointPairContactInfo</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.BodyIndex" title="pydrake.multibody.tree.BodyIndex"><span class="pre">pydrake.multibody.tree.BodyIndex</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.PointPairContactInfo.bodyB_index" title="Link to this definition"></a></dt>
<dd><p>Returns the index of body B in the contact pair.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.PointPairContactInfo.contact_force">
<span class="sig-name descname"><span class="pre">contact_force</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.PointPairContactInfo" title="pydrake.multibody.plant.PointPairContactInfo"><span class="pre">pydrake.multibody.plant.PointPairContactInfo</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.PointPairContactInfo.contact_force" title="Link to this definition"></a></dt>
<dd><p>Returns the contact force <code class="docutils literal notranslate"><span class="pre">f_Bc_W</span></code> on B at contact point C expressed
in the world frame W.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.PointPairContactInfo.contact_point">
<span class="sig-name descname"><span class="pre">contact_point</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.PointPairContactInfo" title="pydrake.multibody.plant.PointPairContactInfo"><span class="pre">pydrake.multibody.plant.PointPairContactInfo</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.PointPairContactInfo.contact_point" title="Link to this definition"></a></dt>
<dd><p>Returns the position <code class="docutils literal notranslate"><span class="pre">p_WC</span></code> of the contact point C in the world
frame W.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.PointPairContactInfo.point_pair">
<span class="sig-name descname"><span class="pre">point_pair</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.PointPairContactInfo" title="pydrake.multibody.plant.PointPairContactInfo"><span class="pre">pydrake.multibody.plant.PointPairContactInfo</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.PenetrationAsPointPair" title="pydrake.geometry.PenetrationAsPointPair"><span class="pre">pydrake.geometry.PenetrationAsPointPair</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.PointPairContactInfo.point_pair" title="Link to this definition"></a></dt>
<dd><p>Returns additional information for the geometric contact query for
<code class="docutils literal notranslate"><span class="pre">this</span></code> pair as a PenetrationAsPointPair. The body containing
<code class="docutils literal notranslate"><span class="pre">point_pair().id_A</span></code> is the same body indexed by <code class="docutils literal notranslate"><span class="pre">bodyA_index()</span></code>.
Likewise, the body containing <code class="docutils literal notranslate"><span class="pre">point_pair().id_B</span></code> is the same body
indexed by <code class="docutils literal notranslate"><span class="pre">bodyB_index()</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.PointPairContactInfo.separation_speed">
<span class="sig-name descname"><span class="pre">separation_speed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.PointPairContactInfo" title="pydrake.multibody.plant.PointPairContactInfo"><span class="pre">pydrake.multibody.plant.PointPairContactInfo</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.PointPairContactInfo.separation_speed" title="Link to this definition"></a></dt>
<dd><p>Returns the separation speed between body A and B along the normal
direction (see PenetrationAsPointPair::nhat_BA_W) at the contact
point. It is defined positive for bodies moving apart in the normal
direction.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.PointPairContactInfo.slip_speed">
<span class="sig-name descname"><span class="pre">slip_speed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.PointPairContactInfo" title="pydrake.multibody.plant.PointPairContactInfo"><span class="pre">pydrake.multibody.plant.PointPairContactInfo</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.PointPairContactInfo.slip_speed" title="Link to this definition"></a></dt>
<dd><p>Returns the slip speed between body A and B at contact point C.</p>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py" id="pydrake.multibody.plant.PointPairContactInfo_">
<em class="property"><span class="pre">template</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">PointPairContactInfo_</span></span><a class="headerlink" href="#pydrake.multibody.plant.PointPairContactInfo_" title="Link to this definition"></a></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">PointPairContactInfo_[float]</span></code>, <a class="reference internal" href="#pydrake.multibody.plant.PointPairContactInfo_-AutoDiffXd" title="pydrake.multibody.plant.PointPairContactInfo_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">PointPairContactInfo_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.plant.PointPairContactInfo_-Expression" title="pydrake.multibody.plant.PointPairContactInfo_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">PointPairContactInfo_[Expression]</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.multibody.plant.PointPairContactInfo_-AutoDiffXd">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">PointPairContactInfo_[AutoDiffXd]</span></span><a class="headerlink" href="#pydrake.multibody.plant.PointPairContactInfo_-AutoDiffXd" title="Link to this definition"></a></dt>
<dd><p>A class containing information regarding contact response between two
bodies including:</p>
<ul class="simple">
<li><p>The pair of bodies that are contacting, referenced by their BodyIndex.</p></li>
<li><p>A resultant contact force.</p></li>
<li><p>A contact point.</p></li>
<li><p>Separation speed.</p></li>
<li><p>Slip speed.</p></li>
</ul>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.PointPairContactInfo_-AutoDiffXd-.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.PointPairContactInfo_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bodyA_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.BodyIndex" title="pydrake.multibody.tree.BodyIndex"><span class="pre">pydrake.multibody.tree.BodyIndex</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">bodyB_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.BodyIndex" title="pydrake.multibody.tree.BodyIndex"><span class="pre">pydrake.multibody.tree.BodyIndex</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">f_Bc_W</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_WC</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">separation_speed</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">pydrake.autodiffutils.AutoDiffXd</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">slip_speed</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">pydrake.autodiffutils.AutoDiffXd</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_pair</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.geometry.PenetrationAsPointPair_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.PointPairContactInfo_-AutoDiffXd-.__init__" title="Link to this definition"></a></dt>
<dd><p>Constructs the contact information for a given pair of two colliding
bodies.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">bodyA_index</span></code>:</dt><dd><p>Index that references body A in <code class="docutils literal notranslate"><span class="pre">this</span></code> contact pair.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">bodyB_index</span></code>:</dt><dd><p>Index that references body B in <code class="docutils literal notranslate"><span class="pre">this</span></code> contact pair.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">f_Bc_W</span></code>:</dt><dd><p>Force on body B applied at contact point C, expressed in the world
frame W.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_WC</span></code>:</dt><dd><p>Position of the contact point C in the world frame W.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">separation_speed</span></code>:</dt><dd><p>Separation speed along the normal direction between body A and
body B, in meters per second. A positive value indicates bodies
are moving apart. A negative value indicates bodies are moving
towards each other.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">slip_speed</span></code>:</dt><dd><p>Slip speed, that is, the magnitude of the relative tangential
velocity at the contact point in meters per second. A non-negative
value always.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">point_pair</span></code>:</dt><dd><p>Additional point pair information for <code class="docutils literal notranslate"><span class="pre">this</span></code> contact info. Refer
to the documentation for PenetrationAsPointPair for further
details. It is expected that the body indexed by <code class="docutils literal notranslate"><span class="pre">bodyA_index</span></code>
is the same body that contains the geometry indexed by
<code class="docutils literal notranslate"><span class="pre">point_pair.id_A</span></code>. Likewise for the body indexed by
<code class="docutils literal notranslate"><span class="pre">bodyB_index</span></code> and the body contining geometry with id
<code class="docutils literal notranslate"><span class="pre">point_pair.id_B</span></code>.</p>
</dd>
<dt>Precondition:</dt><dd><p>The two body indexes must reference bodies from the same
MultibodyPlant. Contact values should likewise be generated by the
same MultibodyPlant.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.PointPairContactInfo_-AutoDiffXd-.bodyA_index">
<span class="sig-name descname"><span class="pre">bodyA_index</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.PointPairContactInfo_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.BodyIndex" title="pydrake.multibody.tree.BodyIndex"><span class="pre">pydrake.multibody.tree.BodyIndex</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.PointPairContactInfo_-AutoDiffXd-.bodyA_index" title="Link to this definition"></a></dt>
<dd><p>Returns the index of body A in the contact pair.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.PointPairContactInfo_-AutoDiffXd-.bodyB_index">
<span class="sig-name descname"><span class="pre">bodyB_index</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.PointPairContactInfo_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.BodyIndex" title="pydrake.multibody.tree.BodyIndex"><span class="pre">pydrake.multibody.tree.BodyIndex</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.PointPairContactInfo_-AutoDiffXd-.bodyB_index" title="Link to this definition"></a></dt>
<dd><p>Returns the index of body B in the contact pair.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.PointPairContactInfo_-AutoDiffXd-.contact_force">
<span class="sig-name descname"><span class="pre">contact_force</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.PointPairContactInfo_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.PointPairContactInfo_-AutoDiffXd-.contact_force" title="Link to this definition"></a></dt>
<dd><p>Returns the contact force <code class="docutils literal notranslate"><span class="pre">f_Bc_W</span></code> on B at contact point C expressed
in the world frame W.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.PointPairContactInfo_-AutoDiffXd-.contact_point">
<span class="sig-name descname"><span class="pre">contact_point</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.PointPairContactInfo_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.PointPairContactInfo_-AutoDiffXd-.contact_point" title="Link to this definition"></a></dt>
<dd><p>Returns the position <code class="docutils literal notranslate"><span class="pre">p_WC</span></code> of the contact point C in the world
frame W.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.PointPairContactInfo_-AutoDiffXd-.point_pair">
<span class="sig-name descname"><span class="pre">point_pair</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.PointPairContactInfo_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.geometry.PenetrationAsPointPair_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.PointPairContactInfo_-AutoDiffXd-.point_pair" title="Link to this definition"></a></dt>
<dd><p>Returns additional information for the geometric contact query for
<code class="docutils literal notranslate"><span class="pre">this</span></code> pair as a PenetrationAsPointPair. The body containing
<code class="docutils literal notranslate"><span class="pre">point_pair().id_A</span></code> is the same body indexed by <code class="docutils literal notranslate"><span class="pre">bodyA_index()</span></code>.
Likewise, the body containing <code class="docutils literal notranslate"><span class="pre">point_pair().id_B</span></code> is the same body
indexed by <code class="docutils literal notranslate"><span class="pre">bodyB_index()</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.PointPairContactInfo_-AutoDiffXd-.separation_speed">
<span class="sig-name descname"><span class="pre">separation_speed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.PointPairContactInfo_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">pydrake.autodiffutils.AutoDiffXd</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.PointPairContactInfo_-AutoDiffXd-.separation_speed" title="Link to this definition"></a></dt>
<dd><p>Returns the separation speed between body A and B along the normal
direction (see PenetrationAsPointPair::nhat_BA_W) at the contact
point. It is defined positive for bodies moving apart in the normal
direction.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.PointPairContactInfo_-AutoDiffXd-.slip_speed">
<span class="sig-name descname"><span class="pre">slip_speed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.PointPairContactInfo_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">pydrake.autodiffutils.AutoDiffXd</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.PointPairContactInfo_-AutoDiffXd-.slip_speed" title="Link to this definition"></a></dt>
<dd><p>Returns the slip speed between body A and B at contact point C.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.multibody.plant.PointPairContactInfo_-Expression">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">PointPairContactInfo_[Expression]</span></span><a class="headerlink" href="#pydrake.multibody.plant.PointPairContactInfo_-Expression" title="Link to this definition"></a></dt>
<dd><p>A class containing information regarding contact response between two
bodies including:</p>
<ul class="simple">
<li><p>The pair of bodies that are contacting, referenced by their BodyIndex.</p></li>
<li><p>A resultant contact force.</p></li>
<li><p>A contact point.</p></li>
<li><p>Separation speed.</p></li>
<li><p>Slip speed.</p></li>
</ul>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.PointPairContactInfo_-Expression-.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.PointPairContactInfo_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bodyA_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.BodyIndex" title="pydrake.multibody.tree.BodyIndex"><span class="pre">pydrake.multibody.tree.BodyIndex</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">bodyB_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.BodyIndex" title="pydrake.multibody.tree.BodyIndex"><span class="pre">pydrake.multibody.tree.BodyIndex</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">f_Bc_W</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_WC</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">separation_speed</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">pydrake.symbolic.Expression</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">slip_speed</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">pydrake.symbolic.Expression</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_pair</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.geometry.PenetrationAsPointPair_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.PointPairContactInfo_-Expression-.__init__" title="Link to this definition"></a></dt>
<dd><p>Constructs the contact information for a given pair of two colliding
bodies.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">bodyA_index</span></code>:</dt><dd><p>Index that references body A in <code class="docutils literal notranslate"><span class="pre">this</span></code> contact pair.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">bodyB_index</span></code>:</dt><dd><p>Index that references body B in <code class="docutils literal notranslate"><span class="pre">this</span></code> contact pair.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">f_Bc_W</span></code>:</dt><dd><p>Force on body B applied at contact point C, expressed in the world
frame W.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_WC</span></code>:</dt><dd><p>Position of the contact point C in the world frame W.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">separation_speed</span></code>:</dt><dd><p>Separation speed along the normal direction between body A and
body B, in meters per second. A positive value indicates bodies
are moving apart. A negative value indicates bodies are moving
towards each other.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">slip_speed</span></code>:</dt><dd><p>Slip speed, that is, the magnitude of the relative tangential
velocity at the contact point in meters per second. A non-negative
value always.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">point_pair</span></code>:</dt><dd><p>Additional point pair information for <code class="docutils literal notranslate"><span class="pre">this</span></code> contact info. Refer
to the documentation for PenetrationAsPointPair for further
details. It is expected that the body indexed by <code class="docutils literal notranslate"><span class="pre">bodyA_index</span></code>
is the same body that contains the geometry indexed by
<code class="docutils literal notranslate"><span class="pre">point_pair.id_A</span></code>. Likewise for the body indexed by
<code class="docutils literal notranslate"><span class="pre">bodyB_index</span></code> and the body contining geometry with id
<code class="docutils literal notranslate"><span class="pre">point_pair.id_B</span></code>.</p>
</dd>
<dt>Precondition:</dt><dd><p>The two body indexes must reference bodies from the same
MultibodyPlant. Contact values should likewise be generated by the
same MultibodyPlant.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.PointPairContactInfo_-Expression-.bodyA_index">
<span class="sig-name descname"><span class="pre">bodyA_index</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.PointPairContactInfo_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.BodyIndex" title="pydrake.multibody.tree.BodyIndex"><span class="pre">pydrake.multibody.tree.BodyIndex</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.PointPairContactInfo_-Expression-.bodyA_index" title="Link to this definition"></a></dt>
<dd><p>Returns the index of body A in the contact pair.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.PointPairContactInfo_-Expression-.bodyB_index">
<span class="sig-name descname"><span class="pre">bodyB_index</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.PointPairContactInfo_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.BodyIndex" title="pydrake.multibody.tree.BodyIndex"><span class="pre">pydrake.multibody.tree.BodyIndex</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.PointPairContactInfo_-Expression-.bodyB_index" title="Link to this definition"></a></dt>
<dd><p>Returns the index of body B in the contact pair.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.PointPairContactInfo_-Expression-.contact_force">
<span class="sig-name descname"><span class="pre">contact_force</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.PointPairContactInfo_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.PointPairContactInfo_-Expression-.contact_force" title="Link to this definition"></a></dt>
<dd><p>Returns the contact force <code class="docutils literal notranslate"><span class="pre">f_Bc_W</span></code> on B at contact point C expressed
in the world frame W.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.PointPairContactInfo_-Expression-.contact_point">
<span class="sig-name descname"><span class="pre">contact_point</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.PointPairContactInfo_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.PointPairContactInfo_-Expression-.contact_point" title="Link to this definition"></a></dt>
<dd><p>Returns the position <code class="docutils literal notranslate"><span class="pre">p_WC</span></code> of the contact point C in the world
frame W.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.PointPairContactInfo_-Expression-.point_pair">
<span class="sig-name descname"><span class="pre">point_pair</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.PointPairContactInfo_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.geometry.PenetrationAsPointPair_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.PointPairContactInfo_-Expression-.point_pair" title="Link to this definition"></a></dt>
<dd><p>Returns additional information for the geometric contact query for
<code class="docutils literal notranslate"><span class="pre">this</span></code> pair as a PenetrationAsPointPair. The body containing
<code class="docutils literal notranslate"><span class="pre">point_pair().id_A</span></code> is the same body indexed by <code class="docutils literal notranslate"><span class="pre">bodyA_index()</span></code>.
Likewise, the body containing <code class="docutils literal notranslate"><span class="pre">point_pair().id_B</span></code> is the same body
indexed by <code class="docutils literal notranslate"><span class="pre">bodyB_index()</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.PointPairContactInfo_-Expression-.separation_speed">
<span class="sig-name descname"><span class="pre">separation_speed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.PointPairContactInfo_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">pydrake.symbolic.Expression</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.PointPairContactInfo_-Expression-.separation_speed" title="Link to this definition"></a></dt>
<dd><p>Returns the separation speed between body A and B along the normal
direction (see PenetrationAsPointPair::nhat_BA_W) at the contact
point. It is defined positive for bodies moving apart in the normal
direction.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.PointPairContactInfo_-Expression-.slip_speed">
<span class="sig-name descname"><span class="pre">slip_speed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.PointPairContactInfo_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">pydrake.symbolic.Expression</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.PointPairContactInfo_-Expression-.slip_speed" title="Link to this definition"></a></dt>
<dd><p>Returns the slip speed between body A and B at contact point C.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.multibody.plant.Propeller">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">Propeller</span></span><a class="headerlink" href="#pydrake.multibody.plant.Propeller" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.LeafSystem" title="pydrake.systems.framework.LeafSystem"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem</span></code></a></p>
<p>A System that connects to the MultibodyPlant in order to model the
effects of one or more controlled propellers acting on a Body.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">command&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">body_poses&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>Propeller</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; spatial_forces</td></tr></table></td></tr></table><ul class="simple">
<li><p>The command input is a BasicVector&lt;T&gt; with one element per propeller.</p></li>
<li><p>It is expected that the body_poses input should be connected to the</p></li>
</ul>
<p>MultibodyPlant::get_body_poses_output_port() “MultibodyPlant body_poses
output port”.
- The output is of type std::vector&lt;ExternallyAppliedSpatialForce&lt;T&gt;&gt;; it is
expected that this output will be connected to the MultibodyPlant::get_applied_spatial_force_input_port()
“externally_applied_spatial_force input port” of the MultibodyPlant.
- This system does not have any state.</p>
<p>The resulting iᵗʰ spatial force will have a force component in the
z-axis of the iᵗʰ propeller frame with magnitude <code class="docutils literal notranslate"><span class="pre">thrust_ratio</span> <span class="pre">*</span>
<span class="pre">command</span></code> Newtons, and a moment around the z-axis with magnitude
<code class="docutils literal notranslate"><span class="pre">moment_ratio</span> <span class="pre">*</span> <span class="pre">command</span></code> Newton-meters. (Including these moments
tends to be important – a quadrotor does not have a stabilizable
linearization around a hovering fixed point in 3D without them).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Set PropellerInfo::moment_ratio to zero if you want a simple
thruster which applies only a force (no moment) in the Propeller
coordinates.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <a class="reference internal" href="#pydrake.multibody.plant.Propeller_" title="pydrake.multibody.plant.Propeller_"><code class="xref py py-class docutils literal notranslate"><span class="pre">Propeller_</span></code></a>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.Propeller.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.Propeller.__init__" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.multibody.plant.Propeller, body_index: pydrake.multibody.tree.BodyIndex, X_BP: pydrake.math.RigidTransform = RigidTransform( R=RotationMatrix([ [1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0], ]), p=[0.0, 0.0, 0.0], ), thrust_ratio: float = 1.0, moment_ratio: float = 0.0) -&gt; None</p></li>
</ol>
<p>Constructs a system describing a single propeller.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>PropellerInfo for details on the arguments.</p>
</div>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.multibody.plant.Propeller, propeller_info: list[pydrake.multibody.plant.PropellerInfo]) -&gt; None</p></li>
</ol>
<p>Constructs a system describing multiple propellers.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>PropellerInfo.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.Propeller.get_body_poses_input_port">
<span class="sig-name descname"><span class="pre">get_body_poses_input_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.Propeller" title="pydrake.multibody.plant.Propeller"><span class="pre">pydrake.multibody.plant.Propeller</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.InputPort" title="pydrake.systems.framework.InputPort"><span class="pre">pydrake.systems.framework.InputPort</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.Propeller.get_body_poses_input_port" title="Link to this definition"></a></dt>
<dd><p>Returns a reference to the body_poses input port. It is anticipated
that this port will be connected the body_poses output port of a
MultibodyPlant.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.Propeller.get_command_input_port">
<span class="sig-name descname"><span class="pre">get_command_input_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.Propeller" title="pydrake.multibody.plant.Propeller"><span class="pre">pydrake.multibody.plant.Propeller</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.InputPort" title="pydrake.systems.framework.InputPort"><span class="pre">pydrake.systems.framework.InputPort</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.Propeller.get_command_input_port" title="Link to this definition"></a></dt>
<dd><p>Returns a reference to the vector-valued input port for the propeller
commands. It has size <code class="docutils literal notranslate"><span class="pre">num_propellers()</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.Propeller.get_spatial_forces_output_port">
<span class="sig-name descname"><span class="pre">get_spatial_forces_output_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.Propeller" title="pydrake.multibody.plant.Propeller"><span class="pre">pydrake.multibody.plant.Propeller</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.OutputPort" title="pydrake.systems.framework.OutputPort"><span class="pre">pydrake.systems.framework.OutputPort</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.Propeller.get_spatial_forces_output_port" title="Link to this definition"></a></dt>
<dd><p>Returns a reference to the spatial_forces output port. It is
anticipated that this port will be connected to the
MultibodyPlant::get_applied_spatial_force_input_port()
“applied_spatial_force” input port of a MultibodyPlant.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.Propeller.num_propellers">
<span class="sig-name descname"><span class="pre">num_propellers</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.Propeller" title="pydrake.multibody.plant.Propeller"><span class="pre">pydrake.multibody.plant.Propeller</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.Propeller.num_propellers" title="Link to this definition"></a></dt>
<dd><p>Returns the number of propellers modeled by this system.</p>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py" id="pydrake.multibody.plant.Propeller_">
<em class="property"><span class="pre">template</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">Propeller_</span></span><a class="headerlink" href="#pydrake.multibody.plant.Propeller_" title="Link to this definition"></a></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">Propeller_[float]</span></code>, <a class="reference internal" href="#pydrake.multibody.plant.Propeller_-AutoDiffXd" title="pydrake.multibody.plant.Propeller_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">Propeller_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.plant.Propeller_-Expression" title="pydrake.multibody.plant.Propeller_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">Propeller_[Expression]</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.multibody.plant.Propeller_-AutoDiffXd">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">Propeller_[AutoDiffXd]</span></span><a class="headerlink" href="#pydrake.multibody.plant.Propeller_-AutoDiffXd" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.LeafSystem_-AutoDiffXd" title="pydrake.systems.framework.LeafSystem_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem_[AutoDiffXd]</span></code></a></p>
<p>A System that connects to the MultibodyPlant in order to model the
effects of one or more controlled propellers acting on a Body.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">command&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">body_poses&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>Propeller</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; spatial_forces</td></tr></table></td></tr></table><ul class="simple">
<li><p>The command input is a BasicVector&lt;T&gt; with one element per propeller.</p></li>
<li><p>It is expected that the body_poses input should be connected to the</p></li>
</ul>
<p>MultibodyPlant::get_body_poses_output_port() “MultibodyPlant body_poses
output port”.
- The output is of type std::vector&lt;ExternallyAppliedSpatialForce&lt;T&gt;&gt;; it is
expected that this output will be connected to the MultibodyPlant::get_applied_spatial_force_input_port()
“externally_applied_spatial_force input port” of the MultibodyPlant.
- This system does not have any state.</p>
<p>The resulting iᵗʰ spatial force will have a force component in the
z-axis of the iᵗʰ propeller frame with magnitude <code class="docutils literal notranslate"><span class="pre">thrust_ratio</span> <span class="pre">*</span>
<span class="pre">command</span></code> Newtons, and a moment around the z-axis with magnitude
<code class="docutils literal notranslate"><span class="pre">moment_ratio</span> <span class="pre">*</span> <span class="pre">command</span></code> Newton-meters. (Including these moments
tends to be important – a quadrotor does not have a stabilizable
linearization around a hovering fixed point in 3D without them).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Set PropellerInfo::moment_ratio to zero if you want a simple
thruster which applies only a force (no moment) in the Propeller
coordinates.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.Propeller_-AutoDiffXd-.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.Propeller_-AutoDiffXd-.__init__" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.multibody.plant.Propeller_[AutoDiffXd], body_index: pydrake.multibody.tree.BodyIndex, X_BP: pydrake.math.RigidTransform = RigidTransform( R=RotationMatrix([ [1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0], ]), p=[0.0, 0.0, 0.0], ), thrust_ratio: float = 1.0, moment_ratio: float = 0.0) -&gt; None</p></li>
</ol>
<p>Constructs a system describing a single propeller.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>PropellerInfo for details on the arguments.</p>
</div>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.multibody.plant.Propeller_[AutoDiffXd], propeller_info: list[pydrake.multibody.plant.PropellerInfo]) -&gt; None</p></li>
</ol>
<p>Constructs a system describing multiple propellers.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>PropellerInfo.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.Propeller_-AutoDiffXd-.get_body_poses_input_port">
<span class="sig-name descname"><span class="pre">get_body_poses_input_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.Propeller_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.systems.framework.InputPort_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.Propeller_-AutoDiffXd-.get_body_poses_input_port" title="Link to this definition"></a></dt>
<dd><p>Returns a reference to the body_poses input port. It is anticipated
that this port will be connected the body_poses output port of a
MultibodyPlant.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.Propeller_-AutoDiffXd-.get_command_input_port">
<span class="sig-name descname"><span class="pre">get_command_input_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.Propeller_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.systems.framework.InputPort_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.Propeller_-AutoDiffXd-.get_command_input_port" title="Link to this definition"></a></dt>
<dd><p>Returns a reference to the vector-valued input port for the propeller
commands. It has size <code class="docutils literal notranslate"><span class="pre">num_propellers()</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.Propeller_-AutoDiffXd-.get_spatial_forces_output_port">
<span class="sig-name descname"><span class="pre">get_spatial_forces_output_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.Propeller_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.systems.framework.OutputPort_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.Propeller_-AutoDiffXd-.get_spatial_forces_output_port" title="Link to this definition"></a></dt>
<dd><p>Returns a reference to the spatial_forces output port. It is
anticipated that this port will be connected to the
MultibodyPlant::get_applied_spatial_force_input_port()
“applied_spatial_force” input port of a MultibodyPlant.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.Propeller_-AutoDiffXd-.num_propellers">
<span class="sig-name descname"><span class="pre">num_propellers</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.Propeller_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.Propeller_-AutoDiffXd-.num_propellers" title="Link to this definition"></a></dt>
<dd><p>Returns the number of propellers modeled by this system.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.multibody.plant.Propeller_-Expression">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">Propeller_[Expression]</span></span><a class="headerlink" href="#pydrake.multibody.plant.Propeller_-Expression" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.LeafSystem_-Expression" title="pydrake.systems.framework.LeafSystem_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem_[Expression]</span></code></a></p>
<p>A System that connects to the MultibodyPlant in order to model the
effects of one or more controlled propellers acting on a Body.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">command&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">body_poses&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>Propeller</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; spatial_forces</td></tr></table></td></tr></table><ul class="simple">
<li><p>The command input is a BasicVector&lt;T&gt; with one element per propeller.</p></li>
<li><p>It is expected that the body_poses input should be connected to the</p></li>
</ul>
<p>MultibodyPlant::get_body_poses_output_port() “MultibodyPlant body_poses
output port”.
- The output is of type std::vector&lt;ExternallyAppliedSpatialForce&lt;T&gt;&gt;; it is
expected that this output will be connected to the MultibodyPlant::get_applied_spatial_force_input_port()
“externally_applied_spatial_force input port” of the MultibodyPlant.
- This system does not have any state.</p>
<p>The resulting iᵗʰ spatial force will have a force component in the
z-axis of the iᵗʰ propeller frame with magnitude <code class="docutils literal notranslate"><span class="pre">thrust_ratio</span> <span class="pre">*</span>
<span class="pre">command</span></code> Newtons, and a moment around the z-axis with magnitude
<code class="docutils literal notranslate"><span class="pre">moment_ratio</span> <span class="pre">*</span> <span class="pre">command</span></code> Newton-meters. (Including these moments
tends to be important – a quadrotor does not have a stabilizable
linearization around a hovering fixed point in 3D without them).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Set PropellerInfo::moment_ratio to zero if you want a simple
thruster which applies only a force (no moment) in the Propeller
coordinates.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.Propeller_-Expression-.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.Propeller_-Expression-.__init__" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.multibody.plant.Propeller_[Expression], body_index: pydrake.multibody.tree.BodyIndex, X_BP: pydrake.math.RigidTransform = RigidTransform( R=RotationMatrix([ [1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0], ]), p=[0.0, 0.0, 0.0], ), thrust_ratio: float = 1.0, moment_ratio: float = 0.0) -&gt; None</p></li>
</ol>
<p>Constructs a system describing a single propeller.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>PropellerInfo for details on the arguments.</p>
</div>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.multibody.plant.Propeller_[Expression], propeller_info: list[pydrake.multibody.plant.PropellerInfo]) -&gt; None</p></li>
</ol>
<p>Constructs a system describing multiple propellers.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>PropellerInfo.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.Propeller_-Expression-.get_body_poses_input_port">
<span class="sig-name descname"><span class="pre">get_body_poses_input_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.Propeller_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.systems.framework.InputPort_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.Propeller_-Expression-.get_body_poses_input_port" title="Link to this definition"></a></dt>
<dd><p>Returns a reference to the body_poses input port. It is anticipated
that this port will be connected the body_poses output port of a
MultibodyPlant.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.Propeller_-Expression-.get_command_input_port">
<span class="sig-name descname"><span class="pre">get_command_input_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.Propeller_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.systems.framework.InputPort_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.Propeller_-Expression-.get_command_input_port" title="Link to this definition"></a></dt>
<dd><p>Returns a reference to the vector-valued input port for the propeller
commands. It has size <code class="docutils literal notranslate"><span class="pre">num_propellers()</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.Propeller_-Expression-.get_spatial_forces_output_port">
<span class="sig-name descname"><span class="pre">get_spatial_forces_output_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.Propeller_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.systems.framework.OutputPort_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.Propeller_-Expression-.get_spatial_forces_output_port" title="Link to this definition"></a></dt>
<dd><p>Returns a reference to the spatial_forces output port. It is
anticipated that this port will be connected to the
MultibodyPlant::get_applied_spatial_force_input_port()
“applied_spatial_force” input port of a MultibodyPlant.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.Propeller_-Expression-.num_propellers">
<span class="sig-name descname"><span class="pre">num_propellers</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.Propeller_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.Propeller_-Expression-.num_propellers" title="Link to this definition"></a></dt>
<dd><p>Returns the number of propellers modeled by this system.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.multibody.plant.PropellerInfo">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">PropellerInfo</span></span><a class="headerlink" href="#pydrake.multibody.plant.PropellerInfo" title="Link to this definition"></a></dt>
<dd><p>Parameters that describe the kinematic frame and force-production
properties of a single propeller.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.PropellerInfo.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.PropellerInfo" title="pydrake.multibody.plant.PropellerInfo"><span class="pre">pydrake.multibody.plant.PropellerInfo</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">body_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.BodyIndex" title="pydrake.multibody.tree.BodyIndex"><span class="pre">pydrake.multibody.tree.BodyIndex</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">X_BP</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.math.html#pydrake.math.RigidTransform" title="pydrake.math.RigidTransform"><span class="pre">pydrake.math.RigidTransform</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">RigidTransform(R=RotationMatrix([[1.0,</span> <span class="pre">0.0,</span> <span class="pre">0.0],</span> <span class="pre">[0.0,</span> <span class="pre">1.0,</span> <span class="pre">0.0],</span> <span class="pre">[0.0,</span> <span class="pre">0.0,</span> <span class="pre">1.0]]),</span> <span class="pre">p=[0.0,</span> <span class="pre">0.0,</span> <span class="pre">0.0])</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">thrust_ratio</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">moment_ratio</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.0</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.PropellerInfo.__init__" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.multibody.plant.PropellerInfo.body_index">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">body_index</span></span><a class="headerlink" href="#pydrake.multibody.plant.PropellerInfo.body_index" title="Link to this definition"></a></dt>
<dd><p>The BodyIndex of a RigidBody in the MultibodyPlant to which the
propeller is attached. The spatial forces will be applied to this
body.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.multibody.plant.PropellerInfo.moment_ratio">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">moment_ratio</span></span><a class="headerlink" href="#pydrake.multibody.plant.PropellerInfo.moment_ratio" title="Link to this definition"></a></dt>
<dd><p>The moment about the z axis (in frame P) of the spatial force will
have magnitude <code class="docutils literal notranslate"><span class="pre">moment_ratio*command</span></code> in Newton-meters. The default
is 0, which makes the propeller a simple Cartesian force generator.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.multibody.plant.PropellerInfo.thrust_ratio">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">thrust_ratio</span></span><a class="headerlink" href="#pydrake.multibody.plant.PropellerInfo.thrust_ratio" title="Link to this definition"></a></dt>
<dd><p>The z component (in frame P) of the spatial force will have magnitude
<code class="docutils literal notranslate"><span class="pre">thrust_ratio*command</span></code> in Newtons. The default is 1 (command in
Newtons), but this can also be used to scale an actuator command to
the resulting force.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.multibody.plant.PropellerInfo.X_BP">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">X_BP</span></span><a class="headerlink" href="#pydrake.multibody.plant.PropellerInfo.X_BP" title="Link to this definition"></a></dt>
<dd><p>Pose of the propeller frame P measured in the body frame B.
$*Default:* is the identity matrix.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.multibody.plant.Wing">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">Wing</span></span><a class="headerlink" href="#pydrake.multibody.plant.Wing" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.LeafSystem" title="pydrake.systems.framework.LeafSystem"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem</span></code></a></p>
<p>A System that connects to the MultibodyPlant in order to model the
simplified dynamics of an airfoil (or hydrofoil). Currently it only
supports a particular model of flat-plate aerodynamics with lift
coefficient = 2 sinα cosα, drag coefficient = 2 sin²α, moment
coefficient = 0, as documented for a number of NACA airfoils with
Reynolds number ≤ 10^5 in:</p>
<p>S. F. Hoerner and H. V. Borst, “Fluid-dynamic lift: practical
information on aerodynamic and hydrodynamic lift,” 1985 (Ch. 4,
Section 6).</p>
<p>This model was also empirically validated for a bird-scale UAV with
flat-plate wings (Reynolds number below 53000) in:</p>
<p>Rick Cory and Russ Tedrake, “Experiments in Fixed-Wing UAV Perching”,
Proceedings of the AIAA Guidance, Navigation, and Control Conference ,
pp. 1-12, 2008.</p>
<p>and may generalize well as a model for other wings in the post-stall
regime, but it should only be viewed as a simple / coarse
approximation. We aim to generalize this class to general
lift/drag/moment coefficients soon.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">body_poses&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">body_spatial_velocities&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">wind_velocity_at_aerodynamic_center (optional)&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">fluid_density (optional)&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>Wing</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; spatial_force</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; aerodynamic_center</td></tr></table></td></tr></table><ul class="simple">
<li><p>The optional wind velocity input is a three-element BasicVector&lt;T&gt;</p></li>
</ul>
<p>representing the translational velocity of the wind in world coordinates at
the aerodynamic center relative to the world origin.  See
get_aerodynamic_center_output_port() for more details.
- It is expected that the body_poses input should be connected to the
MultibodyPlant::get_body_poses_output_port() “MultibodyPlant body_poses
output port” and that body_spatial_velocities input should be connected to
the MultibodyPlant::get_body_spatial_velocities_output_port()
“MultibodyPlant body_spatial_velocities output port”
- The output is of type std::vector&lt;ExternallyAppliedSpatialForce&lt;T&gt;&gt;; it is
expected that this output will be connected to the MultibodyPlant::get_applied_spatial_force_input_port()
“externally_applied_spatial_force input port” of the MultibodyPlant.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <a class="reference internal" href="#pydrake.multibody.plant.Wing_" title="pydrake.multibody.plant.Wing_"><code class="xref py py-class docutils literal notranslate"><span class="pre">Wing_</span></code></a>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.Wing.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.Wing" title="pydrake.multibody.plant.Wing"><span class="pre">pydrake.multibody.plant.Wing</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">body_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.BodyIndex" title="pydrake.multibody.tree.BodyIndex"><span class="pre">pydrake.multibody.tree.BodyIndex</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">surface_area</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X_BodyWing</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.math.html#pydrake.math.RigidTransform" title="pydrake.math.RigidTransform"><span class="pre">pydrake.math.RigidTransform</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">RigidTransform(R=RotationMatrix([[1.0,</span> <span class="pre">0.0,</span> <span class="pre">0.0],</span> <span class="pre">[0.0,</span> <span class="pre">1.0,</span> <span class="pre">0.0],</span> <span class="pre">[0.0,</span> <span class="pre">0.0,</span> <span class="pre">1.0]]),</span> <span class="pre">p=[0.0,</span> <span class="pre">0.0,</span> <span class="pre">0.0])</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fluid_density</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1.204</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.Wing.__init__" title="Link to this definition"></a></dt>
<dd><p>Constructs a system describing a single wing using flat-plate
aerodynamics as described in the class documentation.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body_index</span></code>:</dt><dd><p>indicates the body on which the aerodynamic forces are applied.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">surface_area</span></code>:</dt><dd><p>is the total surface area of the wing in meters squared.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">X_BodyWing</span></code>:</dt><dd><p>is the pose of wing frame relative to the body frame, whose origin
is at the aerodynamic center of the wing, the positive x-axis
points along the chord towards the leading edge (e.g. towards the
nose of the plane), the positive y-axis points along the span, and
the z-axis points up. According to thin airfoil theory, the
aerodynamic center of a symmetric wing (like this flat plate), is
located at a quarter-chord position behind the leading edge.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">fluid_density</span></code>:</dt><dd><p>is the density of the fluid in kg/m^3. The default value is the
density of dry air at 20 deg Celsius at sea-level. This value is
only used if the optional fluid_density input port is not
connected.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.Wing.AddToBuilder">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">AddToBuilder</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">builder</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.DiagramBuilder" title="pydrake.systems.framework.DiagramBuilder"><span class="pre">pydrake.systems.framework.DiagramBuilder</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">plant</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">body_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.BodyIndex" title="pydrake.multibody.tree.BodyIndex"><span class="pre">pydrake.multibody.tree.BodyIndex</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">surface_area</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X_BodyWing</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.math.html#pydrake.math.RigidTransform" title="pydrake.math.RigidTransform"><span class="pre">pydrake.math.RigidTransform</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">RigidTransform(R=RotationMatrix([[1.0,</span> <span class="pre">0.0,</span> <span class="pre">0.0],</span> <span class="pre">[0.0,</span> <span class="pre">1.0,</span> <span class="pre">0.0],</span> <span class="pre">[0.0,</span> <span class="pre">0.0,</span> <span class="pre">1.0]]),</span> <span class="pre">p=[0.0,</span> <span class="pre">0.0,</span> <span class="pre">0.0])</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fluid_density</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1.204</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.multibody.plant.Wing" title="pydrake.multibody.plant.Wing"><span class="pre">pydrake.multibody.plant.Wing</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.Wing.AddToBuilder" title="Link to this definition"></a></dt>
<dd><p>Helper method that constructs a Wing and connects the input and output
ports to the MultibodyPlant.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">builder</span></code>:</dt><dd><p>is a DiagramBuilder that the Wing will be added to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">plant</span></code>:</dt><dd><p>is the MultibodyPlant containing the body referenced by
<code class="docutils literal notranslate"><span class="pre">body_index</span></code>, which the wing ports will be connected to.</p>
</dd>
</dl>
<p>See the Wing constructor for details on the remaining parameters.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.Wing.get_aerodynamic_center_output_port">
<span class="sig-name descname"><span class="pre">get_aerodynamic_center_output_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.Wing" title="pydrake.multibody.plant.Wing"><span class="pre">pydrake.multibody.plant.Wing</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.OutputPort" title="pydrake.systems.framework.OutputPort"><span class="pre">pydrake.systems.framework.OutputPort</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.Wing.get_aerodynamic_center_output_port" title="Link to this definition"></a></dt>
<dd><p>Returns a 3-element position of the aerodynamic center of the wing in
world coordinates. This output port does not depend on the optional
wind velocity input port, so it may be used to compute the wind
velocity at the aerodynamic center without causing any algebraic loops
in the Diagram. For instance, the following (sub-)Diagram could be
used to implement a wind field: ┌────────────┐ ┌──┤ Wind Field │◄─┐ │
└────────────┘ │ │ ┌──────────┐ │ └──►│ Wing ├───┘
wind_velocity_at_└──────────┘aerodynamic_center aerodynamic_center</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.Wing.get_body_poses_input_port">
<span class="sig-name descname"><span class="pre">get_body_poses_input_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.Wing" title="pydrake.multibody.plant.Wing"><span class="pre">pydrake.multibody.plant.Wing</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.InputPort" title="pydrake.systems.framework.InputPort"><span class="pre">pydrake.systems.framework.InputPort</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.Wing.get_body_poses_input_port" title="Link to this definition"></a></dt>
<dd><p>Returns a reference to the body_poses input port. It is anticipated
that this port will be connected the body_poses output port of a
MultibodyPlant.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.Wing.get_body_spatial_velocities_input_port">
<span class="sig-name descname"><span class="pre">get_body_spatial_velocities_input_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.Wing" title="pydrake.multibody.plant.Wing"><span class="pre">pydrake.multibody.plant.Wing</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.InputPort" title="pydrake.systems.framework.InputPort"><span class="pre">pydrake.systems.framework.InputPort</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.Wing.get_body_spatial_velocities_input_port" title="Link to this definition"></a></dt>
<dd><p>Returns a reference to the body_spatial_velocities input port. It is
anticipated that this port will be connected the
body_spatial_velocities output port of a MultibodyPlant.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.Wing.get_fluid_density_input_port">
<span class="sig-name descname"><span class="pre">get_fluid_density_input_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.Wing" title="pydrake.multibody.plant.Wing"><span class="pre">pydrake.multibody.plant.Wing</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.InputPort" title="pydrake.systems.framework.InputPort"><span class="pre">pydrake.systems.framework.InputPort</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.Wing.get_fluid_density_input_port" title="Link to this definition"></a></dt>
<dd><p>Returns a reference to the optional fluid_density input port, which
accepts a scalar vector in units kg/m^3. This port is provided to
support vehicles which must take into account variations in
atmospheric density; such as a spacecraft during re-entry. If left
unconnected, the aerodynamic forces will be calculated using the
default fluid density passed in the constructor.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.Wing.get_spatial_force_output_port">
<span class="sig-name descname"><span class="pre">get_spatial_force_output_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.Wing" title="pydrake.multibody.plant.Wing"><span class="pre">pydrake.multibody.plant.Wing</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.OutputPort" title="pydrake.systems.framework.OutputPort"><span class="pre">pydrake.systems.framework.OutputPort</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.Wing.get_spatial_force_output_port" title="Link to this definition"></a></dt>
<dd><p>Returns a reference to the spatial_forces output port. It is
anticipated that this port will be connected to the
MultibodyPlant::get_applied_spatial_force_input_port()
“applied_spatial_force” input port of a MultibodyPlant.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.Wing.get_wind_velocity_input_port">
<span class="sig-name descname"><span class="pre">get_wind_velocity_input_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.Wing" title="pydrake.multibody.plant.Wing"><span class="pre">pydrake.multibody.plant.Wing</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.InputPort" title="pydrake.systems.framework.InputPort"><span class="pre">pydrake.systems.framework.InputPort</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.Wing.get_wind_velocity_input_port" title="Link to this definition"></a></dt>
<dd><p>Returns a reference to the input port for the optional three-element
BasicVector&lt;T&gt; representing the translational velocity of the wind in
world coordinates at the aerodynamic center relative to the world
origin. If this port is not connected, then the wind velocity is taken
to be zero.</p>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py" id="pydrake.multibody.plant.Wing_">
<em class="property"><span class="pre">template</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">Wing_</span></span><a class="headerlink" href="#pydrake.multibody.plant.Wing_" title="Link to this definition"></a></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">Wing_[float]</span></code>, <a class="reference internal" href="#pydrake.multibody.plant.Wing_-AutoDiffXd" title="pydrake.multibody.plant.Wing_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">Wing_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.plant.Wing_-Expression" title="pydrake.multibody.plant.Wing_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">Wing_[Expression]</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.multibody.plant.Wing_-AutoDiffXd">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">Wing_[AutoDiffXd]</span></span><a class="headerlink" href="#pydrake.multibody.plant.Wing_-AutoDiffXd" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.LeafSystem_-AutoDiffXd" title="pydrake.systems.framework.LeafSystem_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem_[AutoDiffXd]</span></code></a></p>
<p>A System that connects to the MultibodyPlant in order to model the
simplified dynamics of an airfoil (or hydrofoil). Currently it only
supports a particular model of flat-plate aerodynamics with lift
coefficient = 2 sinα cosα, drag coefficient = 2 sin²α, moment
coefficient = 0, as documented for a number of NACA airfoils with
Reynolds number ≤ 10^5 in:</p>
<p>S. F. Hoerner and H. V. Borst, “Fluid-dynamic lift: practical
information on aerodynamic and hydrodynamic lift,” 1985 (Ch. 4,
Section 6).</p>
<p>This model was also empirically validated for a bird-scale UAV with
flat-plate wings (Reynolds number below 53000) in:</p>
<p>Rick Cory and Russ Tedrake, “Experiments in Fixed-Wing UAV Perching”,
Proceedings of the AIAA Guidance, Navigation, and Control Conference ,
pp. 1-12, 2008.</p>
<p>and may generalize well as a model for other wings in the post-stall
regime, but it should only be viewed as a simple / coarse
approximation. We aim to generalize this class to general
lift/drag/moment coefficients soon.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">body_poses&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">body_spatial_velocities&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">wind_velocity_at_aerodynamic_center (optional)&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">fluid_density (optional)&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>Wing</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; spatial_force</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; aerodynamic_center</td></tr></table></td></tr></table><ul class="simple">
<li><p>The optional wind velocity input is a three-element BasicVector&lt;T&gt;</p></li>
</ul>
<p>representing the translational velocity of the wind in world coordinates at
the aerodynamic center relative to the world origin.  See
get_aerodynamic_center_output_port() for more details.
- It is expected that the body_poses input should be connected to the
MultibodyPlant::get_body_poses_output_port() “MultibodyPlant body_poses
output port” and that body_spatial_velocities input should be connected to
the MultibodyPlant::get_body_spatial_velocities_output_port()
“MultibodyPlant body_spatial_velocities output port”
- The output is of type std::vector&lt;ExternallyAppliedSpatialForce&lt;T&gt;&gt;; it is
expected that this output will be connected to the MultibodyPlant::get_applied_spatial_force_input_port()
“externally_applied_spatial_force input port” of the MultibodyPlant.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.Wing_-AutoDiffXd-.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.Wing_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.BodyIndex" title="pydrake.multibody.tree.BodyIndex"><span class="pre">pydrake.multibody.tree.BodyIndex</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">surface_area</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X_BodyWing</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.math.html#pydrake.math.RigidTransform" title="pydrake.math.RigidTransform"><span class="pre">pydrake.math.RigidTransform</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">RigidTransform(R=RotationMatrix([[1.0,</span> <span class="pre">0.0,</span> <span class="pre">0.0],</span> <span class="pre">[0.0,</span> <span class="pre">1.0,</span> <span class="pre">0.0],</span> <span class="pre">[0.0,</span> <span class="pre">0.0,</span> <span class="pre">1.0]]),</span> <span class="pre">p=[0.0,</span> <span class="pre">0.0,</span> <span class="pre">0.0])</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fluid_density</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1.204</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.Wing_-AutoDiffXd-.__init__" title="Link to this definition"></a></dt>
<dd><p>Constructs a system describing a single wing using flat-plate
aerodynamics as described in the class documentation.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body_index</span></code>:</dt><dd><p>indicates the body on which the aerodynamic forces are applied.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">surface_area</span></code>:</dt><dd><p>is the total surface area of the wing in meters squared.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">X_BodyWing</span></code>:</dt><dd><p>is the pose of wing frame relative to the body frame, whose origin
is at the aerodynamic center of the wing, the positive x-axis
points along the chord towards the leading edge (e.g. towards the
nose of the plane), the positive y-axis points along the span, and
the z-axis points up. According to thin airfoil theory, the
aerodynamic center of a symmetric wing (like this flat plate), is
located at a quarter-chord position behind the leading edge.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">fluid_density</span></code>:</dt><dd><p>is the density of the fluid in kg/m^3. The default value is the
density of dry air at 20 deg Celsius at sea-level. This value is
only used if the optional fluid_density input port is not
connected.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.Wing_-AutoDiffXd-.AddToBuilder">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">AddToBuilder</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">builder</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.systems.framework.DiagramBuilder_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plant</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.BodyIndex" title="pydrake.multibody.tree.BodyIndex"><span class="pre">pydrake.multibody.tree.BodyIndex</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">surface_area</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X_BodyWing</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.math.html#pydrake.math.RigidTransform" title="pydrake.math.RigidTransform"><span class="pre">pydrake.math.RigidTransform</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">RigidTransform(R=RotationMatrix([[1.0,</span> <span class="pre">0.0,</span> <span class="pre">0.0],</span> <span class="pre">[0.0,</span> <span class="pre">1.0,</span> <span class="pre">0.0],</span> <span class="pre">[0.0,</span> <span class="pre">0.0,</span> <span class="pre">1.0]]),</span> <span class="pre">p=[0.0,</span> <span class="pre">0.0,</span> <span class="pre">0.0])</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fluid_density</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1.204</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.multibody.plant.Wing_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.Wing_-AutoDiffXd-.AddToBuilder" title="Link to this definition"></a></dt>
<dd><p>Helper method that constructs a Wing and connects the input and output
ports to the MultibodyPlant.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">builder</span></code>:</dt><dd><p>is a DiagramBuilder that the Wing will be added to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">plant</span></code>:</dt><dd><p>is the MultibodyPlant containing the body referenced by
<code class="docutils literal notranslate"><span class="pre">body_index</span></code>, which the wing ports will be connected to.</p>
</dd>
</dl>
<p>See the Wing constructor for details on the remaining parameters.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.Wing_-AutoDiffXd-.get_aerodynamic_center_output_port">
<span class="sig-name descname"><span class="pre">get_aerodynamic_center_output_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.Wing_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.systems.framework.OutputPort_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.Wing_-AutoDiffXd-.get_aerodynamic_center_output_port" title="Link to this definition"></a></dt>
<dd><p>Returns a 3-element position of the aerodynamic center of the wing in
world coordinates. This output port does not depend on the optional
wind velocity input port, so it may be used to compute the wind
velocity at the aerodynamic center without causing any algebraic loops
in the Diagram. For instance, the following (sub-)Diagram could be
used to implement a wind field: ┌────────────┐ ┌──┤ Wind Field │◄─┐ │
└────────────┘ │ │ ┌──────────┐ │ └──►│ Wing ├───┘
wind_velocity_at_└──────────┘aerodynamic_center aerodynamic_center</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.Wing_-AutoDiffXd-.get_body_poses_input_port">
<span class="sig-name descname"><span class="pre">get_body_poses_input_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.Wing_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.systems.framework.InputPort_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.Wing_-AutoDiffXd-.get_body_poses_input_port" title="Link to this definition"></a></dt>
<dd><p>Returns a reference to the body_poses input port. It is anticipated
that this port will be connected the body_poses output port of a
MultibodyPlant.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.Wing_-AutoDiffXd-.get_body_spatial_velocities_input_port">
<span class="sig-name descname"><span class="pre">get_body_spatial_velocities_input_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.Wing_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.systems.framework.InputPort_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.Wing_-AutoDiffXd-.get_body_spatial_velocities_input_port" title="Link to this definition"></a></dt>
<dd><p>Returns a reference to the body_spatial_velocities input port. It is
anticipated that this port will be connected the
body_spatial_velocities output port of a MultibodyPlant.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.Wing_-AutoDiffXd-.get_fluid_density_input_port">
<span class="sig-name descname"><span class="pre">get_fluid_density_input_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.Wing_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.systems.framework.InputPort_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.Wing_-AutoDiffXd-.get_fluid_density_input_port" title="Link to this definition"></a></dt>
<dd><p>Returns a reference to the optional fluid_density input port, which
accepts a scalar vector in units kg/m^3. This port is provided to
support vehicles which must take into account variations in
atmospheric density; such as a spacecraft during re-entry. If left
unconnected, the aerodynamic forces will be calculated using the
default fluid density passed in the constructor.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.Wing_-AutoDiffXd-.get_spatial_force_output_port">
<span class="sig-name descname"><span class="pre">get_spatial_force_output_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.Wing_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.systems.framework.OutputPort_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.Wing_-AutoDiffXd-.get_spatial_force_output_port" title="Link to this definition"></a></dt>
<dd><p>Returns a reference to the spatial_forces output port. It is
anticipated that this port will be connected to the
MultibodyPlant::get_applied_spatial_force_input_port()
“applied_spatial_force” input port of a MultibodyPlant.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.Wing_-AutoDiffXd-.get_wind_velocity_input_port">
<span class="sig-name descname"><span class="pre">get_wind_velocity_input_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.Wing_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.systems.framework.InputPort_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.Wing_-AutoDiffXd-.get_wind_velocity_input_port" title="Link to this definition"></a></dt>
<dd><p>Returns a reference to the input port for the optional three-element
BasicVector&lt;T&gt; representing the translational velocity of the wind in
world coordinates at the aerodynamic center relative to the world
origin. If this port is not connected, then the wind velocity is taken
to be zero.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.multibody.plant.Wing_-Expression">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">Wing_[Expression]</span></span><a class="headerlink" href="#pydrake.multibody.plant.Wing_-Expression" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.LeafSystem_-Expression" title="pydrake.systems.framework.LeafSystem_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem_[Expression]</span></code></a></p>
<p>A System that connects to the MultibodyPlant in order to model the
simplified dynamics of an airfoil (or hydrofoil). Currently it only
supports a particular model of flat-plate aerodynamics with lift
coefficient = 2 sinα cosα, drag coefficient = 2 sin²α, moment
coefficient = 0, as documented for a number of NACA airfoils with
Reynolds number ≤ 10^5 in:</p>
<p>S. F. Hoerner and H. V. Borst, “Fluid-dynamic lift: practical
information on aerodynamic and hydrodynamic lift,” 1985 (Ch. 4,
Section 6).</p>
<p>This model was also empirically validated for a bird-scale UAV with
flat-plate wings (Reynolds number below 53000) in:</p>
<p>Rick Cory and Russ Tedrake, “Experiments in Fixed-Wing UAV Perching”,
Proceedings of the AIAA Guidance, Navigation, and Control Conference ,
pp. 1-12, 2008.</p>
<p>and may generalize well as a model for other wings in the post-stall
regime, but it should only be viewed as a simple / coarse
approximation. We aim to generalize this class to general
lift/drag/moment coefficients soon.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">body_poses&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">body_spatial_velocities&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">wind_velocity_at_aerodynamic_center (optional)&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">fluid_density (optional)&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>Wing</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; spatial_force</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; aerodynamic_center</td></tr></table></td></tr></table><ul class="simple">
<li><p>The optional wind velocity input is a three-element BasicVector&lt;T&gt;</p></li>
</ul>
<p>representing the translational velocity of the wind in world coordinates at
the aerodynamic center relative to the world origin.  See
get_aerodynamic_center_output_port() for more details.
- It is expected that the body_poses input should be connected to the
MultibodyPlant::get_body_poses_output_port() “MultibodyPlant body_poses
output port” and that body_spatial_velocities input should be connected to
the MultibodyPlant::get_body_spatial_velocities_output_port()
“MultibodyPlant body_spatial_velocities output port”
- The output is of type std::vector&lt;ExternallyAppliedSpatialForce&lt;T&gt;&gt;; it is
expected that this output will be connected to the MultibodyPlant::get_applied_spatial_force_input_port()
“externally_applied_spatial_force input port” of the MultibodyPlant.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.Wing_-Expression-.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.Wing_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.BodyIndex" title="pydrake.multibody.tree.BodyIndex"><span class="pre">pydrake.multibody.tree.BodyIndex</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">surface_area</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X_BodyWing</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.math.html#pydrake.math.RigidTransform" title="pydrake.math.RigidTransform"><span class="pre">pydrake.math.RigidTransform</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">RigidTransform(R=RotationMatrix([[1.0,</span> <span class="pre">0.0,</span> <span class="pre">0.0],</span> <span class="pre">[0.0,</span> <span class="pre">1.0,</span> <span class="pre">0.0],</span> <span class="pre">[0.0,</span> <span class="pre">0.0,</span> <span class="pre">1.0]]),</span> <span class="pre">p=[0.0,</span> <span class="pre">0.0,</span> <span class="pre">0.0])</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fluid_density</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1.204</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.Wing_-Expression-.__init__" title="Link to this definition"></a></dt>
<dd><p>Constructs a system describing a single wing using flat-plate
aerodynamics as described in the class documentation.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body_index</span></code>:</dt><dd><p>indicates the body on which the aerodynamic forces are applied.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">surface_area</span></code>:</dt><dd><p>is the total surface area of the wing in meters squared.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">X_BodyWing</span></code>:</dt><dd><p>is the pose of wing frame relative to the body frame, whose origin
is at the aerodynamic center of the wing, the positive x-axis
points along the chord towards the leading edge (e.g. towards the
nose of the plane), the positive y-axis points along the span, and
the z-axis points up. According to thin airfoil theory, the
aerodynamic center of a symmetric wing (like this flat plate), is
located at a quarter-chord position behind the leading edge.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">fluid_density</span></code>:</dt><dd><p>is the density of the fluid in kg/m^3. The default value is the
density of dry air at 20 deg Celsius at sea-level. This value is
only used if the optional fluid_density input port is not
connected.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.Wing_-Expression-.AddToBuilder">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">AddToBuilder</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">builder</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.systems.framework.DiagramBuilder_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plant</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.BodyIndex" title="pydrake.multibody.tree.BodyIndex"><span class="pre">pydrake.multibody.tree.BodyIndex</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">surface_area</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X_BodyWing</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.math.html#pydrake.math.RigidTransform" title="pydrake.math.RigidTransform"><span class="pre">pydrake.math.RigidTransform</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">RigidTransform(R=RotationMatrix([[1.0,</span> <span class="pre">0.0,</span> <span class="pre">0.0],</span> <span class="pre">[0.0,</span> <span class="pre">1.0,</span> <span class="pre">0.0],</span> <span class="pre">[0.0,</span> <span class="pre">0.0,</span> <span class="pre">1.0]]),</span> <span class="pre">p=[0.0,</span> <span class="pre">0.0,</span> <span class="pre">0.0])</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fluid_density</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1.204</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.multibody.plant.Wing_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.Wing_-Expression-.AddToBuilder" title="Link to this definition"></a></dt>
<dd><p>Helper method that constructs a Wing and connects the input and output
ports to the MultibodyPlant.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">builder</span></code>:</dt><dd><p>is a DiagramBuilder that the Wing will be added to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">plant</span></code>:</dt><dd><p>is the MultibodyPlant containing the body referenced by
<code class="docutils literal notranslate"><span class="pre">body_index</span></code>, which the wing ports will be connected to.</p>
</dd>
</dl>
<p>See the Wing constructor for details on the remaining parameters.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.Wing_-Expression-.get_aerodynamic_center_output_port">
<span class="sig-name descname"><span class="pre">get_aerodynamic_center_output_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.Wing_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.systems.framework.OutputPort_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.Wing_-Expression-.get_aerodynamic_center_output_port" title="Link to this definition"></a></dt>
<dd><p>Returns a 3-element position of the aerodynamic center of the wing in
world coordinates. This output port does not depend on the optional
wind velocity input port, so it may be used to compute the wind
velocity at the aerodynamic center without causing any algebraic loops
in the Diagram. For instance, the following (sub-)Diagram could be
used to implement a wind field: ┌────────────┐ ┌──┤ Wind Field │◄─┐ │
└────────────┘ │ │ ┌──────────┐ │ └──►│ Wing ├───┘
wind_velocity_at_└──────────┘aerodynamic_center aerodynamic_center</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.Wing_-Expression-.get_body_poses_input_port">
<span class="sig-name descname"><span class="pre">get_body_poses_input_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.Wing_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.systems.framework.InputPort_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.Wing_-Expression-.get_body_poses_input_port" title="Link to this definition"></a></dt>
<dd><p>Returns a reference to the body_poses input port. It is anticipated
that this port will be connected the body_poses output port of a
MultibodyPlant.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.Wing_-Expression-.get_body_spatial_velocities_input_port">
<span class="sig-name descname"><span class="pre">get_body_spatial_velocities_input_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.Wing_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.systems.framework.InputPort_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.Wing_-Expression-.get_body_spatial_velocities_input_port" title="Link to this definition"></a></dt>
<dd><p>Returns a reference to the body_spatial_velocities input port. It is
anticipated that this port will be connected the
body_spatial_velocities output port of a MultibodyPlant.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.Wing_-Expression-.get_fluid_density_input_port">
<span class="sig-name descname"><span class="pre">get_fluid_density_input_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.Wing_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.systems.framework.InputPort_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.Wing_-Expression-.get_fluid_density_input_port" title="Link to this definition"></a></dt>
<dd><p>Returns a reference to the optional fluid_density input port, which
accepts a scalar vector in units kg/m^3. This port is provided to
support vehicles which must take into account variations in
atmospheric density; such as a spacecraft during re-entry. If left
unconnected, the aerodynamic forces will be calculated using the
default fluid density passed in the constructor.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.Wing_-Expression-.get_spatial_force_output_port">
<span class="sig-name descname"><span class="pre">get_spatial_force_output_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.Wing_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.systems.framework.OutputPort_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.Wing_-Expression-.get_spatial_force_output_port" title="Link to this definition"></a></dt>
<dd><p>Returns a reference to the spatial_forces output port. It is
anticipated that this port will be connected to the
MultibodyPlant::get_applied_spatial_force_input_port()
“applied_spatial_force” input port of a MultibodyPlant.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.Wing_-Expression-.get_wind_velocity_input_port">
<span class="sig-name descname"><span class="pre">get_wind_velocity_input_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.multibody.plant.Wing_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pydrake.systems.framework.InputPort_</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">Expression</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.Wing_-Expression-.get_wind_velocity_input_port" title="Link to this definition"></a></dt>
<dd><p>Returns a reference to the input port for the optional three-element
BasicVector&lt;T&gt; representing the translational velocity of the wind in
world coordinates at the aerodynamic center relative to the world
origin. If this port is not connected, then the wind velocity is taken
to be zero.</p>
</dd></dl>

</dd></dl>

</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="pydrake.multibody.parsing.html" class="btn btn-neutral float-left" title="pydrake.multibody.parsing" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="pydrake.multibody.rational.html" class="btn btn-neutral float-right" title="pydrake.multibody.rational" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p></p>
  </div>

  
</footer>
<script>
  /* Enables clicking for the mobile "hamburger" (three-line) menu item. */
  const siteHeader = document.querySelector('.site-header')
  const mobileButton = document.querySelector('.menu-mobile-toggle')
  const body = document.querySelector('body')

  mobileButton.addEventListener('click', function(event) {
    siteHeader.classList.toggle('open');
    body.classList.toggle('overflow-hidden');
  })
</script>
<footer class="site-footer padding">
  <div class="contain">
    <a href="/" class="drake-logo">
      <img src="/images/drake-logo.svg">
    </a>
    <div class="footer-menu">
      <ul>
        <li>
          <a href="/doxygen_cxx/index.html" class="site-menu-item">C++</a>
        </li>
        <li>
          <a href="/pydrake/index.html" class="site-menu-item">Python</a>
        </li>
        <li class="github-link">
          <a href="https://github.com/RobotLocomotion/drake" class="site-menu-item">GitHub <img src="/third_party/images/GitHub-Mark-64px.png"></a>
        </li>
      </ul>
    </div>
  </div>


</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>