<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>pydrake.multibody.plant &mdash; pydrake  documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/custom.css" type="text/css" />
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="pydrake.multibody.rational" href="pydrake.multibody.rational.html" />
    <link rel="prev" title="pydrake.multibody.parsing" href="pydrake.multibody.parsing.html" /> 
</head>

<body class="wy-body-for-nav">
<header class="site-header">
  <div class="site-header-inner contain">
    <a class="drake-logo" href="/"><img src="/images/drake-logo-white.svg"></a>
    <div class="menu-mobile-toggle">
      <span></span>
    </div>
    <nav class="site-menu">
      <ul>
        <li class="site-menu-item site-menu-item-main">
          <a class="site-menu-item" href="/">Home</a>
        </li>
        <li class="site-menu-item site-menu-item-main">
          <a class="site-menu-item" href="/installation.html">Installation</a>
        </li>
        <li class="site-menu-item site-menu-item-main">
          <a class="site-menu-item" href="/gallery.html">Gallery</a>
        </li>
        <li class="site-menu-item site-menu-item-main">API Documentation
          <div class="sub">
            <a class="site-menu-item" href="/doxygen_cxx/index.html">C++</a> <a class="site-menu-item" href="/pydrake/index.html">Python</a>
          </div>
        </li>
        <li class="site-menu-item site-menu-item-main">Resources
          <div class="sub">
            <a class="site-menu-item" href="/getting_help.html">Getting Help</a> <a class="site-menu-item" href="https://deepnote.com/workspace/Drake-0b3b2c53-a7ad-441b-80f8-bf8350752305/project/Tutorials-2b4fc509-aef2-417d-a40d-6071dfed9199/%2Findex.ipynb">Tutorials</a> <a class="site-menu-item" href="/python_bindings.html">Python Bindings</a> <a class="site-menu-item" href="/developers.html">For Developers</a> <a class="site-menu-item" href="/credits.html">Credits</a>
          </div>
        </li>
        <li class="github-link">
          <a class="site-menu-item" href="https://github.com/RobotLocomotion/drake">GitHub <img src="/third_party/images/GitHub-Mark-Light-64px.png"></a>
        </li>
      </ul>
    </nav>
  </div>
</header>

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> pydrake
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search pydrake only…" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
  <form id="search_form" class="wy_form" action="https://google.com/search" method="get">
    <input type="text" name="q" placeholder="Search all of Drake…" />
    <input type="hidden" name="q" value="site:drake.mit.edu OR site:underactuated.csail.mit.edu OR site:manipulation.csail.mit.edu" />
  </form>
</div>

        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="pydrake.all.html">pydrake.all</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.autodiffutils.html">pydrake.autodiffutils</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.common.html">pydrake.common</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.examples.html">pydrake.examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.forwarddiff.html">pydrake.forwarddiff</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.geometry.html">pydrake.geometry</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.gym.html">pydrake.gym</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.lcm.html">pydrake.lcm</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.manipulation.html">pydrake.manipulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.math.html">pydrake.math</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="pydrake.multibody.html">pydrake.multibody</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="pydrake.multibody.all.html">pydrake.multibody.all</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.multibody.benchmarks.html">pydrake.multibody.benchmarks</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.multibody.fem.html">pydrake.multibody.fem</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.multibody.fix_inertia.html">pydrake.multibody.fix_inertia</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.multibody.inverse_kinematics.html">pydrake.multibody.inverse_kinematics</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.multibody.math.html">pydrake.multibody.math</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.multibody.mesh_to_model.html">pydrake.multibody.mesh_to_model</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.multibody.meshcat.html">pydrake.multibody.meshcat</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.multibody.optimization.html">pydrake.multibody.optimization</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.multibody.parsing.html">pydrake.multibody.parsing</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">pydrake.multibody.plant</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.multibody.rational.html">pydrake.multibody.rational</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.multibody.tree.html">pydrake.multibody.tree</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.perception.html">pydrake.perception</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.planning.html">pydrake.planning</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.polynomial.html">pydrake.polynomial</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.solvers.html">pydrake.solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.symbolic.html">pydrake.symbolic</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.systems.html">pydrake.systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.trajectories.html">pydrake.trajectories</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.tutorials.html">pydrake.tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.visualization.html">pydrake.visualization</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">pydrake</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="pydrake.multibody.html">pydrake.multibody</a> &raquo;</li>
      <li>pydrake.multibody.plant</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="module-pydrake.multibody.plant">
<span id="pydrake-multibody-plant"></span><h1>pydrake.multibody.plant<a class="headerlink" href="#module-pydrake.multibody.plant" title="Permalink to this headline"></a></h1>
<p>Bindings for MultibodyPlant and related classes.</p>
<dl class="py function">
<dt class="sig sig-object py" id="pydrake.multibody.plant.AddMultibodyPlant">
<span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">AddMultibodyPlant</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.AddMultibodyPlant" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>AddMultibodyPlant(config: pydrake.multibody.plant.MultibodyPlantConfig, builder: pydrake.systems.framework.DiagramBuilder) -&gt; tuple</p></li>
</ol>
<p>Adds a new MultibodyPlant and SceneGraph to the given <code class="docutils literal notranslate"><span class="pre">builder</span></code>. The
plant’s settings such as <code class="docutils literal notranslate"><span class="pre">time_step</span></code> are set using the given
<code class="docutils literal notranslate"><span class="pre">config</span></code>.</p>
<ol class="arabic simple" start="2">
<li><p>AddMultibodyPlant(plant_config: pydrake.multibody.plant.MultibodyPlantConfig, scene_graph_config: pydrake.geometry.SceneGraphConfig, builder: pydrake.systems.framework.DiagramBuilder) -&gt; tuple</p></li>
</ol>
<p>Adds a new MultibodyPlant and SceneGraph to the given <code class="docutils literal notranslate"><span class="pre">builder</span></code>. The
plant’s settings such as <code class="docutils literal notranslate"><span class="pre">time_step</span></code> are set using the given
<code class="docutils literal notranslate"><span class="pre">plant_config</span></code>. The scene graph’s settings are set using the given
<code class="docutils literal notranslate"><span class="pre">scene_graph_config</span></code>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydrake.multibody.plant.AddMultibodyPlantSceneGraph">
<span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">AddMultibodyPlantSceneGraph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.AddMultibodyPlantSceneGraph" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>AddMultibodyPlantSceneGraph(builder: pydrake.systems.framework.DiagramBuilder, plant: pydrake.multibody.plant.MultibodyPlant, scene_graph: pydrake.geometry.SceneGraph = None) -&gt; tuple</p></li>
</ol>
<p>Adds a MultibodyPlant and a SceneGraph instance to a diagram builder,
connecting the geometry ports.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Usage examples in add_multibody_plant_scene_graph
“AddMultibodyPlantSceneGraph”.</p>
</div>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">builder</span></code>:</dt><dd><p>Builder to add to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">plant</span></code>:</dt><dd><p>Plant to be added to the builder.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">scene_graph</span></code>:</dt><dd><p>(optional) Constructed scene graph. If none is provided, one will
be created and used.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Pair of the registered plant and scene graph.</p>
</dd>
</dl>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">builder</span></code> and <code class="docutils literal notranslate"><span class="pre">plant</span></code> must be non-null.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>AddMultibodyPlantSceneGraph(builder: pydrake.systems.framework.DiagramBuilder, time_step: float, scene_graph: pydrake.geometry.SceneGraph = None) -&gt; tuple</p></li>
</ol>
<p>Makes a new MultibodyPlant with discrete update period <code class="docutils literal notranslate"><span class="pre">time_step</span></code>
and adds it to a diagram builder together with the provided SceneGraph
instance, connecting the geometry ports.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Usage examples in add_multibody_plant_scene_graph
“AddMultibodyPlantSceneGraph”.</p>
</div>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">builder</span></code>:</dt><dd><p>Builder to add to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">time_step</span></code>:</dt><dd><p>The discrete update period for the new MultibodyPlant to be added.
Please refer to the documentation provided in
MultibodyPlant::MultibodyPlant(double) for further details on the
parameter <code class="docutils literal notranslate"><span class="pre">time_step</span></code>.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">scene_graph</span></code>:</dt><dd><p>(optional) Constructed scene graph. If none is provided, one will
be created and used.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Pair of the registered plant and scene graph.</p>
</dd>
</dl>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">builder</span></code> must be non-null.</p>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li><p>AddMultibodyPlantSceneGraph(builder: pydrake.systems.framework.DiagramBuilder_[AutoDiffXd], plant: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], scene_graph: pydrake.geometry.SceneGraph_[AutoDiffXd] = None) -&gt; tuple</p></li>
</ol>
<p>Adds a MultibodyPlant and a SceneGraph instance to a diagram builder,
connecting the geometry ports.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Usage examples in add_multibody_plant_scene_graph
“AddMultibodyPlantSceneGraph”.</p>
</div>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">builder</span></code>:</dt><dd><p>Builder to add to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">plant</span></code>:</dt><dd><p>Plant to be added to the builder.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">scene_graph</span></code>:</dt><dd><p>(optional) Constructed scene graph. If none is provided, one will
be created and used.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Pair of the registered plant and scene graph.</p>
</dd>
</dl>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">builder</span></code> and <code class="docutils literal notranslate"><span class="pre">plant</span></code> must be non-null.</p>
</dd>
</dl>
<ol class="arabic simple" start="4">
<li><p>AddMultibodyPlantSceneGraph(builder: pydrake.systems.framework.DiagramBuilder_[AutoDiffXd], time_step: float, scene_graph: pydrake.geometry.SceneGraph_[AutoDiffXd] = None) -&gt; tuple</p></li>
</ol>
<p>Makes a new MultibodyPlant with discrete update period <code class="docutils literal notranslate"><span class="pre">time_step</span></code>
and adds it to a diagram builder together with the provided SceneGraph
instance, connecting the geometry ports.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Usage examples in add_multibody_plant_scene_graph
“AddMultibodyPlantSceneGraph”.</p>
</div>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">builder</span></code>:</dt><dd><p>Builder to add to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">time_step</span></code>:</dt><dd><p>The discrete update period for the new MultibodyPlant to be added.
Please refer to the documentation provided in
MultibodyPlant::MultibodyPlant(double) for further details on the
parameter <code class="docutils literal notranslate"><span class="pre">time_step</span></code>.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">scene_graph</span></code>:</dt><dd><p>(optional) Constructed scene graph. If none is provided, one will
be created and used.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Pair of the registered plant and scene graph.</p>
</dd>
</dl>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">builder</span></code> must be non-null.</p>
</dd>
</dl>
<ol class="arabic simple" start="5">
<li><p>AddMultibodyPlantSceneGraph(builder: pydrake.systems.framework.DiagramBuilder_[Expression], plant: pydrake.multibody.plant.MultibodyPlant_[Expression], scene_graph: pydrake.geometry.SceneGraph_[Expression] = None) -&gt; tuple</p></li>
</ol>
<p>Adds a MultibodyPlant and a SceneGraph instance to a diagram builder,
connecting the geometry ports.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Usage examples in add_multibody_plant_scene_graph
“AddMultibodyPlantSceneGraph”.</p>
</div>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">builder</span></code>:</dt><dd><p>Builder to add to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">plant</span></code>:</dt><dd><p>Plant to be added to the builder.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">scene_graph</span></code>:</dt><dd><p>(optional) Constructed scene graph. If none is provided, one will
be created and used.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Pair of the registered plant and scene graph.</p>
</dd>
</dl>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">builder</span></code> and <code class="docutils literal notranslate"><span class="pre">plant</span></code> must be non-null.</p>
</dd>
</dl>
<ol class="arabic simple" start="6">
<li><p>AddMultibodyPlantSceneGraph(builder: pydrake.systems.framework.DiagramBuilder_[Expression], time_step: float, scene_graph: pydrake.geometry.SceneGraph_[Expression] = None) -&gt; tuple</p></li>
</ol>
<p>Makes a new MultibodyPlant with discrete update period <code class="docutils literal notranslate"><span class="pre">time_step</span></code>
and adds it to a diagram builder together with the provided SceneGraph
instance, connecting the geometry ports.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Usage examples in add_multibody_plant_scene_graph
“AddMultibodyPlantSceneGraph”.</p>
</div>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">builder</span></code>:</dt><dd><p>Builder to add to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">time_step</span></code>:</dt><dd><p>The discrete update period for the new MultibodyPlant to be added.
Please refer to the documentation provided in
MultibodyPlant::MultibodyPlant(double) for further details on the
parameter <code class="docutils literal notranslate"><span class="pre">time_step</span></code>.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">scene_graph</span></code>:</dt><dd><p>(optional) Constructed scene graph. If none is provided, one will
be created and used.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Pair of the registered plant and scene graph.</p>
</dd>
</dl>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">builder</span></code> must be non-null.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ApplyMultibodyPlantConfig">
<span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">ApplyMultibodyPlantConfig</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">config</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlantConfig" title="pydrake.multibody.plant.MultibodyPlantConfig"><span class="pre">pydrake.multibody.plant.MultibodyPlantConfig</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">plant</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.ApplyMultibodyPlantConfig" title="Permalink to this definition"></a></dt>
<dd><p>Applies settings given in <code class="docutils literal notranslate"><span class="pre">config</span></code> to an existing <code class="docutils literal notranslate"><span class="pre">plant</span></code>. The
<code class="docutils literal notranslate"><span class="pre">time_step</span></code> is the one value in <code class="docutils literal notranslate"><span class="pre">config</span></code> that cannot be updated –
it can only be set in the MultibodyPlant constructor. Consider using
AddMultibodyPlant() or manually passing <code class="docutils literal notranslate"><span class="pre">config.time_step</span></code> when you
construct the MultibodyPlant.</p>
<p>This method must be called pre-Finalize.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if plant is finalized</strong><strong> or </strong><strong>if time_step is changed.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydrake.multibody.plant.CalcContactFrictionFromSurfaceProperties">
<span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">CalcContactFrictionFromSurfaceProperties</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.CalcContactFrictionFromSurfaceProperties" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>CalcContactFrictionFromSurfaceProperties(surface_properties1: pydrake.multibody.plant.CoulombFriction, surface_properties2: pydrake.multibody.plant.CoulombFriction) -&gt; pydrake.multibody.plant.CoulombFriction</p></li>
</ol>
<p>Given the surface properties of two different surfaces, this method
computes the Coulomb’s law coefficients of friction characterizing the
interaction by friction of the given surface pair. The surface
properties are specified by individual Coulomb’s law coefficients of
friction. As outlined in the class’s documentation for
CoulombFriction, friction coefficients characterize a surface pair and
not individual surfaces. However, we find it useful in practice to
associate the abstract <strong>idea</strong> of friction coefficients to a single
surface. Please refer to the documentation for CoulombFriction for
details on this topic.</p>
<p>More specifically, this method computes the contact coefficients for
the given surface pair as:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">μ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="n">μₘμₙ</span><span class="o">/</span><span class="p">(</span><span class="n">μₘ</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">μₙ</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
</details><p>where the operation above is performed separately on the static and
dynamic friction coefficients.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">surface_properties1</span></code>:</dt><dd><p>Surface properties for surface 1. Specified as an individual set
of Coulomb’s law coefficients of friction.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">surface_properties2</span></code>:</dt><dd><p>Surface properties for surface 2. Specified as an individual set
of Coulomb’s law coefficients of friction.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the combined friction coefficients for the interacting surfaces.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>CalcContactFrictionFromSurfaceProperties(surface_properties1: pydrake.multibody.plant.CoulombFriction_[AutoDiffXd], surface_properties2: pydrake.multibody.plant.CoulombFriction_[AutoDiffXd]) -&gt; pydrake.multibody.plant.CoulombFriction_[AutoDiffXd]</p></li>
</ol>
<p>Given the surface properties of two different surfaces, this method
computes the Coulomb’s law coefficients of friction characterizing the
interaction by friction of the given surface pair. The surface
properties are specified by individual Coulomb’s law coefficients of
friction. As outlined in the class’s documentation for
CoulombFriction, friction coefficients characterize a surface pair and
not individual surfaces. However, we find it useful in practice to
associate the abstract <strong>idea</strong> of friction coefficients to a single
surface. Please refer to the documentation for CoulombFriction for
details on this topic.</p>
<p>More specifically, this method computes the contact coefficients for
the given surface pair as:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">μ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="n">μₘμₙ</span><span class="o">/</span><span class="p">(</span><span class="n">μₘ</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">μₙ</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
</details><p>where the operation above is performed separately on the static and
dynamic friction coefficients.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">surface_properties1</span></code>:</dt><dd><p>Surface properties for surface 1. Specified as an individual set
of Coulomb’s law coefficients of friction.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">surface_properties2</span></code>:</dt><dd><p>Surface properties for surface 2. Specified as an individual set
of Coulomb’s law coefficients of friction.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the combined friction coefficients for the interacting surfaces.</p>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li><p>CalcContactFrictionFromSurfaceProperties(surface_properties1: pydrake.multibody.plant.CoulombFriction_[Expression], surface_properties2: pydrake.multibody.plant.CoulombFriction_[Expression]) -&gt; pydrake.multibody.plant.CoulombFriction_[Expression]</p></li>
</ol>
<p>Given the surface properties of two different surfaces, this method
computes the Coulomb’s law coefficients of friction characterizing the
interaction by friction of the given surface pair. The surface
properties are specified by individual Coulomb’s law coefficients of
friction. As outlined in the class’s documentation for
CoulombFriction, friction coefficients characterize a surface pair and
not individual surfaces. However, we find it useful in practice to
associate the abstract <strong>idea</strong> of friction coefficients to a single
surface. Please refer to the documentation for CoulombFriction for
details on this topic.</p>
<p>More specifically, this method computes the contact coefficients for
the given surface pair as:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">μ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="n">μₘμₙ</span><span class="o">/</span><span class="p">(</span><span class="n">μₘ</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">μₙ</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
</details><p>where the operation above is performed separately on the static and
dynamic friction coefficients.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">surface_properties1</span></code>:</dt><dd><p>Surface properties for surface 1. Specified as an individual set
of Coulomb’s law coefficients of friction.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">surface_properties2</span></code>:</dt><dd><p>Surface properties for surface 2. Specified as an individual set
of Coulomb’s law coefficients of friction.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the combined friction coefficients for the interacting surfaces.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ConnectContactResultsToDrakeVisualizer">
<span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">ConnectContactResultsToDrakeVisualizer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">builder:</span> <span class="pre">pydrake.systems.framework.DiagramBuilder</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plant:</span> <span class="pre">drake::multibody::MultibodyPlant&lt;double&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scene_graph:</span> <span class="pre">pydrake.geometry.SceneGraph</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lcm:</span> <span class="pre">pydrake.lcm.DrakeLcmInterface</span> <span class="pre">=</span> <span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">publish_period:</span> <span class="pre">Optional[float]</span> <span class="pre">=</span> <span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.lcm.html#pydrake.systems.lcm.LcmPublisherSystem" title="pydrake.systems.lcm.LcmPublisherSystem"><span class="pre">pydrake.systems.lcm.LcmPublisherSystem</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.ConnectContactResultsToDrakeVisualizer" title="Permalink to this definition"></a></dt>
<dd><p>MultibodyPlant-connecting overload.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ContactModel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">ContactModel</span></span><a class="headerlink" href="#pydrake.multibody.plant.ContactModel" title="Permalink to this definition"></a></dt>
<dd><p>Enumeration for contact model options.</p>
<p>Members:</p>
<blockquote>
<div><p>kHydroelastic : Contact forces are computed using the Hydroelastic model. Contact</p>
</div></blockquote>
<p>between unsupported geometries will cause a runtime exception.</p>
<blockquote>
<div><p>kPoint : Contact forces are computed using a point contact model, see</p>
</div></blockquote>
<p>point_contact_approximation “Numerical Approximation of Point
Contact”.</p>
<blockquote>
<div><p>kHydroelasticWithFallback : Contact forces are computed using the hydroelastic model, where</p>
</div></blockquote>
<p>possible. For most other unsupported colliding pairs, the point model
from kPoint is used. See
geometry::QueryObject::ComputeContactSurfacesWithFallback for more
details.</p>
<blockquote>
<div><p>kHydroelasticsOnly : Legacy alias. TODO(jwnimmer-tri) Deprecate this constant.</p>
<p>kPointContactOnly : Legacy alias. TODO(jwnimmer-tri) Deprecate this constant.</p>
</div></blockquote>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ContactModel.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.ContactModel" title="pydrake.multibody.plant.ContactModel"><span class="pre">pydrake.multibody.plant.ContactModel</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.ContactModel.__init__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ContactModel.kHydroelastic">
<span class="sig-name descname"><span class="pre">kHydroelastic</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;ContactModel.kHydroelastic:</span> <span class="pre">0&gt;</span></em><a class="headerlink" href="#pydrake.multibody.plant.ContactModel.kHydroelastic" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ContactModel.kHydroelasticsOnly">
<span class="sig-name descname"><span class="pre">kHydroelasticsOnly</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;ContactModel.kHydroelastic:</span> <span class="pre">0&gt;</span></em><a class="headerlink" href="#pydrake.multibody.plant.ContactModel.kHydroelasticsOnly" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ContactModel.kHydroelasticWithFallback">
<span class="sig-name descname"><span class="pre">kHydroelasticWithFallback</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;ContactModel.kHydroelasticWithFallback:</span> <span class="pre">2&gt;</span></em><a class="headerlink" href="#pydrake.multibody.plant.ContactModel.kHydroelasticWithFallback" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ContactModel.kPoint">
<span class="sig-name descname"><span class="pre">kPoint</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;ContactModel.kPoint:</span> <span class="pre">1&gt;</span></em><a class="headerlink" href="#pydrake.multibody.plant.ContactModel.kPoint" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ContactModel.kPointContactOnly">
<span class="sig-name descname"><span class="pre">kPointContactOnly</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;ContactModel.kPoint:</span> <span class="pre">1&gt;</span></em><a class="headerlink" href="#pydrake.multibody.plant.ContactModel.kPointContactOnly" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ContactModel.name">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">name</span></span><a class="headerlink" href="#pydrake.multibody.plant.ContactModel.name" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ContactModel.value">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">value</span></span><a class="headerlink" href="#pydrake.multibody.plant.ContactModel.value" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ContactResults">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">ContactResults</span></span><a class="headerlink" href="#pydrake.multibody.plant.ContactResults" title="Permalink to this definition"></a></dt>
<dd><p>A container class storing the contact results information for each
contact pair for a given state of the simulation. Note that copying
this data structure is expensive when <code class="docutils literal notranslate"><span class="pre">num_hydroelastic_contacts()</span> <span class="pre">&gt;</span>
<span class="pre">0</span></code> because a deep copy is performed.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <a class="reference internal" href="#pydrake.multibody.plant.ContactResults_" title="pydrake.multibody.plant.ContactResults_"><code class="xref py py-class docutils literal notranslate"><span class="pre">ContactResults_</span></code></a>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ContactResults.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.ContactResults" title="pydrake.multibody.plant.ContactResults"><span class="pre">pydrake.multibody.plant.ContactResults</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.ContactResults.__init__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ContactResults.hydroelastic_contact_info">
<span class="sig-name descname"><span class="pre">hydroelastic_contact_info</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.ContactResults" title="pydrake.multibody.plant.ContactResults"><span class="pre">pydrake.multibody.plant.ContactResults</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">i</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.multibody.plant.HydroelasticContactInfo" title="pydrake.multibody.plant.HydroelasticContactInfo"><span class="pre">pydrake.multibody.plant.HydroelasticContactInfo</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.ContactResults.hydroelastic_contact_info" title="Permalink to this definition"></a></dt>
<dd><p>Retrieves the ith HydroelasticContactInfo instance. The input index i
must be in the range [0, <code class="docutils literal notranslate"><span class="pre">num_hydroelastic_contacts()</span></code>) or this
method throws.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ContactResults.num_hydroelastic_contacts">
<span class="sig-name descname"><span class="pre">num_hydroelastic_contacts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.ContactResults" title="pydrake.multibody.plant.ContactResults"><span class="pre">pydrake.multibody.plant.ContactResults</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.ContactResults.num_hydroelastic_contacts" title="Permalink to this definition"></a></dt>
<dd><p>Returns the number of hydroelastic contacts.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ContactResults.num_point_pair_contacts">
<span class="sig-name descname"><span class="pre">num_point_pair_contacts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.ContactResults" title="pydrake.multibody.plant.ContactResults"><span class="pre">pydrake.multibody.plant.ContactResults</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.ContactResults.num_point_pair_contacts" title="Permalink to this definition"></a></dt>
<dd><p>Returns the number of point pair contacts.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ContactResults.plant">
<span class="sig-name descname"><span class="pre">plant</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.ContactResults" title="pydrake.multibody.plant.ContactResults"><span class="pre">pydrake.multibody.plant.ContactResults</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">drake::multibody::MultibodyPlant&lt;double&gt;</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.ContactResults.plant" title="Permalink to this definition"></a></dt>
<dd><p>Returns the plant that produced these contact results. In most cases
the result will be non-null, but default-constructed results might
have nulls.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ContactResults.point_pair_contact_info">
<span class="sig-name descname"><span class="pre">point_pair_contact_info</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.ContactResults" title="pydrake.multibody.plant.ContactResults"><span class="pre">pydrake.multibody.plant.ContactResults</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">i</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.multibody.plant.PointPairContactInfo" title="pydrake.multibody.plant.PointPairContactInfo"><span class="pre">pydrake.multibody.plant.PointPairContactInfo</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.ContactResults.point_pair_contact_info" title="Permalink to this definition"></a></dt>
<dd><p>Retrieves the ith PointPairContactInfo instance. The input index i
must be in the range [0, <code class="docutils literal notranslate"><span class="pre">num_point_pair_contacts()</span></code>) or this method
throws.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ContactResults.SelectHydroelastic">
<span class="sig-name descname"><span class="pre">SelectHydroelastic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.ContactResults" title="pydrake.multibody.plant.ContactResults"><span class="pre">pydrake.multibody.plant.ContactResults</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">selector</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#pydrake.multibody.plant.HydroelasticContactInfo" title="pydrake.multibody.plant.HydroelasticContactInfo"><span class="pre">pydrake.multibody.plant.HydroelasticContactInfo</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">bool</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.multibody.plant.ContactResults" title="pydrake.multibody.plant.ContactResults"><span class="pre">pydrake.multibody.plant.ContactResults</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.ContactResults.SelectHydroelastic" title="Permalink to this definition"></a></dt>
<dd><p>Returns ContactResults with only HydroelasticContactInfo instances
satisfying the selection criterion and with all PointPairContactInfo
instances.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">selector</span></code>:</dt><dd><p>Boolean predicate that returns true to select which
HydroelasticContactInfo.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It uses deep copy.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ContactResults_">
<em class="property"><span class="pre">template</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">ContactResults_</span></span><a class="headerlink" href="#pydrake.multibody.plant.ContactResults_" title="Permalink to this definition"></a></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">ContactResults_[float]</span></code>, <a class="reference internal" href="#pydrake.multibody.plant.ContactResults_-AutoDiffXd" title="pydrake.multibody.plant.ContactResults_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">ContactResults_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.plant.ContactResults_-Expression" title="pydrake.multibody.plant.ContactResults_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">ContactResults_[Expression]</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ContactResults_-AutoDiffXd">
<span id="pydrake.multibody.plant.ContactResults_[AutoDiffXd]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">ContactResults_[AutoDiffXd]</span></span><a class="headerlink" href="#pydrake.multibody.plant.ContactResults_-AutoDiffXd" title="Permalink to this definition"></a></dt>
<dd><p>A container class storing the contact results information for each
contact pair for a given state of the simulation. Note that copying
this data structure is expensive when <code class="docutils literal notranslate"><span class="pre">num_hydroelastic_contacts()</span> <span class="pre">&gt;</span>
<span class="pre">0</span></code> because a deep copy is performed.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ContactResults_-AutoDiffXd-.__init__">
<span id="pydrake.multibody.plant.ContactResults_[AutoDiffXd].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.ContactResults_" title="pydrake.multibody.plant.ContactResults_"><span class="pre">pydrake.multibody.plant.ContactResults_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.ContactResults_-AutoDiffXd-.__init__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ContactResults_-AutoDiffXd-.hydroelastic_contact_info">
<span id="pydrake.multibody.plant.ContactResults_[AutoDiffXd].hydroelastic_contact_info"></span><span class="sig-name descname"><span class="pre">hydroelastic_contact_info</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.ContactResults_" title="pydrake.multibody.plant.ContactResults_"><span class="pre">pydrake.multibody.plant.ContactResults_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.multibody.plant.HydroelasticContactInfo_" title="pydrake.multibody.plant.HydroelasticContactInfo_"><span class="pre">pydrake.multibody.plant.HydroelasticContactInfo_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.ContactResults_-AutoDiffXd-.hydroelastic_contact_info" title="Permalink to this definition"></a></dt>
<dd><p>Retrieves the ith HydroelasticContactInfo instance. The input index i
must be in the range [0, <code class="docutils literal notranslate"><span class="pre">num_hydroelastic_contacts()</span></code>) or this
method throws.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ContactResults_-AutoDiffXd-.num_hydroelastic_contacts">
<span id="pydrake.multibody.plant.ContactResults_[AutoDiffXd].num_hydroelastic_contacts"></span><span class="sig-name descname"><span class="pre">num_hydroelastic_contacts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.ContactResults_" title="pydrake.multibody.plant.ContactResults_"><span class="pre">pydrake.multibody.plant.ContactResults_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.ContactResults_-AutoDiffXd-.num_hydroelastic_contacts" title="Permalink to this definition"></a></dt>
<dd><p>Returns the number of hydroelastic contacts.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ContactResults_-AutoDiffXd-.num_point_pair_contacts">
<span id="pydrake.multibody.plant.ContactResults_[AutoDiffXd].num_point_pair_contacts"></span><span class="sig-name descname"><span class="pre">num_point_pair_contacts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.ContactResults_" title="pydrake.multibody.plant.ContactResults_"><span class="pre">pydrake.multibody.plant.ContactResults_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.ContactResults_-AutoDiffXd-.num_point_pair_contacts" title="Permalink to this definition"></a></dt>
<dd><p>Returns the number of point pair contacts.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ContactResults_-AutoDiffXd-.plant">
<span id="pydrake.multibody.plant.ContactResults_[AutoDiffXd].plant"></span><span class="sig-name descname"><span class="pre">plant</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.ContactResults_" title="pydrake.multibody.plant.ContactResults_"><span class="pre">pydrake.multibody.plant.ContactResults_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">drake::multibody::MultibodyPlant&lt;Eigen::AutoDiffScalar&lt;Eigen::Matrix&lt;double,</span> <span class="pre">-1,</span> <span class="pre">1,</span> <span class="pre">0,</span> <span class="pre">-1,</span> <span class="pre">1&gt;</span> <span class="pre">&gt;</span> <span class="pre">&gt;</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.ContactResults_-AutoDiffXd-.plant" title="Permalink to this definition"></a></dt>
<dd><p>Returns the plant that produced these contact results. In most cases
the result will be non-null, but default-constructed results might
have nulls.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ContactResults_-AutoDiffXd-.point_pair_contact_info">
<span id="pydrake.multibody.plant.ContactResults_[AutoDiffXd].point_pair_contact_info"></span><span class="sig-name descname"><span class="pre">point_pair_contact_info</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.ContactResults_" title="pydrake.multibody.plant.ContactResults_"><span class="pre">pydrake.multibody.plant.ContactResults_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.multibody.plant.PointPairContactInfo_" title="pydrake.multibody.plant.PointPairContactInfo_"><span class="pre">pydrake.multibody.plant.PointPairContactInfo_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.ContactResults_-AutoDiffXd-.point_pair_contact_info" title="Permalink to this definition"></a></dt>
<dd><p>Retrieves the ith PointPairContactInfo instance. The input index i
must be in the range [0, <code class="docutils literal notranslate"><span class="pre">num_point_pair_contacts()</span></code>) or this method
throws.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ContactResults_-AutoDiffXd-.SelectHydroelastic">
<span id="pydrake.multibody.plant.ContactResults_[AutoDiffXd].SelectHydroelastic"></span><span class="sig-name descname"><span class="pre">SelectHydroelastic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.ContactResults_" title="pydrake.multibody.plant.ContactResults_"><span class="pre">pydrake.multibody.plant.ContactResults_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">selector</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#pydrake.multibody.plant.HydroelasticContactInfo_" title="pydrake.multibody.plant.HydroelasticContactInfo_"><span class="pre">pydrake.multibody.plant.HydroelasticContactInfo_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">bool</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.multibody.plant.ContactResults_" title="pydrake.multibody.plant.ContactResults_"><span class="pre">pydrake.multibody.plant.ContactResults_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.ContactResults_-AutoDiffXd-.SelectHydroelastic" title="Permalink to this definition"></a></dt>
<dd><p>Returns ContactResults with only HydroelasticContactInfo instances
satisfying the selection criterion and with all PointPairContactInfo
instances.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">selector</span></code>:</dt><dd><p>Boolean predicate that returns true to select which
HydroelasticContactInfo.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It uses deep copy.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ContactResults_-Expression">
<span id="pydrake.multibody.plant.ContactResults_[Expression]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">ContactResults_[Expression]</span></span><a class="headerlink" href="#pydrake.multibody.plant.ContactResults_-Expression" title="Permalink to this definition"></a></dt>
<dd><p>A container class storing the contact results information for each
contact pair for a given state of the simulation. Note that copying
this data structure is expensive when <code class="docutils literal notranslate"><span class="pre">num_hydroelastic_contacts()</span> <span class="pre">&gt;</span>
<span class="pre">0</span></code> because a deep copy is performed.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ContactResults_-Expression-.__init__">
<span id="pydrake.multibody.plant.ContactResults_[Expression].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.ContactResults_" title="pydrake.multibody.plant.ContactResults_"><span class="pre">pydrake.multibody.plant.ContactResults_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.ContactResults_-Expression-.__init__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ContactResults_-Expression-.hydroelastic_contact_info">
<span id="pydrake.multibody.plant.ContactResults_[Expression].hydroelastic_contact_info"></span><span class="sig-name descname"><span class="pre">hydroelastic_contact_info</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.ContactResults_" title="pydrake.multibody.plant.ContactResults_"><span class="pre">pydrake.multibody.plant.ContactResults_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.multibody.plant.HydroelasticContactInfo_" title="pydrake.multibody.plant.HydroelasticContactInfo_"><span class="pre">pydrake.multibody.plant.HydroelasticContactInfo_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.ContactResults_-Expression-.hydroelastic_contact_info" title="Permalink to this definition"></a></dt>
<dd><p>Retrieves the ith HydroelasticContactInfo instance. The input index i
must be in the range [0, <code class="docutils literal notranslate"><span class="pre">num_hydroelastic_contacts()</span></code>) or this
method throws.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ContactResults_-Expression-.num_hydroelastic_contacts">
<span id="pydrake.multibody.plant.ContactResults_[Expression].num_hydroelastic_contacts"></span><span class="sig-name descname"><span class="pre">num_hydroelastic_contacts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.ContactResults_" title="pydrake.multibody.plant.ContactResults_"><span class="pre">pydrake.multibody.plant.ContactResults_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.ContactResults_-Expression-.num_hydroelastic_contacts" title="Permalink to this definition"></a></dt>
<dd><p>Returns the number of hydroelastic contacts.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ContactResults_-Expression-.num_point_pair_contacts">
<span id="pydrake.multibody.plant.ContactResults_[Expression].num_point_pair_contacts"></span><span class="sig-name descname"><span class="pre">num_point_pair_contacts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.ContactResults_" title="pydrake.multibody.plant.ContactResults_"><span class="pre">pydrake.multibody.plant.ContactResults_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.ContactResults_-Expression-.num_point_pair_contacts" title="Permalink to this definition"></a></dt>
<dd><p>Returns the number of point pair contacts.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ContactResults_-Expression-.plant">
<span id="pydrake.multibody.plant.ContactResults_[Expression].plant"></span><span class="sig-name descname"><span class="pre">plant</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.ContactResults_" title="pydrake.multibody.plant.ContactResults_"><span class="pre">pydrake.multibody.plant.ContactResults_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">drake::multibody::MultibodyPlant&lt;drake::symbolic::Expression&gt;</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.ContactResults_-Expression-.plant" title="Permalink to this definition"></a></dt>
<dd><p>Returns the plant that produced these contact results. In most cases
the result will be non-null, but default-constructed results might
have nulls.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ContactResults_-Expression-.point_pair_contact_info">
<span id="pydrake.multibody.plant.ContactResults_[Expression].point_pair_contact_info"></span><span class="sig-name descname"><span class="pre">point_pair_contact_info</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.ContactResults_" title="pydrake.multibody.plant.ContactResults_"><span class="pre">pydrake.multibody.plant.ContactResults_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.multibody.plant.PointPairContactInfo_" title="pydrake.multibody.plant.PointPairContactInfo_"><span class="pre">pydrake.multibody.plant.PointPairContactInfo_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.ContactResults_-Expression-.point_pair_contact_info" title="Permalink to this definition"></a></dt>
<dd><p>Retrieves the ith PointPairContactInfo instance. The input index i
must be in the range [0, <code class="docutils literal notranslate"><span class="pre">num_point_pair_contacts()</span></code>) or this method
throws.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ContactResults_-Expression-.SelectHydroelastic">
<span id="pydrake.multibody.plant.ContactResults_[Expression].SelectHydroelastic"></span><span class="sig-name descname"><span class="pre">SelectHydroelastic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.ContactResults_" title="pydrake.multibody.plant.ContactResults_"><span class="pre">pydrake.multibody.plant.ContactResults_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">selector</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#pydrake.multibody.plant.HydroelasticContactInfo_" title="pydrake.multibody.plant.HydroelasticContactInfo_"><span class="pre">pydrake.multibody.plant.HydroelasticContactInfo_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">bool</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.multibody.plant.ContactResults_" title="pydrake.multibody.plant.ContactResults_"><span class="pre">pydrake.multibody.plant.ContactResults_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.ContactResults_-Expression-.SelectHydroelastic" title="Permalink to this definition"></a></dt>
<dd><p>Returns ContactResults with only HydroelasticContactInfo instances
satisfying the selection criterion and with all PointPairContactInfo
instances.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">selector</span></code>:</dt><dd><p>Boolean predicate that returns true to select which
HydroelasticContactInfo.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It uses deep copy.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ContactResultsToLcmSystem">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">ContactResultsToLcmSystem</span></span><a class="headerlink" href="#pydrake.multibody.plant.ContactResultsToLcmSystem" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.LeafSystem" title="pydrake.systems.framework.LeafSystem"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem</span></code></a></p>
<p>A System that encodes ContactResults into a
lcmt_contact_results_for_viz message. It has a single input port with
type ContactResults&lt;T&gt; and a single output port with
lcmt_contact_results_for_viz.</p>
<p>Although this class can be instantiated on all default scalars, its
functionality will be limited for <code class="docutils literal notranslate"><span class="pre">T</span></code> = symbolic::Expression. If
there are any symbolic::Variable instances in the expression,
attempting to evaluate the output port will throw an exception. The
support is sufficient that a systems::Diagram with a
ContactResultsToLcmSystem can be scalar converted to
symbolic::Expression without error, but not necessarily evaluated.</p>
<p><strong>Constructing instances</strong></p>
<p>Generally, you shouldn’t construct ContactResultsToLcmSystem instances
directly. We recommend using one of the overloaded
contact_result_vis_creation “ConnectContactResultsToDrakeVisualizer()”
functions to add contact visualization to your diagram.</p>
<p><strong>How contacts are described in visualization</strong></p>
<p>In the visualizer, each contact between two bodies is uniquely
characterized by two triples of names: (model instance name, body
name, geometry name). These triples help distinguish contacts which
might otherwise be ambiguous (e.g., contact with two bodies, both
called “box” but part of different model instances).</p>
<p>ContactResultsToLcmSystem gets the model instance and body names from
an instance of MultibodyPlant, but <em>geometry</em> names are not available
from the plant. By default, ContactResultsToLcmSystem will <em>generate</em>
a unique name based on a geometry’s unique id (e.g., “Id(7)”). For
many applications (those cases where each body has only a single
collision geometry), this is perfectly acceptable. However, in cases
where a body has multiple collision geometries, those default names
may not be helpful when viewing the visualized results. Instead,
ContactResultsToLcmSystem can use the names associated with the id in
a geometry::SceneGraph instance. The only method for doing this is via
the contact_result_vis_creation
“ConnectContactResultsToDrakeVisualizer()” functions and requires the
diagram to be instantiated as double valued. If a diagram with a
different scalar type is required, it should subsequently be scalar
converted.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">u0&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>ContactResultsToLcmSystem</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y0</td></tr></table></td></tr></table><dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ContactResultsToLcmSystem.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self:</span> <span class="pre">pydrake.multibody.plant.ContactResultsToLcmSystem</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plant:</span> <span class="pre">drake::multibody::MultibodyPlant&lt;double&gt;</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.ContactResultsToLcmSystem.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Constructs an instance with <em>default</em> geometry names (e.g., “Id(7)”).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">plant</span></code>:</dt><dd><p>The MultibodyPlant that the ContactResults are generated from.</p>
</dd>
<dt>Precondition:</dt><dd><p>The <code class="docutils literal notranslate"><span class="pre">plant</span></code> parameter (or a fully equivalent plant) connects to
<code class="docutils literal notranslate"><span class="pre">this</span></code> system’s input port.</p>
</dd>
<dt>Precondition:</dt><dd><p>The <code class="docutils literal notranslate"><span class="pre">plant</span></code> parameter is finalized.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ContactResultsToLcmSystem.get_contact_result_input_port">
<span class="sig-name descname"><span class="pre">get_contact_result_input_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.ContactResultsToLcmSystem" title="pydrake.multibody.plant.ContactResultsToLcmSystem"><span class="pre">pydrake.multibody.plant.ContactResultsToLcmSystem</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.InputPort" title="pydrake.systems.framework.InputPort"><span class="pre">pydrake.systems.framework.InputPort</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.ContactResultsToLcmSystem.get_contact_result_input_port" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ContactResultsToLcmSystem.get_lcm_message_output_port">
<span class="sig-name descname"><span class="pre">get_lcm_message_output_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.ContactResultsToLcmSystem" title="pydrake.multibody.plant.ContactResultsToLcmSystem"><span class="pre">pydrake.multibody.plant.ContactResultsToLcmSystem</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.OutputPort" title="pydrake.systems.framework.OutputPort"><span class="pre">pydrake.systems.framework.OutputPort</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.ContactResultsToLcmSystem.get_lcm_message_output_port" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.multibody.plant.CoulombFriction">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">CoulombFriction</span></span><a class="headerlink" href="#pydrake.multibody.plant.CoulombFriction" title="Permalink to this definition"></a></dt>
<dd><p>Parameters for Coulomb’s Law of Friction, namely:</p>
<ul class="simple">
<li><p>Static friction coefficient, for a pair of surfaces at rest relative to
each other.</p></li>
<li><p>Dynamic (or kinematic) friction coefficient, for a pair of surfaces in
relative motion.</p></li>
</ul>
<p>These coefficients are an empirical property characterizing the
interaction by friction between a pair of contacting surfaces.
Friction coefficients depend upon the mechanical properties of the
surfaces’ materials and on the roughness of the surfaces. They are
determined experimentally.</p>
<p>Even though the Coulomb’s law coefficients of friction characterize a
pair of surfaces interacting by friction, we associate the abstract
<strong>idea</strong> of friction coefficients to a single surface by considering
the coefficients for contact between two identical surfaces. For this
case of two identical surfaces, the friction coefficients that
describe the surface pair are taken to equal those of one of the
identical surfaces. We extend this idea to the case of different
surfaces by defining a <strong>combination law</strong> that allow us to obtain the
Coulomb’s law coefficients of friction characterizing the pair of
surfaces, given the individual friction coefficients of each surface.
We would like this <strong>combination law</strong> to satisfy:</p>
<ul class="simple">
<li><p>The friction coefficient of two identical surfaces is the friction
coefficient of one of the surfaces.</p></li>
<li><p>The combination law is commutative. That is, surface A combined with
surface B gives the same results as surface B combined with surface A.</p></li>
<li><p>For two surfaces M and N with very different friction coefficients, say
<code class="docutils literal notranslate"><span class="pre">μₘ</span> <span class="pre">≪</span> <span class="pre">μₙ</span></code>, the combined friction coefficient should be in the order of
magnitude of the smallest friction coefficient (in the example μₘ). To
understand this requirement, consider rubber (high friction coefficient)
sliding on ice (low friction coefficient). We’d like the surface pair
to be defined by a friction coefficient close to that of ice, since rubber
will easily slide on ice.</p></li>
</ul>
<p>These requirements are met by the following ad-hoc combination law:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">μ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="n">μₘμₙ</span><span class="o">/</span><span class="p">(</span><span class="n">μₘ</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">μₙ</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
</details><p>See CalcContactFrictionFromSurfaceProperties(), which implements this
law. More complex combination laws could also be a function of other
parameters such as the mechanical properties of the interacting
surfaces or even their roughnesses. For instance, if the rubber
surface above has metal studs (somehow making the surface “rougher”),
it will definitely have a better grip on an ice surface. Therefore
this new variable should be taken into account in the combination law.
Notice that in this example, this new combination law model for tires,
will have a different set of requirements from the ones stated above.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <a class="reference internal" href="#pydrake.multibody.plant.CoulombFriction_" title="pydrake.multibody.plant.CoulombFriction_"><code class="xref py py-class docutils literal notranslate"><span class="pre">CoulombFriction_</span></code></a>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.CoulombFriction.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.CoulombFriction.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.multibody.plant.CoulombFriction) -&gt; None</p></li>
</ol>
<p>Default constructor for a frictionless surface, i.e. with zero static
and dynamic coefficients of friction.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.multibody.plant.CoulombFriction, static_friction: float, dynamic_friction: float) -&gt; None</p></li>
</ol>
<p>Specifies both the static and dynamic friction coefficients for a
given surface.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if any of the friction coefficients are negative or</strong> – </p></li>
<li><p><strong>if dynamic_friction &gt; static_friction</strong><strong> (</strong><strong>they can be equal.</strong><strong>)</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.CoulombFriction.dynamic_friction">
<span class="sig-name descname"><span class="pre">dynamic_friction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.CoulombFriction" title="pydrake.multibody.plant.CoulombFriction"><span class="pre">pydrake.multibody.plant.CoulombFriction</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.CoulombFriction.dynamic_friction" title="Permalink to this definition"></a></dt>
<dd><p>Returns the coefficient of dynamic friction.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.CoulombFriction.static_friction">
<span class="sig-name descname"><span class="pre">static_friction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.CoulombFriction" title="pydrake.multibody.plant.CoulombFriction"><span class="pre">pydrake.multibody.plant.CoulombFriction</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.CoulombFriction.static_friction" title="Permalink to this definition"></a></dt>
<dd><p>Returns the coefficient of static friction.</p>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py" id="pydrake.multibody.plant.CoulombFriction_">
<em class="property"><span class="pre">template</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">CoulombFriction_</span></span><a class="headerlink" href="#pydrake.multibody.plant.CoulombFriction_" title="Permalink to this definition"></a></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">CoulombFriction_[float]</span></code>, <a class="reference internal" href="#pydrake.multibody.plant.CoulombFriction_-AutoDiffXd" title="pydrake.multibody.plant.CoulombFriction_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">CoulombFriction_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.plant.CoulombFriction_-Expression" title="pydrake.multibody.plant.CoulombFriction_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">CoulombFriction_[Expression]</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.multibody.plant.CoulombFriction_-AutoDiffXd">
<span id="pydrake.multibody.plant.CoulombFriction_[AutoDiffXd]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">CoulombFriction_[AutoDiffXd]</span></span><a class="headerlink" href="#pydrake.multibody.plant.CoulombFriction_-AutoDiffXd" title="Permalink to this definition"></a></dt>
<dd><p>Parameters for Coulomb’s Law of Friction, namely:</p>
<ul class="simple">
<li><p>Static friction coefficient, for a pair of surfaces at rest relative to
each other.</p></li>
<li><p>Dynamic (or kinematic) friction coefficient, for a pair of surfaces in
relative motion.</p></li>
</ul>
<p>These coefficients are an empirical property characterizing the
interaction by friction between a pair of contacting surfaces.
Friction coefficients depend upon the mechanical properties of the
surfaces’ materials and on the roughness of the surfaces. They are
determined experimentally.</p>
<p>Even though the Coulomb’s law coefficients of friction characterize a
pair of surfaces interacting by friction, we associate the abstract
<strong>idea</strong> of friction coefficients to a single surface by considering
the coefficients for contact between two identical surfaces. For this
case of two identical surfaces, the friction coefficients that
describe the surface pair are taken to equal those of one of the
identical surfaces. We extend this idea to the case of different
surfaces by defining a <strong>combination law</strong> that allow us to obtain the
Coulomb’s law coefficients of friction characterizing the pair of
surfaces, given the individual friction coefficients of each surface.
We would like this <strong>combination law</strong> to satisfy:</p>
<ul class="simple">
<li><p>The friction coefficient of two identical surfaces is the friction
coefficient of one of the surfaces.</p></li>
<li><p>The combination law is commutative. That is, surface A combined with
surface B gives the same results as surface B combined with surface A.</p></li>
<li><p>For two surfaces M and N with very different friction coefficients, say
<code class="docutils literal notranslate"><span class="pre">μₘ</span> <span class="pre">≪</span> <span class="pre">μₙ</span></code>, the combined friction coefficient should be in the order of
magnitude of the smallest friction coefficient (in the example μₘ). To
understand this requirement, consider rubber (high friction coefficient)
sliding on ice (low friction coefficient). We’d like the surface pair
to be defined by a friction coefficient close to that of ice, since rubber
will easily slide on ice.</p></li>
</ul>
<p>These requirements are met by the following ad-hoc combination law:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">μ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="n">μₘμₙ</span><span class="o">/</span><span class="p">(</span><span class="n">μₘ</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">μₙ</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
</details><p>See CalcContactFrictionFromSurfaceProperties(), which implements this
law. More complex combination laws could also be a function of other
parameters such as the mechanical properties of the interacting
surfaces or even their roughnesses. For instance, if the rubber
surface above has metal studs (somehow making the surface “rougher”),
it will definitely have a better grip on an ice surface. Therefore
this new variable should be taken into account in the combination law.
Notice that in this example, this new combination law model for tires,
will have a different set of requirements from the ones stated above.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.CoulombFriction_-AutoDiffXd-.__init__">
<span id="pydrake.multibody.plant.CoulombFriction_[AutoDiffXd].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.CoulombFriction_-AutoDiffXd-.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.multibody.plant.CoulombFriction_[AutoDiffXd]) -&gt; None</p></li>
</ol>
<p>Default constructor for a frictionless surface, i.e. with zero static
and dynamic coefficients of friction.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.multibody.plant.CoulombFriction_[AutoDiffXd], static_friction: pydrake.autodiffutils.AutoDiffXd, dynamic_friction: pydrake.autodiffutils.AutoDiffXd) -&gt; None</p></li>
</ol>
<p>Specifies both the static and dynamic friction coefficients for a
given surface.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if any of the friction coefficients are negative or</strong> – </p></li>
<li><p><strong>if dynamic_friction &gt; static_friction</strong><strong> (</strong><strong>they can be equal.</strong><strong>)</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.CoulombFriction_-AutoDiffXd-.dynamic_friction">
<span id="pydrake.multibody.plant.CoulombFriction_[AutoDiffXd].dynamic_friction"></span><span class="sig-name descname"><span class="pre">dynamic_friction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.CoulombFriction_" title="pydrake.multibody.plant.CoulombFriction_"><span class="pre">pydrake.multibody.plant.CoulombFriction_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">pydrake.autodiffutils.AutoDiffXd</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.CoulombFriction_-AutoDiffXd-.dynamic_friction" title="Permalink to this definition"></a></dt>
<dd><p>Returns the coefficient of dynamic friction.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.CoulombFriction_-AutoDiffXd-.static_friction">
<span id="pydrake.multibody.plant.CoulombFriction_[AutoDiffXd].static_friction"></span><span class="sig-name descname"><span class="pre">static_friction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.CoulombFriction_" title="pydrake.multibody.plant.CoulombFriction_"><span class="pre">pydrake.multibody.plant.CoulombFriction_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">pydrake.autodiffutils.AutoDiffXd</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.CoulombFriction_-AutoDiffXd-.static_friction" title="Permalink to this definition"></a></dt>
<dd><p>Returns the coefficient of static friction.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.multibody.plant.CoulombFriction_-Expression">
<span id="pydrake.multibody.plant.CoulombFriction_[Expression]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">CoulombFriction_[Expression]</span></span><a class="headerlink" href="#pydrake.multibody.plant.CoulombFriction_-Expression" title="Permalink to this definition"></a></dt>
<dd><p>Parameters for Coulomb’s Law of Friction, namely:</p>
<ul class="simple">
<li><p>Static friction coefficient, for a pair of surfaces at rest relative to
each other.</p></li>
<li><p>Dynamic (or kinematic) friction coefficient, for a pair of surfaces in
relative motion.</p></li>
</ul>
<p>These coefficients are an empirical property characterizing the
interaction by friction between a pair of contacting surfaces.
Friction coefficients depend upon the mechanical properties of the
surfaces’ materials and on the roughness of the surfaces. They are
determined experimentally.</p>
<p>Even though the Coulomb’s law coefficients of friction characterize a
pair of surfaces interacting by friction, we associate the abstract
<strong>idea</strong> of friction coefficients to a single surface by considering
the coefficients for contact between two identical surfaces. For this
case of two identical surfaces, the friction coefficients that
describe the surface pair are taken to equal those of one of the
identical surfaces. We extend this idea to the case of different
surfaces by defining a <strong>combination law</strong> that allow us to obtain the
Coulomb’s law coefficients of friction characterizing the pair of
surfaces, given the individual friction coefficients of each surface.
We would like this <strong>combination law</strong> to satisfy:</p>
<ul class="simple">
<li><p>The friction coefficient of two identical surfaces is the friction
coefficient of one of the surfaces.</p></li>
<li><p>The combination law is commutative. That is, surface A combined with
surface B gives the same results as surface B combined with surface A.</p></li>
<li><p>For two surfaces M and N with very different friction coefficients, say
<code class="docutils literal notranslate"><span class="pre">μₘ</span> <span class="pre">≪</span> <span class="pre">μₙ</span></code>, the combined friction coefficient should be in the order of
magnitude of the smallest friction coefficient (in the example μₘ). To
understand this requirement, consider rubber (high friction coefficient)
sliding on ice (low friction coefficient). We’d like the surface pair
to be defined by a friction coefficient close to that of ice, since rubber
will easily slide on ice.</p></li>
</ul>
<p>These requirements are met by the following ad-hoc combination law:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">μ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="n">μₘμₙ</span><span class="o">/</span><span class="p">(</span><span class="n">μₘ</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">μₙ</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
</details><p>See CalcContactFrictionFromSurfaceProperties(), which implements this
law. More complex combination laws could also be a function of other
parameters such as the mechanical properties of the interacting
surfaces or even their roughnesses. For instance, if the rubber
surface above has metal studs (somehow making the surface “rougher”),
it will definitely have a better grip on an ice surface. Therefore
this new variable should be taken into account in the combination law.
Notice that in this example, this new combination law model for tires,
will have a different set of requirements from the ones stated above.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.CoulombFriction_-Expression-.__init__">
<span id="pydrake.multibody.plant.CoulombFriction_[Expression].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.CoulombFriction_-Expression-.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.multibody.plant.CoulombFriction_[Expression]) -&gt; None</p></li>
</ol>
<p>Default constructor for a frictionless surface, i.e. with zero static
and dynamic coefficients of friction.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.multibody.plant.CoulombFriction_[Expression], static_friction: pydrake.symbolic.Expression, dynamic_friction: pydrake.symbolic.Expression) -&gt; None</p></li>
</ol>
<p>Specifies both the static and dynamic friction coefficients for a
given surface.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if any of the friction coefficients are negative or</strong> – </p></li>
<li><p><strong>if dynamic_friction &gt; static_friction</strong><strong> (</strong><strong>they can be equal.</strong><strong>)</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.CoulombFriction_-Expression-.dynamic_friction">
<span id="pydrake.multibody.plant.CoulombFriction_[Expression].dynamic_friction"></span><span class="sig-name descname"><span class="pre">dynamic_friction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.CoulombFriction_" title="pydrake.multibody.plant.CoulombFriction_"><span class="pre">pydrake.multibody.plant.CoulombFriction_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">pydrake.symbolic.Expression</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.CoulombFriction_-Expression-.dynamic_friction" title="Permalink to this definition"></a></dt>
<dd><p>Returns the coefficient of dynamic friction.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.CoulombFriction_-Expression-.static_friction">
<span id="pydrake.multibody.plant.CoulombFriction_[Expression].static_friction"></span><span class="sig-name descname"><span class="pre">static_friction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.CoulombFriction_" title="pydrake.multibody.plant.CoulombFriction_"><span class="pre">pydrake.multibody.plant.CoulombFriction_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">pydrake.symbolic.Expression</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.CoulombFriction_-Expression-.static_friction" title="Permalink to this definition"></a></dt>
<dd><p>Returns the coefficient of static friction.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.multibody.plant.DeformableBodyId">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">DeformableBodyId</span></span><a class="headerlink" href="#pydrake.multibody.plant.DeformableBodyId" title="Permalink to this definition"></a></dt>
<dd><p>Uniquely identifies a deformable body. It is valid before and after
Finalize().</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.DeformableBodyId.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.DeformableBodyId.__init__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.DeformableBodyId.get_new_id">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">get_new_id</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.multibody.plant.DeformableBodyId" title="pydrake.multibody.plant.DeformableBodyId"><span class="pre">pydrake.multibody.plant.DeformableBodyId</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.DeformableBodyId.get_new_id" title="Permalink to this definition"></a></dt>
<dd><p>Generates a new identifier for this id type. This new identifier will
be different from all previous identifiers created. This method does
<em>not</em> make any guarantees about the values of ids from successive
invocations. This method is guaranteed to be thread safe.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.DeformableBodyId.get_value">
<span class="sig-name descname"><span class="pre">get_value</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.DeformableBodyId" title="pydrake.multibody.plant.DeformableBodyId"><span class="pre">pydrake.multibody.plant.DeformableBodyId</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.DeformableBodyId.get_value" title="Permalink to this definition"></a></dt>
<dd><p>Extracts the underlying representation from the identifier. This is
considered invalid for invalid ids and is strictly enforced in Debug
builds.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.DeformableBodyId.is_valid">
<span class="sig-name descname"><span class="pre">is_valid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.DeformableBodyId" title="pydrake.multibody.plant.DeformableBodyId"><span class="pre">pydrake.multibody.plant.DeformableBodyId</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.DeformableBodyId.is_valid" title="Permalink to this definition"></a></dt>
<dd><p>Reports if the id is valid.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.multibody.plant.DeformableModel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">DeformableModel</span></span><a class="headerlink" href="#pydrake.multibody.plant.DeformableModel" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.plant.PhysicalModel" title="pydrake.multibody.plant.PhysicalModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.plant.PhysicalModel</span></code></a></p>
<p>DeformableModel implements the interface in PhysicalModel and provides
the functionalities to specify deformable bodies. Unlike rigid bodies,
the shape of deformable bodies can change in a simulation. Each
deformable body is modeled as a volumetric mesh with persisting
topology, changing vertex positions, and an approximated signed
distance field. A finite element model is built for each registered
deformable body that is used to evaluate the dynamics of the body.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This feature is considered to be <strong>experimental</strong> and may change
or be removed at any time, without any deprecation notice ahead of
time.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.DeformableModel.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self:</span> <span class="pre">pydrake.multibody.plant.DeformableModel</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg0:</span> <span class="pre">drake::multibody::MultibodyPlant&lt;double&gt;</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.DeformableModel.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Constructs a DeformableModel to be owned by the given MultibodyPlant.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>plant != nullptr.</p>
</dd>
<dt>Precondition:</dt><dd><p>Finalize() has not been called on <code class="docutils literal notranslate"><span class="pre">plant</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.DeformableModel.GetBodyId">
<span class="sig-name descname"><span class="pre">GetBodyId</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.DeformableModel" title="pydrake.multibody.plant.DeformableModel"><span class="pre">pydrake.multibody.plant.DeformableModel</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">geometry_id</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.GeometryId" title="pydrake.geometry.GeometryId"><span class="pre">pydrake.geometry.GeometryId</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">drake::Identifier&lt;drake::multibody::DeformableBodyTag&gt;</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.DeformableModel.GetBodyId" title="Permalink to this definition"></a></dt>
<dd><p>Returns the DeformableBodyId associated with the given
<code class="docutils literal notranslate"><span class="pre">geometry_id</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the given geometry_id does not correspond to a</strong> – </p></li>
<li><p><strong>deformable body registered with this model.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.DeformableModel.GetDiscreteStateIndex">
<span class="sig-name descname"><span class="pre">GetDiscreteStateIndex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self:</span> <span class="pre">pydrake.multibody.plant.DeformableModel</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">id:</span> <span class="pre">drake::Identifier&lt;drake::multibody::DeformableBodyTag&gt;</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.DiscreteStateIndex" title="pydrake.systems.framework.DiscreteStateIndex"><span class="pre">pydrake.systems.framework.DiscreteStateIndex</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.DeformableModel.GetDiscreteStateIndex" title="Permalink to this definition"></a></dt>
<dd><p>Returns the discrete state index of the deformable body identified by
the given <code class="docutils literal notranslate"><span class="pre">id</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if MultibodyPlant::Finalize</strong><strong>(</strong><strong>) </strong><strong>has not been called</strong> – </p></li>
<li><p><strong>yet.</strong><strong> or </strong><strong>if no deformable body with the given id has been</strong> – </p></li>
<li><p><strong>registered in this model.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.DeformableModel.GetGeometryId">
<span class="sig-name descname"><span class="pre">GetGeometryId</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self:</span> <span class="pre">pydrake.multibody.plant.DeformableModel</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">id:</span> <span class="pre">drake::Identifier&lt;drake::multibody::DeformableBodyTag&gt;</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.GeometryId" title="pydrake.geometry.GeometryId"><span class="pre">pydrake.geometry.GeometryId</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.DeformableModel.GetGeometryId" title="Permalink to this definition"></a></dt>
<dd><p>Returns the GeometryId of the geometry associated with the body with
the given <code class="docutils literal notranslate"><span class="pre">id</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if no body with the given id has been registered.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.DeformableModel.GetReferencePositions">
<span class="sig-name descname"><span class="pre">GetReferencePositions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self:</span> <span class="pre">pydrake.multibody.plant.DeformableModel</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">id:</span> <span class="pre">drake::Identifier&lt;drake::multibody::DeformableBodyTag&gt;</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.DeformableModel.GetReferencePositions" title="Permalink to this definition"></a></dt>
<dd><p>Returns the reference positions of the vertices of the deformable body
identified by the given <code class="docutils literal notranslate"><span class="pre">id</span></code>. The reference positions are
represented as a VectorX with 3N values where N is the number of
vertices. The x-, y-, and z-positions (measured and expressed in the
world frame) of the j-th vertex are 3j, 3j + 1, and 3j + 2 in the
VectorX.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if no deformable body with the given id has been</strong> – </p></li>
<li><p><strong>registered in this model.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.DeformableModel.num_bodies">
<span class="sig-name descname"><span class="pre">num_bodies</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.DeformableModel" title="pydrake.multibody.plant.DeformableModel"><span class="pre">pydrake.multibody.plant.DeformableModel</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.DeformableModel.num_bodies" title="Permalink to this definition"></a></dt>
<dd><p>Returns the number of deformable bodies registered with this
DeformableModel.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.DeformableModel.RegisterDeformableBody">
<span class="sig-name descname"><span class="pre">RegisterDeformableBody</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self:</span> <span class="pre">pydrake.multibody.plant.DeformableModel</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">geometry_instance:</span> <span class="pre">pydrake.geometry.GeometryInstance</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">config:</span> <span class="pre">drake::multibody::fem::DeformableBodyConfig&lt;double&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">resolution_hint:</span> <span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">drake::Identifier&lt;drake::multibody::DeformableBodyTag&gt;</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.DeformableModel.RegisterDeformableBody" title="Permalink to this definition"></a></dt>
<dd><p>Registers a deformable body in <code class="docutils literal notranslate"><span class="pre">this</span></code> DeformableModel with the given
GeometryInstance. The body is represented in the world frame and
simulated with FEM with linear elements and a first order quadrature
rule that integrates linear functions exactly. See FemModel for
details. Returns a unique identifier for the added geometry.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">geometry_instance</span></code>:</dt><dd><p>The geometry to be registered with the model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">config</span></code>:</dt><dd><p>The physical properties of deformable body.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">resolution_hint</span></code>:</dt><dd><p>The parameter that guides the level of mesh refinement of the
deformable geometry. It has length units (in meters) and roughly
corresponds to a typical edge length in the resulting mesh for a
primitive shape.</p>
</dd>
<dt>Precondition:</dt><dd><p>resolution_hint &gt; 0.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if this DeformableModel is not of scalar type</strong> – </p></li>
<li><p><strong>double.</strong> – </p></li>
<li><p><strong>RuntimeError if Finalize</strong><strong>(</strong><strong>) </strong><strong>has been called on the multibody plant</strong> – </p></li>
<li><p><strong>owning this deformable model.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.DeformableModel.SetWallBoundaryCondition">
<span class="sig-name descname"><span class="pre">SetWallBoundaryCondition</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">self:</span> <span class="pre">pydrake.multibody.plant.DeformableModel,</span> <span class="pre">id:</span> <span class="pre">drake::Identifier&lt;drake::multibody::DeformableBodyTag&gt;,</span> <span class="pre">p_WQ:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]],</span> <span class="pre">n_W:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]]</span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.DeformableModel.SetWallBoundaryCondition" title="Permalink to this definition"></a></dt>
<dd><p>Sets wall boundary conditions for the body with the given <code class="docutils literal notranslate"><span class="pre">id</span></code>. All
vertices of the mesh of the deformable body whose reference positions
are inside the prescribed open half space are put under zero
displacement boundary conditions. The open half space is defined by a
plane with outward normal n_W. A vertex V is considered to be subject
to the boundary condition if n̂ ⋅ p_QV &lt; 0 where Q is a point on the
plane and n̂ is normalized n_W.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">id</span></code>:</dt><dd><p>The body to be put under boundary condition.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_WQ</span></code>:</dt><dd><p>The position of a point Q on the plane in the world frame.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">n_W</span></code>:</dt><dd><p>Outward normal to the half space expressed in the world frame.</p>
</dd>
<dt>Precondition:</dt><dd><p>n_W.norm() &gt; 1e-10.</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Be aware of round-off errors in floating computations when placing
a vertex very close to the plane defining the half space.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if Finalize</strong><strong>(</strong><strong>) </strong><strong>has been called on the multibody plant</strong> – </p></li>
<li><p><strong>owning this deformable model</strong><strong> or </strong><strong>if no deformable body with the</strong> – </p></li>
<li><p><strong>given id has been registered in this model.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.multibody.plant.DiscreteContactApproximation">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">DiscreteContactApproximation</span></span><a class="headerlink" href="#pydrake.multibody.plant.DiscreteContactApproximation" title="Permalink to this definition"></a></dt>
<dd><p>The type of the contact approximation used for a discrete
MultibodyPlant model.</p>
<p>kTamsi, kSimilar and kLagged are all approximations to the same
contact model – Compliant contact with regularized friction, refer to
mbp_contact_modeling “Contact Modeling” for further details. The key
difference however, is that the kSimilar and kLagged approximations
are convex and therefore our contact solver has both theoretical and
practical convergence guarantees — the solver will always succeed.
Conversely, being non-convex, kTamsi can fail to find a solution.</p>
<p>kSap is also a convex model of compliant contact with regularized
friction. There are a couple of key differences however: - Dissipation
is modeled using a linear Kelvin–Voigt model, parameterized by a
relaxation time constant. See accessing_contact_properties “contact
parameters”. - Unlike kTamsi, kSimilar and kLagged where
regularization of friction is parameterized by a stiction tolerance
(see set_stiction_tolerance()), SAP determines regularization
automatically solely based on numerics. Users have no control on the
amount of regularization.</p>
<p>How to choose an approximation</p>
<p>The Hunt &amp; Crossley model is based on physics, it is continuous and
has been experimentally validated. Therefore it is the preferred model
to capture the physics of contact.</p>
<p>Being approximations, kSap and kSimilar introduce a spurious effect of
“gliding” in sliding contact, see [Castro et al., 2023]. This artifact
is 𝒪(δt) but can be significant at large time steps and/or large slip
velocities. kLagged does not suffer from this, but introduces a “weak”
coupling of friction that can introduce non-negligible effects in the
dynamics during impacts or strong transients.</p>
<p>Summarizing, kLagged is the preferred approximation when strong
transients are not expected or don’t need to be accurately resolved.
If strong transients do need to be accurately resolved (unusual for
robotics applications), kSimilar is the preferred approximation.</p>
<p class="rubric">References</p>
<ul class="simple">
<li><p>[Castro et al., 2019] Castro A., Qu A., Kuppuswamy N., Alspach A.,
Sherman M, 2019. A Transition-Aware Method for the Simulation of
Compliant Contact with Regularized Friction. Available online at
<a class="reference external" href="https://arxiv.org/abs/1909.05700">https://arxiv.org/abs/1909.05700</a>.</p></li>
<li><p>[Castro et al., 2022] Castro A., Permenter F. and Han X., 2022. An
Unconstrained Convex Formulation of Compliant Contact. Available online at
<a class="reference external" href="https://arxiv.org/abs/2110.10107">https://arxiv.org/abs/2110.10107</a>.</p></li>
<li><p>[Castro et al., 2023] Castro A., Han X., and Masterjohn J., 2023. A Theory
of Irrotational Contact Fields. Available online at
<a class="reference external" href="https://arxiv.org/abs/2312.03908">https://arxiv.org/abs/2312.03908</a></p></li>
</ul>
<p>Members:</p>
<blockquote>
<div><p>kTamsi : TAMSI solver approximation, see [Castro et al., 2019].</p>
<p>kSap : SAP solver model approximation, see [Castro et al., 2022].</p>
<p>kSimilar : Similarity approximation found in [Castro et al., 2023].</p>
<p>kLagged : Approximation in which the normal force is lagged in Coulomb’s law,</p>
</div></blockquote>
<p>such that ‖γₜ‖ ≤ μ γₙ₀, [Castro et al., 2023].</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.DiscreteContactApproximation.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.DiscreteContactApproximation" title="pydrake.multibody.plant.DiscreteContactApproximation"><span class="pre">pydrake.multibody.plant.DiscreteContactApproximation</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.DiscreteContactApproximation.__init__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pydrake.multibody.plant.DiscreteContactApproximation.kLagged">
<span class="sig-name descname"><span class="pre">kLagged</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;DiscreteContactApproximation.kLagged:</span> <span class="pre">3&gt;</span></em><a class="headerlink" href="#pydrake.multibody.plant.DiscreteContactApproximation.kLagged" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pydrake.multibody.plant.DiscreteContactApproximation.kSap">
<span class="sig-name descname"><span class="pre">kSap</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;DiscreteContactApproximation.kSap:</span> <span class="pre">1&gt;</span></em><a class="headerlink" href="#pydrake.multibody.plant.DiscreteContactApproximation.kSap" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pydrake.multibody.plant.DiscreteContactApproximation.kSimilar">
<span class="sig-name descname"><span class="pre">kSimilar</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;DiscreteContactApproximation.kSimilar:</span> <span class="pre">2&gt;</span></em><a class="headerlink" href="#pydrake.multibody.plant.DiscreteContactApproximation.kSimilar" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pydrake.multibody.plant.DiscreteContactApproximation.kTamsi">
<span class="sig-name descname"><span class="pre">kTamsi</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;DiscreteContactApproximation.kTamsi:</span> <span class="pre">0&gt;</span></em><a class="headerlink" href="#pydrake.multibody.plant.DiscreteContactApproximation.kTamsi" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.multibody.plant.DiscreteContactApproximation.name">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">name</span></span><a class="headerlink" href="#pydrake.multibody.plant.DiscreteContactApproximation.name" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.multibody.plant.DiscreteContactApproximation.value">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">value</span></span><a class="headerlink" href="#pydrake.multibody.plant.DiscreteContactApproximation.value" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.multibody.plant.DiscreteContactSolver">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">DiscreteContactSolver</span></span><a class="headerlink" href="#pydrake.multibody.plant.DiscreteContactSolver" title="Permalink to this definition"></a></dt>
<dd><p>The type of the contact solver used for a discrete MultibodyPlant
model.</p>
<p>Note: the SAP solver only fully supports scalar type <code class="docutils literal notranslate"><span class="pre">double</span></code>. For
scalar type <code class="docutils literal notranslate"><span class="pre">AutoDiffXd</span></code>, the SAP solver throws if any constraint
(including contact) is detected. As a consequence, one can only run
dynamic simulations without any constraints under the combination of
SAP and <code class="docutils literal notranslate"><span class="pre">AutoDiffXd</span></code>. The SAP solver does not support symbolic
calculations.</p>
<p class="rubric">References</p>
<ul class="simple">
<li><p>[Castro et al., 2019] Castro, A.M, Qu, A., Kuppuswamy, N., Alspach, A.,
Sherman, M.A., 2019. A Transition-Aware Method for the Simulation of
Compliant Contact with Regularized Friction. Available online at
<a class="reference external" href="https://arxiv.org/abs/1909.05700">https://arxiv.org/abs/1909.05700</a>.</p></li>
<li><p>[Castro et al., 2022] Castro A., Permenter F. and Han X., 2022. An
Unconstrained Convex Formulation of Compliant Contact. Available online at
<a class="reference external" href="https://arxiv.org/abs/2110.10107">https://arxiv.org/abs/2110.10107</a>.</p></li>
</ul>
<p>Members:</p>
<blockquote>
<div><p>kTamsi : TAMSI solver, see [Castro et al., 2019].</p>
<p>kSap : SAP solver, see [Castro et al., 2022].</p>
</div></blockquote>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.DiscreteContactSolver.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.DiscreteContactSolver" title="pydrake.multibody.plant.DiscreteContactSolver"><span class="pre">pydrake.multibody.plant.DiscreteContactSolver</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.DiscreteContactSolver.__init__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pydrake.multibody.plant.DiscreteContactSolver.kSap">
<span class="sig-name descname"><span class="pre">kSap</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;DiscreteContactSolver.kSap:</span> <span class="pre">1&gt;</span></em><a class="headerlink" href="#pydrake.multibody.plant.DiscreteContactSolver.kSap" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pydrake.multibody.plant.DiscreteContactSolver.kTamsi">
<span class="sig-name descname"><span class="pre">kTamsi</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;DiscreteContactSolver.kTamsi:</span> <span class="pre">0&gt;</span></em><a class="headerlink" href="#pydrake.multibody.plant.DiscreteContactSolver.kTamsi" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.multibody.plant.DiscreteContactSolver.name">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">name</span></span><a class="headerlink" href="#pydrake.multibody.plant.DiscreteContactSolver.name" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.multibody.plant.DiscreteContactSolver.value">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">value</span></span><a class="headerlink" href="#pydrake.multibody.plant.DiscreteContactSolver.value" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ExternallyAppliedSpatialForce">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">ExternallyAppliedSpatialForce</span></span><a class="headerlink" href="#pydrake.multibody.plant.ExternallyAppliedSpatialForce" title="Permalink to this definition"></a></dt>
<dd><div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <a class="reference internal" href="#pydrake.multibody.plant.ExternallyAppliedSpatialForce_" title="pydrake.multibody.plant.ExternallyAppliedSpatialForce_"><code class="xref py py-class docutils literal notranslate"><span class="pre">ExternallyAppliedSpatialForce_</span></code></a>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ExternallyAppliedSpatialForce.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.ExternallyAppliedSpatialForce" title="pydrake.multibody.plant.ExternallyAppliedSpatialForce"><span class="pre">pydrake.multibody.plant.ExternallyAppliedSpatialForce</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.ExternallyAppliedSpatialForce.__init__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ExternallyAppliedSpatialForce.body_index">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">body_index</span></span><a class="headerlink" href="#pydrake.multibody.plant.ExternallyAppliedSpatialForce.body_index" title="Permalink to this definition"></a></dt>
<dd><p>The index of the body that the force is to be applied to.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ExternallyAppliedSpatialForce.F_Bq_W">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">F_Bq_W</span></span><a class="headerlink" href="#pydrake.multibody.plant.ExternallyAppliedSpatialForce.F_Bq_W" title="Permalink to this definition"></a></dt>
<dd><p>A spatial force applied to Body B at point Bq, expressed in the world
frame.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ExternallyAppliedSpatialForce.p_BoBq_B">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">p_BoBq_B</span></span><a class="headerlink" href="#pydrake.multibody.plant.ExternallyAppliedSpatialForce.p_BoBq_B" title="Permalink to this definition"></a></dt>
<dd><p>A position vector from Body B’s origin (Bo) to a point Bq (a point of
B), expressed in B’s frame.</p>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ExternallyAppliedSpatialForce_">
<em class="property"><span class="pre">template</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">ExternallyAppliedSpatialForce_</span></span><a class="headerlink" href="#pydrake.multibody.plant.ExternallyAppliedSpatialForce_" title="Permalink to this definition"></a></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">ExternallyAppliedSpatialForce_[float]</span></code>, <a class="reference internal" href="#pydrake.multibody.plant.ExternallyAppliedSpatialForce_-AutoDiffXd" title="pydrake.multibody.plant.ExternallyAppliedSpatialForce_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">ExternallyAppliedSpatialForce_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.plant.ExternallyAppliedSpatialForce_-Expression" title="pydrake.multibody.plant.ExternallyAppliedSpatialForce_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">ExternallyAppliedSpatialForce_[Expression]</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ExternallyAppliedSpatialForce_-AutoDiffXd">
<span id="pydrake.multibody.plant.ExternallyAppliedSpatialForce_[AutoDiffXd]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">ExternallyAppliedSpatialForce_[AutoDiffXd]</span></span><a class="headerlink" href="#pydrake.multibody.plant.ExternallyAppliedSpatialForce_-AutoDiffXd" title="Permalink to this definition"></a></dt>
<dd><dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ExternallyAppliedSpatialForce_-AutoDiffXd-.__init__">
<span id="pydrake.multibody.plant.ExternallyAppliedSpatialForce_[AutoDiffXd].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.ExternallyAppliedSpatialForce_" title="pydrake.multibody.plant.ExternallyAppliedSpatialForce_"><span class="pre">pydrake.multibody.plant.ExternallyAppliedSpatialForce_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.ExternallyAppliedSpatialForce_-AutoDiffXd-.__init__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ExternallyAppliedSpatialForce_-AutoDiffXd-.body_index">
<span id="pydrake.multibody.plant.ExternallyAppliedSpatialForce_[AutoDiffXd].body_index"></span><em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">body_index</span></span><a class="headerlink" href="#pydrake.multibody.plant.ExternallyAppliedSpatialForce_-AutoDiffXd-.body_index" title="Permalink to this definition"></a></dt>
<dd><p>The index of the body that the force is to be applied to.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ExternallyAppliedSpatialForce_-AutoDiffXd-.F_Bq_W">
<span id="pydrake.multibody.plant.ExternallyAppliedSpatialForce_[AutoDiffXd].F_Bq_W"></span><em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">F_Bq_W</span></span><a class="headerlink" href="#pydrake.multibody.plant.ExternallyAppliedSpatialForce_-AutoDiffXd-.F_Bq_W" title="Permalink to this definition"></a></dt>
<dd><p>A spatial force applied to Body B at point Bq, expressed in the world
frame.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ExternallyAppliedSpatialForce_-AutoDiffXd-.p_BoBq_B">
<span id="pydrake.multibody.plant.ExternallyAppliedSpatialForce_[AutoDiffXd].p_BoBq_B"></span><em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">p_BoBq_B</span></span><a class="headerlink" href="#pydrake.multibody.plant.ExternallyAppliedSpatialForce_-AutoDiffXd-.p_BoBq_B" title="Permalink to this definition"></a></dt>
<dd><p>A position vector from Body B’s origin (Bo) to a point Bq (a point of
B), expressed in B’s frame.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ExternallyAppliedSpatialForce_-Expression">
<span id="pydrake.multibody.plant.ExternallyAppliedSpatialForce_[Expression]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">ExternallyAppliedSpatialForce_[Expression]</span></span><a class="headerlink" href="#pydrake.multibody.plant.ExternallyAppliedSpatialForce_-Expression" title="Permalink to this definition"></a></dt>
<dd><dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ExternallyAppliedSpatialForce_-Expression-.__init__">
<span id="pydrake.multibody.plant.ExternallyAppliedSpatialForce_[Expression].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.ExternallyAppliedSpatialForce_" title="pydrake.multibody.plant.ExternallyAppliedSpatialForce_"><span class="pre">pydrake.multibody.plant.ExternallyAppliedSpatialForce_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.ExternallyAppliedSpatialForce_-Expression-.__init__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ExternallyAppliedSpatialForce_-Expression-.body_index">
<span id="pydrake.multibody.plant.ExternallyAppliedSpatialForce_[Expression].body_index"></span><em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">body_index</span></span><a class="headerlink" href="#pydrake.multibody.plant.ExternallyAppliedSpatialForce_-Expression-.body_index" title="Permalink to this definition"></a></dt>
<dd><p>The index of the body that the force is to be applied to.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ExternallyAppliedSpatialForce_-Expression-.F_Bq_W">
<span id="pydrake.multibody.plant.ExternallyAppliedSpatialForce_[Expression].F_Bq_W"></span><em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">F_Bq_W</span></span><a class="headerlink" href="#pydrake.multibody.plant.ExternallyAppliedSpatialForce_-Expression-.F_Bq_W" title="Permalink to this definition"></a></dt>
<dd><p>A spatial force applied to Body B at point Bq, expressed in the world
frame.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ExternallyAppliedSpatialForce_-Expression-.p_BoBq_B">
<span id="pydrake.multibody.plant.ExternallyAppliedSpatialForce_[Expression].p_BoBq_B"></span><em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">p_BoBq_B</span></span><a class="headerlink" href="#pydrake.multibody.plant.ExternallyAppliedSpatialForce_-Expression-.p_BoBq_B" title="Permalink to this definition"></a></dt>
<dd><p>A position vector from Body B’s origin (Bo) to a point Bq (a point of
B), expressed in B’s frame.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ExternallyAppliedSpatialForceMultiplexer">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">ExternallyAppliedSpatialForceMultiplexer</span></span><a class="headerlink" href="#pydrake.multibody.plant.ExternallyAppliedSpatialForceMultiplexer" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.LeafSystem" title="pydrake.systems.framework.LeafSystem"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem</span></code></a></p>
<p>Concatenates multiple std::vector&lt;&gt;’s of
ExternallyAppliedSpatialForce&lt;T&gt;.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">u0&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">...&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">u(N-1)&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>ExternallyAppliedSpatialForceMultiplexer</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y0</td></tr></table></td></tr></table><div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <a class="reference internal" href="#pydrake.multibody.plant.ExternallyAppliedSpatialForceMultiplexer_" title="pydrake.multibody.plant.ExternallyAppliedSpatialForceMultiplexer_"><code class="xref py py-class docutils literal notranslate"><span class="pre">ExternallyAppliedSpatialForceMultiplexer_</span></code></a>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ExternallyAppliedSpatialForceMultiplexer.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.ExternallyAppliedSpatialForceMultiplexer" title="pydrake.multibody.plant.ExternallyAppliedSpatialForceMultiplexer"><span class="pre">pydrake.multibody.plant.ExternallyAppliedSpatialForceMultiplexer</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_inputs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.ExternallyAppliedSpatialForceMultiplexer.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Constructor.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">num_inputs</span></code>:</dt><dd><p>Number of input ports to be added.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ExternallyAppliedSpatialForceMultiplexer_">
<em class="property"><span class="pre">template</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">ExternallyAppliedSpatialForceMultiplexer_</span></span><a class="headerlink" href="#pydrake.multibody.plant.ExternallyAppliedSpatialForceMultiplexer_" title="Permalink to this definition"></a></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">ExternallyAppliedSpatialForceMultiplexer_[float]</span></code>, <a class="reference internal" href="#pydrake.multibody.plant.ExternallyAppliedSpatialForceMultiplexer_-AutoDiffXd" title="pydrake.multibody.plant.ExternallyAppliedSpatialForceMultiplexer_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">ExternallyAppliedSpatialForceMultiplexer_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.plant.ExternallyAppliedSpatialForceMultiplexer_-Expression" title="pydrake.multibody.plant.ExternallyAppliedSpatialForceMultiplexer_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">ExternallyAppliedSpatialForceMultiplexer_[Expression]</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ExternallyAppliedSpatialForceMultiplexer_-AutoDiffXd">
<span id="pydrake.multibody.plant.ExternallyAppliedSpatialForceMultiplexer_[AutoDiffXd]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">ExternallyAppliedSpatialForceMultiplexer_[AutoDiffXd]</span></span><a class="headerlink" href="#pydrake.multibody.plant.ExternallyAppliedSpatialForceMultiplexer_-AutoDiffXd" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.LeafSystem_-AutoDiffXd" title="pydrake.systems.framework.LeafSystem_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem_[AutoDiffXd]</span></code></a></p>
<p>Concatenates multiple std::vector&lt;&gt;’s of
ExternallyAppliedSpatialForce&lt;T&gt;.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">u0&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">...&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">u(N-1)&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>ExternallyAppliedSpatialForceMultiplexer</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y0</td></tr></table></td></tr></table><dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ExternallyAppliedSpatialForceMultiplexer_-AutoDiffXd-.__init__">
<span id="pydrake.multibody.plant.ExternallyAppliedSpatialForceMultiplexer_[AutoDiffXd].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.ExternallyAppliedSpatialForceMultiplexer_" title="pydrake.multibody.plant.ExternallyAppliedSpatialForceMultiplexer_"><span class="pre">pydrake.multibody.plant.ExternallyAppliedSpatialForceMultiplexer_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_inputs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.ExternallyAppliedSpatialForceMultiplexer_-AutoDiffXd-.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Constructor.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">num_inputs</span></code>:</dt><dd><p>Number of input ports to be added.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ExternallyAppliedSpatialForceMultiplexer_-Expression">
<span id="pydrake.multibody.plant.ExternallyAppliedSpatialForceMultiplexer_[Expression]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">ExternallyAppliedSpatialForceMultiplexer_[Expression]</span></span><a class="headerlink" href="#pydrake.multibody.plant.ExternallyAppliedSpatialForceMultiplexer_-Expression" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.LeafSystem_-Expression" title="pydrake.systems.framework.LeafSystem_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem_[Expression]</span></code></a></p>
<p>Concatenates multiple std::vector&lt;&gt;’s of
ExternallyAppliedSpatialForce&lt;T&gt;.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">u0&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">...&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">u(N-1)&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>ExternallyAppliedSpatialForceMultiplexer</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y0</td></tr></table></td></tr></table><dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.ExternallyAppliedSpatialForceMultiplexer_-Expression-.__init__">
<span id="pydrake.multibody.plant.ExternallyAppliedSpatialForceMultiplexer_[Expression].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.ExternallyAppliedSpatialForceMultiplexer_" title="pydrake.multibody.plant.ExternallyAppliedSpatialForceMultiplexer_"><span class="pre">pydrake.multibody.plant.ExternallyAppliedSpatialForceMultiplexer_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_inputs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.ExternallyAppliedSpatialForceMultiplexer_-Expression-.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Constructor.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">num_inputs</span></code>:</dt><dd><p>Number of input ports to be added.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.multibody.plant.HydroelasticContactInfo">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">HydroelasticContactInfo</span></span><a class="headerlink" href="#pydrake.multibody.plant.HydroelasticContactInfo" title="Permalink to this definition"></a></dt>
<dd><p>A class containing information regarding contact and contact response
between two geometries attached to a pair of bodies. This class
provides the output from the Hydroelastic contact model and includes:</p>
<ul class="simple">
<li><p>The shared contact surface between the two geometries, which includes</p></li>
</ul>
<p>the virtual pressures acting at every point on the contact surface.
- The tractions acting at the quadrature points on the contact surface.
- The slip speeds at the quadrature points on the contact surface.
- The spatial force from the integrated tractions that is applied at the
centroid of the contact surface.</p>
<p>The two geometries, denoted M and N (and obtainable via
<code class="docutils literal notranslate"><span class="pre">contact_surface().id_M()</span></code> and <code class="docutils literal notranslate"><span class="pre">contact_surface().id_N()</span></code>) are
attached to bodies A and B, respectively.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <a class="reference internal" href="#pydrake.multibody.plant.HydroelasticContactInfo_" title="pydrake.multibody.plant.HydroelasticContactInfo_"><code class="xref py py-class docutils literal notranslate"><span class="pre">HydroelasticContactInfo_</span></code></a>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.HydroelasticContactInfo.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.HydroelasticContactInfo.__init__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.HydroelasticContactInfo.contact_surface">
<span class="sig-name descname"><span class="pre">contact_surface</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.HydroelasticContactInfo" title="pydrake.multibody.plant.HydroelasticContactInfo"><span class="pre">pydrake.multibody.plant.HydroelasticContactInfo</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.ContactSurface" title="pydrake.geometry.ContactSurface"><span class="pre">pydrake.geometry.ContactSurface</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.HydroelasticContactInfo.contact_surface" title="Permalink to this definition"></a></dt>
<dd><p>Returns a reference to the ContactSurface data structure. Note that
the mesh and gradient vector fields are expressed in the world frame.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.HydroelasticContactInfo.F_Ac_W">
<span class="sig-name descname"><span class="pre">F_Ac_W</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.HydroelasticContactInfo" title="pydrake.multibody.plant.HydroelasticContactInfo"><span class="pre">pydrake.multibody.plant.HydroelasticContactInfo</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.math.html#pydrake.multibody.math.SpatialForce" title="pydrake.multibody.math.SpatialForce"><span class="pre">pydrake.multibody.math.SpatialForce</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.HydroelasticContactInfo.F_Ac_W" title="Permalink to this definition"></a></dt>
<dd><p>Gets the spatial force applied on body A, at the centroid point C of
the surface mesh M, and expressed in the world frame W. The position
<code class="docutils literal notranslate"><span class="pre">p_WC</span></code> of the centroid point C in the world frame W can be obtained
with <code class="docutils literal notranslate"><span class="pre">contact_surface().centroid()</span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py" id="pydrake.multibody.plant.HydroelasticContactInfo_">
<em class="property"><span class="pre">template</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">HydroelasticContactInfo_</span></span><a class="headerlink" href="#pydrake.multibody.plant.HydroelasticContactInfo_" title="Permalink to this definition"></a></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">HydroelasticContactInfo_[float]</span></code>, <a class="reference internal" href="#pydrake.multibody.plant.HydroelasticContactInfo_-AutoDiffXd" title="pydrake.multibody.plant.HydroelasticContactInfo_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">HydroelasticContactInfo_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.plant.HydroelasticContactInfo_-Expression" title="pydrake.multibody.plant.HydroelasticContactInfo_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">HydroelasticContactInfo_[Expression]</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.multibody.plant.HydroelasticContactInfo_-AutoDiffXd">
<span id="pydrake.multibody.plant.HydroelasticContactInfo_[AutoDiffXd]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">HydroelasticContactInfo_[AutoDiffXd]</span></span><a class="headerlink" href="#pydrake.multibody.plant.HydroelasticContactInfo_-AutoDiffXd" title="Permalink to this definition"></a></dt>
<dd><p>A class containing information regarding contact and contact response
between two geometries attached to a pair of bodies. This class
provides the output from the Hydroelastic contact model and includes:</p>
<ul class="simple">
<li><p>The shared contact surface between the two geometries, which includes</p></li>
</ul>
<p>the virtual pressures acting at every point on the contact surface.
- The tractions acting at the quadrature points on the contact surface.
- The slip speeds at the quadrature points on the contact surface.
- The spatial force from the integrated tractions that is applied at the
centroid of the contact surface.</p>
<p>The two geometries, denoted M and N (and obtainable via
<code class="docutils literal notranslate"><span class="pre">contact_surface().id_M()</span></code> and <code class="docutils literal notranslate"><span class="pre">contact_surface().id_N()</span></code>) are
attached to bodies A and B, respectively.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.HydroelasticContactInfo_-AutoDiffXd-.__init__">
<span id="pydrake.multibody.plant.HydroelasticContactInfo_[AutoDiffXd].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.HydroelasticContactInfo_-AutoDiffXd-.__init__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.HydroelasticContactInfo_-AutoDiffXd-.contact_surface">
<span id="pydrake.multibody.plant.HydroelasticContactInfo_[AutoDiffXd].contact_surface"></span><span class="sig-name descname"><span class="pre">contact_surface</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.HydroelasticContactInfo_" title="pydrake.multibody.plant.HydroelasticContactInfo_"><span class="pre">pydrake.multibody.plant.HydroelasticContactInfo_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.ContactSurface_" title="pydrake.geometry.ContactSurface_"><span class="pre">pydrake.geometry.ContactSurface_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.HydroelasticContactInfo_-AutoDiffXd-.contact_surface" title="Permalink to this definition"></a></dt>
<dd><p>Returns a reference to the ContactSurface data structure. Note that
the mesh and gradient vector fields are expressed in the world frame.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.HydroelasticContactInfo_-AutoDiffXd-.F_Ac_W">
<span id="pydrake.multibody.plant.HydroelasticContactInfo_[AutoDiffXd].F_Ac_W"></span><span class="sig-name descname"><span class="pre">F_Ac_W</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.HydroelasticContactInfo_" title="pydrake.multibody.plant.HydroelasticContactInfo_"><span class="pre">pydrake.multibody.plant.HydroelasticContactInfo_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.math.html#pydrake.multibody.math.SpatialForce_" title="pydrake.multibody.math.SpatialForce_"><span class="pre">pydrake.multibody.math.SpatialForce_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.HydroelasticContactInfo_-AutoDiffXd-.F_Ac_W" title="Permalink to this definition"></a></dt>
<dd><p>Gets the spatial force applied on body A, at the centroid point C of
the surface mesh M, and expressed in the world frame W. The position
<code class="docutils literal notranslate"><span class="pre">p_WC</span></code> of the centroid point C in the world frame W can be obtained
with <code class="docutils literal notranslate"><span class="pre">contact_surface().centroid()</span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.multibody.plant.HydroelasticContactInfo_-Expression">
<span id="pydrake.multibody.plant.HydroelasticContactInfo_[Expression]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">HydroelasticContactInfo_[Expression]</span></span><a class="headerlink" href="#pydrake.multibody.plant.HydroelasticContactInfo_-Expression" title="Permalink to this definition"></a></dt>
<dd><p>A class containing information regarding contact and contact response
between two geometries attached to a pair of bodies. This class
provides the output from the Hydroelastic contact model and includes:</p>
<ul class="simple">
<li><p>The shared contact surface between the two geometries, which includes</p></li>
</ul>
<p>the virtual pressures acting at every point on the contact surface.
- The tractions acting at the quadrature points on the contact surface.
- The slip speeds at the quadrature points on the contact surface.
- The spatial force from the integrated tractions that is applied at the
centroid of the contact surface.</p>
<p>The two geometries, denoted M and N (and obtainable via
<code class="docutils literal notranslate"><span class="pre">contact_surface().id_M()</span></code> and <code class="docutils literal notranslate"><span class="pre">contact_surface().id_N()</span></code>) are
attached to bodies A and B, respectively.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.HydroelasticContactInfo_-Expression-.__init__">
<span id="pydrake.multibody.plant.HydroelasticContactInfo_[Expression].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.HydroelasticContactInfo_-Expression-.__init__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.HydroelasticContactInfo_-Expression-.contact_surface">
<span id="pydrake.multibody.plant.HydroelasticContactInfo_[Expression].contact_surface"></span><span class="sig-name descname"><span class="pre">contact_surface</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.HydroelasticContactInfo_" title="pydrake.multibody.plant.HydroelasticContactInfo_"><span class="pre">pydrake.multibody.plant.HydroelasticContactInfo_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">drake::geometry::ContactSurface&lt;drake::symbolic::Expression&gt;</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.HydroelasticContactInfo_-Expression-.contact_surface" title="Permalink to this definition"></a></dt>
<dd><p>Returns a reference to the ContactSurface data structure. Note that
the mesh and gradient vector fields are expressed in the world frame.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.HydroelasticContactInfo_-Expression-.F_Ac_W">
<span id="pydrake.multibody.plant.HydroelasticContactInfo_[Expression].F_Ac_W"></span><span class="sig-name descname"><span class="pre">F_Ac_W</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.HydroelasticContactInfo_" title="pydrake.multibody.plant.HydroelasticContactInfo_"><span class="pre">pydrake.multibody.plant.HydroelasticContactInfo_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.math.html#pydrake.multibody.math.SpatialForce_" title="pydrake.multibody.math.SpatialForce_"><span class="pre">pydrake.multibody.math.SpatialForce_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.HydroelasticContactInfo_-Expression-.F_Ac_W" title="Permalink to this definition"></a></dt>
<dd><p>Gets the spatial force applied on body A, at the centroid point C of
the surface mesh M, and expressed in the world frame W. The position
<code class="docutils literal notranslate"><span class="pre">p_WC</span></code> of the centroid point C in the world frame W can be obtained
with <code class="docutils literal notranslate"><span class="pre">contact_surface().centroid()</span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">MultibodyPlant</span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.LeafSystem" title="pydrake.systems.framework.LeafSystem"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem</span></code></a></p>
<p>MultibodyPlant is a Drake system framework representation (see
systems::System) for the model of a physical system consisting of a
collection of interconnected bodies. See multibody for an overview of
concepts/notation.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">actuation&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">applied_generalized_force&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">applied_spatial_force&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px"><em style="color:gray">model_instance_name[i]</em>_actuation&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px"><em style="color:gray">model_instance_name[i]</em>_desired_state&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px"><span style="color:green">geometry_query</span>&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>MultibodyPlant</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; state</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; body_poses</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; body_spatial_velocities</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; body_spatial_accelerations</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; generalized_acceleration</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; net_actuation</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; reaction_forces</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; contact_results</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; <em style="color:gray">model_instance_name[i]</em>_state</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; <em style="color:gray"> model_instance_name[i]</em>_generalized_acceleration</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; <em style="color:gray"> model_instance_name[i]</em>_generalized_contact_forces</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; <em style="color:gray">model_instance_name[i]</em>_net_actuation</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; <span style="color:green">geometry_pose</span></td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; <span style="color:green">deformable_body_configuration</span></td></tr></table></td></tr></table><p>The ports whose names begin with &lt;em style=”color:gray”&gt;
model_instance_name[i]&lt;/em&gt; represent groups of ports, one for each of
the model_instances “model instances”, with i ∈ {0, …, N-1} for the
N model instances. If a model instance does not contain any data of
the indicated type the port will still be present but its value will
be a zero-length vector. (Model instances <code class="docutils literal notranslate"><span class="pre">world_model_instance()</span></code>
and <code class="docutils literal notranslate"><span class="pre">default_model_instance()</span></code> always exist.)</p>
<p>The ports shown in &lt;span style=”color:green”&gt; green&lt;/span&gt; are for
communication with Drake’s geometry::SceneGraph “SceneGraph” system
for dealing with geometry.</p>
<p>MultibodyPlant provides a user-facing API for:</p>
<ul class="simple">
<li><p>mbp_input_and_output_ports “Ports”:</p></li>
</ul>
<p>Access input and output ports.
- mbp_construction “Construction”:
Add bodies, joints, frames, force elements, and actuators.
- mbp_geometry “Geometry”:
Register geometries to a provided SceneGraph instance.
- mbp_contact_modeling “Contact modeling”:
Select and parameterize contact models.
- mbp_state_accessors_and_mutators “State access and modification”:
Obtain and manipulate position and velocity state variables.
- mbp_parameters “Parameters”
Working with system parameters for various multibody elements.
- mbp_working_with_free_bodies “Free bodies”:
Work conveniently with free (floating) bodies.
- mbp_kinematic_and_dynamic_computations “Kinematics and dynamics”:
Perform systems::Context “Context”-dependent kinematic and dynamic
queries.
- mbp_system_matrix_computations “System matrices”:
Explicitly form matrices that appear in the equations of motion.
- mbp_introspection “Introspection”:
Perform introspection to find out what’s in the MultibodyPlant.</p>
<p><a href="#id1"><span class="problematic" id="id2">**</span></a>** Model Instances</p>
<p>A MultiBodyPlant may contain multiple model instances. Each model
instance corresponds to a set of bodies and their connections
(joints). Model instances provide methods to get or set the state of
the set of bodies (e.g., through GetPositionsAndVelocities() and
SetPositionsAndVelocities()), connecting controllers (through
get_state_output_port() and get_actuation_input_port()), and
organizing duplicate models (read through a parser). In fact, many
MultibodyPlant methods are overloaded to allow operating on the entire
plant or just the subset corresponding to the model instance; for
example, one GetPositions() method obtains the generalized positions
for the entire plant while another GetPositions() method obtains the
generalized positions for model instance.</p>
<p>Model instances are frequently defined through SDFormat files (using
the <code class="docutils literal notranslate"><span class="pre">model</span></code> tag) and are automatically created when SDFormat files
are parsed (by Parser). There are two special
multibody::ModelInstanceIndex values. The world body is always
multibody::ModelInstanceIndex 0. multibody::ModelInstanceIndex 1 is
reserved for all elements with no explicit model instance and is
generally only relevant for elements created programmatically (and
only when a model instance is not explicitly specified). Note that
Parser creates model instances (resulting in a
multibody::ModelInstanceIndex ≥ 2) as needed.</p>
<p>See num_model_instances(), num_positions(), num_velocities(),
num_actuated_dofs(), AddModelInstance() GetPositionsAndVelocities(),
GetPositions(), GetVelocities(), SetPositionsAndVelocities(),
SetPositions(), SetVelocities(), GetPositionsFromArray(),
GetVelocitiesFromArray(), SetPositionsInArray(),
SetVelocitiesInArray(), SetActuationInArray(),
HasModelInstanceNamed(), GetModelInstanceName(),
get_state_output_port(), get_actuation_input_port().</p>
<p><a href="#id3"><span class="problematic" id="id4">**</span></a>** System dynamics</p>
<p>The state of a multibody system <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">[q;</span> <span class="pre">v]</span></code> is given by its
generalized positions vector q, of size <code class="docutils literal notranslate"><span class="pre">nq</span></code> (see num_positions()),
and by its generalized velocities vector v, of size <code class="docutils literal notranslate"><span class="pre">nv</span></code> (see
num_velocities()). As a Drake systems::System “System”, MultibodyPlant
implements the governing equations for a multibody dynamical system in
the form <code class="docutils literal notranslate"><span class="pre">ẋ</span> <span class="pre">=</span> <span class="pre">f(t,</span> <span class="pre">x,</span> <span class="pre">u)</span></code> with t being time and u the actuation
forces. The governing equations for the dynamics of a multibody system
modeled with MultibodyPlant are [Featherstone 2008, Jain 2010]:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>q̇ = N(q)v
(1)    M(q)v̇ + C(q, v)v = τ
</pre></div>
</div>
</details><p>where <code class="docutils literal notranslate"><span class="pre">M(q)</span></code> is the mass matrix of the multibody system (including
rigid body mass properties and reflected_inertia “reflected
inertias”), <code class="docutils literal notranslate"><span class="pre">C(q,</span> <span class="pre">v)v</span></code> contains Coriolis, centripetal, and
gyroscopic terms and <code class="docutils literal notranslate"><span class="pre">N(q)</span></code> is the kinematic coupling matrix
describing the relationship between q̇ (the time derivatives of the
generalized positions) and the generalized velocities v, [Seth 2010].
<code class="docutils literal notranslate"><span class="pre">N(q)</span></code> is an <code class="docutils literal notranslate"><span class="pre">nq</span> <span class="pre">x</span> <span class="pre">nv</span></code> matrix. The vector <code class="docutils literal notranslate"><span class="pre">τ</span> <span class="pre">∈</span> <span class="pre">ℝⁿᵛ</span></code> on the right
hand side of Eq. (1) is the system’s generalized forces. These
incorporate gravity, springs, externally applied body forces,
constraint forces, and contact forces.</p>
<p><a href="#id5"><span class="problematic" id="id6">**</span></a>** Actuation</p>
<p>In a MultibodyPlant model an actuator can be added as a JointActuator,
see AddJointActuator(). The plant declares actuation input ports to
provide feedforward actuation, both for the MultibodyPlant as a whole
(see get_actuation_input_port()) and for each individual
model_instances “model instance” in the MultibodyPlant (see
get_actuation_input_port(ModelInstanceIndex)const
“get_actuation_input_port(ModelInstanceIndex)”). Any actuation input
ports not connected are assumed to be zero. Actuation values from the
full MultibodyPlant model port (get_actuation_input_port()) and from
the per model-instance ports (
get_actuation_input_port(ModelInstanceIndex)const
“get_actuation_input_port(ModelInstanceIndex)”) are summed up.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A JointActuator’s index into the vector data supplied to
MultibodyPlant’s actuation input port for all actuators
(get_actuation_input_port()) is given by
JointActuator::input_start(), NOT by its JointActuatorIndex. That
is, the vector element data for a JointActuator at index
JointActuatorIndex(i) in the full input port vector is found at
index:
MultibodyPlant::get_joint_actuator(JointActuatorIndex(i)).input_start().
For the get_actuation_input_port(ModelInstanceIndex)const
“get_actuation_input_port(ModelInstanceIndex)” specific to a model
index, the vector data is ordered by monotonically increasing
JointActuatorIndex for the actuators within that model instance:
the 0ᵗʰ vector element corresponds to the lowest-numbered
JointActuatorIndex of that instance, the 1ˢᵗ vector element
corresponds to the second-lowest-numbered JointActuatorIndex of
that instance, etc.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The following snippet shows how per model instance actuation can
be set:</p>
</div>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">ModelInstanceIndex</span><span class="w"> </span><span class="n">model_instance_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...;</span><span class="w"></span>
<span class="n">VectorX</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">u_instance</span><span class="p">(</span><span class="n">plant</span><span class="p">.</span><span class="n">num_actuated_dofs</span><span class="p">(</span><span class="n">model_instance_index</span><span class="p">));</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">JointActuatorIndex</span><span class="w"> </span><span class="n">joint_actuator_index</span><span class="w"> </span><span class="o">:</span><span class="w"></span>
<span class="n">plant</span><span class="p">.</span><span class="n">GetJointActuatorIndices</span><span class="p">(</span><span class="n">model_instance_index</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="n">JointActuator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">actuator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">plant</span><span class="p">.</span><span class="n">get_joint_actuator</span><span class="p">(</span><span class="w"></span>
<span class="n">joint_actuator_index</span><span class="p">);</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="n">Joint</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">joint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">actuator</span><span class="p">.</span><span class="n">joint</span><span class="p">();</span><span class="w"></span>
<span class="n">VectorX</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">u_joint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="n">my_actuation_logic_for</span><span class="p">(</span><span class="n">joint</span><span class="p">)</span><span class="w"> </span><span class="p">...;</span><span class="w"></span>
<span class="n">ASSERT</span><span class="p">(</span><span class="n">u_joint</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">joint_actuator</span><span class="p">.</span><span class="n">num_inputs</span><span class="p">());</span><span class="w"></span>
<span class="n">u_instance</span><span class="p">.</span><span class="n">segment</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="n">u_joint</span><span class="p">.</span><span class="n">size</span><span class="p">())</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">u_joint</span><span class="p">;</span><span class="w"></span>
<span class="n">offset</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">u_joint</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="n">plant</span><span class="p">.</span><span class="n">get_actuation_input_port</span><span class="p">(</span><span class="n">model_instance_index</span><span class="p">).</span><span class="n">FixValue</span><span class="p">(</span><span class="w"></span>
<span class="n">plant_context</span><span class="p">,</span><span class="w"> </span><span class="n">u_instance</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</details><div class="admonition note">
<p class="admonition-title">Note</p>
<p>To inter-operate between the whole plant actuation vector and sets
of per-model instance actuation vectors, see SetActuationInArray()
to gather the model instance vectors into a whole plant vector and
GetActuationFromArray() to scatter the whole plant vector into
per-model instance vectors.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Effort limits (JointActuator::effort_limit()) are not enforced,
unless PD controllers are defined. See pd_controllers “Using PD
controlled actuators”.</p>
</div>
<p>** Using PD controlled actuators</p>
<p>While PD controllers can be modeled externally and be connected to the
MultibodyPlant model via the get_actuation_input_port(), simulation
stability at discrete time steps can be compromised for high
controller gains. For such cases, simulation stability and robustness
can be improved significantly by moving your PD controller into the
plant where the discrete solver can strongly couple controller and
model dynamics.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Currently, this feature is only supported for discrete models
(is_discrete() is true) using the SAP solver
(get_discrete_contact_solver() returns
DiscreteContactSolver::kSap.)</p>
</div>
<p>PD controlled joint actuators can be defined by setting PD gains for
each joint actuator, see JointActuator::set_controller_gains(). Unless
these gains are specified, joint actuators will not be PD controlled
and JointActuator::has_controller() will return <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>For PD controlled models, all joint actuators in a model instance
are required to have PD controllers defined. That is, partially PD
controlled model instances are not supported. An exception will be
thrown when evaluating the actuation input ports if only a subset
of the actuators in a model instance is PD controlled.</p>
</div>
<p>For models with PD controllers, the actuation torque per actuator is
computed according to:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>ũ = -Kp⋅(q − qd) - Kd⋅(v − vd) + u_ff
u = max(−e, min(e, ũ))
</pre></div>
</div>
</details><p>where qd and vd are desired configuration and velocity (see
get_desired_state_input_port()) for the actuated joint (see
JointActuator::joint()), Kp and Kd are the proportional and derivative
gains of the actuator (see JointActuator::get_controller_gains()),
<code class="docutils literal notranslate"><span class="pre">u_ff</span></code> is the feed-forward actuation specified with
get_actuation_input_port(), and <code class="docutils literal notranslate"><span class="pre">e</span></code> corresponds to effort limit (see
JointActuator::effort_limit()).</p>
<p>Notice that actuation through get_actuation_input_port() and PD
control are not mutually exclusive, and they can be used together.
This is better explained through examples: 1. <strong>PD controlled
gripper</strong>. In this case, only PD control is used to drive the opening
and closing of the fingers. The feed-forward term is assumed to be
zero and the actuation input port is not required to be connected. 2.
<strong>Robot arm</strong>. A typical configuration consists on applying gravity
compensation in the feed-forward term plus PD control to drive the
robot to a given desired state.</p>
<p>** Actuation input ports requirements</p>
<p>The following table specifies whether actuation ports are required to
be connected or not:</p>
<div class="line-block">
<div class="line">Port | without PD control | with PD control | |</div>
</div>
<dl class="field-list">
<dt class="field-odd">——————————</dt>
<dd class="field-odd"><div class="line-block">
<div class="line">:——————-: |</div>
</div>
</dd>
<dt class="field-even">————-</dt>
<dd class="field-even"><div class="line-block">
<div class="line">| get_actuation_input_port() | yes | no¹ | |</div>
</div>
</dd>
</dl>
<p>get_desired_state_input_port() | no² | yes |</p>
<p>¹ Feed-forward actuation is not required for models with PD controlled
actuators. This simplifies the diagram wiring for models that only
rely on PD controllers.</p>
<p>² This port is always declared, though it will be zero sized for model
instances with no PD controllers.</p>
<p>** Net actuation</p>
<p>The total joint actuation applied via the actuation input port
(get_actuation_input_port()) and applied by the PD controllers is
reported by the net actuation port (get_net_actuation_output_port()).
That is, the net actuation port reports the total actuation applied by
a given actuator.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>PD controllers are ignored when a joint is locked (see
Joint::Lock()), and thus they have no effect on the actuation
output.</p>
</div>
<p><a href="#id7"><span class="problematic" id="id8">**</span></a>** Loading models from SDFormat files</p>
<p>Drake has the capability to load multibody models from SDFormat and
URDF files. Consider the example below which loads an acrobot model:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">acrobot</span><span class="p">;</span><span class="w"></span>
<span class="n">SceneGraph</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">scene_graph</span><span class="p">;</span><span class="w"></span>
<span class="n">Parser</span><span class="w"> </span><span class="nf">parser</span><span class="p">(</span><span class="o">&amp;</span><span class="n">acrobot</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">scene_graph</span><span class="p">);</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">url</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="s">&quot;package://drake/multibody/benchmarks/acrobot/acrobot.sdf&quot;</span><span class="p">;</span><span class="w"></span>
<span class="n">parser</span><span class="p">.</span><span class="n">AddModelsFromUrl</span><span class="p">(</span><span class="n">url</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</details><p>As in the example above, for models including visual geometry,
collision geometry or both, the user must specify a SceneGraph for
geometry handling. You can find a full example of the LQR controlled
acrobot in examples/multibody/acrobot/run_lqr.cc.</p>
<p>AddModelFromFile() can be invoked multiple times on the same plant in
order to load multiple model instances. Other methods are available on
Parser such as AddModels() which allows creating model instances per
each <code class="docutils literal notranslate"><span class="pre">&lt;model&gt;</span></code> tag found in the file. Please refer to each of these
methods’ documentation for further details.</p>
<p><a href="#id9"><span class="problematic" id="id10">**</span></a>** Working with SceneGraph</p>
<p>** Adding a MultibodyPlant connected to a SceneGraph to your Diagram</p>
<p>Probably the simplest way to add and wire up a MultibodyPlant with a
SceneGraph in your Diagram is using AddMultibodyPlantSceneGraph().</p>
<p>Recommended usages:</p>
<p>Assign to a MultibodyPlant reference (ignoring the SceneGraph):</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">plant</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="n">AddMultibodyPlantSceneGraph</span><span class="p">(</span><span class="o">&amp;</span><span class="n">builder</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="o">/+</span><span class="w"> </span><span class="n">time_step</span><span class="w"> </span><span class="o">+/</span><span class="p">);</span><span class="w"></span>
<span class="n">plant</span><span class="p">.</span><span class="n">DoFoo</span><span class="p">(...);</span><span class="w"></span>
</pre></div>
</div>
</details><p>This flavor is the simplest, when the SceneGraph is not explicitly
needed. (It can always be retrieved later via
GetSubsystemByName(“scene_graph”).)</p>
<p>Assign to auto, and use the named public fields:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="n">items</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AddMultibodyPlantSceneGraph</span><span class="p">(</span><span class="o">&amp;</span><span class="n">builder</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="o">/+</span><span class="w"> </span><span class="n">time_step</span><span class="w"> </span><span class="o">+/</span><span class="p">);</span><span class="w"></span>
<span class="n">items</span><span class="p">.</span><span class="n">plant</span><span class="p">.</span><span class="n">DoFoo</span><span class="p">(...);</span><span class="w"></span>
<span class="n">items</span><span class="p">.</span><span class="n">scene_graph</span><span class="p">.</span><span class="n">DoBar</span><span class="p">(...);</span><span class="w"></span>
</pre></div>
</div>
</details><p>or taking advantage of C++’s structured binding:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="p">[</span><span class="n">plant</span><span class="p">,</span><span class="w"> </span><span class="n">scene_graph</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AddMultibodyPlantSceneGraph</span><span class="p">(</span><span class="o">&amp;</span><span class="n">builder</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">);</span><span class="w"></span>
<span class="p">...</span><span class="w"></span>
<span class="n">plant</span><span class="p">.</span><span class="n">DoFoo</span><span class="p">(...);</span><span class="w"></span>
<span class="n">scene_graph</span><span class="p">.</span><span class="n">DoBar</span><span class="p">(...);</span><span class="w"></span>
</pre></div>
</div>
</details><p>This is the easiest way to use both the plant and scene_graph.</p>
<p>Assign to already-declared pointer variables:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;*</span><span class="w"> </span><span class="n">plant</span><span class="p">{};</span><span class="w"></span>
<span class="n">SceneGraph</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;*</span><span class="w"> </span><span class="n">scene_graph</span><span class="p">{};</span><span class="w"></span>
<span class="n">std</span><span class="o">::</span><span class="n">tie</span><span class="p">(</span><span class="n">plant</span><span class="p">,</span><span class="w"> </span><span class="n">scene_graph</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="n">AddMultibodyPlantSceneGraph</span><span class="p">(</span><span class="o">&amp;</span><span class="n">builder</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="o">/+</span><span class="w"> </span><span class="n">time_step</span><span class="w"> </span><span class="o">+/</span><span class="p">);</span><span class="w"></span>
<span class="n">plant</span><span class="o">-&gt;</span><span class="n">DoFoo</span><span class="p">(...);</span><span class="w"></span>
<span class="n">scene_graph</span><span class="o">-&gt;</span><span class="n">DoBar</span><span class="p">(...);</span><span class="w"></span>
</pre></div>
</div>
</details><p>This flavor is most useful when the pointers are class member fields
(and so perhaps cannot be references).</p>
<p>** Registering geometry with a SceneGraph</p>
<p>MultibodyPlant users can register geometry with a SceneGraph for
essentially two purposes; a) visualization and, b) contact modeling.</p>
<p>Before any geometry registration takes place, a user <strong>must</strong> first
make a call to RegisterAsSourceForSceneGraph() in order to register
the MultibodyPlant as a client of a SceneGraph instance, point at
which the plant will have assigned a valid geometry::SourceId. At
Finalize(), MultibodyPlant will declare input/output ports as
appropriate to communicate with the SceneGraph instance on which
registrations took place. All geometry registration <strong>must</strong> be
performed pre-finalize.</p>
<p>Multibodyplant declares an input port for geometric queries, see
get_geometry_query_input_port(). If MultibodyPlant registers geometry
with a SceneGraph via calls to RegisterCollisionGeometry(), users may
use this port for geometric queries. The port must be connected to the
same SceneGraph used for registration. The preferred mechanism is to
use AddMultibodyPlantSceneGraph() as documented above.</p>
<p>In extraordinary circumstances, this can be done by hand and the setup
process will include:</p>
<ol class="arabic simple">
<li><p>Call to RegisterAsSourceForSceneGraph().</p></li>
<li><p>Calls to RegisterCollisionGeometry(), as many as needed.</p></li>
<li><p>Call to Finalize(), user is done specifying the model.</p></li>
</ol>
<p>4. Connect geometry::SceneGraph::get_query_output_port() to
get_geometry_query_input_port().
5. Connect get_geometry_poses_output_port() to
geometry::SceneGraph::get_source_pose_port()</p>
<p>Refer to the documentation provided in each of the methods above for
further details.</p>
<p>** Accessing point contact parameters MultibodyPlant’s point contact
model looks for model parameters stored as
geometry::ProximityProperties by geometry::SceneGraph. These
properties can be obtained before or after context creation through
geometry::SceneGraphInspector APIs as outlined below. MultibodyPlant
expects the following properties for point contact modeling:</p>
<p><a href="#id91"><span class="problematic" id="id92">|Group name|Property Name|Required|Property Type|Property Description|</span></a>
<a href="#id93"><span class="problematic" id="id94">|:--------:|</span></a>:———–:<a href="#id95"><span class="problematic" id="id96">|:------:|</span></a>:—————-:<a href="#id97"><span class="problematic" id="id98">|:-------------------|</span></a>
<a href="#id99"><span class="problematic" id="id100">|material|coulomb_friction|yes¹|CoulombFriction&lt;T&gt;|Static and Dynamic
friction.|</span></a> <a href="#id101"><span class="problematic" id="id102">|material|point_contact_stiffness|no²|T|</span></a> Compliant point
contact stiffness.| <a href="#id103"><span class="problematic" id="id104">|material|hunt_crossley_dissipation |no²⁴|T|</span></a>
Compliant contact dissipation.|
<a href="#id105"><span class="problematic" id="id106">|material|relaxation_time|yes³⁴|T|Linear Kelvin–Voigt model
parameter.|</span></a></p>
<p>¹ Collision geometry is required to be registered with a
geometry::ProximityProperties object that contains the (“material”,
“coulomb_friction”) property. If the property is missing,
MultibodyPlant will throw an exception.</p>
<p>² If the property is missing, MultibodyPlant will use a heuristic
value as the default. Refer to the section mbp_compliant_point_contact
“Compliant point contact model” for further details.</p>
<p>³ When using a linear Kelvin–Voigt model of dissipation (for instance
when selecting the SAP solver), collision geometry is required to be
registered with a geometry::ProximityProperties object that contains
the (“material”, “relaxation_time”) property. If the property is
missing, an exception will be thrown.</p>
<p>⁴ We allow to specify both hunt_crossley_dissipation and
relaxation_time for a given geometry. However only one of these will
get used, depending on the configuration of the MultibodyPlant. As an
example, if the SAP contact approximation is specified (see
set_discrete_contact_approximation()) only the relaxation_time is used
while hunt_crossley_dissipation is ignored. Conversely, if the TAMSI,
Similar or Lagged approximation is used (see
set_discrete_contact_approximation()) only hunt_crossley_dissipation
is used while relaxation_time is ignored. Currently, a continuous
MultibodyPlant model will always use the Hunt &amp; Crossley model and
relaxation_time will be ignored.</p>
<p>Accessing and modifying contact properties requires interfacing with
geometry::SceneGraph’s model inspector. Interfacing with a model
inspector obtained from geometry::SceneGraph will provide the default
registered values for a given parameter. These are the values that
will initially appear in a systems::Context created by
CreateDefaultContext(). Subsequently, true system parameters can be
accessed and changed through a systems::Context once available. For
both of the above cases, proximity properties are accessed through
geometry::SceneGraphInspector APIs.</p>
<p>Before context creation an inspector can be retrieved directly from
SceneGraph as:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// For a SceneGraph&lt;T&gt; instance called scene_graph.</span>
<span class="k">const</span><span class="w"> </span><span class="n">geometry</span><span class="o">::</span><span class="n">SceneGraphInspector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">inspector</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="n">scene_graph</span><span class="p">.</span><span class="n">model_inspector</span><span class="p">();</span><span class="w"></span>
</pre></div>
</div>
</details><p>After context creation, an inspector can be retrieved from the state
stored in the context by the plant’s geometry query input port:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// For a MultibodyPlant&lt;T&gt; instance called mbp and a</span>
<span class="c1">// Context&lt;T&gt; called context.</span>
<span class="k">const</span><span class="w"> </span><span class="n">geometry</span><span class="o">::</span><span class="n">QueryObject</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">query_object</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="n">mbp</span><span class="p">.</span><span class="n">get_geometry_query_input_port</span><span class="p">()</span><span class="w"></span>
<span class="p">.</span><span class="k">template</span><span class="w"> </span><span class="n">Eval</span><span class="o">&lt;</span><span class="n">geometry</span><span class="o">::</span><span class="n">QueryObject</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">context</span><span class="p">);</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="n">geometry</span><span class="o">::</span><span class="n">SceneGraphInspector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">inspector</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="n">query_object</span><span class="p">.</span><span class="n">inspector</span><span class="p">();</span><span class="w"></span>
</pre></div>
</div>
</details><p>Once an inspector is available, proximity properties can be retrieved
as:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// For a body with GeometryId called geometry_id</span>
<span class="k">const</span><span class="w"> </span><span class="n">geometry</span><span class="o">::</span><span class="n">ProximityProperties</span><span class="o">*</span><span class="w"> </span><span class="n">props</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="n">inspector</span><span class="p">.</span><span class="n">GetProximityProperties</span><span class="p">(</span><span class="n">geometry_id</span><span class="p">);</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="n">CoulombFriction</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">geometry_friction</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="n">props</span><span class="o">-&gt;</span><span class="n">GetProperty</span><span class="o">&lt;</span><span class="n">CoulombFriction</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="s">&quot;material&quot;</span><span class="p">,</span><span class="w"></span>
<span class="s">&quot;coulomb_friction&quot;</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</details><p><a href="#id11"><span class="problematic" id="id12">**</span></a>** Working with MultibodyElement parameters Several
MultibodyElements expose parameters, allowing the user flexible
modification of some aspects of the plant’s model, post
systems::Context creation. For details, refer to the documentation for
the MultibodyElement whose parameters you are trying to modify/access
(e.g. RigidBody, FixedOffsetFrame, etc.)</p>
<p>As an example, here is how to access and modify rigid body mass
parameters:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">plant</span><span class="p">;</span><span class="w"></span>
<span class="c1">// ... Code to add bodies, finalize plant, and to obtain a context.</span>
<span class="k">const</span><span class="w"> </span><span class="n">RigidBody</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">body</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="n">plant</span><span class="p">.</span><span class="n">GetRigidBodyByName</span><span class="p">(</span><span class="s">&quot;BodyName&quot;</span><span class="p">);</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="n">SpatialInertia</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">M_BBo_B</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="n">body</span><span class="p">.</span><span class="n">GetSpatialInertiaInBodyFrame</span><span class="p">(</span><span class="n">context</span><span class="p">);</span><span class="w"></span>
<span class="c1">// .. logic to determine a new SpatialInertia parameter for body.</span>
<span class="k">const</span><span class="w"> </span><span class="n">SpatialInertia</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">M_BBo_B_new</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">....</span><span class="w"></span>

<span class="c1">// Modify the body parameter for spatial inertia.</span>
<span class="n">body</span><span class="p">.</span><span class="n">SetSpatialInertiaInBodyFrame</span><span class="p">(</span><span class="o">&amp;</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="n">M_BBo_B_new</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</details><p>Another example, working with automatic differentiation in order to
take derivatives with respect to one of the bodies’ masses:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">plant</span><span class="p">;</span><span class="w"></span>
<span class="c1">// ... Code to add bodies, finalize plant, and to obtain a</span>
<span class="c1">// context and a body&#39;s spatial inertia M_BBo_B.</span>

<span class="c1">// Scalar convert the plant.</span>
<span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="n">AutoDiffXd</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">plant_autodiff</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="n">systems</span><span class="o">::</span><span class="n">System</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">ToAutoDiffXd</span><span class="p">(</span><span class="n">plant</span><span class="p">);</span><span class="w"></span>
<span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Context</span><span class="o">&lt;</span><span class="n">AutoDiffXd</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">context_autodiff</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="n">plant_autodiff</span><span class="o">-&gt;</span><span class="n">CreateDefaultContext</span><span class="p">();</span><span class="w"></span>
<span class="n">context_autodiff</span><span class="o">-&gt;</span><span class="n">SetTimeStateAndParametersFrom</span><span class="p">(</span><span class="n">context</span><span class="p">);</span><span class="w"></span>

<span class="k">const</span><span class="w"> </span><span class="n">RigidBody</span><span class="o">&lt;</span><span class="n">AutoDiffXd</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">body</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="n">plant_autodiff</span><span class="o">-&gt;</span><span class="n">GetRigidBodyByName</span><span class="p">(</span><span class="s">&quot;BodyName&quot;</span><span class="p">);</span><span class="w"></span>

<span class="c1">// Modify the body parameter for mass.</span>
<span class="k">const</span><span class="w"> </span><span class="n">AutoDiffXd</span><span class="w"> </span><span class="nf">mass_autodiff</span><span class="p">(</span><span class="n">mass</span><span class="p">,</span><span class="w"> </span><span class="n">Vector1d</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span><span class="w"></span>
<span class="n">body</span><span class="p">.</span><span class="n">SetMass</span><span class="p">(</span><span class="n">context_autodiff</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span><span class="w"> </span><span class="n">mass_autodiff</span><span class="p">);</span><span class="w"></span>

<span class="c1">// M_autodiff(i, j).derivatives()(0), contains the derivatives of</span>
<span class="c1">// M(i, j) with respect to the body&#39;s mass.</span>
<span class="n">MatrixX</span><span class="o">&lt;</span><span class="n">AutoDiffXd</span><span class="o">&gt;</span><span class="w"> </span><span class="n">M_autodiff</span><span class="p">(</span><span class="n">plant_autodiff</span><span class="o">-&gt;</span><span class="n">num_velocities</span><span class="p">(),</span><span class="w"></span>
<span class="n">plant_autodiff</span><span class="o">-&gt;</span><span class="n">num_velocities</span><span class="p">());</span><span class="w"></span>
<span class="n">plant_autodiff</span><span class="o">-&gt;</span><span class="n">CalcMassMatrix</span><span class="p">(</span><span class="o">*</span><span class="n">context_autodiff</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">M_autodiff</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</details><p><a href="#id13"><span class="problematic" id="id14">**</span></a>** Adding modeling elements</p>
<p>Add multibody elements to a MultibodyPlant with methods like:</p>
<ul class="simple">
<li><p>Bodies: AddRigidBody()</p></li>
<li><p>Joints: AddJoint()</p></li>
<li><p>see mbp_construction “Construction” for more.</p></li>
</ul>
<p>All modeling elements <strong>must</strong> be added before Finalize() is called.
See mbp_finalize_stage “Finalize stage” for a discussion.</p>
<p><a href="#id15"><span class="problematic" id="id16">**</span></a>** Modeling contact</p>
<p>Please refer to drake_contacts “Contact Modeling in Drake” for details
on the available approximations, setup, and considerations for a
multibody simulation with frictional contact.</p>
<p><a href="#id17"><span class="problematic" id="id18">**</span></a>** Energy and Power</p>
<p>MultibodyPlant implements the System energy and power methods, with
some limitations. - Kinetic energy: fully implemented. - Potential
energy and conservative power: currently include only gravity and
contributions from ForceElement objects; potential energy from
compliant contact and joint limits are not included. - Nonconservative
power: currently includes only contributions from ForceElement
objects; actuation and input port forces, joint damping, and
dissipation from joint limits, friction, and contact dissipation are
not included.</p>
<p>See Drake issue #12942 for more discussion.</p>
<p><a href="#id19"><span class="problematic" id="id20">**</span></a>** Finalize() stage</p>
<p>Once the user is done adding modeling elements and registering
geometry, a call to Finalize() must be performed. This call will: -
Build the underlying tree structure of the multibody model, - declare
the plant’s state, - declare the plant’s input and output ports, -
declare collision filters to ignore collisions among rigid bodies: -
between rigid bodies connected by a joint, - within subgraphs of
welded rigid bodies. Note that MultibodyPlant will <em>not</em> introduce
<em>any</em> collision filters on deformable bodies.</p>
<p><a href="#id21"><span class="problematic" id="id22">**</span></a>** References</p>
<ul class="simple">
<li><p>[Featherstone 2008] Featherstone, R., 2008.</p></li>
</ul>
<p>Rigid body dynamics algorithms. Springer.
- [Jain 2010] Jain, A., 2010.
Robot and multibody dynamics: analysis and algorithms.
Springer Science &amp; Business Media.
- [Seth 2010] Seth, A., Sherman, M., Eastman, P. and Delp, S., 2010.
Minimal formulation of joint motion for biomechanisms.
Nonlinear dynamics, 62(1), pp.291-303.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><code class="xref py py-class docutils literal notranslate"><span class="pre">MultibodyPlant_</span></code></a>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_step</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.__init__" title="Permalink to this definition"></a></dt>
<dd><p>This constructor creates a plant with a single “world” body.
Therefore, right after creation, num_bodies() returns one.</p>
<p>MultibodyPlant offers two different modalities to model mechanical
systems in time. These are: 1. As a discrete system with periodic
updates, <code class="docutils literal notranslate"><span class="pre">time_step</span></code> is strictly greater than zero. 2. As a
continuous system, <code class="docutils literal notranslate"><span class="pre">time_step</span></code> equals exactly zero.</p>
<p>Currently the discrete model is preferred for simulation given its
robustness and speed in problems with frictional contact. However this
might change as we work towards developing better strategies to model
contact. See time_advancement_strategy “Choice of Time Advancement
Strategy” for further details.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Users should be aware of current limitations in either modeling
modality. While the discrete model is often the preferred option
for problems with frictional contact given its robustness and
speed, it might become unstable when using large feedback gains,
high damping or large external forcing. MultibodyPlant will throw
an exception whenever the discrete solver is detected to fail.
Conversely, the continuous modality has the potential to leverage
the robustness and accuracy control provide by Drake’s
integrators. However thus far this has proved difficult in
practice and especially due to poor performance.</p>
</div>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">time_step</span></code>:</dt><dd><p>Indicates whether <code class="docutils literal notranslate"><span class="pre">this</span></code> plant is modeled as a continuous system
(<code class="docutils literal notranslate"><span class="pre">time_step</span> <span class="pre">=</span> <span class="pre">0</span></code>) or as a discrete system with periodic updates
of period <code class="docutils literal notranslate"><span class="pre">time_step</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>. See time_advancement_strategy “Choice
of Time Advancement Strategy” for further details.</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Currently the continuous modality with <code class="docutils literal notranslate"><span class="pre">time_step</span> <span class="pre">=</span> <span class="pre">0</span></code> does not
support joint limits for simulation, these are ignored.
MultibodyPlant prints a warning to console if joint limits are
provided. If your simulation requires joint limits currently you
must use a discrete MultibodyPlant model.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if time_step is negative.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.AddBallConstraint">
<span class="sig-name descname"><span class="pre">AddBallConstraint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">body_A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody" title="pydrake.multibody.tree.RigidBody"><span class="pre">pydrake.multibody.tree.RigidBody</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_AP</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody" title="pydrake.multibody.tree.RigidBody"><span class="pre">pydrake.multibody.tree.RigidBody</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_BQ</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.MultibodyConstraintId" title="pydrake.multibody.tree.MultibodyConstraintId"><span class="pre">pydrake.multibody.tree.MultibodyConstraintId</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.AddBallConstraint" title="Permalink to this definition"></a></dt>
<dd><p>Defines a constraint such that point P affixed to body A is coincident
at all times with point Q affixed to body B, effectively modeling a
ball-and-socket joint.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body_A</span></code>:</dt><dd><p>RigidBody to which point P is rigidly attached.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_AP</span></code>:</dt><dd><p>Position of point P in body A’s frame.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body_B</span></code>:</dt><dd><p>RigidBody to which point Q is rigidly attached.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BQ</span></code>:</dt><dd><p>Position of point Q in body B’s frame.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the id of the newly added constraint.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>RuntimeError if bodies A and B are the same body.</strong> – </p></li>
<li><p><strong>RuntimeError if the MultibodyPlant has already been finalized.</strong> – </p></li>
<li><p><strong>RuntimeError if this MultibodyPlant is not a discrete model</strong> – </p></li>
<li><p><strong>(</strong><strong>is_discrete</strong><strong>(</strong><strong>) </strong><strong>== false</strong><strong>)</strong> – </p></li>
<li><p><strong>RuntimeError if this MultibodyPlant's underlying contact</strong> – </p></li>
<li><p><strong>solver is not SAP.</strong><strong> (</strong><strong>i.e. get_discrete_contact_solver</strong><strong>(</strong><strong>) </strong><strong>!=</strong> – </p></li>
<li><p><strong>DiscreteContactSolver::kSap</strong><strong>)</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.AddCouplerConstraint">
<span class="sig-name descname"><span class="pre">AddCouplerConstraint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">joint0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Joint" title="pydrake.multibody.tree.Joint"><span class="pre">pydrake.multibody.tree.Joint</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">joint1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Joint" title="pydrake.multibody.tree.Joint"><span class="pre">pydrake.multibody.tree.Joint</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">gear_ratio</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.0</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.MultibodyConstraintId" title="pydrake.multibody.tree.MultibodyConstraintId"><span class="pre">pydrake.multibody.tree.MultibodyConstraintId</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.AddCouplerConstraint" title="Permalink to this definition"></a></dt>
<dd><p>Defines a holonomic constraint between two single-dof joints
<code class="docutils literal notranslate"><span class="pre">joint0</span></code> and <code class="docutils literal notranslate"><span class="pre">joint1</span></code> with positions q₀ and q₁, respectively, such
that q₀ = ρ⋅q₁ + Δq, where ρ is the gear ratio and Δq is a fixed
offset. The gear ratio can have units if the units of q₀ and q₁ are
different. For instance, between a prismatic and a revolute joint the
gear ratio will specify the “pitch” of the resulting mechanism. As
defined, <code class="docutils literal notranslate"><span class="pre">offset</span></code> has units of <code class="docutils literal notranslate"><span class="pre">q₀</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>joint0 and/or joint1 can still be actuated, regardless of whether
we have coupler constraint among them. That is, one or both of
these joints can have external actuation applied to them.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Generally, to couple (q0, q1, q2), the user would define a coupler
between (q0, q1) and a second coupler between (q1, q2), or any
combination therein.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>if joint0 and joint1 are not both single-dof joints.</strong> – </p></li>
<li><p><strong>RuntimeError if the MultibodyPlant has already been finalized.</strong> – </p></li>
<li><p><strong>RuntimeError if this MultibodyPlant is not a discrete model</strong> – </p></li>
<li><p><strong>(</strong><strong>is_discrete</strong><strong>(</strong><strong>) </strong><strong>== false</strong><strong>)</strong> – </p></li>
<li><p><strong>RuntimeError if this MultibodyPlant's underlying contact</strong> – </p></li>
<li><p><strong>solver is not SAP.</strong><strong> (</strong><strong>i.e. get_discrete_contact_solver</strong><strong>(</strong><strong>) </strong><strong>!=</strong> – </p></li>
<li><p><strong>DiscreteContactSolver::kSap</strong><strong>)</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.AddDistanceConstraint">
<span class="sig-name descname"><span class="pre">AddDistanceConstraint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">body_A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody" title="pydrake.multibody.tree.RigidBody"><span class="pre">pydrake.multibody.tree.RigidBody</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_AP</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody" title="pydrake.multibody.tree.RigidBody"><span class="pre">pydrake.multibody.tree.RigidBody</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_BQ</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stiffness</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">inf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">damping</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.0</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.MultibodyConstraintId" title="pydrake.multibody.tree.MultibodyConstraintId"><span class="pre">pydrake.multibody.tree.MultibodyConstraintId</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.AddDistanceConstraint" title="Permalink to this definition"></a></dt>
<dd><p>Defines a distance constraint between a point P on a body A and a
point Q on a body B.</p>
<p>This constraint can be compliant, modeling a spring with free length
<code class="docutils literal notranslate"><span class="pre">distance</span></code> and given <code class="docutils literal notranslate"><span class="pre">stiffness</span></code> and <code class="docutils literal notranslate"><span class="pre">damping</span></code> parameters
between points P and Q. For d = ‖p_PQ‖, then a compliant distance
constraint models a spring with force along p_PQ given by:</p>
<p>f = −stiffness ⋅ d − damping ⋅ ḋ</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body_A</span></code>:</dt><dd><p>RigidBody to which point P is rigidly attached.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_AP</span></code>:</dt><dd><p>Position of point P in body A’s frame.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body_B</span></code>:</dt><dd><p>RigidBody to which point Q is rigidly attached.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BQ</span></code>:</dt><dd><p>Position of point Q in body B’s frame.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">distance</span></code>:</dt><dd><p>Fixed length of the distance constraint, in meters. It must be
strictly positive.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">stiffness</span></code>:</dt><dd><p>For modeling a spring with free length equal to <code class="docutils literal notranslate"><span class="pre">distance</span></code>, the
stiffness parameter in N/m. Optional, with its default value being
infinite to model a rigid massless rod of length <code class="docutils literal notranslate"><span class="pre">distance</span></code>
connecting points A and B.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">damping</span></code>:</dt><dd><p>For modeling a spring with free length equal to <code class="docutils literal notranslate"><span class="pre">distance</span></code>,
damping parameter in N⋅s/m. Optional, with its default value being
zero for a non-dissipative constraint.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the id of the newly added constraint.</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Currently, it is the user’s responsibility to initialize the
model’s context in a configuration compatible with the newly added
constraint.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>A distance constraint is the wrong modeling choice if the distance
needs to go through zero. To constrain two points to be coincident
we need a 3-dof ball constraint, the 1-dof distance constraint is
singular in this case. Therefore we require the distance parameter
to be strictly positive.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if bodies A and B are the same body.</strong> – </p></li>
<li><p><strong>RuntimeError if distance is not strictly positive.</strong> – </p></li>
<li><p><strong>RuntimeError if stiffness is not positive</strong><strong> or </strong><strong>zero.</strong> – </p></li>
<li><p><strong>RuntimeError if damping is not positive</strong><strong> or </strong><strong>zero.</strong> – </p></li>
<li><p><strong>RuntimeError if the MultibodyPlant has already been finalized.</strong> – </p></li>
<li><p><strong>RuntimeError if this MultibodyPlant is not a discrete model</strong> – </p></li>
<li><p><strong>(</strong><strong>is_discrete</strong><strong>(</strong><strong>) </strong><strong>== false</strong><strong>)</strong> – </p></li>
<li><p><strong>RuntimeError if this MultibodyPlant's underlying contact</strong> – </p></li>
<li><p><strong>solver is not SAP.</strong><strong> (</strong><strong>i.e. get_discrete_contact_solver</strong><strong>(</strong><strong>) </strong><strong>!=</strong> – </p></li>
<li><p><strong>DiscreteContactSolver::kSap</strong><strong>)</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.AddForceElement">
<span class="sig-name descname"><span class="pre">AddForceElement</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">force_element</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ForceElement" title="pydrake.multibody.tree.ForceElement"><span class="pre">pydrake.multibody.tree.ForceElement</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ForceElement" title="pydrake.multibody.tree.ForceElement"><span class="pre">pydrake.multibody.tree.ForceElement</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.AddForceElement" title="Permalink to this definition"></a></dt>
<dd><p>Adds a new force element model of type <code class="docutils literal notranslate"><span class="pre">ForceElementType</span></code> to
<code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant. The arguments to this method <code class="docutils literal notranslate"><span class="pre">args</span></code> are
forwarded to <a href="#id23"><span class="problematic" id="id24">``</span></a>ForceElementType`’s constructor.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">args</span></code>:</dt><dd><p>Zero or more parameters provided to the constructor of the new
force element. It must be the case that
<cite>ForceElementType&lt;T&gt;(args)`</cite> is a valid constructor.</p>
</dd>
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">ForceElementType</span></code>:</dt><dd><p>The type of the ForceElement to add. As there is always a
UniformGravityFieldElement present (accessible through
gravity_field()), an exception will be thrown if this function is
called to add another UniformGravityFieldElement.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A constant reference to the new ForceElement just added, of type
<code class="docutils literal notranslate"><span class="pre">ForceElementType&lt;T&gt;</span></code> specialized on the scalar type T of
<code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant. It will remain valid for the lifetime of
<code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>The ForceElement class’s documentation for further details on how
a force element is defined.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.AddFrame">
<span class="sig-name descname"><span class="pre">AddFrame</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame" title="pydrake.multibody.tree.Frame"><span class="pre">pydrake.multibody.tree.Frame</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame" title="pydrake.multibody.tree.Frame"><span class="pre">pydrake.multibody.tree.Frame</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.AddFrame" title="Permalink to this definition"></a></dt>
<dd><p>This method adds a Frame of type <code class="docutils literal notranslate"><span class="pre">FrameType&lt;T&gt;</span></code>. For more
information, please see the corresponding constructor of
<code class="docutils literal notranslate"><span class="pre">FrameType</span></code>.</p>
<dl class="simple">
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">FrameType</span></code>:</dt><dd><p>Template which will be instantiated on <code class="docutils literal notranslate"><span class="pre">T</span></code>.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame</span></code>:</dt><dd><p>Unique pointer frame instance.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A constant reference to the new Frame just added, which will
remain valid for the lifetime of <code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.AddJoint">
<span class="sig-name descname"><span class="pre">AddJoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">joint</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Joint" title="pydrake.multibody.tree.Joint"><span class="pre">pydrake.multibody.tree.Joint</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Joint" title="pydrake.multibody.tree.Joint"><span class="pre">pydrake.multibody.tree.Joint</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.AddJoint" title="Permalink to this definition"></a></dt>
<dd><p>This method adds a Joint of type <code class="docutils literal notranslate"><span class="pre">JointType</span></code> between two bodies. For
more information, see the below overload of <code class="docutils literal notranslate"><span class="pre">AddJoint&lt;&gt;</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.AddJointActuator">
<span class="sig-name descname"><span class="pre">AddJointActuator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">joint</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Joint" title="pydrake.multibody.tree.Joint"><span class="pre">pydrake.multibody.tree.Joint</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">effort_limit</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">inf</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JointActuator" title="pydrake.multibody.tree.JointActuator"><span class="pre">pydrake.multibody.tree.JointActuator</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.AddJointActuator" title="Permalink to this definition"></a></dt>
<dd><p>Creates and adds a JointActuator model for an actuator acting on a
given <code class="docutils literal notranslate"><span class="pre">joint</span></code>. This method returns a constant reference to the
actuator just added, which will remain valid for the lifetime of
<code class="docutils literal notranslate"><span class="pre">this</span></code> plant.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">name</span></code>:</dt><dd><p>A string that uniquely identifies the new actuator to be added to
<code class="docutils literal notranslate"><span class="pre">this</span></code> model. A RuntimeError is thrown if an actuator with the
same name already exists in the model. See
HasJointActuatorNamed().</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">joint</span></code>:</dt><dd><p>The Joint to be actuated by the new JointActuator.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">effort_limit</span></code>:</dt><dd><p>The maximum effort for the actuator. It must be strictly positive,
otherwise an RuntimeError is thrown. If +∞, the actuator has no
limit, which is the default. The effort limit has physical units
in accordance to the joint type it actuates. For instance, it will
have units of N⋅m (torque) for revolute joints while it will have
units of N (force) for prismatic joints.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The effort limit is unused by MultibodyPlant and is simply
provided here for bookkeeping purposes. It will not, for instance,
saturate external actuation inputs based on this value. If, for
example, a user intends to saturate the force/torque that is
applied to the MultibodyPlant via this actuator, the user-level
code (e.g., a controller) should query this effort limit and
impose the saturation there.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A constant reference to the new JointActuator just added, which
will remain valid for the lifetime of <code class="docutils literal notranslate"><span class="pre">this</span></code> plant or until the
JointActuator has been removed from the plant with
RemoveJointActuator().</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>RuntimeError if joint.num_velocities</strong><strong>(</strong><strong>) </strong><strong>&gt; 1 since for now we</strong> – </p></li>
<li><p><strong>only support actuators for single dof joints.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>RemoveJointActuator()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.AddModelInstance">
<span class="sig-name descname"><span class="pre">AddModelInstance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.AddModelInstance" title="Permalink to this definition"></a></dt>
<dd><p>Creates a new model instance. Returns the index for the model
instance.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">name</span></code>:</dt><dd><p>A string that uniquely identifies the new instance to be added to
<code class="docutils literal notranslate"><span class="pre">this</span></code> model. An exception is thrown if an instance with the
same name already exists in the model. See
HasModelInstanceNamed().</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.AddPhysicalModel">
<span class="sig-name descname"><span class="pre">AddPhysicalModel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">model</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.PhysicalModel" title="pydrake.multibody.plant.PhysicalModel"><span class="pre">pydrake.multibody.plant.PhysicalModel</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.AddPhysicalModel" title="Permalink to this definition"></a></dt>
<dd><p>For use only by advanced developers wanting to try out their new
physical models.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This feature is considered to be <strong>experimental</strong> and may change
or be removed at any time, without any deprecation notice ahead of
time.</p>
</div>
<p>With this method MultibodyPlant takes ownership of <code class="docutils literal notranslate"><span class="pre">model</span></code> and calls
its DeclareSystemResources() method at Finalize(), giving specific
physical model implementations a chance to declare the system
resources it needs. Each type of PhysicalModel can be added at most
once.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">model</span></code>:</dt><dd><p>After this call the model is owned by <code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant.</p>
</dd>
<dt>Precondition:</dt><dd><p>model != nullptr.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if called post-finalize. See Finalize</strong><strong>(</strong><strong>)</strong><strong></strong> – </p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant will no longer support scalar conversion
to or from symbolic::Expression after a call to this method.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.AddRigidBody">
<span class="sig-name descname"><span class="pre">AddRigidBody</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.AddRigidBody" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>AddRigidBody(self: pydrake.multibody.plant.MultibodyPlant, name: str, M_BBo_B: pydrake.multibody.tree.SpatialInertia = &lt;pydrake.multibody.tree.SpatialInertia object at 0x7f14401a6df0&gt;) -&gt; pydrake.multibody.tree.RigidBody</p></li>
</ol>
<p>Creates a rigid body with the provided name and spatial inertia. This
method returns a constant reference to the body just added, which will
remain valid for the lifetime of <code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant. The body
will use the default model instance (model_instance “more on model
instances”).</p>
<p>Example of usage:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">plant</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="c1">// ... Code to define spatial_inertia, a SpatialInertia&lt;T&gt; object ...</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">RigidBody</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">body</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">    </span><span class="n">plant</span><span class="p">.</span><span class="n">AddRigidBody</span><span class="p">(</span><span class="s">&quot;BodyName&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">spatial_inertia</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</details><dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">name</span></code>:</dt><dd><p>A string that identifies the new body to be added to <code class="docutils literal notranslate"><span class="pre">this</span></code>
model. A RuntimeError is thrown if a body named <code class="docutils literal notranslate"><span class="pre">name</span></code> already
is part of the model in the default model instance. See
HasBodyNamed(), RigidBody::name().</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">M_BBo_B</span></code>:</dt><dd><p>The SpatialInertia of the new rigid body to be added to <code class="docutils literal notranslate"><span class="pre">this</span></code>
MultibodyPlant, computed about the body frame origin <code class="docutils literal notranslate"><span class="pre">Bo</span></code> and
expressed in the body frame B. When not provided, defaults to
zero.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A constant reference to the new RigidBody just added, which will
remain valid for the lifetime of <code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>RuntimeError if additional model instances have been created</strong> – </p></li>
<li><p><strong>beyond the world and default instances.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>AddRigidBody(self: pydrake.multibody.plant.MultibodyPlant, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex, M_BBo_B: pydrake.multibody.tree.SpatialInertia = &lt;pydrake.multibody.tree.SpatialInertia object at 0x7f14401b7770&gt;) -&gt; pydrake.multibody.tree.RigidBody</p></li>
</ol>
<p>Creates a rigid body with the provided name and spatial inertia. This
method returns a constant reference to the body just added, which will
remain valid for the lifetime of <code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant.</p>
<p>Example of usage:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">plant</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="c1">// ... Code to define spatial_inertia, a SpatialInertia&lt;T&gt; object ...</span>
<span class="w">  </span><span class="n">ModelInstanceIndex</span><span class="w"> </span><span class="n">model_instance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">plant</span><span class="p">.</span><span class="n">AddModelInstance</span><span class="p">(</span><span class="s">&quot;instance&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">RigidBody</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">body</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">    </span><span class="n">plant</span><span class="p">.</span><span class="n">AddRigidBody</span><span class="p">(</span><span class="s">&quot;BodyName&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">model_instance</span><span class="p">,</span><span class="w"> </span><span class="n">spatial_inertia</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</details><dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">name</span></code>:</dt><dd><p>A string that identifies the new body to be added to <code class="docutils literal notranslate"><span class="pre">this</span></code>
model. A RuntimeError is thrown if a body named <code class="docutils literal notranslate"><span class="pre">name</span></code> already
is part of <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>. See HasBodyNamed(),
RigidBody::name().</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>:</dt><dd><p>A model instance index which this body is part of.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">M_BBo_B</span></code>:</dt><dd><p>The SpatialInertia of the new rigid body to be added to <code class="docutils literal notranslate"><span class="pre">this</span></code>
MultibodyPlant, computed about the body frame origin <code class="docutils literal notranslate"><span class="pre">Bo</span></code> and
expressed in the body frame B. When not provided, defaults to
zero.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A constant reference to the new RigidBody just added, which will
remain valid for the lifetime of <code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.AddWeldConstraint">
<span class="sig-name descname"><span class="pre">AddWeldConstraint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">body_A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody" title="pydrake.multibody.tree.RigidBody"><span class="pre">pydrake.multibody.tree.RigidBody</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">X_AP</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.math.html#pydrake.math.RigidTransform" title="pydrake.math.RigidTransform"><span class="pre">pydrake.math.RigidTransform</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">body_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody" title="pydrake.multibody.tree.RigidBody"><span class="pre">pydrake.multibody.tree.RigidBody</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">X_BQ</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.math.html#pydrake.math.RigidTransform" title="pydrake.math.RigidTransform"><span class="pre">pydrake.math.RigidTransform</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.MultibodyConstraintId" title="pydrake.multibody.tree.MultibodyConstraintId"><span class="pre">pydrake.multibody.tree.MultibodyConstraintId</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.AddWeldConstraint" title="Permalink to this definition"></a></dt>
<dd><p>Defines a constraint such that frame P affixed to body A is coincident
at all times with frame Q affixed to body B, effectively modeling a
weld joint.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body_A</span></code>:</dt><dd><p>RigidBody to which frame P is rigidly attached.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">X_AP</span></code>:</dt><dd><p>Pose of frame P in body A’s frame.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body_B</span></code>:</dt><dd><p>RigidBody to which frame Q is rigidly attached.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">X_BQ</span></code>:</dt><dd><p>Pose of frame Q in body B’s frame.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the id of the newly added constraint.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>RuntimeError if bodies A and B are the same body.</strong> – </p></li>
<li><p><strong>RuntimeError if the MultibodyPlant has already been finalized.</strong> – </p></li>
<li><p><strong>RuntimeError if this MultibodyPlant is not a discrete model</strong> – </p></li>
<li><p><strong>(</strong><strong>is_discrete</strong><strong>(</strong><strong>) </strong><strong>== false</strong><strong>)</strong> – </p></li>
<li><p><strong>RuntimeError if this MultibodyPlant's underlying contact</strong> – </p></li>
<li><p><strong>solver is not SAP.</strong><strong> (</strong><strong>i.e. get_discrete_contact_solver</strong><strong>(</strong><strong>) </strong><strong>!=</strong> – </p></li>
<li><p><strong>DiscreteContactSolver::kSap</strong><strong>)</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.CalcBiasCenterOfMassTranslationalAcceleration">
<span class="sig-name descname"><span class="pre">CalcBiasCenterOfMassTranslationalAcceleration</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context" title="pydrake.systems.framework.Context"><span class="pre">pydrake.systems.framework.Context</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_respect_to</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JacobianWrtVariable" title="pydrake.multibody.tree.JacobianWrtVariable"><span class="pre">pydrake.multibody.tree.JacobianWrtVariable</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame" title="pydrake.multibody.tree.Frame"><span class="pre">pydrake.multibody.tree.Frame</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_E</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame" title="pydrake.multibody.tree.Frame"><span class="pre">pydrake.multibody.tree.Frame</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.CalcBiasCenterOfMassTranslationalAcceleration" title="Permalink to this definition"></a></dt>
<dd><p>Calculates abias_ACcm_E, point Ccm’s translational “bias” acceleration
term in frame A with respect to “speeds” 𝑠, expressed in frame E,
where point Ccm is the composite center of mass of the system of all
bodies (except world_body()) in the MultibodyPlant. abias_ACcm is the
part of a_ACcm (Ccm’s translational acceleration) that does not
multiply ṡ, equal to abias_ACcm = J̇𝑠_v_ACcm ⋅ s. This allows a_ACcm
to be written as a_ACcm = J𝑠_v_ACcm ⋅ ṡ + abias_ACcm.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The state of the multibody system.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">with_respect_to</span></code>:</dt><dd><p>Enum equal to JacobianWrtVariable::kQDot or
JacobianWrtVariable::kV, indicating whether the Jacobian
<code class="docutils literal notranslate"><span class="pre">abias_ACcm</span></code> is partial derivatives with respect to 𝑠 = q̇
(time-derivatives of generalized positions) or with respect to 𝑠 =
v (generalized velocities).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_A</span></code>:</dt><dd><p>The frame in which abias_ACcm is measured.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_E</span></code>:</dt><dd><p>The frame in which abias_ACcm is expressed on output.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">abias_ACcm_E</span></code>:</dt><dd><p>Point Ccm’s translational “bias” acceleration term in frame A with
respect to “speeds” 𝑠, expressed in frame E.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if Ccm does not exist</strong><strong>, </strong><strong>which occurs if there are no</strong> – </p></li>
<li><p><strong>massive bodies in MultibodyPlant</strong><strong> (</strong><strong>except world_body</strong><strong>(</strong><strong>)</strong><strong>)</strong><strong></strong> – </p></li>
<li><p><strong>RuntimeError if composite_mass &lt;= 0</strong><strong>, </strong><strong>where composite_mass is the</strong> – </p></li>
<li><p><strong>total mass of all bodies except world_body</strong><strong>(</strong><strong>) </strong><strong>in MultibodyPlant.</strong> – </p></li>
<li><p><strong>RuntimeError if frame_A is not the world frame.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.CalcBiasSpatialAcceleration">
<span class="sig-name descname"><span class="pre">CalcBiasSpatialAcceleration</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context" title="pydrake.systems.framework.Context"><span class="pre">pydrake.systems.framework.Context</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_respect_to</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JacobianWrtVariable" title="pydrake.multibody.tree.JacobianWrtVariable"><span class="pre">pydrake.multibody.tree.JacobianWrtVariable</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame" title="pydrake.multibody.tree.Frame"><span class="pre">pydrake.multibody.tree.Frame</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_BoBp_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame" title="pydrake.multibody.tree.Frame"><span class="pre">pydrake.multibody.tree.Frame</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_E</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame" title="pydrake.multibody.tree.Frame"><span class="pre">pydrake.multibody.tree.Frame</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.math.html#pydrake.multibody.math.SpatialAcceleration" title="pydrake.multibody.math.SpatialAcceleration"><span class="pre">pydrake.multibody.math.SpatialAcceleration</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.CalcBiasSpatialAcceleration" title="Permalink to this definition"></a></dt>
<dd><p>For one point Bp affixed/welded to a frame B, calculates A𝑠Bias_ABp,
Bp’s spatial acceleration bias in frame A with respect to “speeds” 𝑠,
where 𝑠 is either q̇ (time-derivatives of generalized positions) or v
(generalized velocities). A𝑠Bias_ABp is the term in A_ABp (Bp’s
spatial acceleration in A) that does not include 𝑠̇, i.e., A𝑠Bias_ABp
is Bi’s translational acceleration in A when 𝑠̇ = 0.</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>A_ABp =  J𝑠_V_ABp ⋅ 𝑠̇  +  J̇𝑠_V_ABp ⋅ 𝑠   (𝑠 = q̇ or 𝑠 = v), hence
  A𝑠Bias_ABp = J̇𝑠_V_ABp ⋅ 𝑠
</pre></div>
</div>
</details><p>where J𝑠_V_ABp is Bp’s spatial velocity Jacobian in frame A for speeds
s (see CalcJacobianSpatialVelocity() for details on J𝑠_V_ABp).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The state of the multibody system.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">with_respect_to</span></code>:</dt><dd><p>Enum equal to JacobianWrtVariable::kQDot or
JacobianWrtVariable::kV, indicating whether the spatial
accceleration bias is with respect to 𝑠 = q̇ or 𝑠 = v.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_B</span></code>:</dt><dd><p>The frame on which point Bp is affixed/welded.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BoBp_B</span></code>:</dt><dd><p>Position vector from Bo (frame_B’s origin) to point Bp (regarded
as affixed/welded to B), expressed in frame_B.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_A</span></code>:</dt><dd><p>The frame that measures A𝑠Bias_ABp. Currently, an exception is
thrown if frame_A is not the World frame.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_E</span></code>:</dt><dd><p>The frame in which A𝑠Bias_ABp is expressed on output.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A𝑠Bias_ABp_E Point Bp’s spatial acceleration bias in frame A with
respect to speeds 𝑠 (𝑠 = q̇ or 𝑠 = v), expressed in frame E.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Shown below, A𝑠Bias_ABp_E = J̇𝑠_V_ABp ⋅ 𝑠 is quadratic in 𝑠.</p>
</div>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>V_ABp =  J𝑠_V_ABp ⋅ 𝑠        which upon vector differentiation in A gives
 A_ABp =  J𝑠_V_ABp ⋅ 𝑠̇  +  J̇𝑠_V_ABp ⋅ 𝑠   Since J̇𝑠_V_ABp is linear in 𝑠,
 A𝑠Bias_ABp = J̇𝑠_V_ABp ⋅ 𝑠                             is quadratic in 𝑠.
</pre></div>
</div>
</details><div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcJacobianSpatialVelocity() to compute J𝑠_V_ABp, point Bp’s
translational velocity Jacobian in frame A with respect to 𝑠.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if with_respect_to is not JacobianWrtVariable::kV</strong> – </p></li>
<li><p><strong>RuntimeError if frame_A is not the world frame.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.CalcBiasTerm">
<span class="sig-name descname"><span class="pre">CalcBiasTerm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context" title="pydrake.systems.framework.Context"><span class="pre">pydrake.systems.framework.Context</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.CalcBiasTerm" title="Permalink to this definition"></a></dt>
<dd><p>Computes the bias term <code class="docutils literal notranslate"><span class="pre">C(q,</span> <span class="pre">v)v</span></code> containing Coriolis, centripetal,
and gyroscopic effects in the multibody equations of motion:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>M(q) v̇ + C(q, v) v = tau_app + ∑ (Jv_V_WBᵀ(q) ⋅ Fapp_Bo_W)
</pre></div>
</div>
</details><p>where <code class="docutils literal notranslate"><span class="pre">M(q)</span></code> is the multibody model’s mass matrix (including rigid
body mass properties and reflected_inertia “reflected inertias”) and
<code class="docutils literal notranslate"><span class="pre">tau_app</span></code> is a vector of applied generalized forces. The last term
is a summation over all bodies of the dot-product of <code class="docutils literal notranslate"><span class="pre">Fapp_Bo_W</span></code>
(applied spatial force on body B at Bo) with <code class="docutils literal notranslate"><span class="pre">Jv_V_WB(q)</span></code> (B’s
spatial Jacobian in world W with respect to generalized velocities v).
Note: B’s spatial velocity in W can be written <code class="docutils literal notranslate"><span class="pre">V_WB</span> <span class="pre">=</span> <span class="pre">Jv_V_WB</span> <span class="pre">*</span> <span class="pre">v</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context containing the state of the model. It stores the
generalized positions q and the generalized velocities v.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">Cv</span></code>:</dt><dd><p>On output, <code class="docutils literal notranslate"><span class="pre">Cv</span></code> will contain the product <code class="docutils literal notranslate"><span class="pre">C(q,</span> <span class="pre">v)v</span></code>. It must
be a valid (non-null) pointer to a column vector in <code class="docutils literal notranslate"><span class="pre">ℛⁿ</span></code> with n
the number of generalized velocities (num_velocities()) of the
model. This method aborts if Cv is nullptr or if it does not have
the proper size.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.CalcBiasTranslationalAcceleration">
<span class="sig-name descname"><span class="pre">CalcBiasTranslationalAcceleration</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context" title="pydrake.systems.framework.Context"><span class="pre">pydrake.systems.framework.Context</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_respect_to</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JacobianWrtVariable" title="pydrake.multibody.tree.JacobianWrtVariable"><span class="pre">pydrake.multibody.tree.JacobianWrtVariable</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame" title="pydrake.multibody.tree.Frame"><span class="pre">pydrake.multibody.tree.Frame</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_BoBi_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.f_contiguous</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame" title="pydrake.multibody.tree.Frame"><span class="pre">pydrake.multibody.tree.Frame</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_E</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame" title="pydrake.multibody.tree.Frame"><span class="pre">pydrake.multibody.tree.Frame</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.CalcBiasTranslationalAcceleration" title="Permalink to this definition"></a></dt>
<dd><p>For each point Bi affixed/welded to a frame B, calculates a𝑠Bias_ABi,
Bi’s translational acceleration bias in frame A with respect to
“speeds” 𝑠, where 𝑠 is either q̇ (time-derivatives of generalized
positions) or v (generalized velocities). a𝑠Bias_ABi is the term in
a_ABi (Bi’s translational acceleration in A) that does not include 𝑠̇,
i.e., a𝑠Bias_ABi is Bi’s translational acceleration in A when 𝑠̇ = 0.</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>a_ABi =  J𝑠_v_ABi ⋅ 𝑠̇  +  J̇𝑠_v_ABi ⋅ 𝑠  (𝑠 = q̇ or 𝑠 = v), hence
  a𝑠Bias_ABi = J̇𝑠_v_ABi ⋅ 𝑠
</pre></div>
</div>
</details><p>where J𝑠_v_ABi is Bi’s translational velocity Jacobian in frame A for
s (see CalcJacobianTranslationalVelocity() for details on J𝑠_v_ABi).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The state of the multibody system.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">with_respect_to</span></code>:</dt><dd><p>Enum equal to JacobianWrtVariable::kQDot or
JacobianWrtVariable::kV, indicating whether the translational
acceleration bias is with respect to 𝑠 = q̇ or 𝑠 = v.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_B</span></code>:</dt><dd><p>The frame on which points Bi are affixed/welded.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BoBi_B</span></code>:</dt><dd><p>A position vector or list of p position vectors from Bo (frame_B’s
origin) to points Bi (regarded as affixed to B), where each
position vector is expressed in frame_B. Each column in the <code class="docutils literal notranslate"><span class="pre">3</span> <span class="pre">x</span>
<span class="pre">p</span></code> matrix p_BoBi_B corresponds to a position vector.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_A</span></code>:</dt><dd><p>The frame that measures a𝑠Bias_ABi. Currently, an exception is
thrown if frame_A is not the World frame.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_E</span></code>:</dt><dd><p>The frame in which a𝑠Bias_ABi is expressed on output.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a𝑠Bias_ABi_E Point Bi’s translational acceleration bias in frame A
with respect to speeds 𝑠 (𝑠 = q̇ or 𝑠 = v), expressed in frame E.
a𝑠Bias_ABi_E is a <code class="docutils literal notranslate"><span class="pre">3</span> <span class="pre">x</span> <span class="pre">p</span></code> matrix, where p is the number of
points Bi.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Shown below, a𝑠Bias_ABi_E = J̇𝑠_v_ABp ⋅ 𝑠 is quadratic in 𝑠.</p>
</div>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>v_ABi =  J𝑠_v_ABi ⋅ 𝑠        which upon vector differentiation in A gives
 a_ABi =  J𝑠_v_ABi ⋅ 𝑠̇ + J̇𝑠_v_ABi ⋅ 𝑠     Since J̇𝑠_v_ABi is linear in 𝑠,
 a𝑠Bias_ABi = J̇𝑠_v_ABi ⋅ 𝑠                             is quadratic in 𝑠.
</pre></div>
</div>
</details><div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcJacobianTranslationalVelocity() to compute J𝑠_v_ABi, point
Bi’s translational velocity Jacobian in frame A with respect to 𝑠.</p>
</div>
<dl class="simple">
<dt>Precondition:</dt><dd><p>p_BoBi_B must have 3 rows.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if with_respect_to is not JacobianWrtVariable::kV</strong> – </p></li>
<li><p><strong>RuntimeError if frame_A is not the world frame.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.CalcCenterOfMassPositionInWorld">
<span class="sig-name descname"><span class="pre">CalcCenterOfMassPositionInWorld</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.CalcCenterOfMassPositionInWorld" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>CalcCenterOfMassPositionInWorld(self: pydrake.multibody.plant.MultibodyPlant, context: pydrake.systems.framework.Context) -&gt; numpy.ndarray[numpy.float64[3, 1]]</p></li>
</ol>
<p>Calculates the position vector from the world origin Wo to the center
of mass of all bodies in this MultibodyPlant, expressed in the world
frame W.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>Contains the state of the model.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">p_WoScm_W</span></code>:</dt><dd><p>position vector from Wo to Scm expressed in world frame W, where
Scm is the center of mass of the system S stored by <code class="docutils literal notranslate"><span class="pre">this</span></code>
plant.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if this has no body except world_body</strong><strong>(</strong><strong>)</strong><strong></strong> – </p></li>
<li><p><strong>RuntimeError if mₛ ≤ 0</strong><strong> (</strong><strong>where mₛ is the mass of system S</strong><strong>)</strong><strong></strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The world_body() is ignored. p_WoScm_W = ∑ (mᵢ pᵢ) / mₛ, where mₛ
= ∑ mᵢ, mᵢ is the mass of the iᵗʰ body, and pᵢ is Bcm’s position
vector from Wo expressed in frame W (Bcm is the center of mass of
the iᵗʰ body).</p>
</div>
<ol class="arabic simple" start="2">
<li><p>CalcCenterOfMassPositionInWorld(self: pydrake.multibody.plant.MultibodyPlant, context: pydrake.systems.framework.Context, model_instances: List[pydrake.multibody.tree.ModelInstanceIndex]) -&gt; numpy.ndarray[numpy.float64[3, 1]]</p></li>
</ol>
<p>Calculates the position vector from the world origin Wo to the center
of mass of all non-world bodies contained in model_instances,
expressed in the world frame W.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>Contains the state of the model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">model_instances</span></code>:</dt><dd><p>Vector of selected model instances. If a model instance is
repeated in the vector (unusual), it is only counted once.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">p_WoScm_W</span></code>:</dt><dd><p>position vector from world origin Wo to Scm expressed in the world
frame W, where Scm is the center of mass of the system S of
non-world bodies contained in model_instances.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if model_instances is empty</strong><strong> or </strong><strong>only has world body.</strong> – </p></li>
<li><p><strong>RuntimeError if mₛ ≤ 0</strong><strong> (</strong><strong>where mₛ is the mass of system S</strong><strong>)</strong><strong></strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The world_body() is ignored. p_WoScm_W = ∑ (mᵢ pᵢ) / mₛ, where mₛ
= ∑ mᵢ, mᵢ is the mass of the iᵗʰ body contained in
model_instances, and pᵢ is Bcm’s position vector from Wo expressed
in frame W (Bcm is the center of mass of the iᵗʰ body).</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.CalcForceElementsContribution">
<span class="sig-name descname"><span class="pre">CalcForceElementsContribution</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context" title="pydrake.systems.framework.Context"><span class="pre">pydrake.systems.framework.Context</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">forces</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.MultibodyForces" title="pydrake.multibody.tree.MultibodyForces"><span class="pre">pydrake.multibody.tree.MultibodyForces</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.CalcForceElementsContribution" title="Permalink to this definition"></a></dt>
<dd><p>Computes the combined force contribution of ForceElement objects in
the model. A ForceElement can apply forces as a spatial force per body
or as generalized forces, depending on the ForceElement model.
ForceElement contributions are a function of the state and time only.
The output from this method can immediately be used as input to
CalcInverseDynamics() to include the effect of applied forces by force
elements.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context containing the state of this model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">forces</span></code>:</dt><dd><p>A pointer to a valid, non nullptr, multibody forces object. On
output <code class="docutils literal notranslate"><span class="pre">forces</span></code> will store the forces exerted by all the
ForceElement objects in the model.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if forces is null</strong><strong> or </strong><strong>not compatible with this</strong> – </p></li>
<li><p><strong>model</strong><strong>, </strong><strong>per MultibodyForces::CheckInvariants</strong><strong>(</strong><strong>)</strong><strong></strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.CalcGeneralizedForces">
<span class="sig-name descname"><span class="pre">CalcGeneralizedForces</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context" title="pydrake.systems.framework.Context"><span class="pre">pydrake.systems.framework.Context</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">forces</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.MultibodyForces" title="pydrake.multibody.tree.MultibodyForces"><span class="pre">pydrake.multibody.tree.MultibodyForces</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.CalcGeneralizedForces" title="Permalink to this definition"></a></dt>
<dd><p>Computes the generalized forces result of a set of MultibodyForces
applied to this model.</p>
<p>MultibodyForces stores applied forces as both generalized forces τ and
spatial forces F on each body, refer to documentation in
MultibodyForces for details. Users of MultibodyForces will use
MultibodyForces::mutable_generalized_forces() to mutate the stored
generalized forces directly and will use
RigidBody::AddInForceInWorld() to append spatial forces.</p>
<p>For a given set of forces stored as MultibodyForces, this method will
compute the total generalized forces on this model. More precisely, if
J_WBo is the Jacobian (with respect to velocities) for this model,
including all bodies, then this method computes:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>τᵣₑₛᵤₗₜ = τ + J_WBo⋅F
</pre></div>
</div>
</details><dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>Context that stores the state of the model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">forces</span></code>:</dt><dd><p>Set of multibody forces, including both generalized forces and
per-body spatial forces.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">generalized_forces</span></code>:</dt><dd><p>The total generalized forces on the model that would result from
applying <code class="docutils literal notranslate"><span class="pre">forces</span></code>. In other words, <code class="docutils literal notranslate"><span class="pre">forces</span></code> can be replaced by
the equivalent <code class="docutils literal notranslate"><span class="pre">generalized_forces</span></code>. On output,
<code class="docutils literal notranslate"><span class="pre">generalized_forces</span></code> is resized to num_velocities().</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if forces is null</strong><strong> or </strong><strong>not compatible with this</strong> – </p></li>
<li><p><strong>model.</strong> – </p></li>
<li><p><strong>RuntimeError if generalized_forces is not a valid non-null</strong> – </p></li>
<li><p><strong>pointer.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.CalcGravityGeneralizedForces">
<span class="sig-name descname"><span class="pre">CalcGravityGeneralizedForces</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context" title="pydrake.systems.framework.Context"><span class="pre">pydrake.systems.framework.Context</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.CalcGravityGeneralizedForces" title="Permalink to this definition"></a></dt>
<dd><p>Computes the generalized forces <code class="docutils literal notranslate"><span class="pre">tau_g(q)</span></code> due to gravity as a
function of the generalized positions <code class="docutils literal notranslate"><span class="pre">q</span></code> stored in the input
<code class="docutils literal notranslate"><span class="pre">context</span></code>. The vector of generalized forces due to gravity
<code class="docutils literal notranslate"><span class="pre">tau_g(q)</span></code> is defined such that it appears on the right hand side of
the equations of motion together with any other generalized forces,
like so:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>Mv̇ + C(q, v)v = tau_g(q) + tau_app
</pre></div>
</div>
</details><p>where <code class="docutils literal notranslate"><span class="pre">tau_app</span></code> includes any other generalized forces applied on the
system.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context storing the state of the model.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>tau_g A vector containing the generalized forces due to gravity.
The generalized forces are consistent with the vector of
generalized velocities <code class="docutils literal notranslate"><span class="pre">v</span></code> for <code class="docutils literal notranslate"><span class="pre">this</span></code> so that the inner
product <code class="docutils literal notranslate"><span class="pre">v⋅tau_g</span></code> corresponds to the power applied by the
gravity forces on the mechanical system. That is, <code class="docutils literal notranslate"><span class="pre">v⋅tau_g</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>
corresponds to potential energy going into the system, as either
mechanical kinetic energy, some other potential energy, or heat,
and therefore to a decrease of the gravitational potential energy.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.CalcInverseDynamics">
<span class="sig-name descname"><span class="pre">CalcInverseDynamics</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context" title="pydrake.systems.framework.Context"><span class="pre">pydrake.systems.framework.Context</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">known_vdot</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">external_forces</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.MultibodyForces" title="pydrake.multibody.tree.MultibodyForces"><span class="pre">pydrake.multibody.tree.MultibodyForces</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.CalcInverseDynamics" title="Permalink to this definition"></a></dt>
<dd><p>Given the state of this model in <code class="docutils literal notranslate"><span class="pre">context</span></code> and a known vector of
generalized accelerations <code class="docutils literal notranslate"><span class="pre">vdot</span></code>, this method computes the set of
generalized forces <code class="docutils literal notranslate"><span class="pre">tau</span></code> that would need to be applied in order to
attain the specified generalized accelerations. Mathematically, this
method computes:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>tau = M(q)v̇ + C(q, v)v - tau_app - ∑ J_WBᵀ(q) Fapp_Bo_W
</pre></div>
</div>
</details><p>where <code class="docutils literal notranslate"><span class="pre">M(q)</span></code> is the model’s mass matrix (including rigid body mass
properties and reflected_inertia “reflected inertias”), <code class="docutils literal notranslate"><span class="pre">C(q,</span> <span class="pre">v)v</span></code>
is the bias term for Coriolis and gyroscopic effects and <code class="docutils literal notranslate"><span class="pre">tau_app</span></code>
consists of a vector applied generalized forces. The last term is a
summation over all bodies in the model where <code class="docutils literal notranslate"><span class="pre">Fapp_Bo_W</span></code> is an
applied spatial force on body B at <code class="docutils literal notranslate"><span class="pre">Bo</span></code> which gets projected into
the space of generalized forces with the transpose of <code class="docutils literal notranslate"><span class="pre">Jv_V_WB(q)</span></code>
(where <code class="docutils literal notranslate"><span class="pre">Jv_V_WB</span></code> is B’s spatial velocity Jacobian in W with respect
to generalized velocities v). Note: B’s spatial velocity in W can be
written as <code class="docutils literal notranslate"><span class="pre">V_WB</span> <span class="pre">=</span> <span class="pre">Jv_V_WB</span> <span class="pre">*</span> <span class="pre">v</span></code>.</p>
<p>This method does not compute explicit expressions for the mass matrix
nor for the bias term, which would be of at least <code class="docutils literal notranslate"><span class="pre">O(n²)</span></code>
complexity, but it implements an <code class="docutils literal notranslate"><span class="pre">O(n)</span></code> Newton-Euler recursive
algorithm, where n is the number of bodies in the model. The explicit
formation of the mass matrix <code class="docutils literal notranslate"><span class="pre">M(q)</span></code> would require the calculation of
<code class="docutils literal notranslate"><span class="pre">O(n²)</span></code> entries while explicitly forming the product <code class="docutils literal notranslate"><span class="pre">C(q,</span> <span class="pre">v)</span> <span class="pre">*</span> <span class="pre">v</span></code>
could require up to <code class="docutils literal notranslate"><span class="pre">O(n³)</span></code> operations (see [Featherstone 1987,
§4]), depending on the implementation. The recursive Newton-Euler
algorithm is the most efficient currently known general method for
solving inverse dynamics [Featherstone 2008].</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context containing the state of the model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">known_vdot</span></code>:</dt><dd><p>A vector with the known generalized accelerations <code class="docutils literal notranslate"><span class="pre">vdot</span></code> for the
full model. Use the provided Joint APIs in order to access entries
into this array.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">external_forces</span></code>:</dt><dd><p>A set of forces to be applied to the system either as body spatial
forces <code class="docutils literal notranslate"><span class="pre">Fapp_Bo_W</span></code> or generalized forces <code class="docutils literal notranslate"><span class="pre">tau_app</span></code>, see
MultibodyForces for details.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the vector of generalized forces that would need to be applied to
the mechanical system in order to achieve the desired acceleration
given by <code class="docutils literal notranslate"><span class="pre">known_vdot</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.CalcJacobianAngularVelocity">
<span class="sig-name descname"><span class="pre">CalcJacobianAngularVelocity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context" title="pydrake.systems.framework.Context"><span class="pre">pydrake.systems.framework.Context</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_respect_to</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JacobianWrtVariable" title="pydrake.multibody.tree.JacobianWrtVariable"><span class="pre">pydrake.multibody.tree.JacobianWrtVariable</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame" title="pydrake.multibody.tree.Frame"><span class="pre">pydrake.multibody.tree.Frame</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame" title="pydrake.multibody.tree.Frame"><span class="pre">pydrake.multibody.tree.Frame</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_E</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame" title="pydrake.multibody.tree.Frame"><span class="pre">pydrake.multibody.tree.Frame</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.CalcJacobianAngularVelocity" title="Permalink to this definition"></a></dt>
<dd><p>Calculates J𝑠_w_AB, a frame B’s angular velocity Jacobian in a frame A
with respect to “speeds” 𝑠.</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>J𝑠_w_AB ≜ [ ∂(w_AB)/∂𝑠₁,  ...  ∂(w_AB)/∂𝑠ₙ ]    (n is j or k)
     w_AB = J𝑠_w_AB ⋅ 𝑠          w_AB is linear in 𝑠 ≜ [𝑠₁ ... 𝑠ₙ]ᵀ
</pre></div>
</div>
</details><p><code class="docutils literal notranslate"><span class="pre">w_AB</span></code> is B’s angular velocity in frame A and “speeds” 𝑠 is either
q̇ ≜ [q̇₁ … q̇ⱼ]ᵀ (time-derivatives of j generalized positions) or v
≜ [v₁ … vₖ]ᵀ (k generalized velocities).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The state of the multibody system.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">with_respect_to</span></code>:</dt><dd><p>Enum equal to JacobianWrtVariable::kQDot or
JacobianWrtVariable::kV, indicating whether the Jacobian
<code class="docutils literal notranslate"><span class="pre">J𝑠_w_AB</span></code> is partial derivatives with respect to 𝑠 = q̇
(time-derivatives of generalized positions) or with respect to 𝑠 =
v (generalized velocities).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_B</span></code>:</dt><dd><p>The frame B in <code class="docutils literal notranslate"><span class="pre">w_AB</span></code> (B’s angular velocity in A).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_A</span></code>:</dt><dd><p>The frame A in <code class="docutils literal notranslate"><span class="pre">w_AB</span></code> (B’s angular velocity in A).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_E</span></code>:</dt><dd><p>The frame in which <code class="docutils literal notranslate"><span class="pre">w_AB</span></code> is expressed on input and the frame in
which the Jacobian <code class="docutils literal notranslate"><span class="pre">J𝑠_w_AB</span></code> is expressed on output.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">J𝑠_w_AB_E</span></code>:</dt><dd><p>Frame B’s angular velocity Jacobian in frame A with respect to
speeds 𝑠 (which is either q̇ or v), expressed in frame E. The
Jacobian is a function of only generalized positions q (which are
pulled from the context). The previous definition shows
<code class="docutils literal notranslate"><span class="pre">J𝑠_w_AB_E</span></code> is a matrix of size <code class="docutils literal notranslate"><span class="pre">3</span> <span class="pre">x</span> <span class="pre">n</span></code>, where n is the number
of elements in 𝑠.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if J𝑠_w_AB_E is nullptr</strong><strong> or </strong><strong>not of size 3 x n.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.CalcJacobianCenterOfMassTranslationalVelocity">
<span class="sig-name descname"><span class="pre">CalcJacobianCenterOfMassTranslationalVelocity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.CalcJacobianCenterOfMassTranslationalVelocity" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>CalcJacobianCenterOfMassTranslationalVelocity(self: pydrake.multibody.plant.MultibodyPlant, context: pydrake.systems.framework.Context, with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_A: pydrake.multibody.tree.Frame, frame_E: pydrake.multibody.tree.Frame) -&gt; numpy.ndarray[numpy.float64[3, n]]</p></li>
</ol>
<p>Calculates J𝑠_v_ACcm_E, point Ccm’s translational velocity Jacobian in
frame A with respect to “speeds” 𝑠, expressed in frame E, where point
CCm is the center of mass of the system of all non-world bodies
contained in <code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>contains the state of the model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">with_respect_to</span></code>:</dt><dd><p>Enum equal to JacobianWrtVariable::kQDot or
JacobianWrtVariable::kV, indicating whether the Jacobian
<code class="docutils literal notranslate"><span class="pre">J𝑠_v_ACcm_E</span></code> is partial derivatives with respect to 𝑠 = q̇
(time-derivatives of generalized positions) or with respect to 𝑠 =
v (generalized velocities).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_A</span></code>:</dt><dd><p>The frame in which the translational velocity v_ACcm and its
Jacobian J𝑠_v_ACcm are measured.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_E</span></code>:</dt><dd><p>The frame in which the Jacobian J𝑠_v_ACcm is expressed on output.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">J𝑠_v_ACcm_E</span></code>:</dt><dd><p>Point Ccm’s translational velocity Jacobian in frame A with
respect to speeds 𝑠 (𝑠 = q̇ or 𝑠 = v), expressed in frame E.
J𝑠_v_ACcm_E is a 3 x n matrix, where n is the number of elements
in 𝑠. The Jacobian is a function of only generalized positions q
(which are pulled from the context).</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if CCm does not exist</strong><strong>, </strong><strong>which occurs if there are no</strong> – </p></li>
<li><p><strong>massive bodies in MultibodyPlant</strong><strong> (</strong><strong>except world_body</strong><strong>(</strong><strong>)</strong><strong>)</strong><strong></strong> – </p></li>
<li><p><strong>RuntimeError if mₛ ≤ 0</strong><strong> (</strong><strong>where mₛ is the mass of all non-world</strong> – </p></li>
<li><p><strong>bodies contained in this MultibodyPlant</strong><strong>)</strong><strong></strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>CalcJacobianCenterOfMassTranslationalVelocity(self: pydrake.multibody.plant.MultibodyPlant, context: pydrake.systems.framework.Context, model_instances: List[pydrake.multibody.tree.ModelInstanceIndex], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_A: pydrake.multibody.tree.Frame, frame_E: pydrake.multibody.tree.Frame) -&gt; numpy.ndarray[numpy.float64[3, n]]</p></li>
</ol>
<p>Calculates J𝑠_v_ACcm_E, point Ccm’s translational velocity Jacobian in
frame A with respect to “speeds” 𝑠, expressed in frame E, where point
CCm is the center of mass of the system of all non-world bodies
contained in model_instances.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>contains the state of the model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">model_instances</span></code>:</dt><dd><p>Vector of selected model instances. If a model instance is
repeated in the vector (unusual), it is only counted once.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">with_respect_to</span></code>:</dt><dd><p>Enum equal to JacobianWrtVariable::kQDot or
JacobianWrtVariable::kV, indicating whether the Jacobian
<code class="docutils literal notranslate"><span class="pre">J𝑠_v_ACcm_E</span></code> is partial derivatives with respect to 𝑠 = q̇
(time-derivatives of generalized positions) or with respect to 𝑠 =
v (generalized velocities).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_A</span></code>:</dt><dd><p>The frame in which the translational velocity v_ACcm and its
Jacobian J𝑠_v_ACcm are measured.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_E</span></code>:</dt><dd><p>The frame in which the Jacobian J𝑠_v_ACcm is expressed on output.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">J𝑠_v_ACcm_E</span></code>:</dt><dd><p>Point Ccm’s translational velocity Jacobian in frame A with
respect to speeds 𝑠 (𝑠 = q̇ or 𝑠 = v), expressed in frame E.
J𝑠_v_ACcm_E is a 3 x n matrix, where n is the number of elements
in 𝑠. The Jacobian is a function of only generalized positions q
(which are pulled from the context).</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if mₛ ≤ 0</strong><strong> (</strong><strong>where mₛ is the mass of all non-world</strong> – </p></li>
<li><p><strong>bodies contained in model_instances</strong><strong>)</strong><strong></strong> – </p></li>
<li><p><strong>RuntimeError if model_instances is empty</strong><strong> or </strong><strong>only has world body.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The world_body() is ignored. <a href="#id139"><span class="problematic" id="id140">J𝑠_v_ACcm_</span></a> = ∑ (mᵢ Jᵢ) / mₛ, where mₛ
= ∑ mᵢ, mᵢ is the mass of the iᵗʰ body contained in
model_instances, and Jᵢ is Bcm’s translational velocity Jacobian
in frame A, expressed in frame E (Bcm is the center of mass of the
iᵗʰ body).</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.CalcJacobianPositionVector">
<span class="sig-name descname"><span class="pre">CalcJacobianPositionVector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context" title="pydrake.systems.framework.Context"><span class="pre">pydrake.systems.framework.Context</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame" title="pydrake.multibody.tree.Frame"><span class="pre">pydrake.multibody.tree.Frame</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_BoBi_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.f_contiguous</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame" title="pydrake.multibody.tree.Frame"><span class="pre">pydrake.multibody.tree.Frame</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_E</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame" title="pydrake.multibody.tree.Frame"><span class="pre">pydrake.multibody.tree.Frame</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.CalcJacobianPositionVector" title="Permalink to this definition"></a></dt>
<dd><p>For each point Bi affixed/welded to a frame B, calculates Jq_p_AoBi,
Bi’s position vector Jacobian in frame A with respect to the
generalized positions q ≜ [q₁ … qₙ]ᵀ as</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>Jq_p_AoBi ≜ [ ᴬ∂(p_AoBi)/∂q₁,  ...  ᴬ∂(p_AoBi)/∂qₙ ]
</pre></div>
</div>
</details><p>where p_AoBi is Bi’s position vector from point Ao (frame A’s origin)
and ᴬ∂(p_AoBi)/∂qᵣ denotes the partial derivative in frame A of p_AoBi
with respect to the generalized position qᵣ, where qᵣ is one of q₁ …
qₙ.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The state of the multibody system.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_B</span></code>:</dt><dd><p>The frame on which point Bi is affixed/welded.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BoBi_B</span></code>:</dt><dd><p>A position vector or list of k position vectors from Bo (frame_B’s
origin) to points Bi (Bi is regarded as affixed to B), where each
position vector is expressed in frame_B.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_A</span></code>:</dt><dd><p>The frame in which partial derivatives are calculated and the
frame in which point Ao is affixed.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_E</span></code>:</dt><dd><p>The frame in which the Jacobian Jq_p_AoBi is expressed on output.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">Jq_p_AoBi_E</span></code>:</dt><dd><p>Point Bi’s position vector Jacobian in frame A with generalized
positions q, expressed in frame E. Jq_p_AoBi_E is a <code class="docutils literal notranslate"><span class="pre">3*k</span> <span class="pre">x</span> <span class="pre">n</span></code>
matrix, where k is the number of points Bi and n is the number of
elements in q. The Jacobian is a function of only generalized
positions q (which are pulled from the context).</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if Jq_p_AoBi_E is nullptr</strong><strong> or </strong><strong>not sized 3*k x n.</strong> – </p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Jq̇_v_ABi = Jq_p_AoBi. In other words, point Bi’s velocity
Jacobian in frame A with respect to q̇ is equal to point Bi’s
position vector Jacobian in frame A with respect to q.</p>
</div>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>[∂(v_ABi)/∂q̇₁, ... ∂(v_ABi)/∂q̇ₙ] = [ᴬ∂(p_AoBi)/∂q₁, ... ᴬ∂(p_AoBi)/∂qₙ]
</pre></div>
</div>
</details><div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcJacobianTranslationalVelocity() for details on Jq̇_v_ABi.
Note: Jq_p_AaBi = Jq_p_AoBi, where point Aa is <em>any</em> point
fixed/welded to frame A, i.e., this calculation’s result is the
same if point Ao is replaced with any point fixed on frame A.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.CalcJacobianSpatialVelocity">
<span class="sig-name descname"><span class="pre">CalcJacobianSpatialVelocity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context" title="pydrake.systems.framework.Context"><span class="pre">pydrake.systems.framework.Context</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_respect_to</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JacobianWrtVariable" title="pydrake.multibody.tree.JacobianWrtVariable"><span class="pre">pydrake.multibody.tree.JacobianWrtVariable</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame" title="pydrake.multibody.tree.Frame"><span class="pre">pydrake.multibody.tree.Frame</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_BoBp_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame" title="pydrake.multibody.tree.Frame"><span class="pre">pydrake.multibody.tree.Frame</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_E</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame" title="pydrake.multibody.tree.Frame"><span class="pre">pydrake.multibody.tree.Frame</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.CalcJacobianSpatialVelocity" title="Permalink to this definition"></a></dt>
<dd><p>For one point Bp fixed/welded to a frame B, calculates J𝑠_V_ABp, Bp’s
spatial velocity Jacobian in frame A with respect to “speeds” 𝑠.</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>J𝑠_V_ABp ≜ [ ∂(V_ABp)/∂𝑠₁,  ...  ∂(V_ABp)/∂𝑠ₙ ]    (n is j or k)
     V_ABp = J𝑠_V_ABp ⋅ 𝑠          V_ABp is linear in 𝑠 ≜ [𝑠₁ ... 𝑠ₙ]ᵀ
</pre></div>
</div>
</details><p><code class="docutils literal notranslate"><span class="pre">V_ABp</span></code> is Bp’s spatial velocity in frame A and “speeds” 𝑠 is either
q̇ ≜ [q̇₁ … q̇ⱼ]ᵀ (time-derivatives of j generalized positions) or v
≜ [v₁ … vₖ]ᵀ (k generalized velocities).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The state of the multibody system.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">with_respect_to</span></code>:</dt><dd><p>Enum equal to JacobianWrtVariable::kQDot or
JacobianWrtVariable::kV, indicating whether the Jacobian
<code class="docutils literal notranslate"><span class="pre">J𝑠_V_ABp</span></code> is partial derivatives with respect to 𝑠 = q̇
(time-derivatives of generalized positions) or with respect to 𝑠 =
v (generalized velocities).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_B</span></code>:</dt><dd><p>The frame on which point Bp is fixed/welded.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BoBp_B</span></code>:</dt><dd><p>A position vector from Bo (frame_B’s origin) to point Bp (regarded
as fixed/welded to B), expressed in frame_B.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_A</span></code>:</dt><dd><p>The frame that measures <code class="docutils literal notranslate"><span class="pre">v_ABp</span></code> (Bp’s velocity in A). Note: It
is natural to wonder why there is no parameter p_AoAp_A (similar
to the parameter p_BoBp_B for frame_B). There is no need for
p_AoAp_A because Bp’s velocity in A is defined as the derivative
in frame A of Bp’s position vector from <em>any</em> point fixed to A.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_E</span></code>:</dt><dd><p>The frame in which <code class="docutils literal notranslate"><span class="pre">v_ABp</span></code> is expressed on input and the frame
in which the Jacobian <code class="docutils literal notranslate"><span class="pre">J𝑠_V_ABp</span></code> is expressed on output.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">J𝑠_V_ABp_E</span></code>:</dt><dd><p>Point Bp’s spatial velocity Jacobian in frame A with respect to
speeds 𝑠 (which is either q̇ or v), expressed in frame E.
<code class="docutils literal notranslate"><span class="pre">J𝑠_V_ABp_E</span></code> is a <code class="docutils literal notranslate"><span class="pre">6</span> <span class="pre">x</span> <span class="pre">n</span></code> matrix, where n is the number of
elements in 𝑠. The Jacobian is a function of only generalized
positions q (which are pulled from the context). Note: The
returned <code class="docutils literal notranslate"><span class="pre">6</span> <span class="pre">x</span> <span class="pre">n</span></code> matrix stores frame B’s angular velocity
Jacobian in A in rows 1-3 and stores point Bp’s translational
velocity Jacobian in A in rows 4-6, i.e.,</p>
</dd>
</dl>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">J𝑠_w_AB_E</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">J𝑠_V_ABp_E</span><span class="p">.</span><span class="n">topRows</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">J𝑠_v_ABp_E</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">J𝑠_V_ABp_E</span><span class="p">.</span><span class="n">bottomRows</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">();</span><span class="w"></span>
</pre></div>
</div>
</details><p>Note: Consider CalcJacobianTranslationalVelocity() for multiple points
fixed to frame B and consider CalcJacobianAngularVelocity() to
calculate frame B’s angular velocity Jacobian.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if J𝑠_V_ABp_E is nullptr</strong><strong> or </strong><strong>not sized 6 x n.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.CalcJacobianTranslationalVelocity">
<span class="sig-name descname"><span class="pre">CalcJacobianTranslationalVelocity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context" title="pydrake.systems.framework.Context"><span class="pre">pydrake.systems.framework.Context</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_respect_to</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JacobianWrtVariable" title="pydrake.multibody.tree.JacobianWrtVariable"><span class="pre">pydrake.multibody.tree.JacobianWrtVariable</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame" title="pydrake.multibody.tree.Frame"><span class="pre">pydrake.multibody.tree.Frame</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_BoBi_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.f_contiguous</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame" title="pydrake.multibody.tree.Frame"><span class="pre">pydrake.multibody.tree.Frame</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_E</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame" title="pydrake.multibody.tree.Frame"><span class="pre">pydrake.multibody.tree.Frame</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.CalcJacobianTranslationalVelocity" title="Permalink to this definition"></a></dt>
<dd><p>For each point Bi affixed/welded to a frame B, calculates J𝑠_v_ABi,
Bi’s translational velocity Jacobian in frame A with respect to
“speeds” 𝑠.</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>J𝑠_v_ABi ≜ [ ∂(v_ABi)/∂𝑠₁,  ...  ∂(v_ABi)/∂𝑠ₙ ]    (n is j or k)
     v_ABi = J𝑠_v_ABi ⋅ 𝑠          v_ABi is linear in 𝑠 ≜ [𝑠₁ ... 𝑠ₙ]ᵀ
</pre></div>
</div>
</details><p><code class="docutils literal notranslate"><span class="pre">v_ABi</span></code> is Bi’s translational velocity in frame A and “speeds” 𝑠 is
either q̇ ≜ [q̇₁ … q̇ⱼ]ᵀ (time-derivatives of j generalized
positions) or v ≜ [v₁ … vₖ]ᵀ (k generalized velocities).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The state of the multibody system.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">with_respect_to</span></code>:</dt><dd><p>Enum equal to JacobianWrtVariable::kQDot or
JacobianWrtVariable::kV, indicating whether the Jacobian
<code class="docutils literal notranslate"><span class="pre">J𝑠_v_ABi</span></code> is partial derivatives with respect to 𝑠 = q̇
(time-derivatives of generalized positions) or with respect to 𝑠 =
v (generalized velocities).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_B</span></code>:</dt><dd><p>The frame on which point Bi is affixed/welded.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BoBi_B</span></code>:</dt><dd><p>A position vector or list of p position vectors from Bo (frame_B’s
origin) to points Bi (regarded as affixed to B), where each
position vector is expressed in frame_B.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_A</span></code>:</dt><dd><p>The frame that measures <code class="docutils literal notranslate"><span class="pre">v_ABi</span></code> (Bi’s velocity in A). Note: It
is natural to wonder why there is no parameter p_AoAi_A (similar
to the parameter p_BoBi_B for frame_B). There is no need for
p_AoAi_A because Bi’s velocity in A is defined as the derivative
in frame A of Bi’s position vector from <em>any</em> point affixed to A.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_E</span></code>:</dt><dd><p>The frame in which <code class="docutils literal notranslate"><span class="pre">v_ABi</span></code> is expressed on input and the frame
in which the Jacobian <code class="docutils literal notranslate"><span class="pre">J𝑠_v_ABi</span></code> is expressed on output.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">J𝑠_v_ABi_E</span></code>:</dt><dd><p>Point Bi’s velocity Jacobian in frame A with respect to speeds 𝑠
(which is either q̇ or v), expressed in frame E. <code class="docutils literal notranslate"><span class="pre">J𝑠_v_ABi_E</span></code> is
a <code class="docutils literal notranslate"><span class="pre">3*p</span> <span class="pre">x</span> <span class="pre">n</span></code> matrix, where p is the number of points Bi and n is
the number of elements in 𝑠. The Jacobian is a function of only
generalized positions q (which are pulled from the context).</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if J𝑠_v_ABi_E is nullptr</strong><strong> or </strong><strong>not sized ``3*p x</strong> – </p></li>
<li><p><strong>n``.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When 𝑠 = q̇, <code class="docutils literal notranslate"><span class="pre">Jq̇_v_ABi</span> <span class="pre">=</span> <span class="pre">Jq_p_AoBi</span></code>. In other words, point Bi’s
velocity Jacobian in frame A with respect to q̇ is equal to point
Bi’s position Jacobian from Ao (A’s origin) in frame A with
respect to q.</p>
</div>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>[∂(v_ABi)/∂q̇₁,  ...  ∂(v_ABi)/∂q̇ⱼ] = [∂(p_AoBi)/∂q₁,  ...  ∂(p_AoBi)/∂qⱼ]
</pre></div>
</div>
</details><p>Note: Each partial derivative of p_AoBi is taken in frame A.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcJacobianPositionVector() for details on Jq_p_AoBi.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.CalcMassMatrix">
<span class="sig-name descname"><span class="pre">CalcMassMatrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context" title="pydrake.systems.framework.Context"><span class="pre">pydrake.systems.framework.Context</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.CalcMassMatrix" title="Permalink to this definition"></a></dt>
<dd><p>Efficiently computes the mass matrix <code class="docutils literal notranslate"><span class="pre">M(q)</span></code> of the model. The
generalized positions q are taken from the given <code class="docutils literal notranslate"><span class="pre">context</span></code>. M
includes the mass properties of rigid bodies and reflected_inertia
“reflected inertias” as provided with JointActuator specifications.</p>
<p>This method employs the Composite Body Algorithm, which we believe to
be the fastest O(n²) algorithm to compute the mass matrix of a
multibody system.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The Context containing the state of the model from which
generalized coordinates q are extracted.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">M</span></code>:</dt><dd><p>A pointer to a square matrix in <code class="docutils literal notranslate"><span class="pre">ℛⁿˣⁿ</span></code> with n the number of
generalized velocities (num_velocities()) of the model. Although
symmetric, the matrix is filled in completely on return.</p>
</dd>
<dt>Precondition:</dt><dd><p>M is non-null and has the right size.</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This is an O(n²) algorithm. Avoid the explicit computation of the
mass matrix whenever possible.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcMassMatrixViaInverseDynamics() (slower)</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.CalcMassMatrixViaInverseDynamics">
<span class="sig-name descname"><span class="pre">CalcMassMatrixViaInverseDynamics</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context" title="pydrake.systems.framework.Context"><span class="pre">pydrake.systems.framework.Context</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.CalcMassMatrixViaInverseDynamics" title="Permalink to this definition"></a></dt>
<dd><p>Computes the mass matrix <code class="docutils literal notranslate"><span class="pre">M(q)</span></code> of the model using a slow method
(inverse dynamics). The generalized positions q are taken from the
given <code class="docutils literal notranslate"><span class="pre">context</span></code>. M includes the mass properties of rigid bodies and
reflected_inertia “reflected inertias” as provided with JointActuator
specifications.</p>
<p>Use CalcMassMatrix() for a faster implementation using the Composite
Body Algorithm.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The Context containing the state of the model from which
generalized coordinates q are extracted.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">M</span></code>:</dt><dd><p>A pointer to a square matrix in <code class="docutils literal notranslate"><span class="pre">ℛⁿˣⁿ</span></code> with n the number of
generalized velocities (num_velocities()) of the model. Although
symmetric, the matrix is filled in completely on return.</p>
</dd>
<dt>Precondition:</dt><dd><p>M is non-null and has the right size.</p>
</dd>
</dl>
<p>The algorithm used to build <code class="docutils literal notranslate"><span class="pre">M(q)</span></code> consists in computing one column
of <code class="docutils literal notranslate"><span class="pre">M(q)</span></code> at a time using inverse dynamics. The result from inverse
dynamics, with no applied forces, is the vector of generalized forces:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>tau = M(q)v̇ + C(q, v)v
</pre></div>
</div>
</details><p>where q and v are the generalized positions and velocities,
respectively. When <code class="docutils literal notranslate"><span class="pre">v</span> <span class="pre">=</span> <span class="pre">0</span></code> the Coriolis and gyroscopic forces term
<code class="docutils literal notranslate"><span class="pre">C(q,</span> <span class="pre">v)v</span></code> is zero. Therefore the <code class="docutils literal notranslate"><span class="pre">i-th</span></code> column of <code class="docutils literal notranslate"><span class="pre">M(q)</span></code> can be
obtained performing inverse dynamics with an acceleration vector <code class="docutils literal notranslate"><span class="pre">v̇</span>
<span class="pre">=</span> <span class="pre">eᵢ</span></code>, with <code class="docutils literal notranslate"><span class="pre">eᵢ</span></code> the standard (or natural) basis of <code class="docutils literal notranslate"><span class="pre">ℛⁿ</span></code> with n
the number of generalized velocities. We write this as:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">M</span><span class="p">.</span><span class="n">ᵢ</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">M</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">e_i</span><span class="w"></span>
</pre></div>
</div>
</details><p>where <code class="docutils literal notranslate"><span class="pre">M.ᵢ(q)</span></code> (notice the dot for the rows index) denotes the
<code class="docutils literal notranslate"><span class="pre">i-th</span></code> column in M(q).</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This is an O(n²) algorithm. Avoid the explicit computation of the
mass matrix whenever possible.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcMassMatrix(), CalcInverseDynamics()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.CalcPointsPositions">
<span class="sig-name descname"><span class="pre">CalcPointsPositions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context" title="pydrake.systems.framework.Context"><span class="pre">pydrake.systems.framework.Context</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame" title="pydrake.multibody.tree.Frame"><span class="pre">pydrake.multibody.tree.Frame</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_BQi</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.f_contiguous</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame" title="pydrake.multibody.tree.Frame"><span class="pre">pydrake.multibody.tree.Frame</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.CalcPointsPositions" title="Permalink to this definition"></a></dt>
<dd><p>Given the positions <code class="docutils literal notranslate"><span class="pre">p_BQi</span></code> for a set of points <code class="docutils literal notranslate"><span class="pre">Qi</span></code> measured and
expressed in a frame B, this method computes the positions
<code class="docutils literal notranslate"><span class="pre">p_AQi(q)</span></code> of each point <code class="docutils literal notranslate"><span class="pre">Qi</span></code> in the set as measured and expressed
in another frame A, as a function of the generalized positions q of
the model.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context containing the state of the model. It stores the
generalized positions q of the model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_B</span></code>:</dt><dd><p>The frame B in which the positions <code class="docutils literal notranslate"><span class="pre">p_BQi</span></code> of a set of points
<code class="docutils literal notranslate"><span class="pre">Qi</span></code> are given.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BQi</span></code>:</dt><dd><p>The input positions of each point <code class="docutils literal notranslate"><span class="pre">Qi</span></code> in frame B. <code class="docutils literal notranslate"><span class="pre">p_BQi</span> <span class="pre">∈</span>
<span class="pre">ℝ³ˣⁿᵖ</span></code> with <code class="docutils literal notranslate"><span class="pre">np</span></code> the number of points in the set. Each column
of <code class="docutils literal notranslate"><span class="pre">p_BQi</span></code> corresponds to a vector in ℝ³ holding the position of
one of the points in the set as measured and expressed in frame B.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_A</span></code>:</dt><dd><p>The frame A in which it is desired to compute the positions
<code class="docutils literal notranslate"><span class="pre">p_AQi</span></code> of each point <code class="docutils literal notranslate"><span class="pre">Qi</span></code> in the set.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_AQi</span></code>:</dt><dd><p>The output positions of each point <code class="docutils literal notranslate"><span class="pre">Qi</span></code> now computed as measured
and expressed in frame A. The output <code class="docutils literal notranslate"><span class="pre">p_AQi</span></code> <strong>must</strong> have the
same size as the input <code class="docutils literal notranslate"><span class="pre">p_BQi</span></code> or otherwise this method aborts.
That is <code class="docutils literal notranslate"><span class="pre">p_AQi</span></code> <strong>must</strong> be in <code class="docutils literal notranslate"><span class="pre">ℝ³ˣⁿᵖ</span></code>.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Both <code class="docutils literal notranslate"><span class="pre">p_BQi</span></code> and <code class="docutils literal notranslate"><span class="pre">p_AQi</span></code> must have three rows. Otherwise this
method will throw a RuntimeError. This method also throws a
RuntimeError if <code class="docutils literal notranslate"><span class="pre">p_BQi</span></code> and <code class="docutils literal notranslate"><span class="pre">p_AQi</span></code> differ in the number of
columns.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.CalcRelativeRotationMatrix">
<span class="sig-name descname"><span class="pre">CalcRelativeRotationMatrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context" title="pydrake.systems.framework.Context"><span class="pre">pydrake.systems.framework.Context</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame" title="pydrake.multibody.tree.Frame"><span class="pre">pydrake.multibody.tree.Frame</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame" title="pydrake.multibody.tree.Frame"><span class="pre">pydrake.multibody.tree.Frame</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.math.html#pydrake.math.RotationMatrix" title="pydrake.math.RotationMatrix"><span class="pre">pydrake.math.RotationMatrix</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.CalcRelativeRotationMatrix" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the rotation matrix <code class="docutils literal notranslate"><span class="pre">R_AB</span></code> relating frame A and frame B.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The state of the multibody system, which includes the system’s
generalized positions q. Note: <code class="docutils literal notranslate"><span class="pre">R_AB</span></code> is a function of q.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_A</span></code>:</dt><dd><p>The frame A designated in the rigid transform <code class="docutils literal notranslate"><span class="pre">R_AB</span></code>.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_B</span></code>:</dt><dd><p>The frame G designated in the rigid transform <code class="docutils literal notranslate"><span class="pre">R_AB</span></code>.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">R_AB</span></code>:</dt><dd><p>The RigidTransform relating frame A and frame B.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.CalcRelativeTransform">
<span class="sig-name descname"><span class="pre">CalcRelativeTransform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context" title="pydrake.systems.framework.Context"><span class="pre">pydrake.systems.framework.Context</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame" title="pydrake.multibody.tree.Frame"><span class="pre">pydrake.multibody.tree.Frame</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame" title="pydrake.multibody.tree.Frame"><span class="pre">pydrake.multibody.tree.Frame</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.math.html#pydrake.math.RigidTransform" title="pydrake.math.RigidTransform"><span class="pre">pydrake.math.RigidTransform</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.CalcRelativeTransform" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the rigid transform (pose) <code class="docutils literal notranslate"><span class="pre">X_AB</span></code> relating frame A and
frame B.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The state of the multibody system, which includes the system’s
generalized positions q. Note: <code class="docutils literal notranslate"><span class="pre">X_AB</span></code> is a function of q.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_A</span></code>:</dt><dd><p>The frame A designated in the rigid transform <code class="docutils literal notranslate"><span class="pre">X_AB</span></code>.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_B</span></code>:</dt><dd><p>The frame G designated in the rigid transform <code class="docutils literal notranslate"><span class="pre">X_AB</span></code>.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">X_AB</span></code>:</dt><dd><p>The RigidTransform relating frame A and frame B.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.CalcSpatialAccelerationsFromVdot">
<span class="sig-name descname"><span class="pre">CalcSpatialAccelerationsFromVdot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context" title="pydrake.systems.framework.Context"><span class="pre">pydrake.systems.framework.Context</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">known_vdot</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.multibody.math.html#pydrake.multibody.math.SpatialAcceleration" title="pydrake.multibody.math.SpatialAcceleration"><span class="pre">pydrake.multibody.math.SpatialAcceleration</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.CalcSpatialAccelerationsFromVdot" title="Permalink to this definition"></a></dt>
<dd><p>Given the state of this model in <code class="docutils literal notranslate"><span class="pre">context</span></code> and a known vector of
generalized accelerations <code class="docutils literal notranslate"><span class="pre">known_vdot</span></code>, this method computes the
spatial acceleration <code class="docutils literal notranslate"><span class="pre">A_WB</span></code> for each body as measured and expressed
in the world frame W.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context containing the state of this model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">known_vdot</span></code>:</dt><dd><p>A vector with the generalized accelerations for the full model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">A_WB_array</span></code>:</dt><dd><p>A pointer to a valid, non nullptr, vector of spatial accelerations
containing the spatial acceleration <code class="docutils literal notranslate"><span class="pre">A_WB</span></code> for each body. It
must be of size equal to the number of bodies in the model. On
output, entries will be ordered by BodyIndex.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if A_WB_array is not of size num_bodies</strong><strong>(</strong><strong>)</strong><strong></strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.CalcSpatialInertia">
<span class="sig-name descname"><span class="pre">CalcSpatialInertia</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context" title="pydrake.systems.framework.Context"><span class="pre">pydrake.systems.framework.Context</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_F</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame" title="pydrake.multibody.tree.Frame"><span class="pre">pydrake.multibody.tree.Frame</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">body_indexes</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.BodyIndex" title="pydrake.multibody.tree.BodyIndex"><span class="pre">pydrake.multibody.tree.BodyIndex</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.SpatialInertia" title="pydrake.multibody.tree.SpatialInertia"><span class="pre">pydrake.multibody.tree.SpatialInertia</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.CalcSpatialInertia" title="Permalink to this definition"></a></dt>
<dd><p>Returns M_SFo_F, the spatial inertia of a set S of bodies about point
Fo (the origin of a frame F), expressed in frame F. You may regard
M_SFo_F as measuring spatial inertia as if the set S of bodies were
welded into a single composite body at the configuration specified in
the <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>Contains the configuration of the set S of bodies.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_F</span></code>:</dt><dd><p>specifies the about-point Fo (frame_F’s origin) and the
expressed-in frame for the returned spatial inertia.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body_indexes</span></code>:</dt><dd><p>Array of selected bodies. This method does not distinguish between
welded bodies, joint-connected bodies, etc.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if body_indexes contains an invalid BodyIndex</strong><strong> or </strong><strong>if</strong> – </p></li>
<li><p><strong>there is a repeated BodyIndex.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The mass and inertia of the world_body() does not contribute to
the the returned spatial inertia.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.CalcSpatialMomentumInWorldAboutPoint">
<span class="sig-name descname"><span class="pre">CalcSpatialMomentumInWorldAboutPoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.CalcSpatialMomentumInWorldAboutPoint" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>CalcSpatialMomentumInWorldAboutPoint(self: pydrake.multibody.plant.MultibodyPlant, context: pydrake.systems.framework.Context, p_WoP_W: numpy.ndarray[numpy.float64[3, 1]]) -&gt; pydrake.multibody.math.SpatialMomentum</p></li>
</ol>
<p>This method returns the spatial momentum of <code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant in
the world frame W, about a designated point P, expressed in the world
frame W.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>Contains the state of the model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_WoP_W</span></code>:</dt><dd><p>Position from Wo (origin of the world frame W) to an arbitrary
point P, expressed in the world frame W.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">L_WSP_W</span></code>:</dt><dd><p>, spatial momentum of the system S represented by <code class="docutils literal notranslate"><span class="pre">this</span></code> plant,
measured in the world frame W, about point P, expressed in W.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>To calculate the spatial momentum of this system S in W about Scm
(the system’s center of mass), use something like:</p>
</div>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">plant</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="c1">// ... code to load a model ....</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">Vector3</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">p_WoScm_W</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">    </span><span class="n">plant</span><span class="p">.</span><span class="n">CalcCenterOfMassPositionInWorld</span><span class="p">(</span><span class="n">context</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">SpatialMomentum</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">L_WScm_W</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">    </span><span class="n">plant</span><span class="p">.</span><span class="n">CalcSpatialMomentumInWorldAboutPoint</span><span class="p">(</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="n">p_WoScm_W</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</details><ol class="arabic simple" start="2">
<li><p>CalcSpatialMomentumInWorldAboutPoint(self: pydrake.multibody.plant.MultibodyPlant, context: pydrake.systems.framework.Context, model_instances: List[pydrake.multibody.tree.ModelInstanceIndex], p_WoP_W: numpy.ndarray[numpy.float64[3, 1]]) -&gt; pydrake.multibody.math.SpatialMomentum</p></li>
</ol>
<p>This method returns the spatial momentum of a set of model instances
in the world frame W, about a designated point P, expressed in frame
W.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>Contains the state of the model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">model_instances</span></code>:</dt><dd><p>Set of selected model instances.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_WoP_W</span></code>:</dt><dd><p>Position from Wo (origin of the world frame W) to an arbitrary
point P, expressed in the world frame W.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">L_WSP_W</span></code>:</dt><dd><p>, spatial momentum of the system S represented by the
model_instances, measured in world frame W, about point P,
expressed in W.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>To calculate the spatial momentum of this system S in W about Scm
(the system’s center of mass), use something like:</p>
</div>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">plant</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="c1">// ... code to create a set of selected model instances, e.g., ...</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">ModelInstanceIndex</span><span class="w"> </span><span class="n">gripper_model_instance</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">    </span><span class="n">plant</span><span class="p">.</span><span class="n">GetModelInstanceByName</span><span class="p">(</span><span class="s">&quot;gripper&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">ModelInstanceIndex</span><span class="w"> </span><span class="n">robot_model_instance</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">    </span><span class="n">plant</span><span class="p">.</span><span class="n">GetBodyByName</span><span class="p">(</span><span class="s">&quot;end_effector&quot;</span><span class="p">).</span><span class="n">model_instance</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ModelInstanceIndex</span><span class="o">&gt;</span><span class="w"> </span><span class="n">model_instances</span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">gripper_model_instance</span><span class="p">,</span><span class="w"> </span><span class="n">robot_model_instance</span><span class="p">};</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">Vector3</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">p_WoScm_W</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">    </span><span class="n">plant</span><span class="p">.</span><span class="n">CalcCenterOfMassPositionInWorld</span><span class="p">(</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="n">model_instances</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">SpatialMomentum</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">L_WScm_W</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">    </span><span class="n">plant</span><span class="p">.</span><span class="n">CalcSpatialMomentumInWorldAboutPoint</span><span class="p">(</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="n">model_instances</span><span class="p">,</span><span class="w"></span>
<span class="w">                                               </span><span class="n">p_WoScm_W</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</details><dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if model_instances contains an invalid</strong> – </p></li>
<li><p><strong>ModelInstanceIndex.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.CalcTotalMass">
<span class="sig-name descname"><span class="pre">CalcTotalMass</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.CalcTotalMass" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>CalcTotalMass(self: pydrake.multibody.plant.MultibodyPlant, context: pydrake.systems.framework.Context) -&gt; float</p></li>
</ol>
<p>Calculates the total mass of all bodies in this MultibodyPlant.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>Contains the state of the model.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">The</span></code>:</dt><dd><p>total mass of all bodies or 0 if there are none.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The mass of the world_body() does not contribute to the total
mass.</p>
</div>
<ol class="arabic simple" start="2">
<li><p>CalcTotalMass(self: pydrake.multibody.plant.MultibodyPlant, context: pydrake.systems.framework.Context, model_instances: List[pydrake.multibody.tree.ModelInstanceIndex]) -&gt; float</p></li>
</ol>
<p>Calculates the total mass of all bodies contained in model_instances.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>Contains the state of the model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">model_instances</span></code>:</dt><dd><p>Vector of selected model instances. This method does not
distinguish between welded, joint connected, or floating bodies.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">The</span></code>:</dt><dd><p>total mass of all bodies belonging to a model instance in
model_instances or 0 if model_instances is empty.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The mass of the world_body() does not contribute to the total mass
and each body only contributes to the total mass once, even if the
body has repeated occurrence (instance) in model_instances.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.CollectRegisteredGeometries">
<span class="sig-name descname"><span class="pre">CollectRegisteredGeometries</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">bodies</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody" title="pydrake.multibody.tree.RigidBody"><span class="pre">pydrake.multibody.tree.RigidBody</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.GeometrySet" title="pydrake.geometry.GeometrySet"><span class="pre">pydrake.geometry.GeometrySet</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.CollectRegisteredGeometries" title="Permalink to this definition"></a></dt>
<dd><p>For each of the provided <code class="docutils literal notranslate"><span class="pre">bodies</span></code>, collects up all geometries that
have been registered to that body. Intended to be used in conjunction
with CollisionFilterDeclaration and CollisionFilterManager::Apply() to
filter collisions between the geometries registered to the bodies.</p>
<p>For example:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Don&#39;t report on collisions between geometries affixed to `body1`,</span>
<span class="c1">// `body2`, or `body3`.</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">RigidBody</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*&gt;</span><span class="w"> </span><span class="n">bodies</span><span class="p">{</span><span class="o">&amp;</span><span class="n">body1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">body2</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">body3</span><span class="p">};</span><span class="w"></span>
<span class="n">geometry</span><span class="o">::</span><span class="n">GeometrySet</span><span class="w"> </span><span class="n">set</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">plant</span><span class="p">.</span><span class="n">CollectRegisteredGeometries</span><span class="p">(</span><span class="n">bodies</span><span class="p">);</span><span class="w"></span>
<span class="n">scene_graph</span><span class="p">.</span><span class="n">collision_filter_manager</span><span class="p">().</span><span class="n">Apply</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">CollisionFilterDeclaration</span><span class="p">().</span><span class="n">ExcludeWithin</span><span class="p">(</span><span class="n">set</span><span class="p">));</span><span class="w"></span>
</pre></div>
</div>
</details><div class="admonition note">
<p class="admonition-title">Note</p>
<p>There is a <em>very</em> specific order of operations:</p>
</div>
<ol class="arabic simple">
<li><p>Bodies and geometries must be added to the MultibodyPlant.</p></li>
<li><p>Create GeometrySet instances from bodies (via this method).</p></li>
<li><p>Invoke SceneGraph::ExcludeCollisions*() to filter collisions.</p></li>
<li><p>Allocate context.</p></li>
</ol>
<p>Changing the order will cause exceptions to be thrown.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if this MultibodyPlant was not registered with a</strong> – </p></li>
<li><p><strong>SceneGraph.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.EvalBodyPoseInWorld">
<span class="sig-name descname"><span class="pre">EvalBodyPoseInWorld</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context" title="pydrake.systems.framework.Context"><span class="pre">pydrake.systems.framework.Context</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">body</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody" title="pydrake.multibody.tree.RigidBody"><span class="pre">pydrake.multibody.tree.RigidBody</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.math.html#pydrake.math.RigidTransform" title="pydrake.math.RigidTransform"><span class="pre">pydrake.math.RigidTransform</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.EvalBodyPoseInWorld" title="Permalink to this definition"></a></dt>
<dd><p>Evaluate the pose <code class="docutils literal notranslate"><span class="pre">X_WB</span></code> of a body B in the world frame W.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context storing the state of the model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body_B</span></code>:</dt><dd><p>The body B for which the pose is requested.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">X_WB</span></code>:</dt><dd><p>The pose of body frame B in the world frame W.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if Finalize</strong><strong>(</strong><strong>) </strong><strong>was not called on this model</strong><strong> or </strong><strong>if</strong> – </p></li>
<li><p><strong>body_B` does not belong to this model</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.EvalBodySpatialAccelerationInWorld">
<span class="sig-name descname"><span class="pre">EvalBodySpatialAccelerationInWorld</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context" title="pydrake.systems.framework.Context"><span class="pre">pydrake.systems.framework.Context</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">body</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody" title="pydrake.multibody.tree.RigidBody"><span class="pre">pydrake.multibody.tree.RigidBody</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.math.html#pydrake.multibody.math.SpatialAcceleration" title="pydrake.multibody.math.SpatialAcceleration"><span class="pre">pydrake.multibody.math.SpatialAcceleration</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.EvalBodySpatialAccelerationInWorld" title="Permalink to this definition"></a></dt>
<dd><p>Evaluates A_WB, body B’s spatial acceleration in the world frame W.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context storing the state of the model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body_B</span></code>:</dt><dd><p>The body for which spatial acceleration is requested.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">A_WB_W</span></code>:</dt><dd><p>RigidBody B’s spatial acceleration in the world frame W, expressed
in W (for point Bo, the body’s origin).</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if Finalize</strong><strong>(</strong><strong>) </strong><strong>was not called on this model</strong><strong> or </strong><strong>if</strong> – </p></li>
<li><p><strong>body_B` does not belong to this model</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When cached values are out of sync with the state stored in
context, this method performs an expensive forward dynamics
computation, whereas once evaluated, successive calls to this
method are inexpensive.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.EvalBodySpatialVelocityInWorld">
<span class="sig-name descname"><span class="pre">EvalBodySpatialVelocityInWorld</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context" title="pydrake.systems.framework.Context"><span class="pre">pydrake.systems.framework.Context</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">body</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody" title="pydrake.multibody.tree.RigidBody"><span class="pre">pydrake.multibody.tree.RigidBody</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.math.html#pydrake.multibody.math.SpatialVelocity" title="pydrake.multibody.math.SpatialVelocity"><span class="pre">pydrake.multibody.math.SpatialVelocity</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.EvalBodySpatialVelocityInWorld" title="Permalink to this definition"></a></dt>
<dd><p>Evaluates V_WB, body B’s spatial velocity in the world frame W.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context storing the state of the model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body_B</span></code>:</dt><dd><p>The body B for which the spatial velocity is requested.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">V_WB_W</span></code>:</dt><dd><p>RigidBody B’s spatial velocity in the world frame W, expressed in
W (for point Bo, the body’s origin).</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if Finalize</strong><strong>(</strong><strong>) </strong><strong>was not called on this model</strong><strong> or </strong><strong>if</strong> – </p></li>
<li><p><strong>body_B` does not belong to this model</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.Finalize">
<span class="sig-name descname"><span class="pre">Finalize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.Finalize" title="Permalink to this definition"></a></dt>
<dd><p>This method must be called after all elements in the model (joints,
bodies, force elements, constraints, etc.) are added and before any
computations are performed. It essentially compiles all the necessary
“topological information”, i.e. how bodies, joints and, any other
elements connect with each other, and performs all the required
pre-processing to enable computations at a later stage.</p>
<p>If the finalize stage is successful, the topology of this
MultibodyPlant is valid, meaning that the topology is up-to-date after
this call. No more multibody elements can be added after a call to
Finalize().</p>
<p>At Finalize(), state and input/output ports for <code class="docutils literal notranslate"><span class="pre">this</span></code> plant are
declared.</p>
<p>For a full account of the effects of Finalize(), see
mbp_finalize_stage “Finalize() stage”.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>is_finalized(), mbp_finalize_stage “Finalize() stage”.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if the MultibodyPlant has already been finalized.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.geometry_source_is_registered">
<span class="sig-name descname"><span class="pre">geometry_source_is_registered</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.geometry_source_is_registered" title="Permalink to this definition"></a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if <code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant was registered with a
SceneGraph. This method can be called at any time during the lifetime
of <code class="docutils literal notranslate"><span class="pre">this</span></code> plant to query if <code class="docutils literal notranslate"><span class="pre">this</span></code> plant has been registered with
a SceneGraph, either pre- or post-finalize, see Finalize().</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.get_actuation_input_port">
<span class="sig-name descname"><span class="pre">get_actuation_input_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.get_actuation_input_port" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>get_actuation_input_port(self: pydrake.multibody.plant.MultibodyPlant) -&gt; pydrake.systems.framework.InputPort</p></li>
</ol>
<p>Returns a constant reference to the input port for external actuation
for all actuated dofs. This input port is a vector valued port and can
be set with JointActuator::set_actuation_vector(). The actuation value
for a particular actuator can be found at offset
JointActuator::input_start() in this vector. Refer to mbp_actuation
“Actuation” for further details.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>Finalize() was already called on <code class="docutils literal notranslate"><span class="pre">this</span></code> plant.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if called before Finalize</strong><strong>(</strong><strong>)</strong><strong></strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>get_actuation_input_port(self: pydrake.multibody.plant.MultibodyPlant, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; pydrake.systems.framework.InputPort</p></li>
</ol>
<p>Returns a constant reference to the input port for external actuation
for a specific model instance. This is a vector valued port with
entries ordered by monotonically increasing JointActuatorIndex within
<code class="docutils literal notranslate"><span class="pre">model_instance</span></code>. Refer to mbp_actuation “Actuation” for further
details.</p>
<p>Every model instance in <code class="docutils literal notranslate"><span class="pre">this</span></code> plant model has an actuation input
port, even if zero sized (for model instance with no actuators).</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>GetJointActuatorIndices(), GetActuatedJointIndices().</p>
</div>
<dl class="simple">
<dt>Precondition:</dt><dd><p>Finalize() was already called on <code class="docutils literal notranslate"><span class="pre">this</span></code> plant.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if called before Finalize</strong><strong>(</strong><strong>)</strong><strong></strong> – </p></li>
<li><p><strong>RuntimeError if the model instance does not exist.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.get_adjacent_bodies_collision_filters">
<span class="sig-name descname"><span class="pre">get_adjacent_bodies_collision_filters</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.get_adjacent_bodies_collision_filters" title="Permalink to this definition"></a></dt>
<dd><p>Returns whether to apply collision filters to topologically adjacent
bodies at Finalize() time.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.get_applied_generalized_force_input_port">
<span class="sig-name descname"><span class="pre">get_applied_generalized_force_input_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.InputPort" title="pydrake.systems.framework.InputPort"><span class="pre">pydrake.systems.framework.InputPort</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.get_applied_generalized_force_input_port" title="Permalink to this definition"></a></dt>
<dd><p>Returns a constant reference to the vector-valued input port for
applied generalized forces, and the vector will be added directly into
<code class="docutils literal notranslate"><span class="pre">tau</span></code> (see mbp_equations_of_motion “System dynamics”). This vector
is ordered using the same convention as the plant velocities: you can
set the generalized forces that will be applied to model instance i
using, e.g., <code class="docutils literal notranslate"><span class="pre">SetVelocitiesInArray(i,</span> <span class="pre">model_forces,</span> <span class="pre">&amp;force_array)</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if called before Finalize</strong><strong>(</strong><strong>)</strong><strong></strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.get_applied_spatial_force_input_port">
<span class="sig-name descname"><span class="pre">get_applied_spatial_force_input_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.InputPort" title="pydrake.systems.framework.InputPort"><span class="pre">pydrake.systems.framework.InputPort</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.get_applied_spatial_force_input_port" title="Permalink to this definition"></a></dt>
<dd><p>Returns a constant reference to the input port for applying spatial
forces to bodies in the plant. The data type for the port is an
std::vector of ExternallyAppliedSpatialForce; any number of spatial
forces can be applied to any number of bodies in the plant.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.get_body">
<span class="sig-name descname"><span class="pre">get_body</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">body_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.BodyIndex" title="pydrake.multibody.tree.BodyIndex"><span class="pre">pydrake.multibody.tree.BodyIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody" title="pydrake.multibody.tree.RigidBody"><span class="pre">pydrake.multibody.tree.RigidBody</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.get_body" title="Permalink to this definition"></a></dt>
<dd><p>Returns a constant reference to the body with unique index
<code class="docutils literal notranslate"><span class="pre">body_index</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if body_index does not correspond to a body in</strong> – </p></li>
<li><p><strong>this model.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.get_body_poses_output_port">
<span class="sig-name descname"><span class="pre">get_body_poses_output_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.OutputPort" title="pydrake.systems.framework.OutputPort"><span class="pre">pydrake.systems.framework.OutputPort</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.get_body_poses_output_port" title="Permalink to this definition"></a></dt>
<dd><p>Returns the output port of all body poses in the world frame. You can
obtain the pose <code class="docutils literal notranslate"><span class="pre">X_WB</span></code> of a body B in the world frame W with:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">X_WB_all</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">plant</span><span class="p">.</span><span class="n">get_body_poses_output_port</span><span class="p">().</span><span class="w"></span>
<span class="w">      </span><span class="p">.</span><span class="n">Eval</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">math</span><span class="o">::</span><span class="n">RigidTransform</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">plant_context</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">BodyIndex</span><span class="w"> </span><span class="n">arm_body_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">plant</span><span class="p">.</span><span class="n">GetBodyByName</span><span class="p">(</span><span class="s">&quot;arm&quot;</span><span class="p">).</span><span class="n">index</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">math</span><span class="o">::</span><span class="n">RigidTransform</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">X_WArm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">X_WB_all</span><span class="p">[</span><span class="n">arm_body_index</span><span class="p">];</span><span class="w"></span>
</pre></div>
</div>
</details><p>As shown in the example above, the resulting <code class="docutils literal notranslate"><span class="pre">std::vector</span></code> of body
poses is indexed by BodyIndex, and it has size num_bodies(). BodyIndex
“zero” (0) always corresponds to the world body, with pose equal to
the identity at all times.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.get_body_spatial_accelerations_output_port">
<span class="sig-name descname"><span class="pre">get_body_spatial_accelerations_output_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.OutputPort" title="pydrake.systems.framework.OutputPort"><span class="pre">pydrake.systems.framework.OutputPort</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.get_body_spatial_accelerations_output_port" title="Permalink to this definition"></a></dt>
<dd><p>Returns the output port of all body spatial accelerations in the world
frame. You can obtain the spatial acceleration <code class="docutils literal notranslate"><span class="pre">A_WB</span></code> of a body B in
the world frame W with:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">A_WB_all</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">  </span><span class="n">plant</span><span class="p">.</span><span class="n">get_body_spatial_accelerations_output_port</span><span class="p">().</span><span class="w"></span>
<span class="w">      </span><span class="p">.</span><span class="n">Eval</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SpatialAcceleration</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">plant_context</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">BodyIndex</span><span class="w"> </span><span class="n">arm_body_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">plant</span><span class="p">.</span><span class="n">GetBodyByName</span><span class="p">(</span><span class="s">&quot;arm&quot;</span><span class="p">).</span><span class="n">index</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">SpatialVelocity</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">A_WArm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A_WB_all</span><span class="p">[</span><span class="n">arm_body_index</span><span class="p">];</span><span class="w"></span>
</pre></div>
</div>
</details><p>As shown in the example above, the resulting <code class="docutils literal notranslate"><span class="pre">std::vector</span></code> of body
spatial accelerations is indexed by BodyIndex, and it has size
num_bodies(). BodyIndex “zero” (0) always corresponds to the world
body, with zero spatial acceleration at all times.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.get_body_spatial_velocities_output_port">
<span class="sig-name descname"><span class="pre">get_body_spatial_velocities_output_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.OutputPort" title="pydrake.systems.framework.OutputPort"><span class="pre">pydrake.systems.framework.OutputPort</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.get_body_spatial_velocities_output_port" title="Permalink to this definition"></a></dt>
<dd><p>Returns the output port of all body spatial velocities in the world
frame. You can obtain the spatial velocity <code class="docutils literal notranslate"><span class="pre">V_WB</span></code> of a body B in the
world frame W with:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">V_WB_all</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">plant</span><span class="p">.</span><span class="n">get_body_spatial_velocities_output_port</span><span class="p">().</span><span class="w"></span>
<span class="w">      </span><span class="p">.</span><span class="n">Eval</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SpatialVelocity</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">plant_context</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">BodyIndex</span><span class="w"> </span><span class="n">arm_body_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">plant</span><span class="p">.</span><span class="n">GetBodyByName</span><span class="p">(</span><span class="s">&quot;arm&quot;</span><span class="p">).</span><span class="n">index</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">SpatialVelocity</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">V_WArm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">V_WB_all</span><span class="p">[</span><span class="n">arm_body_index</span><span class="p">];</span><span class="w"></span>
</pre></div>
</div>
</details><p>As shown in the example above, the resulting <code class="docutils literal notranslate"><span class="pre">std::vector</span></code> of body
spatial velocities is indexed by BodyIndex, and it has size
num_bodies(). BodyIndex “zero” (0) always corresponds to the world
body, with zero spatial velocity at all times.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.get_contact_model">
<span class="sig-name descname"><span class="pre">get_contact_model</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.multibody.plant.ContactModel" title="pydrake.multibody.plant.ContactModel"><span class="pre">pydrake.multibody.plant.ContactModel</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.get_contact_model" title="Permalink to this definition"></a></dt>
<dd><p>Returns the model used for contact. See documentation for
ContactModel.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.get_contact_penalty_method_time_scale">
<span class="sig-name descname"><span class="pre">get_contact_penalty_method_time_scale</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.get_contact_penalty_method_time_scale" title="Permalink to this definition"></a></dt>
<dd><p>Returns a time-scale estimate <code class="docutils literal notranslate"><span class="pre">tc</span></code> based on the requested
penetration allowance δ set with set_penetration_allowance(). For the
compliant contact model to enforce non-penetration, this time scale
relates to the time it takes the relative normal velocity between two
bodies to go to zero. This time scale <code class="docutils literal notranslate"><span class="pre">tc</span></code> is a global estimate of
the dynamics introduced by the compliant contact model and goes to
zero in the limit to ideal rigid contact. Since numerical integration
methods for continuum systems must be able to resolve a system’s
dynamics, the time step used by an integrator must in general be much
smaller than the time scale <code class="docutils literal notranslate"><span class="pre">tc</span></code>. How much smaller will depend on
the details of the problem and the convergence characteristics of the
integrator and should be tuned appropriately. Another factor to take
into account for setting up the simulation’s time step is the speed of
the objects in your simulation. If <code class="docutils literal notranslate"><span class="pre">vn</span></code> represents a reference
velocity scale for the normal relative velocity between bodies, the
new time scale <code class="docutils literal notranslate"><span class="pre">tn</span> <span class="pre">=</span> <span class="pre">δ</span> <span class="pre">/</span> <span class="pre">vn</span></code> represents the time it would take for
the distance between two bodies approaching with relative normal
velocity <code class="docutils literal notranslate"><span class="pre">vn</span></code> to decrease by the penetration_allowance δ. In this
case a user should choose a time step for simulation that can resolve
the smallest of the two time scales <code class="docutils literal notranslate"><span class="pre">tc</span></code> and <code class="docutils literal notranslate"><span class="pre">tn</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.get_contact_results_output_port">
<span class="sig-name descname"><span class="pre">get_contact_results_output_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.OutputPort" title="pydrake.systems.framework.OutputPort"><span class="pre">pydrake.systems.framework.OutputPort</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.get_contact_results_output_port" title="Permalink to this definition"></a></dt>
<dd><p>Returns a constant reference to the port that outputs ContactResults.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize</strong><strong>, </strong><strong>see Finalize</strong><strong>(</strong><strong>)</strong><strong></strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.get_contact_surface_representation">
<span class="sig-name descname"><span class="pre">get_contact_surface_representation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.HydroelasticContactRepresentation" title="pydrake.geometry.HydroelasticContactRepresentation"><span class="pre">pydrake.geometry.HydroelasticContactRepresentation</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.get_contact_surface_representation" title="Permalink to this definition"></a></dt>
<dd><p>Gets the current representation of contact surfaces used by <code class="docutils literal notranslate"><span class="pre">this</span></code>
MultibodyPlant.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.get_deformable_body_configuration_output_port">
<span class="sig-name descname"><span class="pre">get_deformable_body_configuration_output_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.OutputPort" title="pydrake.systems.framework.OutputPort"><span class="pre">pydrake.systems.framework.OutputPort</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.get_deformable_body_configuration_output_port" title="Permalink to this definition"></a></dt>
<dd><p>Returns the output port for vertex positions (configurations),
measured and expressed in the World frame, of the deformable bodies in
<code class="docutils literal notranslate"><span class="pre">this</span></code> plant as a GeometryConfigurationVector.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if this MultibodyPlant doesn't have a</strong> – </p></li>
<li><p><strong>DeformableModel. See AddPhysicalModel</strong><strong>(</strong><strong>)</strong><strong></strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.get_desired_state_input_port">
<span class="sig-name descname"><span class="pre">get_desired_state_input_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.InputPort" title="pydrake.systems.framework.InputPort"><span class="pre">pydrake.systems.framework.InputPort</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.get_desired_state_input_port" title="Permalink to this definition"></a></dt>
<dd><p>For models with PD controlled joint actuators, returns the port to
provide the desired state for the full <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>. Refer to
mbp_actuation “Actuation” for further details.</p>
<p>For consistency with get_actuation_input_port(), each model instance
in <code class="docutils literal notranslate"><span class="pre">this</span></code> plant model has a desired states input port, even if zero
sized (for model instance with no actuators.)</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is a vector valued port of size
2*num_actuators(model_instance), where we assumed 1-DOF actuated
joints. This is true even for unactuated models, for which this
port is zero sized. This port must provide one desired position
and one desired velocity per joint actuator. Desired state is
assumed to be packed as xd = [qd, vd] that is, configurations
first followed by velocities. The actuation value for a particular
actuator can be found at offset JointActuator::input_start() in
both qd and vd. For example:</p>
</div>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">qd_actuator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xd</span><span class="p">[</span><span class="n">actuator</span><span class="p">.</span><span class="n">input_start</span><span class="p">()];</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">vd_actuator</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">   </span><span class="n">xd</span><span class="p">[</span><span class="n">actuator</span><span class="p">.</span><span class="n">input_start</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">plant</span><span class="p">.</span><span class="n">num_actuated_dofs</span><span class="p">()];</span><span class="w"></span>
</pre></div>
</div>
</details><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>If a user specifies a PD controller for an actuator from a given
model instance, then all actuators of that model instance are
required to be PD controlled.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>It is required to connect this port for PD controlled model
instances.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.get_discrete_contact_approximation">
<span class="sig-name descname"><span class="pre">get_discrete_contact_approximation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.multibody.plant.DiscreteContactApproximation" title="pydrake.multibody.plant.DiscreteContactApproximation"><span class="pre">pydrake.multibody.plant.DiscreteContactApproximation</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.get_discrete_contact_approximation" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the discrete contact solver approximation.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.get_discrete_contact_solver">
<span class="sig-name descname"><span class="pre">get_discrete_contact_solver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.multibody.plant.DiscreteContactSolver" title="pydrake.multibody.plant.DiscreteContactSolver"><span class="pre">pydrake.multibody.plant.DiscreteContactSolver</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.get_discrete_contact_solver" title="Permalink to this definition"></a></dt>
<dd><p>Returns the contact solver type used for discrete MultibodyPlant
models.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.get_force_element">
<span class="sig-name descname"><span class="pre">get_force_element</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">force_element_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ForceElementIndex" title="pydrake.multibody.tree.ForceElementIndex"><span class="pre">pydrake.multibody.tree.ForceElementIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ForceElement" title="pydrake.multibody.tree.ForceElement"><span class="pre">pydrake.multibody.tree.ForceElement</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.get_force_element" title="Permalink to this definition"></a></dt>
<dd><p>Returns a constant reference to the force element with unique index
<code class="docutils literal notranslate"><span class="pre">force_element_index</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError when force_element_index does not correspond to a</strong> – </p></li>
<li><p><strong>force element in this model.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.get_frame">
<span class="sig-name descname"><span class="pre">get_frame</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.FrameIndex" title="pydrake.multibody.tree.FrameIndex"><span class="pre">pydrake.multibody.tree.FrameIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame" title="pydrake.multibody.tree.Frame"><span class="pre">pydrake.multibody.tree.Frame</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.get_frame" title="Permalink to this definition"></a></dt>
<dd><p>Returns a constant reference to the frame with unique index
<code class="docutils literal notranslate"><span class="pre">frame_index</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if frame_index does not correspond to a frame in</strong> – </p></li>
<li><p><strong>this plant.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.get_generalized_acceleration_output_port">
<span class="sig-name descname"><span class="pre">get_generalized_acceleration_output_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.get_generalized_acceleration_output_port" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>get_generalized_acceleration_output_port(self: pydrake.multibody.plant.MultibodyPlant) -&gt; pydrake.systems.framework.OutputPort</p></li>
</ol>
<p>Returns a constant reference to the output port for generalized
accelerations v̇ of the model.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>Finalize() was already called on <code class="docutils literal notranslate"><span class="pre">this</span></code> plant.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if called before Finalize</strong><strong>(</strong><strong>)</strong><strong></strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>get_generalized_acceleration_output_port(self: pydrake.multibody.plant.MultibodyPlant, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; pydrake.systems.framework.OutputPort</p></li>
</ol>
<p>Returns a constant reference to the output port for the generalized
accelerations v̇ᵢ ⊆ v̇ for model instance i.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>Finalize() was already called on <code class="docutils literal notranslate"><span class="pre">this</span></code> plant.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if called before Finalize</strong><strong>(</strong><strong>)</strong><strong></strong> – </p></li>
<li><p><strong>RuntimeError if the model instance does not exist.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.get_generalized_contact_forces_output_port">
<span class="sig-name descname"><span class="pre">get_generalized_contact_forces_output_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.OutputPort" title="pydrake.systems.framework.OutputPort"><span class="pre">pydrake.systems.framework.OutputPort</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.get_generalized_contact_forces_output_port" title="Permalink to this definition"></a></dt>
<dd><p>Returns a constant reference to the output port of generalized contact
forces for a specific model instance.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>Finalize() was already called on <code class="docutils literal notranslate"><span class="pre">this</span></code> plant.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if called before Finalize</strong><strong>(</strong><strong>)</strong><strong></strong> – </p></li>
<li><p><strong>RuntimeError if the model instance does not exist.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.get_geometry_poses_output_port">
<span class="sig-name descname"><span class="pre">get_geometry_poses_output_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.OutputPort" title="pydrake.systems.framework.OutputPort"><span class="pre">pydrake.systems.framework.OutputPort</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.get_geometry_poses_output_port" title="Permalink to this definition"></a></dt>
<dd><p>Returns the output port of frames’ poses to communicate with a
SceneGraph.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.get_geometry_query_input_port">
<span class="sig-name descname"><span class="pre">get_geometry_query_input_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.InputPort" title="pydrake.systems.framework.InputPort"><span class="pre">pydrake.systems.framework.InputPort</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.get_geometry_query_input_port" title="Permalink to this definition"></a></dt>
<dd><p>Returns a constant reference to the input port used to perform
geometric queries on a SceneGraph. See
SceneGraph::get_query_output_port(). Refer to section mbp_geometry
“Geometry” of this class’s documentation for further details on
collision geometry registration and connection with a SceneGraph.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.get_joint">
<span class="sig-name descname"><span class="pre">get_joint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">joint_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JointIndex" title="pydrake.multibody.tree.JointIndex"><span class="pre">pydrake.multibody.tree.JointIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Joint" title="pydrake.multibody.tree.Joint"><span class="pre">pydrake.multibody.tree.Joint</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.get_joint" title="Permalink to this definition"></a></dt>
<dd><p>Returns a constant reference to the joint with unique index
<code class="docutils literal notranslate"><span class="pre">joint_index</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError when joint_index does not correspond to a joint</strong> – </p></li>
<li><p><strong>in this model.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.get_joint_actuator">
<span class="sig-name descname"><span class="pre">get_joint_actuator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">actuator_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JointActuatorIndex" title="pydrake.multibody.tree.JointActuatorIndex"><span class="pre">pydrake.multibody.tree.JointActuatorIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JointActuator" title="pydrake.multibody.tree.JointActuator"><span class="pre">pydrake.multibody.tree.JointActuator</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.get_joint_actuator" title="Permalink to this definition"></a></dt>
<dd><p>Returns a constant reference to the joint actuator with unique index
<code class="docutils literal notranslate"><span class="pre">actuator_index</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if actuator_index does not correspond to a joint</strong> – </p></li>
<li><p><strong>actuator in this tree.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.get_mutable_joint">
<span class="sig-name descname"><span class="pre">get_mutable_joint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">joint_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JointIndex" title="pydrake.multibody.tree.JointIndex"><span class="pre">pydrake.multibody.tree.JointIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Joint" title="pydrake.multibody.tree.Joint"><span class="pre">pydrake.multibody.tree.Joint</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.get_mutable_joint" title="Permalink to this definition"></a></dt>
<dd><p>Returns a mutable reference to the joint with unique index
<code class="docutils literal notranslate"><span class="pre">joint_index</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError when joint_index does not correspond to a joint</strong> – </p></li>
<li><p><strong>in this model.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.get_mutable_joint_actuator">
<span class="sig-name descname"><span class="pre">get_mutable_joint_actuator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">actuator_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JointActuatorIndex" title="pydrake.multibody.tree.JointActuatorIndex"><span class="pre">pydrake.multibody.tree.JointActuatorIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JointActuator" title="pydrake.multibody.tree.JointActuator"><span class="pre">pydrake.multibody.tree.JointActuator</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.get_mutable_joint_actuator" title="Permalink to this definition"></a></dt>
<dd><p>Returns a mutable reference to the joint actuator with unique index
<code class="docutils literal notranslate"><span class="pre">actuator_index</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if actuator_index does not correspond to a joint</strong> – </p></li>
<li><p><strong>actuator in this tree.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.get_net_actuation_output_port">
<span class="sig-name descname"><span class="pre">get_net_actuation_output_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.get_net_actuation_output_port" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>get_net_actuation_output_port(self: pydrake.multibody.plant.MultibodyPlant) -&gt; pydrake.systems.framework.OutputPort</p></li>
</ol>
<p>Returns a constant reference to the output port that reports actuation
values applied through joint actuators. This output port is a vector
valued port. The actuation value for a particular actuator can be
found at offset JointActuator::input_start() in this vector. Models
that include PD controllers will include their contribution in this
port, refer to mbp_actuation “Actuation” for further details.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>PD controllers are not considered for actuators on locked joints,
see Joint::Lock(). Therefore they do not contribute to this port.</p>
</div>
<dl class="simple">
<dt>Precondition:</dt><dd><p>Finalize() was already called on <code class="docutils literal notranslate"><span class="pre">this</span></code> plant.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if called before Finalize</strong><strong>(</strong><strong>)</strong><strong></strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>get_net_actuation_output_port(self: pydrake.multibody.plant.MultibodyPlant, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; pydrake.systems.framework.OutputPort</p></li>
</ol>
<p>Returns a constant reference to the output port that reports actuation
values applied through joint actuators, for a specific model instance.
Models that include PD controllers will include their contribution in
this port, refer to mbp_actuation “Actuation” for further details.
This is a vector valued port with entries ordered by monotonically
increasing JointActuatorIndex within <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>.</p>
<p>Every model instance in <code class="docutils literal notranslate"><span class="pre">this</span></code> plant model has a net actuation
output port, even if zero sized (for model instance with no
actuators).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>PD controllers are not considered for actuators on locked joints,
see Joint::Lock(). Therefore they do not contribute to this port.</p>
</div>
<dl class="simple">
<dt>Precondition:</dt><dd><p>Finalize() was already called on <code class="docutils literal notranslate"><span class="pre">this</span></code> plant.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if called before Finalize</strong><strong>(</strong><strong>)</strong><strong></strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.get_reaction_forces_output_port">
<span class="sig-name descname"><span class="pre">get_reaction_forces_output_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.OutputPort" title="pydrake.systems.framework.OutputPort"><span class="pre">pydrake.systems.framework.OutputPort</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.get_reaction_forces_output_port" title="Permalink to this definition"></a></dt>
<dd><p>Returns the port for joint reaction forces. A Joint models the
kinematical relationship which characterizes the possible relative
motion between two bodies. In Drake, a joint connects a frame <code class="docutils literal notranslate"><span class="pre">Jp</span></code>
on <em>parent</em> body P with a frame <code class="docutils literal notranslate"><span class="pre">Jc</span></code> on a <em>child</em> body C. This usage
of the terms <em>parent</em> and <em>child</em> is just a convention and implies
nothing about the inboard-outboard relationship between the bodies.
Since a Joint imposes a kinematical relationship which characterizes
the possible relative motion between frames Jp and Jc, reaction forces
on each body are established. That is, we could cut the model at the
joint and replace it with equivalent forces equal to these reaction
forces in order to attain the same motions of the mechanical system.</p>
<p>This output port allows to evaluate the reaction force <code class="docutils literal notranslate"><span class="pre">F_CJc_Jc</span></code> on
the <em>child</em> body C, at <code class="docutils literal notranslate"><span class="pre">Jc</span></code>, and expressed in Jc for all joints in
the model. This port evaluates to a vector of type
std::vector&lt;SpatialForce&lt;T&gt;&gt; and size num_joints() indexed by
JointIndex, see Joint::index(). Each entry corresponds to the spatial
force <code class="docutils literal notranslate"><span class="pre">F_CJc_Jc</span></code> applied on the joint’s child body C
(Joint::child_body()), at the joint’s child frame <code class="docutils literal notranslate"><span class="pre">Jc</span></code>
(Joint::frame_on_child()) and expressed in frame <code class="docutils literal notranslate"><span class="pre">Jc</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.get_sap_near_rigid_threshold">
<span class="sig-name descname"><span class="pre">get_sap_near_rigid_threshold</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.get_sap_near_rigid_threshold" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the SAP near rigid regime threshold.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>See set_sap_near_rigid_threshold().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.get_source_id">
<span class="sig-name descname"><span class="pre">get_source_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.SourceId" title="pydrake.geometry.SourceId"><span class="pre">pydrake.geometry.SourceId</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.get_source_id" title="Permalink to this definition"></a></dt>
<dd><p>Returns the unique id identifying <code class="docutils literal notranslate"><span class="pre">this</span></code> plant as a source for a
SceneGraph. Returns <code class="docutils literal notranslate"><span class="pre">nullopt</span></code> if <code class="docutils literal notranslate"><span class="pre">this</span></code> plant did not register any
geometry. This method can be called at any time during the lifetime of
<code class="docutils literal notranslate"><span class="pre">this</span></code> plant to query if <code class="docutils literal notranslate"><span class="pre">this</span></code> plant has been registered with a
SceneGraph, either pre- or post-finalize, see Finalize(). However, a
geometry::SourceId is only assigned once at the first call of any of
this plant’s geometry registration methods, and it does not change
after that. Post-finalize calls will always return the same value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.get_state_output_port">
<span class="sig-name descname"><span class="pre">get_state_output_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.get_state_output_port" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>get_state_output_port(self: pydrake.multibody.plant.MultibodyPlant) -&gt; pydrake.systems.framework.OutputPort</p></li>
</ol>
<p>Returns a constant reference to the output port for the multibody
state x = [q, v] of the model.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>Finalize() was already called on <code class="docutils literal notranslate"><span class="pre">this</span></code> plant.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if called before Finalize</strong><strong>(</strong><strong>)</strong><strong></strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>get_state_output_port(self: pydrake.multibody.plant.MultibodyPlant, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; pydrake.systems.framework.OutputPort</p></li>
</ol>
<p>Returns a constant reference to the output port for the state xᵢ = [qᵢ
vᵢ] of model instance i. (Here qᵢ ⊆ q and vᵢ ⊆ v.)</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>Finalize() was already called on <code class="docutils literal notranslate"><span class="pre">this</span></code> plant.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if called before Finalize</strong><strong>(</strong><strong>)</strong><strong></strong> – </p></li>
<li><p><strong>RuntimeError if the model instance does not exist.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetAccelerationLowerLimits">
<span class="sig-name descname"><span class="pre">GetAccelerationLowerLimits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetAccelerationLowerLimits" title="Permalink to this definition"></a></dt>
<dd><p>Returns a vector of size <code class="docutils literal notranslate"><span class="pre">num_velocities()</span></code> containing the lower
acceleration limits for every generalized velocity coordinate. These
include joint and free body coordinates. Any unbounded or unspecified
limits will be -infinity.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetAccelerationUpperLimits">
<span class="sig-name descname"><span class="pre">GetAccelerationUpperLimits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetAccelerationUpperLimits" title="Permalink to this definition"></a></dt>
<dd><p>Upper limit analog of GetAccelerationsLowerLimits(), where any
unbounded or unspecified limits will be +infinity.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>GetAccelerationLowerLimits() for more information.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetActuatedJointIndices">
<span class="sig-name descname"><span class="pre">GetActuatedJointIndices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JointIndex" title="pydrake.multibody.tree.JointIndex"><span class="pre">pydrake.multibody.tree.JointIndex</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetActuatedJointIndices" title="Permalink to this definition"></a></dt>
<dd><p>Returns a list of actuated joint indices associated with
<code class="docutils literal notranslate"><span class="pre">model_instance</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetActuatorNames">
<span class="sig-name descname"><span class="pre">GetActuatorNames</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetActuatorNames" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetActuatorNames(self: pydrake.multibody.plant.MultibodyPlant, add_model_instance_prefix: bool = True) -&gt; List[str]</p></li>
</ol>
<p>Returns a list of string names corresponding to each element of the
actuation vector. These strings take the form
<code class="docutils literal notranslate"><span class="pre">{model_instance_name}_{joint_actuator_name}</span></code>, but the prefix may
optionally be withheld using <code class="docutils literal notranslate"><span class="pre">add_model_instance_prefix</span></code>.</p>
<p>The returned names are guaranteed to be unique if
<code class="docutils literal notranslate"><span class="pre">add_model_instance_prefix</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code> (the default).</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if the plant is not finalized.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>GetActuatorNames(self: pydrake.multibody.plant.MultibodyPlant, model_instance: pydrake.multibody.tree.ModelInstanceIndex, add_model_instance_prefix: bool = False) -&gt; List[str]</p></li>
</ol>
<p>Returns a list of string names corresponding to each element of the
actuation vector. These strings take the form
<code class="docutils literal notranslate"><span class="pre">{model_instance_name}_{joint_actuator_name}</span></code>, but the prefix may
optionally be withheld using <code class="docutils literal notranslate"><span class="pre">add_model_instance_prefix</span></code>.</p>
<p>The returned names are guaranteed to be unique.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the plant is not finalized</strong><strong> or </strong><strong>if the</strong> – </p></li>
<li><p><strong>model_instance` is invalid</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetBodiesKinematicallyAffectedBy">
<span class="sig-name descname"><span class="pre">GetBodiesKinematicallyAffectedBy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">joint_indexes</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JointIndex" title="pydrake.multibody.tree.JointIndex"><span class="pre">pydrake.multibody.tree.JointIndex</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.BodyIndex" title="pydrake.multibody.tree.BodyIndex"><span class="pre">pydrake.multibody.tree.BodyIndex</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetBodiesKinematicallyAffectedBy" title="Permalink to this definition"></a></dt>
<dd><p>Returns all bodies whose kinematics are transitively affected by the
given vector of joints. The affected bodies are returned in increasing
order of body indexes. Note that this is a kinematic relationship
rather than a dynamic one. For example, if one of the inboard joints
is a free (6dof) joint, the kinematic influence is still felt even
though dynamically there would be no influence on the outboard body.
This function can be only be called post-finalize, see Finalize().</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if any of the given joint has an invalid index</strong><strong>,</strong> – </p></li>
<li><p><strong>doesn't correspond to a mobilizer</strong><strong>, or </strong><strong>is welded.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetBodiesWeldedTo">
<span class="sig-name descname"><span class="pre">GetBodiesWeldedTo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">body</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody" title="pydrake.multibody.tree.RigidBody"><span class="pre">pydrake.multibody.tree.RigidBody</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody" title="pydrake.multibody.tree.RigidBody"><span class="pre">pydrake.multibody.tree.RigidBody</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetBodiesWeldedTo" title="Permalink to this definition"></a></dt>
<dd><p>Returns all bodies that are transitively welded, or rigidly affixed,
to <code class="docutils literal notranslate"><span class="pre">body</span></code>, per these two definitions:</p>
<ol class="arabic simple">
<li><p>A body is always considered welded to itself.</p></li>
</ol>
<p>2. Two unique bodies are considered welded together exclusively by the
presence of a weld joint, not by other constructs that prevent mobility
(e.g. constraints).</p>
<p>This method can be called at any time during the lifetime of <code class="docutils literal notranslate"><span class="pre">this</span></code>
plant, either pre- or post-finalize, see Finalize().</p>
<p>Meant to be used with <code class="docutils literal notranslate"><span class="pre">CollectRegisteredGeometries</span></code>.</p>
<p>The following example demonstrates filtering collisions between all
bodies rigidly affixed to a door (which could be moving) and all
bodies rigidly affixed to the world:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">GeometrySet</span><span class="w"> </span><span class="n">g_world</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">plant</span><span class="p">.</span><span class="n">CollectRegisteredGeometries</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">plant</span><span class="p">.</span><span class="n">GetBodiesWeldedTo</span><span class="p">(</span><span class="n">plant</span><span class="p">.</span><span class="n">world_body</span><span class="p">()));</span><span class="w"></span>
<span class="n">GeometrySet</span><span class="w"> </span><span class="n">g_door</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">plant</span><span class="p">.</span><span class="n">CollectRegisteredGeometries</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">plant</span><span class="p">.</span><span class="n">GetBodiesWeldedTo</span><span class="p">(</span><span class="n">plant</span><span class="p">.</span><span class="n">GetBodyByName</span><span class="p">(</span><span class="s">&quot;door&quot;</span><span class="p">)));</span><span class="w"></span>
<span class="n">scene_graph</span><span class="p">.</span><span class="n">ExcludeCollisionsBetweeen</span><span class="p">(</span><span class="n">g_world</span><span class="p">,</span><span class="w"> </span><span class="n">g_door</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</details><div class="admonition note">
<p class="admonition-title">Note</p>
<p>Usages akin to this example may introduce redundant collision
filtering; this will not have a functional impact, but may have a
minor performance impact.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>all bodies rigidly fixed to <code class="docutils literal notranslate"><span class="pre">body</span></code>. This does not return the
bodies in any prescribed order.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>RuntimeError if body is not part of this plant.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetBodyByName">
<span class="sig-name descname"><span class="pre">GetBodyByName</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetBodyByName" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetBodyByName(self: pydrake.multibody.plant.MultibodyPlant, name: str) -&gt; pydrake.multibody.tree.RigidBody</p></li>
</ol>
<p>Returns a constant reference to a body that is identified by the
string <code class="docutils literal notranslate"><span class="pre">name</span></code> in <code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if there is no body with the requested name.</strong> – </p></li>
<li><p><strong>RuntimeError if the body name occurs in multiple model instances.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>HasBodyNamed() to query if there exists a body in <code class="docutils literal notranslate"><span class="pre">this</span></code>
MultibodyPlant with a given specified name.</p>
</div>
<ol class="arabic simple" start="2">
<li><p>GetBodyByName(self: pydrake.multibody.plant.MultibodyPlant, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; pydrake.multibody.tree.RigidBody</p></li>
</ol>
<p>Returns a constant reference to the body that is uniquely identified
by the string <code class="docutils literal notranslate"><span class="pre">name</span></code> and <code class="docutils literal notranslate"><span class="pre">model_instance</span></code> in <code class="docutils literal notranslate"><span class="pre">this</span></code>
MultibodyPlant.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if there is no body with the requested name.</strong> – </p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>HasBodyNamed() to query if there exists a body in <code class="docutils literal notranslate"><span class="pre">this</span></code>
MultibodyPlant with a given specified name.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetBodyFrameIdIfExists">
<span class="sig-name descname"><span class="pre">GetBodyFrameIdIfExists</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">body_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.BodyIndex" title="pydrake.multibody.tree.BodyIndex"><span class="pre">pydrake.multibody.tree.BodyIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.FrameId" title="pydrake.geometry.FrameId"><span class="pre">pydrake.geometry.FrameId</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetBodyFrameIdIfExists" title="Permalink to this definition"></a></dt>
<dd><p>If the body with <code class="docutils literal notranslate"><span class="pre">body_index</span></code> belongs to the called plant, it
returns the geometry::FrameId associated with it. Otherwise, it
returns nullopt.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetBodyFrameIdOrThrow">
<span class="sig-name descname"><span class="pre">GetBodyFrameIdOrThrow</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">body_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.BodyIndex" title="pydrake.multibody.tree.BodyIndex"><span class="pre">pydrake.multibody.tree.BodyIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.FrameId" title="pydrake.geometry.FrameId"><span class="pre">pydrake.geometry.FrameId</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetBodyFrameIdOrThrow" title="Permalink to this definition"></a></dt>
<dd><p>If the body with <code class="docutils literal notranslate"><span class="pre">body_index</span></code> belongs to the called plant, it
returns the geometry::FrameId associated with it. Otherwise this
method throws an exception.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the called plant does not have the body indicated</strong> – </p></li>
<li><p><strong>by body_index.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetBodyFromFrameId">
<span class="sig-name descname"><span class="pre">GetBodyFromFrameId</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.FrameId" title="pydrake.geometry.FrameId"><span class="pre">pydrake.geometry.FrameId</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody" title="pydrake.multibody.tree.RigidBody"><span class="pre">pydrake.multibody.tree.RigidBody</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetBodyFromFrameId" title="Permalink to this definition"></a></dt>
<dd><p>Given a geometry frame identifier, returns a pointer to the body
associated with that id (nullptr if there is no such body).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetBodyIndices">
<span class="sig-name descname"><span class="pre">GetBodyIndices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.BodyIndex" title="pydrake.multibody.tree.BodyIndex"><span class="pre">pydrake.multibody.tree.BodyIndex</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetBodyIndices" title="Permalink to this definition"></a></dt>
<dd><p>Returns a list of body indices associated with <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetCollisionGeometriesForBody">
<span class="sig-name descname"><span class="pre">GetCollisionGeometriesForBody</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">body</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody" title="pydrake.multibody.tree.RigidBody"><span class="pre">pydrake.multibody.tree.RigidBody</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.GeometryId" title="pydrake.geometry.GeometryId"><span class="pre">pydrake.geometry.GeometryId</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetCollisionGeometriesForBody" title="Permalink to this definition"></a></dt>
<dd><p>Returns an array of GeometryId’s identifying the different contact
geometries for <code class="docutils literal notranslate"><span class="pre">body</span></code> previously registered with a SceneGraph.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method can be called at any time during the lifetime of
<code class="docutils literal notranslate"><span class="pre">this</span></code> plant, either pre- or post-finalize, see Finalize().
Post-finalize calls will always return the same value.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>RegisterCollisionGeometry(), Finalize()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetConstraintActiveStatus">
<span class="sig-name descname"><span class="pre">GetConstraintActiveStatus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context" title="pydrake.systems.framework.Context"><span class="pre">pydrake.systems.framework.Context</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">id</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.MultibodyConstraintId" title="pydrake.multibody.tree.MultibodyConstraintId"><span class="pre">pydrake.multibody.tree.MultibodyConstraintId</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetConstraintActiveStatus" title="Permalink to this definition"></a></dt>
<dd><p>Returns the active status of the constraint given by <code class="docutils literal notranslate"><span class="pre">id</span></code> in
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the MultibodyPlant has not been finalized.</strong> – </p></li>
<li><p><strong>RuntimeError if id does not belong to any multibody constraint</strong> – </p></li>
<li><p><strong>in context.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetDefaultContactSurfaceRepresentation">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">GetDefaultContactSurfaceRepresentation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">time_step</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.HydroelasticContactRepresentation" title="pydrake.geometry.HydroelasticContactRepresentation"><span class="pre">pydrake.geometry.HydroelasticContactRepresentation</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetDefaultContactSurfaceRepresentation" title="Permalink to this definition"></a></dt>
<dd><p>Return the default value for contact representation, given the desired
time step. Discrete systems default to use polygons; continuous
systems default to use triangles.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetDefaultFreeBodyPose">
<span class="sig-name descname"><span class="pre">GetDefaultFreeBodyPose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">body</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody" title="pydrake.multibody.tree.RigidBody"><span class="pre">pydrake.multibody.tree.RigidBody</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.math.html#pydrake.math.RigidTransform" title="pydrake.math.RigidTransform"><span class="pre">pydrake.math.RigidTransform</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetDefaultFreeBodyPose" title="Permalink to this definition"></a></dt>
<dd><p>Gets the default pose of <code class="docutils literal notranslate"><span class="pre">body</span></code> as set by SetDefaultFreeBodyPose().
If no pose is specified for the body, returns the identity pose.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body</span></code>:</dt><dd><p>RigidBody whose default pose will be retrieved.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetDefaultPositions">
<span class="sig-name descname"><span class="pre">GetDefaultPositions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetDefaultPositions" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetDefaultPositions(self: pydrake.multibody.plant.MultibodyPlant) -&gt; numpy.ndarray[numpy.float64[m, 1]]</p></li>
</ol>
<p>Gets the default positions for the plant, which can be changed via
SetDefaultPositions().</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if the plant is not finalized.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>GetDefaultPositions(self: pydrake.multibody.plant.MultibodyPlant, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; numpy.ndarray[numpy.float64[m, 1]]</p></li>
</ol>
<p>Gets the default positions for the plant for a given model instance,
which can be changed via SetDefaultPositions().</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the plant is not finalized</strong><strong>, or </strong><strong>if the</strong> – </p></li>
<li><p><strong>model_instance is invalid</strong><strong>,</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetEffortLowerLimits">
<span class="sig-name descname"><span class="pre">GetEffortLowerLimits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetEffortLowerLimits" title="Permalink to this definition"></a></dt>
<dd><p>Returns a vector of size <code class="docutils literal notranslate"><span class="pre">num_actuated_dofs()</span></code> containing the lower
effort limits for every actuator. Any unbounded or unspecified limits
will be -∞. The returned vector is indexed by JointActuatorIndex, see
JointActuator::index().</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>GetEffortUpperLimits()</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetEffortUpperLimits">
<span class="sig-name descname"><span class="pre">GetEffortUpperLimits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetEffortUpperLimits" title="Permalink to this definition"></a></dt>
<dd><p>Returns a vector of size <code class="docutils literal notranslate"><span class="pre">num_actuated_dofs()</span></code> containing the upper
effort limits for every actuator. Any unbounded or unspecified limits
will be +∞. The returned vector is indexed by JointActuatorIndex, see
JointActuator::index().</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>GetEffortLowerLimits()</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetFloatingBaseBodies">
<span class="sig-name descname"><span class="pre">GetFloatingBaseBodies</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Set</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.BodyIndex" title="pydrake.multibody.tree.BodyIndex"><span class="pre">pydrake.multibody.tree.BodyIndex</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetFloatingBaseBodies" title="Permalink to this definition"></a></dt>
<dd><p>Returns the set of body indexes corresponding to the free (floating)
bodies in the model, in no particular order.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize</strong><strong>, </strong><strong>see Finalize</strong><strong>(</strong><strong>)</strong><strong></strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetFrameByName">
<span class="sig-name descname"><span class="pre">GetFrameByName</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetFrameByName" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetFrameByName(self: pydrake.multibody.plant.MultibodyPlant, name: str) -&gt; pydrake.multibody.tree.Frame</p></li>
</ol>
<p>Returns a constant reference to a frame that is identified by the
string <code class="docutils literal notranslate"><span class="pre">name</span></code> in <code class="docutils literal notranslate"><span class="pre">this</span></code> model.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if there is no frame with the requested name.</strong> – </p></li>
<li><p><strong>RuntimeError if the frame name occurs in multiple model instances.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>HasFrameNamed() to query if there exists a frame in <code class="docutils literal notranslate"><span class="pre">this</span></code> model
with a given specified name.</p>
</div>
<ol class="arabic simple" start="2">
<li><p>GetFrameByName(self: pydrake.multibody.plant.MultibodyPlant, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; pydrake.multibody.tree.Frame</p></li>
</ol>
<p>Returns a constant reference to the frame that is uniquely identified
by the string <code class="docutils literal notranslate"><span class="pre">name</span></code> in <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if there is no frame with the requested name.</strong> – </p></li>
<li><p><strong>RuntimeError if model_instance is not valid for this model.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>HasFrameNamed() to query if there exists a frame in <code class="docutils literal notranslate"><span class="pre">this</span></code> model
with a given specified name.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetFrameIndices">
<span class="sig-name descname"><span class="pre">GetFrameIndices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.FrameIndex" title="pydrake.multibody.tree.FrameIndex"><span class="pre">pydrake.multibody.tree.FrameIndex</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetFrameIndices" title="Permalink to this definition"></a></dt>
<dd><p>Returns a list of frame indices associated with <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetFreeBodyPose">
<span class="sig-name descname"><span class="pre">GetFreeBodyPose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context" title="pydrake.systems.framework.Context"><span class="pre">pydrake.systems.framework.Context</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">body</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody" title="pydrake.multibody.tree.RigidBody"><span class="pre">pydrake.multibody.tree.RigidBody</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.math.html#pydrake.math.RigidTransform" title="pydrake.math.RigidTransform"><span class="pre">pydrake.math.RigidTransform</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetFreeBodyPose" title="Permalink to this definition"></a></dt>
<dd><p>Gets the pose of a given <code class="docutils literal notranslate"><span class="pre">body</span></code> in the world frame W.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In general getting the pose of a body in the model would involve
solving the kinematics. This method allows us to simplify this
process when we know the body is free in space.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if body is not a free body in the model.</strong> – </p></li>
<li><p><strong>RuntimeError if called pre-finalize.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetJointActuatorByName">
<span class="sig-name descname"><span class="pre">GetJointActuatorByName</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetJointActuatorByName" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetJointActuatorByName(self: pydrake.multibody.plant.MultibodyPlant, name: str) -&gt; pydrake.multibody.tree.JointActuator</p></li>
</ol>
<p>Returns a constant reference to an actuator that is identified by the
string <code class="docutils literal notranslate"><span class="pre">name</span></code> in <code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if there is no actuator with the requested name.</strong> – </p></li>
<li><p><strong>RuntimeError if the actuator name occurs in multiple model</strong> – </p></li>
<li><p><strong>instances.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>HasJointActuatorNamed() to query if there exists an actuator in
<code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant with a given specified name.</p>
</div>
<ol class="arabic simple" start="2">
<li><p>GetJointActuatorByName(self: pydrake.multibody.plant.MultibodyPlant, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; pydrake.multibody.tree.JointActuator</p></li>
</ol>
<p>Returns a constant reference to the actuator that is uniquely
identified by the string <code class="docutils literal notranslate"><span class="pre">name</span></code> and <code class="docutils literal notranslate"><span class="pre">model_instance</span></code> in <code class="docutils literal notranslate"><span class="pre">this</span></code>
MultibodyPlant.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if there is no actuator with the requested name.</strong> – </p></li>
<li><p><strong>RuntimeError if model_instance is not valid for this model.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>HasJointActuatorNamed() to query if there exists an actuator in
<code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant with a given specified name.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetJointActuatorIndices">
<span class="sig-name descname"><span class="pre">GetJointActuatorIndices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetJointActuatorIndices" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetJointActuatorIndices(self: pydrake.multibody.plant.MultibodyPlant) -&gt; List[pydrake.multibody.tree.JointActuatorIndex]</p></li>
</ol>
<p>Returns a list of all joint actuator indices. The vector is ordered by
monotonically increasing JointActuatorIndex, but the indexes will in
general not be consecutive due to actuators that were removed.</p>
<ol class="arabic simple" start="2">
<li><p>GetJointActuatorIndices(self: pydrake.multibody.plant.MultibodyPlant, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; List[pydrake.multibody.tree.JointActuatorIndex]</p></li>
</ol>
<p>Returns a list of joint actuator indices associated with
<code class="docutils literal notranslate"><span class="pre">model_instance</span></code>. The vector is ordered by monotonically increasing
JointActuatorIndex.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetJointByName">
<span class="sig-name descname"><span class="pre">GetJointByName</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Joint" title="pydrake.multibody.tree.Joint"><span class="pre">pydrake.multibody.tree.Joint</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetJointByName" title="Permalink to this definition"></a></dt>
<dd><p>Returns a constant reference to a joint that is identified by the
string <code class="docutils literal notranslate"><span class="pre">name</span></code> in <code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant. If the optional template
argument is supplied, then the returned value is downcast to the
specified <code class="docutils literal notranslate"><span class="pre">JointType</span></code>.</p>
<dl class="simple">
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">JointType</span></code>:</dt><dd><p>The specific type of the Joint to be retrieved. It must be a
subclass of Joint.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the named joint is not of type JointType</strong><strong> or </strong><strong>if</strong> – </p></li>
<li><p><strong>there is no Joint with that name.</strong> – </p></li>
<li><p><strong>RuntimeError if model_instance is not valid for this model.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>HasJointNamed() to query if there exists a joint in <code class="docutils literal notranslate"><span class="pre">this</span></code>
MultibodyPlant with a given specified name.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetJointIndices">
<span class="sig-name descname"><span class="pre">GetJointIndices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetJointIndices" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetJointIndices(self: pydrake.multibody.plant.MultibodyPlant) -&gt; List[pydrake.multibody.tree.JointIndex]</p></li>
</ol>
<p>Returns a list of all joint indices. The vector is ordered by
monotonically increasing JointIndex, but the indexes will in general
not be consecutive due to joints that were removed.</p>
<ol class="arabic simple" start="2">
<li><p>GetJointIndices(self: pydrake.multibody.plant.MultibodyPlant, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; List[pydrake.multibody.tree.JointIndex]</p></li>
</ol>
<p>Returns a list of joint indices associated with <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetModelInstanceByName">
<span class="sig-name descname"><span class="pre">GetModelInstanceByName</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetModelInstanceByName" title="Permalink to this definition"></a></dt>
<dd><p>Returns the index to the model instance that is uniquely identified by
the string <code class="docutils literal notranslate"><span class="pre">name</span></code> in <code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if there is no instance with the requested name.</strong> – </p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>HasModelInstanceNamed() to query if there exists an instance in
<code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant with a given specified name.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetModelInstanceName">
<span class="sig-name descname"><span class="pre">GetModelInstanceName</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">str</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetModelInstanceName" title="Permalink to this definition"></a></dt>
<dd><p>Returns the name of a <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError when model_instance does not correspond to a</strong> – </p></li>
<li><p><strong>model in this model.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetMutableJointByName">
<span class="sig-name descname"><span class="pre">GetMutableJointByName</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Joint" title="pydrake.multibody.tree.Joint"><span class="pre">pydrake.multibody.tree.Joint</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetMutableJointByName" title="Permalink to this definition"></a></dt>
<dd><p>Returns a constant reference to a joint that is identified by the
string <code class="docutils literal notranslate"><span class="pre">name</span></code> in <code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant. If the optional template
argument is supplied, then the returned value is downcast to the
specified <code class="docutils literal notranslate"><span class="pre">JointType</span></code>.</p>
<dl class="simple">
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">JointType</span></code>:</dt><dd><p>The specific type of the Joint to be retrieved. It must be a
subclass of Joint.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the named joint is not of type JointType</strong><strong> or </strong><strong>if</strong> – </p></li>
<li><p><strong>there is no Joint with that name.</strong> – </p></li>
<li><p><strong>RuntimeError if model_instance is not valid for this model.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>HasJointNamed() to query if there exists a joint in <code class="docutils literal notranslate"><span class="pre">this</span></code>
MultibodyPlant with a given specified name.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetPositionLowerLimits">
<span class="sig-name descname"><span class="pre">GetPositionLowerLimits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetPositionLowerLimits" title="Permalink to this definition"></a></dt>
<dd><p>Returns a vector of size <code class="docutils literal notranslate"><span class="pre">num_positions()</span></code> containing the lower
position limits for every generalized position coordinate. These
include joint and free body coordinates. Any unbounded or unspecified
limits will be -infinity.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetPositionNames">
<span class="sig-name descname"><span class="pre">GetPositionNames</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetPositionNames" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetPositionNames(self: pydrake.multibody.plant.MultibodyPlant, add_model_instance_prefix: bool = True, always_add_suffix: bool = True) -&gt; List[str]</p></li>
</ol>
<p>Returns a list of string names corresponding to each element of the
position vector. These strings take the form
<code class="docutils literal notranslate"><span class="pre">{model_instance_name}_{joint_name}_{joint_position_suffix}</span></code>, but
the prefix and suffix may optionally be withheld using
<code class="docutils literal notranslate"><span class="pre">add_model_instance_prefix</span></code> and <code class="docutils literal notranslate"><span class="pre">always_add_suffix</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">always_add_suffix</span></code>:</dt><dd><p>(optional). If true, then the suffix is always added. If false,
then the suffix is only added for joints that have more than one
position (in this case, not adding would lead to ambiguity).</p>
</dd>
</dl>
<p>The returned names are guaranteed to be unique if
<code class="docutils literal notranslate"><span class="pre">add_model_instance_prefix</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code> (the default).</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if the plant is not finalized.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>GetPositionNames(self: pydrake.multibody.plant.MultibodyPlant, model_instance: pydrake.multibody.tree.ModelInstanceIndex, add_model_instance_prefix: bool = False, always_add_suffix: bool = True) -&gt; List[str]</p></li>
</ol>
<p>Returns a list of string names corresponding to each element of the
position vector. These strings take the form
<code class="docutils literal notranslate"><span class="pre">{model_instance_name}_{joint_name}_{joint_position_suffix}</span></code>, but
the prefix and suffix may optionally be withheld using
<code class="docutils literal notranslate"><span class="pre">add_model_instance_prefix</span></code> and <code class="docutils literal notranslate"><span class="pre">always_add_suffix</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">always_add_suffix</span></code>:</dt><dd><p>(optional). If true, then the suffix is always added. If false,
then the suffix is only added for joints that have more than one
position (in this case, not adding would lead to ambiguity).</p>
</dd>
</dl>
<p>The returned names are guaranteed to be unique.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the plant is not finalized</strong><strong> or </strong><strong>if the</strong> – </p></li>
<li><p><strong>model_instance` is invalid</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetPositions">
<span class="sig-name descname"><span class="pre">GetPositions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetPositions" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetPositions(self: pydrake.multibody.plant.MultibodyPlant, context: pydrake.systems.framework.Context) -&gt; numpy.ndarray[numpy.float64[m, 1]]</p></li>
</ol>
<p>Returns a const vector reference to the vector of generalized
positions q in a given Context.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method returns a reference to existing data, exhibits
constant i.e., O(1) time complexity, and runs very quickly.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if context does not correspond to the Context for</strong> – </p></li>
<li><p><strong>a multibody model.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>GetPositions(self: pydrake.multibody.plant.MultibodyPlant, context: pydrake.systems.framework.Context, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; numpy.ndarray[numpy.float64[m, 1]]</p></li>
</ol>
<p>Returns a vector containing the generalized positions q of a specified
model instance in a given Context.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Returns a dense vector of dimension
<code class="docutils literal notranslate"><span class="pre">num_positions(model_instance)</span></code> associated with
<code class="docutils literal notranslate"><span class="pre">model_instance</span></code> by copying from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if context does not correspond to the Context for</strong> – </p></li>
<li><p><strong>a multibody model</strong><strong> or </strong><strong>model_instance is invalid.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li><p>GetPositions(self: pydrake.multibody.plant.MultibodyPlant, context: pydrake.systems.framework.Context) -&gt; numpy.ndarray[numpy.float64[m, 1]]</p></li>
</ol>
<p>Returns a const vector reference to the vector of generalized
positions q in a given Context.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method returns a reference to existing data, exhibits
constant i.e., O(1) time complexity, and runs very quickly.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if context does not correspond to the Context for</strong> – </p></li>
<li><p><strong>a multibody model.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="4">
<li><p>GetPositions(self: pydrake.multibody.plant.MultibodyPlant, context: pydrake.systems.framework.Context, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; numpy.ndarray[numpy.float64[m, 1]]</p></li>
</ol>
<p>Returns a vector containing the generalized positions q of a specified
model instance in a given Context.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Returns a dense vector of dimension
<code class="docutils literal notranslate"><span class="pre">num_positions(model_instance)</span></code> associated with
<code class="docutils literal notranslate"><span class="pre">model_instance</span></code> by copying from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if context does not correspond to the Context for</strong> – </p></li>
<li><p><strong>a multibody model</strong><strong> or </strong><strong>model_instance is invalid.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetPositionsAndVelocities">
<span class="sig-name descname"><span class="pre">GetPositionsAndVelocities</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetPositionsAndVelocities" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetPositionsAndVelocities(self: pydrake.multibody.plant.MultibodyPlant, context: pydrake.systems.framework.Context) -&gt; numpy.ndarray[numpy.float64[m, 1]]</p></li>
</ol>
<p>Returns a const vector reference <code class="docutils literal notranslate"><span class="pre">[q;</span> <span class="pre">v]</span></code> to the generalized
positions q and generalized velocities v in a given Context.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method returns a reference to existing data, exhibits
constant i.e., O(1) time complexity, and runs very quickly.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if context does not correspond to the Context for</strong> – </p></li>
<li><p><strong>a multibody model.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>GetPositionsAndVelocities(self: pydrake.multibody.plant.MultibodyPlant, context: pydrake.systems.framework.Context, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; numpy.ndarray[numpy.float64[m, 1]]</p></li>
</ol>
<p>Returns a vector <code class="docutils literal notranslate"><span class="pre">[q;</span> <span class="pre">v]</span></code> containing the generalized positions q and
generalized velocities v of a specified model instance in a given
Context.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Returns a dense vector of dimension
<code class="docutils literal notranslate"><span class="pre">num_positions(model_instance)</span> <span class="pre">+</span> <span class="pre">num_velocities(model_instance)</span></code>
associated with <code class="docutils literal notranslate"><span class="pre">model_instance</span></code> by copying from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if context does not correspond to the Context for</strong> – </p></li>
<li><p><strong>a multibody model</strong><strong> or </strong><strong>model_instance is invalid.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetPositionsFromArray">
<span class="sig-name descname"><span class="pre">GetPositionsFromArray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetPositionsFromArray" title="Permalink to this definition"></a></dt>
<dd><p>Returns a vector of generalized positions for <code class="docutils literal notranslate"><span class="pre">model_instance</span></code> from
a vector <code class="docutils literal notranslate"><span class="pre">q_array</span></code> of generalized positions for the entire model
model. This method throws an exception if <code class="docutils literal notranslate"><span class="pre">q</span></code> is not of size
MultibodyPlant::num_positions().</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetPositionUpperLimits">
<span class="sig-name descname"><span class="pre">GetPositionUpperLimits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetPositionUpperLimits" title="Permalink to this definition"></a></dt>
<dd><p>Upper limit analog of GetPositionLowerLimits(), where any unbounded or
unspecified limits will be +infinity.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>GetPositionLowerLimits() for more information.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetRigidBodyByName">
<span class="sig-name descname"><span class="pre">GetRigidBodyByName</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetRigidBodyByName" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetRigidBodyByName(self: pydrake.multibody.plant.MultibodyPlant, name: str) -&gt; pydrake.multibody.tree.RigidBody</p></li>
</ol>
<p>Returns a constant reference to a rigid body that is identified by the
string <code class="docutils literal notranslate"><span class="pre">name</span></code> in <code class="docutils literal notranslate"><span class="pre">this</span></code> model.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if there is no body with the requested name.</strong> – </p></li>
<li><p><strong>RuntimeError if the body name occurs in multiple model instances.</strong> – </p></li>
<li><p><strong>RuntimeError if the requested body is not a RigidBody.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>HasBodyNamed() to query if there exists a body in <code class="docutils literal notranslate"><span class="pre">this</span></code> model
with a given specified name.</p>
</div>
<ol class="arabic simple" start="2">
<li><p>GetRigidBodyByName(self: pydrake.multibody.plant.MultibodyPlant, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; pydrake.multibody.tree.RigidBody</p></li>
</ol>
<p>Returns a constant reference to the rigid body that is uniquely
identified by the string <code class="docutils literal notranslate"><span class="pre">name</span></code> in <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if there is no body with the requested name.</strong> – </p></li>
<li><p><strong>RuntimeError if the requested body is not a RigidBody.</strong> – </p></li>
<li><p><strong>RuntimeError if model_instance is not valid for this model.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>HasBodyNamed() to query if there exists a body in <code class="docutils literal notranslate"><span class="pre">this</span></code> model
with a given specified name.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetStateNames">
<span class="sig-name descname"><span class="pre">GetStateNames</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetStateNames" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetStateNames(self: pydrake.multibody.plant.MultibodyPlant, add_model_instance_prefix: bool = True) -&gt; List[str]</p></li>
</ol>
<p>Returns a list of string names corresponding to each element of the
multibody state vector. These strings take the form
<code class="docutils literal notranslate"><span class="pre">{model_instance_name}_{joint_name}_{joint_position_suffix</span> <span class="pre">|</span>
<span class="pre">joint_velocity_suffix}</span></code>, but the prefix may optionally be withheld
using <code class="docutils literal notranslate"><span class="pre">add_model_instance_prefix</span></code>.</p>
<p>The returned names are guaranteed to be unique if
<code class="docutils literal notranslate"><span class="pre">add_model_instance_prefix</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code> (the default).</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if the plant is not finalized.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>GetStateNames(self: pydrake.multibody.plant.MultibodyPlant, model_instance: pydrake.multibody.tree.ModelInstanceIndex, add_model_instance_prefix: bool = False) -&gt; List[str]</p></li>
</ol>
<p>Returns a list of string names corresponding to each element of the
multibody state vector. These strings take the form
<code class="docutils literal notranslate"><span class="pre">{model_instance_name}_{joint_name}_{joint_position_suffix</span> <span class="pre">|</span>
<span class="pre">joint_velocity_suffix}</span></code>, but the prefix may optionally be withheld
using <code class="docutils literal notranslate"><span class="pre">add_model_instance_prefix</span></code>.</p>
<p>The returned names are guaranteed to be unique.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the plant is not finalized</strong><strong> or </strong><strong>if the</strong> – </p></li>
<li><p><strong>model_instance` is invalid</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetTopologyGraphvizString">
<span class="sig-name descname"><span class="pre">GetTopologyGraphvizString</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">str</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetTopologyGraphvizString" title="Permalink to this definition"></a></dt>
<dd><p>Returns a Graphviz string describing the topology of this plant. To
render the string, use the Graphviz tool, <code class="docutils literal notranslate"><span class="pre">dot</span></code>.
<a class="reference external" href="http://www.graphviz.org/">http://www.graphviz.org/</a></p>
<p>Note: this method can be called either before or after <code class="docutils literal notranslate"><span class="pre">Finalize()</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetUniqueFreeBaseBodyOrThrow">
<span class="sig-name descname"><span class="pre">GetUniqueFreeBaseBodyOrThrow</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody" title="pydrake.multibody.tree.RigidBody"><span class="pre">pydrake.multibody.tree.RigidBody</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetUniqueFreeBaseBodyOrThrow" title="Permalink to this definition"></a></dt>
<dd><p>If there exists a unique base body that belongs to the model given by
<code class="docutils literal notranslate"><span class="pre">model_instance</span></code> and that unique base body is free (see
HasUniqueBaseBody()), return that free body. Throw an exception
otherwise.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if called pre-finalize.</strong> – </p></li>
<li><p><strong>RuntimeError if model_instance is not valid.</strong> – </p></li>
<li><p><strong>RuntimeError if HasUniqueFreeBaseBody</strong><strong>(</strong><strong>model_instance</strong><strong>) </strong><strong>== false.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetVelocities">
<span class="sig-name descname"><span class="pre">GetVelocities</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetVelocities" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetVelocities(self: pydrake.multibody.plant.MultibodyPlant, context: pydrake.systems.framework.Context) -&gt; numpy.ndarray[numpy.float64[m, 1]]</p></li>
</ol>
<p>Returns a const vector reference to the generalized velocities v in a
given Context.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method returns a reference to existing data, exhibits
constant i.e., O(1) time complexity, and runs very quickly.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if context does not correspond to the Context for</strong> – </p></li>
<li><p><strong>a multibody model.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>GetVelocities(self: pydrake.multibody.plant.MultibodyPlant, context: pydrake.systems.framework.Context, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; numpy.ndarray[numpy.float64[m, 1]]</p></li>
</ol>
<p>Returns a vector containing the generalized velocities v of a
specified model instance in a given Context.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>returns a dense vector of dimension
<code class="docutils literal notranslate"><span class="pre">num_velocities(model_instance)</span></code> associated with
<code class="docutils literal notranslate"><span class="pre">model_instance</span></code> by copying from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if context does not correspond to the Context for</strong> – </p></li>
<li><p><strong>a multibody model</strong><strong> or </strong><strong>model_instance is invalid.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li><p>GetVelocities(self: pydrake.multibody.plant.MultibodyPlant, context: pydrake.systems.framework.Context) -&gt; numpy.ndarray[numpy.float64[m, 1]]</p></li>
</ol>
<p>Returns a const vector reference to the generalized velocities v in a
given Context.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method returns a reference to existing data, exhibits
constant i.e., O(1) time complexity, and runs very quickly.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if context does not correspond to the Context for</strong> – </p></li>
<li><p><strong>a multibody model.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="4">
<li><p>GetVelocities(self: pydrake.multibody.plant.MultibodyPlant, context: pydrake.systems.framework.Context, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; numpy.ndarray[numpy.float64[m, 1]]</p></li>
</ol>
<p>Returns a vector containing the generalized velocities v of a
specified model instance in a given Context.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>returns a dense vector of dimension
<code class="docutils literal notranslate"><span class="pre">num_velocities(model_instance)</span></code> associated with
<code class="docutils literal notranslate"><span class="pre">model_instance</span></code> by copying from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if context does not correspond to the Context for</strong> – </p></li>
<li><p><strong>a multibody model</strong><strong> or </strong><strong>model_instance is invalid.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetVelocitiesFromArray">
<span class="sig-name descname"><span class="pre">GetVelocitiesFromArray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetVelocitiesFromArray" title="Permalink to this definition"></a></dt>
<dd><p>Returns a vector of generalized velocities for <code class="docutils literal notranslate"><span class="pre">model_instance</span></code> from
a vector <code class="docutils literal notranslate"><span class="pre">v</span></code> of generalized velocities for the entire MultibodyPlant
model. This method throws an exception if the input array is not of
size MultibodyPlant::num_velocities().</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetVelocityLowerLimits">
<span class="sig-name descname"><span class="pre">GetVelocityLowerLimits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetVelocityLowerLimits" title="Permalink to this definition"></a></dt>
<dd><p>Returns a vector of size <code class="docutils literal notranslate"><span class="pre">num_velocities()</span></code> containing the lower
velocity limits for every generalized velocity coordinate. These
include joint and free body coordinates. Any unbounded or unspecified
limits will be -infinity.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetVelocityNames">
<span class="sig-name descname"><span class="pre">GetVelocityNames</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetVelocityNames" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetVelocityNames(self: pydrake.multibody.plant.MultibodyPlant, add_model_instance_prefix: bool = True, always_add_suffix: bool = True) -&gt; List[str]</p></li>
</ol>
<p>Returns a list of string names corresponding to each element of the
velocity vector. These strings take the form
<code class="docutils literal notranslate"><span class="pre">{model_instance_name}_{joint_name}_{joint_velocity_suffix}</span></code>, but
the prefix and suffix may optionally be withheld using
<code class="docutils literal notranslate"><span class="pre">add_model_instance_prefix</span></code> and <code class="docutils literal notranslate"><span class="pre">always_add_suffix</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">always_add_suffix</span></code>:</dt><dd><p>(optional). If true, then the suffix is always added. If false,
then the suffix is only added for joints that have more than one
position (in this case, not adding would lead to ambiguity).</p>
</dd>
</dl>
<p>The returned names are guaranteed to be unique if
<code class="docutils literal notranslate"><span class="pre">add_model_instance_prefix</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code> (the default).</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if the plant is not finalized.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>GetVelocityNames(self: pydrake.multibody.plant.MultibodyPlant, model_instance: pydrake.multibody.tree.ModelInstanceIndex, add_model_instance_prefix: bool = False, always_add_suffix: bool = True) -&gt; List[str]</p></li>
</ol>
<p>Returns a list of string names corresponding to each element of the
velocity vector. These strings take the form
<code class="docutils literal notranslate"><span class="pre">{model_instance_name}_{joint_name}_{joint_velocity_suffix}</span></code>, but
the prefix and suffix may optionally be withheld using
<code class="docutils literal notranslate"><span class="pre">add_model_instance_prefix</span></code> and <code class="docutils literal notranslate"><span class="pre">always_add_suffix</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">always_add_suffix</span></code>:</dt><dd><p>(optional). If true, then the suffix is always added. If false,
then the suffix is only added for joints that have more than one
position (in this case, not adding would lead to ambiguity).</p>
</dd>
</dl>
<p>The returned names are guaranteed to be unique.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the plant is not finalized</strong><strong> or </strong><strong>if the</strong> – </p></li>
<li><p><strong>model_instance` is invalid</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetVelocityUpperLimits">
<span class="sig-name descname"><span class="pre">GetVelocityUpperLimits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetVelocityUpperLimits" title="Permalink to this definition"></a></dt>
<dd><p>Upper limit analog of GetVelocitysLowerLimits(), where any unbounded
or unspecified limits will be +infinity.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>GetVelocityLowerLimits() for more information.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.GetVisualGeometriesForBody">
<span class="sig-name descname"><span class="pre">GetVisualGeometriesForBody</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">body</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody" title="pydrake.multibody.tree.RigidBody"><span class="pre">pydrake.multibody.tree.RigidBody</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.GeometryId" title="pydrake.geometry.GeometryId"><span class="pre">pydrake.geometry.GeometryId</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.GetVisualGeometriesForBody" title="Permalink to this definition"></a></dt>
<dd><p>Returns an array of GeometryId’s identifying the different visual
geometries for <code class="docutils literal notranslate"><span class="pre">body</span></code> previously registered with a SceneGraph.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method can be called at any time during the lifetime of
<code class="docutils literal notranslate"><span class="pre">this</span></code> plant, either pre- or post-finalize, see Finalize().
Post-finalize calls will always return the same value.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>RegisterVisualGeometry(), Finalize()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.gravity_field">
<span class="sig-name descname"><span class="pre">gravity_field</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.UniformGravityFieldElement" title="pydrake.multibody.tree.UniformGravityFieldElement"><span class="pre">pydrake.multibody.tree.UniformGravityFieldElement</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.gravity_field" title="Permalink to this definition"></a></dt>
<dd><p>An accessor to the current gravity field.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.has_joint">
<span class="sig-name descname"><span class="pre">has_joint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">joint_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JointIndex" title="pydrake.multibody.tree.JointIndex"><span class="pre">pydrake.multibody.tree.JointIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.has_joint" title="Permalink to this definition"></a></dt>
<dd><p>Returns true if plant has a joint with unique index <code class="docutils literal notranslate"><span class="pre">joint_index</span></code>.
The value could be false if the joint was removed using RemoveJoint().</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.has_joint_actuator">
<span class="sig-name descname"><span class="pre">has_joint_actuator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">actuator_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JointActuatorIndex" title="pydrake.multibody.tree.JointActuatorIndex"><span class="pre">pydrake.multibody.tree.JointActuatorIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.has_joint_actuator" title="Permalink to this definition"></a></dt>
<dd><p>Returns true if plant has a joint actuator with unique index
<code class="docutils literal notranslate"><span class="pre">actuator_index</span></code>. The value could be false if the actuator was
removed using RemoveJointActuator().</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.HasBodyNamed">
<span class="sig-name descname"><span class="pre">HasBodyNamed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.HasBodyNamed" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>HasBodyNamed(self: pydrake.multibody.plant.MultibodyPlant, name: str) -&gt; bool</p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if a body named <code class="docutils literal notranslate"><span class="pre">name</span></code> was added to the MultibodyPlant.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddRigidBody().</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if the body name occurs in multiple model instances.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>HasBodyNamed(self: pydrake.multibody.plant.MultibodyPlant, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; bool</p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if a body named <code class="docutils literal notranslate"><span class="pre">name</span></code> was added to the MultibodyPlant
in <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddRigidBody().</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if model_instance is not valid for this model.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.HasFrameNamed">
<span class="sig-name descname"><span class="pre">HasFrameNamed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.HasFrameNamed" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>HasFrameNamed(self: pydrake.multibody.plant.MultibodyPlant, name: str) -&gt; bool</p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if a frame named <code class="docutils literal notranslate"><span class="pre">name</span></code> was added to the model.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddFrame().</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if the frame name occurs in multiple model instances.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>HasFrameNamed(self: pydrake.multibody.plant.MultibodyPlant, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; bool</p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if a frame named <code class="docutils literal notranslate"><span class="pre">name</span></code> was added to
<code class="docutils literal notranslate"><span class="pre">model_instance</span></code>.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddFrame().</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if model_instance is not valid for this model.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.HasJointActuatorNamed">
<span class="sig-name descname"><span class="pre">HasJointActuatorNamed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.HasJointActuatorNamed" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>HasJointActuatorNamed(self: pydrake.multibody.plant.MultibodyPlant, name: str) -&gt; bool</p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if an actuator named <code class="docutils literal notranslate"><span class="pre">name</span></code> was added to this model.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddJointActuator().</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the actuator name occurs in multiple model</strong> – </p></li>
<li><p><strong>instances.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>HasJointActuatorNamed(self: pydrake.multibody.plant.MultibodyPlant, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; bool</p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if an actuator named <code class="docutils literal notranslate"><span class="pre">name</span></code> was added to
<code class="docutils literal notranslate"><span class="pre">model_instance</span></code>.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddJointActuator().</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if model_instance is not valid for this model.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.HasJointNamed">
<span class="sig-name descname"><span class="pre">HasJointNamed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.HasJointNamed" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>HasJointNamed(self: pydrake.multibody.plant.MultibodyPlant, name: str) -&gt; bool</p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if a joint named <code class="docutils literal notranslate"><span class="pre">name</span></code> was added to this model.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddJoint().</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if the joint name occurs in multiple model instances.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>HasJointNamed(self: pydrake.multibody.plant.MultibodyPlant, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; bool</p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if a joint named <code class="docutils literal notranslate"><span class="pre">name</span></code> was added to
<code class="docutils literal notranslate"><span class="pre">model_instance</span></code>.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddJoint().</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if model_instance is not valid for this model.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.HasModelInstanceNamed">
<span class="sig-name descname"><span class="pre">HasModelInstanceNamed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.HasModelInstanceNamed" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if a model instance named <code class="docutils literal notranslate"><span class="pre">name</span></code> was added to this
model.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddModelInstance().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.HasUniqueFreeBaseBody">
<span class="sig-name descname"><span class="pre">HasUniqueFreeBaseBody</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.HasUniqueFreeBaseBody" title="Permalink to this definition"></a></dt>
<dd><p>Return true if there exists a unique base body in the model given by
<code class="docutils literal notranslate"><span class="pre">model_instance</span></code> and that unique base body is free.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if called pre-finalize.</strong> – </p></li>
<li><p><strong>RuntimeError if model_instance is not valid.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.is_finalized">
<span class="sig-name descname"><span class="pre">is_finalized</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.is_finalized" title="Permalink to this definition"></a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if this MultibodyPlant was finalized with a call to
Finalize().</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>Finalize().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.is_gravity_enabled">
<span class="sig-name descname"><span class="pre">is_gravity_enabled</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.is_gravity_enabled" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> iff gravity is enabled for <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>set_gravity_enabled().</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if the model instance is invalid.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.IsVelocityEqualToQDot">
<span class="sig-name descname"><span class="pre">IsVelocityEqualToQDot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.IsVelocityEqualToQDot" title="Permalink to this definition"></a></dt>
<dd><p>Returns true iff the generalized velocity v is exactly the time
derivative q̇ of the generalized coordinates q. In this case
MapQDotToVelocity() and MapVelocityToQDot() implement the identity
map. This method is, in the worst case, O(n), where n is the number of
joints.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.MakeActuationMatrix">
<span class="sig-name descname"><span class="pre">MakeActuationMatrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.MakeActuationMatrix" title="Permalink to this definition"></a></dt>
<dd><p>This method creates an actuation matrix B mapping a vector of
actuation values u into generalized forces <code class="docutils literal notranslate"><span class="pre">tau_u</span> <span class="pre">=</span> <span class="pre">B</span> <span class="pre">*</span> <span class="pre">u</span></code>, where B
is a matrix of size <code class="docutils literal notranslate"><span class="pre">nv</span> <span class="pre">x</span> <span class="pre">nu</span></code> with <code class="docutils literal notranslate"><span class="pre">nu</span></code> equal to
num_actuated_dofs() and <code class="docutils literal notranslate"><span class="pre">nv</span></code> equal to num_velocities(). The vector u
of actuation values is of size num_actuated_dofs(). For a given
JointActuator, <code class="docutils literal notranslate"><span class="pre">u[JointActuator::input_start()]</span></code> stores the value
for the external actuation corresponding to that actuator. <code class="docutils literal notranslate"><span class="pre">tau_u</span></code>
on the other hand is indexed by generalized velocity indexes according
to <code class="docutils literal notranslate"><span class="pre">Joint::velocity_start()</span></code>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>B is a permutation matrix. While making a permutation has <code class="docutils literal notranslate"><span class="pre">O(n)</span></code>
complexity, making a full B matrix has <code class="docutils literal notranslate"><span class="pre">O(n²)</span></code> complexity. For
most applications this cost can be neglected but it could become
significant for very large systems.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.MakeActuationMatrixPseudoinverse">
<span class="sig-name descname"><span class="pre">MakeActuationMatrixPseudoinverse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">scipy.sparse.csc_matrix</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.MakeActuationMatrixPseudoinverse" title="Permalink to this definition"></a></dt>
<dd><p>Creates the pseudoinverse of the actuation matrix B directly (without
requiring an explicit inverse calculation). See MakeActuationMatrix().</p>
<p>Notably, when B is full row rank (the system is fully actuated), then
the pseudoinverse is a true inverse.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.MakeActuatorSelectorMatrix">
<span class="sig-name descname"><span class="pre">MakeActuatorSelectorMatrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.MakeActuatorSelectorMatrix" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>MakeActuatorSelectorMatrix(self: pydrake.multibody.plant.MultibodyPlant, user_to_actuator_index_map: List[pydrake.multibody.tree.JointActuatorIndex]) -&gt; numpy.ndarray[numpy.float64[m, n]]</p></li>
</ol>
<p>This method allows user to map a vector <code class="docutils literal notranslate"><span class="pre">uₛ</span></code> containing the
actuation for a set of selected actuators into the vector u containing
the actuation values for <code class="docutils literal notranslate"><span class="pre">this</span></code> full model. The mapping, or
selection, is returned in the form of a selector matrix Su such that
<code class="docutils literal notranslate"><span class="pre">u</span> <span class="pre">=</span> <span class="pre">Su⋅uₛ</span></code>. The size nₛ of uₛ is always smaller or equal than the
size of the full vector of actuation values u. That is, a user might
be interested in only a given subset of actuators in the model.</p>
<p>This selection matrix is particularly useful when adding PID control
on a portion of the state, see systems::controllers::PidController.</p>
<p>A user specifies the preferred order in uₛ via
<code class="docutils literal notranslate"><span class="pre">user_to_actuator_index_map</span></code>. The actuation values in uₛ are a
concatenation of the values for each actuator in the order they appear
in <code class="docutils literal notranslate"><span class="pre">user_to_actuator_index_map</span></code>. The actuation value in the full
vector of actuation values <code class="docutils literal notranslate"><span class="pre">u</span></code> for a particular actuator can be
found at offset JointActuator::input_start().</p>
<ol class="arabic simple" start="2">
<li><p>MakeActuatorSelectorMatrix(self: pydrake.multibody.plant.MultibodyPlant, user_to_joint_index_map: List[pydrake.multibody.tree.JointIndex]) -&gt; numpy.ndarray[numpy.float64[m, n]]</p></li>
</ol>
<p>Alternative signature to build an actuation selector matrix <code class="docutils literal notranslate"><span class="pre">Su</span></code>
such that <code class="docutils literal notranslate"><span class="pre">u</span> <span class="pre">=</span> <span class="pre">Su⋅uₛ</span></code>, where u is the vector of actuation values for
the full model (see get_actuation_input_port()) and uₛ is a vector of
actuation values for the actuators acting on the joints listed by
<code class="docutils literal notranslate"><span class="pre">user_to_joint_index_map</span></code>. It is assumed that all joints referenced
by <code class="docutils literal notranslate"><span class="pre">user_to_joint_index_map</span></code> are actuated. See
MakeActuatorSelectorMatrix(const std::vector&lt;JointActuatorIndex&gt;&amp;) for
details.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if any of the joints in user_to_joint_index_map</strong> – </p></li>
<li><p><strong>does not have an actuator.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.MakeQDotToVelocityMap">
<span class="sig-name descname"><span class="pre">MakeQDotToVelocityMap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context" title="pydrake.systems.framework.Context"><span class="pre">pydrake.systems.framework.Context</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">scipy.sparse.csc_matrix</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.MakeQDotToVelocityMap" title="Permalink to this definition"></a></dt>
<dd><p>Returns the matrix <code class="docutils literal notranslate"><span class="pre">N⁺(q)</span></code>, which maps <code class="docutils literal notranslate"><span class="pre">v</span> <span class="pre">=</span> <span class="pre">N⁺(q)⋅q̇</span></code>, as
described in MapQDotToVelocity(). Prefer calling MapQDotToVelocity()
directly; this entry point is provided to support callers that require
the explicit linear form (once q is given) of the relationship. This
method is, in the worst case, O(n), where n is the number of joints.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context containing the state of the model.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>MapVelocityToQDot()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.MakeStateSelectorMatrix">
<span class="sig-name descname"><span class="pre">MakeStateSelectorMatrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">user_to_joint_index_map</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JointIndex" title="pydrake.multibody.tree.JointIndex"><span class="pre">pydrake.multibody.tree.JointIndex</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.MakeStateSelectorMatrix" title="Permalink to this definition"></a></dt>
<dd><p>This method allows users to map the state of <code class="docutils literal notranslate"><span class="pre">this</span></code> model, x, into a
vector of selected state xₛ with a given preferred ordering. The
mapping, or selection, is returned in the form of a selector matrix Sx
such that <code class="docutils literal notranslate"><span class="pre">xₛ</span> <span class="pre">=</span> <span class="pre">Sx⋅x</span></code>. The size nₛ of xₛ is always smaller or equal
than the size of the full state x. That is, a user might be interested
in only a given portion of the full state x.</p>
<p>This selection matrix is particularly useful when adding PID control
on a portion of the state, see systems::controllers::PidController.</p>
<p>A user specifies the preferred order in xₛ via
<code class="docutils literal notranslate"><span class="pre">user_to_joint_index_map</span></code>. The selected state is built such that
selected positions are followed by selected velocities, as in <code class="docutils literal notranslate"><span class="pre">xₛ</span> <span class="pre">=</span>
<span class="pre">[qₛ,</span> <span class="pre">vₛ]</span></code>. The positions in qₛ are a concatenation of the positions
for each joint in the order they appear in
<code class="docutils literal notranslate"><span class="pre">user_to_joint_index_map</span></code>. That is, the positions for
<code class="docutils literal notranslate"><span class="pre">user_to_joint_index_map[0]</span></code> are first, followed by the positions
for <code class="docutils literal notranslate"><span class="pre">user_to_joint_index_map[1]</span></code>, etc. Similarly for the selected
velocities vₛ.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if there are repeated indexes in</strong> – </p></li>
<li><p><strong>user_to_joint_index_map`</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.MakeVelocityToQDotMap">
<span class="sig-name descname"><span class="pre">MakeVelocityToQDotMap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context" title="pydrake.systems.framework.Context"><span class="pre">pydrake.systems.framework.Context</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">scipy.sparse.csc_matrix</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.MakeVelocityToQDotMap" title="Permalink to this definition"></a></dt>
<dd><p>Returns the matrix <code class="docutils literal notranslate"><span class="pre">N(q)</span></code>, which maps <code class="docutils literal notranslate"><span class="pre">q̇</span> <span class="pre">=</span> <span class="pre">N(q)⋅v</span></code>, as described
in MapVelocityToQDot(). Prefer calling MapVelocityToQDot() directly;
this entry point is provided to support callers that require the
explicit linear form (once q is given) of the relationship. Do not
take the (pseudo-)inverse of <code class="docutils literal notranslate"><span class="pre">N(q)</span></code>; call MakeQDotToVelocityMap
instead. This method is, in the worst case, O(n), where n is the
number of joints.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context containing the state of the model.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>MapVelocityToQDot()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.MapQDotToVelocity">
<span class="sig-name descname"><span class="pre">MapQDotToVelocity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context" title="pydrake.systems.framework.Context"><span class="pre">pydrake.systems.framework.Context</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">qdot</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.MapQDotToVelocity" title="Permalink to this definition"></a></dt>
<dd><p>Transforms the time derivative <code class="docutils literal notranslate"><span class="pre">qdot</span></code> of the generalized positions
vector <code class="docutils literal notranslate"><span class="pre">q</span></code> (stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>) to generalized velocities <code class="docutils literal notranslate"><span class="pre">v</span></code>.
<cite>v</cite> and <code class="docutils literal notranslate"><span class="pre">q̇</span></code> are related linearly by <code class="docutils literal notranslate"><span class="pre">q̇</span> <span class="pre">=</span> <span class="pre">N(q)⋅v</span></code>. Although
<code class="docutils literal notranslate"><span class="pre">N(q)</span></code> is not necessarily square, its left pseudo-inverse <code class="docutils literal notranslate"><span class="pre">N⁺(q)</span></code>
can be used to invert that relationship without residual error,
provided that <code class="docutils literal notranslate"><span class="pre">qdot</span></code> is in the range space of <code class="docutils literal notranslate"><span class="pre">N(q)</span></code> (that is, if
it <em>could</em> have been produced as <code class="docutils literal notranslate"><span class="pre">q̇</span> <span class="pre">=</span> <span class="pre">N(q)⋅v</span></code> for some <code class="docutils literal notranslate"><span class="pre">v</span></code>).
Using the configuration <code class="docutils literal notranslate"><span class="pre">q</span></code> stored in the given <code class="docutils literal notranslate"><span class="pre">context</span></code> this
method calculates <code class="docutils literal notranslate"><span class="pre">v</span> <span class="pre">=</span> <span class="pre">N⁺(q)⋅q̇</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context containing the state of the model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">qdot</span></code>:</dt><dd><p>A vector containing the time derivatives of the generalized
positions. This method aborts if <code class="docutils literal notranslate"><span class="pre">qdot</span></code> is not of size
num_positions().</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">v</span></code>:</dt><dd><p>A valid (non-null) pointer to a vector in <code class="docutils literal notranslate"><span class="pre">ℛⁿ</span></code> with n the number
of generalized velocities. This method aborts if v is nullptr or
if it is not of size num_velocities().</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>MapVelocityToQDot()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>Mobilizer::MapQDotToVelocity()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.MapVelocityToQDot">
<span class="sig-name descname"><span class="pre">MapVelocityToQDot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context" title="pydrake.systems.framework.Context"><span class="pre">pydrake.systems.framework.Context</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.MapVelocityToQDot" title="Permalink to this definition"></a></dt>
<dd><p>Transforms generalized velocities v to time derivatives <code class="docutils literal notranslate"><span class="pre">qdot</span></code> of
the generalized positions vector <code class="docutils literal notranslate"><span class="pre">q</span></code> (stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>). <cite>v</cite>
and <code class="docutils literal notranslate"><span class="pre">qdot</span></code> are related linearly by <code class="docutils literal notranslate"><span class="pre">q̇</span> <span class="pre">=</span> <span class="pre">N(q)⋅v</span></code>. Using the
configuration <code class="docutils literal notranslate"><span class="pre">q</span></code> stored in the given <code class="docutils literal notranslate"><span class="pre">context</span></code> this method
calculates <code class="docutils literal notranslate"><span class="pre">q̇</span> <span class="pre">=</span> <span class="pre">N(q)⋅v</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context containing the state of the model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">v</span></code>:</dt><dd><p>A vector of generalized velocities for this model. This method
aborts if v is not of size num_velocities().</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">qdot</span></code>:</dt><dd><p>A valid (non-null) pointer to a vector in <code class="docutils literal notranslate"><span class="pre">ℝⁿ</span></code> with n being the
number of generalized positions in this model, given by
<code class="docutils literal notranslate"><span class="pre">num_positions()</span></code>. This method aborts if <code class="docutils literal notranslate"><span class="pre">qdot</span></code> is nullptr or
if it is not of size num_positions().</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>MapQDotToVelocity()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>Mobilizer::MapVelocityToQDot()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.mutable_gravity_field">
<span class="sig-name descname"><span class="pre">mutable_gravity_field</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.UniformGravityFieldElement" title="pydrake.multibody.tree.UniformGravityFieldElement"><span class="pre">pydrake.multibody.tree.UniformGravityFieldElement</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.mutable_gravity_field" title="Permalink to this definition"></a></dt>
<dd><p>A mutable accessor to the current gravity field.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.num_actuated_dofs">
<span class="sig-name descname"><span class="pre">num_actuated_dofs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.num_actuated_dofs" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>num_actuated_dofs(self: pydrake.multibody.plant.MultibodyPlant) -&gt; int</p></li>
</ol>
<p>Returns the total number of actuated degrees of freedom. That is, the
vector of actuation values u has this size. See AddJointActuator().</p>
<ol class="arabic simple" start="2">
<li><p>num_actuated_dofs(self: pydrake.multibody.plant.MultibodyPlant, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; int</p></li>
</ol>
<p>Returns the total number of actuated degrees of freedom for a specific
model instance. That is, the vector of actuation values u has this
size. See AddJointActuator().</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.num_actuators">
<span class="sig-name descname"><span class="pre">num_actuators</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.num_actuators" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>num_actuators(self: pydrake.multibody.plant.MultibodyPlant) -&gt; int</p></li>
</ol>
<p>Returns the number of joint actuators in the model.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddJointActuator().</p>
</div>
<ol class="arabic simple" start="2">
<li><p>num_actuators(self: pydrake.multibody.plant.MultibodyPlant, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; int</p></li>
</ol>
<p>Returns the number of actuators for a specific model instance.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.num_bodies">
<span class="sig-name descname"><span class="pre">num_bodies</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.num_bodies" title="Permalink to this definition"></a></dt>
<dd><p>Returns the number of bodies in the model, including the “world” body,
which is always part of the model.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddRigidBody().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.num_collision_geometries">
<span class="sig-name descname"><span class="pre">num_collision_geometries</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.num_collision_geometries" title="Permalink to this definition"></a></dt>
<dd><p>Returns the number of geometries registered for contact modeling. This
method can be called at any time during the lifetime of <code class="docutils literal notranslate"><span class="pre">this</span></code>
plant, either pre- or post-finalize, see Finalize(). Post-finalize
calls will always return the same value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.num_constraints">
<span class="sig-name descname"><span class="pre">num_constraints</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.num_constraints" title="Permalink to this definition"></a></dt>
<dd><p>Returns the total number of constraints specified by the user.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.num_force_elements">
<span class="sig-name descname"><span class="pre">num_force_elements</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.num_force_elements" title="Permalink to this definition"></a></dt>
<dd><p>Returns the number of ForceElement objects.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddForceElement().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.num_frames">
<span class="sig-name descname"><span class="pre">num_frames</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.num_frames" title="Permalink to this definition"></a></dt>
<dd><p>Returns the number of Frame objects in this model. Frames include body
frames associated with each of the bodies, including the <em>world</em> body.
This means the minimum number of frames is one.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.num_joints">
<span class="sig-name descname"><span class="pre">num_joints</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.num_joints" title="Permalink to this definition"></a></dt>
<dd><p>Returns the number of joints in the model.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddJoint().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.num_model_instances">
<span class="sig-name descname"><span class="pre">num_model_instances</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.num_model_instances" title="Permalink to this definition"></a></dt>
<dd><p>Returns the number of model instances in the model.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddModelInstance().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.num_multibody_states">
<span class="sig-name descname"><span class="pre">num_multibody_states</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.num_multibody_states" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>num_multibody_states(self: pydrake.multibody.plant.MultibodyPlant) -&gt; int</p></li>
</ol>
<p>Returns the size of the multibody system state vector x = [q v]. This
will be <code class="docutils literal notranslate"><span class="pre">num_positions()</span></code> plus <code class="docutils literal notranslate"><span class="pre">num_velocities()</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>num_multibody_states(self: pydrake.multibody.plant.MultibodyPlant, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; int</p></li>
</ol>
<p>Returns the size of the multibody system state vector xᵢ = [qᵢ vᵢ] for
model instance i. (Here qᵢ ⊆ q and vᵢ ⊆ v.) will be
<code class="docutils literal notranslate"><span class="pre">num_positions(model_instance)</span></code> plus
<code class="docutils literal notranslate"><span class="pre">num_velocities(model_instance)</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.num_positions">
<span class="sig-name descname"><span class="pre">num_positions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.num_positions" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>num_positions(self: pydrake.multibody.plant.MultibodyPlant) -&gt; int</p></li>
</ol>
<p>Returns the size of the generalized position vector q for this model.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>num_positions(self: pydrake.multibody.plant.MultibodyPlant, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; int</p></li>
</ol>
<p>Returns the size of the generalized position vector qᵢ for model
instance i.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.num_velocities">
<span class="sig-name descname"><span class="pre">num_velocities</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.num_velocities" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>num_velocities(self: pydrake.multibody.plant.MultibodyPlant) -&gt; int</p></li>
</ol>
<p>Returns the size of the generalized velocity vector v for this model.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>num_velocities(self: pydrake.multibody.plant.MultibodyPlant, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; int</p></li>
</ol>
<p>Returns the size of the generalized velocity vector vᵢ for model
instance i.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.physical_models">
<span class="sig-name descname"><span class="pre">physical_models</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#pydrake.multibody.plant.PhysicalModel" title="pydrake.multibody.plant.PhysicalModel"><span class="pre">pydrake.multibody.plant.PhysicalModel</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.physical_models" title="Permalink to this definition"></a></dt>
<dd><p>Returns a vector of pointers to all physical models registered with
this MultibodyPlant. For use only by advanced developers.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This feature is considered to be <strong>experimental</strong> and may change
or be removed at any time, without any deprecation notice ahead of
time.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.RegisterAsSourceForSceneGraph">
<span class="sig-name descname"><span class="pre">RegisterAsSourceForSceneGraph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">scene_graph</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.SceneGraph" title="pydrake.geometry.SceneGraph"><span class="pre">pydrake.geometry.SceneGraph</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.SourceId" title="pydrake.geometry.SourceId"><span class="pre">pydrake.geometry.SourceId</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.RegisterAsSourceForSceneGraph" title="Permalink to this definition"></a></dt>
<dd><p>Registers <code class="docutils literal notranslate"><span class="pre">this</span></code> plant to serve as a source for an instance of
SceneGraph. This registration allows MultibodyPlant to register
geometry with <code class="docutils literal notranslate"><span class="pre">scene_graph</span></code> for visualization and/or collision
queries. The string returned by <code class="docutils literal notranslate"><span class="pre">this-&gt;get_name()</span></code> is passed to
SceneGraph’s RegisterSource, so it is highly recommended that you give
the plant a recognizable name before calling this. Successive
registration calls with SceneGraph <strong>must</strong> be performed on the same
instance to which the pointer argument <code class="docutils literal notranslate"><span class="pre">scene_graph</span></code> points to.
Failure to do so will result in runtime exceptions.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">scene_graph</span></code>:</dt><dd><p>A valid non nullptr to the SceneGraph instance for which <code class="docutils literal notranslate"><span class="pre">this</span></code>
plant will sever as a source, see SceneGraph documentation for
further details.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the SourceId of <code class="docutils literal notranslate"><span class="pre">this</span></code> plant in <code class="docutils literal notranslate"><span class="pre">scene_graph</span></code>. It can also
later on be retrieved with get_source_id().</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>RuntimeError if called post-finalize.</strong> – </p></li>
<li><p><strong>RuntimeError if scene_graph is the nullptr.</strong> – </p></li>
<li><p><strong>RuntimeError if called more than once.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.RegisterCollisionGeometry">
<span class="sig-name descname"><span class="pre">RegisterCollisionGeometry</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.RegisterCollisionGeometry" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>RegisterCollisionGeometry(self: pydrake.multibody.plant.MultibodyPlant, body: pydrake.multibody.tree.RigidBody, X_BG: pydrake.math.RigidTransform, shape: pydrake.geometry.Shape, name: str, properties: pydrake.geometry.ProximityProperties) -&gt; pydrake.geometry.GeometryId</p></li>
</ol>
<p>Registers geometry in a SceneGraph with a given geometry::Shape to be
used for the contact modeling of a given <code class="docutils literal notranslate"><span class="pre">body</span></code>. More than one
geometry can be registered with a body, in which case the body’s
contact geometry is the union of all geometries registered to that
body.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body</span></code>:</dt><dd><p>The body for which geometry is being registered.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">X_BG</span></code>:</dt><dd><p>The fixed pose of the geometry frame G in the body frame B.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">shape</span></code>:</dt><dd><p>The geometry::Shape used for visualization. E.g.:
geometry::Sphere, geometry::Cylinder, etc.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">properties</span></code>:</dt><dd><p>The proximity properties associated with the collision geometry.
They <em>must</em> include the (<code class="docutils literal notranslate"><span class="pre">material</span></code>, <cite>coulomb_friction</cite>)
property of type CoulombFriction&lt;double&gt;.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if called post-finalize</strong><strong> or </strong><strong>if the properties are</strong> – </p></li>
<li><p><strong>missing the coulomb friction property</strong><strong> (or </strong><strong>if it is of the wrong</strong> – </p></li>
<li><p><strong>type</strong><strong>)</strong><strong></strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>RegisterCollisionGeometry(self: pydrake.multibody.plant.MultibodyPlant, body: pydrake.multibody.tree.RigidBody, X_BG: pydrake.math.RigidTransform, shape: pydrake.geometry.Shape, name: str, coulomb_friction: pydrake.multibody.plant.CoulombFriction) -&gt; pydrake.geometry.GeometryId</p></li>
</ol>
<p>Overload which specifies a single property: coulomb_friction.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.RegisterVisualGeometry">
<span class="sig-name descname"><span class="pre">RegisterVisualGeometry</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">body</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody" title="pydrake.multibody.tree.RigidBody"><span class="pre">pydrake.multibody.tree.RigidBody</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">X_BG</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.math.html#pydrake.math.RigidTransform" title="pydrake.math.RigidTransform"><span class="pre">pydrake.math.RigidTransform</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">shape</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.Shape" title="pydrake.geometry.Shape"><span class="pre">pydrake.geometry.Shape</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">diffuse_color</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">4</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.GeometryId" title="pydrake.geometry.GeometryId"><span class="pre">pydrake.geometry.GeometryId</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.RegisterVisualGeometry" title="Permalink to this definition"></a></dt>
<dd><p>Overload for visual geometry registration; it converts the
<code class="docutils literal notranslate"><span class="pre">diffuse_color</span></code> (RGBA with values in the range [0, 1]) into a
geometry::DrakeVisualizer-compatible set of
geometry::IllustrationProperties.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.RemoveConstraint">
<span class="sig-name descname"><span class="pre">RemoveConstraint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">id</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.MultibodyConstraintId" title="pydrake.multibody.tree.MultibodyConstraintId"><span class="pre">pydrake.multibody.tree.MultibodyConstraintId</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.RemoveConstraint" title="Permalink to this definition"></a></dt>
<dd><p>Removes the constraint <code class="docutils literal notranslate"><span class="pre">id</span></code> from the plant. Note that this will
<em>not</em> remove constraints registered directly with DeformableModel.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the MultibodyPlant has already been finalized.</strong> – </p></li>
<li><p><strong>RuntimeError if id does not identify any multibody constraint</strong> – </p></li>
<li><p><strong>in this plant.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.RemoveJoint">
<span class="sig-name descname"><span class="pre">RemoveJoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">joint</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Joint" title="pydrake.multibody.tree.Joint"><span class="pre">pydrake.multibody.tree.Joint</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.RemoveJoint" title="Permalink to this definition"></a></dt>
<dd><p>Removes and deletes <code class="docutils literal notranslate"><span class="pre">joint</span></code> from this MultibodyPlant. Any existing
references to <code class="docutils literal notranslate"><span class="pre">joint</span></code> will become invalid, and future calls to
<code class="docutils literal notranslate"><span class="pre">get_joint(joint_index)</span></code> will throw an exception. Other elements of
the plant may depend on <code class="docutils literal notranslate"><span class="pre">joint</span></code> at the time of removal and should be
removed first. For example, a JointActuator that depends on <code class="docutils literal notranslate"><span class="pre">joint</span></code>
should be removed with RemoveJointActuator(). Currently, we do not
provide joint dependency tracking for force elements or constraints,
so this function will throw an exception if there are <em>any</em> user-added
force elements or constraints in the plant.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the plant is already finalized.</strong> – </p></li>
<li><p><strong>RuntimeError if the plant contains a non-zero number of user-added</strong> – </p></li>
<li><p><strong>force elements</strong><strong> or </strong><strong>user-added constraints.</strong> – </p></li>
<li><p><strong>RuntimeError if joint has a dependent JointActuator.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddJoint()</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is important to note that the JointIndex assigned to a joint is
immutable. New joint indices are assigned in increasing order,
even if a joint with a lower index has been removed. This has the
consequence that when a joint is removed from the plant, the
sequence <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">num_joints())</span></code> is not necessarily the correct set
of un-removed joint indices in the plant. Thus, it is important
<em>NOT</em> to loop over joint indices sequentially from <code class="docutils literal notranslate"><span class="pre">0</span></code> to
<code class="docutils literal notranslate"><span class="pre">num_joints()</span> <span class="pre">-</span> <span class="pre">1</span></code>. Instead users should use the provided
GetJointIndices() and GetJointIndices(ModelIndex) functions:</p>
</div>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">JointIndex</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">plant</span><span class="p">.</span><span class="n">GetJointIndices</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">Joint</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">joint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">plant</span><span class="p">.</span><span class="n">get_joint</span><span class="p">(</span><span class="n">index</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="w"> </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</details></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.RemoveJointActuator">
<span class="sig-name descname"><span class="pre">RemoveJointActuator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">actuator</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JointActuator" title="pydrake.multibody.tree.JointActuator"><span class="pre">pydrake.multibody.tree.JointActuator</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.RemoveJointActuator" title="Permalink to this definition"></a></dt>
<dd><p>Removes and deletes <code class="docutils literal notranslate"><span class="pre">actuator</span></code> from this MultibodyPlant. Any
existing references to <code class="docutils literal notranslate"><span class="pre">actuator</span></code> will become invalid, and future
calls to <code class="docutils literal notranslate"><span class="pre">get_joint_actuator(actuator_index)</span></code> will throw an
exception.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if the plant is already finalized.</strong> – </p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddJointActuator()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.RenameModelInstance">
<span class="sig-name descname"><span class="pre">RenameModelInstance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.RenameModelInstance" title="Permalink to this definition"></a></dt>
<dd><p>Renames an existing model instance.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>:</dt><dd><p>The instance to rename.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">name</span></code>:</dt><dd><p>A string that uniquely identifies the instance within <code class="docutils literal notranslate"><span class="pre">this</span></code>
model.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if called after Finalize</strong><strong>(</strong><strong>)</strong><strong></strong> – </p></li>
<li><p><strong>RuntimeError if model_instance is not a valid index.</strong> – </p></li>
<li><p><strong>RuntimeError if HasModelInstanceNamed</strong><strong>(</strong><strong>name</strong><strong>) </strong><strong>is true.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.set_adjacent_bodies_collision_filters">
<span class="sig-name descname"><span class="pre">set_adjacent_bodies_collision_filters</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.set_adjacent_bodies_collision_filters" title="Permalink to this definition"></a></dt>
<dd><p>Sets whether to apply collision filters to topologically adjacent
bodies at Finalize() time. Filters are applied when there exists a
joint between bodies, except in the case of 6-dof joints or joints in
which the parent body is <code class="docutils literal notranslate"><span class="pre">world</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError iff called post-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.set_contact_model">
<span class="sig-name descname"><span class="pre">set_contact_model</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">model</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.ContactModel" title="pydrake.multibody.plant.ContactModel"><span class="pre">pydrake.multibody.plant.ContactModel</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.set_contact_model" title="Permalink to this definition"></a></dt>
<dd><p>Sets the contact model to be used by <code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant, see
ContactModel for available options. The default contact model is
ContactModel::kHydroelasticWithFallback.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError iff called post-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.set_contact_surface_representation">
<span class="sig-name descname"><span class="pre">set_contact_surface_representation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">surface_representation</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.HydroelasticContactRepresentation" title="pydrake.geometry.HydroelasticContactRepresentation"><span class="pre">pydrake.geometry.HydroelasticContactRepresentation</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.set_contact_surface_representation" title="Permalink to this definition"></a></dt>
<dd><p>Sets the representation of contact surfaces to be used by <code class="docutils literal notranslate"><span class="pre">this</span></code>
MultibodyPlant. See geometry::HydroelasticContactRepresentation for
available options. See GetDefaultContactSurfaceRepresentation() for
explanation of default values.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.set_discrete_contact_approximation">
<span class="sig-name descname"><span class="pre">set_discrete_contact_approximation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">approximation</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.DiscreteContactApproximation" title="pydrake.multibody.plant.DiscreteContactApproximation"><span class="pre">pydrake.multibody.plant.DiscreteContactApproximation</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.set_discrete_contact_approximation" title="Permalink to this definition"></a></dt>
<dd><p>Sets the discrete contact model approximation.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Calling this method also sets the contact solver type (see
set_discrete_contact_solver()) according to: -
DiscreteContactApproximation::kTamsi sets the solver to
DiscreteContactSolver::kTamsi. -
DiscreteContactApproximation::kSap,
DiscreteContactApproximation::kSimilar and
DiscreteContactApproximation::kLagged set the solver to
DiscreteContactSolver::kSap.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>iff this plant is continuous</strong><strong> (</strong><strong>i.e. is_discrete</strong><strong>(</strong><strong>) </strong><strong>is</strong> – </p></li>
<li><p><strong>False`.</strong> – </p></li>
<li><p><strong>RuntimeError iff called post-finalize.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.set_discrete_contact_solver">
<span class="sig-name descname"><span class="pre">set_discrete_contact_solver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">contact_solver</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.DiscreteContactSolver" title="pydrake.multibody.plant.DiscreteContactSolver"><span class="pre">pydrake.multibody.plant.DiscreteContactSolver</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.set_discrete_contact_solver" title="Permalink to this definition"></a></dt>
<dd><p>Sets the contact solver type used for discrete MultibodyPlant models.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Calling this method also sets a default discrete approximation of
contact (see set_discrete_contact_approximation()) according to: -
DiscreteContactSolver::kTamsi sets the approximation to
DiscreteContactApproximation::kTamsi. -
DiscreteContactSolver::kSap sets the approximation to
DiscreteContactApproximation::kSap.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This function is a no-op for continuous models (when is_discrete()
is false.)</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError iff called post-finalize.</strong><strong> (</strong><strong>Deprecated.</strong><strong>)</strong> – </p>
</dd>
</dl>
<dl class="simple">
<dt>Deprecated:</dt><dd><p>Use set_discrete_contact_approximation() to set the contact model
approximation. The underlying solver will be inferred
automatically. This will be removed from Drake on or after
2024-04-01.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.set_gravity_enabled">
<span class="sig-name descname"><span class="pre">set_gravity_enabled</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_enabled</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.set_gravity_enabled" title="Permalink to this definition"></a></dt>
<dd><p>Sets is_gravity_enabled() for <code class="docutils literal notranslate"><span class="pre">model_instance</span></code> to <code class="docutils literal notranslate"><span class="pre">is_enabled</span></code>.
The effect of <code class="docutils literal notranslate"><span class="pre">is_enabled</span> <span class="pre">=</span> <span class="pre">false</span></code> is effectively equivalent to
disabling (or making zero) gravity for all bodies in the specified
model instance. By default is_gravity_enabled() equals <code class="docutils literal notranslate"><span class="pre">True</span></code> for
all model instances.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if called post-finalize.</strong> – </p></li>
<li><p><strong>RuntimeError if the model instance is invalid.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.set_penetration_allowance">
<span class="sig-name descname"><span class="pre">set_penetration_allowance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">penetration_allowance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.001</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.set_penetration_allowance" title="Permalink to this definition"></a></dt>
<dd><p>Sets the penetration allowance used to estimate the coefficients in
the penalty method used to impose non-penetration among bodies. Refer
to the section mbp_compliant_point_contact “Compliant point contact
model” for further details.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if penetration_allowance is not positive.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.set_sap_near_rigid_threshold">
<span class="sig-name descname"><span class="pre">set_sap_near_rigid_threshold</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">near_rigid_threshold</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.set_sap_near_rigid_threshold" title="Permalink to this definition"></a></dt>
<dd><p>Non-negative dimensionless number typically in the range [0.0, 1.0],
though larger values are allowed even if uncommon. This parameter
controls the “near rigid” regime of the SAP solver, β in section V.B
of [Castro et al., 2021]. It essentially controls a threshold value
for the maximum amount of stiffness SAP can handle robustly. Beyond
this value, stiffness saturates as explained in [Castro et al., 2021].
A value of 1.0 is a conservative choice to avoid ill-conditioning that
might lead to softer than expected contact. If this is your case,
consider turning off this approximation by setting this parameter to
zero. For difficult cases where ill-conditioning is a problem, a small
but non-zero number can be used, e.g. 1.0e-3.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if near_rigid_threshold is negative.</strong> – </p></li>
<li><p><strong>RuntimeError if called post-finalize.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.set_stiction_tolerance">
<span class="sig-name descname"><span class="pre">set_stiction_tolerance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">v_stiction</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.001</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.set_stiction_tolerance" title="Permalink to this definition"></a></dt>
<dd><p><a href="#id27"><span class="problematic" id="id28">**</span></a>** Stribeck model of friction</p>
<p>Currently MultibodyPlant uses the Stribeck approximation to model dry
friction. The Stribeck model of friction is an approximation to
Coulomb’s law of friction that allows using continuous time
integration without the need to specify complementarity constraints.
While this results in a simpler model immediately tractable with
standard numerical methods for integration of ODE’s, it often leads to
stiff dynamics that require an explicit integrator to take very small
time steps. It is therefore recommended to use error controlled
integrators when using this model or the discrete time stepping (see
time_advancement_strategy “Choice of Time Advancement Strategy”). See
stribeck_approximation for a detailed discussion of the Stribeck
model.</p>
<p>Sets the stiction tolerance <code class="docutils literal notranslate"><span class="pre">v_stiction</span></code> for the Stribeck model,
where <code class="docutils literal notranslate"><span class="pre">v_stiction</span></code> must be specified in m/s (meters per second.)
<code class="docutils literal notranslate"><span class="pre">v_stiction</span></code> defaults to a value of 1 millimeter per second. In
selecting a value for <code class="docutils literal notranslate"><span class="pre">v_stiction</span></code>, you must ask yourself the
question, “When two objects are ostensibly in stiction, how much slip
am I willing to allow?” There are two opposing design issues in
picking a value for vₛ. On the one hand, small values of vₛ make the
problem numerically stiff during stiction, potentially increasing the
integration cost. On the other hand, it should be picked to be
appropriate for the scale of the problem. For example, a car
simulation could allow a “large” value for vₛ of 1 cm/s (1×10⁻² m/s),
but reasonable stiction for grasping a 10 cm box might require
limiting residual slip to 1×10⁻³ m/s or less. Ultimately, picking the
largest viable value will allow your simulation to run faster and more
robustly. Note that <code class="docutils literal notranslate"><span class="pre">v_stiction</span></code> is the slip velocity that we’d have
when we are at edge of the friction cone. For cases when the friction
force is well within the friction cone the slip velocity will always
be smaller than this value. See also stribeck_approximation.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if v_stiction is non-positive.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.SetActuationInArray">
<span class="sig-name descname"><span class="pre">SetActuationInArray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">u_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">u</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.writeable</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.SetActuationInArray" title="Permalink to this definition"></a></dt>
<dd><p>Given actuation values <code class="docutils literal notranslate"><span class="pre">u_instance</span></code> for the actuators in
<code class="docutils literal notranslate"><span class="pre">model_instance</span></code>, this function updates the actuation vector u for
the entire plant model to which this actuator belongs to. Refer to
mbp_actuation “Actuation” for further details.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">u_instance</span></code>:</dt><dd><p>Actuation values for the model instance. Values are ordered by
monotonically increasing JointActuatorIndex within the model
instance.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">u</span></code>:</dt><dd><p>Actuation values for the entire plant model. The actuation value
in <code class="docutils literal notranslate"><span class="pre">u</span></code> for a particular actuator must be found at offset
JointActuator::input_start(). Only values corresponding to
<code class="docutils literal notranslate"><span class="pre">model_instance</span></code> are changed.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the size of u_instance is not equal to the</strong> – </p></li>
<li><p><strong>number of actuation inputs for the joints of model_instance.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.SetConstraintActiveStatus">
<span class="sig-name descname"><span class="pre">SetConstraintActiveStatus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context" title="pydrake.systems.framework.Context"><span class="pre">pydrake.systems.framework.Context</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">id</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.MultibodyConstraintId" title="pydrake.multibody.tree.MultibodyConstraintId"><span class="pre">pydrake.multibody.tree.MultibodyConstraintId</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">status</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.SetConstraintActiveStatus" title="Permalink to this definition"></a></dt>
<dd><p>Sets the active status of the constraint given by <code class="docutils literal notranslate"><span class="pre">id</span></code> in
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the MultibodyPlant has not been finalized.</strong> – </p></li>
<li><p><strong>RuntimeError if context == nullptr</strong> – </p></li>
<li><p><strong>RuntimeError if id does not belong to any multibody constraint</strong> – </p></li>
<li><p><strong>in context.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.SetDefaultFreeBodyPose">
<span class="sig-name descname"><span class="pre">SetDefaultFreeBodyPose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">body</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody" title="pydrake.multibody.tree.RigidBody"><span class="pre">pydrake.multibody.tree.RigidBody</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">X_WB</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.math.html#pydrake.math.RigidTransform" title="pydrake.math.RigidTransform"><span class="pre">pydrake.math.RigidTransform</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.SetDefaultFreeBodyPose" title="Permalink to this definition"></a></dt>
<dd><p>Sets the default pose of <code class="docutils literal notranslate"><span class="pre">body</span></code>. If <code class="docutils literal notranslate"><span class="pre">body.is_floating()</span></code> is true,
this will affect subsequent calls to SetDefaultState(); otherwise, the
only effect of the call is that the value will be echoed back in
GetDefaultFreeBodyPose().</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body</span></code>:</dt><dd><p>RigidBody whose default pose will be set.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">X_WB</span></code>:</dt><dd><p>Default pose of the body.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.SetDefaultPositions">
<span class="sig-name descname"><span class="pre">SetDefaultPositions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.SetDefaultPositions" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>SetDefaultPositions(self: pydrake.multibody.plant.MultibodyPlant, q: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</p></li>
</ol>
<p>Sets the default positions for the plant. Calls to
CreateDefaultContext or SetDefaultContext/SetDefaultState will return
a Context populated with these position values. They have no other
effects on the dynamics of the system.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the plant is not finalized</strong><strong> or </strong><strong>if q is not of size</strong> – </p></li>
<li><p><strong>num_positions</strong><strong>(</strong><strong>)</strong><strong></strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>SetDefaultPositions(self: pydrake.multibody.plant.MultibodyPlant, model_instance: pydrake.multibody.tree.ModelInstanceIndex, q_instance: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</p></li>
</ol>
<p>Sets the default positions for the model instance. Calls to
CreateDefaultContext or SetDefaultContext/SetDefaultState will return
a Context populated with these position values. They have no other
effects on the dynamics of the system.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the plant is not finalized</strong><strong>, </strong><strong>if the model_instance</strong> – </p></li>
<li><p><strong>is invalid</strong><strong>, or </strong><strong>if the length of q_instance is not equal to</strong> – </p></li>
<li><p><strong>num_positions</strong><strong>(</strong><strong>model_instance</strong><strong>)</strong><strong>`</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.SetDefaultState">
<span class="sig-name descname"><span class="pre">SetDefaultState</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context" title="pydrake.systems.framework.Context"><span class="pre">pydrake.systems.framework.Context</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">state</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.State" title="pydrake.systems.framework.State"><span class="pre">pydrake.systems.framework.State</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.SetDefaultState" title="Permalink to this definition"></a></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">state</span></code> according to defaults set by the user for joints (e.g.
RevoluteJoint::set_default_angle()) and free bodies
(SetDefaultFreeBodyPose()). If the user does not specify defaults, the
state corresponds to zero generalized positions and velocities.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize. See Finalize</strong><strong>(</strong><strong>)</strong><strong></strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.SetFreeBodyPose">
<span class="sig-name descname"><span class="pre">SetFreeBodyPose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context" title="pydrake.systems.framework.Context"><span class="pre">pydrake.systems.framework.Context</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">body</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody" title="pydrake.multibody.tree.RigidBody"><span class="pre">pydrake.multibody.tree.RigidBody</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">X_WB</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.math.html#pydrake.math.RigidTransform" title="pydrake.math.RigidTransform"><span class="pre">pydrake.math.RigidTransform</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.SetFreeBodyPose" title="Permalink to this definition"></a></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">context</span></code> to store the pose <code class="docutils literal notranslate"><span class="pre">X_WB</span></code> of a given <code class="docutils literal notranslate"><span class="pre">body</span></code> B in
the world frame W.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In general setting the pose and/or velocity of a body in the model
would involve a complex inverse kinematics problem. This method
allows us to simplify this process when we know the body is free
in space.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if body is not a free body in the model.</strong> – </p></li>
<li><p><strong>RuntimeError if called pre-finalize.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.SetFreeBodySpatialVelocity">
<span class="sig-name descname"><span class="pre">SetFreeBodySpatialVelocity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">body</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody" title="pydrake.multibody.tree.RigidBody"><span class="pre">pydrake.multibody.tree.RigidBody</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">V_WB</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.math.html#pydrake.multibody.math.SpatialVelocity" title="pydrake.multibody.math.SpatialVelocity"><span class="pre">pydrake.multibody.math.SpatialVelocity</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context" title="pydrake.systems.framework.Context"><span class="pre">pydrake.systems.framework.Context</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.SetFreeBodySpatialVelocity" title="Permalink to this definition"></a></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">context</span></code> to store the spatial velocity <code class="docutils literal notranslate"><span class="pre">V_WB</span></code> of a given
<code class="docutils literal notranslate"><span class="pre">body</span></code> B in the world frame W.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In general setting the pose and/or velocity of a body in the model
would involve a complex inverse kinematics problem. This method
allows us to simplify this process when we know the body is free
in space.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if body is not a free body in the model.</strong> – </p></li>
<li><p><strong>RuntimeError if called pre-finalize.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.SetPositions">
<span class="sig-name descname"><span class="pre">SetPositions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.SetPositions" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>SetPositions(self: pydrake.multibody.plant.MultibodyPlant, context: pydrake.systems.framework.Context, q: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</p></li>
</ol>
<p>Sets the generalized positions q in a given Context from a given
vector. Prefer this method over GetMutablePositions().</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if context is nullptr</strong><strong>, </strong><strong>if context does not</strong> – </p></li>
<li><p><strong>correspond to the Context for a multibody model</strong><strong>, or </strong><strong>if the length</strong> – </p></li>
<li><p><strong>of q is not equal to num_positions</strong><strong>(</strong><strong>)</strong><strong></strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>SetPositions(self: pydrake.multibody.plant.MultibodyPlant, context: pydrake.systems.framework.Context, model_instance: pydrake.multibody.tree.ModelInstanceIndex, q: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</p></li>
</ol>
<p>Sets the generalized positions q in a given Context from a given
vector. Prefer this method over GetMutablePositions().</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if context is nullptr</strong><strong>, </strong><strong>if context does not</strong> – </p></li>
<li><p><strong>correspond to the Context for a multibody model</strong><strong>, or </strong><strong>if the length</strong> – </p></li>
<li><p><strong>of q is not equal to num_positions</strong><strong>(</strong><strong>)</strong><strong></strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.SetPositionsAndVelocities">
<span class="sig-name descname"><span class="pre">SetPositionsAndVelocities</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.SetPositionsAndVelocities" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>SetPositionsAndVelocities(self: pydrake.multibody.plant.MultibodyPlant, context: pydrake.systems.framework.Context, q_v: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</p></li>
</ol>
<p>Sets generalized positions q and generalized velocities v in a given
Context from a given vector [q; v]. Prefer this method over
GetMutablePositionsAndVelocities().</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if context is nullptr</strong><strong>, </strong><strong>if context does not</strong> – </p></li>
<li><p><strong>correspond to the context for a multibody model</strong><strong>, or </strong><strong>if the length</strong> – </p></li>
<li><p><strong>of q_v is not equal to num_positions</strong><strong>(</strong><strong>) </strong><strong>+ num_velocities</strong><strong>(</strong><strong>)</strong><strong></strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>SetPositionsAndVelocities(self: pydrake.multibody.plant.MultibodyPlant, context: pydrake.systems.framework.Context, model_instance: pydrake.multibody.tree.ModelInstanceIndex, q_v: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</p></li>
</ol>
<p>Sets generalized positions q and generalized velocities v from a given
vector [q; v] for a specified model instance in a given Context.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if context is nullptr</strong><strong>, </strong><strong>if context does not</strong> – </p></li>
<li><p><strong>correspond to the Context for a multibody model</strong><strong>, </strong><strong>if the model</strong> – </p></li>
<li><p><strong>instance index is invalid</strong><strong>, or </strong><strong>if the length of q_v is not</strong> – </p></li>
<li><p><strong>equal to ``num_positions</strong><strong>(</strong><strong>model_instance</strong><strong>) </strong><strong>+</strong> – </p></li>
<li><p><strong>num_velocities</strong><strong>(</strong><strong>model_instance</strong><strong>)</strong><strong>``.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.SetPositionsInArray">
<span class="sig-name descname"><span class="pre">SetPositionsInArray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">q_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.writeable</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.SetPositionsInArray" title="Permalink to this definition"></a></dt>
<dd><p>Sets the vector of generalized positions for <code class="docutils literal notranslate"><span class="pre">model_instance</span></code> in
<code class="docutils literal notranslate"><span class="pre">q</span></code> using <code class="docutils literal notranslate"><span class="pre">q_instance</span></code>, leaving all other elements in the array
untouched. This method throws an exception if <code class="docutils literal notranslate"><span class="pre">q</span></code> is not of size
MultibodyPlant::num_positions() or <code class="docutils literal notranslate"><span class="pre">q_instance</span></code> is not of size
<code class="docutils literal notranslate"><span class="pre">MultibodyPlant::num_positions(model_instance)</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.SetVelocities">
<span class="sig-name descname"><span class="pre">SetVelocities</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.SetVelocities" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>SetVelocities(self: pydrake.multibody.plant.MultibodyPlant, context: pydrake.systems.framework.Context, v: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</p></li>
</ol>
<p>Sets the generalized velocities v in a given Context from a given
vector. Prefer this method over GetMutableVelocities().</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the context is nullptr</strong><strong>, </strong><strong>if the context does</strong> – </p></li>
<li><p><strong>not correspond to the context for a multibody model</strong><strong>, or </strong><strong>if the</strong> – </p></li>
<li><p><strong>length of v is not equal to num_velocities</strong><strong>(</strong><strong>)</strong><strong></strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>SetVelocities(self: pydrake.multibody.plant.MultibodyPlant, context: pydrake.systems.framework.Context, model_instance: pydrake.multibody.tree.ModelInstanceIndex, v: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</p></li>
</ol>
<p>Sets the generalized velocities v for a particular model instance in a
given Context from a given vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the context is nullptr</strong><strong>, </strong><strong>if context does</strong> – </p></li>
<li><p><strong>not correspond to the Context for a multibody model</strong><strong>, </strong><strong>if the model</strong> – </p></li>
<li><p><strong>instance index is invalid</strong><strong>, or </strong><strong>if the length of v_instance is</strong> – </p></li>
<li><p><strong>not equal to num_velocities</strong><strong>(</strong><strong>model_instance</strong><strong>)</strong><strong></strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.SetVelocitiesInArray">
<span class="sig-name descname"><span class="pre">SetVelocitiesInArray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">v_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.writeable</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.SetVelocitiesInArray" title="Permalink to this definition"></a></dt>
<dd><p>Sets the vector of generalized velocities for <code class="docutils literal notranslate"><span class="pre">model_instance</span></code> in
<code class="docutils literal notranslate"><span class="pre">v</span></code> using <code class="docutils literal notranslate"><span class="pre">v_instance</span></code>, leaving all other elements in the array
untouched. This method throws an exception if <code class="docutils literal notranslate"><span class="pre">v</span></code> is not of size
MultibodyPlant::num_velocities() or <code class="docutils literal notranslate"><span class="pre">v_instance</span></code> is not of size
<code class="docutils literal notranslate"><span class="pre">MultibodyPlant::num_positions(model_instance)</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.time_step">
<span class="sig-name descname"><span class="pre">time_step</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.time_step" title="Permalink to this definition"></a></dt>
<dd><p>The time step (or period) used to model <code class="docutils literal notranslate"><span class="pre">this</span></code> plant as a discrete
system with periodic updates. Returns 0 (zero) if the plant is modeled
as a continuous system. This property of the plant is specified at
construction and therefore this query can be performed either pre- or
post-finalize, see Finalize().</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>MultibodyPlant::MultibodyPlant(double)</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.WeldFrames">
<span class="sig-name descname"><span class="pre">WeldFrames</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.WeldFrames" title="Permalink to this definition"></a></dt>
<dd><dl>
<dt>WeldFrames(self: pydrake.multibody.plant.MultibodyPlant, frame_on_parent_F: pydrake.multibody.tree.Frame, frame_on_child_M: pydrake.multibody.tree.Frame, X_FM: pydrake.math.RigidTransform = RigidTransform(</dt><dd><dl class="simple">
<dt>R=RotationMatrix([</dt><dd><p>[1.0, 0.0, 0.0],
[0.0, 1.0, 0.0],
[0.0, 0.0, 1.0],</p>
</dd>
</dl>
<p>]),
p=[0.0, 0.0, 0.0],</p>
</dd>
</dl>
<p>)) -&gt; pydrake.multibody.tree.WeldJoint</p>
<p>Welds <code class="docutils literal notranslate"><span class="pre">frame_on_parent_F</span></code> and <code class="docutils literal notranslate"><span class="pre">frame_on_child_M</span></code> with relative
pose <code class="docutils literal notranslate"><span class="pre">X_FM</span></code>. That is, the pose of frame M in frame F is fixed, with
value <code class="docutils literal notranslate"><span class="pre">X_FM</span></code>. If <code class="docutils literal notranslate"><span class="pre">X_FM</span></code> is omitted, the identity transform will be
used. The call to this method creates and adds a new WeldJoint to the
model. The new WeldJoint is named as: frame_on_parent_F.name() +
“_welds_to_” + frame_on_child_M.name().</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a constant reference to the WeldJoint welding frames F and M.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>RuntimeError if the weld produces a duplicate joint name.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.world_body">
<span class="sig-name descname"><span class="pre">world_body</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody" title="pydrake.multibody.tree.RigidBody"><span class="pre">pydrake.multibody.tree.RigidBody</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.world_body" title="Permalink to this definition"></a></dt>
<dd><p>Returns a constant reference to the <em>world</em> body.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant.world_frame">
<span class="sig-name descname"><span class="pre">world_frame</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBodyFrame" title="pydrake.multibody.tree.RigidBodyFrame"><span class="pre">pydrake.multibody.tree.RigidBodyFrame</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant.world_frame" title="Permalink to this definition"></a></dt>
<dd><p>Returns a constant reference to the <em>world</em> frame.</p>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_">
<em class="property"><span class="pre">template</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">MultibodyPlant_</span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_" title="Permalink to this definition"></a></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">MultibodyPlant_[float]</span></code>, <a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd" title="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">MultibodyPlant_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_-Expression" title="pydrake.multibody.plant.MultibodyPlant_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">MultibodyPlant_[Expression]</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">MultibodyPlant_[AutoDiffXd]</span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.LeafSystem_-AutoDiffXd" title="pydrake.systems.framework.LeafSystem_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem_[AutoDiffXd]</span></code></a></p>
<p>MultibodyPlant is a Drake system framework representation (see
systems::System) for the model of a physical system consisting of a
collection of interconnected bodies. See multibody for an overview of
concepts/notation.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">actuation&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">applied_generalized_force&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">applied_spatial_force&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px"><em style="color:gray">model_instance_name[i]</em>_actuation&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px"><em style="color:gray">model_instance_name[i]</em>_desired_state&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px"><span style="color:green">geometry_query</span>&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>MultibodyPlant</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; state</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; body_poses</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; body_spatial_velocities</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; body_spatial_accelerations</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; generalized_acceleration</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; net_actuation</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; reaction_forces</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; contact_results</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; <em style="color:gray">model_instance_name[i]</em>_state</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; <em style="color:gray"> model_instance_name[i]</em>_generalized_acceleration</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; <em style="color:gray"> model_instance_name[i]</em>_generalized_contact_forces</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; <em style="color:gray">model_instance_name[i]</em>_net_actuation</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; <span style="color:green">geometry_pose</span></td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; <span style="color:green">deformable_body_configuration</span></td></tr></table></td></tr></table><p>The ports whose names begin with &lt;em style=”color:gray”&gt;
model_instance_name[i]&lt;/em&gt; represent groups of ports, one for each of
the model_instances “model instances”, with i ∈ {0, …, N-1} for the
N model instances. If a model instance does not contain any data of
the indicated type the port will still be present but its value will
be a zero-length vector. (Model instances <code class="docutils literal notranslate"><span class="pre">world_model_instance()</span></code>
and <code class="docutils literal notranslate"><span class="pre">default_model_instance()</span></code> always exist.)</p>
<p>The ports shown in &lt;span style=”color:green”&gt; green&lt;/span&gt; are for
communication with Drake’s geometry::SceneGraph “SceneGraph” system
for dealing with geometry.</p>
<p>MultibodyPlant provides a user-facing API for:</p>
<ul class="simple">
<li><p>mbp_input_and_output_ports “Ports”:</p></li>
</ul>
<p>Access input and output ports.
- mbp_construction “Construction”:
Add bodies, joints, frames, force elements, and actuators.
- mbp_geometry “Geometry”:
Register geometries to a provided SceneGraph instance.
- mbp_contact_modeling “Contact modeling”:
Select and parameterize contact models.
- mbp_state_accessors_and_mutators “State access and modification”:
Obtain and manipulate position and velocity state variables.
- mbp_parameters “Parameters”
Working with system parameters for various multibody elements.
- mbp_working_with_free_bodies “Free bodies”:
Work conveniently with free (floating) bodies.
- mbp_kinematic_and_dynamic_computations “Kinematics and dynamics”:
Perform systems::Context “Context”-dependent kinematic and dynamic
queries.
- mbp_system_matrix_computations “System matrices”:
Explicitly form matrices that appear in the equations of motion.
- mbp_introspection “Introspection”:
Perform introspection to find out what’s in the MultibodyPlant.</p>
<p><a href="#id31"><span class="problematic" id="id32">**</span></a>** Model Instances</p>
<p>A MultiBodyPlant may contain multiple model instances. Each model
instance corresponds to a set of bodies and their connections
(joints). Model instances provide methods to get or set the state of
the set of bodies (e.g., through GetPositionsAndVelocities() and
SetPositionsAndVelocities()), connecting controllers (through
get_state_output_port() and get_actuation_input_port()), and
organizing duplicate models (read through a parser). In fact, many
MultibodyPlant methods are overloaded to allow operating on the entire
plant or just the subset corresponding to the model instance; for
example, one GetPositions() method obtains the generalized positions
for the entire plant while another GetPositions() method obtains the
generalized positions for model instance.</p>
<p>Model instances are frequently defined through SDFormat files (using
the <code class="docutils literal notranslate"><span class="pre">model</span></code> tag) and are automatically created when SDFormat files
are parsed (by Parser). There are two special
multibody::ModelInstanceIndex values. The world body is always
multibody::ModelInstanceIndex 0. multibody::ModelInstanceIndex 1 is
reserved for all elements with no explicit model instance and is
generally only relevant for elements created programmatically (and
only when a model instance is not explicitly specified). Note that
Parser creates model instances (resulting in a
multibody::ModelInstanceIndex ≥ 2) as needed.</p>
<p>See num_model_instances(), num_positions(), num_velocities(),
num_actuated_dofs(), AddModelInstance() GetPositionsAndVelocities(),
GetPositions(), GetVelocities(), SetPositionsAndVelocities(),
SetPositions(), SetVelocities(), GetPositionsFromArray(),
GetVelocitiesFromArray(), SetPositionsInArray(),
SetVelocitiesInArray(), SetActuationInArray(),
HasModelInstanceNamed(), GetModelInstanceName(),
get_state_output_port(), get_actuation_input_port().</p>
<p><a href="#id33"><span class="problematic" id="id34">**</span></a>** System dynamics</p>
<p>The state of a multibody system <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">[q;</span> <span class="pre">v]</span></code> is given by its
generalized positions vector q, of size <code class="docutils literal notranslate"><span class="pre">nq</span></code> (see num_positions()),
and by its generalized velocities vector v, of size <code class="docutils literal notranslate"><span class="pre">nv</span></code> (see
num_velocities()). As a Drake systems::System “System”, MultibodyPlant
implements the governing equations for a multibody dynamical system in
the form <code class="docutils literal notranslate"><span class="pre">ẋ</span> <span class="pre">=</span> <span class="pre">f(t,</span> <span class="pre">x,</span> <span class="pre">u)</span></code> with t being time and u the actuation
forces. The governing equations for the dynamics of a multibody system
modeled with MultibodyPlant are [Featherstone 2008, Jain 2010]:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>q̇ = N(q)v
(1)    M(q)v̇ + C(q, v)v = τ
</pre></div>
</div>
</details><p>where <code class="docutils literal notranslate"><span class="pre">M(q)</span></code> is the mass matrix of the multibody system (including
rigid body mass properties and reflected_inertia “reflected
inertias”), <code class="docutils literal notranslate"><span class="pre">C(q,</span> <span class="pre">v)v</span></code> contains Coriolis, centripetal, and
gyroscopic terms and <code class="docutils literal notranslate"><span class="pre">N(q)</span></code> is the kinematic coupling matrix
describing the relationship between q̇ (the time derivatives of the
generalized positions) and the generalized velocities v, [Seth 2010].
<code class="docutils literal notranslate"><span class="pre">N(q)</span></code> is an <code class="docutils literal notranslate"><span class="pre">nq</span> <span class="pre">x</span> <span class="pre">nv</span></code> matrix. The vector <code class="docutils literal notranslate"><span class="pre">τ</span> <span class="pre">∈</span> <span class="pre">ℝⁿᵛ</span></code> on the right
hand side of Eq. (1) is the system’s generalized forces. These
incorporate gravity, springs, externally applied body forces,
constraint forces, and contact forces.</p>
<p><a href="#id35"><span class="problematic" id="id36">**</span></a>** Actuation</p>
<p>In a MultibodyPlant model an actuator can be added as a JointActuator,
see AddJointActuator(). The plant declares actuation input ports to
provide feedforward actuation, both for the MultibodyPlant as a whole
(see get_actuation_input_port()) and for each individual
model_instances “model instance” in the MultibodyPlant (see
get_actuation_input_port(ModelInstanceIndex)const
“get_actuation_input_port(ModelInstanceIndex)”). Any actuation input
ports not connected are assumed to be zero. Actuation values from the
full MultibodyPlant model port (get_actuation_input_port()) and from
the per model-instance ports (
get_actuation_input_port(ModelInstanceIndex)const
“get_actuation_input_port(ModelInstanceIndex)”) are summed up.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A JointActuator’s index into the vector data supplied to
MultibodyPlant’s actuation input port for all actuators
(get_actuation_input_port()) is given by
JointActuator::input_start(), NOT by its JointActuatorIndex. That
is, the vector element data for a JointActuator at index
JointActuatorIndex(i) in the full input port vector is found at
index:
MultibodyPlant::get_joint_actuator(JointActuatorIndex(i)).input_start().
For the get_actuation_input_port(ModelInstanceIndex)const
“get_actuation_input_port(ModelInstanceIndex)” specific to a model
index, the vector data is ordered by monotonically increasing
JointActuatorIndex for the actuators within that model instance:
the 0ᵗʰ vector element corresponds to the lowest-numbered
JointActuatorIndex of that instance, the 1ˢᵗ vector element
corresponds to the second-lowest-numbered JointActuatorIndex of
that instance, etc.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The following snippet shows how per model instance actuation can
be set:</p>
</div>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">ModelInstanceIndex</span><span class="w"> </span><span class="n">model_instance_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...;</span><span class="w"></span>
<span class="n">VectorX</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">u_instance</span><span class="p">(</span><span class="n">plant</span><span class="p">.</span><span class="n">num_actuated_dofs</span><span class="p">(</span><span class="n">model_instance_index</span><span class="p">));</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">JointActuatorIndex</span><span class="w"> </span><span class="n">joint_actuator_index</span><span class="w"> </span><span class="o">:</span><span class="w"></span>
<span class="n">plant</span><span class="p">.</span><span class="n">GetJointActuatorIndices</span><span class="p">(</span><span class="n">model_instance_index</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="n">JointActuator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">actuator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">plant</span><span class="p">.</span><span class="n">get_joint_actuator</span><span class="p">(</span><span class="w"></span>
<span class="n">joint_actuator_index</span><span class="p">);</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="n">Joint</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">joint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">actuator</span><span class="p">.</span><span class="n">joint</span><span class="p">();</span><span class="w"></span>
<span class="n">VectorX</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">u_joint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="n">my_actuation_logic_for</span><span class="p">(</span><span class="n">joint</span><span class="p">)</span><span class="w"> </span><span class="p">...;</span><span class="w"></span>
<span class="n">ASSERT</span><span class="p">(</span><span class="n">u_joint</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">joint_actuator</span><span class="p">.</span><span class="n">num_inputs</span><span class="p">());</span><span class="w"></span>
<span class="n">u_instance</span><span class="p">.</span><span class="n">segment</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="n">u_joint</span><span class="p">.</span><span class="n">size</span><span class="p">())</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">u_joint</span><span class="p">;</span><span class="w"></span>
<span class="n">offset</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">u_joint</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="n">plant</span><span class="p">.</span><span class="n">get_actuation_input_port</span><span class="p">(</span><span class="n">model_instance_index</span><span class="p">).</span><span class="n">FixValue</span><span class="p">(</span><span class="w"></span>
<span class="n">plant_context</span><span class="p">,</span><span class="w"> </span><span class="n">u_instance</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</details><div class="admonition note">
<p class="admonition-title">Note</p>
<p>To inter-operate between the whole plant actuation vector and sets
of per-model instance actuation vectors, see SetActuationInArray()
to gather the model instance vectors into a whole plant vector and
GetActuationFromArray() to scatter the whole plant vector into
per-model instance vectors.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Effort limits (JointActuator::effort_limit()) are not enforced,
unless PD controllers are defined. See pd_controllers “Using PD
controlled actuators”.</p>
</div>
<p>** Using PD controlled actuators</p>
<p>While PD controllers can be modeled externally and be connected to the
MultibodyPlant model via the get_actuation_input_port(), simulation
stability at discrete time steps can be compromised for high
controller gains. For such cases, simulation stability and robustness
can be improved significantly by moving your PD controller into the
plant where the discrete solver can strongly couple controller and
model dynamics.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Currently, this feature is only supported for discrete models
(is_discrete() is true) using the SAP solver
(get_discrete_contact_solver() returns
DiscreteContactSolver::kSap.)</p>
</div>
<p>PD controlled joint actuators can be defined by setting PD gains for
each joint actuator, see JointActuator::set_controller_gains(). Unless
these gains are specified, joint actuators will not be PD controlled
and JointActuator::has_controller() will return <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>For PD controlled models, all joint actuators in a model instance
are required to have PD controllers defined. That is, partially PD
controlled model instances are not supported. An exception will be
thrown when evaluating the actuation input ports if only a subset
of the actuators in a model instance is PD controlled.</p>
</div>
<p>For models with PD controllers, the actuation torque per actuator is
computed according to:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>ũ = -Kp⋅(q − qd) - Kd⋅(v − vd) + u_ff
u = max(−e, min(e, ũ))
</pre></div>
</div>
</details><p>where qd and vd are desired configuration and velocity (see
get_desired_state_input_port()) for the actuated joint (see
JointActuator::joint()), Kp and Kd are the proportional and derivative
gains of the actuator (see JointActuator::get_controller_gains()),
<code class="docutils literal notranslate"><span class="pre">u_ff</span></code> is the feed-forward actuation specified with
get_actuation_input_port(), and <code class="docutils literal notranslate"><span class="pre">e</span></code> corresponds to effort limit (see
JointActuator::effort_limit()).</p>
<p>Notice that actuation through get_actuation_input_port() and PD
control are not mutually exclusive, and they can be used together.
This is better explained through examples: 1. <strong>PD controlled
gripper</strong>. In this case, only PD control is used to drive the opening
and closing of the fingers. The feed-forward term is assumed to be
zero and the actuation input port is not required to be connected. 2.
<strong>Robot arm</strong>. A typical configuration consists on applying gravity
compensation in the feed-forward term plus PD control to drive the
robot to a given desired state.</p>
<p>** Actuation input ports requirements</p>
<p>The following table specifies whether actuation ports are required to
be connected or not:</p>
<div class="line-block">
<div class="line">Port | without PD control | with PD control | |</div>
</div>
<dl class="field-list">
<dt class="field-odd">——————————</dt>
<dd class="field-odd"><div class="line-block">
<div class="line">:——————-: |</div>
</div>
</dd>
<dt class="field-even">————-</dt>
<dd class="field-even"><div class="line-block">
<div class="line">| get_actuation_input_port() | yes | no¹ | |</div>
</div>
</dd>
</dl>
<p>get_desired_state_input_port() | no² | yes |</p>
<p>¹ Feed-forward actuation is not required for models with PD controlled
actuators. This simplifies the diagram wiring for models that only
rely on PD controllers.</p>
<p>² This port is always declared, though it will be zero sized for model
instances with no PD controllers.</p>
<p>** Net actuation</p>
<p>The total joint actuation applied via the actuation input port
(get_actuation_input_port()) and applied by the PD controllers is
reported by the net actuation port (get_net_actuation_output_port()).
That is, the net actuation port reports the total actuation applied by
a given actuator.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>PD controllers are ignored when a joint is locked (see
Joint::Lock()), and thus they have no effect on the actuation
output.</p>
</div>
<p><a href="#id37"><span class="problematic" id="id38">**</span></a>** Loading models from SDFormat files</p>
<p>Drake has the capability to load multibody models from SDFormat and
URDF files. Consider the example below which loads an acrobot model:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">acrobot</span><span class="p">;</span><span class="w"></span>
<span class="n">SceneGraph</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">scene_graph</span><span class="p">;</span><span class="w"></span>
<span class="n">Parser</span><span class="w"> </span><span class="nf">parser</span><span class="p">(</span><span class="o">&amp;</span><span class="n">acrobot</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">scene_graph</span><span class="p">);</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">url</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="s">&quot;package://drake/multibody/benchmarks/acrobot/acrobot.sdf&quot;</span><span class="p">;</span><span class="w"></span>
<span class="n">parser</span><span class="p">.</span><span class="n">AddModelsFromUrl</span><span class="p">(</span><span class="n">url</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</details><p>As in the example above, for models including visual geometry,
collision geometry or both, the user must specify a SceneGraph for
geometry handling. You can find a full example of the LQR controlled
acrobot in examples/multibody/acrobot/run_lqr.cc.</p>
<p>AddModelFromFile() can be invoked multiple times on the same plant in
order to load multiple model instances. Other methods are available on
Parser such as AddModels() which allows creating model instances per
each <code class="docutils literal notranslate"><span class="pre">&lt;model&gt;</span></code> tag found in the file. Please refer to each of these
methods’ documentation for further details.</p>
<p><a href="#id39"><span class="problematic" id="id40">**</span></a>** Working with SceneGraph</p>
<p>** Adding a MultibodyPlant connected to a SceneGraph to your Diagram</p>
<p>Probably the simplest way to add and wire up a MultibodyPlant with a
SceneGraph in your Diagram is using AddMultibodyPlantSceneGraph().</p>
<p>Recommended usages:</p>
<p>Assign to a MultibodyPlant reference (ignoring the SceneGraph):</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">plant</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="n">AddMultibodyPlantSceneGraph</span><span class="p">(</span><span class="o">&amp;</span><span class="n">builder</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="o">/+</span><span class="w"> </span><span class="n">time_step</span><span class="w"> </span><span class="o">+/</span><span class="p">);</span><span class="w"></span>
<span class="n">plant</span><span class="p">.</span><span class="n">DoFoo</span><span class="p">(...);</span><span class="w"></span>
</pre></div>
</div>
</details><p>This flavor is the simplest, when the SceneGraph is not explicitly
needed. (It can always be retrieved later via
GetSubsystemByName(“scene_graph”).)</p>
<p>Assign to auto, and use the named public fields:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="n">items</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AddMultibodyPlantSceneGraph</span><span class="p">(</span><span class="o">&amp;</span><span class="n">builder</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="o">/+</span><span class="w"> </span><span class="n">time_step</span><span class="w"> </span><span class="o">+/</span><span class="p">);</span><span class="w"></span>
<span class="n">items</span><span class="p">.</span><span class="n">plant</span><span class="p">.</span><span class="n">DoFoo</span><span class="p">(...);</span><span class="w"></span>
<span class="n">items</span><span class="p">.</span><span class="n">scene_graph</span><span class="p">.</span><span class="n">DoBar</span><span class="p">(...);</span><span class="w"></span>
</pre></div>
</div>
</details><p>or taking advantage of C++’s structured binding:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="p">[</span><span class="n">plant</span><span class="p">,</span><span class="w"> </span><span class="n">scene_graph</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AddMultibodyPlantSceneGraph</span><span class="p">(</span><span class="o">&amp;</span><span class="n">builder</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">);</span><span class="w"></span>
<span class="p">...</span><span class="w"></span>
<span class="n">plant</span><span class="p">.</span><span class="n">DoFoo</span><span class="p">(...);</span><span class="w"></span>
<span class="n">scene_graph</span><span class="p">.</span><span class="n">DoBar</span><span class="p">(...);</span><span class="w"></span>
</pre></div>
</div>
</details><p>This is the easiest way to use both the plant and scene_graph.</p>
<p>Assign to already-declared pointer variables:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;*</span><span class="w"> </span><span class="n">plant</span><span class="p">{};</span><span class="w"></span>
<span class="n">SceneGraph</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;*</span><span class="w"> </span><span class="n">scene_graph</span><span class="p">{};</span><span class="w"></span>
<span class="n">std</span><span class="o">::</span><span class="n">tie</span><span class="p">(</span><span class="n">plant</span><span class="p">,</span><span class="w"> </span><span class="n">scene_graph</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="n">AddMultibodyPlantSceneGraph</span><span class="p">(</span><span class="o">&amp;</span><span class="n">builder</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="o">/+</span><span class="w"> </span><span class="n">time_step</span><span class="w"> </span><span class="o">+/</span><span class="p">);</span><span class="w"></span>
<span class="n">plant</span><span class="o">-&gt;</span><span class="n">DoFoo</span><span class="p">(...);</span><span class="w"></span>
<span class="n">scene_graph</span><span class="o">-&gt;</span><span class="n">DoBar</span><span class="p">(...);</span><span class="w"></span>
</pre></div>
</div>
</details><p>This flavor is most useful when the pointers are class member fields
(and so perhaps cannot be references).</p>
<p>** Registering geometry with a SceneGraph</p>
<p>MultibodyPlant users can register geometry with a SceneGraph for
essentially two purposes; a) visualization and, b) contact modeling.</p>
<p>Before any geometry registration takes place, a user <strong>must</strong> first
make a call to RegisterAsSourceForSceneGraph() in order to register
the MultibodyPlant as a client of a SceneGraph instance, point at
which the plant will have assigned a valid geometry::SourceId. At
Finalize(), MultibodyPlant will declare input/output ports as
appropriate to communicate with the SceneGraph instance on which
registrations took place. All geometry registration <strong>must</strong> be
performed pre-finalize.</p>
<p>Multibodyplant declares an input port for geometric queries, see
get_geometry_query_input_port(). If MultibodyPlant registers geometry
with a SceneGraph via calls to RegisterCollisionGeometry(), users may
use this port for geometric queries. The port must be connected to the
same SceneGraph used for registration. The preferred mechanism is to
use AddMultibodyPlantSceneGraph() as documented above.</p>
<p>In extraordinary circumstances, this can be done by hand and the setup
process will include:</p>
<ol class="arabic simple">
<li><p>Call to RegisterAsSourceForSceneGraph().</p></li>
<li><p>Calls to RegisterCollisionGeometry(), as many as needed.</p></li>
<li><p>Call to Finalize(), user is done specifying the model.</p></li>
</ol>
<p>4. Connect geometry::SceneGraph::get_query_output_port() to
get_geometry_query_input_port().
5. Connect get_geometry_poses_output_port() to
geometry::SceneGraph::get_source_pose_port()</p>
<p>Refer to the documentation provided in each of the methods above for
further details.</p>
<p>** Accessing point contact parameters MultibodyPlant’s point contact
model looks for model parameters stored as
geometry::ProximityProperties by geometry::SceneGraph. These
properties can be obtained before or after context creation through
geometry::SceneGraphInspector APIs as outlined below. MultibodyPlant
expects the following properties for point contact modeling:</p>
<p><a href="#id107"><span class="problematic" id="id108">|Group name|Property Name|Required|Property Type|Property Description|</span></a>
<a href="#id109"><span class="problematic" id="id110">|:--------:|</span></a>:———–:<a href="#id111"><span class="problematic" id="id112">|:------:|</span></a>:—————-:<a href="#id113"><span class="problematic" id="id114">|:-------------------|</span></a>
<a href="#id115"><span class="problematic" id="id116">|material|coulomb_friction|yes¹|CoulombFriction&lt;T&gt;|Static and Dynamic
friction.|</span></a> <a href="#id117"><span class="problematic" id="id118">|material|point_contact_stiffness|no²|T|</span></a> Compliant point
contact stiffness.| <a href="#id119"><span class="problematic" id="id120">|material|hunt_crossley_dissipation |no²⁴|T|</span></a>
Compliant contact dissipation.|
<a href="#id121"><span class="problematic" id="id122">|material|relaxation_time|yes³⁴|T|Linear Kelvin–Voigt model
parameter.|</span></a></p>
<p>¹ Collision geometry is required to be registered with a
geometry::ProximityProperties object that contains the (“material”,
“coulomb_friction”) property. If the property is missing,
MultibodyPlant will throw an exception.</p>
<p>² If the property is missing, MultibodyPlant will use a heuristic
value as the default. Refer to the section mbp_compliant_point_contact
“Compliant point contact model” for further details.</p>
<p>³ When using a linear Kelvin–Voigt model of dissipation (for instance
when selecting the SAP solver), collision geometry is required to be
registered with a geometry::ProximityProperties object that contains
the (“material”, “relaxation_time”) property. If the property is
missing, an exception will be thrown.</p>
<p>⁴ We allow to specify both hunt_crossley_dissipation and
relaxation_time for a given geometry. However only one of these will
get used, depending on the configuration of the MultibodyPlant. As an
example, if the SAP contact approximation is specified (see
set_discrete_contact_approximation()) only the relaxation_time is used
while hunt_crossley_dissipation is ignored. Conversely, if the TAMSI,
Similar or Lagged approximation is used (see
set_discrete_contact_approximation()) only hunt_crossley_dissipation
is used while relaxation_time is ignored. Currently, a continuous
MultibodyPlant model will always use the Hunt &amp; Crossley model and
relaxation_time will be ignored.</p>
<p>Accessing and modifying contact properties requires interfacing with
geometry::SceneGraph’s model inspector. Interfacing with a model
inspector obtained from geometry::SceneGraph will provide the default
registered values for a given parameter. These are the values that
will initially appear in a systems::Context created by
CreateDefaultContext(). Subsequently, true system parameters can be
accessed and changed through a systems::Context once available. For
both of the above cases, proximity properties are accessed through
geometry::SceneGraphInspector APIs.</p>
<p>Before context creation an inspector can be retrieved directly from
SceneGraph as:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// For a SceneGraph&lt;T&gt; instance called scene_graph.</span>
<span class="k">const</span><span class="w"> </span><span class="n">geometry</span><span class="o">::</span><span class="n">SceneGraphInspector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">inspector</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="n">scene_graph</span><span class="p">.</span><span class="n">model_inspector</span><span class="p">();</span><span class="w"></span>
</pre></div>
</div>
</details><p>After context creation, an inspector can be retrieved from the state
stored in the context by the plant’s geometry query input port:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// For a MultibodyPlant&lt;T&gt; instance called mbp and a</span>
<span class="c1">// Context&lt;T&gt; called context.</span>
<span class="k">const</span><span class="w"> </span><span class="n">geometry</span><span class="o">::</span><span class="n">QueryObject</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">query_object</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="n">mbp</span><span class="p">.</span><span class="n">get_geometry_query_input_port</span><span class="p">()</span><span class="w"></span>
<span class="p">.</span><span class="k">template</span><span class="w"> </span><span class="n">Eval</span><span class="o">&lt;</span><span class="n">geometry</span><span class="o">::</span><span class="n">QueryObject</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">context</span><span class="p">);</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="n">geometry</span><span class="o">::</span><span class="n">SceneGraphInspector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">inspector</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="n">query_object</span><span class="p">.</span><span class="n">inspector</span><span class="p">();</span><span class="w"></span>
</pre></div>
</div>
</details><p>Once an inspector is available, proximity properties can be retrieved
as:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// For a body with GeometryId called geometry_id</span>
<span class="k">const</span><span class="w"> </span><span class="n">geometry</span><span class="o">::</span><span class="n">ProximityProperties</span><span class="o">*</span><span class="w"> </span><span class="n">props</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="n">inspector</span><span class="p">.</span><span class="n">GetProximityProperties</span><span class="p">(</span><span class="n">geometry_id</span><span class="p">);</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="n">CoulombFriction</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">geometry_friction</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="n">props</span><span class="o">-&gt;</span><span class="n">GetProperty</span><span class="o">&lt;</span><span class="n">CoulombFriction</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="s">&quot;material&quot;</span><span class="p">,</span><span class="w"></span>
<span class="s">&quot;coulomb_friction&quot;</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</details><p><a href="#id41"><span class="problematic" id="id42">**</span></a>** Working with MultibodyElement parameters Several
MultibodyElements expose parameters, allowing the user flexible
modification of some aspects of the plant’s model, post
systems::Context creation. For details, refer to the documentation for
the MultibodyElement whose parameters you are trying to modify/access
(e.g. RigidBody, FixedOffsetFrame, etc.)</p>
<p>As an example, here is how to access and modify rigid body mass
parameters:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">plant</span><span class="p">;</span><span class="w"></span>
<span class="c1">// ... Code to add bodies, finalize plant, and to obtain a context.</span>
<span class="k">const</span><span class="w"> </span><span class="n">RigidBody</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">body</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="n">plant</span><span class="p">.</span><span class="n">GetRigidBodyByName</span><span class="p">(</span><span class="s">&quot;BodyName&quot;</span><span class="p">);</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="n">SpatialInertia</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">M_BBo_B</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="n">body</span><span class="p">.</span><span class="n">GetSpatialInertiaInBodyFrame</span><span class="p">(</span><span class="n">context</span><span class="p">);</span><span class="w"></span>
<span class="c1">// .. logic to determine a new SpatialInertia parameter for body.</span>
<span class="k">const</span><span class="w"> </span><span class="n">SpatialInertia</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">M_BBo_B_new</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">....</span><span class="w"></span>

<span class="c1">// Modify the body parameter for spatial inertia.</span>
<span class="n">body</span><span class="p">.</span><span class="n">SetSpatialInertiaInBodyFrame</span><span class="p">(</span><span class="o">&amp;</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="n">M_BBo_B_new</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</details><p>Another example, working with automatic differentiation in order to
take derivatives with respect to one of the bodies’ masses:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">plant</span><span class="p">;</span><span class="w"></span>
<span class="c1">// ... Code to add bodies, finalize plant, and to obtain a</span>
<span class="c1">// context and a body&#39;s spatial inertia M_BBo_B.</span>

<span class="c1">// Scalar convert the plant.</span>
<span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="n">AutoDiffXd</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">plant_autodiff</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="n">systems</span><span class="o">::</span><span class="n">System</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">ToAutoDiffXd</span><span class="p">(</span><span class="n">plant</span><span class="p">);</span><span class="w"></span>
<span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Context</span><span class="o">&lt;</span><span class="n">AutoDiffXd</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">context_autodiff</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="n">plant_autodiff</span><span class="o">-&gt;</span><span class="n">CreateDefaultContext</span><span class="p">();</span><span class="w"></span>
<span class="n">context_autodiff</span><span class="o">-&gt;</span><span class="n">SetTimeStateAndParametersFrom</span><span class="p">(</span><span class="n">context</span><span class="p">);</span><span class="w"></span>

<span class="k">const</span><span class="w"> </span><span class="n">RigidBody</span><span class="o">&lt;</span><span class="n">AutoDiffXd</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">body</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="n">plant_autodiff</span><span class="o">-&gt;</span><span class="n">GetRigidBodyByName</span><span class="p">(</span><span class="s">&quot;BodyName&quot;</span><span class="p">);</span><span class="w"></span>

<span class="c1">// Modify the body parameter for mass.</span>
<span class="k">const</span><span class="w"> </span><span class="n">AutoDiffXd</span><span class="w"> </span><span class="nf">mass_autodiff</span><span class="p">(</span><span class="n">mass</span><span class="p">,</span><span class="w"> </span><span class="n">Vector1d</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span><span class="w"></span>
<span class="n">body</span><span class="p">.</span><span class="n">SetMass</span><span class="p">(</span><span class="n">context_autodiff</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span><span class="w"> </span><span class="n">mass_autodiff</span><span class="p">);</span><span class="w"></span>

<span class="c1">// M_autodiff(i, j).derivatives()(0), contains the derivatives of</span>
<span class="c1">// M(i, j) with respect to the body&#39;s mass.</span>
<span class="n">MatrixX</span><span class="o">&lt;</span><span class="n">AutoDiffXd</span><span class="o">&gt;</span><span class="w"> </span><span class="n">M_autodiff</span><span class="p">(</span><span class="n">plant_autodiff</span><span class="o">-&gt;</span><span class="n">num_velocities</span><span class="p">(),</span><span class="w"></span>
<span class="n">plant_autodiff</span><span class="o">-&gt;</span><span class="n">num_velocities</span><span class="p">());</span><span class="w"></span>
<span class="n">plant_autodiff</span><span class="o">-&gt;</span><span class="n">CalcMassMatrix</span><span class="p">(</span><span class="o">*</span><span class="n">context_autodiff</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">M_autodiff</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</details><p><a href="#id43"><span class="problematic" id="id44">**</span></a>** Adding modeling elements</p>
<p>Add multibody elements to a MultibodyPlant with methods like:</p>
<ul class="simple">
<li><p>Bodies: AddRigidBody()</p></li>
<li><p>Joints: AddJoint()</p></li>
<li><p>see mbp_construction “Construction” for more.</p></li>
</ul>
<p>All modeling elements <strong>must</strong> be added before Finalize() is called.
See mbp_finalize_stage “Finalize stage” for a discussion.</p>
<p><a href="#id45"><span class="problematic" id="id46">**</span></a>** Modeling contact</p>
<p>Please refer to drake_contacts “Contact Modeling in Drake” for details
on the available approximations, setup, and considerations for a
multibody simulation with frictional contact.</p>
<p><a href="#id47"><span class="problematic" id="id48">**</span></a>** Energy and Power</p>
<p>MultibodyPlant implements the System energy and power methods, with
some limitations. - Kinetic energy: fully implemented. - Potential
energy and conservative power: currently include only gravity and
contributions from ForceElement objects; potential energy from
compliant contact and joint limits are not included. - Nonconservative
power: currently includes only contributions from ForceElement
objects; actuation and input port forces, joint damping, and
dissipation from joint limits, friction, and contact dissipation are
not included.</p>
<p>See Drake issue #12942 for more discussion.</p>
<p><a href="#id49"><span class="problematic" id="id50">**</span></a>** Finalize() stage</p>
<p>Once the user is done adding modeling elements and registering
geometry, a call to Finalize() must be performed. This call will: -
Build the underlying tree structure of the multibody model, - declare
the plant’s state, - declare the plant’s input and output ports, -
declare collision filters to ignore collisions among rigid bodies: -
between rigid bodies connected by a joint, - within subgraphs of
welded rigid bodies. Note that MultibodyPlant will <em>not</em> introduce
<em>any</em> collision filters on deformable bodies.</p>
<p><a href="#id51"><span class="problematic" id="id52">**</span></a>** References</p>
<ul class="simple">
<li><p>[Featherstone 2008] Featherstone, R., 2008.</p></li>
</ul>
<p>Rigid body dynamics algorithms. Springer.
- [Jain 2010] Jain, A., 2010.
Robot and multibody dynamics: analysis and algorithms.
Springer Science &amp; Business Media.
- [Seth 2010] Seth, A., Sherman, M., Eastman, P. and Delp, S., 2010.
Minimal formulation of joint motion for biomechanisms.
Nonlinear dynamics, 62(1), pp.291-303.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.__init__">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_step</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.__init__" title="Permalink to this definition"></a></dt>
<dd><p>This constructor creates a plant with a single “world” body.
Therefore, right after creation, num_bodies() returns one.</p>
<p>MultibodyPlant offers two different modalities to model mechanical
systems in time. These are: 1. As a discrete system with periodic
updates, <code class="docutils literal notranslate"><span class="pre">time_step</span></code> is strictly greater than zero. 2. As a
continuous system, <code class="docutils literal notranslate"><span class="pre">time_step</span></code> equals exactly zero.</p>
<p>Currently the discrete model is preferred for simulation given its
robustness and speed in problems with frictional contact. However this
might change as we work towards developing better strategies to model
contact. See time_advancement_strategy “Choice of Time Advancement
Strategy” for further details.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Users should be aware of current limitations in either modeling
modality. While the discrete model is often the preferred option
for problems with frictional contact given its robustness and
speed, it might become unstable when using large feedback gains,
high damping or large external forcing. MultibodyPlant will throw
an exception whenever the discrete solver is detected to fail.
Conversely, the continuous modality has the potential to leverage
the robustness and accuracy control provide by Drake’s
integrators. However thus far this has proved difficult in
practice and especially due to poor performance.</p>
</div>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">time_step</span></code>:</dt><dd><p>Indicates whether <code class="docutils literal notranslate"><span class="pre">this</span></code> plant is modeled as a continuous system
(<code class="docutils literal notranslate"><span class="pre">time_step</span> <span class="pre">=</span> <span class="pre">0</span></code>) or as a discrete system with periodic updates
of period <code class="docutils literal notranslate"><span class="pre">time_step</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>. See time_advancement_strategy “Choice
of Time Advancement Strategy” for further details.</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Currently the continuous modality with <code class="docutils literal notranslate"><span class="pre">time_step</span> <span class="pre">=</span> <span class="pre">0</span></code> does not
support joint limits for simulation, these are ignored.
MultibodyPlant prints a warning to console if joint limits are
provided. If your simulation requires joint limits currently you
must use a discrete MultibodyPlant model.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if time_step is negative.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.AddBallConstraint">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].AddBallConstraint"></span><span class="sig-name descname"><span class="pre">AddBallConstraint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body_A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody_" title="pydrake.multibody.tree.RigidBody_"><span class="pre">pydrake.multibody.tree.RigidBody_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_AP</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody_" title="pydrake.multibody.tree.RigidBody_"><span class="pre">pydrake.multibody.tree.RigidBody_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_BQ</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.MultibodyConstraintId" title="pydrake.multibody.tree.MultibodyConstraintId"><span class="pre">pydrake.multibody.tree.MultibodyConstraintId</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.AddBallConstraint" title="Permalink to this definition"></a></dt>
<dd><p>Defines a constraint such that point P affixed to body A is coincident
at all times with point Q affixed to body B, effectively modeling a
ball-and-socket joint.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body_A</span></code>:</dt><dd><p>RigidBody to which point P is rigidly attached.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_AP</span></code>:</dt><dd><p>Position of point P in body A’s frame.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body_B</span></code>:</dt><dd><p>RigidBody to which point Q is rigidly attached.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BQ</span></code>:</dt><dd><p>Position of point Q in body B’s frame.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the id of the newly added constraint.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>RuntimeError if bodies A and B are the same body.</strong> – </p></li>
<li><p><strong>RuntimeError if the MultibodyPlant has already been finalized.</strong> – </p></li>
<li><p><strong>RuntimeError if this MultibodyPlant is not a discrete model</strong> – </p></li>
<li><p><strong>(</strong><strong>is_discrete</strong><strong>(</strong><strong>) </strong><strong>== false</strong><strong>)</strong> – </p></li>
<li><p><strong>RuntimeError if this MultibodyPlant's underlying contact</strong> – </p></li>
<li><p><strong>solver is not SAP.</strong><strong> (</strong><strong>i.e. get_discrete_contact_solver</strong><strong>(</strong><strong>) </strong><strong>!=</strong> – </p></li>
<li><p><strong>DiscreteContactSolver::kSap</strong><strong>)</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.AddCouplerConstraint">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].AddCouplerConstraint"></span><span class="sig-name descname"><span class="pre">AddCouplerConstraint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">joint0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Joint_" title="pydrake.multibody.tree.Joint_"><span class="pre">pydrake.multibody.tree.Joint_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">joint1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Joint_" title="pydrake.multibody.tree.Joint_"><span class="pre">pydrake.multibody.tree.Joint_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gear_ratio</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.0</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.MultibodyConstraintId" title="pydrake.multibody.tree.MultibodyConstraintId"><span class="pre">pydrake.multibody.tree.MultibodyConstraintId</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.AddCouplerConstraint" title="Permalink to this definition"></a></dt>
<dd><p>Defines a holonomic constraint between two single-dof joints
<code class="docutils literal notranslate"><span class="pre">joint0</span></code> and <code class="docutils literal notranslate"><span class="pre">joint1</span></code> with positions q₀ and q₁, respectively, such
that q₀ = ρ⋅q₁ + Δq, where ρ is the gear ratio and Δq is a fixed
offset. The gear ratio can have units if the units of q₀ and q₁ are
different. For instance, between a prismatic and a revolute joint the
gear ratio will specify the “pitch” of the resulting mechanism. As
defined, <code class="docutils literal notranslate"><span class="pre">offset</span></code> has units of <code class="docutils literal notranslate"><span class="pre">q₀</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>joint0 and/or joint1 can still be actuated, regardless of whether
we have coupler constraint among them. That is, one or both of
these joints can have external actuation applied to them.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Generally, to couple (q0, q1, q2), the user would define a coupler
between (q0, q1) and a second coupler between (q1, q2), or any
combination therein.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>if joint0 and joint1 are not both single-dof joints.</strong> – </p></li>
<li><p><strong>RuntimeError if the MultibodyPlant has already been finalized.</strong> – </p></li>
<li><p><strong>RuntimeError if this MultibodyPlant is not a discrete model</strong> – </p></li>
<li><p><strong>(</strong><strong>is_discrete</strong><strong>(</strong><strong>) </strong><strong>== false</strong><strong>)</strong> – </p></li>
<li><p><strong>RuntimeError if this MultibodyPlant's underlying contact</strong> – </p></li>
<li><p><strong>solver is not SAP.</strong><strong> (</strong><strong>i.e. get_discrete_contact_solver</strong><strong>(</strong><strong>) </strong><strong>!=</strong> – </p></li>
<li><p><strong>DiscreteContactSolver::kSap</strong><strong>)</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.AddDistanceConstraint">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].AddDistanceConstraint"></span><span class="sig-name descname"><span class="pre">AddDistanceConstraint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body_A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody_" title="pydrake.multibody.tree.RigidBody_"><span class="pre">pydrake.multibody.tree.RigidBody_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_AP</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody_" title="pydrake.multibody.tree.RigidBody_"><span class="pre">pydrake.multibody.tree.RigidBody_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_BQ</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stiffness</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">inf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">damping</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.0</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.MultibodyConstraintId" title="pydrake.multibody.tree.MultibodyConstraintId"><span class="pre">pydrake.multibody.tree.MultibodyConstraintId</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.AddDistanceConstraint" title="Permalink to this definition"></a></dt>
<dd><p>Defines a distance constraint between a point P on a body A and a
point Q on a body B.</p>
<p>This constraint can be compliant, modeling a spring with free length
<code class="docutils literal notranslate"><span class="pre">distance</span></code> and given <code class="docutils literal notranslate"><span class="pre">stiffness</span></code> and <code class="docutils literal notranslate"><span class="pre">damping</span></code> parameters
between points P and Q. For d = ‖p_PQ‖, then a compliant distance
constraint models a spring with force along p_PQ given by:</p>
<p>f = −stiffness ⋅ d − damping ⋅ ḋ</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body_A</span></code>:</dt><dd><p>RigidBody to which point P is rigidly attached.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_AP</span></code>:</dt><dd><p>Position of point P in body A’s frame.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body_B</span></code>:</dt><dd><p>RigidBody to which point Q is rigidly attached.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BQ</span></code>:</dt><dd><p>Position of point Q in body B’s frame.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">distance</span></code>:</dt><dd><p>Fixed length of the distance constraint, in meters. It must be
strictly positive.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">stiffness</span></code>:</dt><dd><p>For modeling a spring with free length equal to <code class="docutils literal notranslate"><span class="pre">distance</span></code>, the
stiffness parameter in N/m. Optional, with its default value being
infinite to model a rigid massless rod of length <code class="docutils literal notranslate"><span class="pre">distance</span></code>
connecting points A and B.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">damping</span></code>:</dt><dd><p>For modeling a spring with free length equal to <code class="docutils literal notranslate"><span class="pre">distance</span></code>,
damping parameter in N⋅s/m. Optional, with its default value being
zero for a non-dissipative constraint.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the id of the newly added constraint.</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Currently, it is the user’s responsibility to initialize the
model’s context in a configuration compatible with the newly added
constraint.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>A distance constraint is the wrong modeling choice if the distance
needs to go through zero. To constrain two points to be coincident
we need a 3-dof ball constraint, the 1-dof distance constraint is
singular in this case. Therefore we require the distance parameter
to be strictly positive.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if bodies A and B are the same body.</strong> – </p></li>
<li><p><strong>RuntimeError if distance is not strictly positive.</strong> – </p></li>
<li><p><strong>RuntimeError if stiffness is not positive</strong><strong> or </strong><strong>zero.</strong> – </p></li>
<li><p><strong>RuntimeError if damping is not positive</strong><strong> or </strong><strong>zero.</strong> – </p></li>
<li><p><strong>RuntimeError if the MultibodyPlant has already been finalized.</strong> – </p></li>
<li><p><strong>RuntimeError if this MultibodyPlant is not a discrete model</strong> – </p></li>
<li><p><strong>(</strong><strong>is_discrete</strong><strong>(</strong><strong>) </strong><strong>== false</strong><strong>)</strong> – </p></li>
<li><p><strong>RuntimeError if this MultibodyPlant's underlying contact</strong> – </p></li>
<li><p><strong>solver is not SAP.</strong><strong> (</strong><strong>i.e. get_discrete_contact_solver</strong><strong>(</strong><strong>) </strong><strong>!=</strong> – </p></li>
<li><p><strong>DiscreteContactSolver::kSap</strong><strong>)</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.AddForceElement">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].AddForceElement"></span><span class="sig-name descname"><span class="pre">AddForceElement</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">force_element</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ForceElement_" title="pydrake.multibody.tree.ForceElement_"><span class="pre">pydrake.multibody.tree.ForceElement_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ForceElement_" title="pydrake.multibody.tree.ForceElement_"><span class="pre">pydrake.multibody.tree.ForceElement_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.AddForceElement" title="Permalink to this definition"></a></dt>
<dd><p>Adds a new force element model of type <code class="docutils literal notranslate"><span class="pre">ForceElementType</span></code> to
<code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant. The arguments to this method <code class="docutils literal notranslate"><span class="pre">args</span></code> are
forwarded to <a href="#id53"><span class="problematic" id="id54">``</span></a>ForceElementType`’s constructor.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">args</span></code>:</dt><dd><p>Zero or more parameters provided to the constructor of the new
force element. It must be the case that
<cite>ForceElementType&lt;T&gt;(args)`</cite> is a valid constructor.</p>
</dd>
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">ForceElementType</span></code>:</dt><dd><p>The type of the ForceElement to add. As there is always a
UniformGravityFieldElement present (accessible through
gravity_field()), an exception will be thrown if this function is
called to add another UniformGravityFieldElement.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A constant reference to the new ForceElement just added, of type
<code class="docutils literal notranslate"><span class="pre">ForceElementType&lt;T&gt;</span></code> specialized on the scalar type T of
<code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant. It will remain valid for the lifetime of
<code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>The ForceElement class’s documentation for further details on how
a force element is defined.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.AddFrame">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].AddFrame"></span><span class="sig-name descname"><span class="pre">AddFrame</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame_" title="pydrake.multibody.tree.Frame_"><span class="pre">pydrake.multibody.tree.Frame_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame_" title="pydrake.multibody.tree.Frame_"><span class="pre">pydrake.multibody.tree.Frame_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.AddFrame" title="Permalink to this definition"></a></dt>
<dd><p>This method adds a Frame of type <code class="docutils literal notranslate"><span class="pre">FrameType&lt;T&gt;</span></code>. For more
information, please see the corresponding constructor of
<code class="docutils literal notranslate"><span class="pre">FrameType</span></code>.</p>
<dl class="simple">
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">FrameType</span></code>:</dt><dd><p>Template which will be instantiated on <code class="docutils literal notranslate"><span class="pre">T</span></code>.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame</span></code>:</dt><dd><p>Unique pointer frame instance.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A constant reference to the new Frame just added, which will
remain valid for the lifetime of <code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.AddJoint">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].AddJoint"></span><span class="sig-name descname"><span class="pre">AddJoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">joint</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Joint_" title="pydrake.multibody.tree.Joint_"><span class="pre">pydrake.multibody.tree.Joint_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Joint_" title="pydrake.multibody.tree.Joint_"><span class="pre">pydrake.multibody.tree.Joint_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.AddJoint" title="Permalink to this definition"></a></dt>
<dd><p>This method adds a Joint of type <code class="docutils literal notranslate"><span class="pre">JointType</span></code> between two bodies. For
more information, see the below overload of <code class="docutils literal notranslate"><span class="pre">AddJoint&lt;&gt;</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.AddJointActuator">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].AddJointActuator"></span><span class="sig-name descname"><span class="pre">AddJointActuator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">joint</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Joint_" title="pydrake.multibody.tree.Joint_"><span class="pre">pydrake.multibody.tree.Joint_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">effort_limit</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">inf</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JointActuator_" title="pydrake.multibody.tree.JointActuator_"><span class="pre">pydrake.multibody.tree.JointActuator_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.AddJointActuator" title="Permalink to this definition"></a></dt>
<dd><p>Creates and adds a JointActuator model for an actuator acting on a
given <code class="docutils literal notranslate"><span class="pre">joint</span></code>. This method returns a constant reference to the
actuator just added, which will remain valid for the lifetime of
<code class="docutils literal notranslate"><span class="pre">this</span></code> plant.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">name</span></code>:</dt><dd><p>A string that uniquely identifies the new actuator to be added to
<code class="docutils literal notranslate"><span class="pre">this</span></code> model. A RuntimeError is thrown if an actuator with the
same name already exists in the model. See
HasJointActuatorNamed().</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">joint</span></code>:</dt><dd><p>The Joint to be actuated by the new JointActuator.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">effort_limit</span></code>:</dt><dd><p>The maximum effort for the actuator. It must be strictly positive,
otherwise an RuntimeError is thrown. If +∞, the actuator has no
limit, which is the default. The effort limit has physical units
in accordance to the joint type it actuates. For instance, it will
have units of N⋅m (torque) for revolute joints while it will have
units of N (force) for prismatic joints.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The effort limit is unused by MultibodyPlant and is simply
provided here for bookkeeping purposes. It will not, for instance,
saturate external actuation inputs based on this value. If, for
example, a user intends to saturate the force/torque that is
applied to the MultibodyPlant via this actuator, the user-level
code (e.g., a controller) should query this effort limit and
impose the saturation there.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A constant reference to the new JointActuator just added, which
will remain valid for the lifetime of <code class="docutils literal notranslate"><span class="pre">this</span></code> plant or until the
JointActuator has been removed from the plant with
RemoveJointActuator().</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>RuntimeError if joint.num_velocities</strong><strong>(</strong><strong>) </strong><strong>&gt; 1 since for now we</strong> – </p></li>
<li><p><strong>only support actuators for single dof joints.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>RemoveJointActuator()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.AddModelInstance">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].AddModelInstance"></span><span class="sig-name descname"><span class="pre">AddModelInstance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.AddModelInstance" title="Permalink to this definition"></a></dt>
<dd><p>Creates a new model instance. Returns the index for the model
instance.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">name</span></code>:</dt><dd><p>A string that uniquely identifies the new instance to be added to
<code class="docutils literal notranslate"><span class="pre">this</span></code> model. An exception is thrown if an instance with the
same name already exists in the model. See
HasModelInstanceNamed().</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.AddPhysicalModel">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].AddPhysicalModel"></span><span class="sig-name descname"><span class="pre">AddPhysicalModel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">self:</span> <span class="pre">pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd],</span> <span class="pre">model:</span> <span class="pre">drake::multibody::PhysicalModel&lt;Eigen::AutoDiffScalar&lt;Eigen::Matrix&lt;double,</span> <span class="pre">-1,</span> <span class="pre">1,</span> <span class="pre">0,</span> <span class="pre">-1,</span> <span class="pre">1&gt;</span> <span class="pre">&gt;</span> <span class="pre">&gt;</span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.AddPhysicalModel" title="Permalink to this definition"></a></dt>
<dd><p>For use only by advanced developers wanting to try out their new
physical models.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This feature is considered to be <strong>experimental</strong> and may change
or be removed at any time, without any deprecation notice ahead of
time.</p>
</div>
<p>With this method MultibodyPlant takes ownership of <code class="docutils literal notranslate"><span class="pre">model</span></code> and calls
its DeclareSystemResources() method at Finalize(), giving specific
physical model implementations a chance to declare the system
resources it needs. Each type of PhysicalModel can be added at most
once.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">model</span></code>:</dt><dd><p>After this call the model is owned by <code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant.</p>
</dd>
<dt>Precondition:</dt><dd><p>model != nullptr.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if called post-finalize. See Finalize</strong><strong>(</strong><strong>)</strong><strong></strong> – </p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant will no longer support scalar conversion
to or from symbolic::Expression after a call to this method.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.AddRigidBody">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].AddRigidBody"></span><span class="sig-name descname"><span class="pre">AddRigidBody</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.AddRigidBody" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>AddRigidBody(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], name: str, M_BBo_B: pydrake.multibody.tree.SpatialInertia = &lt;pydrake.multibody.tree.SpatialInertia object at 0x7f1440048b30&gt;) -&gt; pydrake.multibody.tree.RigidBody_[AutoDiffXd]</p></li>
</ol>
<p>Creates a rigid body with the provided name and spatial inertia. This
method returns a constant reference to the body just added, which will
remain valid for the lifetime of <code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant. The body
will use the default model instance (model_instance “more on model
instances”).</p>
<p>Example of usage:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">plant</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="c1">// ... Code to define spatial_inertia, a SpatialInertia&lt;T&gt; object ...</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">RigidBody</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">body</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">    </span><span class="n">plant</span><span class="p">.</span><span class="n">AddRigidBody</span><span class="p">(</span><span class="s">&quot;BodyName&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">spatial_inertia</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</details><dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">name</span></code>:</dt><dd><p>A string that identifies the new body to be added to <code class="docutils literal notranslate"><span class="pre">this</span></code>
model. A RuntimeError is thrown if a body named <code class="docutils literal notranslate"><span class="pre">name</span></code> already
is part of the model in the default model instance. See
HasBodyNamed(), RigidBody::name().</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">M_BBo_B</span></code>:</dt><dd><p>The SpatialInertia of the new rigid body to be added to <code class="docutils literal notranslate"><span class="pre">this</span></code>
MultibodyPlant, computed about the body frame origin <code class="docutils literal notranslate"><span class="pre">Bo</span></code> and
expressed in the body frame B. When not provided, defaults to
zero.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A constant reference to the new RigidBody just added, which will
remain valid for the lifetime of <code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>RuntimeError if additional model instances have been created</strong> – </p></li>
<li><p><strong>beyond the world and default instances.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>AddRigidBody(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex, M_BBo_B: pydrake.multibody.tree.SpatialInertia = &lt;pydrake.multibody.tree.SpatialInertia object at 0x7f14400676f0&gt;) -&gt; pydrake.multibody.tree.RigidBody_[AutoDiffXd]</p></li>
</ol>
<p>Creates a rigid body with the provided name and spatial inertia. This
method returns a constant reference to the body just added, which will
remain valid for the lifetime of <code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant.</p>
<p>Example of usage:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">plant</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="c1">// ... Code to define spatial_inertia, a SpatialInertia&lt;T&gt; object ...</span>
<span class="w">  </span><span class="n">ModelInstanceIndex</span><span class="w"> </span><span class="n">model_instance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">plant</span><span class="p">.</span><span class="n">AddModelInstance</span><span class="p">(</span><span class="s">&quot;instance&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">RigidBody</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">body</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">    </span><span class="n">plant</span><span class="p">.</span><span class="n">AddRigidBody</span><span class="p">(</span><span class="s">&quot;BodyName&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">model_instance</span><span class="p">,</span><span class="w"> </span><span class="n">spatial_inertia</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</details><dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">name</span></code>:</dt><dd><p>A string that identifies the new body to be added to <code class="docutils literal notranslate"><span class="pre">this</span></code>
model. A RuntimeError is thrown if a body named <code class="docutils literal notranslate"><span class="pre">name</span></code> already
is part of <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>. See HasBodyNamed(),
RigidBody::name().</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>:</dt><dd><p>A model instance index which this body is part of.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">M_BBo_B</span></code>:</dt><dd><p>The SpatialInertia of the new rigid body to be added to <code class="docutils literal notranslate"><span class="pre">this</span></code>
MultibodyPlant, computed about the body frame origin <code class="docutils literal notranslate"><span class="pre">Bo</span></code> and
expressed in the body frame B. When not provided, defaults to
zero.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A constant reference to the new RigidBody just added, which will
remain valid for the lifetime of <code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.AddWeldConstraint">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].AddWeldConstraint"></span><span class="sig-name descname"><span class="pre">AddWeldConstraint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body_A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody_" title="pydrake.multibody.tree.RigidBody_"><span class="pre">pydrake.multibody.tree.RigidBody_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X_AP</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.math.html#pydrake.math.RigidTransform" title="pydrake.math.RigidTransform"><span class="pre">pydrake.math.RigidTransform</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">body_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody_" title="pydrake.multibody.tree.RigidBody_"><span class="pre">pydrake.multibody.tree.RigidBody_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X_BQ</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.math.html#pydrake.math.RigidTransform" title="pydrake.math.RigidTransform"><span class="pre">pydrake.math.RigidTransform</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.MultibodyConstraintId" title="pydrake.multibody.tree.MultibodyConstraintId"><span class="pre">pydrake.multibody.tree.MultibodyConstraintId</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.AddWeldConstraint" title="Permalink to this definition"></a></dt>
<dd><p>Defines a constraint such that frame P affixed to body A is coincident
at all times with frame Q affixed to body B, effectively modeling a
weld joint.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body_A</span></code>:</dt><dd><p>RigidBody to which frame P is rigidly attached.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">X_AP</span></code>:</dt><dd><p>Pose of frame P in body A’s frame.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body_B</span></code>:</dt><dd><p>RigidBody to which frame Q is rigidly attached.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">X_BQ</span></code>:</dt><dd><p>Pose of frame Q in body B’s frame.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the id of the newly added constraint.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>RuntimeError if bodies A and B are the same body.</strong> – </p></li>
<li><p><strong>RuntimeError if the MultibodyPlant has already been finalized.</strong> – </p></li>
<li><p><strong>RuntimeError if this MultibodyPlant is not a discrete model</strong> – </p></li>
<li><p><strong>(</strong><strong>is_discrete</strong><strong>(</strong><strong>) </strong><strong>== false</strong><strong>)</strong> – </p></li>
<li><p><strong>RuntimeError if this MultibodyPlant's underlying contact</strong> – </p></li>
<li><p><strong>solver is not SAP.</strong><strong> (</strong><strong>i.e. get_discrete_contact_solver</strong><strong>(</strong><strong>) </strong><strong>!=</strong> – </p></li>
<li><p><strong>DiscreteContactSolver::kSap</strong><strong>)</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcBiasCenterOfMassTranslationalAcceleration">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].CalcBiasCenterOfMassTranslationalAcceleration"></span><span class="sig-name descname"><span class="pre">CalcBiasCenterOfMassTranslationalAcceleration</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_respect_to</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JacobianWrtVariable" title="pydrake.multibody.tree.JacobianWrtVariable"><span class="pre">pydrake.multibody.tree.JacobianWrtVariable</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame_" title="pydrake.multibody.tree.Frame_"><span class="pre">pydrake.multibody.tree.Frame_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_E</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame_" title="pydrake.multibody.tree.Frame_"><span class="pre">pydrake.multibody.tree.Frame_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcBiasCenterOfMassTranslationalAcceleration" title="Permalink to this definition"></a></dt>
<dd><p>Calculates abias_ACcm_E, point Ccm’s translational “bias” acceleration
term in frame A with respect to “speeds” 𝑠, expressed in frame E,
where point Ccm is the composite center of mass of the system of all
bodies (except world_body()) in the MultibodyPlant. abias_ACcm is the
part of a_ACcm (Ccm’s translational acceleration) that does not
multiply ṡ, equal to abias_ACcm = J̇𝑠_v_ACcm ⋅ s. This allows a_ACcm
to be written as a_ACcm = J𝑠_v_ACcm ⋅ ṡ + abias_ACcm.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The state of the multibody system.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">with_respect_to</span></code>:</dt><dd><p>Enum equal to JacobianWrtVariable::kQDot or
JacobianWrtVariable::kV, indicating whether the Jacobian
<code class="docutils literal notranslate"><span class="pre">abias_ACcm</span></code> is partial derivatives with respect to 𝑠 = q̇
(time-derivatives of generalized positions) or with respect to 𝑠 =
v (generalized velocities).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_A</span></code>:</dt><dd><p>The frame in which abias_ACcm is measured.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_E</span></code>:</dt><dd><p>The frame in which abias_ACcm is expressed on output.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">abias_ACcm_E</span></code>:</dt><dd><p>Point Ccm’s translational “bias” acceleration term in frame A with
respect to “speeds” 𝑠, expressed in frame E.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if Ccm does not exist</strong><strong>, </strong><strong>which occurs if there are no</strong> – </p></li>
<li><p><strong>massive bodies in MultibodyPlant</strong><strong> (</strong><strong>except world_body</strong><strong>(</strong><strong>)</strong><strong>)</strong><strong></strong> – </p></li>
<li><p><strong>RuntimeError if composite_mass &lt;= 0</strong><strong>, </strong><strong>where composite_mass is the</strong> – </p></li>
<li><p><strong>total mass of all bodies except world_body</strong><strong>(</strong><strong>) </strong><strong>in MultibodyPlant.</strong> – </p></li>
<li><p><strong>RuntimeError if frame_A is not the world frame.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcBiasSpatialAcceleration">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].CalcBiasSpatialAcceleration"></span><span class="sig-name descname"><span class="pre">CalcBiasSpatialAcceleration</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_respect_to</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JacobianWrtVariable" title="pydrake.multibody.tree.JacobianWrtVariable"><span class="pre">pydrake.multibody.tree.JacobianWrtVariable</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame_" title="pydrake.multibody.tree.Frame_"><span class="pre">pydrake.multibody.tree.Frame_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_BoBp_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame_" title="pydrake.multibody.tree.Frame_"><span class="pre">pydrake.multibody.tree.Frame_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_E</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame_" title="pydrake.multibody.tree.Frame_"><span class="pre">pydrake.multibody.tree.Frame_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.math.html#pydrake.multibody.math.SpatialAcceleration_" title="pydrake.multibody.math.SpatialAcceleration_"><span class="pre">pydrake.multibody.math.SpatialAcceleration_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcBiasSpatialAcceleration" title="Permalink to this definition"></a></dt>
<dd><p>For one point Bp affixed/welded to a frame B, calculates A𝑠Bias_ABp,
Bp’s spatial acceleration bias in frame A with respect to “speeds” 𝑠,
where 𝑠 is either q̇ (time-derivatives of generalized positions) or v
(generalized velocities). A𝑠Bias_ABp is the term in A_ABp (Bp’s
spatial acceleration in A) that does not include 𝑠̇, i.e., A𝑠Bias_ABp
is Bi’s translational acceleration in A when 𝑠̇ = 0.</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>A_ABp =  J𝑠_V_ABp ⋅ 𝑠̇  +  J̇𝑠_V_ABp ⋅ 𝑠   (𝑠 = q̇ or 𝑠 = v), hence
  A𝑠Bias_ABp = J̇𝑠_V_ABp ⋅ 𝑠
</pre></div>
</div>
</details><p>where J𝑠_V_ABp is Bp’s spatial velocity Jacobian in frame A for speeds
s (see CalcJacobianSpatialVelocity() for details on J𝑠_V_ABp).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The state of the multibody system.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">with_respect_to</span></code>:</dt><dd><p>Enum equal to JacobianWrtVariable::kQDot or
JacobianWrtVariable::kV, indicating whether the spatial
accceleration bias is with respect to 𝑠 = q̇ or 𝑠 = v.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_B</span></code>:</dt><dd><p>The frame on which point Bp is affixed/welded.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BoBp_B</span></code>:</dt><dd><p>Position vector from Bo (frame_B’s origin) to point Bp (regarded
as affixed/welded to B), expressed in frame_B.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_A</span></code>:</dt><dd><p>The frame that measures A𝑠Bias_ABp. Currently, an exception is
thrown if frame_A is not the World frame.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_E</span></code>:</dt><dd><p>The frame in which A𝑠Bias_ABp is expressed on output.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A𝑠Bias_ABp_E Point Bp’s spatial acceleration bias in frame A with
respect to speeds 𝑠 (𝑠 = q̇ or 𝑠 = v), expressed in frame E.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Shown below, A𝑠Bias_ABp_E = J̇𝑠_V_ABp ⋅ 𝑠 is quadratic in 𝑠.</p>
</div>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>V_ABp =  J𝑠_V_ABp ⋅ 𝑠        which upon vector differentiation in A gives
 A_ABp =  J𝑠_V_ABp ⋅ 𝑠̇  +  J̇𝑠_V_ABp ⋅ 𝑠   Since J̇𝑠_V_ABp is linear in 𝑠,
 A𝑠Bias_ABp = J̇𝑠_V_ABp ⋅ 𝑠                             is quadratic in 𝑠.
</pre></div>
</div>
</details><div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcJacobianSpatialVelocity() to compute J𝑠_V_ABp, point Bp’s
translational velocity Jacobian in frame A with respect to 𝑠.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if with_respect_to is not JacobianWrtVariable::kV</strong> – </p></li>
<li><p><strong>RuntimeError if frame_A is not the world frame.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcBiasTerm">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].CalcBiasTerm"></span><span class="sig-name descname"><span class="pre">CalcBiasTerm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcBiasTerm" title="Permalink to this definition"></a></dt>
<dd><p>Computes the bias term <code class="docutils literal notranslate"><span class="pre">C(q,</span> <span class="pre">v)v</span></code> containing Coriolis, centripetal,
and gyroscopic effects in the multibody equations of motion:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>M(q) v̇ + C(q, v) v = tau_app + ∑ (Jv_V_WBᵀ(q) ⋅ Fapp_Bo_W)
</pre></div>
</div>
</details><p>where <code class="docutils literal notranslate"><span class="pre">M(q)</span></code> is the multibody model’s mass matrix (including rigid
body mass properties and reflected_inertia “reflected inertias”) and
<code class="docutils literal notranslate"><span class="pre">tau_app</span></code> is a vector of applied generalized forces. The last term
is a summation over all bodies of the dot-product of <code class="docutils literal notranslate"><span class="pre">Fapp_Bo_W</span></code>
(applied spatial force on body B at Bo) with <code class="docutils literal notranslate"><span class="pre">Jv_V_WB(q)</span></code> (B’s
spatial Jacobian in world W with respect to generalized velocities v).
Note: B’s spatial velocity in W can be written <code class="docutils literal notranslate"><span class="pre">V_WB</span> <span class="pre">=</span> <span class="pre">Jv_V_WB</span> <span class="pre">*</span> <span class="pre">v</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context containing the state of the model. It stores the
generalized positions q and the generalized velocities v.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">Cv</span></code>:</dt><dd><p>On output, <code class="docutils literal notranslate"><span class="pre">Cv</span></code> will contain the product <code class="docutils literal notranslate"><span class="pre">C(q,</span> <span class="pre">v)v</span></code>. It must
be a valid (non-null) pointer to a column vector in <code class="docutils literal notranslate"><span class="pre">ℛⁿ</span></code> with n
the number of generalized velocities (num_velocities()) of the
model. This method aborts if Cv is nullptr or if it does not have
the proper size.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcBiasTranslationalAcceleration">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].CalcBiasTranslationalAcceleration"></span><span class="sig-name descname"><span class="pre">CalcBiasTranslationalAcceleration</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_respect_to</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JacobianWrtVariable" title="pydrake.multibody.tree.JacobianWrtVariable"><span class="pre">pydrake.multibody.tree.JacobianWrtVariable</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame_" title="pydrake.multibody.tree.Frame_"><span class="pre">pydrake.multibody.tree.Frame_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_BoBi_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.f_contiguous</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame_" title="pydrake.multibody.tree.Frame_"><span class="pre">pydrake.multibody.tree.Frame_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_E</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame_" title="pydrake.multibody.tree.Frame_"><span class="pre">pydrake.multibody.tree.Frame_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcBiasTranslationalAcceleration" title="Permalink to this definition"></a></dt>
<dd><p>For each point Bi affixed/welded to a frame B, calculates a𝑠Bias_ABi,
Bi’s translational acceleration bias in frame A with respect to
“speeds” 𝑠, where 𝑠 is either q̇ (time-derivatives of generalized
positions) or v (generalized velocities). a𝑠Bias_ABi is the term in
a_ABi (Bi’s translational acceleration in A) that does not include 𝑠̇,
i.e., a𝑠Bias_ABi is Bi’s translational acceleration in A when 𝑠̇ = 0.</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>a_ABi =  J𝑠_v_ABi ⋅ 𝑠̇  +  J̇𝑠_v_ABi ⋅ 𝑠  (𝑠 = q̇ or 𝑠 = v), hence
  a𝑠Bias_ABi = J̇𝑠_v_ABi ⋅ 𝑠
</pre></div>
</div>
</details><p>where J𝑠_v_ABi is Bi’s translational velocity Jacobian in frame A for
s (see CalcJacobianTranslationalVelocity() for details on J𝑠_v_ABi).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The state of the multibody system.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">with_respect_to</span></code>:</dt><dd><p>Enum equal to JacobianWrtVariable::kQDot or
JacobianWrtVariable::kV, indicating whether the translational
acceleration bias is with respect to 𝑠 = q̇ or 𝑠 = v.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_B</span></code>:</dt><dd><p>The frame on which points Bi are affixed/welded.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BoBi_B</span></code>:</dt><dd><p>A position vector or list of p position vectors from Bo (frame_B’s
origin) to points Bi (regarded as affixed to B), where each
position vector is expressed in frame_B. Each column in the <code class="docutils literal notranslate"><span class="pre">3</span> <span class="pre">x</span>
<span class="pre">p</span></code> matrix p_BoBi_B corresponds to a position vector.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_A</span></code>:</dt><dd><p>The frame that measures a𝑠Bias_ABi. Currently, an exception is
thrown if frame_A is not the World frame.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_E</span></code>:</dt><dd><p>The frame in which a𝑠Bias_ABi is expressed on output.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a𝑠Bias_ABi_E Point Bi’s translational acceleration bias in frame A
with respect to speeds 𝑠 (𝑠 = q̇ or 𝑠 = v), expressed in frame E.
a𝑠Bias_ABi_E is a <code class="docutils literal notranslate"><span class="pre">3</span> <span class="pre">x</span> <span class="pre">p</span></code> matrix, where p is the number of
points Bi.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Shown below, a𝑠Bias_ABi_E = J̇𝑠_v_ABp ⋅ 𝑠 is quadratic in 𝑠.</p>
</div>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>v_ABi =  J𝑠_v_ABi ⋅ 𝑠        which upon vector differentiation in A gives
 a_ABi =  J𝑠_v_ABi ⋅ 𝑠̇ + J̇𝑠_v_ABi ⋅ 𝑠     Since J̇𝑠_v_ABi is linear in 𝑠,
 a𝑠Bias_ABi = J̇𝑠_v_ABi ⋅ 𝑠                             is quadratic in 𝑠.
</pre></div>
</div>
</details><div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcJacobianTranslationalVelocity() to compute J𝑠_v_ABi, point
Bi’s translational velocity Jacobian in frame A with respect to 𝑠.</p>
</div>
<dl class="simple">
<dt>Precondition:</dt><dd><p>p_BoBi_B must have 3 rows.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if with_respect_to is not JacobianWrtVariable::kV</strong> – </p></li>
<li><p><strong>RuntimeError if frame_A is not the world frame.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcCenterOfMassPositionInWorld">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].CalcCenterOfMassPositionInWorld"></span><span class="sig-name descname"><span class="pre">CalcCenterOfMassPositionInWorld</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcCenterOfMassPositionInWorld" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>CalcCenterOfMassPositionInWorld(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd]) -&gt; numpy.ndarray[object[3, 1]]</p></li>
</ol>
<p>Calculates the position vector from the world origin Wo to the center
of mass of all bodies in this MultibodyPlant, expressed in the world
frame W.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>Contains the state of the model.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">p_WoScm_W</span></code>:</dt><dd><p>position vector from Wo to Scm expressed in world frame W, where
Scm is the center of mass of the system S stored by <code class="docutils literal notranslate"><span class="pre">this</span></code>
plant.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if this has no body except world_body</strong><strong>(</strong><strong>)</strong><strong></strong> – </p></li>
<li><p><strong>RuntimeError if mₛ ≤ 0</strong><strong> (</strong><strong>where mₛ is the mass of system S</strong><strong>)</strong><strong></strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The world_body() is ignored. p_WoScm_W = ∑ (mᵢ pᵢ) / mₛ, where mₛ
= ∑ mᵢ, mᵢ is the mass of the iᵗʰ body, and pᵢ is Bcm’s position
vector from Wo expressed in frame W (Bcm is the center of mass of
the iᵗʰ body).</p>
</div>
<ol class="arabic simple" start="2">
<li><p>CalcCenterOfMassPositionInWorld(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], model_instances: List[pydrake.multibody.tree.ModelInstanceIndex]) -&gt; numpy.ndarray[object[3, 1]]</p></li>
</ol>
<p>Calculates the position vector from the world origin Wo to the center
of mass of all non-world bodies contained in model_instances,
expressed in the world frame W.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>Contains the state of the model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">model_instances</span></code>:</dt><dd><p>Vector of selected model instances. If a model instance is
repeated in the vector (unusual), it is only counted once.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">p_WoScm_W</span></code>:</dt><dd><p>position vector from world origin Wo to Scm expressed in the world
frame W, where Scm is the center of mass of the system S of
non-world bodies contained in model_instances.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if model_instances is empty</strong><strong> or </strong><strong>only has world body.</strong> – </p></li>
<li><p><strong>RuntimeError if mₛ ≤ 0</strong><strong> (</strong><strong>where mₛ is the mass of system S</strong><strong>)</strong><strong></strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The world_body() is ignored. p_WoScm_W = ∑ (mᵢ pᵢ) / mₛ, where mₛ
= ∑ mᵢ, mᵢ is the mass of the iᵗʰ body contained in
model_instances, and pᵢ is Bcm’s position vector from Wo expressed
in frame W (Bcm is the center of mass of the iᵗʰ body).</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcForceElementsContribution">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].CalcForceElementsContribution"></span><span class="sig-name descname"><span class="pre">CalcForceElementsContribution</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">forces</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.MultibodyForces_" title="pydrake.multibody.tree.MultibodyForces_"><span class="pre">pydrake.multibody.tree.MultibodyForces_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcForceElementsContribution" title="Permalink to this definition"></a></dt>
<dd><p>Computes the combined force contribution of ForceElement objects in
the model. A ForceElement can apply forces as a spatial force per body
or as generalized forces, depending on the ForceElement model.
ForceElement contributions are a function of the state and time only.
The output from this method can immediately be used as input to
CalcInverseDynamics() to include the effect of applied forces by force
elements.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context containing the state of this model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">forces</span></code>:</dt><dd><p>A pointer to a valid, non nullptr, multibody forces object. On
output <code class="docutils literal notranslate"><span class="pre">forces</span></code> will store the forces exerted by all the
ForceElement objects in the model.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if forces is null</strong><strong> or </strong><strong>not compatible with this</strong> – </p></li>
<li><p><strong>model</strong><strong>, </strong><strong>per MultibodyForces::CheckInvariants</strong><strong>(</strong><strong>)</strong><strong></strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcGeneralizedForces">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].CalcGeneralizedForces"></span><span class="sig-name descname"><span class="pre">CalcGeneralizedForces</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">forces</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.MultibodyForces_" title="pydrake.multibody.tree.MultibodyForces_"><span class="pre">pydrake.multibody.tree.MultibodyForces_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcGeneralizedForces" title="Permalink to this definition"></a></dt>
<dd><p>Computes the generalized forces result of a set of MultibodyForces
applied to this model.</p>
<p>MultibodyForces stores applied forces as both generalized forces τ and
spatial forces F on each body, refer to documentation in
MultibodyForces for details. Users of MultibodyForces will use
MultibodyForces::mutable_generalized_forces() to mutate the stored
generalized forces directly and will use
RigidBody::AddInForceInWorld() to append spatial forces.</p>
<p>For a given set of forces stored as MultibodyForces, this method will
compute the total generalized forces on this model. More precisely, if
J_WBo is the Jacobian (with respect to velocities) for this model,
including all bodies, then this method computes:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>τᵣₑₛᵤₗₜ = τ + J_WBo⋅F
</pre></div>
</div>
</details><dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>Context that stores the state of the model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">forces</span></code>:</dt><dd><p>Set of multibody forces, including both generalized forces and
per-body spatial forces.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">generalized_forces</span></code>:</dt><dd><p>The total generalized forces on the model that would result from
applying <code class="docutils literal notranslate"><span class="pre">forces</span></code>. In other words, <code class="docutils literal notranslate"><span class="pre">forces</span></code> can be replaced by
the equivalent <code class="docutils literal notranslate"><span class="pre">generalized_forces</span></code>. On output,
<code class="docutils literal notranslate"><span class="pre">generalized_forces</span></code> is resized to num_velocities().</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if forces is null</strong><strong> or </strong><strong>not compatible with this</strong> – </p></li>
<li><p><strong>model.</strong> – </p></li>
<li><p><strong>RuntimeError if generalized_forces is not a valid non-null</strong> – </p></li>
<li><p><strong>pointer.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcGravityGeneralizedForces">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].CalcGravityGeneralizedForces"></span><span class="sig-name descname"><span class="pre">CalcGravityGeneralizedForces</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcGravityGeneralizedForces" title="Permalink to this definition"></a></dt>
<dd><p>Computes the generalized forces <code class="docutils literal notranslate"><span class="pre">tau_g(q)</span></code> due to gravity as a
function of the generalized positions <code class="docutils literal notranslate"><span class="pre">q</span></code> stored in the input
<code class="docutils literal notranslate"><span class="pre">context</span></code>. The vector of generalized forces due to gravity
<code class="docutils literal notranslate"><span class="pre">tau_g(q)</span></code> is defined such that it appears on the right hand side of
the equations of motion together with any other generalized forces,
like so:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>Mv̇ + C(q, v)v = tau_g(q) + tau_app
</pre></div>
</div>
</details><p>where <code class="docutils literal notranslate"><span class="pre">tau_app</span></code> includes any other generalized forces applied on the
system.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context storing the state of the model.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>tau_g A vector containing the generalized forces due to gravity.
The generalized forces are consistent with the vector of
generalized velocities <code class="docutils literal notranslate"><span class="pre">v</span></code> for <code class="docutils literal notranslate"><span class="pre">this</span></code> so that the inner
product <code class="docutils literal notranslate"><span class="pre">v⋅tau_g</span></code> corresponds to the power applied by the
gravity forces on the mechanical system. That is, <code class="docutils literal notranslate"><span class="pre">v⋅tau_g</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>
corresponds to potential energy going into the system, as either
mechanical kinetic energy, some other potential energy, or heat,
and therefore to a decrease of the gravitational potential energy.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcInverseDynamics">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].CalcInverseDynamics"></span><span class="sig-name descname"><span class="pre">CalcInverseDynamics</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">known_vdot</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">external_forces</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.MultibodyForces_" title="pydrake.multibody.tree.MultibodyForces_"><span class="pre">pydrake.multibody.tree.MultibodyForces_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcInverseDynamics" title="Permalink to this definition"></a></dt>
<dd><p>Given the state of this model in <code class="docutils literal notranslate"><span class="pre">context</span></code> and a known vector of
generalized accelerations <code class="docutils literal notranslate"><span class="pre">vdot</span></code>, this method computes the set of
generalized forces <code class="docutils literal notranslate"><span class="pre">tau</span></code> that would need to be applied in order to
attain the specified generalized accelerations. Mathematically, this
method computes:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>tau = M(q)v̇ + C(q, v)v - tau_app - ∑ J_WBᵀ(q) Fapp_Bo_W
</pre></div>
</div>
</details><p>where <code class="docutils literal notranslate"><span class="pre">M(q)</span></code> is the model’s mass matrix (including rigid body mass
properties and reflected_inertia “reflected inertias”), <code class="docutils literal notranslate"><span class="pre">C(q,</span> <span class="pre">v)v</span></code>
is the bias term for Coriolis and gyroscopic effects and <code class="docutils literal notranslate"><span class="pre">tau_app</span></code>
consists of a vector applied generalized forces. The last term is a
summation over all bodies in the model where <code class="docutils literal notranslate"><span class="pre">Fapp_Bo_W</span></code> is an
applied spatial force on body B at <code class="docutils literal notranslate"><span class="pre">Bo</span></code> which gets projected into
the space of generalized forces with the transpose of <code class="docutils literal notranslate"><span class="pre">Jv_V_WB(q)</span></code>
(where <code class="docutils literal notranslate"><span class="pre">Jv_V_WB</span></code> is B’s spatial velocity Jacobian in W with respect
to generalized velocities v). Note: B’s spatial velocity in W can be
written as <code class="docutils literal notranslate"><span class="pre">V_WB</span> <span class="pre">=</span> <span class="pre">Jv_V_WB</span> <span class="pre">*</span> <span class="pre">v</span></code>.</p>
<p>This method does not compute explicit expressions for the mass matrix
nor for the bias term, which would be of at least <code class="docutils literal notranslate"><span class="pre">O(n²)</span></code>
complexity, but it implements an <code class="docutils literal notranslate"><span class="pre">O(n)</span></code> Newton-Euler recursive
algorithm, where n is the number of bodies in the model. The explicit
formation of the mass matrix <code class="docutils literal notranslate"><span class="pre">M(q)</span></code> would require the calculation of
<code class="docutils literal notranslate"><span class="pre">O(n²)</span></code> entries while explicitly forming the product <code class="docutils literal notranslate"><span class="pre">C(q,</span> <span class="pre">v)</span> <span class="pre">*</span> <span class="pre">v</span></code>
could require up to <code class="docutils literal notranslate"><span class="pre">O(n³)</span></code> operations (see [Featherstone 1987,
§4]), depending on the implementation. The recursive Newton-Euler
algorithm is the most efficient currently known general method for
solving inverse dynamics [Featherstone 2008].</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context containing the state of the model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">known_vdot</span></code>:</dt><dd><p>A vector with the known generalized accelerations <code class="docutils literal notranslate"><span class="pre">vdot</span></code> for the
full model. Use the provided Joint APIs in order to access entries
into this array.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">external_forces</span></code>:</dt><dd><p>A set of forces to be applied to the system either as body spatial
forces <code class="docutils literal notranslate"><span class="pre">Fapp_Bo_W</span></code> or generalized forces <code class="docutils literal notranslate"><span class="pre">tau_app</span></code>, see
MultibodyForces for details.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the vector of generalized forces that would need to be applied to
the mechanical system in order to achieve the desired acceleration
given by <code class="docutils literal notranslate"><span class="pre">known_vdot</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcJacobianAngularVelocity">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].CalcJacobianAngularVelocity"></span><span class="sig-name descname"><span class="pre">CalcJacobianAngularVelocity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_respect_to</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JacobianWrtVariable" title="pydrake.multibody.tree.JacobianWrtVariable"><span class="pre">pydrake.multibody.tree.JacobianWrtVariable</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame_" title="pydrake.multibody.tree.Frame_"><span class="pre">pydrake.multibody.tree.Frame_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame_" title="pydrake.multibody.tree.Frame_"><span class="pre">pydrake.multibody.tree.Frame_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_E</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame_" title="pydrake.multibody.tree.Frame_"><span class="pre">pydrake.multibody.tree.Frame_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcJacobianAngularVelocity" title="Permalink to this definition"></a></dt>
<dd><p>Calculates J𝑠_w_AB, a frame B’s angular velocity Jacobian in a frame A
with respect to “speeds” 𝑠.</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>J𝑠_w_AB ≜ [ ∂(w_AB)/∂𝑠₁,  ...  ∂(w_AB)/∂𝑠ₙ ]    (n is j or k)
     w_AB = J𝑠_w_AB ⋅ 𝑠          w_AB is linear in 𝑠 ≜ [𝑠₁ ... 𝑠ₙ]ᵀ
</pre></div>
</div>
</details><p><code class="docutils literal notranslate"><span class="pre">w_AB</span></code> is B’s angular velocity in frame A and “speeds” 𝑠 is either
q̇ ≜ [q̇₁ … q̇ⱼ]ᵀ (time-derivatives of j generalized positions) or v
≜ [v₁ … vₖ]ᵀ (k generalized velocities).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The state of the multibody system.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">with_respect_to</span></code>:</dt><dd><p>Enum equal to JacobianWrtVariable::kQDot or
JacobianWrtVariable::kV, indicating whether the Jacobian
<code class="docutils literal notranslate"><span class="pre">J𝑠_w_AB</span></code> is partial derivatives with respect to 𝑠 = q̇
(time-derivatives of generalized positions) or with respect to 𝑠 =
v (generalized velocities).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_B</span></code>:</dt><dd><p>The frame B in <code class="docutils literal notranslate"><span class="pre">w_AB</span></code> (B’s angular velocity in A).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_A</span></code>:</dt><dd><p>The frame A in <code class="docutils literal notranslate"><span class="pre">w_AB</span></code> (B’s angular velocity in A).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_E</span></code>:</dt><dd><p>The frame in which <code class="docutils literal notranslate"><span class="pre">w_AB</span></code> is expressed on input and the frame in
which the Jacobian <code class="docutils literal notranslate"><span class="pre">J𝑠_w_AB</span></code> is expressed on output.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">J𝑠_w_AB_E</span></code>:</dt><dd><p>Frame B’s angular velocity Jacobian in frame A with respect to
speeds 𝑠 (which is either q̇ or v), expressed in frame E. The
Jacobian is a function of only generalized positions q (which are
pulled from the context). The previous definition shows
<code class="docutils literal notranslate"><span class="pre">J𝑠_w_AB_E</span></code> is a matrix of size <code class="docutils literal notranslate"><span class="pre">3</span> <span class="pre">x</span> <span class="pre">n</span></code>, where n is the number
of elements in 𝑠.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if J𝑠_w_AB_E is nullptr</strong><strong> or </strong><strong>not of size 3 x n.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcJacobianCenterOfMassTranslationalVelocity">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].CalcJacobianCenterOfMassTranslationalVelocity"></span><span class="sig-name descname"><span class="pre">CalcJacobianCenterOfMassTranslationalVelocity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcJacobianCenterOfMassTranslationalVelocity" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>CalcJacobianCenterOfMassTranslationalVelocity(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_A: pydrake.multibody.tree.Frame_[AutoDiffXd], frame_E: pydrake.multibody.tree.Frame_[AutoDiffXd]) -&gt; numpy.ndarray[object[3, n]]</p></li>
</ol>
<p>Calculates J𝑠_v_ACcm_E, point Ccm’s translational velocity Jacobian in
frame A with respect to “speeds” 𝑠, expressed in frame E, where point
CCm is the center of mass of the system of all non-world bodies
contained in <code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>contains the state of the model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">with_respect_to</span></code>:</dt><dd><p>Enum equal to JacobianWrtVariable::kQDot or
JacobianWrtVariable::kV, indicating whether the Jacobian
<code class="docutils literal notranslate"><span class="pre">J𝑠_v_ACcm_E</span></code> is partial derivatives with respect to 𝑠 = q̇
(time-derivatives of generalized positions) or with respect to 𝑠 =
v (generalized velocities).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_A</span></code>:</dt><dd><p>The frame in which the translational velocity v_ACcm and its
Jacobian J𝑠_v_ACcm are measured.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_E</span></code>:</dt><dd><p>The frame in which the Jacobian J𝑠_v_ACcm is expressed on output.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">J𝑠_v_ACcm_E</span></code>:</dt><dd><p>Point Ccm’s translational velocity Jacobian in frame A with
respect to speeds 𝑠 (𝑠 = q̇ or 𝑠 = v), expressed in frame E.
J𝑠_v_ACcm_E is a 3 x n matrix, where n is the number of elements
in 𝑠. The Jacobian is a function of only generalized positions q
(which are pulled from the context).</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if CCm does not exist</strong><strong>, </strong><strong>which occurs if there are no</strong> – </p></li>
<li><p><strong>massive bodies in MultibodyPlant</strong><strong> (</strong><strong>except world_body</strong><strong>(</strong><strong>)</strong><strong>)</strong><strong></strong> – </p></li>
<li><p><strong>RuntimeError if mₛ ≤ 0</strong><strong> (</strong><strong>where mₛ is the mass of all non-world</strong> – </p></li>
<li><p><strong>bodies contained in this MultibodyPlant</strong><strong>)</strong><strong></strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>CalcJacobianCenterOfMassTranslationalVelocity(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], model_instances: List[pydrake.multibody.tree.ModelInstanceIndex], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_A: pydrake.multibody.tree.Frame_[AutoDiffXd], frame_E: pydrake.multibody.tree.Frame_[AutoDiffXd]) -&gt; numpy.ndarray[object[3, n]]</p></li>
</ol>
<p>Calculates J𝑠_v_ACcm_E, point Ccm’s translational velocity Jacobian in
frame A with respect to “speeds” 𝑠, expressed in frame E, where point
CCm is the center of mass of the system of all non-world bodies
contained in model_instances.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>contains the state of the model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">model_instances</span></code>:</dt><dd><p>Vector of selected model instances. If a model instance is
repeated in the vector (unusual), it is only counted once.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">with_respect_to</span></code>:</dt><dd><p>Enum equal to JacobianWrtVariable::kQDot or
JacobianWrtVariable::kV, indicating whether the Jacobian
<code class="docutils literal notranslate"><span class="pre">J𝑠_v_ACcm_E</span></code> is partial derivatives with respect to 𝑠 = q̇
(time-derivatives of generalized positions) or with respect to 𝑠 =
v (generalized velocities).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_A</span></code>:</dt><dd><p>The frame in which the translational velocity v_ACcm and its
Jacobian J𝑠_v_ACcm are measured.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_E</span></code>:</dt><dd><p>The frame in which the Jacobian J𝑠_v_ACcm is expressed on output.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">J𝑠_v_ACcm_E</span></code>:</dt><dd><p>Point Ccm’s translational velocity Jacobian in frame A with
respect to speeds 𝑠 (𝑠 = q̇ or 𝑠 = v), expressed in frame E.
J𝑠_v_ACcm_E is a 3 x n matrix, where n is the number of elements
in 𝑠. The Jacobian is a function of only generalized positions q
(which are pulled from the context).</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if mₛ ≤ 0</strong><strong> (</strong><strong>where mₛ is the mass of all non-world</strong> – </p></li>
<li><p><strong>bodies contained in model_instances</strong><strong>)</strong><strong></strong> – </p></li>
<li><p><strong>RuntimeError if model_instances is empty</strong><strong> or </strong><strong>only has world body.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The world_body() is ignored. <a href="#id141"><span class="problematic" id="id142">J𝑠_v_ACcm_</span></a> = ∑ (mᵢ Jᵢ) / mₛ, where mₛ
= ∑ mᵢ, mᵢ is the mass of the iᵗʰ body contained in
model_instances, and Jᵢ is Bcm’s translational velocity Jacobian
in frame A, expressed in frame E (Bcm is the center of mass of the
iᵗʰ body).</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcJacobianPositionVector">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].CalcJacobianPositionVector"></span><span class="sig-name descname"><span class="pre">CalcJacobianPositionVector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame_" title="pydrake.multibody.tree.Frame_"><span class="pre">pydrake.multibody.tree.Frame_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_BoBi_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.f_contiguous</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame_" title="pydrake.multibody.tree.Frame_"><span class="pre">pydrake.multibody.tree.Frame_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_E</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame_" title="pydrake.multibody.tree.Frame_"><span class="pre">pydrake.multibody.tree.Frame_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcJacobianPositionVector" title="Permalink to this definition"></a></dt>
<dd><p>For each point Bi affixed/welded to a frame B, calculates Jq_p_AoBi,
Bi’s position vector Jacobian in frame A with respect to the
generalized positions q ≜ [q₁ … qₙ]ᵀ as</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>Jq_p_AoBi ≜ [ ᴬ∂(p_AoBi)/∂q₁,  ...  ᴬ∂(p_AoBi)/∂qₙ ]
</pre></div>
</div>
</details><p>where p_AoBi is Bi’s position vector from point Ao (frame A’s origin)
and ᴬ∂(p_AoBi)/∂qᵣ denotes the partial derivative in frame A of p_AoBi
with respect to the generalized position qᵣ, where qᵣ is one of q₁ …
qₙ.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The state of the multibody system.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_B</span></code>:</dt><dd><p>The frame on which point Bi is affixed/welded.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BoBi_B</span></code>:</dt><dd><p>A position vector or list of k position vectors from Bo (frame_B’s
origin) to points Bi (Bi is regarded as affixed to B), where each
position vector is expressed in frame_B.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_A</span></code>:</dt><dd><p>The frame in which partial derivatives are calculated and the
frame in which point Ao is affixed.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_E</span></code>:</dt><dd><p>The frame in which the Jacobian Jq_p_AoBi is expressed on output.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">Jq_p_AoBi_E</span></code>:</dt><dd><p>Point Bi’s position vector Jacobian in frame A with generalized
positions q, expressed in frame E. Jq_p_AoBi_E is a <code class="docutils literal notranslate"><span class="pre">3*k</span> <span class="pre">x</span> <span class="pre">n</span></code>
matrix, where k is the number of points Bi and n is the number of
elements in q. The Jacobian is a function of only generalized
positions q (which are pulled from the context).</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if Jq_p_AoBi_E is nullptr</strong><strong> or </strong><strong>not sized 3*k x n.</strong> – </p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Jq̇_v_ABi = Jq_p_AoBi. In other words, point Bi’s velocity
Jacobian in frame A with respect to q̇ is equal to point Bi’s
position vector Jacobian in frame A with respect to q.</p>
</div>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>[∂(v_ABi)/∂q̇₁, ... ∂(v_ABi)/∂q̇ₙ] = [ᴬ∂(p_AoBi)/∂q₁, ... ᴬ∂(p_AoBi)/∂qₙ]
</pre></div>
</div>
</details><div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcJacobianTranslationalVelocity() for details on Jq̇_v_ABi.
Note: Jq_p_AaBi = Jq_p_AoBi, where point Aa is <em>any</em> point
fixed/welded to frame A, i.e., this calculation’s result is the
same if point Ao is replaced with any point fixed on frame A.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcJacobianSpatialVelocity">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].CalcJacobianSpatialVelocity"></span><span class="sig-name descname"><span class="pre">CalcJacobianSpatialVelocity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_respect_to</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JacobianWrtVariable" title="pydrake.multibody.tree.JacobianWrtVariable"><span class="pre">pydrake.multibody.tree.JacobianWrtVariable</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame_" title="pydrake.multibody.tree.Frame_"><span class="pre">pydrake.multibody.tree.Frame_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_BoBp_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame_" title="pydrake.multibody.tree.Frame_"><span class="pre">pydrake.multibody.tree.Frame_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_E</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame_" title="pydrake.multibody.tree.Frame_"><span class="pre">pydrake.multibody.tree.Frame_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcJacobianSpatialVelocity" title="Permalink to this definition"></a></dt>
<dd><p>For one point Bp fixed/welded to a frame B, calculates J𝑠_V_ABp, Bp’s
spatial velocity Jacobian in frame A with respect to “speeds” 𝑠.</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>J𝑠_V_ABp ≜ [ ∂(V_ABp)/∂𝑠₁,  ...  ∂(V_ABp)/∂𝑠ₙ ]    (n is j or k)
     V_ABp = J𝑠_V_ABp ⋅ 𝑠          V_ABp is linear in 𝑠 ≜ [𝑠₁ ... 𝑠ₙ]ᵀ
</pre></div>
</div>
</details><p><code class="docutils literal notranslate"><span class="pre">V_ABp</span></code> is Bp’s spatial velocity in frame A and “speeds” 𝑠 is either
q̇ ≜ [q̇₁ … q̇ⱼ]ᵀ (time-derivatives of j generalized positions) or v
≜ [v₁ … vₖ]ᵀ (k generalized velocities).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The state of the multibody system.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">with_respect_to</span></code>:</dt><dd><p>Enum equal to JacobianWrtVariable::kQDot or
JacobianWrtVariable::kV, indicating whether the Jacobian
<code class="docutils literal notranslate"><span class="pre">J𝑠_V_ABp</span></code> is partial derivatives with respect to 𝑠 = q̇
(time-derivatives of generalized positions) or with respect to 𝑠 =
v (generalized velocities).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_B</span></code>:</dt><dd><p>The frame on which point Bp is fixed/welded.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BoBp_B</span></code>:</dt><dd><p>A position vector from Bo (frame_B’s origin) to point Bp (regarded
as fixed/welded to B), expressed in frame_B.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_A</span></code>:</dt><dd><p>The frame that measures <code class="docutils literal notranslate"><span class="pre">v_ABp</span></code> (Bp’s velocity in A). Note: It
is natural to wonder why there is no parameter p_AoAp_A (similar
to the parameter p_BoBp_B for frame_B). There is no need for
p_AoAp_A because Bp’s velocity in A is defined as the derivative
in frame A of Bp’s position vector from <em>any</em> point fixed to A.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_E</span></code>:</dt><dd><p>The frame in which <code class="docutils literal notranslate"><span class="pre">v_ABp</span></code> is expressed on input and the frame
in which the Jacobian <code class="docutils literal notranslate"><span class="pre">J𝑠_V_ABp</span></code> is expressed on output.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">J𝑠_V_ABp_E</span></code>:</dt><dd><p>Point Bp’s spatial velocity Jacobian in frame A with respect to
speeds 𝑠 (which is either q̇ or v), expressed in frame E.
<code class="docutils literal notranslate"><span class="pre">J𝑠_V_ABp_E</span></code> is a <code class="docutils literal notranslate"><span class="pre">6</span> <span class="pre">x</span> <span class="pre">n</span></code> matrix, where n is the number of
elements in 𝑠. The Jacobian is a function of only generalized
positions q (which are pulled from the context). Note: The
returned <code class="docutils literal notranslate"><span class="pre">6</span> <span class="pre">x</span> <span class="pre">n</span></code> matrix stores frame B’s angular velocity
Jacobian in A in rows 1-3 and stores point Bp’s translational
velocity Jacobian in A in rows 4-6, i.e.,</p>
</dd>
</dl>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">J𝑠_w_AB_E</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">J𝑠_V_ABp_E</span><span class="p">.</span><span class="n">topRows</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">J𝑠_v_ABp_E</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">J𝑠_V_ABp_E</span><span class="p">.</span><span class="n">bottomRows</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">();</span><span class="w"></span>
</pre></div>
</div>
</details><p>Note: Consider CalcJacobianTranslationalVelocity() for multiple points
fixed to frame B and consider CalcJacobianAngularVelocity() to
calculate frame B’s angular velocity Jacobian.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if J𝑠_V_ABp_E is nullptr</strong><strong> or </strong><strong>not sized 6 x n.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcJacobianTranslationalVelocity">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].CalcJacobianTranslationalVelocity"></span><span class="sig-name descname"><span class="pre">CalcJacobianTranslationalVelocity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_respect_to</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JacobianWrtVariable" title="pydrake.multibody.tree.JacobianWrtVariable"><span class="pre">pydrake.multibody.tree.JacobianWrtVariable</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame_" title="pydrake.multibody.tree.Frame_"><span class="pre">pydrake.multibody.tree.Frame_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_BoBi_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.f_contiguous</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame_" title="pydrake.multibody.tree.Frame_"><span class="pre">pydrake.multibody.tree.Frame_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_E</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame_" title="pydrake.multibody.tree.Frame_"><span class="pre">pydrake.multibody.tree.Frame_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcJacobianTranslationalVelocity" title="Permalink to this definition"></a></dt>
<dd><p>For each point Bi affixed/welded to a frame B, calculates J𝑠_v_ABi,
Bi’s translational velocity Jacobian in frame A with respect to
“speeds” 𝑠.</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>J𝑠_v_ABi ≜ [ ∂(v_ABi)/∂𝑠₁,  ...  ∂(v_ABi)/∂𝑠ₙ ]    (n is j or k)
     v_ABi = J𝑠_v_ABi ⋅ 𝑠          v_ABi is linear in 𝑠 ≜ [𝑠₁ ... 𝑠ₙ]ᵀ
</pre></div>
</div>
</details><p><code class="docutils literal notranslate"><span class="pre">v_ABi</span></code> is Bi’s translational velocity in frame A and “speeds” 𝑠 is
either q̇ ≜ [q̇₁ … q̇ⱼ]ᵀ (time-derivatives of j generalized
positions) or v ≜ [v₁ … vₖ]ᵀ (k generalized velocities).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The state of the multibody system.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">with_respect_to</span></code>:</dt><dd><p>Enum equal to JacobianWrtVariable::kQDot or
JacobianWrtVariable::kV, indicating whether the Jacobian
<code class="docutils literal notranslate"><span class="pre">J𝑠_v_ABi</span></code> is partial derivatives with respect to 𝑠 = q̇
(time-derivatives of generalized positions) or with respect to 𝑠 =
v (generalized velocities).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_B</span></code>:</dt><dd><p>The frame on which point Bi is affixed/welded.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BoBi_B</span></code>:</dt><dd><p>A position vector or list of p position vectors from Bo (frame_B’s
origin) to points Bi (regarded as affixed to B), where each
position vector is expressed in frame_B.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_A</span></code>:</dt><dd><p>The frame that measures <code class="docutils literal notranslate"><span class="pre">v_ABi</span></code> (Bi’s velocity in A). Note: It
is natural to wonder why there is no parameter p_AoAi_A (similar
to the parameter p_BoBi_B for frame_B). There is no need for
p_AoAi_A because Bi’s velocity in A is defined as the derivative
in frame A of Bi’s position vector from <em>any</em> point affixed to A.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_E</span></code>:</dt><dd><p>The frame in which <code class="docutils literal notranslate"><span class="pre">v_ABi</span></code> is expressed on input and the frame
in which the Jacobian <code class="docutils literal notranslate"><span class="pre">J𝑠_v_ABi</span></code> is expressed on output.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">J𝑠_v_ABi_E</span></code>:</dt><dd><p>Point Bi’s velocity Jacobian in frame A with respect to speeds 𝑠
(which is either q̇ or v), expressed in frame E. <code class="docutils literal notranslate"><span class="pre">J𝑠_v_ABi_E</span></code> is
a <code class="docutils literal notranslate"><span class="pre">3*p</span> <span class="pre">x</span> <span class="pre">n</span></code> matrix, where p is the number of points Bi and n is
the number of elements in 𝑠. The Jacobian is a function of only
generalized positions q (which are pulled from the context).</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if J𝑠_v_ABi_E is nullptr</strong><strong> or </strong><strong>not sized ``3*p x</strong> – </p></li>
<li><p><strong>n``.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When 𝑠 = q̇, <code class="docutils literal notranslate"><span class="pre">Jq̇_v_ABi</span> <span class="pre">=</span> <span class="pre">Jq_p_AoBi</span></code>. In other words, point Bi’s
velocity Jacobian in frame A with respect to q̇ is equal to point
Bi’s position Jacobian from Ao (A’s origin) in frame A with
respect to q.</p>
</div>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>[∂(v_ABi)/∂q̇₁,  ...  ∂(v_ABi)/∂q̇ⱼ] = [∂(p_AoBi)/∂q₁,  ...  ∂(p_AoBi)/∂qⱼ]
</pre></div>
</div>
</details><p>Note: Each partial derivative of p_AoBi is taken in frame A.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcJacobianPositionVector() for details on Jq_p_AoBi.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcMassMatrix">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].CalcMassMatrix"></span><span class="sig-name descname"><span class="pre">CalcMassMatrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcMassMatrix" title="Permalink to this definition"></a></dt>
<dd><p>Efficiently computes the mass matrix <code class="docutils literal notranslate"><span class="pre">M(q)</span></code> of the model. The
generalized positions q are taken from the given <code class="docutils literal notranslate"><span class="pre">context</span></code>. M
includes the mass properties of rigid bodies and reflected_inertia
“reflected inertias” as provided with JointActuator specifications.</p>
<p>This method employs the Composite Body Algorithm, which we believe to
be the fastest O(n²) algorithm to compute the mass matrix of a
multibody system.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The Context containing the state of the model from which
generalized coordinates q are extracted.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">M</span></code>:</dt><dd><p>A pointer to a square matrix in <code class="docutils literal notranslate"><span class="pre">ℛⁿˣⁿ</span></code> with n the number of
generalized velocities (num_velocities()) of the model. Although
symmetric, the matrix is filled in completely on return.</p>
</dd>
<dt>Precondition:</dt><dd><p>M is non-null and has the right size.</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This is an O(n²) algorithm. Avoid the explicit computation of the
mass matrix whenever possible.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcMassMatrixViaInverseDynamics() (slower)</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcMassMatrixViaInverseDynamics">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].CalcMassMatrixViaInverseDynamics"></span><span class="sig-name descname"><span class="pre">CalcMassMatrixViaInverseDynamics</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcMassMatrixViaInverseDynamics" title="Permalink to this definition"></a></dt>
<dd><p>Computes the mass matrix <code class="docutils literal notranslate"><span class="pre">M(q)</span></code> of the model using a slow method
(inverse dynamics). The generalized positions q are taken from the
given <code class="docutils literal notranslate"><span class="pre">context</span></code>. M includes the mass properties of rigid bodies and
reflected_inertia “reflected inertias” as provided with JointActuator
specifications.</p>
<p>Use CalcMassMatrix() for a faster implementation using the Composite
Body Algorithm.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The Context containing the state of the model from which
generalized coordinates q are extracted.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">M</span></code>:</dt><dd><p>A pointer to a square matrix in <code class="docutils literal notranslate"><span class="pre">ℛⁿˣⁿ</span></code> with n the number of
generalized velocities (num_velocities()) of the model. Although
symmetric, the matrix is filled in completely on return.</p>
</dd>
<dt>Precondition:</dt><dd><p>M is non-null and has the right size.</p>
</dd>
</dl>
<p>The algorithm used to build <code class="docutils literal notranslate"><span class="pre">M(q)</span></code> consists in computing one column
of <code class="docutils literal notranslate"><span class="pre">M(q)</span></code> at a time using inverse dynamics. The result from inverse
dynamics, with no applied forces, is the vector of generalized forces:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>tau = M(q)v̇ + C(q, v)v
</pre></div>
</div>
</details><p>where q and v are the generalized positions and velocities,
respectively. When <code class="docutils literal notranslate"><span class="pre">v</span> <span class="pre">=</span> <span class="pre">0</span></code> the Coriolis and gyroscopic forces term
<code class="docutils literal notranslate"><span class="pre">C(q,</span> <span class="pre">v)v</span></code> is zero. Therefore the <code class="docutils literal notranslate"><span class="pre">i-th</span></code> column of <code class="docutils literal notranslate"><span class="pre">M(q)</span></code> can be
obtained performing inverse dynamics with an acceleration vector <code class="docutils literal notranslate"><span class="pre">v̇</span>
<span class="pre">=</span> <span class="pre">eᵢ</span></code>, with <code class="docutils literal notranslate"><span class="pre">eᵢ</span></code> the standard (or natural) basis of <code class="docutils literal notranslate"><span class="pre">ℛⁿ</span></code> with n
the number of generalized velocities. We write this as:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">M</span><span class="p">.</span><span class="n">ᵢ</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">M</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">e_i</span><span class="w"></span>
</pre></div>
</div>
</details><p>where <code class="docutils literal notranslate"><span class="pre">M.ᵢ(q)</span></code> (notice the dot for the rows index) denotes the
<code class="docutils literal notranslate"><span class="pre">i-th</span></code> column in M(q).</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This is an O(n²) algorithm. Avoid the explicit computation of the
mass matrix whenever possible.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcMassMatrix(), CalcInverseDynamics()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcPointsPositions">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].CalcPointsPositions"></span><span class="sig-name descname"><span class="pre">CalcPointsPositions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame_" title="pydrake.multibody.tree.Frame_"><span class="pre">pydrake.multibody.tree.Frame_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_BQi</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.f_contiguous</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame_" title="pydrake.multibody.tree.Frame_"><span class="pre">pydrake.multibody.tree.Frame_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcPointsPositions" title="Permalink to this definition"></a></dt>
<dd><p>Given the positions <code class="docutils literal notranslate"><span class="pre">p_BQi</span></code> for a set of points <code class="docutils literal notranslate"><span class="pre">Qi</span></code> measured and
expressed in a frame B, this method computes the positions
<code class="docutils literal notranslate"><span class="pre">p_AQi(q)</span></code> of each point <code class="docutils literal notranslate"><span class="pre">Qi</span></code> in the set as measured and expressed
in another frame A, as a function of the generalized positions q of
the model.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context containing the state of the model. It stores the
generalized positions q of the model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_B</span></code>:</dt><dd><p>The frame B in which the positions <code class="docutils literal notranslate"><span class="pre">p_BQi</span></code> of a set of points
<code class="docutils literal notranslate"><span class="pre">Qi</span></code> are given.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BQi</span></code>:</dt><dd><p>The input positions of each point <code class="docutils literal notranslate"><span class="pre">Qi</span></code> in frame B. <code class="docutils literal notranslate"><span class="pre">p_BQi</span> <span class="pre">∈</span>
<span class="pre">ℝ³ˣⁿᵖ</span></code> with <code class="docutils literal notranslate"><span class="pre">np</span></code> the number of points in the set. Each column
of <code class="docutils literal notranslate"><span class="pre">p_BQi</span></code> corresponds to a vector in ℝ³ holding the position of
one of the points in the set as measured and expressed in frame B.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_A</span></code>:</dt><dd><p>The frame A in which it is desired to compute the positions
<code class="docutils literal notranslate"><span class="pre">p_AQi</span></code> of each point <code class="docutils literal notranslate"><span class="pre">Qi</span></code> in the set.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_AQi</span></code>:</dt><dd><p>The output positions of each point <code class="docutils literal notranslate"><span class="pre">Qi</span></code> now computed as measured
and expressed in frame A. The output <code class="docutils literal notranslate"><span class="pre">p_AQi</span></code> <strong>must</strong> have the
same size as the input <code class="docutils literal notranslate"><span class="pre">p_BQi</span></code> or otherwise this method aborts.
That is <code class="docutils literal notranslate"><span class="pre">p_AQi</span></code> <strong>must</strong> be in <code class="docutils literal notranslate"><span class="pre">ℝ³ˣⁿᵖ</span></code>.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Both <code class="docutils literal notranslate"><span class="pre">p_BQi</span></code> and <code class="docutils literal notranslate"><span class="pre">p_AQi</span></code> must have three rows. Otherwise this
method will throw a RuntimeError. This method also throws a
RuntimeError if <code class="docutils literal notranslate"><span class="pre">p_BQi</span></code> and <code class="docutils literal notranslate"><span class="pre">p_AQi</span></code> differ in the number of
columns.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcRelativeRotationMatrix">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].CalcRelativeRotationMatrix"></span><span class="sig-name descname"><span class="pre">CalcRelativeRotationMatrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame_" title="pydrake.multibody.tree.Frame_"><span class="pre">pydrake.multibody.tree.Frame_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame_" title="pydrake.multibody.tree.Frame_"><span class="pre">pydrake.multibody.tree.Frame_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.math.html#pydrake.math.RotationMatrix_" title="pydrake.math.RotationMatrix_"><span class="pre">pydrake.math.RotationMatrix_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcRelativeRotationMatrix" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the rotation matrix <code class="docutils literal notranslate"><span class="pre">R_AB</span></code> relating frame A and frame B.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The state of the multibody system, which includes the system’s
generalized positions q. Note: <code class="docutils literal notranslate"><span class="pre">R_AB</span></code> is a function of q.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_A</span></code>:</dt><dd><p>The frame A designated in the rigid transform <code class="docutils literal notranslate"><span class="pre">R_AB</span></code>.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_B</span></code>:</dt><dd><p>The frame G designated in the rigid transform <code class="docutils literal notranslate"><span class="pre">R_AB</span></code>.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">R_AB</span></code>:</dt><dd><p>The RigidTransform relating frame A and frame B.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcRelativeTransform">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].CalcRelativeTransform"></span><span class="sig-name descname"><span class="pre">CalcRelativeTransform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame_" title="pydrake.multibody.tree.Frame_"><span class="pre">pydrake.multibody.tree.Frame_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame_" title="pydrake.multibody.tree.Frame_"><span class="pre">pydrake.multibody.tree.Frame_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.math.html#pydrake.math.RigidTransform_" title="pydrake.math.RigidTransform_"><span class="pre">pydrake.math.RigidTransform_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcRelativeTransform" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the rigid transform (pose) <code class="docutils literal notranslate"><span class="pre">X_AB</span></code> relating frame A and
frame B.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The state of the multibody system, which includes the system’s
generalized positions q. Note: <code class="docutils literal notranslate"><span class="pre">X_AB</span></code> is a function of q.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_A</span></code>:</dt><dd><p>The frame A designated in the rigid transform <code class="docutils literal notranslate"><span class="pre">X_AB</span></code>.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_B</span></code>:</dt><dd><p>The frame G designated in the rigid transform <code class="docutils literal notranslate"><span class="pre">X_AB</span></code>.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">X_AB</span></code>:</dt><dd><p>The RigidTransform relating frame A and frame B.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcSpatialAccelerationsFromVdot">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].CalcSpatialAccelerationsFromVdot"></span><span class="sig-name descname"><span class="pre">CalcSpatialAccelerationsFromVdot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">known_vdot</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.multibody.math.html#pydrake.multibody.math.SpatialAcceleration_" title="pydrake.multibody.math.SpatialAcceleration_"><span class="pre">pydrake.multibody.math.SpatialAcceleration_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcSpatialAccelerationsFromVdot" title="Permalink to this definition"></a></dt>
<dd><p>Given the state of this model in <code class="docutils literal notranslate"><span class="pre">context</span></code> and a known vector of
generalized accelerations <code class="docutils literal notranslate"><span class="pre">known_vdot</span></code>, this method computes the
spatial acceleration <code class="docutils literal notranslate"><span class="pre">A_WB</span></code> for each body as measured and expressed
in the world frame W.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context containing the state of this model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">known_vdot</span></code>:</dt><dd><p>A vector with the generalized accelerations for the full model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">A_WB_array</span></code>:</dt><dd><p>A pointer to a valid, non nullptr, vector of spatial accelerations
containing the spatial acceleration <code class="docutils literal notranslate"><span class="pre">A_WB</span></code> for each body. It
must be of size equal to the number of bodies in the model. On
output, entries will be ordered by BodyIndex.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if A_WB_array is not of size num_bodies</strong><strong>(</strong><strong>)</strong><strong></strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcSpatialInertia">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].CalcSpatialInertia"></span><span class="sig-name descname"><span class="pre">CalcSpatialInertia</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_F</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame_" title="pydrake.multibody.tree.Frame_"><span class="pre">pydrake.multibody.tree.Frame_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body_indexes</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.BodyIndex" title="pydrake.multibody.tree.BodyIndex"><span class="pre">pydrake.multibody.tree.BodyIndex</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.SpatialInertia_" title="pydrake.multibody.tree.SpatialInertia_"><span class="pre">pydrake.multibody.tree.SpatialInertia_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcSpatialInertia" title="Permalink to this definition"></a></dt>
<dd><p>Returns M_SFo_F, the spatial inertia of a set S of bodies about point
Fo (the origin of a frame F), expressed in frame F. You may regard
M_SFo_F as measuring spatial inertia as if the set S of bodies were
welded into a single composite body at the configuration specified in
the <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>Contains the configuration of the set S of bodies.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_F</span></code>:</dt><dd><p>specifies the about-point Fo (frame_F’s origin) and the
expressed-in frame for the returned spatial inertia.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body_indexes</span></code>:</dt><dd><p>Array of selected bodies. This method does not distinguish between
welded bodies, joint-connected bodies, etc.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if body_indexes contains an invalid BodyIndex</strong><strong> or </strong><strong>if</strong> – </p></li>
<li><p><strong>there is a repeated BodyIndex.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The mass and inertia of the world_body() does not contribute to
the the returned spatial inertia.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcSpatialMomentumInWorldAboutPoint">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].CalcSpatialMomentumInWorldAboutPoint"></span><span class="sig-name descname"><span class="pre">CalcSpatialMomentumInWorldAboutPoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcSpatialMomentumInWorldAboutPoint" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>CalcSpatialMomentumInWorldAboutPoint(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], p_WoP_W: numpy.ndarray[object[3, 1]]) -&gt; pydrake.multibody.math.SpatialMomentum_[AutoDiffXd]</p></li>
</ol>
<p>This method returns the spatial momentum of <code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant in
the world frame W, about a designated point P, expressed in the world
frame W.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>Contains the state of the model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_WoP_W</span></code>:</dt><dd><p>Position from Wo (origin of the world frame W) to an arbitrary
point P, expressed in the world frame W.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">L_WSP_W</span></code>:</dt><dd><p>, spatial momentum of the system S represented by <code class="docutils literal notranslate"><span class="pre">this</span></code> plant,
measured in the world frame W, about point P, expressed in W.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>To calculate the spatial momentum of this system S in W about Scm
(the system’s center of mass), use something like:</p>
</div>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">plant</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="c1">// ... code to load a model ....</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">Vector3</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">p_WoScm_W</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">    </span><span class="n">plant</span><span class="p">.</span><span class="n">CalcCenterOfMassPositionInWorld</span><span class="p">(</span><span class="n">context</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">SpatialMomentum</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">L_WScm_W</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">    </span><span class="n">plant</span><span class="p">.</span><span class="n">CalcSpatialMomentumInWorldAboutPoint</span><span class="p">(</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="n">p_WoScm_W</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</details><ol class="arabic simple" start="2">
<li><p>CalcSpatialMomentumInWorldAboutPoint(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], model_instances: List[pydrake.multibody.tree.ModelInstanceIndex], p_WoP_W: numpy.ndarray[object[3, 1]]) -&gt; pydrake.multibody.math.SpatialMomentum_[AutoDiffXd]</p></li>
</ol>
<p>This method returns the spatial momentum of a set of model instances
in the world frame W, about a designated point P, expressed in frame
W.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>Contains the state of the model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">model_instances</span></code>:</dt><dd><p>Set of selected model instances.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_WoP_W</span></code>:</dt><dd><p>Position from Wo (origin of the world frame W) to an arbitrary
point P, expressed in the world frame W.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">L_WSP_W</span></code>:</dt><dd><p>, spatial momentum of the system S represented by the
model_instances, measured in world frame W, about point P,
expressed in W.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>To calculate the spatial momentum of this system S in W about Scm
(the system’s center of mass), use something like:</p>
</div>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">plant</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="c1">// ... code to create a set of selected model instances, e.g., ...</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">ModelInstanceIndex</span><span class="w"> </span><span class="n">gripper_model_instance</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">    </span><span class="n">plant</span><span class="p">.</span><span class="n">GetModelInstanceByName</span><span class="p">(</span><span class="s">&quot;gripper&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">ModelInstanceIndex</span><span class="w"> </span><span class="n">robot_model_instance</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">    </span><span class="n">plant</span><span class="p">.</span><span class="n">GetBodyByName</span><span class="p">(</span><span class="s">&quot;end_effector&quot;</span><span class="p">).</span><span class="n">model_instance</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ModelInstanceIndex</span><span class="o">&gt;</span><span class="w"> </span><span class="n">model_instances</span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">gripper_model_instance</span><span class="p">,</span><span class="w"> </span><span class="n">robot_model_instance</span><span class="p">};</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">Vector3</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">p_WoScm_W</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">    </span><span class="n">plant</span><span class="p">.</span><span class="n">CalcCenterOfMassPositionInWorld</span><span class="p">(</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="n">model_instances</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">SpatialMomentum</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">L_WScm_W</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">    </span><span class="n">plant</span><span class="p">.</span><span class="n">CalcSpatialMomentumInWorldAboutPoint</span><span class="p">(</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="n">model_instances</span><span class="p">,</span><span class="w"></span>
<span class="w">                                               </span><span class="n">p_WoScm_W</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</details><dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if model_instances contains an invalid</strong> – </p></li>
<li><p><strong>ModelInstanceIndex.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcTotalMass">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].CalcTotalMass"></span><span class="sig-name descname"><span class="pre">CalcTotalMass</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CalcTotalMass" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>CalcTotalMass(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd]) -&gt; pydrake.autodiffutils.AutoDiffXd</p></li>
</ol>
<p>Calculates the total mass of all bodies in this MultibodyPlant.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>Contains the state of the model.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">The</span></code>:</dt><dd><p>total mass of all bodies or 0 if there are none.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The mass of the world_body() does not contribute to the total
mass.</p>
</div>
<ol class="arabic simple" start="2">
<li><p>CalcTotalMass(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], model_instances: List[pydrake.multibody.tree.ModelInstanceIndex]) -&gt; pydrake.autodiffutils.AutoDiffXd</p></li>
</ol>
<p>Calculates the total mass of all bodies contained in model_instances.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>Contains the state of the model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">model_instances</span></code>:</dt><dd><p>Vector of selected model instances. This method does not
distinguish between welded, joint connected, or floating bodies.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">The</span></code>:</dt><dd><p>total mass of all bodies belonging to a model instance in
model_instances or 0 if model_instances is empty.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The mass of the world_body() does not contribute to the total mass
and each body only contributes to the total mass once, even if the
body has repeated occurrence (instance) in model_instances.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CollectRegisteredGeometries">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].CollectRegisteredGeometries"></span><span class="sig-name descname"><span class="pre">CollectRegisteredGeometries</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bodies</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody_" title="pydrake.multibody.tree.RigidBody_"><span class="pre">pydrake.multibody.tree.RigidBody_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.GeometrySet" title="pydrake.geometry.GeometrySet"><span class="pre">pydrake.geometry.GeometrySet</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.CollectRegisteredGeometries" title="Permalink to this definition"></a></dt>
<dd><p>For each of the provided <code class="docutils literal notranslate"><span class="pre">bodies</span></code>, collects up all geometries that
have been registered to that body. Intended to be used in conjunction
with CollisionFilterDeclaration and CollisionFilterManager::Apply() to
filter collisions between the geometries registered to the bodies.</p>
<p>For example:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Don&#39;t report on collisions between geometries affixed to `body1`,</span>
<span class="c1">// `body2`, or `body3`.</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">RigidBody</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*&gt;</span><span class="w"> </span><span class="n">bodies</span><span class="p">{</span><span class="o">&amp;</span><span class="n">body1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">body2</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">body3</span><span class="p">};</span><span class="w"></span>
<span class="n">geometry</span><span class="o">::</span><span class="n">GeometrySet</span><span class="w"> </span><span class="n">set</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">plant</span><span class="p">.</span><span class="n">CollectRegisteredGeometries</span><span class="p">(</span><span class="n">bodies</span><span class="p">);</span><span class="w"></span>
<span class="n">scene_graph</span><span class="p">.</span><span class="n">collision_filter_manager</span><span class="p">().</span><span class="n">Apply</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">CollisionFilterDeclaration</span><span class="p">().</span><span class="n">ExcludeWithin</span><span class="p">(</span><span class="n">set</span><span class="p">));</span><span class="w"></span>
</pre></div>
</div>
</details><div class="admonition note">
<p class="admonition-title">Note</p>
<p>There is a <em>very</em> specific order of operations:</p>
</div>
<ol class="arabic simple">
<li><p>Bodies and geometries must be added to the MultibodyPlant.</p></li>
<li><p>Create GeometrySet instances from bodies (via this method).</p></li>
<li><p>Invoke SceneGraph::ExcludeCollisions*() to filter collisions.</p></li>
<li><p>Allocate context.</p></li>
</ol>
<p>Changing the order will cause exceptions to be thrown.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if this MultibodyPlant was not registered with a</strong> – </p></li>
<li><p><strong>SceneGraph.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.EvalBodyPoseInWorld">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].EvalBodyPoseInWorld"></span><span class="sig-name descname"><span class="pre">EvalBodyPoseInWorld</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody_" title="pydrake.multibody.tree.RigidBody_"><span class="pre">pydrake.multibody.tree.RigidBody_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.math.html#pydrake.math.RigidTransform_" title="pydrake.math.RigidTransform_"><span class="pre">pydrake.math.RigidTransform_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.EvalBodyPoseInWorld" title="Permalink to this definition"></a></dt>
<dd><p>Evaluate the pose <code class="docutils literal notranslate"><span class="pre">X_WB</span></code> of a body B in the world frame W.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context storing the state of the model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body_B</span></code>:</dt><dd><p>The body B for which the pose is requested.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">X_WB</span></code>:</dt><dd><p>The pose of body frame B in the world frame W.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if Finalize</strong><strong>(</strong><strong>) </strong><strong>was not called on this model</strong><strong> or </strong><strong>if</strong> – </p></li>
<li><p><strong>body_B` does not belong to this model</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.EvalBodySpatialAccelerationInWorld">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].EvalBodySpatialAccelerationInWorld"></span><span class="sig-name descname"><span class="pre">EvalBodySpatialAccelerationInWorld</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody_" title="pydrake.multibody.tree.RigidBody_"><span class="pre">pydrake.multibody.tree.RigidBody_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.math.html#pydrake.multibody.math.SpatialAcceleration_" title="pydrake.multibody.math.SpatialAcceleration_"><span class="pre">pydrake.multibody.math.SpatialAcceleration_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.EvalBodySpatialAccelerationInWorld" title="Permalink to this definition"></a></dt>
<dd><p>Evaluates A_WB, body B’s spatial acceleration in the world frame W.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context storing the state of the model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body_B</span></code>:</dt><dd><p>The body for which spatial acceleration is requested.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">A_WB_W</span></code>:</dt><dd><p>RigidBody B’s spatial acceleration in the world frame W, expressed
in W (for point Bo, the body’s origin).</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if Finalize</strong><strong>(</strong><strong>) </strong><strong>was not called on this model</strong><strong> or </strong><strong>if</strong> – </p></li>
<li><p><strong>body_B` does not belong to this model</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When cached values are out of sync with the state stored in
context, this method performs an expensive forward dynamics
computation, whereas once evaluated, successive calls to this
method are inexpensive.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.EvalBodySpatialVelocityInWorld">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].EvalBodySpatialVelocityInWorld"></span><span class="sig-name descname"><span class="pre">EvalBodySpatialVelocityInWorld</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody_" title="pydrake.multibody.tree.RigidBody_"><span class="pre">pydrake.multibody.tree.RigidBody_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.math.html#pydrake.multibody.math.SpatialVelocity_" title="pydrake.multibody.math.SpatialVelocity_"><span class="pre">pydrake.multibody.math.SpatialVelocity_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.EvalBodySpatialVelocityInWorld" title="Permalink to this definition"></a></dt>
<dd><p>Evaluates V_WB, body B’s spatial velocity in the world frame W.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context storing the state of the model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body_B</span></code>:</dt><dd><p>The body B for which the spatial velocity is requested.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">V_WB_W</span></code>:</dt><dd><p>RigidBody B’s spatial velocity in the world frame W, expressed in
W (for point Bo, the body’s origin).</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if Finalize</strong><strong>(</strong><strong>) </strong><strong>was not called on this model</strong><strong> or </strong><strong>if</strong> – </p></li>
<li><p><strong>body_B` does not belong to this model</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.Finalize">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].Finalize"></span><span class="sig-name descname"><span class="pre">Finalize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.Finalize" title="Permalink to this definition"></a></dt>
<dd><p>This method must be called after all elements in the model (joints,
bodies, force elements, constraints, etc.) are added and before any
computations are performed. It essentially compiles all the necessary
“topological information”, i.e. how bodies, joints and, any other
elements connect with each other, and performs all the required
pre-processing to enable computations at a later stage.</p>
<p>If the finalize stage is successful, the topology of this
MultibodyPlant is valid, meaning that the topology is up-to-date after
this call. No more multibody elements can be added after a call to
Finalize().</p>
<p>At Finalize(), state and input/output ports for <code class="docutils literal notranslate"><span class="pre">this</span></code> plant are
declared.</p>
<p>For a full account of the effects of Finalize(), see
mbp_finalize_stage “Finalize() stage”.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>is_finalized(), mbp_finalize_stage “Finalize() stage”.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if the MultibodyPlant has already been finalized.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.geometry_source_is_registered">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].geometry_source_is_registered"></span><span class="sig-name descname"><span class="pre">geometry_source_is_registered</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.geometry_source_is_registered" title="Permalink to this definition"></a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if <code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant was registered with a
SceneGraph. This method can be called at any time during the lifetime
of <code class="docutils literal notranslate"><span class="pre">this</span></code> plant to query if <code class="docutils literal notranslate"><span class="pre">this</span></code> plant has been registered with
a SceneGraph, either pre- or post-finalize, see Finalize().</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_actuation_input_port">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].get_actuation_input_port"></span><span class="sig-name descname"><span class="pre">get_actuation_input_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_actuation_input_port" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>get_actuation_input_port(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd]) -&gt; pydrake.systems.framework.InputPort_[AutoDiffXd]</p></li>
</ol>
<p>Returns a constant reference to the input port for external actuation
for all actuated dofs. This input port is a vector valued port and can
be set with JointActuator::set_actuation_vector(). The actuation value
for a particular actuator can be found at offset
JointActuator::input_start() in this vector. Refer to mbp_actuation
“Actuation” for further details.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>Finalize() was already called on <code class="docutils literal notranslate"><span class="pre">this</span></code> plant.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if called before Finalize</strong><strong>(</strong><strong>)</strong><strong></strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>get_actuation_input_port(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; pydrake.systems.framework.InputPort_[AutoDiffXd]</p></li>
</ol>
<p>Returns a constant reference to the input port for external actuation
for a specific model instance. This is a vector valued port with
entries ordered by monotonically increasing JointActuatorIndex within
<code class="docutils literal notranslate"><span class="pre">model_instance</span></code>. Refer to mbp_actuation “Actuation” for further
details.</p>
<p>Every model instance in <code class="docutils literal notranslate"><span class="pre">this</span></code> plant model has an actuation input
port, even if zero sized (for model instance with no actuators).</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>GetJointActuatorIndices(), GetActuatedJointIndices().</p>
</div>
<dl class="simple">
<dt>Precondition:</dt><dd><p>Finalize() was already called on <code class="docutils literal notranslate"><span class="pre">this</span></code> plant.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if called before Finalize</strong><strong>(</strong><strong>)</strong><strong></strong> – </p></li>
<li><p><strong>RuntimeError if the model instance does not exist.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_adjacent_bodies_collision_filters">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].get_adjacent_bodies_collision_filters"></span><span class="sig-name descname"><span class="pre">get_adjacent_bodies_collision_filters</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_adjacent_bodies_collision_filters" title="Permalink to this definition"></a></dt>
<dd><p>Returns whether to apply collision filters to topologically adjacent
bodies at Finalize() time.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_applied_generalized_force_input_port">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].get_applied_generalized_force_input_port"></span><span class="sig-name descname"><span class="pre">get_applied_generalized_force_input_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.InputPort_" title="pydrake.systems.framework.InputPort_"><span class="pre">pydrake.systems.framework.InputPort_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_applied_generalized_force_input_port" title="Permalink to this definition"></a></dt>
<dd><p>Returns a constant reference to the vector-valued input port for
applied generalized forces, and the vector will be added directly into
<code class="docutils literal notranslate"><span class="pre">tau</span></code> (see mbp_equations_of_motion “System dynamics”). This vector
is ordered using the same convention as the plant velocities: you can
set the generalized forces that will be applied to model instance i
using, e.g., <code class="docutils literal notranslate"><span class="pre">SetVelocitiesInArray(i,</span> <span class="pre">model_forces,</span> <span class="pre">&amp;force_array)</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if called before Finalize</strong><strong>(</strong><strong>)</strong><strong></strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_applied_spatial_force_input_port">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].get_applied_spatial_force_input_port"></span><span class="sig-name descname"><span class="pre">get_applied_spatial_force_input_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.InputPort_" title="pydrake.systems.framework.InputPort_"><span class="pre">pydrake.systems.framework.InputPort_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_applied_spatial_force_input_port" title="Permalink to this definition"></a></dt>
<dd><p>Returns a constant reference to the input port for applying spatial
forces to bodies in the plant. The data type for the port is an
std::vector of ExternallyAppliedSpatialForce; any number of spatial
forces can be applied to any number of bodies in the plant.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_body">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].get_body"></span><span class="sig-name descname"><span class="pre">get_body</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.BodyIndex" title="pydrake.multibody.tree.BodyIndex"><span class="pre">pydrake.multibody.tree.BodyIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody_" title="pydrake.multibody.tree.RigidBody_"><span class="pre">pydrake.multibody.tree.RigidBody_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_body" title="Permalink to this definition"></a></dt>
<dd><p>Returns a constant reference to the body with unique index
<code class="docutils literal notranslate"><span class="pre">body_index</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if body_index does not correspond to a body in</strong> – </p></li>
<li><p><strong>this model.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_body_poses_output_port">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].get_body_poses_output_port"></span><span class="sig-name descname"><span class="pre">get_body_poses_output_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.OutputPort_" title="pydrake.systems.framework.OutputPort_"><span class="pre">pydrake.systems.framework.OutputPort_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_body_poses_output_port" title="Permalink to this definition"></a></dt>
<dd><p>Returns the output port of all body poses in the world frame. You can
obtain the pose <code class="docutils literal notranslate"><span class="pre">X_WB</span></code> of a body B in the world frame W with:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">X_WB_all</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">plant</span><span class="p">.</span><span class="n">get_body_poses_output_port</span><span class="p">().</span><span class="w"></span>
<span class="w">      </span><span class="p">.</span><span class="n">Eval</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">math</span><span class="o">::</span><span class="n">RigidTransform</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">plant_context</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">BodyIndex</span><span class="w"> </span><span class="n">arm_body_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">plant</span><span class="p">.</span><span class="n">GetBodyByName</span><span class="p">(</span><span class="s">&quot;arm&quot;</span><span class="p">).</span><span class="n">index</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">math</span><span class="o">::</span><span class="n">RigidTransform</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">X_WArm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">X_WB_all</span><span class="p">[</span><span class="n">arm_body_index</span><span class="p">];</span><span class="w"></span>
</pre></div>
</div>
</details><p>As shown in the example above, the resulting <code class="docutils literal notranslate"><span class="pre">std::vector</span></code> of body
poses is indexed by BodyIndex, and it has size num_bodies(). BodyIndex
“zero” (0) always corresponds to the world body, with pose equal to
the identity at all times.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_body_spatial_accelerations_output_port">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].get_body_spatial_accelerations_output_port"></span><span class="sig-name descname"><span class="pre">get_body_spatial_accelerations_output_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.OutputPort_" title="pydrake.systems.framework.OutputPort_"><span class="pre">pydrake.systems.framework.OutputPort_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_body_spatial_accelerations_output_port" title="Permalink to this definition"></a></dt>
<dd><p>Returns the output port of all body spatial accelerations in the world
frame. You can obtain the spatial acceleration <code class="docutils literal notranslate"><span class="pre">A_WB</span></code> of a body B in
the world frame W with:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">A_WB_all</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">  </span><span class="n">plant</span><span class="p">.</span><span class="n">get_body_spatial_accelerations_output_port</span><span class="p">().</span><span class="w"></span>
<span class="w">      </span><span class="p">.</span><span class="n">Eval</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SpatialAcceleration</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">plant_context</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">BodyIndex</span><span class="w"> </span><span class="n">arm_body_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">plant</span><span class="p">.</span><span class="n">GetBodyByName</span><span class="p">(</span><span class="s">&quot;arm&quot;</span><span class="p">).</span><span class="n">index</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">SpatialVelocity</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">A_WArm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A_WB_all</span><span class="p">[</span><span class="n">arm_body_index</span><span class="p">];</span><span class="w"></span>
</pre></div>
</div>
</details><p>As shown in the example above, the resulting <code class="docutils literal notranslate"><span class="pre">std::vector</span></code> of body
spatial accelerations is indexed by BodyIndex, and it has size
num_bodies(). BodyIndex “zero” (0) always corresponds to the world
body, with zero spatial acceleration at all times.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_body_spatial_velocities_output_port">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].get_body_spatial_velocities_output_port"></span><span class="sig-name descname"><span class="pre">get_body_spatial_velocities_output_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.OutputPort_" title="pydrake.systems.framework.OutputPort_"><span class="pre">pydrake.systems.framework.OutputPort_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_body_spatial_velocities_output_port" title="Permalink to this definition"></a></dt>
<dd><p>Returns the output port of all body spatial velocities in the world
frame. You can obtain the spatial velocity <code class="docutils literal notranslate"><span class="pre">V_WB</span></code> of a body B in the
world frame W with:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">V_WB_all</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">plant</span><span class="p">.</span><span class="n">get_body_spatial_velocities_output_port</span><span class="p">().</span><span class="w"></span>
<span class="w">      </span><span class="p">.</span><span class="n">Eval</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SpatialVelocity</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">plant_context</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">BodyIndex</span><span class="w"> </span><span class="n">arm_body_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">plant</span><span class="p">.</span><span class="n">GetBodyByName</span><span class="p">(</span><span class="s">&quot;arm&quot;</span><span class="p">).</span><span class="n">index</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">SpatialVelocity</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">V_WArm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">V_WB_all</span><span class="p">[</span><span class="n">arm_body_index</span><span class="p">];</span><span class="w"></span>
</pre></div>
</div>
</details><p>As shown in the example above, the resulting <code class="docutils literal notranslate"><span class="pre">std::vector</span></code> of body
spatial velocities is indexed by BodyIndex, and it has size
num_bodies(). BodyIndex “zero” (0) always corresponds to the world
body, with zero spatial velocity at all times.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_contact_model">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].get_contact_model"></span><span class="sig-name descname"><span class="pre">get_contact_model</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.multibody.plant.ContactModel" title="pydrake.multibody.plant.ContactModel"><span class="pre">pydrake.multibody.plant.ContactModel</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_contact_model" title="Permalink to this definition"></a></dt>
<dd><p>Returns the model used for contact. See documentation for
ContactModel.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_contact_penalty_method_time_scale">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].get_contact_penalty_method_time_scale"></span><span class="sig-name descname"><span class="pre">get_contact_penalty_method_time_scale</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_contact_penalty_method_time_scale" title="Permalink to this definition"></a></dt>
<dd><p>Returns a time-scale estimate <code class="docutils literal notranslate"><span class="pre">tc</span></code> based on the requested
penetration allowance δ set with set_penetration_allowance(). For the
compliant contact model to enforce non-penetration, this time scale
relates to the time it takes the relative normal velocity between two
bodies to go to zero. This time scale <code class="docutils literal notranslate"><span class="pre">tc</span></code> is a global estimate of
the dynamics introduced by the compliant contact model and goes to
zero in the limit to ideal rigid contact. Since numerical integration
methods for continuum systems must be able to resolve a system’s
dynamics, the time step used by an integrator must in general be much
smaller than the time scale <code class="docutils literal notranslate"><span class="pre">tc</span></code>. How much smaller will depend on
the details of the problem and the convergence characteristics of the
integrator and should be tuned appropriately. Another factor to take
into account for setting up the simulation’s time step is the speed of
the objects in your simulation. If <code class="docutils literal notranslate"><span class="pre">vn</span></code> represents a reference
velocity scale for the normal relative velocity between bodies, the
new time scale <code class="docutils literal notranslate"><span class="pre">tn</span> <span class="pre">=</span> <span class="pre">δ</span> <span class="pre">/</span> <span class="pre">vn</span></code> represents the time it would take for
the distance between two bodies approaching with relative normal
velocity <code class="docutils literal notranslate"><span class="pre">vn</span></code> to decrease by the penetration_allowance δ. In this
case a user should choose a time step for simulation that can resolve
the smallest of the two time scales <code class="docutils literal notranslate"><span class="pre">tc</span></code> and <code class="docutils literal notranslate"><span class="pre">tn</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_contact_results_output_port">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].get_contact_results_output_port"></span><span class="sig-name descname"><span class="pre">get_contact_results_output_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.OutputPort_" title="pydrake.systems.framework.OutputPort_"><span class="pre">pydrake.systems.framework.OutputPort_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_contact_results_output_port" title="Permalink to this definition"></a></dt>
<dd><p>Returns a constant reference to the port that outputs ContactResults.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize</strong><strong>, </strong><strong>see Finalize</strong><strong>(</strong><strong>)</strong><strong></strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_contact_surface_representation">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].get_contact_surface_representation"></span><span class="sig-name descname"><span class="pre">get_contact_surface_representation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.HydroelasticContactRepresentation" title="pydrake.geometry.HydroelasticContactRepresentation"><span class="pre">pydrake.geometry.HydroelasticContactRepresentation</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_contact_surface_representation" title="Permalink to this definition"></a></dt>
<dd><p>Gets the current representation of contact surfaces used by <code class="docutils literal notranslate"><span class="pre">this</span></code>
MultibodyPlant.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_deformable_body_configuration_output_port">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].get_deformable_body_configuration_output_port"></span><span class="sig-name descname"><span class="pre">get_deformable_body_configuration_output_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.OutputPort_" title="pydrake.systems.framework.OutputPort_"><span class="pre">pydrake.systems.framework.OutputPort_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_deformable_body_configuration_output_port" title="Permalink to this definition"></a></dt>
<dd><p>Returns the output port for vertex positions (configurations),
measured and expressed in the World frame, of the deformable bodies in
<code class="docutils literal notranslate"><span class="pre">this</span></code> plant as a GeometryConfigurationVector.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if this MultibodyPlant doesn't have a</strong> – </p></li>
<li><p><strong>DeformableModel. See AddPhysicalModel</strong><strong>(</strong><strong>)</strong><strong></strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_desired_state_input_port">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].get_desired_state_input_port"></span><span class="sig-name descname"><span class="pre">get_desired_state_input_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.InputPort_" title="pydrake.systems.framework.InputPort_"><span class="pre">pydrake.systems.framework.InputPort_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_desired_state_input_port" title="Permalink to this definition"></a></dt>
<dd><p>For models with PD controlled joint actuators, returns the port to
provide the desired state for the full <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>. Refer to
mbp_actuation “Actuation” for further details.</p>
<p>For consistency with get_actuation_input_port(), each model instance
in <code class="docutils literal notranslate"><span class="pre">this</span></code> plant model has a desired states input port, even if zero
sized (for model instance with no actuators.)</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is a vector valued port of size
2*num_actuators(model_instance), where we assumed 1-DOF actuated
joints. This is true even for unactuated models, for which this
port is zero sized. This port must provide one desired position
and one desired velocity per joint actuator. Desired state is
assumed to be packed as xd = [qd, vd] that is, configurations
first followed by velocities. The actuation value for a particular
actuator can be found at offset JointActuator::input_start() in
both qd and vd. For example:</p>
</div>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">qd_actuator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xd</span><span class="p">[</span><span class="n">actuator</span><span class="p">.</span><span class="n">input_start</span><span class="p">()];</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">vd_actuator</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">   </span><span class="n">xd</span><span class="p">[</span><span class="n">actuator</span><span class="p">.</span><span class="n">input_start</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">plant</span><span class="p">.</span><span class="n">num_actuated_dofs</span><span class="p">()];</span><span class="w"></span>
</pre></div>
</div>
</details><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>If a user specifies a PD controller for an actuator from a given
model instance, then all actuators of that model instance are
required to be PD controlled.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>It is required to connect this port for PD controlled model
instances.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_discrete_contact_approximation">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].get_discrete_contact_approximation"></span><span class="sig-name descname"><span class="pre">get_discrete_contact_approximation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.multibody.plant.DiscreteContactApproximation" title="pydrake.multibody.plant.DiscreteContactApproximation"><span class="pre">pydrake.multibody.plant.DiscreteContactApproximation</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_discrete_contact_approximation" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the discrete contact solver approximation.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_discrete_contact_solver">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].get_discrete_contact_solver"></span><span class="sig-name descname"><span class="pre">get_discrete_contact_solver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.multibody.plant.DiscreteContactSolver" title="pydrake.multibody.plant.DiscreteContactSolver"><span class="pre">pydrake.multibody.plant.DiscreteContactSolver</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_discrete_contact_solver" title="Permalink to this definition"></a></dt>
<dd><p>Returns the contact solver type used for discrete MultibodyPlant
models.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_force_element">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].get_force_element"></span><span class="sig-name descname"><span class="pre">get_force_element</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">force_element_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ForceElementIndex" title="pydrake.multibody.tree.ForceElementIndex"><span class="pre">pydrake.multibody.tree.ForceElementIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ForceElement_" title="pydrake.multibody.tree.ForceElement_"><span class="pre">pydrake.multibody.tree.ForceElement_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_force_element" title="Permalink to this definition"></a></dt>
<dd><p>Returns a constant reference to the force element with unique index
<code class="docutils literal notranslate"><span class="pre">force_element_index</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError when force_element_index does not correspond to a</strong> – </p></li>
<li><p><strong>force element in this model.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_frame">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].get_frame"></span><span class="sig-name descname"><span class="pre">get_frame</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.FrameIndex" title="pydrake.multibody.tree.FrameIndex"><span class="pre">pydrake.multibody.tree.FrameIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame_" title="pydrake.multibody.tree.Frame_"><span class="pre">pydrake.multibody.tree.Frame_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_frame" title="Permalink to this definition"></a></dt>
<dd><p>Returns a constant reference to the frame with unique index
<code class="docutils literal notranslate"><span class="pre">frame_index</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if frame_index does not correspond to a frame in</strong> – </p></li>
<li><p><strong>this plant.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_generalized_acceleration_output_port">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].get_generalized_acceleration_output_port"></span><span class="sig-name descname"><span class="pre">get_generalized_acceleration_output_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_generalized_acceleration_output_port" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>get_generalized_acceleration_output_port(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd]) -&gt; pydrake.systems.framework.OutputPort_[AutoDiffXd]</p></li>
</ol>
<p>Returns a constant reference to the output port for generalized
accelerations v̇ of the model.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>Finalize() was already called on <code class="docutils literal notranslate"><span class="pre">this</span></code> plant.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if called before Finalize</strong><strong>(</strong><strong>)</strong><strong></strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>get_generalized_acceleration_output_port(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; pydrake.systems.framework.OutputPort_[AutoDiffXd]</p></li>
</ol>
<p>Returns a constant reference to the output port for the generalized
accelerations v̇ᵢ ⊆ v̇ for model instance i.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>Finalize() was already called on <code class="docutils literal notranslate"><span class="pre">this</span></code> plant.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if called before Finalize</strong><strong>(</strong><strong>)</strong><strong></strong> – </p></li>
<li><p><strong>RuntimeError if the model instance does not exist.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_generalized_contact_forces_output_port">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].get_generalized_contact_forces_output_port"></span><span class="sig-name descname"><span class="pre">get_generalized_contact_forces_output_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.OutputPort_" title="pydrake.systems.framework.OutputPort_"><span class="pre">pydrake.systems.framework.OutputPort_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_generalized_contact_forces_output_port" title="Permalink to this definition"></a></dt>
<dd><p>Returns a constant reference to the output port of generalized contact
forces for a specific model instance.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>Finalize() was already called on <code class="docutils literal notranslate"><span class="pre">this</span></code> plant.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if called before Finalize</strong><strong>(</strong><strong>)</strong><strong></strong> – </p></li>
<li><p><strong>RuntimeError if the model instance does not exist.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_geometry_poses_output_port">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].get_geometry_poses_output_port"></span><span class="sig-name descname"><span class="pre">get_geometry_poses_output_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.OutputPort_" title="pydrake.systems.framework.OutputPort_"><span class="pre">pydrake.systems.framework.OutputPort_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_geometry_poses_output_port" title="Permalink to this definition"></a></dt>
<dd><p>Returns the output port of frames’ poses to communicate with a
SceneGraph.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_geometry_query_input_port">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].get_geometry_query_input_port"></span><span class="sig-name descname"><span class="pre">get_geometry_query_input_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.InputPort_" title="pydrake.systems.framework.InputPort_"><span class="pre">pydrake.systems.framework.InputPort_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_geometry_query_input_port" title="Permalink to this definition"></a></dt>
<dd><p>Returns a constant reference to the input port used to perform
geometric queries on a SceneGraph. See
SceneGraph::get_query_output_port(). Refer to section mbp_geometry
“Geometry” of this class’s documentation for further details on
collision geometry registration and connection with a SceneGraph.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_joint">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].get_joint"></span><span class="sig-name descname"><span class="pre">get_joint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">joint_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JointIndex" title="pydrake.multibody.tree.JointIndex"><span class="pre">pydrake.multibody.tree.JointIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Joint_" title="pydrake.multibody.tree.Joint_"><span class="pre">pydrake.multibody.tree.Joint_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_joint" title="Permalink to this definition"></a></dt>
<dd><p>Returns a constant reference to the joint with unique index
<code class="docutils literal notranslate"><span class="pre">joint_index</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError when joint_index does not correspond to a joint</strong> – </p></li>
<li><p><strong>in this model.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_joint_actuator">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].get_joint_actuator"></span><span class="sig-name descname"><span class="pre">get_joint_actuator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">actuator_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JointActuatorIndex" title="pydrake.multibody.tree.JointActuatorIndex"><span class="pre">pydrake.multibody.tree.JointActuatorIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JointActuator_" title="pydrake.multibody.tree.JointActuator_"><span class="pre">pydrake.multibody.tree.JointActuator_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_joint_actuator" title="Permalink to this definition"></a></dt>
<dd><p>Returns a constant reference to the joint actuator with unique index
<code class="docutils literal notranslate"><span class="pre">actuator_index</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if actuator_index does not correspond to a joint</strong> – </p></li>
<li><p><strong>actuator in this tree.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_mutable_joint">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].get_mutable_joint"></span><span class="sig-name descname"><span class="pre">get_mutable_joint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">joint_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JointIndex" title="pydrake.multibody.tree.JointIndex"><span class="pre">pydrake.multibody.tree.JointIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Joint_" title="pydrake.multibody.tree.Joint_"><span class="pre">pydrake.multibody.tree.Joint_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_mutable_joint" title="Permalink to this definition"></a></dt>
<dd><p>Returns a mutable reference to the joint with unique index
<code class="docutils literal notranslate"><span class="pre">joint_index</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError when joint_index does not correspond to a joint</strong> – </p></li>
<li><p><strong>in this model.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_mutable_joint_actuator">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].get_mutable_joint_actuator"></span><span class="sig-name descname"><span class="pre">get_mutable_joint_actuator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">actuator_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JointActuatorIndex" title="pydrake.multibody.tree.JointActuatorIndex"><span class="pre">pydrake.multibody.tree.JointActuatorIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JointActuator_" title="pydrake.multibody.tree.JointActuator_"><span class="pre">pydrake.multibody.tree.JointActuator_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_mutable_joint_actuator" title="Permalink to this definition"></a></dt>
<dd><p>Returns a mutable reference to the joint actuator with unique index
<code class="docutils literal notranslate"><span class="pre">actuator_index</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if actuator_index does not correspond to a joint</strong> – </p></li>
<li><p><strong>actuator in this tree.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_net_actuation_output_port">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].get_net_actuation_output_port"></span><span class="sig-name descname"><span class="pre">get_net_actuation_output_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_net_actuation_output_port" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>get_net_actuation_output_port(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd]) -&gt; pydrake.systems.framework.OutputPort_[AutoDiffXd]</p></li>
</ol>
<p>Returns a constant reference to the output port that reports actuation
values applied through joint actuators. This output port is a vector
valued port. The actuation value for a particular actuator can be
found at offset JointActuator::input_start() in this vector. Models
that include PD controllers will include their contribution in this
port, refer to mbp_actuation “Actuation” for further details.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>PD controllers are not considered for actuators on locked joints,
see Joint::Lock(). Therefore they do not contribute to this port.</p>
</div>
<dl class="simple">
<dt>Precondition:</dt><dd><p>Finalize() was already called on <code class="docutils literal notranslate"><span class="pre">this</span></code> plant.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if called before Finalize</strong><strong>(</strong><strong>)</strong><strong></strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>get_net_actuation_output_port(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; pydrake.systems.framework.OutputPort_[AutoDiffXd]</p></li>
</ol>
<p>Returns a constant reference to the output port that reports actuation
values applied through joint actuators, for a specific model instance.
Models that include PD controllers will include their contribution in
this port, refer to mbp_actuation “Actuation” for further details.
This is a vector valued port with entries ordered by monotonically
increasing JointActuatorIndex within <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>.</p>
<p>Every model instance in <code class="docutils literal notranslate"><span class="pre">this</span></code> plant model has a net actuation
output port, even if zero sized (for model instance with no
actuators).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>PD controllers are not considered for actuators on locked joints,
see Joint::Lock(). Therefore they do not contribute to this port.</p>
</div>
<dl class="simple">
<dt>Precondition:</dt><dd><p>Finalize() was already called on <code class="docutils literal notranslate"><span class="pre">this</span></code> plant.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if called before Finalize</strong><strong>(</strong><strong>)</strong><strong></strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_reaction_forces_output_port">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].get_reaction_forces_output_port"></span><span class="sig-name descname"><span class="pre">get_reaction_forces_output_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.OutputPort_" title="pydrake.systems.framework.OutputPort_"><span class="pre">pydrake.systems.framework.OutputPort_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_reaction_forces_output_port" title="Permalink to this definition"></a></dt>
<dd><p>Returns the port for joint reaction forces. A Joint models the
kinematical relationship which characterizes the possible relative
motion between two bodies. In Drake, a joint connects a frame <code class="docutils literal notranslate"><span class="pre">Jp</span></code>
on <em>parent</em> body P with a frame <code class="docutils literal notranslate"><span class="pre">Jc</span></code> on a <em>child</em> body C. This usage
of the terms <em>parent</em> and <em>child</em> is just a convention and implies
nothing about the inboard-outboard relationship between the bodies.
Since a Joint imposes a kinematical relationship which characterizes
the possible relative motion between frames Jp and Jc, reaction forces
on each body are established. That is, we could cut the model at the
joint and replace it with equivalent forces equal to these reaction
forces in order to attain the same motions of the mechanical system.</p>
<p>This output port allows to evaluate the reaction force <code class="docutils literal notranslate"><span class="pre">F_CJc_Jc</span></code> on
the <em>child</em> body C, at <code class="docutils literal notranslate"><span class="pre">Jc</span></code>, and expressed in Jc for all joints in
the model. This port evaluates to a vector of type
std::vector&lt;SpatialForce&lt;T&gt;&gt; and size num_joints() indexed by
JointIndex, see Joint::index(). Each entry corresponds to the spatial
force <code class="docutils literal notranslate"><span class="pre">F_CJc_Jc</span></code> applied on the joint’s child body C
(Joint::child_body()), at the joint’s child frame <code class="docutils literal notranslate"><span class="pre">Jc</span></code>
(Joint::frame_on_child()) and expressed in frame <code class="docutils literal notranslate"><span class="pre">Jc</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_sap_near_rigid_threshold">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].get_sap_near_rigid_threshold"></span><span class="sig-name descname"><span class="pre">get_sap_near_rigid_threshold</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_sap_near_rigid_threshold" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the SAP near rigid regime threshold.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>See set_sap_near_rigid_threshold().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_source_id">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].get_source_id"></span><span class="sig-name descname"><span class="pre">get_source_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.SourceId" title="pydrake.geometry.SourceId"><span class="pre">pydrake.geometry.SourceId</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_source_id" title="Permalink to this definition"></a></dt>
<dd><p>Returns the unique id identifying <code class="docutils literal notranslate"><span class="pre">this</span></code> plant as a source for a
SceneGraph. Returns <code class="docutils literal notranslate"><span class="pre">nullopt</span></code> if <code class="docutils literal notranslate"><span class="pre">this</span></code> plant did not register any
geometry. This method can be called at any time during the lifetime of
<code class="docutils literal notranslate"><span class="pre">this</span></code> plant to query if <code class="docutils literal notranslate"><span class="pre">this</span></code> plant has been registered with a
SceneGraph, either pre- or post-finalize, see Finalize(). However, a
geometry::SourceId is only assigned once at the first call of any of
this plant’s geometry registration methods, and it does not change
after that. Post-finalize calls will always return the same value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_state_output_port">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].get_state_output_port"></span><span class="sig-name descname"><span class="pre">get_state_output_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.get_state_output_port" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>get_state_output_port(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd]) -&gt; pydrake.systems.framework.OutputPort_[AutoDiffXd]</p></li>
</ol>
<p>Returns a constant reference to the output port for the multibody
state x = [q, v] of the model.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>Finalize() was already called on <code class="docutils literal notranslate"><span class="pre">this</span></code> plant.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if called before Finalize</strong><strong>(</strong><strong>)</strong><strong></strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>get_state_output_port(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; pydrake.systems.framework.OutputPort_[AutoDiffXd]</p></li>
</ol>
<p>Returns a constant reference to the output port for the state xᵢ = [qᵢ
vᵢ] of model instance i. (Here qᵢ ⊆ q and vᵢ ⊆ v.)</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>Finalize() was already called on <code class="docutils literal notranslate"><span class="pre">this</span></code> plant.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if called before Finalize</strong><strong>(</strong><strong>)</strong><strong></strong> – </p></li>
<li><p><strong>RuntimeError if the model instance does not exist.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetAccelerationLowerLimits">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetAccelerationLowerLimits"></span><span class="sig-name descname"><span class="pre">GetAccelerationLowerLimits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetAccelerationLowerLimits" title="Permalink to this definition"></a></dt>
<dd><p>Returns a vector of size <code class="docutils literal notranslate"><span class="pre">num_velocities()</span></code> containing the lower
acceleration limits for every generalized velocity coordinate. These
include joint and free body coordinates. Any unbounded or unspecified
limits will be -infinity.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetAccelerationUpperLimits">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetAccelerationUpperLimits"></span><span class="sig-name descname"><span class="pre">GetAccelerationUpperLimits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetAccelerationUpperLimits" title="Permalink to this definition"></a></dt>
<dd><p>Upper limit analog of GetAccelerationsLowerLimits(), where any
unbounded or unspecified limits will be +infinity.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>GetAccelerationLowerLimits() for more information.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetActuatedJointIndices">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetActuatedJointIndices"></span><span class="sig-name descname"><span class="pre">GetActuatedJointIndices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JointIndex" title="pydrake.multibody.tree.JointIndex"><span class="pre">pydrake.multibody.tree.JointIndex</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetActuatedJointIndices" title="Permalink to this definition"></a></dt>
<dd><p>Returns a list of actuated joint indices associated with
<code class="docutils literal notranslate"><span class="pre">model_instance</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetActuatorNames">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetActuatorNames"></span><span class="sig-name descname"><span class="pre">GetActuatorNames</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetActuatorNames" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetActuatorNames(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], add_model_instance_prefix: bool = True) -&gt; List[str]</p></li>
</ol>
<p>Returns a list of string names corresponding to each element of the
actuation vector. These strings take the form
<code class="docutils literal notranslate"><span class="pre">{model_instance_name}_{joint_actuator_name}</span></code>, but the prefix may
optionally be withheld using <code class="docutils literal notranslate"><span class="pre">add_model_instance_prefix</span></code>.</p>
<p>The returned names are guaranteed to be unique if
<code class="docutils literal notranslate"><span class="pre">add_model_instance_prefix</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code> (the default).</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if the plant is not finalized.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>GetActuatorNames(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], model_instance: pydrake.multibody.tree.ModelInstanceIndex, add_model_instance_prefix: bool = False) -&gt; List[str]</p></li>
</ol>
<p>Returns a list of string names corresponding to each element of the
actuation vector. These strings take the form
<code class="docutils literal notranslate"><span class="pre">{model_instance_name}_{joint_actuator_name}</span></code>, but the prefix may
optionally be withheld using <code class="docutils literal notranslate"><span class="pre">add_model_instance_prefix</span></code>.</p>
<p>The returned names are guaranteed to be unique.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the plant is not finalized</strong><strong> or </strong><strong>if the</strong> – </p></li>
<li><p><strong>model_instance` is invalid</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetBodiesKinematicallyAffectedBy">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetBodiesKinematicallyAffectedBy"></span><span class="sig-name descname"><span class="pre">GetBodiesKinematicallyAffectedBy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">joint_indexes</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JointIndex" title="pydrake.multibody.tree.JointIndex"><span class="pre">pydrake.multibody.tree.JointIndex</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.BodyIndex" title="pydrake.multibody.tree.BodyIndex"><span class="pre">pydrake.multibody.tree.BodyIndex</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetBodiesKinematicallyAffectedBy" title="Permalink to this definition"></a></dt>
<dd><p>Returns all bodies whose kinematics are transitively affected by the
given vector of joints. The affected bodies are returned in increasing
order of body indexes. Note that this is a kinematic relationship
rather than a dynamic one. For example, if one of the inboard joints
is a free (6dof) joint, the kinematic influence is still felt even
though dynamically there would be no influence on the outboard body.
This function can be only be called post-finalize, see Finalize().</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if any of the given joint has an invalid index</strong><strong>,</strong> – </p></li>
<li><p><strong>doesn't correspond to a mobilizer</strong><strong>, or </strong><strong>is welded.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetBodiesWeldedTo">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetBodiesWeldedTo"></span><span class="sig-name descname"><span class="pre">GetBodiesWeldedTo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody_" title="pydrake.multibody.tree.RigidBody_"><span class="pre">pydrake.multibody.tree.RigidBody_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody_" title="pydrake.multibody.tree.RigidBody_"><span class="pre">pydrake.multibody.tree.RigidBody_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetBodiesWeldedTo" title="Permalink to this definition"></a></dt>
<dd><p>Returns all bodies that are transitively welded, or rigidly affixed,
to <code class="docutils literal notranslate"><span class="pre">body</span></code>, per these two definitions:</p>
<ol class="arabic simple">
<li><p>A body is always considered welded to itself.</p></li>
</ol>
<p>2. Two unique bodies are considered welded together exclusively by the
presence of a weld joint, not by other constructs that prevent mobility
(e.g. constraints).</p>
<p>This method can be called at any time during the lifetime of <code class="docutils literal notranslate"><span class="pre">this</span></code>
plant, either pre- or post-finalize, see Finalize().</p>
<p>Meant to be used with <code class="docutils literal notranslate"><span class="pre">CollectRegisteredGeometries</span></code>.</p>
<p>The following example demonstrates filtering collisions between all
bodies rigidly affixed to a door (which could be moving) and all
bodies rigidly affixed to the world:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">GeometrySet</span><span class="w"> </span><span class="n">g_world</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">plant</span><span class="p">.</span><span class="n">CollectRegisteredGeometries</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">plant</span><span class="p">.</span><span class="n">GetBodiesWeldedTo</span><span class="p">(</span><span class="n">plant</span><span class="p">.</span><span class="n">world_body</span><span class="p">()));</span><span class="w"></span>
<span class="n">GeometrySet</span><span class="w"> </span><span class="n">g_door</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">plant</span><span class="p">.</span><span class="n">CollectRegisteredGeometries</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">plant</span><span class="p">.</span><span class="n">GetBodiesWeldedTo</span><span class="p">(</span><span class="n">plant</span><span class="p">.</span><span class="n">GetBodyByName</span><span class="p">(</span><span class="s">&quot;door&quot;</span><span class="p">)));</span><span class="w"></span>
<span class="n">scene_graph</span><span class="p">.</span><span class="n">ExcludeCollisionsBetweeen</span><span class="p">(</span><span class="n">g_world</span><span class="p">,</span><span class="w"> </span><span class="n">g_door</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</details><div class="admonition note">
<p class="admonition-title">Note</p>
<p>Usages akin to this example may introduce redundant collision
filtering; this will not have a functional impact, but may have a
minor performance impact.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>all bodies rigidly fixed to <code class="docutils literal notranslate"><span class="pre">body</span></code>. This does not return the
bodies in any prescribed order.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>RuntimeError if body is not part of this plant.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetBodyByName">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetBodyByName"></span><span class="sig-name descname"><span class="pre">GetBodyByName</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetBodyByName" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetBodyByName(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], name: str) -&gt; pydrake.multibody.tree.RigidBody_[AutoDiffXd]</p></li>
</ol>
<p>Returns a constant reference to a body that is identified by the
string <code class="docutils literal notranslate"><span class="pre">name</span></code> in <code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if there is no body with the requested name.</strong> – </p></li>
<li><p><strong>RuntimeError if the body name occurs in multiple model instances.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>HasBodyNamed() to query if there exists a body in <code class="docutils literal notranslate"><span class="pre">this</span></code>
MultibodyPlant with a given specified name.</p>
</div>
<ol class="arabic simple" start="2">
<li><p>GetBodyByName(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; pydrake.multibody.tree.RigidBody_[AutoDiffXd]</p></li>
</ol>
<p>Returns a constant reference to the body that is uniquely identified
by the string <code class="docutils literal notranslate"><span class="pre">name</span></code> and <code class="docutils literal notranslate"><span class="pre">model_instance</span></code> in <code class="docutils literal notranslate"><span class="pre">this</span></code>
MultibodyPlant.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if there is no body with the requested name.</strong> – </p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>HasBodyNamed() to query if there exists a body in <code class="docutils literal notranslate"><span class="pre">this</span></code>
MultibodyPlant with a given specified name.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetBodyFrameIdIfExists">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetBodyFrameIdIfExists"></span><span class="sig-name descname"><span class="pre">GetBodyFrameIdIfExists</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.BodyIndex" title="pydrake.multibody.tree.BodyIndex"><span class="pre">pydrake.multibody.tree.BodyIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.FrameId" title="pydrake.geometry.FrameId"><span class="pre">pydrake.geometry.FrameId</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetBodyFrameIdIfExists" title="Permalink to this definition"></a></dt>
<dd><p>If the body with <code class="docutils literal notranslate"><span class="pre">body_index</span></code> belongs to the called plant, it
returns the geometry::FrameId associated with it. Otherwise, it
returns nullopt.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetBodyFrameIdOrThrow">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetBodyFrameIdOrThrow"></span><span class="sig-name descname"><span class="pre">GetBodyFrameIdOrThrow</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.BodyIndex" title="pydrake.multibody.tree.BodyIndex"><span class="pre">pydrake.multibody.tree.BodyIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.FrameId" title="pydrake.geometry.FrameId"><span class="pre">pydrake.geometry.FrameId</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetBodyFrameIdOrThrow" title="Permalink to this definition"></a></dt>
<dd><p>If the body with <code class="docutils literal notranslate"><span class="pre">body_index</span></code> belongs to the called plant, it
returns the geometry::FrameId associated with it. Otherwise this
method throws an exception.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the called plant does not have the body indicated</strong> – </p></li>
<li><p><strong>by body_index.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetBodyFromFrameId">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetBodyFromFrameId"></span><span class="sig-name descname"><span class="pre">GetBodyFromFrameId</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.FrameId" title="pydrake.geometry.FrameId"><span class="pre">pydrake.geometry.FrameId</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody_" title="pydrake.multibody.tree.RigidBody_"><span class="pre">pydrake.multibody.tree.RigidBody_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetBodyFromFrameId" title="Permalink to this definition"></a></dt>
<dd><p>Given a geometry frame identifier, returns a pointer to the body
associated with that id (nullptr if there is no such body).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetBodyIndices">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetBodyIndices"></span><span class="sig-name descname"><span class="pre">GetBodyIndices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.BodyIndex" title="pydrake.multibody.tree.BodyIndex"><span class="pre">pydrake.multibody.tree.BodyIndex</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetBodyIndices" title="Permalink to this definition"></a></dt>
<dd><p>Returns a list of body indices associated with <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetCollisionGeometriesForBody">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetCollisionGeometriesForBody"></span><span class="sig-name descname"><span class="pre">GetCollisionGeometriesForBody</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody_" title="pydrake.multibody.tree.RigidBody_"><span class="pre">pydrake.multibody.tree.RigidBody_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.GeometryId" title="pydrake.geometry.GeometryId"><span class="pre">pydrake.geometry.GeometryId</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetCollisionGeometriesForBody" title="Permalink to this definition"></a></dt>
<dd><p>Returns an array of GeometryId’s identifying the different contact
geometries for <code class="docutils literal notranslate"><span class="pre">body</span></code> previously registered with a SceneGraph.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method can be called at any time during the lifetime of
<code class="docutils literal notranslate"><span class="pre">this</span></code> plant, either pre- or post-finalize, see Finalize().
Post-finalize calls will always return the same value.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>RegisterCollisionGeometry(), Finalize()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetConstraintActiveStatus">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetConstraintActiveStatus"></span><span class="sig-name descname"><span class="pre">GetConstraintActiveStatus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">id</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.MultibodyConstraintId" title="pydrake.multibody.tree.MultibodyConstraintId"><span class="pre">pydrake.multibody.tree.MultibodyConstraintId</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetConstraintActiveStatus" title="Permalink to this definition"></a></dt>
<dd><p>Returns the active status of the constraint given by <code class="docutils literal notranslate"><span class="pre">id</span></code> in
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the MultibodyPlant has not been finalized.</strong> – </p></li>
<li><p><strong>RuntimeError if id does not belong to any multibody constraint</strong> – </p></li>
<li><p><strong>in context.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetDefaultContactSurfaceRepresentation">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetDefaultContactSurfaceRepresentation"></span><em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">GetDefaultContactSurfaceRepresentation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">time_step</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.HydroelasticContactRepresentation" title="pydrake.geometry.HydroelasticContactRepresentation"><span class="pre">pydrake.geometry.HydroelasticContactRepresentation</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetDefaultContactSurfaceRepresentation" title="Permalink to this definition"></a></dt>
<dd><p>Return the default value for contact representation, given the desired
time step. Discrete systems default to use polygons; continuous
systems default to use triangles.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetDefaultFreeBodyPose">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetDefaultFreeBodyPose"></span><span class="sig-name descname"><span class="pre">GetDefaultFreeBodyPose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody_" title="pydrake.multibody.tree.RigidBody_"><span class="pre">pydrake.multibody.tree.RigidBody_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.math.html#pydrake.math.RigidTransform" title="pydrake.math.RigidTransform"><span class="pre">pydrake.math.RigidTransform</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetDefaultFreeBodyPose" title="Permalink to this definition"></a></dt>
<dd><p>Gets the default pose of <code class="docutils literal notranslate"><span class="pre">body</span></code> as set by SetDefaultFreeBodyPose().
If no pose is specified for the body, returns the identity pose.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body</span></code>:</dt><dd><p>RigidBody whose default pose will be retrieved.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetDefaultPositions">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetDefaultPositions"></span><span class="sig-name descname"><span class="pre">GetDefaultPositions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetDefaultPositions" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetDefaultPositions(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd]) -&gt; numpy.ndarray[object[m, 1]]</p></li>
</ol>
<p>Gets the default positions for the plant, which can be changed via
SetDefaultPositions().</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if the plant is not finalized.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>GetDefaultPositions(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; numpy.ndarray[object[m, 1]]</p></li>
</ol>
<p>Gets the default positions for the plant for a given model instance,
which can be changed via SetDefaultPositions().</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the plant is not finalized</strong><strong>, or </strong><strong>if the</strong> – </p></li>
<li><p><strong>model_instance is invalid</strong><strong>,</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetEffortLowerLimits">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetEffortLowerLimits"></span><span class="sig-name descname"><span class="pre">GetEffortLowerLimits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetEffortLowerLimits" title="Permalink to this definition"></a></dt>
<dd><p>Returns a vector of size <code class="docutils literal notranslate"><span class="pre">num_actuated_dofs()</span></code> containing the lower
effort limits for every actuator. Any unbounded or unspecified limits
will be -∞. The returned vector is indexed by JointActuatorIndex, see
JointActuator::index().</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>GetEffortUpperLimits()</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetEffortUpperLimits">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetEffortUpperLimits"></span><span class="sig-name descname"><span class="pre">GetEffortUpperLimits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetEffortUpperLimits" title="Permalink to this definition"></a></dt>
<dd><p>Returns a vector of size <code class="docutils literal notranslate"><span class="pre">num_actuated_dofs()</span></code> containing the upper
effort limits for every actuator. Any unbounded or unspecified limits
will be +∞. The returned vector is indexed by JointActuatorIndex, see
JointActuator::index().</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>GetEffortLowerLimits()</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetFloatingBaseBodies">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetFloatingBaseBodies"></span><span class="sig-name descname"><span class="pre">GetFloatingBaseBodies</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Set</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.BodyIndex" title="pydrake.multibody.tree.BodyIndex"><span class="pre">pydrake.multibody.tree.BodyIndex</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetFloatingBaseBodies" title="Permalink to this definition"></a></dt>
<dd><p>Returns the set of body indexes corresponding to the free (floating)
bodies in the model, in no particular order.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize</strong><strong>, </strong><strong>see Finalize</strong><strong>(</strong><strong>)</strong><strong></strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetFrameByName">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetFrameByName"></span><span class="sig-name descname"><span class="pre">GetFrameByName</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetFrameByName" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetFrameByName(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], name: str) -&gt; pydrake.multibody.tree.Frame_[AutoDiffXd]</p></li>
</ol>
<p>Returns a constant reference to a frame that is identified by the
string <code class="docutils literal notranslate"><span class="pre">name</span></code> in <code class="docutils literal notranslate"><span class="pre">this</span></code> model.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if there is no frame with the requested name.</strong> – </p></li>
<li><p><strong>RuntimeError if the frame name occurs in multiple model instances.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>HasFrameNamed() to query if there exists a frame in <code class="docutils literal notranslate"><span class="pre">this</span></code> model
with a given specified name.</p>
</div>
<ol class="arabic simple" start="2">
<li><p>GetFrameByName(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; pydrake.multibody.tree.Frame_[AutoDiffXd]</p></li>
</ol>
<p>Returns a constant reference to the frame that is uniquely identified
by the string <code class="docutils literal notranslate"><span class="pre">name</span></code> in <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if there is no frame with the requested name.</strong> – </p></li>
<li><p><strong>RuntimeError if model_instance is not valid for this model.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>HasFrameNamed() to query if there exists a frame in <code class="docutils literal notranslate"><span class="pre">this</span></code> model
with a given specified name.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetFrameIndices">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetFrameIndices"></span><span class="sig-name descname"><span class="pre">GetFrameIndices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.FrameIndex" title="pydrake.multibody.tree.FrameIndex"><span class="pre">pydrake.multibody.tree.FrameIndex</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetFrameIndices" title="Permalink to this definition"></a></dt>
<dd><p>Returns a list of frame indices associated with <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetFreeBodyPose">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetFreeBodyPose"></span><span class="sig-name descname"><span class="pre">GetFreeBodyPose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody_" title="pydrake.multibody.tree.RigidBody_"><span class="pre">pydrake.multibody.tree.RigidBody_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.math.html#pydrake.math.RigidTransform_" title="pydrake.math.RigidTransform_"><span class="pre">pydrake.math.RigidTransform_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetFreeBodyPose" title="Permalink to this definition"></a></dt>
<dd><p>Gets the pose of a given <code class="docutils literal notranslate"><span class="pre">body</span></code> in the world frame W.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In general getting the pose of a body in the model would involve
solving the kinematics. This method allows us to simplify this
process when we know the body is free in space.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if body is not a free body in the model.</strong> – </p></li>
<li><p><strong>RuntimeError if called pre-finalize.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetJointActuatorByName">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetJointActuatorByName"></span><span class="sig-name descname"><span class="pre">GetJointActuatorByName</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetJointActuatorByName" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetJointActuatorByName(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], name: str) -&gt; pydrake.multibody.tree.JointActuator_[AutoDiffXd]</p></li>
</ol>
<p>Returns a constant reference to an actuator that is identified by the
string <code class="docutils literal notranslate"><span class="pre">name</span></code> in <code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if there is no actuator with the requested name.</strong> – </p></li>
<li><p><strong>RuntimeError if the actuator name occurs in multiple model</strong> – </p></li>
<li><p><strong>instances.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>HasJointActuatorNamed() to query if there exists an actuator in
<code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant with a given specified name.</p>
</div>
<ol class="arabic simple" start="2">
<li><p>GetJointActuatorByName(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; pydrake.multibody.tree.JointActuator_[AutoDiffXd]</p></li>
</ol>
<p>Returns a constant reference to the actuator that is uniquely
identified by the string <code class="docutils literal notranslate"><span class="pre">name</span></code> and <code class="docutils literal notranslate"><span class="pre">model_instance</span></code> in <code class="docutils literal notranslate"><span class="pre">this</span></code>
MultibodyPlant.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if there is no actuator with the requested name.</strong> – </p></li>
<li><p><strong>RuntimeError if model_instance is not valid for this model.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>HasJointActuatorNamed() to query if there exists an actuator in
<code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant with a given specified name.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetJointActuatorIndices">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetJointActuatorIndices"></span><span class="sig-name descname"><span class="pre">GetJointActuatorIndices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetJointActuatorIndices" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetJointActuatorIndices(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd]) -&gt; List[pydrake.multibody.tree.JointActuatorIndex]</p></li>
</ol>
<p>Returns a list of all joint actuator indices. The vector is ordered by
monotonically increasing JointActuatorIndex, but the indexes will in
general not be consecutive due to actuators that were removed.</p>
<ol class="arabic simple" start="2">
<li><p>GetJointActuatorIndices(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; List[pydrake.multibody.tree.JointActuatorIndex]</p></li>
</ol>
<p>Returns a list of joint actuator indices associated with
<code class="docutils literal notranslate"><span class="pre">model_instance</span></code>. The vector is ordered by monotonically increasing
JointActuatorIndex.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetJointByName">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetJointByName"></span><span class="sig-name descname"><span class="pre">GetJointByName</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Joint_" title="pydrake.multibody.tree.Joint_"><span class="pre">pydrake.multibody.tree.Joint_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetJointByName" title="Permalink to this definition"></a></dt>
<dd><p>Returns a constant reference to a joint that is identified by the
string <code class="docutils literal notranslate"><span class="pre">name</span></code> in <code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant. If the optional template
argument is supplied, then the returned value is downcast to the
specified <code class="docutils literal notranslate"><span class="pre">JointType</span></code>.</p>
<dl class="simple">
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">JointType</span></code>:</dt><dd><p>The specific type of the Joint to be retrieved. It must be a
subclass of Joint.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the named joint is not of type JointType</strong><strong> or </strong><strong>if</strong> – </p></li>
<li><p><strong>there is no Joint with that name.</strong> – </p></li>
<li><p><strong>RuntimeError if model_instance is not valid for this model.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>HasJointNamed() to query if there exists a joint in <code class="docutils literal notranslate"><span class="pre">this</span></code>
MultibodyPlant with a given specified name.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetJointIndices">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetJointIndices"></span><span class="sig-name descname"><span class="pre">GetJointIndices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetJointIndices" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetJointIndices(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd]) -&gt; List[pydrake.multibody.tree.JointIndex]</p></li>
</ol>
<p>Returns a list of all joint indices. The vector is ordered by
monotonically increasing JointIndex, but the indexes will in general
not be consecutive due to joints that were removed.</p>
<ol class="arabic simple" start="2">
<li><p>GetJointIndices(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; List[pydrake.multibody.tree.JointIndex]</p></li>
</ol>
<p>Returns a list of joint indices associated with <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetModelInstanceByName">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetModelInstanceByName"></span><span class="sig-name descname"><span class="pre">GetModelInstanceByName</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetModelInstanceByName" title="Permalink to this definition"></a></dt>
<dd><p>Returns the index to the model instance that is uniquely identified by
the string <code class="docutils literal notranslate"><span class="pre">name</span></code> in <code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if there is no instance with the requested name.</strong> – </p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>HasModelInstanceNamed() to query if there exists an instance in
<code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant with a given specified name.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetModelInstanceName">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetModelInstanceName"></span><span class="sig-name descname"><span class="pre">GetModelInstanceName</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">str</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetModelInstanceName" title="Permalink to this definition"></a></dt>
<dd><p>Returns the name of a <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError when model_instance does not correspond to a</strong> – </p></li>
<li><p><strong>model in this model.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetMutableJointByName">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetMutableJointByName"></span><span class="sig-name descname"><span class="pre">GetMutableJointByName</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Joint_" title="pydrake.multibody.tree.Joint_"><span class="pre">pydrake.multibody.tree.Joint_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetMutableJointByName" title="Permalink to this definition"></a></dt>
<dd><p>Returns a constant reference to a joint that is identified by the
string <code class="docutils literal notranslate"><span class="pre">name</span></code> in <code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant. If the optional template
argument is supplied, then the returned value is downcast to the
specified <code class="docutils literal notranslate"><span class="pre">JointType</span></code>.</p>
<dl class="simple">
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">JointType</span></code>:</dt><dd><p>The specific type of the Joint to be retrieved. It must be a
subclass of Joint.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the named joint is not of type JointType</strong><strong> or </strong><strong>if</strong> – </p></li>
<li><p><strong>there is no Joint with that name.</strong> – </p></li>
<li><p><strong>RuntimeError if model_instance is not valid for this model.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>HasJointNamed() to query if there exists a joint in <code class="docutils literal notranslate"><span class="pre">this</span></code>
MultibodyPlant with a given specified name.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetPositionLowerLimits">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetPositionLowerLimits"></span><span class="sig-name descname"><span class="pre">GetPositionLowerLimits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetPositionLowerLimits" title="Permalink to this definition"></a></dt>
<dd><p>Returns a vector of size <code class="docutils literal notranslate"><span class="pre">num_positions()</span></code> containing the lower
position limits for every generalized position coordinate. These
include joint and free body coordinates. Any unbounded or unspecified
limits will be -infinity.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetPositionNames">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetPositionNames"></span><span class="sig-name descname"><span class="pre">GetPositionNames</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetPositionNames" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetPositionNames(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], add_model_instance_prefix: bool = True, always_add_suffix: bool = True) -&gt; List[str]</p></li>
</ol>
<p>Returns a list of string names corresponding to each element of the
position vector. These strings take the form
<code class="docutils literal notranslate"><span class="pre">{model_instance_name}_{joint_name}_{joint_position_suffix}</span></code>, but
the prefix and suffix may optionally be withheld using
<code class="docutils literal notranslate"><span class="pre">add_model_instance_prefix</span></code> and <code class="docutils literal notranslate"><span class="pre">always_add_suffix</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">always_add_suffix</span></code>:</dt><dd><p>(optional). If true, then the suffix is always added. If false,
then the suffix is only added for joints that have more than one
position (in this case, not adding would lead to ambiguity).</p>
</dd>
</dl>
<p>The returned names are guaranteed to be unique if
<code class="docutils literal notranslate"><span class="pre">add_model_instance_prefix</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code> (the default).</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if the plant is not finalized.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>GetPositionNames(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], model_instance: pydrake.multibody.tree.ModelInstanceIndex, add_model_instance_prefix: bool = False, always_add_suffix: bool = True) -&gt; List[str]</p></li>
</ol>
<p>Returns a list of string names corresponding to each element of the
position vector. These strings take the form
<code class="docutils literal notranslate"><span class="pre">{model_instance_name}_{joint_name}_{joint_position_suffix}</span></code>, but
the prefix and suffix may optionally be withheld using
<code class="docutils literal notranslate"><span class="pre">add_model_instance_prefix</span></code> and <code class="docutils literal notranslate"><span class="pre">always_add_suffix</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">always_add_suffix</span></code>:</dt><dd><p>(optional). If true, then the suffix is always added. If false,
then the suffix is only added for joints that have more than one
position (in this case, not adding would lead to ambiguity).</p>
</dd>
</dl>
<p>The returned names are guaranteed to be unique.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the plant is not finalized</strong><strong> or </strong><strong>if the</strong> – </p></li>
<li><p><strong>model_instance` is invalid</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetPositions">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetPositions"></span><span class="sig-name descname"><span class="pre">GetPositions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetPositions" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetPositions(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd]) -&gt; numpy.ndarray[object[m, 1]]</p></li>
</ol>
<p>Returns a const vector reference to the vector of generalized
positions q in a given Context.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method returns a reference to existing data, exhibits
constant i.e., O(1) time complexity, and runs very quickly.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if context does not correspond to the Context for</strong> – </p></li>
<li><p><strong>a multibody model.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>GetPositions(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; numpy.ndarray[object[m, 1]]</p></li>
</ol>
<p>Returns a vector containing the generalized positions q of a specified
model instance in a given Context.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Returns a dense vector of dimension
<code class="docutils literal notranslate"><span class="pre">num_positions(model_instance)</span></code> associated with
<code class="docutils literal notranslate"><span class="pre">model_instance</span></code> by copying from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if context does not correspond to the Context for</strong> – </p></li>
<li><p><strong>a multibody model</strong><strong> or </strong><strong>model_instance is invalid.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li><p>GetPositions(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd]) -&gt; numpy.ndarray[object[m, 1]]</p></li>
</ol>
<p>Returns a const vector reference to the vector of generalized
positions q in a given Context.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method returns a reference to existing data, exhibits
constant i.e., O(1) time complexity, and runs very quickly.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if context does not correspond to the Context for</strong> – </p></li>
<li><p><strong>a multibody model.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="4">
<li><p>GetPositions(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; numpy.ndarray[object[m, 1]]</p></li>
</ol>
<p>Returns a vector containing the generalized positions q of a specified
model instance in a given Context.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Returns a dense vector of dimension
<code class="docutils literal notranslate"><span class="pre">num_positions(model_instance)</span></code> associated with
<code class="docutils literal notranslate"><span class="pre">model_instance</span></code> by copying from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if context does not correspond to the Context for</strong> – </p></li>
<li><p><strong>a multibody model</strong><strong> or </strong><strong>model_instance is invalid.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetPositionsAndVelocities">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetPositionsAndVelocities"></span><span class="sig-name descname"><span class="pre">GetPositionsAndVelocities</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetPositionsAndVelocities" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetPositionsAndVelocities(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd]) -&gt; numpy.ndarray[object[m, 1]]</p></li>
</ol>
<p>Returns a const vector reference <code class="docutils literal notranslate"><span class="pre">[q;</span> <span class="pre">v]</span></code> to the generalized
positions q and generalized velocities v in a given Context.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method returns a reference to existing data, exhibits
constant i.e., O(1) time complexity, and runs very quickly.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if context does not correspond to the Context for</strong> – </p></li>
<li><p><strong>a multibody model.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>GetPositionsAndVelocities(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; numpy.ndarray[object[m, 1]]</p></li>
</ol>
<p>Returns a vector <code class="docutils literal notranslate"><span class="pre">[q;</span> <span class="pre">v]</span></code> containing the generalized positions q and
generalized velocities v of a specified model instance in a given
Context.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Returns a dense vector of dimension
<code class="docutils literal notranslate"><span class="pre">num_positions(model_instance)</span> <span class="pre">+</span> <span class="pre">num_velocities(model_instance)</span></code>
associated with <code class="docutils literal notranslate"><span class="pre">model_instance</span></code> by copying from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if context does not correspond to the Context for</strong> – </p></li>
<li><p><strong>a multibody model</strong><strong> or </strong><strong>model_instance is invalid.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetPositionsFromArray">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetPositionsFromArray"></span><span class="sig-name descname"><span class="pre">GetPositionsFromArray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetPositionsFromArray" title="Permalink to this definition"></a></dt>
<dd><p>Returns a vector of generalized positions for <code class="docutils literal notranslate"><span class="pre">model_instance</span></code> from
a vector <code class="docutils literal notranslate"><span class="pre">q_array</span></code> of generalized positions for the entire model
model. This method throws an exception if <code class="docutils literal notranslate"><span class="pre">q</span></code> is not of size
MultibodyPlant::num_positions().</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetPositionUpperLimits">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetPositionUpperLimits"></span><span class="sig-name descname"><span class="pre">GetPositionUpperLimits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetPositionUpperLimits" title="Permalink to this definition"></a></dt>
<dd><p>Upper limit analog of GetPositionLowerLimits(), where any unbounded or
unspecified limits will be +infinity.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>GetPositionLowerLimits() for more information.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetRigidBodyByName">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetRigidBodyByName"></span><span class="sig-name descname"><span class="pre">GetRigidBodyByName</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetRigidBodyByName" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetRigidBodyByName(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], name: str) -&gt; pydrake.multibody.tree.RigidBody_[AutoDiffXd]</p></li>
</ol>
<p>Returns a constant reference to a rigid body that is identified by the
string <code class="docutils literal notranslate"><span class="pre">name</span></code> in <code class="docutils literal notranslate"><span class="pre">this</span></code> model.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if there is no body with the requested name.</strong> – </p></li>
<li><p><strong>RuntimeError if the body name occurs in multiple model instances.</strong> – </p></li>
<li><p><strong>RuntimeError if the requested body is not a RigidBody.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>HasBodyNamed() to query if there exists a body in <code class="docutils literal notranslate"><span class="pre">this</span></code> model
with a given specified name.</p>
</div>
<ol class="arabic simple" start="2">
<li><p>GetRigidBodyByName(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; pydrake.multibody.tree.RigidBody_[AutoDiffXd]</p></li>
</ol>
<p>Returns a constant reference to the rigid body that is uniquely
identified by the string <code class="docutils literal notranslate"><span class="pre">name</span></code> in <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if there is no body with the requested name.</strong> – </p></li>
<li><p><strong>RuntimeError if the requested body is not a RigidBody.</strong> – </p></li>
<li><p><strong>RuntimeError if model_instance is not valid for this model.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>HasBodyNamed() to query if there exists a body in <code class="docutils literal notranslate"><span class="pre">this</span></code> model
with a given specified name.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetStateNames">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetStateNames"></span><span class="sig-name descname"><span class="pre">GetStateNames</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetStateNames" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetStateNames(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], add_model_instance_prefix: bool = True) -&gt; List[str]</p></li>
</ol>
<p>Returns a list of string names corresponding to each element of the
multibody state vector. These strings take the form
<code class="docutils literal notranslate"><span class="pre">{model_instance_name}_{joint_name}_{joint_position_suffix</span> <span class="pre">|</span>
<span class="pre">joint_velocity_suffix}</span></code>, but the prefix may optionally be withheld
using <code class="docutils literal notranslate"><span class="pre">add_model_instance_prefix</span></code>.</p>
<p>The returned names are guaranteed to be unique if
<code class="docutils literal notranslate"><span class="pre">add_model_instance_prefix</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code> (the default).</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if the plant is not finalized.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>GetStateNames(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], model_instance: pydrake.multibody.tree.ModelInstanceIndex, add_model_instance_prefix: bool = False) -&gt; List[str]</p></li>
</ol>
<p>Returns a list of string names corresponding to each element of the
multibody state vector. These strings take the form
<code class="docutils literal notranslate"><span class="pre">{model_instance_name}_{joint_name}_{joint_position_suffix</span> <span class="pre">|</span>
<span class="pre">joint_velocity_suffix}</span></code>, but the prefix may optionally be withheld
using <code class="docutils literal notranslate"><span class="pre">add_model_instance_prefix</span></code>.</p>
<p>The returned names are guaranteed to be unique.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the plant is not finalized</strong><strong> or </strong><strong>if the</strong> – </p></li>
<li><p><strong>model_instance` is invalid</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetTopologyGraphvizString">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetTopologyGraphvizString"></span><span class="sig-name descname"><span class="pre">GetTopologyGraphvizString</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">str</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetTopologyGraphvizString" title="Permalink to this definition"></a></dt>
<dd><p>Returns a Graphviz string describing the topology of this plant. To
render the string, use the Graphviz tool, <code class="docutils literal notranslate"><span class="pre">dot</span></code>.
<a class="reference external" href="http://www.graphviz.org/">http://www.graphviz.org/</a></p>
<p>Note: this method can be called either before or after <code class="docutils literal notranslate"><span class="pre">Finalize()</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetUniqueFreeBaseBodyOrThrow">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetUniqueFreeBaseBodyOrThrow"></span><span class="sig-name descname"><span class="pre">GetUniqueFreeBaseBodyOrThrow</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody_" title="pydrake.multibody.tree.RigidBody_"><span class="pre">pydrake.multibody.tree.RigidBody_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetUniqueFreeBaseBodyOrThrow" title="Permalink to this definition"></a></dt>
<dd><p>If there exists a unique base body that belongs to the model given by
<code class="docutils literal notranslate"><span class="pre">model_instance</span></code> and that unique base body is free (see
HasUniqueBaseBody()), return that free body. Throw an exception
otherwise.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if called pre-finalize.</strong> – </p></li>
<li><p><strong>RuntimeError if model_instance is not valid.</strong> – </p></li>
<li><p><strong>RuntimeError if HasUniqueFreeBaseBody</strong><strong>(</strong><strong>model_instance</strong><strong>) </strong><strong>== false.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetVelocities">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetVelocities"></span><span class="sig-name descname"><span class="pre">GetVelocities</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetVelocities" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetVelocities(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd]) -&gt; numpy.ndarray[object[m, 1]]</p></li>
</ol>
<p>Returns a const vector reference to the generalized velocities v in a
given Context.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method returns a reference to existing data, exhibits
constant i.e., O(1) time complexity, and runs very quickly.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if context does not correspond to the Context for</strong> – </p></li>
<li><p><strong>a multibody model.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>GetVelocities(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; numpy.ndarray[object[m, 1]]</p></li>
</ol>
<p>Returns a vector containing the generalized velocities v of a
specified model instance in a given Context.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>returns a dense vector of dimension
<code class="docutils literal notranslate"><span class="pre">num_velocities(model_instance)</span></code> associated with
<code class="docutils literal notranslate"><span class="pre">model_instance</span></code> by copying from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if context does not correspond to the Context for</strong> – </p></li>
<li><p><strong>a multibody model</strong><strong> or </strong><strong>model_instance is invalid.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li><p>GetVelocities(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd]) -&gt; numpy.ndarray[object[m, 1]]</p></li>
</ol>
<p>Returns a const vector reference to the generalized velocities v in a
given Context.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method returns a reference to existing data, exhibits
constant i.e., O(1) time complexity, and runs very quickly.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if context does not correspond to the Context for</strong> – </p></li>
<li><p><strong>a multibody model.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="4">
<li><p>GetVelocities(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; numpy.ndarray[object[m, 1]]</p></li>
</ol>
<p>Returns a vector containing the generalized velocities v of a
specified model instance in a given Context.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>returns a dense vector of dimension
<code class="docutils literal notranslate"><span class="pre">num_velocities(model_instance)</span></code> associated with
<code class="docutils literal notranslate"><span class="pre">model_instance</span></code> by copying from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if context does not correspond to the Context for</strong> – </p></li>
<li><p><strong>a multibody model</strong><strong> or </strong><strong>model_instance is invalid.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetVelocitiesFromArray">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetVelocitiesFromArray"></span><span class="sig-name descname"><span class="pre">GetVelocitiesFromArray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetVelocitiesFromArray" title="Permalink to this definition"></a></dt>
<dd><p>Returns a vector of generalized velocities for <code class="docutils literal notranslate"><span class="pre">model_instance</span></code> from
a vector <code class="docutils literal notranslate"><span class="pre">v</span></code> of generalized velocities for the entire MultibodyPlant
model. This method throws an exception if the input array is not of
size MultibodyPlant::num_velocities().</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetVelocityLowerLimits">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetVelocityLowerLimits"></span><span class="sig-name descname"><span class="pre">GetVelocityLowerLimits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetVelocityLowerLimits" title="Permalink to this definition"></a></dt>
<dd><p>Returns a vector of size <code class="docutils literal notranslate"><span class="pre">num_velocities()</span></code> containing the lower
velocity limits for every generalized velocity coordinate. These
include joint and free body coordinates. Any unbounded or unspecified
limits will be -infinity.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetVelocityNames">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetVelocityNames"></span><span class="sig-name descname"><span class="pre">GetVelocityNames</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetVelocityNames" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetVelocityNames(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], add_model_instance_prefix: bool = True, always_add_suffix: bool = True) -&gt; List[str]</p></li>
</ol>
<p>Returns a list of string names corresponding to each element of the
velocity vector. These strings take the form
<code class="docutils literal notranslate"><span class="pre">{model_instance_name}_{joint_name}_{joint_velocity_suffix}</span></code>, but
the prefix and suffix may optionally be withheld using
<code class="docutils literal notranslate"><span class="pre">add_model_instance_prefix</span></code> and <code class="docutils literal notranslate"><span class="pre">always_add_suffix</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">always_add_suffix</span></code>:</dt><dd><p>(optional). If true, then the suffix is always added. If false,
then the suffix is only added for joints that have more than one
position (in this case, not adding would lead to ambiguity).</p>
</dd>
</dl>
<p>The returned names are guaranteed to be unique if
<code class="docutils literal notranslate"><span class="pre">add_model_instance_prefix</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code> (the default).</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if the plant is not finalized.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>GetVelocityNames(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], model_instance: pydrake.multibody.tree.ModelInstanceIndex, add_model_instance_prefix: bool = False, always_add_suffix: bool = True) -&gt; List[str]</p></li>
</ol>
<p>Returns a list of string names corresponding to each element of the
velocity vector. These strings take the form
<code class="docutils literal notranslate"><span class="pre">{model_instance_name}_{joint_name}_{joint_velocity_suffix}</span></code>, but
the prefix and suffix may optionally be withheld using
<code class="docutils literal notranslate"><span class="pre">add_model_instance_prefix</span></code> and <code class="docutils literal notranslate"><span class="pre">always_add_suffix</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">always_add_suffix</span></code>:</dt><dd><p>(optional). If true, then the suffix is always added. If false,
then the suffix is only added for joints that have more than one
position (in this case, not adding would lead to ambiguity).</p>
</dd>
</dl>
<p>The returned names are guaranteed to be unique.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the plant is not finalized</strong><strong> or </strong><strong>if the</strong> – </p></li>
<li><p><strong>model_instance` is invalid</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetVelocityUpperLimits">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetVelocityUpperLimits"></span><span class="sig-name descname"><span class="pre">GetVelocityUpperLimits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetVelocityUpperLimits" title="Permalink to this definition"></a></dt>
<dd><p>Upper limit analog of GetVelocitysLowerLimits(), where any unbounded
or unspecified limits will be +infinity.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>GetVelocityLowerLimits() for more information.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetVisualGeometriesForBody">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetVisualGeometriesForBody"></span><span class="sig-name descname"><span class="pre">GetVisualGeometriesForBody</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody_" title="pydrake.multibody.tree.RigidBody_"><span class="pre">pydrake.multibody.tree.RigidBody_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.GeometryId" title="pydrake.geometry.GeometryId"><span class="pre">pydrake.geometry.GeometryId</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.GetVisualGeometriesForBody" title="Permalink to this definition"></a></dt>
<dd><p>Returns an array of GeometryId’s identifying the different visual
geometries for <code class="docutils literal notranslate"><span class="pre">body</span></code> previously registered with a SceneGraph.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method can be called at any time during the lifetime of
<code class="docutils literal notranslate"><span class="pre">this</span></code> plant, either pre- or post-finalize, see Finalize().
Post-finalize calls will always return the same value.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>RegisterVisualGeometry(), Finalize()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.gravity_field">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].gravity_field"></span><span class="sig-name descname"><span class="pre">gravity_field</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.UniformGravityFieldElement_" title="pydrake.multibody.tree.UniformGravityFieldElement_"><span class="pre">pydrake.multibody.tree.UniformGravityFieldElement_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.gravity_field" title="Permalink to this definition"></a></dt>
<dd><p>An accessor to the current gravity field.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.has_joint">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].has_joint"></span><span class="sig-name descname"><span class="pre">has_joint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">joint_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JointIndex" title="pydrake.multibody.tree.JointIndex"><span class="pre">pydrake.multibody.tree.JointIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.has_joint" title="Permalink to this definition"></a></dt>
<dd><p>Returns true if plant has a joint with unique index <code class="docutils literal notranslate"><span class="pre">joint_index</span></code>.
The value could be false if the joint was removed using RemoveJoint().</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.has_joint_actuator">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].has_joint_actuator"></span><span class="sig-name descname"><span class="pre">has_joint_actuator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">actuator_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JointActuatorIndex" title="pydrake.multibody.tree.JointActuatorIndex"><span class="pre">pydrake.multibody.tree.JointActuatorIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.has_joint_actuator" title="Permalink to this definition"></a></dt>
<dd><p>Returns true if plant has a joint actuator with unique index
<code class="docutils literal notranslate"><span class="pre">actuator_index</span></code>. The value could be false if the actuator was
removed using RemoveJointActuator().</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.HasBodyNamed">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].HasBodyNamed"></span><span class="sig-name descname"><span class="pre">HasBodyNamed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.HasBodyNamed" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>HasBodyNamed(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], name: str) -&gt; bool</p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if a body named <code class="docutils literal notranslate"><span class="pre">name</span></code> was added to the MultibodyPlant.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddRigidBody().</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if the body name occurs in multiple model instances.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>HasBodyNamed(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; bool</p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if a body named <code class="docutils literal notranslate"><span class="pre">name</span></code> was added to the MultibodyPlant
in <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddRigidBody().</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if model_instance is not valid for this model.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.HasFrameNamed">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].HasFrameNamed"></span><span class="sig-name descname"><span class="pre">HasFrameNamed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.HasFrameNamed" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>HasFrameNamed(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], name: str) -&gt; bool</p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if a frame named <code class="docutils literal notranslate"><span class="pre">name</span></code> was added to the model.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddFrame().</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if the frame name occurs in multiple model instances.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>HasFrameNamed(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; bool</p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if a frame named <code class="docutils literal notranslate"><span class="pre">name</span></code> was added to
<code class="docutils literal notranslate"><span class="pre">model_instance</span></code>.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddFrame().</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if model_instance is not valid for this model.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.HasJointActuatorNamed">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].HasJointActuatorNamed"></span><span class="sig-name descname"><span class="pre">HasJointActuatorNamed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.HasJointActuatorNamed" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>HasJointActuatorNamed(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], name: str) -&gt; bool</p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if an actuator named <code class="docutils literal notranslate"><span class="pre">name</span></code> was added to this model.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddJointActuator().</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the actuator name occurs in multiple model</strong> – </p></li>
<li><p><strong>instances.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>HasJointActuatorNamed(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; bool</p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if an actuator named <code class="docutils literal notranslate"><span class="pre">name</span></code> was added to
<code class="docutils literal notranslate"><span class="pre">model_instance</span></code>.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddJointActuator().</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if model_instance is not valid for this model.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.HasJointNamed">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].HasJointNamed"></span><span class="sig-name descname"><span class="pre">HasJointNamed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.HasJointNamed" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>HasJointNamed(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], name: str) -&gt; bool</p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if a joint named <code class="docutils literal notranslate"><span class="pre">name</span></code> was added to this model.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddJoint().</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if the joint name occurs in multiple model instances.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>HasJointNamed(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; bool</p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if a joint named <code class="docutils literal notranslate"><span class="pre">name</span></code> was added to
<code class="docutils literal notranslate"><span class="pre">model_instance</span></code>.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddJoint().</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if model_instance is not valid for this model.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.HasModelInstanceNamed">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].HasModelInstanceNamed"></span><span class="sig-name descname"><span class="pre">HasModelInstanceNamed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.HasModelInstanceNamed" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if a model instance named <code class="docutils literal notranslate"><span class="pre">name</span></code> was added to this
model.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddModelInstance().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.HasUniqueFreeBaseBody">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].HasUniqueFreeBaseBody"></span><span class="sig-name descname"><span class="pre">HasUniqueFreeBaseBody</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.HasUniqueFreeBaseBody" title="Permalink to this definition"></a></dt>
<dd><p>Return true if there exists a unique base body in the model given by
<code class="docutils literal notranslate"><span class="pre">model_instance</span></code> and that unique base body is free.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if called pre-finalize.</strong> – </p></li>
<li><p><strong>RuntimeError if model_instance is not valid.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.is_finalized">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].is_finalized"></span><span class="sig-name descname"><span class="pre">is_finalized</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.is_finalized" title="Permalink to this definition"></a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if this MultibodyPlant was finalized with a call to
Finalize().</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>Finalize().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.is_gravity_enabled">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].is_gravity_enabled"></span><span class="sig-name descname"><span class="pre">is_gravity_enabled</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.is_gravity_enabled" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> iff gravity is enabled for <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>set_gravity_enabled().</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if the model instance is invalid.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.IsVelocityEqualToQDot">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].IsVelocityEqualToQDot"></span><span class="sig-name descname"><span class="pre">IsVelocityEqualToQDot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.IsVelocityEqualToQDot" title="Permalink to this definition"></a></dt>
<dd><p>Returns true iff the generalized velocity v is exactly the time
derivative q̇ of the generalized coordinates q. In this case
MapQDotToVelocity() and MapVelocityToQDot() implement the identity
map. This method is, in the worst case, O(n), where n is the number of
joints.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.MakeActuationMatrix">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].MakeActuationMatrix"></span><span class="sig-name descname"><span class="pre">MakeActuationMatrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.MakeActuationMatrix" title="Permalink to this definition"></a></dt>
<dd><p>This method creates an actuation matrix B mapping a vector of
actuation values u into generalized forces <code class="docutils literal notranslate"><span class="pre">tau_u</span> <span class="pre">=</span> <span class="pre">B</span> <span class="pre">*</span> <span class="pre">u</span></code>, where B
is a matrix of size <code class="docutils literal notranslate"><span class="pre">nv</span> <span class="pre">x</span> <span class="pre">nu</span></code> with <code class="docutils literal notranslate"><span class="pre">nu</span></code> equal to
num_actuated_dofs() and <code class="docutils literal notranslate"><span class="pre">nv</span></code> equal to num_velocities(). The vector u
of actuation values is of size num_actuated_dofs(). For a given
JointActuator, <code class="docutils literal notranslate"><span class="pre">u[JointActuator::input_start()]</span></code> stores the value
for the external actuation corresponding to that actuator. <code class="docutils literal notranslate"><span class="pre">tau_u</span></code>
on the other hand is indexed by generalized velocity indexes according
to <code class="docutils literal notranslate"><span class="pre">Joint::velocity_start()</span></code>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>B is a permutation matrix. While making a permutation has <code class="docutils literal notranslate"><span class="pre">O(n)</span></code>
complexity, making a full B matrix has <code class="docutils literal notranslate"><span class="pre">O(n²)</span></code> complexity. For
most applications this cost can be neglected but it could become
significant for very large systems.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.MakeActuationMatrixPseudoinverse">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].MakeActuationMatrixPseudoinverse"></span><span class="sig-name descname"><span class="pre">MakeActuationMatrixPseudoinverse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">scipy.sparse.csc_matrix</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.MakeActuationMatrixPseudoinverse" title="Permalink to this definition"></a></dt>
<dd><p>Creates the pseudoinverse of the actuation matrix B directly (without
requiring an explicit inverse calculation). See MakeActuationMatrix().</p>
<p>Notably, when B is full row rank (the system is fully actuated), then
the pseudoinverse is a true inverse.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.MakeActuatorSelectorMatrix">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].MakeActuatorSelectorMatrix"></span><span class="sig-name descname"><span class="pre">MakeActuatorSelectorMatrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.MakeActuatorSelectorMatrix" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>MakeActuatorSelectorMatrix(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], user_to_actuator_index_map: List[pydrake.multibody.tree.JointActuatorIndex]) -&gt; numpy.ndarray[numpy.float64[m, n]]</p></li>
</ol>
<p>This method allows user to map a vector <code class="docutils literal notranslate"><span class="pre">uₛ</span></code> containing the
actuation for a set of selected actuators into the vector u containing
the actuation values for <code class="docutils literal notranslate"><span class="pre">this</span></code> full model. The mapping, or
selection, is returned in the form of a selector matrix Su such that
<code class="docutils literal notranslate"><span class="pre">u</span> <span class="pre">=</span> <span class="pre">Su⋅uₛ</span></code>. The size nₛ of uₛ is always smaller or equal than the
size of the full vector of actuation values u. That is, a user might
be interested in only a given subset of actuators in the model.</p>
<p>This selection matrix is particularly useful when adding PID control
on a portion of the state, see systems::controllers::PidController.</p>
<p>A user specifies the preferred order in uₛ via
<code class="docutils literal notranslate"><span class="pre">user_to_actuator_index_map</span></code>. The actuation values in uₛ are a
concatenation of the values for each actuator in the order they appear
in <code class="docutils literal notranslate"><span class="pre">user_to_actuator_index_map</span></code>. The actuation value in the full
vector of actuation values <code class="docutils literal notranslate"><span class="pre">u</span></code> for a particular actuator can be
found at offset JointActuator::input_start().</p>
<ol class="arabic simple" start="2">
<li><p>MakeActuatorSelectorMatrix(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], user_to_joint_index_map: List[pydrake.multibody.tree.JointIndex]) -&gt; numpy.ndarray[numpy.float64[m, n]]</p></li>
</ol>
<p>Alternative signature to build an actuation selector matrix <code class="docutils literal notranslate"><span class="pre">Su</span></code>
such that <code class="docutils literal notranslate"><span class="pre">u</span> <span class="pre">=</span> <span class="pre">Su⋅uₛ</span></code>, where u is the vector of actuation values for
the full model (see get_actuation_input_port()) and uₛ is a vector of
actuation values for the actuators acting on the joints listed by
<code class="docutils literal notranslate"><span class="pre">user_to_joint_index_map</span></code>. It is assumed that all joints referenced
by <code class="docutils literal notranslate"><span class="pre">user_to_joint_index_map</span></code> are actuated. See
MakeActuatorSelectorMatrix(const std::vector&lt;JointActuatorIndex&gt;&amp;) for
details.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if any of the joints in user_to_joint_index_map</strong> – </p></li>
<li><p><strong>does not have an actuator.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.MakeStateSelectorMatrix">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].MakeStateSelectorMatrix"></span><span class="sig-name descname"><span class="pre">MakeStateSelectorMatrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">user_to_joint_index_map</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JointIndex" title="pydrake.multibody.tree.JointIndex"><span class="pre">pydrake.multibody.tree.JointIndex</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.MakeStateSelectorMatrix" title="Permalink to this definition"></a></dt>
<dd><p>This method allows users to map the state of <code class="docutils literal notranslate"><span class="pre">this</span></code> model, x, into a
vector of selected state xₛ with a given preferred ordering. The
mapping, or selection, is returned in the form of a selector matrix Sx
such that <code class="docutils literal notranslate"><span class="pre">xₛ</span> <span class="pre">=</span> <span class="pre">Sx⋅x</span></code>. The size nₛ of xₛ is always smaller or equal
than the size of the full state x. That is, a user might be interested
in only a given portion of the full state x.</p>
<p>This selection matrix is particularly useful when adding PID control
on a portion of the state, see systems::controllers::PidController.</p>
<p>A user specifies the preferred order in xₛ via
<code class="docutils literal notranslate"><span class="pre">user_to_joint_index_map</span></code>. The selected state is built such that
selected positions are followed by selected velocities, as in <code class="docutils literal notranslate"><span class="pre">xₛ</span> <span class="pre">=</span>
<span class="pre">[qₛ,</span> <span class="pre">vₛ]</span></code>. The positions in qₛ are a concatenation of the positions
for each joint in the order they appear in
<code class="docutils literal notranslate"><span class="pre">user_to_joint_index_map</span></code>. That is, the positions for
<code class="docutils literal notranslate"><span class="pre">user_to_joint_index_map[0]</span></code> are first, followed by the positions
for <code class="docutils literal notranslate"><span class="pre">user_to_joint_index_map[1]</span></code>, etc. Similarly for the selected
velocities vₛ.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if there are repeated indexes in</strong> – </p></li>
<li><p><strong>user_to_joint_index_map`</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.MapQDotToVelocity">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].MapQDotToVelocity"></span><span class="sig-name descname"><span class="pre">MapQDotToVelocity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qdot</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.MapQDotToVelocity" title="Permalink to this definition"></a></dt>
<dd><p>Transforms the time derivative <code class="docutils literal notranslate"><span class="pre">qdot</span></code> of the generalized positions
vector <code class="docutils literal notranslate"><span class="pre">q</span></code> (stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>) to generalized velocities <code class="docutils literal notranslate"><span class="pre">v</span></code>.
<cite>v</cite> and <code class="docutils literal notranslate"><span class="pre">q̇</span></code> are related linearly by <code class="docutils literal notranslate"><span class="pre">q̇</span> <span class="pre">=</span> <span class="pre">N(q)⋅v</span></code>. Although
<code class="docutils literal notranslate"><span class="pre">N(q)</span></code> is not necessarily square, its left pseudo-inverse <code class="docutils literal notranslate"><span class="pre">N⁺(q)</span></code>
can be used to invert that relationship without residual error,
provided that <code class="docutils literal notranslate"><span class="pre">qdot</span></code> is in the range space of <code class="docutils literal notranslate"><span class="pre">N(q)</span></code> (that is, if
it <em>could</em> have been produced as <code class="docutils literal notranslate"><span class="pre">q̇</span> <span class="pre">=</span> <span class="pre">N(q)⋅v</span></code> for some <code class="docutils literal notranslate"><span class="pre">v</span></code>).
Using the configuration <code class="docutils literal notranslate"><span class="pre">q</span></code> stored in the given <code class="docutils literal notranslate"><span class="pre">context</span></code> this
method calculates <code class="docutils literal notranslate"><span class="pre">v</span> <span class="pre">=</span> <span class="pre">N⁺(q)⋅q̇</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context containing the state of the model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">qdot</span></code>:</dt><dd><p>A vector containing the time derivatives of the generalized
positions. This method aborts if <code class="docutils literal notranslate"><span class="pre">qdot</span></code> is not of size
num_positions().</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">v</span></code>:</dt><dd><p>A valid (non-null) pointer to a vector in <code class="docutils literal notranslate"><span class="pre">ℛⁿ</span></code> with n the number
of generalized velocities. This method aborts if v is nullptr or
if it is not of size num_velocities().</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>MapVelocityToQDot()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>Mobilizer::MapQDotToVelocity()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.MapVelocityToQDot">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].MapVelocityToQDot"></span><span class="sig-name descname"><span class="pre">MapVelocityToQDot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.MapVelocityToQDot" title="Permalink to this definition"></a></dt>
<dd><p>Transforms generalized velocities v to time derivatives <code class="docutils literal notranslate"><span class="pre">qdot</span></code> of
the generalized positions vector <code class="docutils literal notranslate"><span class="pre">q</span></code> (stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>). <cite>v</cite>
and <code class="docutils literal notranslate"><span class="pre">qdot</span></code> are related linearly by <code class="docutils literal notranslate"><span class="pre">q̇</span> <span class="pre">=</span> <span class="pre">N(q)⋅v</span></code>. Using the
configuration <code class="docutils literal notranslate"><span class="pre">q</span></code> stored in the given <code class="docutils literal notranslate"><span class="pre">context</span></code> this method
calculates <code class="docutils literal notranslate"><span class="pre">q̇</span> <span class="pre">=</span> <span class="pre">N(q)⋅v</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context containing the state of the model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">v</span></code>:</dt><dd><p>A vector of generalized velocities for this model. This method
aborts if v is not of size num_velocities().</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">qdot</span></code>:</dt><dd><p>A valid (non-null) pointer to a vector in <code class="docutils literal notranslate"><span class="pre">ℝⁿ</span></code> with n being the
number of generalized positions in this model, given by
<code class="docutils literal notranslate"><span class="pre">num_positions()</span></code>. This method aborts if <code class="docutils literal notranslate"><span class="pre">qdot</span></code> is nullptr or
if it is not of size num_positions().</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>MapQDotToVelocity()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>Mobilizer::MapVelocityToQDot()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.mutable_gravity_field">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].mutable_gravity_field"></span><span class="sig-name descname"><span class="pre">mutable_gravity_field</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.UniformGravityFieldElement_" title="pydrake.multibody.tree.UniformGravityFieldElement_"><span class="pre">pydrake.multibody.tree.UniformGravityFieldElement_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.mutable_gravity_field" title="Permalink to this definition"></a></dt>
<dd><p>A mutable accessor to the current gravity field.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.num_actuated_dofs">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].num_actuated_dofs"></span><span class="sig-name descname"><span class="pre">num_actuated_dofs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.num_actuated_dofs" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>num_actuated_dofs(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd]) -&gt; int</p></li>
</ol>
<p>Returns the total number of actuated degrees of freedom. That is, the
vector of actuation values u has this size. See AddJointActuator().</p>
<ol class="arabic simple" start="2">
<li><p>num_actuated_dofs(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; int</p></li>
</ol>
<p>Returns the total number of actuated degrees of freedom for a specific
model instance. That is, the vector of actuation values u has this
size. See AddJointActuator().</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.num_actuators">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].num_actuators"></span><span class="sig-name descname"><span class="pre">num_actuators</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.num_actuators" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>num_actuators(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd]) -&gt; int</p></li>
</ol>
<p>Returns the number of joint actuators in the model.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddJointActuator().</p>
</div>
<ol class="arabic simple" start="2">
<li><p>num_actuators(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; int</p></li>
</ol>
<p>Returns the number of actuators for a specific model instance.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.num_bodies">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].num_bodies"></span><span class="sig-name descname"><span class="pre">num_bodies</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.num_bodies" title="Permalink to this definition"></a></dt>
<dd><p>Returns the number of bodies in the model, including the “world” body,
which is always part of the model.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddRigidBody().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.num_collision_geometries">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].num_collision_geometries"></span><span class="sig-name descname"><span class="pre">num_collision_geometries</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.num_collision_geometries" title="Permalink to this definition"></a></dt>
<dd><p>Returns the number of geometries registered for contact modeling. This
method can be called at any time during the lifetime of <code class="docutils literal notranslate"><span class="pre">this</span></code>
plant, either pre- or post-finalize, see Finalize(). Post-finalize
calls will always return the same value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.num_constraints">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].num_constraints"></span><span class="sig-name descname"><span class="pre">num_constraints</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.num_constraints" title="Permalink to this definition"></a></dt>
<dd><p>Returns the total number of constraints specified by the user.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.num_force_elements">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].num_force_elements"></span><span class="sig-name descname"><span class="pre">num_force_elements</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.num_force_elements" title="Permalink to this definition"></a></dt>
<dd><p>Returns the number of ForceElement objects.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddForceElement().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.num_frames">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].num_frames"></span><span class="sig-name descname"><span class="pre">num_frames</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.num_frames" title="Permalink to this definition"></a></dt>
<dd><p>Returns the number of Frame objects in this model. Frames include body
frames associated with each of the bodies, including the <em>world</em> body.
This means the minimum number of frames is one.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.num_joints">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].num_joints"></span><span class="sig-name descname"><span class="pre">num_joints</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.num_joints" title="Permalink to this definition"></a></dt>
<dd><p>Returns the number of joints in the model.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddJoint().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.num_model_instances">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].num_model_instances"></span><span class="sig-name descname"><span class="pre">num_model_instances</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.num_model_instances" title="Permalink to this definition"></a></dt>
<dd><p>Returns the number of model instances in the model.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddModelInstance().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.num_multibody_states">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].num_multibody_states"></span><span class="sig-name descname"><span class="pre">num_multibody_states</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.num_multibody_states" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>num_multibody_states(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd]) -&gt; int</p></li>
</ol>
<p>Returns the size of the multibody system state vector x = [q v]. This
will be <code class="docutils literal notranslate"><span class="pre">num_positions()</span></code> plus <code class="docutils literal notranslate"><span class="pre">num_velocities()</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>num_multibody_states(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; int</p></li>
</ol>
<p>Returns the size of the multibody system state vector xᵢ = [qᵢ vᵢ] for
model instance i. (Here qᵢ ⊆ q and vᵢ ⊆ v.) will be
<code class="docutils literal notranslate"><span class="pre">num_positions(model_instance)</span></code> plus
<code class="docutils literal notranslate"><span class="pre">num_velocities(model_instance)</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.num_positions">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].num_positions"></span><span class="sig-name descname"><span class="pre">num_positions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.num_positions" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>num_positions(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd]) -&gt; int</p></li>
</ol>
<p>Returns the size of the generalized position vector q for this model.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>num_positions(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; int</p></li>
</ol>
<p>Returns the size of the generalized position vector qᵢ for model
instance i.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.num_velocities">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].num_velocities"></span><span class="sig-name descname"><span class="pre">num_velocities</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.num_velocities" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>num_velocities(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd]) -&gt; int</p></li>
</ol>
<p>Returns the size of the generalized velocity vector v for this model.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>num_velocities(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; int</p></li>
</ol>
<p>Returns the size of the generalized velocity vector vᵢ for model
instance i.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.physical_models">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].physical_models"></span><span class="sig-name descname"><span class="pre">physical_models</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List[drake::multibody::PhysicalModel&lt;Eigen::AutoDiffScalar&lt;Eigen::Matrix&lt;double,</span> <span class="pre">-1,</span> <span class="pre">1,</span> <span class="pre">0,</span> <span class="pre">-1,</span> <span class="pre">1&gt;</span> <span class="pre">&gt;</span> <span class="pre">&gt;]</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.physical_models" title="Permalink to this definition"></a></dt>
<dd><p>Returns a vector of pointers to all physical models registered with
this MultibodyPlant. For use only by advanced developers.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This feature is considered to be <strong>experimental</strong> and may change
or be removed at any time, without any deprecation notice ahead of
time.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.RegisterAsSourceForSceneGraph">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].RegisterAsSourceForSceneGraph"></span><span class="sig-name descname"><span class="pre">RegisterAsSourceForSceneGraph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scene_graph</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.SceneGraph_" title="pydrake.geometry.SceneGraph_"><span class="pre">pydrake.geometry.SceneGraph_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.SourceId" title="pydrake.geometry.SourceId"><span class="pre">pydrake.geometry.SourceId</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.RegisterAsSourceForSceneGraph" title="Permalink to this definition"></a></dt>
<dd><p>Registers <code class="docutils literal notranslate"><span class="pre">this</span></code> plant to serve as a source for an instance of
SceneGraph. This registration allows MultibodyPlant to register
geometry with <code class="docutils literal notranslate"><span class="pre">scene_graph</span></code> for visualization and/or collision
queries. The string returned by <code class="docutils literal notranslate"><span class="pre">this-&gt;get_name()</span></code> is passed to
SceneGraph’s RegisterSource, so it is highly recommended that you give
the plant a recognizable name before calling this. Successive
registration calls with SceneGraph <strong>must</strong> be performed on the same
instance to which the pointer argument <code class="docutils literal notranslate"><span class="pre">scene_graph</span></code> points to.
Failure to do so will result in runtime exceptions.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">scene_graph</span></code>:</dt><dd><p>A valid non nullptr to the SceneGraph instance for which <code class="docutils literal notranslate"><span class="pre">this</span></code>
plant will sever as a source, see SceneGraph documentation for
further details.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the SourceId of <code class="docutils literal notranslate"><span class="pre">this</span></code> plant in <code class="docutils literal notranslate"><span class="pre">scene_graph</span></code>. It can also
later on be retrieved with get_source_id().</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>RuntimeError if called post-finalize.</strong> – </p></li>
<li><p><strong>RuntimeError if scene_graph is the nullptr.</strong> – </p></li>
<li><p><strong>RuntimeError if called more than once.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.RegisterCollisionGeometry">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].RegisterCollisionGeometry"></span><span class="sig-name descname"><span class="pre">RegisterCollisionGeometry</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.RegisterCollisionGeometry" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>RegisterCollisionGeometry(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], body: pydrake.multibody.tree.RigidBody_[AutoDiffXd], X_BG: pydrake.math.RigidTransform, shape: pydrake.geometry.Shape, name: str, properties: pydrake.geometry.ProximityProperties) -&gt; pydrake.geometry.GeometryId</p></li>
</ol>
<p>Registers geometry in a SceneGraph with a given geometry::Shape to be
used for the contact modeling of a given <code class="docutils literal notranslate"><span class="pre">body</span></code>. More than one
geometry can be registered with a body, in which case the body’s
contact geometry is the union of all geometries registered to that
body.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body</span></code>:</dt><dd><p>The body for which geometry is being registered.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">X_BG</span></code>:</dt><dd><p>The fixed pose of the geometry frame G in the body frame B.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">shape</span></code>:</dt><dd><p>The geometry::Shape used for visualization. E.g.:
geometry::Sphere, geometry::Cylinder, etc.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">properties</span></code>:</dt><dd><p>The proximity properties associated with the collision geometry.
They <em>must</em> include the (<code class="docutils literal notranslate"><span class="pre">material</span></code>, <cite>coulomb_friction</cite>)
property of type CoulombFriction&lt;double&gt;.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if called post-finalize</strong><strong> or </strong><strong>if the properties are</strong> – </p></li>
<li><p><strong>missing the coulomb friction property</strong><strong> (or </strong><strong>if it is of the wrong</strong> – </p></li>
<li><p><strong>type</strong><strong>)</strong><strong></strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>RegisterCollisionGeometry(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], body: pydrake.multibody.tree.RigidBody_[AutoDiffXd], X_BG: pydrake.math.RigidTransform, shape: pydrake.geometry.Shape, name: str, coulomb_friction: pydrake.multibody.plant.CoulombFriction) -&gt; pydrake.geometry.GeometryId</p></li>
</ol>
<p>Overload which specifies a single property: coulomb_friction.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.RegisterVisualGeometry">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].RegisterVisualGeometry"></span><span class="sig-name descname"><span class="pre">RegisterVisualGeometry</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody_" title="pydrake.multibody.tree.RigidBody_"><span class="pre">pydrake.multibody.tree.RigidBody_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X_BG</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.math.html#pydrake.math.RigidTransform" title="pydrake.math.RigidTransform"><span class="pre">pydrake.math.RigidTransform</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">shape</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.Shape" title="pydrake.geometry.Shape"><span class="pre">pydrake.geometry.Shape</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">diffuse_color</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">4</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.GeometryId" title="pydrake.geometry.GeometryId"><span class="pre">pydrake.geometry.GeometryId</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.RegisterVisualGeometry" title="Permalink to this definition"></a></dt>
<dd><p>Overload for visual geometry registration; it converts the
<code class="docutils literal notranslate"><span class="pre">diffuse_color</span></code> (RGBA with values in the range [0, 1]) into a
geometry::DrakeVisualizer-compatible set of
geometry::IllustrationProperties.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.RemoveConstraint">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].RemoveConstraint"></span><span class="sig-name descname"><span class="pre">RemoveConstraint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">id</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.MultibodyConstraintId" title="pydrake.multibody.tree.MultibodyConstraintId"><span class="pre">pydrake.multibody.tree.MultibodyConstraintId</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.RemoveConstraint" title="Permalink to this definition"></a></dt>
<dd><p>Removes the constraint <code class="docutils literal notranslate"><span class="pre">id</span></code> from the plant. Note that this will
<em>not</em> remove constraints registered directly with DeformableModel.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the MultibodyPlant has already been finalized.</strong> – </p></li>
<li><p><strong>RuntimeError if id does not identify any multibody constraint</strong> – </p></li>
<li><p><strong>in this plant.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.RemoveJoint">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].RemoveJoint"></span><span class="sig-name descname"><span class="pre">RemoveJoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">joint</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Joint_" title="pydrake.multibody.tree.Joint_"><span class="pre">pydrake.multibody.tree.Joint_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.RemoveJoint" title="Permalink to this definition"></a></dt>
<dd><p>Removes and deletes <code class="docutils literal notranslate"><span class="pre">joint</span></code> from this MultibodyPlant. Any existing
references to <code class="docutils literal notranslate"><span class="pre">joint</span></code> will become invalid, and future calls to
<code class="docutils literal notranslate"><span class="pre">get_joint(joint_index)</span></code> will throw an exception. Other elements of
the plant may depend on <code class="docutils literal notranslate"><span class="pre">joint</span></code> at the time of removal and should be
removed first. For example, a JointActuator that depends on <code class="docutils literal notranslate"><span class="pre">joint</span></code>
should be removed with RemoveJointActuator(). Currently, we do not
provide joint dependency tracking for force elements or constraints,
so this function will throw an exception if there are <em>any</em> user-added
force elements or constraints in the plant.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the plant is already finalized.</strong> – </p></li>
<li><p><strong>RuntimeError if the plant contains a non-zero number of user-added</strong> – </p></li>
<li><p><strong>force elements</strong><strong> or </strong><strong>user-added constraints.</strong> – </p></li>
<li><p><strong>RuntimeError if joint has a dependent JointActuator.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddJoint()</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is important to note that the JointIndex assigned to a joint is
immutable. New joint indices are assigned in increasing order,
even if a joint with a lower index has been removed. This has the
consequence that when a joint is removed from the plant, the
sequence <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">num_joints())</span></code> is not necessarily the correct set
of un-removed joint indices in the plant. Thus, it is important
<em>NOT</em> to loop over joint indices sequentially from <code class="docutils literal notranslate"><span class="pre">0</span></code> to
<code class="docutils literal notranslate"><span class="pre">num_joints()</span> <span class="pre">-</span> <span class="pre">1</span></code>. Instead users should use the provided
GetJointIndices() and GetJointIndices(ModelIndex) functions:</p>
</div>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">JointIndex</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">plant</span><span class="p">.</span><span class="n">GetJointIndices</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">Joint</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">joint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">plant</span><span class="p">.</span><span class="n">get_joint</span><span class="p">(</span><span class="n">index</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="w"> </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</details></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.RemoveJointActuator">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].RemoveJointActuator"></span><span class="sig-name descname"><span class="pre">RemoveJointActuator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">actuator</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JointActuator_" title="pydrake.multibody.tree.JointActuator_"><span class="pre">pydrake.multibody.tree.JointActuator_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.RemoveJointActuator" title="Permalink to this definition"></a></dt>
<dd><p>Removes and deletes <code class="docutils literal notranslate"><span class="pre">actuator</span></code> from this MultibodyPlant. Any
existing references to <code class="docutils literal notranslate"><span class="pre">actuator</span></code> will become invalid, and future
calls to <code class="docutils literal notranslate"><span class="pre">get_joint_actuator(actuator_index)</span></code> will throw an
exception.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if the plant is already finalized.</strong> – </p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddJointActuator()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.RenameModelInstance">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].RenameModelInstance"></span><span class="sig-name descname"><span class="pre">RenameModelInstance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.RenameModelInstance" title="Permalink to this definition"></a></dt>
<dd><p>Renames an existing model instance.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>:</dt><dd><p>The instance to rename.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">name</span></code>:</dt><dd><p>A string that uniquely identifies the instance within <code class="docutils literal notranslate"><span class="pre">this</span></code>
model.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if called after Finalize</strong><strong>(</strong><strong>)</strong><strong></strong> – </p></li>
<li><p><strong>RuntimeError if model_instance is not a valid index.</strong> – </p></li>
<li><p><strong>RuntimeError if HasModelInstanceNamed</strong><strong>(</strong><strong>name</strong><strong>) </strong><strong>is true.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.set_adjacent_bodies_collision_filters">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].set_adjacent_bodies_collision_filters"></span><span class="sig-name descname"><span class="pre">set_adjacent_bodies_collision_filters</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.set_adjacent_bodies_collision_filters" title="Permalink to this definition"></a></dt>
<dd><p>Sets whether to apply collision filters to topologically adjacent
bodies at Finalize() time. Filters are applied when there exists a
joint between bodies, except in the case of 6-dof joints or joints in
which the parent body is <code class="docutils literal notranslate"><span class="pre">world</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError iff called post-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.set_contact_model">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].set_contact_model"></span><span class="sig-name descname"><span class="pre">set_contact_model</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.ContactModel" title="pydrake.multibody.plant.ContactModel"><span class="pre">pydrake.multibody.plant.ContactModel</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.set_contact_model" title="Permalink to this definition"></a></dt>
<dd><p>Sets the contact model to be used by <code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant, see
ContactModel for available options. The default contact model is
ContactModel::kHydroelasticWithFallback.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError iff called post-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.set_contact_surface_representation">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].set_contact_surface_representation"></span><span class="sig-name descname"><span class="pre">set_contact_surface_representation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">surface_representation</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.HydroelasticContactRepresentation" title="pydrake.geometry.HydroelasticContactRepresentation"><span class="pre">pydrake.geometry.HydroelasticContactRepresentation</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.set_contact_surface_representation" title="Permalink to this definition"></a></dt>
<dd><p>Sets the representation of contact surfaces to be used by <code class="docutils literal notranslate"><span class="pre">this</span></code>
MultibodyPlant. See geometry::HydroelasticContactRepresentation for
available options. See GetDefaultContactSurfaceRepresentation() for
explanation of default values.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.set_discrete_contact_approximation">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].set_discrete_contact_approximation"></span><span class="sig-name descname"><span class="pre">set_discrete_contact_approximation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">approximation</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.DiscreteContactApproximation" title="pydrake.multibody.plant.DiscreteContactApproximation"><span class="pre">pydrake.multibody.plant.DiscreteContactApproximation</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.set_discrete_contact_approximation" title="Permalink to this definition"></a></dt>
<dd><p>Sets the discrete contact model approximation.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Calling this method also sets the contact solver type (see
set_discrete_contact_solver()) according to: -
DiscreteContactApproximation::kTamsi sets the solver to
DiscreteContactSolver::kTamsi. -
DiscreteContactApproximation::kSap,
DiscreteContactApproximation::kSimilar and
DiscreteContactApproximation::kLagged set the solver to
DiscreteContactSolver::kSap.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>iff this plant is continuous</strong><strong> (</strong><strong>i.e. is_discrete</strong><strong>(</strong><strong>) </strong><strong>is</strong> – </p></li>
<li><p><strong>False`.</strong> – </p></li>
<li><p><strong>RuntimeError iff called post-finalize.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.set_discrete_contact_solver">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].set_discrete_contact_solver"></span><span class="sig-name descname"><span class="pre">set_discrete_contact_solver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">contact_solver</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.DiscreteContactSolver" title="pydrake.multibody.plant.DiscreteContactSolver"><span class="pre">pydrake.multibody.plant.DiscreteContactSolver</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.set_discrete_contact_solver" title="Permalink to this definition"></a></dt>
<dd><p>Sets the contact solver type used for discrete MultibodyPlant models.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Calling this method also sets a default discrete approximation of
contact (see set_discrete_contact_approximation()) according to: -
DiscreteContactSolver::kTamsi sets the approximation to
DiscreteContactApproximation::kTamsi. -
DiscreteContactSolver::kSap sets the approximation to
DiscreteContactApproximation::kSap.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This function is a no-op for continuous models (when is_discrete()
is false.)</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError iff called post-finalize.</strong><strong> (</strong><strong>Deprecated.</strong><strong>)</strong> – </p>
</dd>
</dl>
<dl class="simple">
<dt>Deprecated:</dt><dd><p>Use set_discrete_contact_approximation() to set the contact model
approximation. The underlying solver will be inferred
automatically. This will be removed from Drake on or after
2024-04-01.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.set_gravity_enabled">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].set_gravity_enabled"></span><span class="sig-name descname"><span class="pre">set_gravity_enabled</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_enabled</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.set_gravity_enabled" title="Permalink to this definition"></a></dt>
<dd><p>Sets is_gravity_enabled() for <code class="docutils literal notranslate"><span class="pre">model_instance</span></code> to <code class="docutils literal notranslate"><span class="pre">is_enabled</span></code>.
The effect of <code class="docutils literal notranslate"><span class="pre">is_enabled</span> <span class="pre">=</span> <span class="pre">false</span></code> is effectively equivalent to
disabling (or making zero) gravity for all bodies in the specified
model instance. By default is_gravity_enabled() equals <code class="docutils literal notranslate"><span class="pre">True</span></code> for
all model instances.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if called post-finalize.</strong> – </p></li>
<li><p><strong>RuntimeError if the model instance is invalid.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.set_penetration_allowance">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].set_penetration_allowance"></span><span class="sig-name descname"><span class="pre">set_penetration_allowance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">penetration_allowance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.001</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.set_penetration_allowance" title="Permalink to this definition"></a></dt>
<dd><p>Sets the penetration allowance used to estimate the coefficients in
the penalty method used to impose non-penetration among bodies. Refer
to the section mbp_compliant_point_contact “Compliant point contact
model” for further details.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if penetration_allowance is not positive.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.set_sap_near_rigid_threshold">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].set_sap_near_rigid_threshold"></span><span class="sig-name descname"><span class="pre">set_sap_near_rigid_threshold</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">near_rigid_threshold</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.set_sap_near_rigid_threshold" title="Permalink to this definition"></a></dt>
<dd><p>Non-negative dimensionless number typically in the range [0.0, 1.0],
though larger values are allowed even if uncommon. This parameter
controls the “near rigid” regime of the SAP solver, β in section V.B
of [Castro et al., 2021]. It essentially controls a threshold value
for the maximum amount of stiffness SAP can handle robustly. Beyond
this value, stiffness saturates as explained in [Castro et al., 2021].
A value of 1.0 is a conservative choice to avoid ill-conditioning that
might lead to softer than expected contact. If this is your case,
consider turning off this approximation by setting this parameter to
zero. For difficult cases where ill-conditioning is a problem, a small
but non-zero number can be used, e.g. 1.0e-3.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if near_rigid_threshold is negative.</strong> – </p></li>
<li><p><strong>RuntimeError if called post-finalize.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.set_stiction_tolerance">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].set_stiction_tolerance"></span><span class="sig-name descname"><span class="pre">set_stiction_tolerance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v_stiction</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.001</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.set_stiction_tolerance" title="Permalink to this definition"></a></dt>
<dd><p><a href="#id57"><span class="problematic" id="id58">**</span></a>** Stribeck model of friction</p>
<p>Currently MultibodyPlant uses the Stribeck approximation to model dry
friction. The Stribeck model of friction is an approximation to
Coulomb’s law of friction that allows using continuous time
integration without the need to specify complementarity constraints.
While this results in a simpler model immediately tractable with
standard numerical methods for integration of ODE’s, it often leads to
stiff dynamics that require an explicit integrator to take very small
time steps. It is therefore recommended to use error controlled
integrators when using this model or the discrete time stepping (see
time_advancement_strategy “Choice of Time Advancement Strategy”). See
stribeck_approximation for a detailed discussion of the Stribeck
model.</p>
<p>Sets the stiction tolerance <code class="docutils literal notranslate"><span class="pre">v_stiction</span></code> for the Stribeck model,
where <code class="docutils literal notranslate"><span class="pre">v_stiction</span></code> must be specified in m/s (meters per second.)
<code class="docutils literal notranslate"><span class="pre">v_stiction</span></code> defaults to a value of 1 millimeter per second. In
selecting a value for <code class="docutils literal notranslate"><span class="pre">v_stiction</span></code>, you must ask yourself the
question, “When two objects are ostensibly in stiction, how much slip
am I willing to allow?” There are two opposing design issues in
picking a value for vₛ. On the one hand, small values of vₛ make the
problem numerically stiff during stiction, potentially increasing the
integration cost. On the other hand, it should be picked to be
appropriate for the scale of the problem. For example, a car
simulation could allow a “large” value for vₛ of 1 cm/s (1×10⁻² m/s),
but reasonable stiction for grasping a 10 cm box might require
limiting residual slip to 1×10⁻³ m/s or less. Ultimately, picking the
largest viable value will allow your simulation to run faster and more
robustly. Note that <code class="docutils literal notranslate"><span class="pre">v_stiction</span></code> is the slip velocity that we’d have
when we are at edge of the friction cone. For cases when the friction
force is well within the friction cone the slip velocity will always
be smaller than this value. See also stribeck_approximation.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if v_stiction is non-positive.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.SetActuationInArray">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].SetActuationInArray"></span><span class="sig-name descname"><span class="pre">SetActuationInArray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">u_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">u</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.writeable</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.SetActuationInArray" title="Permalink to this definition"></a></dt>
<dd><p>Given actuation values <code class="docutils literal notranslate"><span class="pre">u_instance</span></code> for the actuators in
<code class="docutils literal notranslate"><span class="pre">model_instance</span></code>, this function updates the actuation vector u for
the entire plant model to which this actuator belongs to. Refer to
mbp_actuation “Actuation” for further details.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">u_instance</span></code>:</dt><dd><p>Actuation values for the model instance. Values are ordered by
monotonically increasing JointActuatorIndex within the model
instance.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">u</span></code>:</dt><dd><p>Actuation values for the entire plant model. The actuation value
in <code class="docutils literal notranslate"><span class="pre">u</span></code> for a particular actuator must be found at offset
JointActuator::input_start(). Only values corresponding to
<code class="docutils literal notranslate"><span class="pre">model_instance</span></code> are changed.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the size of u_instance is not equal to the</strong> – </p></li>
<li><p><strong>number of actuation inputs for the joints of model_instance.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.SetConstraintActiveStatus">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].SetConstraintActiveStatus"></span><span class="sig-name descname"><span class="pre">SetConstraintActiveStatus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">id</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.MultibodyConstraintId" title="pydrake.multibody.tree.MultibodyConstraintId"><span class="pre">pydrake.multibody.tree.MultibodyConstraintId</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">status</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.SetConstraintActiveStatus" title="Permalink to this definition"></a></dt>
<dd><p>Sets the active status of the constraint given by <code class="docutils literal notranslate"><span class="pre">id</span></code> in
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the MultibodyPlant has not been finalized.</strong> – </p></li>
<li><p><strong>RuntimeError if context == nullptr</strong> – </p></li>
<li><p><strong>RuntimeError if id does not belong to any multibody constraint</strong> – </p></li>
<li><p><strong>in context.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.SetDefaultFreeBodyPose">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].SetDefaultFreeBodyPose"></span><span class="sig-name descname"><span class="pre">SetDefaultFreeBodyPose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody_" title="pydrake.multibody.tree.RigidBody_"><span class="pre">pydrake.multibody.tree.RigidBody_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X_WB</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.math.html#pydrake.math.RigidTransform" title="pydrake.math.RigidTransform"><span class="pre">pydrake.math.RigidTransform</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.SetDefaultFreeBodyPose" title="Permalink to this definition"></a></dt>
<dd><p>Sets the default pose of <code class="docutils literal notranslate"><span class="pre">body</span></code>. If <code class="docutils literal notranslate"><span class="pre">body.is_floating()</span></code> is true,
this will affect subsequent calls to SetDefaultState(); otherwise, the
only effect of the call is that the value will be echoed back in
GetDefaultFreeBodyPose().</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body</span></code>:</dt><dd><p>RigidBody whose default pose will be set.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">X_WB</span></code>:</dt><dd><p>Default pose of the body.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.SetDefaultPositions">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].SetDefaultPositions"></span><span class="sig-name descname"><span class="pre">SetDefaultPositions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.SetDefaultPositions" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>SetDefaultPositions(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], q: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</p></li>
</ol>
<p>Sets the default positions for the plant. Calls to
CreateDefaultContext or SetDefaultContext/SetDefaultState will return
a Context populated with these position values. They have no other
effects on the dynamics of the system.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the plant is not finalized</strong><strong> or </strong><strong>if q is not of size</strong> – </p></li>
<li><p><strong>num_positions</strong><strong>(</strong><strong>)</strong><strong></strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>SetDefaultPositions(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], model_instance: pydrake.multibody.tree.ModelInstanceIndex, q_instance: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</p></li>
</ol>
<p>Sets the default positions for the model instance. Calls to
CreateDefaultContext or SetDefaultContext/SetDefaultState will return
a Context populated with these position values. They have no other
effects on the dynamics of the system.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the plant is not finalized</strong><strong>, </strong><strong>if the model_instance</strong> – </p></li>
<li><p><strong>is invalid</strong><strong>, or </strong><strong>if the length of q_instance is not equal to</strong> – </p></li>
<li><p><strong>num_positions</strong><strong>(</strong><strong>model_instance</strong><strong>)</strong><strong>`</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.SetDefaultState">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].SetDefaultState"></span><span class="sig-name descname"><span class="pre">SetDefaultState</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">state</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.State_" title="pydrake.systems.framework.State_"><span class="pre">pydrake.systems.framework.State_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.SetDefaultState" title="Permalink to this definition"></a></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">state</span></code> according to defaults set by the user for joints (e.g.
RevoluteJoint::set_default_angle()) and free bodies
(SetDefaultFreeBodyPose()). If the user does not specify defaults, the
state corresponds to zero generalized positions and velocities.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize. See Finalize</strong><strong>(</strong><strong>)</strong><strong></strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.SetFreeBodyPose">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].SetFreeBodyPose"></span><span class="sig-name descname"><span class="pre">SetFreeBodyPose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody_" title="pydrake.multibody.tree.RigidBody_"><span class="pre">pydrake.multibody.tree.RigidBody_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X_WB</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.math.html#pydrake.math.RigidTransform_" title="pydrake.math.RigidTransform_"><span class="pre">pydrake.math.RigidTransform_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.SetFreeBodyPose" title="Permalink to this definition"></a></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">context</span></code> to store the pose <code class="docutils literal notranslate"><span class="pre">X_WB</span></code> of a given <code class="docutils literal notranslate"><span class="pre">body</span></code> B in
the world frame W.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In general setting the pose and/or velocity of a body in the model
would involve a complex inverse kinematics problem. This method
allows us to simplify this process when we know the body is free
in space.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if body is not a free body in the model.</strong> – </p></li>
<li><p><strong>RuntimeError if called pre-finalize.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.SetFreeBodySpatialVelocity">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].SetFreeBodySpatialVelocity"></span><span class="sig-name descname"><span class="pre">SetFreeBodySpatialVelocity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody_" title="pydrake.multibody.tree.RigidBody_"><span class="pre">pydrake.multibody.tree.RigidBody_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">V_WB</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.math.html#pydrake.multibody.math.SpatialVelocity_" title="pydrake.multibody.math.SpatialVelocity_"><span class="pre">pydrake.multibody.math.SpatialVelocity_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.SetFreeBodySpatialVelocity" title="Permalink to this definition"></a></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">context</span></code> to store the spatial velocity <code class="docutils literal notranslate"><span class="pre">V_WB</span></code> of a given
<code class="docutils literal notranslate"><span class="pre">body</span></code> B in the world frame W.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In general setting the pose and/or velocity of a body in the model
would involve a complex inverse kinematics problem. This method
allows us to simplify this process when we know the body is free
in space.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if body is not a free body in the model.</strong> – </p></li>
<li><p><strong>RuntimeError if called pre-finalize.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.SetPositions">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].SetPositions"></span><span class="sig-name descname"><span class="pre">SetPositions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.SetPositions" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>SetPositions(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], q: numpy.ndarray[object[m, 1]]) -&gt; None</p></li>
</ol>
<p>Sets the generalized positions q in a given Context from a given
vector. Prefer this method over GetMutablePositions().</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if context is nullptr</strong><strong>, </strong><strong>if context does not</strong> – </p></li>
<li><p><strong>correspond to the Context for a multibody model</strong><strong>, or </strong><strong>if the length</strong> – </p></li>
<li><p><strong>of q is not equal to num_positions</strong><strong>(</strong><strong>)</strong><strong></strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>SetPositions(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], model_instance: pydrake.multibody.tree.ModelInstanceIndex, q: numpy.ndarray[object[m, 1]]) -&gt; None</p></li>
</ol>
<p>Sets the generalized positions q in a given Context from a given
vector. Prefer this method over GetMutablePositions().</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if context is nullptr</strong><strong>, </strong><strong>if context does not</strong> – </p></li>
<li><p><strong>correspond to the Context for a multibody model</strong><strong>, or </strong><strong>if the length</strong> – </p></li>
<li><p><strong>of q is not equal to num_positions</strong><strong>(</strong><strong>)</strong><strong></strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.SetPositionsAndVelocities">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].SetPositionsAndVelocities"></span><span class="sig-name descname"><span class="pre">SetPositionsAndVelocities</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.SetPositionsAndVelocities" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>SetPositionsAndVelocities(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], q_v: numpy.ndarray[object[m, 1]]) -&gt; None</p></li>
</ol>
<p>Sets generalized positions q and generalized velocities v in a given
Context from a given vector [q; v]. Prefer this method over
GetMutablePositionsAndVelocities().</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if context is nullptr</strong><strong>, </strong><strong>if context does not</strong> – </p></li>
<li><p><strong>correspond to the context for a multibody model</strong><strong>, or </strong><strong>if the length</strong> – </p></li>
<li><p><strong>of q_v is not equal to num_positions</strong><strong>(</strong><strong>) </strong><strong>+ num_velocities</strong><strong>(</strong><strong>)</strong><strong></strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>SetPositionsAndVelocities(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], model_instance: pydrake.multibody.tree.ModelInstanceIndex, q_v: numpy.ndarray[object[m, 1]]) -&gt; None</p></li>
</ol>
<p>Sets generalized positions q and generalized velocities v from a given
vector [q; v] for a specified model instance in a given Context.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if context is nullptr</strong><strong>, </strong><strong>if context does not</strong> – </p></li>
<li><p><strong>correspond to the Context for a multibody model</strong><strong>, </strong><strong>if the model</strong> – </p></li>
<li><p><strong>instance index is invalid</strong><strong>, or </strong><strong>if the length of q_v is not</strong> – </p></li>
<li><p><strong>equal to ``num_positions</strong><strong>(</strong><strong>model_instance</strong><strong>) </strong><strong>+</strong> – </p></li>
<li><p><strong>num_velocities</strong><strong>(</strong><strong>model_instance</strong><strong>)</strong><strong>``.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.SetPositionsInArray">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].SetPositionsInArray"></span><span class="sig-name descname"><span class="pre">SetPositionsInArray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">q_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.writeable</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.SetPositionsInArray" title="Permalink to this definition"></a></dt>
<dd><p>Sets the vector of generalized positions for <code class="docutils literal notranslate"><span class="pre">model_instance</span></code> in
<code class="docutils literal notranslate"><span class="pre">q</span></code> using <code class="docutils literal notranslate"><span class="pre">q_instance</span></code>, leaving all other elements in the array
untouched. This method throws an exception if <code class="docutils literal notranslate"><span class="pre">q</span></code> is not of size
MultibodyPlant::num_positions() or <code class="docutils literal notranslate"><span class="pre">q_instance</span></code> is not of size
<code class="docutils literal notranslate"><span class="pre">MultibodyPlant::num_positions(model_instance)</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.SetVelocities">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].SetVelocities"></span><span class="sig-name descname"><span class="pre">SetVelocities</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.SetVelocities" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>SetVelocities(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], v: numpy.ndarray[object[m, 1]]) -&gt; None</p></li>
</ol>
<p>Sets the generalized velocities v in a given Context from a given
vector. Prefer this method over GetMutableVelocities().</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the context is nullptr</strong><strong>, </strong><strong>if the context does</strong> – </p></li>
<li><p><strong>not correspond to the context for a multibody model</strong><strong>, or </strong><strong>if the</strong> – </p></li>
<li><p><strong>length of v is not equal to num_velocities</strong><strong>(</strong><strong>)</strong><strong></strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>SetVelocities(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], model_instance: pydrake.multibody.tree.ModelInstanceIndex, v: numpy.ndarray[object[m, 1]]) -&gt; None</p></li>
</ol>
<p>Sets the generalized velocities v for a particular model instance in a
given Context from a given vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the context is nullptr</strong><strong>, </strong><strong>if context does</strong> – </p></li>
<li><p><strong>not correspond to the Context for a multibody model</strong><strong>, </strong><strong>if the model</strong> – </p></li>
<li><p><strong>instance index is invalid</strong><strong>, or </strong><strong>if the length of v_instance is</strong> – </p></li>
<li><p><strong>not equal to num_velocities</strong><strong>(</strong><strong>model_instance</strong><strong>)</strong><strong></strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.SetVelocitiesInArray">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].SetVelocitiesInArray"></span><span class="sig-name descname"><span class="pre">SetVelocitiesInArray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">v_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.writeable</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.SetVelocitiesInArray" title="Permalink to this definition"></a></dt>
<dd><p>Sets the vector of generalized velocities for <code class="docutils literal notranslate"><span class="pre">model_instance</span></code> in
<code class="docutils literal notranslate"><span class="pre">v</span></code> using <code class="docutils literal notranslate"><span class="pre">v_instance</span></code>, leaving all other elements in the array
untouched. This method throws an exception if <code class="docutils literal notranslate"><span class="pre">v</span></code> is not of size
MultibodyPlant::num_velocities() or <code class="docutils literal notranslate"><span class="pre">v_instance</span></code> is not of size
<code class="docutils literal notranslate"><span class="pre">MultibodyPlant::num_positions(model_instance)</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.time_step">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].time_step"></span><span class="sig-name descname"><span class="pre">time_step</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.time_step" title="Permalink to this definition"></a></dt>
<dd><p>The time step (or period) used to model <code class="docutils literal notranslate"><span class="pre">this</span></code> plant as a discrete
system with periodic updates. Returns 0 (zero) if the plant is modeled
as a continuous system. This property of the plant is specified at
construction and therefore this query can be performed either pre- or
post-finalize, see Finalize().</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>MultibodyPlant::MultibodyPlant(double)</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.WeldFrames">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].WeldFrames"></span><span class="sig-name descname"><span class="pre">WeldFrames</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.WeldFrames" title="Permalink to this definition"></a></dt>
<dd><dl>
<dt>WeldFrames(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], frame_on_parent_F: pydrake.multibody.tree.Frame_[AutoDiffXd], frame_on_child_M: pydrake.multibody.tree.Frame_[AutoDiffXd], X_FM: pydrake.math.RigidTransform = RigidTransform(</dt><dd><dl class="simple">
<dt>R=RotationMatrix([</dt><dd><p>[1.0, 0.0, 0.0],
[0.0, 1.0, 0.0],
[0.0, 0.0, 1.0],</p>
</dd>
</dl>
<p>]),
p=[0.0, 0.0, 0.0],</p>
</dd>
</dl>
<p>)) -&gt; pydrake.multibody.tree.WeldJoint_[AutoDiffXd]</p>
<p>Welds <code class="docutils literal notranslate"><span class="pre">frame_on_parent_F</span></code> and <code class="docutils literal notranslate"><span class="pre">frame_on_child_M</span></code> with relative
pose <code class="docutils literal notranslate"><span class="pre">X_FM</span></code>. That is, the pose of frame M in frame F is fixed, with
value <code class="docutils literal notranslate"><span class="pre">X_FM</span></code>. If <code class="docutils literal notranslate"><span class="pre">X_FM</span></code> is omitted, the identity transform will be
used. The call to this method creates and adds a new WeldJoint to the
model. The new WeldJoint is named as: frame_on_parent_F.name() +
“_welds_to_” + frame_on_child_M.name().</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a constant reference to the WeldJoint welding frames F and M.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>RuntimeError if the weld produces a duplicate joint name.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.world_body">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].world_body"></span><span class="sig-name descname"><span class="pre">world_body</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody_" title="pydrake.multibody.tree.RigidBody_"><span class="pre">pydrake.multibody.tree.RigidBody_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.world_body" title="Permalink to this definition"></a></dt>
<dd><p>Returns a constant reference to the <em>world</em> body.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.world_frame">
<span id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].world_frame"></span><span class="sig-name descname"><span class="pre">world_frame</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBodyFrame_" title="pydrake.multibody.tree.RigidBodyFrame_"><span class="pre">pydrake.multibody.tree.RigidBodyFrame_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-AutoDiffXd-.world_frame" title="Permalink to this definition"></a></dt>
<dd><p>Returns a constant reference to the <em>world</em> frame.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">MultibodyPlant_[Expression]</span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.LeafSystem_-Expression" title="pydrake.systems.framework.LeafSystem_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem_[Expression]</span></code></a></p>
<p>MultibodyPlant is a Drake system framework representation (see
systems::System) for the model of a physical system consisting of a
collection of interconnected bodies. See multibody for an overview of
concepts/notation.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">actuation&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">applied_generalized_force&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">applied_spatial_force&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px"><em style="color:gray">model_instance_name[i]</em>_actuation&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px"><em style="color:gray">model_instance_name[i]</em>_desired_state&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px"><span style="color:green">geometry_query</span>&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>MultibodyPlant</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; state</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; body_poses</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; body_spatial_velocities</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; body_spatial_accelerations</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; generalized_acceleration</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; net_actuation</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; reaction_forces</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; contact_results</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; <em style="color:gray">model_instance_name[i]</em>_state</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; <em style="color:gray"> model_instance_name[i]</em>_generalized_acceleration</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; <em style="color:gray"> model_instance_name[i]</em>_generalized_contact_forces</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; <em style="color:gray">model_instance_name[i]</em>_net_actuation</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; <span style="color:green">geometry_pose</span></td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; <span style="color:green">deformable_body_configuration</span></td></tr></table></td></tr></table><p>The ports whose names begin with &lt;em style=”color:gray”&gt;
model_instance_name[i]&lt;/em&gt; represent groups of ports, one for each of
the model_instances “model instances”, with i ∈ {0, …, N-1} for the
N model instances. If a model instance does not contain any data of
the indicated type the port will still be present but its value will
be a zero-length vector. (Model instances <code class="docutils literal notranslate"><span class="pre">world_model_instance()</span></code>
and <code class="docutils literal notranslate"><span class="pre">default_model_instance()</span></code> always exist.)</p>
<p>The ports shown in &lt;span style=”color:green”&gt; green&lt;/span&gt; are for
communication with Drake’s geometry::SceneGraph “SceneGraph” system
for dealing with geometry.</p>
<p>MultibodyPlant provides a user-facing API for:</p>
<ul class="simple">
<li><p>mbp_input_and_output_ports “Ports”:</p></li>
</ul>
<p>Access input and output ports.
- mbp_construction “Construction”:
Add bodies, joints, frames, force elements, and actuators.
- mbp_geometry “Geometry”:
Register geometries to a provided SceneGraph instance.
- mbp_contact_modeling “Contact modeling”:
Select and parameterize contact models.
- mbp_state_accessors_and_mutators “State access and modification”:
Obtain and manipulate position and velocity state variables.
- mbp_parameters “Parameters”
Working with system parameters for various multibody elements.
- mbp_working_with_free_bodies “Free bodies”:
Work conveniently with free (floating) bodies.
- mbp_kinematic_and_dynamic_computations “Kinematics and dynamics”:
Perform systems::Context “Context”-dependent kinematic and dynamic
queries.
- mbp_system_matrix_computations “System matrices”:
Explicitly form matrices that appear in the equations of motion.
- mbp_introspection “Introspection”:
Perform introspection to find out what’s in the MultibodyPlant.</p>
<p><a href="#id61"><span class="problematic" id="id62">**</span></a>** Model Instances</p>
<p>A MultiBodyPlant may contain multiple model instances. Each model
instance corresponds to a set of bodies and their connections
(joints). Model instances provide methods to get or set the state of
the set of bodies (e.g., through GetPositionsAndVelocities() and
SetPositionsAndVelocities()), connecting controllers (through
get_state_output_port() and get_actuation_input_port()), and
organizing duplicate models (read through a parser). In fact, many
MultibodyPlant methods are overloaded to allow operating on the entire
plant or just the subset corresponding to the model instance; for
example, one GetPositions() method obtains the generalized positions
for the entire plant while another GetPositions() method obtains the
generalized positions for model instance.</p>
<p>Model instances are frequently defined through SDFormat files (using
the <code class="docutils literal notranslate"><span class="pre">model</span></code> tag) and are automatically created when SDFormat files
are parsed (by Parser). There are two special
multibody::ModelInstanceIndex values. The world body is always
multibody::ModelInstanceIndex 0. multibody::ModelInstanceIndex 1 is
reserved for all elements with no explicit model instance and is
generally only relevant for elements created programmatically (and
only when a model instance is not explicitly specified). Note that
Parser creates model instances (resulting in a
multibody::ModelInstanceIndex ≥ 2) as needed.</p>
<p>See num_model_instances(), num_positions(), num_velocities(),
num_actuated_dofs(), AddModelInstance() GetPositionsAndVelocities(),
GetPositions(), GetVelocities(), SetPositionsAndVelocities(),
SetPositions(), SetVelocities(), GetPositionsFromArray(),
GetVelocitiesFromArray(), SetPositionsInArray(),
SetVelocitiesInArray(), SetActuationInArray(),
HasModelInstanceNamed(), GetModelInstanceName(),
get_state_output_port(), get_actuation_input_port().</p>
<p><a href="#id63"><span class="problematic" id="id64">**</span></a>** System dynamics</p>
<p>The state of a multibody system <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">[q;</span> <span class="pre">v]</span></code> is given by its
generalized positions vector q, of size <code class="docutils literal notranslate"><span class="pre">nq</span></code> (see num_positions()),
and by its generalized velocities vector v, of size <code class="docutils literal notranslate"><span class="pre">nv</span></code> (see
num_velocities()). As a Drake systems::System “System”, MultibodyPlant
implements the governing equations for a multibody dynamical system in
the form <code class="docutils literal notranslate"><span class="pre">ẋ</span> <span class="pre">=</span> <span class="pre">f(t,</span> <span class="pre">x,</span> <span class="pre">u)</span></code> with t being time and u the actuation
forces. The governing equations for the dynamics of a multibody system
modeled with MultibodyPlant are [Featherstone 2008, Jain 2010]:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>q̇ = N(q)v
(1)    M(q)v̇ + C(q, v)v = τ
</pre></div>
</div>
</details><p>where <code class="docutils literal notranslate"><span class="pre">M(q)</span></code> is the mass matrix of the multibody system (including
rigid body mass properties and reflected_inertia “reflected
inertias”), <code class="docutils literal notranslate"><span class="pre">C(q,</span> <span class="pre">v)v</span></code> contains Coriolis, centripetal, and
gyroscopic terms and <code class="docutils literal notranslate"><span class="pre">N(q)</span></code> is the kinematic coupling matrix
describing the relationship between q̇ (the time derivatives of the
generalized positions) and the generalized velocities v, [Seth 2010].
<code class="docutils literal notranslate"><span class="pre">N(q)</span></code> is an <code class="docutils literal notranslate"><span class="pre">nq</span> <span class="pre">x</span> <span class="pre">nv</span></code> matrix. The vector <code class="docutils literal notranslate"><span class="pre">τ</span> <span class="pre">∈</span> <span class="pre">ℝⁿᵛ</span></code> on the right
hand side of Eq. (1) is the system’s generalized forces. These
incorporate gravity, springs, externally applied body forces,
constraint forces, and contact forces.</p>
<p><a href="#id65"><span class="problematic" id="id66">**</span></a>** Actuation</p>
<p>In a MultibodyPlant model an actuator can be added as a JointActuator,
see AddJointActuator(). The plant declares actuation input ports to
provide feedforward actuation, both for the MultibodyPlant as a whole
(see get_actuation_input_port()) and for each individual
model_instances “model instance” in the MultibodyPlant (see
get_actuation_input_port(ModelInstanceIndex)const
“get_actuation_input_port(ModelInstanceIndex)”). Any actuation input
ports not connected are assumed to be zero. Actuation values from the
full MultibodyPlant model port (get_actuation_input_port()) and from
the per model-instance ports (
get_actuation_input_port(ModelInstanceIndex)const
“get_actuation_input_port(ModelInstanceIndex)”) are summed up.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A JointActuator’s index into the vector data supplied to
MultibodyPlant’s actuation input port for all actuators
(get_actuation_input_port()) is given by
JointActuator::input_start(), NOT by its JointActuatorIndex. That
is, the vector element data for a JointActuator at index
JointActuatorIndex(i) in the full input port vector is found at
index:
MultibodyPlant::get_joint_actuator(JointActuatorIndex(i)).input_start().
For the get_actuation_input_port(ModelInstanceIndex)const
“get_actuation_input_port(ModelInstanceIndex)” specific to a model
index, the vector data is ordered by monotonically increasing
JointActuatorIndex for the actuators within that model instance:
the 0ᵗʰ vector element corresponds to the lowest-numbered
JointActuatorIndex of that instance, the 1ˢᵗ vector element
corresponds to the second-lowest-numbered JointActuatorIndex of
that instance, etc.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The following snippet shows how per model instance actuation can
be set:</p>
</div>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">ModelInstanceIndex</span><span class="w"> </span><span class="n">model_instance_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...;</span><span class="w"></span>
<span class="n">VectorX</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">u_instance</span><span class="p">(</span><span class="n">plant</span><span class="p">.</span><span class="n">num_actuated_dofs</span><span class="p">(</span><span class="n">model_instance_index</span><span class="p">));</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">JointActuatorIndex</span><span class="w"> </span><span class="n">joint_actuator_index</span><span class="w"> </span><span class="o">:</span><span class="w"></span>
<span class="n">plant</span><span class="p">.</span><span class="n">GetJointActuatorIndices</span><span class="p">(</span><span class="n">model_instance_index</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="n">JointActuator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">actuator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">plant</span><span class="p">.</span><span class="n">get_joint_actuator</span><span class="p">(</span><span class="w"></span>
<span class="n">joint_actuator_index</span><span class="p">);</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="n">Joint</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">joint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">actuator</span><span class="p">.</span><span class="n">joint</span><span class="p">();</span><span class="w"></span>
<span class="n">VectorX</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">u_joint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="n">my_actuation_logic_for</span><span class="p">(</span><span class="n">joint</span><span class="p">)</span><span class="w"> </span><span class="p">...;</span><span class="w"></span>
<span class="n">ASSERT</span><span class="p">(</span><span class="n">u_joint</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">joint_actuator</span><span class="p">.</span><span class="n">num_inputs</span><span class="p">());</span><span class="w"></span>
<span class="n">u_instance</span><span class="p">.</span><span class="n">segment</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="n">u_joint</span><span class="p">.</span><span class="n">size</span><span class="p">())</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">u_joint</span><span class="p">;</span><span class="w"></span>
<span class="n">offset</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">u_joint</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="n">plant</span><span class="p">.</span><span class="n">get_actuation_input_port</span><span class="p">(</span><span class="n">model_instance_index</span><span class="p">).</span><span class="n">FixValue</span><span class="p">(</span><span class="w"></span>
<span class="n">plant_context</span><span class="p">,</span><span class="w"> </span><span class="n">u_instance</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</details><div class="admonition note">
<p class="admonition-title">Note</p>
<p>To inter-operate between the whole plant actuation vector and sets
of per-model instance actuation vectors, see SetActuationInArray()
to gather the model instance vectors into a whole plant vector and
GetActuationFromArray() to scatter the whole plant vector into
per-model instance vectors.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Effort limits (JointActuator::effort_limit()) are not enforced,
unless PD controllers are defined. See pd_controllers “Using PD
controlled actuators”.</p>
</div>
<p>** Using PD controlled actuators</p>
<p>While PD controllers can be modeled externally and be connected to the
MultibodyPlant model via the get_actuation_input_port(), simulation
stability at discrete time steps can be compromised for high
controller gains. For such cases, simulation stability and robustness
can be improved significantly by moving your PD controller into the
plant where the discrete solver can strongly couple controller and
model dynamics.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Currently, this feature is only supported for discrete models
(is_discrete() is true) using the SAP solver
(get_discrete_contact_solver() returns
DiscreteContactSolver::kSap.)</p>
</div>
<p>PD controlled joint actuators can be defined by setting PD gains for
each joint actuator, see JointActuator::set_controller_gains(). Unless
these gains are specified, joint actuators will not be PD controlled
and JointActuator::has_controller() will return <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>For PD controlled models, all joint actuators in a model instance
are required to have PD controllers defined. That is, partially PD
controlled model instances are not supported. An exception will be
thrown when evaluating the actuation input ports if only a subset
of the actuators in a model instance is PD controlled.</p>
</div>
<p>For models with PD controllers, the actuation torque per actuator is
computed according to:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>ũ = -Kp⋅(q − qd) - Kd⋅(v − vd) + u_ff
u = max(−e, min(e, ũ))
</pre></div>
</div>
</details><p>where qd and vd are desired configuration and velocity (see
get_desired_state_input_port()) for the actuated joint (see
JointActuator::joint()), Kp and Kd are the proportional and derivative
gains of the actuator (see JointActuator::get_controller_gains()),
<code class="docutils literal notranslate"><span class="pre">u_ff</span></code> is the feed-forward actuation specified with
get_actuation_input_port(), and <code class="docutils literal notranslate"><span class="pre">e</span></code> corresponds to effort limit (see
JointActuator::effort_limit()).</p>
<p>Notice that actuation through get_actuation_input_port() and PD
control are not mutually exclusive, and they can be used together.
This is better explained through examples: 1. <strong>PD controlled
gripper</strong>. In this case, only PD control is used to drive the opening
and closing of the fingers. The feed-forward term is assumed to be
zero and the actuation input port is not required to be connected. 2.
<strong>Robot arm</strong>. A typical configuration consists on applying gravity
compensation in the feed-forward term plus PD control to drive the
robot to a given desired state.</p>
<p>** Actuation input ports requirements</p>
<p>The following table specifies whether actuation ports are required to
be connected or not:</p>
<div class="line-block">
<div class="line">Port | without PD control | with PD control | |</div>
</div>
<dl class="field-list">
<dt class="field-odd">——————————</dt>
<dd class="field-odd"><div class="line-block">
<div class="line">:——————-: |</div>
</div>
</dd>
<dt class="field-even">————-</dt>
<dd class="field-even"><div class="line-block">
<div class="line">| get_actuation_input_port() | yes | no¹ | |</div>
</div>
</dd>
</dl>
<p>get_desired_state_input_port() | no² | yes |</p>
<p>¹ Feed-forward actuation is not required for models with PD controlled
actuators. This simplifies the diagram wiring for models that only
rely on PD controllers.</p>
<p>² This port is always declared, though it will be zero sized for model
instances with no PD controllers.</p>
<p>** Net actuation</p>
<p>The total joint actuation applied via the actuation input port
(get_actuation_input_port()) and applied by the PD controllers is
reported by the net actuation port (get_net_actuation_output_port()).
That is, the net actuation port reports the total actuation applied by
a given actuator.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>PD controllers are ignored when a joint is locked (see
Joint::Lock()), and thus they have no effect on the actuation
output.</p>
</div>
<p><a href="#id67"><span class="problematic" id="id68">**</span></a>** Loading models from SDFormat files</p>
<p>Drake has the capability to load multibody models from SDFormat and
URDF files. Consider the example below which loads an acrobot model:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">acrobot</span><span class="p">;</span><span class="w"></span>
<span class="n">SceneGraph</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">scene_graph</span><span class="p">;</span><span class="w"></span>
<span class="n">Parser</span><span class="w"> </span><span class="nf">parser</span><span class="p">(</span><span class="o">&amp;</span><span class="n">acrobot</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">scene_graph</span><span class="p">);</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">url</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="s">&quot;package://drake/multibody/benchmarks/acrobot/acrobot.sdf&quot;</span><span class="p">;</span><span class="w"></span>
<span class="n">parser</span><span class="p">.</span><span class="n">AddModelsFromUrl</span><span class="p">(</span><span class="n">url</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</details><p>As in the example above, for models including visual geometry,
collision geometry or both, the user must specify a SceneGraph for
geometry handling. You can find a full example of the LQR controlled
acrobot in examples/multibody/acrobot/run_lqr.cc.</p>
<p>AddModelFromFile() can be invoked multiple times on the same plant in
order to load multiple model instances. Other methods are available on
Parser such as AddModels() which allows creating model instances per
each <code class="docutils literal notranslate"><span class="pre">&lt;model&gt;</span></code> tag found in the file. Please refer to each of these
methods’ documentation for further details.</p>
<p><a href="#id69"><span class="problematic" id="id70">**</span></a>** Working with SceneGraph</p>
<p>** Adding a MultibodyPlant connected to a SceneGraph to your Diagram</p>
<p>Probably the simplest way to add and wire up a MultibodyPlant with a
SceneGraph in your Diagram is using AddMultibodyPlantSceneGraph().</p>
<p>Recommended usages:</p>
<p>Assign to a MultibodyPlant reference (ignoring the SceneGraph):</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">plant</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="n">AddMultibodyPlantSceneGraph</span><span class="p">(</span><span class="o">&amp;</span><span class="n">builder</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="o">/+</span><span class="w"> </span><span class="n">time_step</span><span class="w"> </span><span class="o">+/</span><span class="p">);</span><span class="w"></span>
<span class="n">plant</span><span class="p">.</span><span class="n">DoFoo</span><span class="p">(...);</span><span class="w"></span>
</pre></div>
</div>
</details><p>This flavor is the simplest, when the SceneGraph is not explicitly
needed. (It can always be retrieved later via
GetSubsystemByName(“scene_graph”).)</p>
<p>Assign to auto, and use the named public fields:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="n">items</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AddMultibodyPlantSceneGraph</span><span class="p">(</span><span class="o">&amp;</span><span class="n">builder</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="o">/+</span><span class="w"> </span><span class="n">time_step</span><span class="w"> </span><span class="o">+/</span><span class="p">);</span><span class="w"></span>
<span class="n">items</span><span class="p">.</span><span class="n">plant</span><span class="p">.</span><span class="n">DoFoo</span><span class="p">(...);</span><span class="w"></span>
<span class="n">items</span><span class="p">.</span><span class="n">scene_graph</span><span class="p">.</span><span class="n">DoBar</span><span class="p">(...);</span><span class="w"></span>
</pre></div>
</div>
</details><p>or taking advantage of C++’s structured binding:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="p">[</span><span class="n">plant</span><span class="p">,</span><span class="w"> </span><span class="n">scene_graph</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AddMultibodyPlantSceneGraph</span><span class="p">(</span><span class="o">&amp;</span><span class="n">builder</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">);</span><span class="w"></span>
<span class="p">...</span><span class="w"></span>
<span class="n">plant</span><span class="p">.</span><span class="n">DoFoo</span><span class="p">(...);</span><span class="w"></span>
<span class="n">scene_graph</span><span class="p">.</span><span class="n">DoBar</span><span class="p">(...);</span><span class="w"></span>
</pre></div>
</div>
</details><p>This is the easiest way to use both the plant and scene_graph.</p>
<p>Assign to already-declared pointer variables:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;*</span><span class="w"> </span><span class="n">plant</span><span class="p">{};</span><span class="w"></span>
<span class="n">SceneGraph</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;*</span><span class="w"> </span><span class="n">scene_graph</span><span class="p">{};</span><span class="w"></span>
<span class="n">std</span><span class="o">::</span><span class="n">tie</span><span class="p">(</span><span class="n">plant</span><span class="p">,</span><span class="w"> </span><span class="n">scene_graph</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="n">AddMultibodyPlantSceneGraph</span><span class="p">(</span><span class="o">&amp;</span><span class="n">builder</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="o">/+</span><span class="w"> </span><span class="n">time_step</span><span class="w"> </span><span class="o">+/</span><span class="p">);</span><span class="w"></span>
<span class="n">plant</span><span class="o">-&gt;</span><span class="n">DoFoo</span><span class="p">(...);</span><span class="w"></span>
<span class="n">scene_graph</span><span class="o">-&gt;</span><span class="n">DoBar</span><span class="p">(...);</span><span class="w"></span>
</pre></div>
</div>
</details><p>This flavor is most useful when the pointers are class member fields
(and so perhaps cannot be references).</p>
<p>** Registering geometry with a SceneGraph</p>
<p>MultibodyPlant users can register geometry with a SceneGraph for
essentially two purposes; a) visualization and, b) contact modeling.</p>
<p>Before any geometry registration takes place, a user <strong>must</strong> first
make a call to RegisterAsSourceForSceneGraph() in order to register
the MultibodyPlant as a client of a SceneGraph instance, point at
which the plant will have assigned a valid geometry::SourceId. At
Finalize(), MultibodyPlant will declare input/output ports as
appropriate to communicate with the SceneGraph instance on which
registrations took place. All geometry registration <strong>must</strong> be
performed pre-finalize.</p>
<p>Multibodyplant declares an input port for geometric queries, see
get_geometry_query_input_port(). If MultibodyPlant registers geometry
with a SceneGraph via calls to RegisterCollisionGeometry(), users may
use this port for geometric queries. The port must be connected to the
same SceneGraph used for registration. The preferred mechanism is to
use AddMultibodyPlantSceneGraph() as documented above.</p>
<p>In extraordinary circumstances, this can be done by hand and the setup
process will include:</p>
<ol class="arabic simple">
<li><p>Call to RegisterAsSourceForSceneGraph().</p></li>
<li><p>Calls to RegisterCollisionGeometry(), as many as needed.</p></li>
<li><p>Call to Finalize(), user is done specifying the model.</p></li>
</ol>
<p>4. Connect geometry::SceneGraph::get_query_output_port() to
get_geometry_query_input_port().
5. Connect get_geometry_poses_output_port() to
geometry::SceneGraph::get_source_pose_port()</p>
<p>Refer to the documentation provided in each of the methods above for
further details.</p>
<p>** Accessing point contact parameters MultibodyPlant’s point contact
model looks for model parameters stored as
geometry::ProximityProperties by geometry::SceneGraph. These
properties can be obtained before or after context creation through
geometry::SceneGraphInspector APIs as outlined below. MultibodyPlant
expects the following properties for point contact modeling:</p>
<p><a href="#id123"><span class="problematic" id="id124">|Group name|Property Name|Required|Property Type|Property Description|</span></a>
<a href="#id125"><span class="problematic" id="id126">|:--------:|</span></a>:———–:<a href="#id127"><span class="problematic" id="id128">|:------:|</span></a>:—————-:<a href="#id129"><span class="problematic" id="id130">|:-------------------|</span></a>
<a href="#id131"><span class="problematic" id="id132">|material|coulomb_friction|yes¹|CoulombFriction&lt;T&gt;|Static and Dynamic
friction.|</span></a> <a href="#id133"><span class="problematic" id="id134">|material|point_contact_stiffness|no²|T|</span></a> Compliant point
contact stiffness.| <a href="#id135"><span class="problematic" id="id136">|material|hunt_crossley_dissipation |no²⁴|T|</span></a>
Compliant contact dissipation.|
<a href="#id137"><span class="problematic" id="id138">|material|relaxation_time|yes³⁴|T|Linear Kelvin–Voigt model
parameter.|</span></a></p>
<p>¹ Collision geometry is required to be registered with a
geometry::ProximityProperties object that contains the (“material”,
“coulomb_friction”) property. If the property is missing,
MultibodyPlant will throw an exception.</p>
<p>² If the property is missing, MultibodyPlant will use a heuristic
value as the default. Refer to the section mbp_compliant_point_contact
“Compliant point contact model” for further details.</p>
<p>³ When using a linear Kelvin–Voigt model of dissipation (for instance
when selecting the SAP solver), collision geometry is required to be
registered with a geometry::ProximityProperties object that contains
the (“material”, “relaxation_time”) property. If the property is
missing, an exception will be thrown.</p>
<p>⁴ We allow to specify both hunt_crossley_dissipation and
relaxation_time for a given geometry. However only one of these will
get used, depending on the configuration of the MultibodyPlant. As an
example, if the SAP contact approximation is specified (see
set_discrete_contact_approximation()) only the relaxation_time is used
while hunt_crossley_dissipation is ignored. Conversely, if the TAMSI,
Similar or Lagged approximation is used (see
set_discrete_contact_approximation()) only hunt_crossley_dissipation
is used while relaxation_time is ignored. Currently, a continuous
MultibodyPlant model will always use the Hunt &amp; Crossley model and
relaxation_time will be ignored.</p>
<p>Accessing and modifying contact properties requires interfacing with
geometry::SceneGraph’s model inspector. Interfacing with a model
inspector obtained from geometry::SceneGraph will provide the default
registered values for a given parameter. These are the values that
will initially appear in a systems::Context created by
CreateDefaultContext(). Subsequently, true system parameters can be
accessed and changed through a systems::Context once available. For
both of the above cases, proximity properties are accessed through
geometry::SceneGraphInspector APIs.</p>
<p>Before context creation an inspector can be retrieved directly from
SceneGraph as:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// For a SceneGraph&lt;T&gt; instance called scene_graph.</span>
<span class="k">const</span><span class="w"> </span><span class="n">geometry</span><span class="o">::</span><span class="n">SceneGraphInspector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">inspector</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="n">scene_graph</span><span class="p">.</span><span class="n">model_inspector</span><span class="p">();</span><span class="w"></span>
</pre></div>
</div>
</details><p>After context creation, an inspector can be retrieved from the state
stored in the context by the plant’s geometry query input port:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// For a MultibodyPlant&lt;T&gt; instance called mbp and a</span>
<span class="c1">// Context&lt;T&gt; called context.</span>
<span class="k">const</span><span class="w"> </span><span class="n">geometry</span><span class="o">::</span><span class="n">QueryObject</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">query_object</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="n">mbp</span><span class="p">.</span><span class="n">get_geometry_query_input_port</span><span class="p">()</span><span class="w"></span>
<span class="p">.</span><span class="k">template</span><span class="w"> </span><span class="n">Eval</span><span class="o">&lt;</span><span class="n">geometry</span><span class="o">::</span><span class="n">QueryObject</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">context</span><span class="p">);</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="n">geometry</span><span class="o">::</span><span class="n">SceneGraphInspector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">inspector</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="n">query_object</span><span class="p">.</span><span class="n">inspector</span><span class="p">();</span><span class="w"></span>
</pre></div>
</div>
</details><p>Once an inspector is available, proximity properties can be retrieved
as:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// For a body with GeometryId called geometry_id</span>
<span class="k">const</span><span class="w"> </span><span class="n">geometry</span><span class="o">::</span><span class="n">ProximityProperties</span><span class="o">*</span><span class="w"> </span><span class="n">props</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="n">inspector</span><span class="p">.</span><span class="n">GetProximityProperties</span><span class="p">(</span><span class="n">geometry_id</span><span class="p">);</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="n">CoulombFriction</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">geometry_friction</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="n">props</span><span class="o">-&gt;</span><span class="n">GetProperty</span><span class="o">&lt;</span><span class="n">CoulombFriction</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="s">&quot;material&quot;</span><span class="p">,</span><span class="w"></span>
<span class="s">&quot;coulomb_friction&quot;</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</details><p><a href="#id71"><span class="problematic" id="id72">**</span></a>** Working with MultibodyElement parameters Several
MultibodyElements expose parameters, allowing the user flexible
modification of some aspects of the plant’s model, post
systems::Context creation. For details, refer to the documentation for
the MultibodyElement whose parameters you are trying to modify/access
(e.g. RigidBody, FixedOffsetFrame, etc.)</p>
<p>As an example, here is how to access and modify rigid body mass
parameters:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">plant</span><span class="p">;</span><span class="w"></span>
<span class="c1">// ... Code to add bodies, finalize plant, and to obtain a context.</span>
<span class="k">const</span><span class="w"> </span><span class="n">RigidBody</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">body</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="n">plant</span><span class="p">.</span><span class="n">GetRigidBodyByName</span><span class="p">(</span><span class="s">&quot;BodyName&quot;</span><span class="p">);</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="n">SpatialInertia</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">M_BBo_B</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="n">body</span><span class="p">.</span><span class="n">GetSpatialInertiaInBodyFrame</span><span class="p">(</span><span class="n">context</span><span class="p">);</span><span class="w"></span>
<span class="c1">// .. logic to determine a new SpatialInertia parameter for body.</span>
<span class="k">const</span><span class="w"> </span><span class="n">SpatialInertia</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">M_BBo_B_new</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">....</span><span class="w"></span>

<span class="c1">// Modify the body parameter for spatial inertia.</span>
<span class="n">body</span><span class="p">.</span><span class="n">SetSpatialInertiaInBodyFrame</span><span class="p">(</span><span class="o">&amp;</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="n">M_BBo_B_new</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</details><p>Another example, working with automatic differentiation in order to
take derivatives with respect to one of the bodies’ masses:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">plant</span><span class="p">;</span><span class="w"></span>
<span class="c1">// ... Code to add bodies, finalize plant, and to obtain a</span>
<span class="c1">// context and a body&#39;s spatial inertia M_BBo_B.</span>

<span class="c1">// Scalar convert the plant.</span>
<span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="n">AutoDiffXd</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">plant_autodiff</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="n">systems</span><span class="o">::</span><span class="n">System</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">ToAutoDiffXd</span><span class="p">(</span><span class="n">plant</span><span class="p">);</span><span class="w"></span>
<span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Context</span><span class="o">&lt;</span><span class="n">AutoDiffXd</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">context_autodiff</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="n">plant_autodiff</span><span class="o">-&gt;</span><span class="n">CreateDefaultContext</span><span class="p">();</span><span class="w"></span>
<span class="n">context_autodiff</span><span class="o">-&gt;</span><span class="n">SetTimeStateAndParametersFrom</span><span class="p">(</span><span class="n">context</span><span class="p">);</span><span class="w"></span>

<span class="k">const</span><span class="w"> </span><span class="n">RigidBody</span><span class="o">&lt;</span><span class="n">AutoDiffXd</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">body</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="n">plant_autodiff</span><span class="o">-&gt;</span><span class="n">GetRigidBodyByName</span><span class="p">(</span><span class="s">&quot;BodyName&quot;</span><span class="p">);</span><span class="w"></span>

<span class="c1">// Modify the body parameter for mass.</span>
<span class="k">const</span><span class="w"> </span><span class="n">AutoDiffXd</span><span class="w"> </span><span class="nf">mass_autodiff</span><span class="p">(</span><span class="n">mass</span><span class="p">,</span><span class="w"> </span><span class="n">Vector1d</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span><span class="w"></span>
<span class="n">body</span><span class="p">.</span><span class="n">SetMass</span><span class="p">(</span><span class="n">context_autodiff</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span><span class="w"> </span><span class="n">mass_autodiff</span><span class="p">);</span><span class="w"></span>

<span class="c1">// M_autodiff(i, j).derivatives()(0), contains the derivatives of</span>
<span class="c1">// M(i, j) with respect to the body&#39;s mass.</span>
<span class="n">MatrixX</span><span class="o">&lt;</span><span class="n">AutoDiffXd</span><span class="o">&gt;</span><span class="w"> </span><span class="n">M_autodiff</span><span class="p">(</span><span class="n">plant_autodiff</span><span class="o">-&gt;</span><span class="n">num_velocities</span><span class="p">(),</span><span class="w"></span>
<span class="n">plant_autodiff</span><span class="o">-&gt;</span><span class="n">num_velocities</span><span class="p">());</span><span class="w"></span>
<span class="n">plant_autodiff</span><span class="o">-&gt;</span><span class="n">CalcMassMatrix</span><span class="p">(</span><span class="o">*</span><span class="n">context_autodiff</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">M_autodiff</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</details><p><a href="#id73"><span class="problematic" id="id74">**</span></a>** Adding modeling elements</p>
<p>Add multibody elements to a MultibodyPlant with methods like:</p>
<ul class="simple">
<li><p>Bodies: AddRigidBody()</p></li>
<li><p>Joints: AddJoint()</p></li>
<li><p>see mbp_construction “Construction” for more.</p></li>
</ul>
<p>All modeling elements <strong>must</strong> be added before Finalize() is called.
See mbp_finalize_stage “Finalize stage” for a discussion.</p>
<p><a href="#id75"><span class="problematic" id="id76">**</span></a>** Modeling contact</p>
<p>Please refer to drake_contacts “Contact Modeling in Drake” for details
on the available approximations, setup, and considerations for a
multibody simulation with frictional contact.</p>
<p><a href="#id77"><span class="problematic" id="id78">**</span></a>** Energy and Power</p>
<p>MultibodyPlant implements the System energy and power methods, with
some limitations. - Kinetic energy: fully implemented. - Potential
energy and conservative power: currently include only gravity and
contributions from ForceElement objects; potential energy from
compliant contact and joint limits are not included. - Nonconservative
power: currently includes only contributions from ForceElement
objects; actuation and input port forces, joint damping, and
dissipation from joint limits, friction, and contact dissipation are
not included.</p>
<p>See Drake issue #12942 for more discussion.</p>
<p><a href="#id79"><span class="problematic" id="id80">**</span></a>** Finalize() stage</p>
<p>Once the user is done adding modeling elements and registering
geometry, a call to Finalize() must be performed. This call will: -
Build the underlying tree structure of the multibody model, - declare
the plant’s state, - declare the plant’s input and output ports, -
declare collision filters to ignore collisions among rigid bodies: -
between rigid bodies connected by a joint, - within subgraphs of
welded rigid bodies. Note that MultibodyPlant will <em>not</em> introduce
<em>any</em> collision filters on deformable bodies.</p>
<p><a href="#id81"><span class="problematic" id="id82">**</span></a>** References</p>
<ul class="simple">
<li><p>[Featherstone 2008] Featherstone, R., 2008.</p></li>
</ul>
<p>Rigid body dynamics algorithms. Springer.
- [Jain 2010] Jain, A., 2010.
Robot and multibody dynamics: analysis and algorithms.
Springer Science &amp; Business Media.
- [Seth 2010] Seth, A., Sherman, M., Eastman, P. and Delp, S., 2010.
Minimal formulation of joint motion for biomechanisms.
Nonlinear dynamics, 62(1), pp.291-303.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.__init__">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_step</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.__init__" title="Permalink to this definition"></a></dt>
<dd><p>This constructor creates a plant with a single “world” body.
Therefore, right after creation, num_bodies() returns one.</p>
<p>MultibodyPlant offers two different modalities to model mechanical
systems in time. These are: 1. As a discrete system with periodic
updates, <code class="docutils literal notranslate"><span class="pre">time_step</span></code> is strictly greater than zero. 2. As a
continuous system, <code class="docutils literal notranslate"><span class="pre">time_step</span></code> equals exactly zero.</p>
<p>Currently the discrete model is preferred for simulation given its
robustness and speed in problems with frictional contact. However this
might change as we work towards developing better strategies to model
contact. See time_advancement_strategy “Choice of Time Advancement
Strategy” for further details.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Users should be aware of current limitations in either modeling
modality. While the discrete model is often the preferred option
for problems with frictional contact given its robustness and
speed, it might become unstable when using large feedback gains,
high damping or large external forcing. MultibodyPlant will throw
an exception whenever the discrete solver is detected to fail.
Conversely, the continuous modality has the potential to leverage
the robustness and accuracy control provide by Drake’s
integrators. However thus far this has proved difficult in
practice and especially due to poor performance.</p>
</div>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">time_step</span></code>:</dt><dd><p>Indicates whether <code class="docutils literal notranslate"><span class="pre">this</span></code> plant is modeled as a continuous system
(<code class="docutils literal notranslate"><span class="pre">time_step</span> <span class="pre">=</span> <span class="pre">0</span></code>) or as a discrete system with periodic updates
of period <code class="docutils literal notranslate"><span class="pre">time_step</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>. See time_advancement_strategy “Choice
of Time Advancement Strategy” for further details.</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Currently the continuous modality with <code class="docutils literal notranslate"><span class="pre">time_step</span> <span class="pre">=</span> <span class="pre">0</span></code> does not
support joint limits for simulation, these are ignored.
MultibodyPlant prints a warning to console if joint limits are
provided. If your simulation requires joint limits currently you
must use a discrete MultibodyPlant model.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if time_step is negative.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.AddBallConstraint">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].AddBallConstraint"></span><span class="sig-name descname"><span class="pre">AddBallConstraint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body_A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody_" title="pydrake.multibody.tree.RigidBody_"><span class="pre">pydrake.multibody.tree.RigidBody_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_AP</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody_" title="pydrake.multibody.tree.RigidBody_"><span class="pre">pydrake.multibody.tree.RigidBody_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_BQ</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.MultibodyConstraintId" title="pydrake.multibody.tree.MultibodyConstraintId"><span class="pre">pydrake.multibody.tree.MultibodyConstraintId</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.AddBallConstraint" title="Permalink to this definition"></a></dt>
<dd><p>Defines a constraint such that point P affixed to body A is coincident
at all times with point Q affixed to body B, effectively modeling a
ball-and-socket joint.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body_A</span></code>:</dt><dd><p>RigidBody to which point P is rigidly attached.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_AP</span></code>:</dt><dd><p>Position of point P in body A’s frame.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body_B</span></code>:</dt><dd><p>RigidBody to which point Q is rigidly attached.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BQ</span></code>:</dt><dd><p>Position of point Q in body B’s frame.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the id of the newly added constraint.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>RuntimeError if bodies A and B are the same body.</strong> – </p></li>
<li><p><strong>RuntimeError if the MultibodyPlant has already been finalized.</strong> – </p></li>
<li><p><strong>RuntimeError if this MultibodyPlant is not a discrete model</strong> – </p></li>
<li><p><strong>(</strong><strong>is_discrete</strong><strong>(</strong><strong>) </strong><strong>== false</strong><strong>)</strong> – </p></li>
<li><p><strong>RuntimeError if this MultibodyPlant's underlying contact</strong> – </p></li>
<li><p><strong>solver is not SAP.</strong><strong> (</strong><strong>i.e. get_discrete_contact_solver</strong><strong>(</strong><strong>) </strong><strong>!=</strong> – </p></li>
<li><p><strong>DiscreteContactSolver::kSap</strong><strong>)</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.AddCouplerConstraint">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].AddCouplerConstraint"></span><span class="sig-name descname"><span class="pre">AddCouplerConstraint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">joint0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Joint_" title="pydrake.multibody.tree.Joint_"><span class="pre">pydrake.multibody.tree.Joint_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">joint1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Joint_" title="pydrake.multibody.tree.Joint_"><span class="pre">pydrake.multibody.tree.Joint_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gear_ratio</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.0</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.MultibodyConstraintId" title="pydrake.multibody.tree.MultibodyConstraintId"><span class="pre">pydrake.multibody.tree.MultibodyConstraintId</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.AddCouplerConstraint" title="Permalink to this definition"></a></dt>
<dd><p>Defines a holonomic constraint between two single-dof joints
<code class="docutils literal notranslate"><span class="pre">joint0</span></code> and <code class="docutils literal notranslate"><span class="pre">joint1</span></code> with positions q₀ and q₁, respectively, such
that q₀ = ρ⋅q₁ + Δq, where ρ is the gear ratio and Δq is a fixed
offset. The gear ratio can have units if the units of q₀ and q₁ are
different. For instance, between a prismatic and a revolute joint the
gear ratio will specify the “pitch” of the resulting mechanism. As
defined, <code class="docutils literal notranslate"><span class="pre">offset</span></code> has units of <code class="docutils literal notranslate"><span class="pre">q₀</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>joint0 and/or joint1 can still be actuated, regardless of whether
we have coupler constraint among them. That is, one or both of
these joints can have external actuation applied to them.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Generally, to couple (q0, q1, q2), the user would define a coupler
between (q0, q1) and a second coupler between (q1, q2), or any
combination therein.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>if joint0 and joint1 are not both single-dof joints.</strong> – </p></li>
<li><p><strong>RuntimeError if the MultibodyPlant has already been finalized.</strong> – </p></li>
<li><p><strong>RuntimeError if this MultibodyPlant is not a discrete model</strong> – </p></li>
<li><p><strong>(</strong><strong>is_discrete</strong><strong>(</strong><strong>) </strong><strong>== false</strong><strong>)</strong> – </p></li>
<li><p><strong>RuntimeError if this MultibodyPlant's underlying contact</strong> – </p></li>
<li><p><strong>solver is not SAP.</strong><strong> (</strong><strong>i.e. get_discrete_contact_solver</strong><strong>(</strong><strong>) </strong><strong>!=</strong> – </p></li>
<li><p><strong>DiscreteContactSolver::kSap</strong><strong>)</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.AddDistanceConstraint">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].AddDistanceConstraint"></span><span class="sig-name descname"><span class="pre">AddDistanceConstraint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body_A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody_" title="pydrake.multibody.tree.RigidBody_"><span class="pre">pydrake.multibody.tree.RigidBody_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_AP</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody_" title="pydrake.multibody.tree.RigidBody_"><span class="pre">pydrake.multibody.tree.RigidBody_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_BQ</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stiffness</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">inf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">damping</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.0</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.MultibodyConstraintId" title="pydrake.multibody.tree.MultibodyConstraintId"><span class="pre">pydrake.multibody.tree.MultibodyConstraintId</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.AddDistanceConstraint" title="Permalink to this definition"></a></dt>
<dd><p>Defines a distance constraint between a point P on a body A and a
point Q on a body B.</p>
<p>This constraint can be compliant, modeling a spring with free length
<code class="docutils literal notranslate"><span class="pre">distance</span></code> and given <code class="docutils literal notranslate"><span class="pre">stiffness</span></code> and <code class="docutils literal notranslate"><span class="pre">damping</span></code> parameters
between points P and Q. For d = ‖p_PQ‖, then a compliant distance
constraint models a spring with force along p_PQ given by:</p>
<p>f = −stiffness ⋅ d − damping ⋅ ḋ</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body_A</span></code>:</dt><dd><p>RigidBody to which point P is rigidly attached.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_AP</span></code>:</dt><dd><p>Position of point P in body A’s frame.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body_B</span></code>:</dt><dd><p>RigidBody to which point Q is rigidly attached.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BQ</span></code>:</dt><dd><p>Position of point Q in body B’s frame.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">distance</span></code>:</dt><dd><p>Fixed length of the distance constraint, in meters. It must be
strictly positive.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">stiffness</span></code>:</dt><dd><p>For modeling a spring with free length equal to <code class="docutils literal notranslate"><span class="pre">distance</span></code>, the
stiffness parameter in N/m. Optional, with its default value being
infinite to model a rigid massless rod of length <code class="docutils literal notranslate"><span class="pre">distance</span></code>
connecting points A and B.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">damping</span></code>:</dt><dd><p>For modeling a spring with free length equal to <code class="docutils literal notranslate"><span class="pre">distance</span></code>,
damping parameter in N⋅s/m. Optional, with its default value being
zero for a non-dissipative constraint.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the id of the newly added constraint.</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Currently, it is the user’s responsibility to initialize the
model’s context in a configuration compatible with the newly added
constraint.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>A distance constraint is the wrong modeling choice if the distance
needs to go through zero. To constrain two points to be coincident
we need a 3-dof ball constraint, the 1-dof distance constraint is
singular in this case. Therefore we require the distance parameter
to be strictly positive.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if bodies A and B are the same body.</strong> – </p></li>
<li><p><strong>RuntimeError if distance is not strictly positive.</strong> – </p></li>
<li><p><strong>RuntimeError if stiffness is not positive</strong><strong> or </strong><strong>zero.</strong> – </p></li>
<li><p><strong>RuntimeError if damping is not positive</strong><strong> or </strong><strong>zero.</strong> – </p></li>
<li><p><strong>RuntimeError if the MultibodyPlant has already been finalized.</strong> – </p></li>
<li><p><strong>RuntimeError if this MultibodyPlant is not a discrete model</strong> – </p></li>
<li><p><strong>(</strong><strong>is_discrete</strong><strong>(</strong><strong>) </strong><strong>== false</strong><strong>)</strong> – </p></li>
<li><p><strong>RuntimeError if this MultibodyPlant's underlying contact</strong> – </p></li>
<li><p><strong>solver is not SAP.</strong><strong> (</strong><strong>i.e. get_discrete_contact_solver</strong><strong>(</strong><strong>) </strong><strong>!=</strong> – </p></li>
<li><p><strong>DiscreteContactSolver::kSap</strong><strong>)</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.AddForceElement">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].AddForceElement"></span><span class="sig-name descname"><span class="pre">AddForceElement</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">force_element</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ForceElement_" title="pydrake.multibody.tree.ForceElement_"><span class="pre">pydrake.multibody.tree.ForceElement_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ForceElement_" title="pydrake.multibody.tree.ForceElement_"><span class="pre">pydrake.multibody.tree.ForceElement_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.AddForceElement" title="Permalink to this definition"></a></dt>
<dd><p>Adds a new force element model of type <code class="docutils literal notranslate"><span class="pre">ForceElementType</span></code> to
<code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant. The arguments to this method <code class="docutils literal notranslate"><span class="pre">args</span></code> are
forwarded to <a href="#id83"><span class="problematic" id="id84">``</span></a>ForceElementType`’s constructor.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">args</span></code>:</dt><dd><p>Zero or more parameters provided to the constructor of the new
force element. It must be the case that
<cite>ForceElementType&lt;T&gt;(args)`</cite> is a valid constructor.</p>
</dd>
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">ForceElementType</span></code>:</dt><dd><p>The type of the ForceElement to add. As there is always a
UniformGravityFieldElement present (accessible through
gravity_field()), an exception will be thrown if this function is
called to add another UniformGravityFieldElement.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A constant reference to the new ForceElement just added, of type
<code class="docutils literal notranslate"><span class="pre">ForceElementType&lt;T&gt;</span></code> specialized on the scalar type T of
<code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant. It will remain valid for the lifetime of
<code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>The ForceElement class’s documentation for further details on how
a force element is defined.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.AddFrame">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].AddFrame"></span><span class="sig-name descname"><span class="pre">AddFrame</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame_" title="pydrake.multibody.tree.Frame_"><span class="pre">pydrake.multibody.tree.Frame_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame_" title="pydrake.multibody.tree.Frame_"><span class="pre">pydrake.multibody.tree.Frame_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.AddFrame" title="Permalink to this definition"></a></dt>
<dd><p>This method adds a Frame of type <code class="docutils literal notranslate"><span class="pre">FrameType&lt;T&gt;</span></code>. For more
information, please see the corresponding constructor of
<code class="docutils literal notranslate"><span class="pre">FrameType</span></code>.</p>
<dl class="simple">
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">FrameType</span></code>:</dt><dd><p>Template which will be instantiated on <code class="docutils literal notranslate"><span class="pre">T</span></code>.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame</span></code>:</dt><dd><p>Unique pointer frame instance.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A constant reference to the new Frame just added, which will
remain valid for the lifetime of <code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.AddJoint">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].AddJoint"></span><span class="sig-name descname"><span class="pre">AddJoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">joint</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Joint_" title="pydrake.multibody.tree.Joint_"><span class="pre">pydrake.multibody.tree.Joint_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Joint_" title="pydrake.multibody.tree.Joint_"><span class="pre">pydrake.multibody.tree.Joint_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.AddJoint" title="Permalink to this definition"></a></dt>
<dd><p>This method adds a Joint of type <code class="docutils literal notranslate"><span class="pre">JointType</span></code> between two bodies. For
more information, see the below overload of <code class="docutils literal notranslate"><span class="pre">AddJoint&lt;&gt;</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.AddJointActuator">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].AddJointActuator"></span><span class="sig-name descname"><span class="pre">AddJointActuator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">joint</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Joint_" title="pydrake.multibody.tree.Joint_"><span class="pre">pydrake.multibody.tree.Joint_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">effort_limit</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">inf</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JointActuator_" title="pydrake.multibody.tree.JointActuator_"><span class="pre">pydrake.multibody.tree.JointActuator_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.AddJointActuator" title="Permalink to this definition"></a></dt>
<dd><p>Creates and adds a JointActuator model for an actuator acting on a
given <code class="docutils literal notranslate"><span class="pre">joint</span></code>. This method returns a constant reference to the
actuator just added, which will remain valid for the lifetime of
<code class="docutils literal notranslate"><span class="pre">this</span></code> plant.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">name</span></code>:</dt><dd><p>A string that uniquely identifies the new actuator to be added to
<code class="docutils literal notranslate"><span class="pre">this</span></code> model. A RuntimeError is thrown if an actuator with the
same name already exists in the model. See
HasJointActuatorNamed().</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">joint</span></code>:</dt><dd><p>The Joint to be actuated by the new JointActuator.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">effort_limit</span></code>:</dt><dd><p>The maximum effort for the actuator. It must be strictly positive,
otherwise an RuntimeError is thrown. If +∞, the actuator has no
limit, which is the default. The effort limit has physical units
in accordance to the joint type it actuates. For instance, it will
have units of N⋅m (torque) for revolute joints while it will have
units of N (force) for prismatic joints.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The effort limit is unused by MultibodyPlant and is simply
provided here for bookkeeping purposes. It will not, for instance,
saturate external actuation inputs based on this value. If, for
example, a user intends to saturate the force/torque that is
applied to the MultibodyPlant via this actuator, the user-level
code (e.g., a controller) should query this effort limit and
impose the saturation there.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A constant reference to the new JointActuator just added, which
will remain valid for the lifetime of <code class="docutils literal notranslate"><span class="pre">this</span></code> plant or until the
JointActuator has been removed from the plant with
RemoveJointActuator().</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>RuntimeError if joint.num_velocities</strong><strong>(</strong><strong>) </strong><strong>&gt; 1 since for now we</strong> – </p></li>
<li><p><strong>only support actuators for single dof joints.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>RemoveJointActuator()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.AddModelInstance">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].AddModelInstance"></span><span class="sig-name descname"><span class="pre">AddModelInstance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.AddModelInstance" title="Permalink to this definition"></a></dt>
<dd><p>Creates a new model instance. Returns the index for the model
instance.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">name</span></code>:</dt><dd><p>A string that uniquely identifies the new instance to be added to
<code class="docutils literal notranslate"><span class="pre">this</span></code> model. An exception is thrown if an instance with the
same name already exists in the model. See
HasModelInstanceNamed().</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.AddPhysicalModel">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].AddPhysicalModel"></span><span class="sig-name descname"><span class="pre">AddPhysicalModel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">self:</span> <span class="pre">pydrake.multibody.plant.MultibodyPlant_[Expression],</span> <span class="pre">model:</span> <span class="pre">drake::multibody::PhysicalModel&lt;drake::symbolic::Expression&gt;</span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.AddPhysicalModel" title="Permalink to this definition"></a></dt>
<dd><p>For use only by advanced developers wanting to try out their new
physical models.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This feature is considered to be <strong>experimental</strong> and may change
or be removed at any time, without any deprecation notice ahead of
time.</p>
</div>
<p>With this method MultibodyPlant takes ownership of <code class="docutils literal notranslate"><span class="pre">model</span></code> and calls
its DeclareSystemResources() method at Finalize(), giving specific
physical model implementations a chance to declare the system
resources it needs. Each type of PhysicalModel can be added at most
once.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">model</span></code>:</dt><dd><p>After this call the model is owned by <code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant.</p>
</dd>
<dt>Precondition:</dt><dd><p>model != nullptr.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if called post-finalize. See Finalize</strong><strong>(</strong><strong>)</strong><strong></strong> – </p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant will no longer support scalar conversion
to or from symbolic::Expression after a call to this method.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.AddRigidBody">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].AddRigidBody"></span><span class="sig-name descname"><span class="pre">AddRigidBody</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.AddRigidBody" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>AddRigidBody(self: pydrake.multibody.plant.MultibodyPlant_[Expression], name: str, M_BBo_B: pydrake.multibody.tree.SpatialInertia = &lt;pydrake.multibody.tree.SpatialInertia object at 0x7f1440066530&gt;) -&gt; pydrake.multibody.tree.RigidBody_[Expression]</p></li>
</ol>
<p>Creates a rigid body with the provided name and spatial inertia. This
method returns a constant reference to the body just added, which will
remain valid for the lifetime of <code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant. The body
will use the default model instance (model_instance “more on model
instances”).</p>
<p>Example of usage:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">plant</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="c1">// ... Code to define spatial_inertia, a SpatialInertia&lt;T&gt; object ...</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">RigidBody</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">body</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">    </span><span class="n">plant</span><span class="p">.</span><span class="n">AddRigidBody</span><span class="p">(</span><span class="s">&quot;BodyName&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">spatial_inertia</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</details><dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">name</span></code>:</dt><dd><p>A string that identifies the new body to be added to <code class="docutils literal notranslate"><span class="pre">this</span></code>
model. A RuntimeError is thrown if a body named <code class="docutils literal notranslate"><span class="pre">name</span></code> already
is part of the model in the default model instance. See
HasBodyNamed(), RigidBody::name().</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">M_BBo_B</span></code>:</dt><dd><p>The SpatialInertia of the new rigid body to be added to <code class="docutils literal notranslate"><span class="pre">this</span></code>
MultibodyPlant, computed about the body frame origin <code class="docutils literal notranslate"><span class="pre">Bo</span></code> and
expressed in the body frame B. When not provided, defaults to
zero.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A constant reference to the new RigidBody just added, which will
remain valid for the lifetime of <code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>RuntimeError if additional model instances have been created</strong> – </p></li>
<li><p><strong>beyond the world and default instances.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>AddRigidBody(self: pydrake.multibody.plant.MultibodyPlant_[Expression], name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex, M_BBo_B: pydrake.multibody.tree.SpatialInertia = &lt;pydrake.multibody.tree.SpatialInertia object at 0x7f144016ee30&gt;) -&gt; pydrake.multibody.tree.RigidBody_[Expression]</p></li>
</ol>
<p>Creates a rigid body with the provided name and spatial inertia. This
method returns a constant reference to the body just added, which will
remain valid for the lifetime of <code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant.</p>
<p>Example of usage:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">plant</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="c1">// ... Code to define spatial_inertia, a SpatialInertia&lt;T&gt; object ...</span>
<span class="w">  </span><span class="n">ModelInstanceIndex</span><span class="w"> </span><span class="n">model_instance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">plant</span><span class="p">.</span><span class="n">AddModelInstance</span><span class="p">(</span><span class="s">&quot;instance&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">RigidBody</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">body</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">    </span><span class="n">plant</span><span class="p">.</span><span class="n">AddRigidBody</span><span class="p">(</span><span class="s">&quot;BodyName&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">model_instance</span><span class="p">,</span><span class="w"> </span><span class="n">spatial_inertia</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</details><dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">name</span></code>:</dt><dd><p>A string that identifies the new body to be added to <code class="docutils literal notranslate"><span class="pre">this</span></code>
model. A RuntimeError is thrown if a body named <code class="docutils literal notranslate"><span class="pre">name</span></code> already
is part of <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>. See HasBodyNamed(),
RigidBody::name().</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>:</dt><dd><p>A model instance index which this body is part of.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">M_BBo_B</span></code>:</dt><dd><p>The SpatialInertia of the new rigid body to be added to <code class="docutils literal notranslate"><span class="pre">this</span></code>
MultibodyPlant, computed about the body frame origin <code class="docutils literal notranslate"><span class="pre">Bo</span></code> and
expressed in the body frame B. When not provided, defaults to
zero.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A constant reference to the new RigidBody just added, which will
remain valid for the lifetime of <code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.AddWeldConstraint">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].AddWeldConstraint"></span><span class="sig-name descname"><span class="pre">AddWeldConstraint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body_A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody_" title="pydrake.multibody.tree.RigidBody_"><span class="pre">pydrake.multibody.tree.RigidBody_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X_AP</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.math.html#pydrake.math.RigidTransform" title="pydrake.math.RigidTransform"><span class="pre">pydrake.math.RigidTransform</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">body_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody_" title="pydrake.multibody.tree.RigidBody_"><span class="pre">pydrake.multibody.tree.RigidBody_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X_BQ</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.math.html#pydrake.math.RigidTransform" title="pydrake.math.RigidTransform"><span class="pre">pydrake.math.RigidTransform</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.MultibodyConstraintId" title="pydrake.multibody.tree.MultibodyConstraintId"><span class="pre">pydrake.multibody.tree.MultibodyConstraintId</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.AddWeldConstraint" title="Permalink to this definition"></a></dt>
<dd><p>Defines a constraint such that frame P affixed to body A is coincident
at all times with frame Q affixed to body B, effectively modeling a
weld joint.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body_A</span></code>:</dt><dd><p>RigidBody to which frame P is rigidly attached.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">X_AP</span></code>:</dt><dd><p>Pose of frame P in body A’s frame.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body_B</span></code>:</dt><dd><p>RigidBody to which frame Q is rigidly attached.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">X_BQ</span></code>:</dt><dd><p>Pose of frame Q in body B’s frame.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the id of the newly added constraint.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>RuntimeError if bodies A and B are the same body.</strong> – </p></li>
<li><p><strong>RuntimeError if the MultibodyPlant has already been finalized.</strong> – </p></li>
<li><p><strong>RuntimeError if this MultibodyPlant is not a discrete model</strong> – </p></li>
<li><p><strong>(</strong><strong>is_discrete</strong><strong>(</strong><strong>) </strong><strong>== false</strong><strong>)</strong> – </p></li>
<li><p><strong>RuntimeError if this MultibodyPlant's underlying contact</strong> – </p></li>
<li><p><strong>solver is not SAP.</strong><strong> (</strong><strong>i.e. get_discrete_contact_solver</strong><strong>(</strong><strong>) </strong><strong>!=</strong> – </p></li>
<li><p><strong>DiscreteContactSolver::kSap</strong><strong>)</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcBiasCenterOfMassTranslationalAcceleration">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].CalcBiasCenterOfMassTranslationalAcceleration"></span><span class="sig-name descname"><span class="pre">CalcBiasCenterOfMassTranslationalAcceleration</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_respect_to</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JacobianWrtVariable" title="pydrake.multibody.tree.JacobianWrtVariable"><span class="pre">pydrake.multibody.tree.JacobianWrtVariable</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame_" title="pydrake.multibody.tree.Frame_"><span class="pre">pydrake.multibody.tree.Frame_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_E</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame_" title="pydrake.multibody.tree.Frame_"><span class="pre">pydrake.multibody.tree.Frame_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcBiasCenterOfMassTranslationalAcceleration" title="Permalink to this definition"></a></dt>
<dd><p>Calculates abias_ACcm_E, point Ccm’s translational “bias” acceleration
term in frame A with respect to “speeds” 𝑠, expressed in frame E,
where point Ccm is the composite center of mass of the system of all
bodies (except world_body()) in the MultibodyPlant. abias_ACcm is the
part of a_ACcm (Ccm’s translational acceleration) that does not
multiply ṡ, equal to abias_ACcm = J̇𝑠_v_ACcm ⋅ s. This allows a_ACcm
to be written as a_ACcm = J𝑠_v_ACcm ⋅ ṡ + abias_ACcm.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The state of the multibody system.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">with_respect_to</span></code>:</dt><dd><p>Enum equal to JacobianWrtVariable::kQDot or
JacobianWrtVariable::kV, indicating whether the Jacobian
<code class="docutils literal notranslate"><span class="pre">abias_ACcm</span></code> is partial derivatives with respect to 𝑠 = q̇
(time-derivatives of generalized positions) or with respect to 𝑠 =
v (generalized velocities).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_A</span></code>:</dt><dd><p>The frame in which abias_ACcm is measured.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_E</span></code>:</dt><dd><p>The frame in which abias_ACcm is expressed on output.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">abias_ACcm_E</span></code>:</dt><dd><p>Point Ccm’s translational “bias” acceleration term in frame A with
respect to “speeds” 𝑠, expressed in frame E.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if Ccm does not exist</strong><strong>, </strong><strong>which occurs if there are no</strong> – </p></li>
<li><p><strong>massive bodies in MultibodyPlant</strong><strong> (</strong><strong>except world_body</strong><strong>(</strong><strong>)</strong><strong>)</strong><strong></strong> – </p></li>
<li><p><strong>RuntimeError if composite_mass &lt;= 0</strong><strong>, </strong><strong>where composite_mass is the</strong> – </p></li>
<li><p><strong>total mass of all bodies except world_body</strong><strong>(</strong><strong>) </strong><strong>in MultibodyPlant.</strong> – </p></li>
<li><p><strong>RuntimeError if frame_A is not the world frame.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcBiasSpatialAcceleration">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].CalcBiasSpatialAcceleration"></span><span class="sig-name descname"><span class="pre">CalcBiasSpatialAcceleration</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_respect_to</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JacobianWrtVariable" title="pydrake.multibody.tree.JacobianWrtVariable"><span class="pre">pydrake.multibody.tree.JacobianWrtVariable</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame_" title="pydrake.multibody.tree.Frame_"><span class="pre">pydrake.multibody.tree.Frame_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_BoBp_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame_" title="pydrake.multibody.tree.Frame_"><span class="pre">pydrake.multibody.tree.Frame_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_E</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame_" title="pydrake.multibody.tree.Frame_"><span class="pre">pydrake.multibody.tree.Frame_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.math.html#pydrake.multibody.math.SpatialAcceleration_" title="pydrake.multibody.math.SpatialAcceleration_"><span class="pre">pydrake.multibody.math.SpatialAcceleration_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcBiasSpatialAcceleration" title="Permalink to this definition"></a></dt>
<dd><p>For one point Bp affixed/welded to a frame B, calculates A𝑠Bias_ABp,
Bp’s spatial acceleration bias in frame A with respect to “speeds” 𝑠,
where 𝑠 is either q̇ (time-derivatives of generalized positions) or v
(generalized velocities). A𝑠Bias_ABp is the term in A_ABp (Bp’s
spatial acceleration in A) that does not include 𝑠̇, i.e., A𝑠Bias_ABp
is Bi’s translational acceleration in A when 𝑠̇ = 0.</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>A_ABp =  J𝑠_V_ABp ⋅ 𝑠̇  +  J̇𝑠_V_ABp ⋅ 𝑠   (𝑠 = q̇ or 𝑠 = v), hence
  A𝑠Bias_ABp = J̇𝑠_V_ABp ⋅ 𝑠
</pre></div>
</div>
</details><p>where J𝑠_V_ABp is Bp’s spatial velocity Jacobian in frame A for speeds
s (see CalcJacobianSpatialVelocity() for details on J𝑠_V_ABp).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The state of the multibody system.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">with_respect_to</span></code>:</dt><dd><p>Enum equal to JacobianWrtVariable::kQDot or
JacobianWrtVariable::kV, indicating whether the spatial
accceleration bias is with respect to 𝑠 = q̇ or 𝑠 = v.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_B</span></code>:</dt><dd><p>The frame on which point Bp is affixed/welded.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BoBp_B</span></code>:</dt><dd><p>Position vector from Bo (frame_B’s origin) to point Bp (regarded
as affixed/welded to B), expressed in frame_B.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_A</span></code>:</dt><dd><p>The frame that measures A𝑠Bias_ABp. Currently, an exception is
thrown if frame_A is not the World frame.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_E</span></code>:</dt><dd><p>The frame in which A𝑠Bias_ABp is expressed on output.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A𝑠Bias_ABp_E Point Bp’s spatial acceleration bias in frame A with
respect to speeds 𝑠 (𝑠 = q̇ or 𝑠 = v), expressed in frame E.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Shown below, A𝑠Bias_ABp_E = J̇𝑠_V_ABp ⋅ 𝑠 is quadratic in 𝑠.</p>
</div>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>V_ABp =  J𝑠_V_ABp ⋅ 𝑠        which upon vector differentiation in A gives
 A_ABp =  J𝑠_V_ABp ⋅ 𝑠̇  +  J̇𝑠_V_ABp ⋅ 𝑠   Since J̇𝑠_V_ABp is linear in 𝑠,
 A𝑠Bias_ABp = J̇𝑠_V_ABp ⋅ 𝑠                             is quadratic in 𝑠.
</pre></div>
</div>
</details><div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcJacobianSpatialVelocity() to compute J𝑠_V_ABp, point Bp’s
translational velocity Jacobian in frame A with respect to 𝑠.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if with_respect_to is not JacobianWrtVariable::kV</strong> – </p></li>
<li><p><strong>RuntimeError if frame_A is not the world frame.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcBiasTerm">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].CalcBiasTerm"></span><span class="sig-name descname"><span class="pre">CalcBiasTerm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcBiasTerm" title="Permalink to this definition"></a></dt>
<dd><p>Computes the bias term <code class="docutils literal notranslate"><span class="pre">C(q,</span> <span class="pre">v)v</span></code> containing Coriolis, centripetal,
and gyroscopic effects in the multibody equations of motion:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>M(q) v̇ + C(q, v) v = tau_app + ∑ (Jv_V_WBᵀ(q) ⋅ Fapp_Bo_W)
</pre></div>
</div>
</details><p>where <code class="docutils literal notranslate"><span class="pre">M(q)</span></code> is the multibody model’s mass matrix (including rigid
body mass properties and reflected_inertia “reflected inertias”) and
<code class="docutils literal notranslate"><span class="pre">tau_app</span></code> is a vector of applied generalized forces. The last term
is a summation over all bodies of the dot-product of <code class="docutils literal notranslate"><span class="pre">Fapp_Bo_W</span></code>
(applied spatial force on body B at Bo) with <code class="docutils literal notranslate"><span class="pre">Jv_V_WB(q)</span></code> (B’s
spatial Jacobian in world W with respect to generalized velocities v).
Note: B’s spatial velocity in W can be written <code class="docutils literal notranslate"><span class="pre">V_WB</span> <span class="pre">=</span> <span class="pre">Jv_V_WB</span> <span class="pre">*</span> <span class="pre">v</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context containing the state of the model. It stores the
generalized positions q and the generalized velocities v.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">Cv</span></code>:</dt><dd><p>On output, <code class="docutils literal notranslate"><span class="pre">Cv</span></code> will contain the product <code class="docutils literal notranslate"><span class="pre">C(q,</span> <span class="pre">v)v</span></code>. It must
be a valid (non-null) pointer to a column vector in <code class="docutils literal notranslate"><span class="pre">ℛⁿ</span></code> with n
the number of generalized velocities (num_velocities()) of the
model. This method aborts if Cv is nullptr or if it does not have
the proper size.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcBiasTranslationalAcceleration">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].CalcBiasTranslationalAcceleration"></span><span class="sig-name descname"><span class="pre">CalcBiasTranslationalAcceleration</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_respect_to</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JacobianWrtVariable" title="pydrake.multibody.tree.JacobianWrtVariable"><span class="pre">pydrake.multibody.tree.JacobianWrtVariable</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame_" title="pydrake.multibody.tree.Frame_"><span class="pre">pydrake.multibody.tree.Frame_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_BoBi_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.f_contiguous</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame_" title="pydrake.multibody.tree.Frame_"><span class="pre">pydrake.multibody.tree.Frame_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_E</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame_" title="pydrake.multibody.tree.Frame_"><span class="pre">pydrake.multibody.tree.Frame_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcBiasTranslationalAcceleration" title="Permalink to this definition"></a></dt>
<dd><p>For each point Bi affixed/welded to a frame B, calculates a𝑠Bias_ABi,
Bi’s translational acceleration bias in frame A with respect to
“speeds” 𝑠, where 𝑠 is either q̇ (time-derivatives of generalized
positions) or v (generalized velocities). a𝑠Bias_ABi is the term in
a_ABi (Bi’s translational acceleration in A) that does not include 𝑠̇,
i.e., a𝑠Bias_ABi is Bi’s translational acceleration in A when 𝑠̇ = 0.</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>a_ABi =  J𝑠_v_ABi ⋅ 𝑠̇  +  J̇𝑠_v_ABi ⋅ 𝑠  (𝑠 = q̇ or 𝑠 = v), hence
  a𝑠Bias_ABi = J̇𝑠_v_ABi ⋅ 𝑠
</pre></div>
</div>
</details><p>where J𝑠_v_ABi is Bi’s translational velocity Jacobian in frame A for
s (see CalcJacobianTranslationalVelocity() for details on J𝑠_v_ABi).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The state of the multibody system.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">with_respect_to</span></code>:</dt><dd><p>Enum equal to JacobianWrtVariable::kQDot or
JacobianWrtVariable::kV, indicating whether the translational
acceleration bias is with respect to 𝑠 = q̇ or 𝑠 = v.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_B</span></code>:</dt><dd><p>The frame on which points Bi are affixed/welded.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BoBi_B</span></code>:</dt><dd><p>A position vector or list of p position vectors from Bo (frame_B’s
origin) to points Bi (regarded as affixed to B), where each
position vector is expressed in frame_B. Each column in the <code class="docutils literal notranslate"><span class="pre">3</span> <span class="pre">x</span>
<span class="pre">p</span></code> matrix p_BoBi_B corresponds to a position vector.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_A</span></code>:</dt><dd><p>The frame that measures a𝑠Bias_ABi. Currently, an exception is
thrown if frame_A is not the World frame.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_E</span></code>:</dt><dd><p>The frame in which a𝑠Bias_ABi is expressed on output.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a𝑠Bias_ABi_E Point Bi’s translational acceleration bias in frame A
with respect to speeds 𝑠 (𝑠 = q̇ or 𝑠 = v), expressed in frame E.
a𝑠Bias_ABi_E is a <code class="docutils literal notranslate"><span class="pre">3</span> <span class="pre">x</span> <span class="pre">p</span></code> matrix, where p is the number of
points Bi.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Shown below, a𝑠Bias_ABi_E = J̇𝑠_v_ABp ⋅ 𝑠 is quadratic in 𝑠.</p>
</div>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>v_ABi =  J𝑠_v_ABi ⋅ 𝑠        which upon vector differentiation in A gives
 a_ABi =  J𝑠_v_ABi ⋅ 𝑠̇ + J̇𝑠_v_ABi ⋅ 𝑠     Since J̇𝑠_v_ABi is linear in 𝑠,
 a𝑠Bias_ABi = J̇𝑠_v_ABi ⋅ 𝑠                             is quadratic in 𝑠.
</pre></div>
</div>
</details><div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcJacobianTranslationalVelocity() to compute J𝑠_v_ABi, point
Bi’s translational velocity Jacobian in frame A with respect to 𝑠.</p>
</div>
<dl class="simple">
<dt>Precondition:</dt><dd><p>p_BoBi_B must have 3 rows.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if with_respect_to is not JacobianWrtVariable::kV</strong> – </p></li>
<li><p><strong>RuntimeError if frame_A is not the world frame.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcCenterOfMassPositionInWorld">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].CalcCenterOfMassPositionInWorld"></span><span class="sig-name descname"><span class="pre">CalcCenterOfMassPositionInWorld</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcCenterOfMassPositionInWorld" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>CalcCenterOfMassPositionInWorld(self: pydrake.multibody.plant.MultibodyPlant_[Expression], context: pydrake.systems.framework.Context_[Expression]) -&gt; numpy.ndarray[object[3, 1]]</p></li>
</ol>
<p>Calculates the position vector from the world origin Wo to the center
of mass of all bodies in this MultibodyPlant, expressed in the world
frame W.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>Contains the state of the model.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">p_WoScm_W</span></code>:</dt><dd><p>position vector from Wo to Scm expressed in world frame W, where
Scm is the center of mass of the system S stored by <code class="docutils literal notranslate"><span class="pre">this</span></code>
plant.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if this has no body except world_body</strong><strong>(</strong><strong>)</strong><strong></strong> – </p></li>
<li><p><strong>RuntimeError if mₛ ≤ 0</strong><strong> (</strong><strong>where mₛ is the mass of system S</strong><strong>)</strong><strong></strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The world_body() is ignored. p_WoScm_W = ∑ (mᵢ pᵢ) / mₛ, where mₛ
= ∑ mᵢ, mᵢ is the mass of the iᵗʰ body, and pᵢ is Bcm’s position
vector from Wo expressed in frame W (Bcm is the center of mass of
the iᵗʰ body).</p>
</div>
<ol class="arabic simple" start="2">
<li><p>CalcCenterOfMassPositionInWorld(self: pydrake.multibody.plant.MultibodyPlant_[Expression], context: pydrake.systems.framework.Context_[Expression], model_instances: List[pydrake.multibody.tree.ModelInstanceIndex]) -&gt; numpy.ndarray[object[3, 1]]</p></li>
</ol>
<p>Calculates the position vector from the world origin Wo to the center
of mass of all non-world bodies contained in model_instances,
expressed in the world frame W.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>Contains the state of the model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">model_instances</span></code>:</dt><dd><p>Vector of selected model instances. If a model instance is
repeated in the vector (unusual), it is only counted once.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">p_WoScm_W</span></code>:</dt><dd><p>position vector from world origin Wo to Scm expressed in the world
frame W, where Scm is the center of mass of the system S of
non-world bodies contained in model_instances.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if model_instances is empty</strong><strong> or </strong><strong>only has world body.</strong> – </p></li>
<li><p><strong>RuntimeError if mₛ ≤ 0</strong><strong> (</strong><strong>where mₛ is the mass of system S</strong><strong>)</strong><strong></strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The world_body() is ignored. p_WoScm_W = ∑ (mᵢ pᵢ) / mₛ, where mₛ
= ∑ mᵢ, mᵢ is the mass of the iᵗʰ body contained in
model_instances, and pᵢ is Bcm’s position vector from Wo expressed
in frame W (Bcm is the center of mass of the iᵗʰ body).</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcForceElementsContribution">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].CalcForceElementsContribution"></span><span class="sig-name descname"><span class="pre">CalcForceElementsContribution</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">forces</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.MultibodyForces_" title="pydrake.multibody.tree.MultibodyForces_"><span class="pre">pydrake.multibody.tree.MultibodyForces_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcForceElementsContribution" title="Permalink to this definition"></a></dt>
<dd><p>Computes the combined force contribution of ForceElement objects in
the model. A ForceElement can apply forces as a spatial force per body
or as generalized forces, depending on the ForceElement model.
ForceElement contributions are a function of the state and time only.
The output from this method can immediately be used as input to
CalcInverseDynamics() to include the effect of applied forces by force
elements.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context containing the state of this model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">forces</span></code>:</dt><dd><p>A pointer to a valid, non nullptr, multibody forces object. On
output <code class="docutils literal notranslate"><span class="pre">forces</span></code> will store the forces exerted by all the
ForceElement objects in the model.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if forces is null</strong><strong> or </strong><strong>not compatible with this</strong> – </p></li>
<li><p><strong>model</strong><strong>, </strong><strong>per MultibodyForces::CheckInvariants</strong><strong>(</strong><strong>)</strong><strong></strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcGeneralizedForces">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].CalcGeneralizedForces"></span><span class="sig-name descname"><span class="pre">CalcGeneralizedForces</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">forces</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.MultibodyForces_" title="pydrake.multibody.tree.MultibodyForces_"><span class="pre">pydrake.multibody.tree.MultibodyForces_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcGeneralizedForces" title="Permalink to this definition"></a></dt>
<dd><p>Computes the generalized forces result of a set of MultibodyForces
applied to this model.</p>
<p>MultibodyForces stores applied forces as both generalized forces τ and
spatial forces F on each body, refer to documentation in
MultibodyForces for details. Users of MultibodyForces will use
MultibodyForces::mutable_generalized_forces() to mutate the stored
generalized forces directly and will use
RigidBody::AddInForceInWorld() to append spatial forces.</p>
<p>For a given set of forces stored as MultibodyForces, this method will
compute the total generalized forces on this model. More precisely, if
J_WBo is the Jacobian (with respect to velocities) for this model,
including all bodies, then this method computes:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>τᵣₑₛᵤₗₜ = τ + J_WBo⋅F
</pre></div>
</div>
</details><dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>Context that stores the state of the model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">forces</span></code>:</dt><dd><p>Set of multibody forces, including both generalized forces and
per-body spatial forces.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">generalized_forces</span></code>:</dt><dd><p>The total generalized forces on the model that would result from
applying <code class="docutils literal notranslate"><span class="pre">forces</span></code>. In other words, <code class="docutils literal notranslate"><span class="pre">forces</span></code> can be replaced by
the equivalent <code class="docutils literal notranslate"><span class="pre">generalized_forces</span></code>. On output,
<code class="docutils literal notranslate"><span class="pre">generalized_forces</span></code> is resized to num_velocities().</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if forces is null</strong><strong> or </strong><strong>not compatible with this</strong> – </p></li>
<li><p><strong>model.</strong> – </p></li>
<li><p><strong>RuntimeError if generalized_forces is not a valid non-null</strong> – </p></li>
<li><p><strong>pointer.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcGravityGeneralizedForces">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].CalcGravityGeneralizedForces"></span><span class="sig-name descname"><span class="pre">CalcGravityGeneralizedForces</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcGravityGeneralizedForces" title="Permalink to this definition"></a></dt>
<dd><p>Computes the generalized forces <code class="docutils literal notranslate"><span class="pre">tau_g(q)</span></code> due to gravity as a
function of the generalized positions <code class="docutils literal notranslate"><span class="pre">q</span></code> stored in the input
<code class="docutils literal notranslate"><span class="pre">context</span></code>. The vector of generalized forces due to gravity
<code class="docutils literal notranslate"><span class="pre">tau_g(q)</span></code> is defined such that it appears on the right hand side of
the equations of motion together with any other generalized forces,
like so:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>Mv̇ + C(q, v)v = tau_g(q) + tau_app
</pre></div>
</div>
</details><p>where <code class="docutils literal notranslate"><span class="pre">tau_app</span></code> includes any other generalized forces applied on the
system.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context storing the state of the model.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>tau_g A vector containing the generalized forces due to gravity.
The generalized forces are consistent with the vector of
generalized velocities <code class="docutils literal notranslate"><span class="pre">v</span></code> for <code class="docutils literal notranslate"><span class="pre">this</span></code> so that the inner
product <code class="docutils literal notranslate"><span class="pre">v⋅tau_g</span></code> corresponds to the power applied by the
gravity forces on the mechanical system. That is, <code class="docutils literal notranslate"><span class="pre">v⋅tau_g</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>
corresponds to potential energy going into the system, as either
mechanical kinetic energy, some other potential energy, or heat,
and therefore to a decrease of the gravitational potential energy.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcInverseDynamics">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].CalcInverseDynamics"></span><span class="sig-name descname"><span class="pre">CalcInverseDynamics</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">known_vdot</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">external_forces</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.MultibodyForces_" title="pydrake.multibody.tree.MultibodyForces_"><span class="pre">pydrake.multibody.tree.MultibodyForces_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcInverseDynamics" title="Permalink to this definition"></a></dt>
<dd><p>Given the state of this model in <code class="docutils literal notranslate"><span class="pre">context</span></code> and a known vector of
generalized accelerations <code class="docutils literal notranslate"><span class="pre">vdot</span></code>, this method computes the set of
generalized forces <code class="docutils literal notranslate"><span class="pre">tau</span></code> that would need to be applied in order to
attain the specified generalized accelerations. Mathematically, this
method computes:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>tau = M(q)v̇ + C(q, v)v - tau_app - ∑ J_WBᵀ(q) Fapp_Bo_W
</pre></div>
</div>
</details><p>where <code class="docutils literal notranslate"><span class="pre">M(q)</span></code> is the model’s mass matrix (including rigid body mass
properties and reflected_inertia “reflected inertias”), <code class="docutils literal notranslate"><span class="pre">C(q,</span> <span class="pre">v)v</span></code>
is the bias term for Coriolis and gyroscopic effects and <code class="docutils literal notranslate"><span class="pre">tau_app</span></code>
consists of a vector applied generalized forces. The last term is a
summation over all bodies in the model where <code class="docutils literal notranslate"><span class="pre">Fapp_Bo_W</span></code> is an
applied spatial force on body B at <code class="docutils literal notranslate"><span class="pre">Bo</span></code> which gets projected into
the space of generalized forces with the transpose of <code class="docutils literal notranslate"><span class="pre">Jv_V_WB(q)</span></code>
(where <code class="docutils literal notranslate"><span class="pre">Jv_V_WB</span></code> is B’s spatial velocity Jacobian in W with respect
to generalized velocities v). Note: B’s spatial velocity in W can be
written as <code class="docutils literal notranslate"><span class="pre">V_WB</span> <span class="pre">=</span> <span class="pre">Jv_V_WB</span> <span class="pre">*</span> <span class="pre">v</span></code>.</p>
<p>This method does not compute explicit expressions for the mass matrix
nor for the bias term, which would be of at least <code class="docutils literal notranslate"><span class="pre">O(n²)</span></code>
complexity, but it implements an <code class="docutils literal notranslate"><span class="pre">O(n)</span></code> Newton-Euler recursive
algorithm, where n is the number of bodies in the model. The explicit
formation of the mass matrix <code class="docutils literal notranslate"><span class="pre">M(q)</span></code> would require the calculation of
<code class="docutils literal notranslate"><span class="pre">O(n²)</span></code> entries while explicitly forming the product <code class="docutils literal notranslate"><span class="pre">C(q,</span> <span class="pre">v)</span> <span class="pre">*</span> <span class="pre">v</span></code>
could require up to <code class="docutils literal notranslate"><span class="pre">O(n³)</span></code> operations (see [Featherstone 1987,
§4]), depending on the implementation. The recursive Newton-Euler
algorithm is the most efficient currently known general method for
solving inverse dynamics [Featherstone 2008].</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context containing the state of the model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">known_vdot</span></code>:</dt><dd><p>A vector with the known generalized accelerations <code class="docutils literal notranslate"><span class="pre">vdot</span></code> for the
full model. Use the provided Joint APIs in order to access entries
into this array.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">external_forces</span></code>:</dt><dd><p>A set of forces to be applied to the system either as body spatial
forces <code class="docutils literal notranslate"><span class="pre">Fapp_Bo_W</span></code> or generalized forces <code class="docutils literal notranslate"><span class="pre">tau_app</span></code>, see
MultibodyForces for details.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the vector of generalized forces that would need to be applied to
the mechanical system in order to achieve the desired acceleration
given by <code class="docutils literal notranslate"><span class="pre">known_vdot</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcJacobianAngularVelocity">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].CalcJacobianAngularVelocity"></span><span class="sig-name descname"><span class="pre">CalcJacobianAngularVelocity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_respect_to</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JacobianWrtVariable" title="pydrake.multibody.tree.JacobianWrtVariable"><span class="pre">pydrake.multibody.tree.JacobianWrtVariable</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame_" title="pydrake.multibody.tree.Frame_"><span class="pre">pydrake.multibody.tree.Frame_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame_" title="pydrake.multibody.tree.Frame_"><span class="pre">pydrake.multibody.tree.Frame_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_E</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame_" title="pydrake.multibody.tree.Frame_"><span class="pre">pydrake.multibody.tree.Frame_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcJacobianAngularVelocity" title="Permalink to this definition"></a></dt>
<dd><p>Calculates J𝑠_w_AB, a frame B’s angular velocity Jacobian in a frame A
with respect to “speeds” 𝑠.</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>J𝑠_w_AB ≜ [ ∂(w_AB)/∂𝑠₁,  ...  ∂(w_AB)/∂𝑠ₙ ]    (n is j or k)
     w_AB = J𝑠_w_AB ⋅ 𝑠          w_AB is linear in 𝑠 ≜ [𝑠₁ ... 𝑠ₙ]ᵀ
</pre></div>
</div>
</details><p><code class="docutils literal notranslate"><span class="pre">w_AB</span></code> is B’s angular velocity in frame A and “speeds” 𝑠 is either
q̇ ≜ [q̇₁ … q̇ⱼ]ᵀ (time-derivatives of j generalized positions) or v
≜ [v₁ … vₖ]ᵀ (k generalized velocities).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The state of the multibody system.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">with_respect_to</span></code>:</dt><dd><p>Enum equal to JacobianWrtVariable::kQDot or
JacobianWrtVariable::kV, indicating whether the Jacobian
<code class="docutils literal notranslate"><span class="pre">J𝑠_w_AB</span></code> is partial derivatives with respect to 𝑠 = q̇
(time-derivatives of generalized positions) or with respect to 𝑠 =
v (generalized velocities).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_B</span></code>:</dt><dd><p>The frame B in <code class="docutils literal notranslate"><span class="pre">w_AB</span></code> (B’s angular velocity in A).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_A</span></code>:</dt><dd><p>The frame A in <code class="docutils literal notranslate"><span class="pre">w_AB</span></code> (B’s angular velocity in A).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_E</span></code>:</dt><dd><p>The frame in which <code class="docutils literal notranslate"><span class="pre">w_AB</span></code> is expressed on input and the frame in
which the Jacobian <code class="docutils literal notranslate"><span class="pre">J𝑠_w_AB</span></code> is expressed on output.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">J𝑠_w_AB_E</span></code>:</dt><dd><p>Frame B’s angular velocity Jacobian in frame A with respect to
speeds 𝑠 (which is either q̇ or v), expressed in frame E. The
Jacobian is a function of only generalized positions q (which are
pulled from the context). The previous definition shows
<code class="docutils literal notranslate"><span class="pre">J𝑠_w_AB_E</span></code> is a matrix of size <code class="docutils literal notranslate"><span class="pre">3</span> <span class="pre">x</span> <span class="pre">n</span></code>, where n is the number
of elements in 𝑠.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if J𝑠_w_AB_E is nullptr</strong><strong> or </strong><strong>not of size 3 x n.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcJacobianCenterOfMassTranslationalVelocity">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].CalcJacobianCenterOfMassTranslationalVelocity"></span><span class="sig-name descname"><span class="pre">CalcJacobianCenterOfMassTranslationalVelocity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcJacobianCenterOfMassTranslationalVelocity" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>CalcJacobianCenterOfMassTranslationalVelocity(self: pydrake.multibody.plant.MultibodyPlant_[Expression], context: pydrake.systems.framework.Context_[Expression], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_A: pydrake.multibody.tree.Frame_[Expression], frame_E: pydrake.multibody.tree.Frame_[Expression]) -&gt; numpy.ndarray[object[3, n]]</p></li>
</ol>
<p>Calculates J𝑠_v_ACcm_E, point Ccm’s translational velocity Jacobian in
frame A with respect to “speeds” 𝑠, expressed in frame E, where point
CCm is the center of mass of the system of all non-world bodies
contained in <code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>contains the state of the model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">with_respect_to</span></code>:</dt><dd><p>Enum equal to JacobianWrtVariable::kQDot or
JacobianWrtVariable::kV, indicating whether the Jacobian
<code class="docutils literal notranslate"><span class="pre">J𝑠_v_ACcm_E</span></code> is partial derivatives with respect to 𝑠 = q̇
(time-derivatives of generalized positions) or with respect to 𝑠 =
v (generalized velocities).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_A</span></code>:</dt><dd><p>The frame in which the translational velocity v_ACcm and its
Jacobian J𝑠_v_ACcm are measured.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_E</span></code>:</dt><dd><p>The frame in which the Jacobian J𝑠_v_ACcm is expressed on output.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">J𝑠_v_ACcm_E</span></code>:</dt><dd><p>Point Ccm’s translational velocity Jacobian in frame A with
respect to speeds 𝑠 (𝑠 = q̇ or 𝑠 = v), expressed in frame E.
J𝑠_v_ACcm_E is a 3 x n matrix, where n is the number of elements
in 𝑠. The Jacobian is a function of only generalized positions q
(which are pulled from the context).</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if CCm does not exist</strong><strong>, </strong><strong>which occurs if there are no</strong> – </p></li>
<li><p><strong>massive bodies in MultibodyPlant</strong><strong> (</strong><strong>except world_body</strong><strong>(</strong><strong>)</strong><strong>)</strong><strong></strong> – </p></li>
<li><p><strong>RuntimeError if mₛ ≤ 0</strong><strong> (</strong><strong>where mₛ is the mass of all non-world</strong> – </p></li>
<li><p><strong>bodies contained in this MultibodyPlant</strong><strong>)</strong><strong></strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>CalcJacobianCenterOfMassTranslationalVelocity(self: pydrake.multibody.plant.MultibodyPlant_[Expression], context: pydrake.systems.framework.Context_[Expression], model_instances: List[pydrake.multibody.tree.ModelInstanceIndex], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_A: pydrake.multibody.tree.Frame_[Expression], frame_E: pydrake.multibody.tree.Frame_[Expression]) -&gt; numpy.ndarray[object[3, n]]</p></li>
</ol>
<p>Calculates J𝑠_v_ACcm_E, point Ccm’s translational velocity Jacobian in
frame A with respect to “speeds” 𝑠, expressed in frame E, where point
CCm is the center of mass of the system of all non-world bodies
contained in model_instances.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>contains the state of the model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">model_instances</span></code>:</dt><dd><p>Vector of selected model instances. If a model instance is
repeated in the vector (unusual), it is only counted once.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">with_respect_to</span></code>:</dt><dd><p>Enum equal to JacobianWrtVariable::kQDot or
JacobianWrtVariable::kV, indicating whether the Jacobian
<code class="docutils literal notranslate"><span class="pre">J𝑠_v_ACcm_E</span></code> is partial derivatives with respect to 𝑠 = q̇
(time-derivatives of generalized positions) or with respect to 𝑠 =
v (generalized velocities).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_A</span></code>:</dt><dd><p>The frame in which the translational velocity v_ACcm and its
Jacobian J𝑠_v_ACcm are measured.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_E</span></code>:</dt><dd><p>The frame in which the Jacobian J𝑠_v_ACcm is expressed on output.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">J𝑠_v_ACcm_E</span></code>:</dt><dd><p>Point Ccm’s translational velocity Jacobian in frame A with
respect to speeds 𝑠 (𝑠 = q̇ or 𝑠 = v), expressed in frame E.
J𝑠_v_ACcm_E is a 3 x n matrix, where n is the number of elements
in 𝑠. The Jacobian is a function of only generalized positions q
(which are pulled from the context).</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if mₛ ≤ 0</strong><strong> (</strong><strong>where mₛ is the mass of all non-world</strong> – </p></li>
<li><p><strong>bodies contained in model_instances</strong><strong>)</strong><strong></strong> – </p></li>
<li><p><strong>RuntimeError if model_instances is empty</strong><strong> or </strong><strong>only has world body.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The world_body() is ignored. <a href="#id143"><span class="problematic" id="id144">J𝑠_v_ACcm_</span></a> = ∑ (mᵢ Jᵢ) / mₛ, where mₛ
= ∑ mᵢ, mᵢ is the mass of the iᵗʰ body contained in
model_instances, and Jᵢ is Bcm’s translational velocity Jacobian
in frame A, expressed in frame E (Bcm is the center of mass of the
iᵗʰ body).</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcJacobianPositionVector">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].CalcJacobianPositionVector"></span><span class="sig-name descname"><span class="pre">CalcJacobianPositionVector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame_" title="pydrake.multibody.tree.Frame_"><span class="pre">pydrake.multibody.tree.Frame_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_BoBi_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.f_contiguous</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame_" title="pydrake.multibody.tree.Frame_"><span class="pre">pydrake.multibody.tree.Frame_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_E</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame_" title="pydrake.multibody.tree.Frame_"><span class="pre">pydrake.multibody.tree.Frame_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcJacobianPositionVector" title="Permalink to this definition"></a></dt>
<dd><p>For each point Bi affixed/welded to a frame B, calculates Jq_p_AoBi,
Bi’s position vector Jacobian in frame A with respect to the
generalized positions q ≜ [q₁ … qₙ]ᵀ as</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>Jq_p_AoBi ≜ [ ᴬ∂(p_AoBi)/∂q₁,  ...  ᴬ∂(p_AoBi)/∂qₙ ]
</pre></div>
</div>
</details><p>where p_AoBi is Bi’s position vector from point Ao (frame A’s origin)
and ᴬ∂(p_AoBi)/∂qᵣ denotes the partial derivative in frame A of p_AoBi
with respect to the generalized position qᵣ, where qᵣ is one of q₁ …
qₙ.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The state of the multibody system.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_B</span></code>:</dt><dd><p>The frame on which point Bi is affixed/welded.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BoBi_B</span></code>:</dt><dd><p>A position vector or list of k position vectors from Bo (frame_B’s
origin) to points Bi (Bi is regarded as affixed to B), where each
position vector is expressed in frame_B.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_A</span></code>:</dt><dd><p>The frame in which partial derivatives are calculated and the
frame in which point Ao is affixed.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_E</span></code>:</dt><dd><p>The frame in which the Jacobian Jq_p_AoBi is expressed on output.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">Jq_p_AoBi_E</span></code>:</dt><dd><p>Point Bi’s position vector Jacobian in frame A with generalized
positions q, expressed in frame E. Jq_p_AoBi_E is a <code class="docutils literal notranslate"><span class="pre">3*k</span> <span class="pre">x</span> <span class="pre">n</span></code>
matrix, where k is the number of points Bi and n is the number of
elements in q. The Jacobian is a function of only generalized
positions q (which are pulled from the context).</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if Jq_p_AoBi_E is nullptr</strong><strong> or </strong><strong>not sized 3*k x n.</strong> – </p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Jq̇_v_ABi = Jq_p_AoBi. In other words, point Bi’s velocity
Jacobian in frame A with respect to q̇ is equal to point Bi’s
position vector Jacobian in frame A with respect to q.</p>
</div>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>[∂(v_ABi)/∂q̇₁, ... ∂(v_ABi)/∂q̇ₙ] = [ᴬ∂(p_AoBi)/∂q₁, ... ᴬ∂(p_AoBi)/∂qₙ]
</pre></div>
</div>
</details><div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcJacobianTranslationalVelocity() for details on Jq̇_v_ABi.
Note: Jq_p_AaBi = Jq_p_AoBi, where point Aa is <em>any</em> point
fixed/welded to frame A, i.e., this calculation’s result is the
same if point Ao is replaced with any point fixed on frame A.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcJacobianSpatialVelocity">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].CalcJacobianSpatialVelocity"></span><span class="sig-name descname"><span class="pre">CalcJacobianSpatialVelocity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_respect_to</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JacobianWrtVariable" title="pydrake.multibody.tree.JacobianWrtVariable"><span class="pre">pydrake.multibody.tree.JacobianWrtVariable</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame_" title="pydrake.multibody.tree.Frame_"><span class="pre">pydrake.multibody.tree.Frame_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_BoBp_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame_" title="pydrake.multibody.tree.Frame_"><span class="pre">pydrake.multibody.tree.Frame_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_E</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame_" title="pydrake.multibody.tree.Frame_"><span class="pre">pydrake.multibody.tree.Frame_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcJacobianSpatialVelocity" title="Permalink to this definition"></a></dt>
<dd><p>For one point Bp fixed/welded to a frame B, calculates J𝑠_V_ABp, Bp’s
spatial velocity Jacobian in frame A with respect to “speeds” 𝑠.</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>J𝑠_V_ABp ≜ [ ∂(V_ABp)/∂𝑠₁,  ...  ∂(V_ABp)/∂𝑠ₙ ]    (n is j or k)
     V_ABp = J𝑠_V_ABp ⋅ 𝑠          V_ABp is linear in 𝑠 ≜ [𝑠₁ ... 𝑠ₙ]ᵀ
</pre></div>
</div>
</details><p><code class="docutils literal notranslate"><span class="pre">V_ABp</span></code> is Bp’s spatial velocity in frame A and “speeds” 𝑠 is either
q̇ ≜ [q̇₁ … q̇ⱼ]ᵀ (time-derivatives of j generalized positions) or v
≜ [v₁ … vₖ]ᵀ (k generalized velocities).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The state of the multibody system.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">with_respect_to</span></code>:</dt><dd><p>Enum equal to JacobianWrtVariable::kQDot or
JacobianWrtVariable::kV, indicating whether the Jacobian
<code class="docutils literal notranslate"><span class="pre">J𝑠_V_ABp</span></code> is partial derivatives with respect to 𝑠 = q̇
(time-derivatives of generalized positions) or with respect to 𝑠 =
v (generalized velocities).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_B</span></code>:</dt><dd><p>The frame on which point Bp is fixed/welded.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BoBp_B</span></code>:</dt><dd><p>A position vector from Bo (frame_B’s origin) to point Bp (regarded
as fixed/welded to B), expressed in frame_B.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_A</span></code>:</dt><dd><p>The frame that measures <code class="docutils literal notranslate"><span class="pre">v_ABp</span></code> (Bp’s velocity in A). Note: It
is natural to wonder why there is no parameter p_AoAp_A (similar
to the parameter p_BoBp_B for frame_B). There is no need for
p_AoAp_A because Bp’s velocity in A is defined as the derivative
in frame A of Bp’s position vector from <em>any</em> point fixed to A.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_E</span></code>:</dt><dd><p>The frame in which <code class="docutils literal notranslate"><span class="pre">v_ABp</span></code> is expressed on input and the frame
in which the Jacobian <code class="docutils literal notranslate"><span class="pre">J𝑠_V_ABp</span></code> is expressed on output.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">J𝑠_V_ABp_E</span></code>:</dt><dd><p>Point Bp’s spatial velocity Jacobian in frame A with respect to
speeds 𝑠 (which is either q̇ or v), expressed in frame E.
<code class="docutils literal notranslate"><span class="pre">J𝑠_V_ABp_E</span></code> is a <code class="docutils literal notranslate"><span class="pre">6</span> <span class="pre">x</span> <span class="pre">n</span></code> matrix, where n is the number of
elements in 𝑠. The Jacobian is a function of only generalized
positions q (which are pulled from the context). Note: The
returned <code class="docutils literal notranslate"><span class="pre">6</span> <span class="pre">x</span> <span class="pre">n</span></code> matrix stores frame B’s angular velocity
Jacobian in A in rows 1-3 and stores point Bp’s translational
velocity Jacobian in A in rows 4-6, i.e.,</p>
</dd>
</dl>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">J𝑠_w_AB_E</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">J𝑠_V_ABp_E</span><span class="p">.</span><span class="n">topRows</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">J𝑠_v_ABp_E</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">J𝑠_V_ABp_E</span><span class="p">.</span><span class="n">bottomRows</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">();</span><span class="w"></span>
</pre></div>
</div>
</details><p>Note: Consider CalcJacobianTranslationalVelocity() for multiple points
fixed to frame B and consider CalcJacobianAngularVelocity() to
calculate frame B’s angular velocity Jacobian.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if J𝑠_V_ABp_E is nullptr</strong><strong> or </strong><strong>not sized 6 x n.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcJacobianTranslationalVelocity">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].CalcJacobianTranslationalVelocity"></span><span class="sig-name descname"><span class="pre">CalcJacobianTranslationalVelocity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_respect_to</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JacobianWrtVariable" title="pydrake.multibody.tree.JacobianWrtVariable"><span class="pre">pydrake.multibody.tree.JacobianWrtVariable</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame_" title="pydrake.multibody.tree.Frame_"><span class="pre">pydrake.multibody.tree.Frame_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_BoBi_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.f_contiguous</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame_" title="pydrake.multibody.tree.Frame_"><span class="pre">pydrake.multibody.tree.Frame_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_E</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame_" title="pydrake.multibody.tree.Frame_"><span class="pre">pydrake.multibody.tree.Frame_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcJacobianTranslationalVelocity" title="Permalink to this definition"></a></dt>
<dd><p>For each point Bi affixed/welded to a frame B, calculates J𝑠_v_ABi,
Bi’s translational velocity Jacobian in frame A with respect to
“speeds” 𝑠.</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>J𝑠_v_ABi ≜ [ ∂(v_ABi)/∂𝑠₁,  ...  ∂(v_ABi)/∂𝑠ₙ ]    (n is j or k)
     v_ABi = J𝑠_v_ABi ⋅ 𝑠          v_ABi is linear in 𝑠 ≜ [𝑠₁ ... 𝑠ₙ]ᵀ
</pre></div>
</div>
</details><p><code class="docutils literal notranslate"><span class="pre">v_ABi</span></code> is Bi’s translational velocity in frame A and “speeds” 𝑠 is
either q̇ ≜ [q̇₁ … q̇ⱼ]ᵀ (time-derivatives of j generalized
positions) or v ≜ [v₁ … vₖ]ᵀ (k generalized velocities).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The state of the multibody system.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">with_respect_to</span></code>:</dt><dd><p>Enum equal to JacobianWrtVariable::kQDot or
JacobianWrtVariable::kV, indicating whether the Jacobian
<code class="docutils literal notranslate"><span class="pre">J𝑠_v_ABi</span></code> is partial derivatives with respect to 𝑠 = q̇
(time-derivatives of generalized positions) or with respect to 𝑠 =
v (generalized velocities).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_B</span></code>:</dt><dd><p>The frame on which point Bi is affixed/welded.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BoBi_B</span></code>:</dt><dd><p>A position vector or list of p position vectors from Bo (frame_B’s
origin) to points Bi (regarded as affixed to B), where each
position vector is expressed in frame_B.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_A</span></code>:</dt><dd><p>The frame that measures <code class="docutils literal notranslate"><span class="pre">v_ABi</span></code> (Bi’s velocity in A). Note: It
is natural to wonder why there is no parameter p_AoAi_A (similar
to the parameter p_BoBi_B for frame_B). There is no need for
p_AoAi_A because Bi’s velocity in A is defined as the derivative
in frame A of Bi’s position vector from <em>any</em> point affixed to A.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_E</span></code>:</dt><dd><p>The frame in which <code class="docutils literal notranslate"><span class="pre">v_ABi</span></code> is expressed on input and the frame
in which the Jacobian <code class="docutils literal notranslate"><span class="pre">J𝑠_v_ABi</span></code> is expressed on output.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">J𝑠_v_ABi_E</span></code>:</dt><dd><p>Point Bi’s velocity Jacobian in frame A with respect to speeds 𝑠
(which is either q̇ or v), expressed in frame E. <code class="docutils literal notranslate"><span class="pre">J𝑠_v_ABi_E</span></code> is
a <code class="docutils literal notranslate"><span class="pre">3*p</span> <span class="pre">x</span> <span class="pre">n</span></code> matrix, where p is the number of points Bi and n is
the number of elements in 𝑠. The Jacobian is a function of only
generalized positions q (which are pulled from the context).</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if J𝑠_v_ABi_E is nullptr</strong><strong> or </strong><strong>not sized ``3*p x</strong> – </p></li>
<li><p><strong>n``.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When 𝑠 = q̇, <code class="docutils literal notranslate"><span class="pre">Jq̇_v_ABi</span> <span class="pre">=</span> <span class="pre">Jq_p_AoBi</span></code>. In other words, point Bi’s
velocity Jacobian in frame A with respect to q̇ is equal to point
Bi’s position Jacobian from Ao (A’s origin) in frame A with
respect to q.</p>
</div>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>[∂(v_ABi)/∂q̇₁,  ...  ∂(v_ABi)/∂q̇ⱼ] = [∂(p_AoBi)/∂q₁,  ...  ∂(p_AoBi)/∂qⱼ]
</pre></div>
</div>
</details><p>Note: Each partial derivative of p_AoBi is taken in frame A.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcJacobianPositionVector() for details on Jq_p_AoBi.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcMassMatrix">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].CalcMassMatrix"></span><span class="sig-name descname"><span class="pre">CalcMassMatrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcMassMatrix" title="Permalink to this definition"></a></dt>
<dd><p>Efficiently computes the mass matrix <code class="docutils literal notranslate"><span class="pre">M(q)</span></code> of the model. The
generalized positions q are taken from the given <code class="docutils literal notranslate"><span class="pre">context</span></code>. M
includes the mass properties of rigid bodies and reflected_inertia
“reflected inertias” as provided with JointActuator specifications.</p>
<p>This method employs the Composite Body Algorithm, which we believe to
be the fastest O(n²) algorithm to compute the mass matrix of a
multibody system.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The Context containing the state of the model from which
generalized coordinates q are extracted.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">M</span></code>:</dt><dd><p>A pointer to a square matrix in <code class="docutils literal notranslate"><span class="pre">ℛⁿˣⁿ</span></code> with n the number of
generalized velocities (num_velocities()) of the model. Although
symmetric, the matrix is filled in completely on return.</p>
</dd>
<dt>Precondition:</dt><dd><p>M is non-null and has the right size.</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This is an O(n²) algorithm. Avoid the explicit computation of the
mass matrix whenever possible.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcMassMatrixViaInverseDynamics() (slower)</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcMassMatrixViaInverseDynamics">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].CalcMassMatrixViaInverseDynamics"></span><span class="sig-name descname"><span class="pre">CalcMassMatrixViaInverseDynamics</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcMassMatrixViaInverseDynamics" title="Permalink to this definition"></a></dt>
<dd><p>Computes the mass matrix <code class="docutils literal notranslate"><span class="pre">M(q)</span></code> of the model using a slow method
(inverse dynamics). The generalized positions q are taken from the
given <code class="docutils literal notranslate"><span class="pre">context</span></code>. M includes the mass properties of rigid bodies and
reflected_inertia “reflected inertias” as provided with JointActuator
specifications.</p>
<p>Use CalcMassMatrix() for a faster implementation using the Composite
Body Algorithm.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The Context containing the state of the model from which
generalized coordinates q are extracted.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">M</span></code>:</dt><dd><p>A pointer to a square matrix in <code class="docutils literal notranslate"><span class="pre">ℛⁿˣⁿ</span></code> with n the number of
generalized velocities (num_velocities()) of the model. Although
symmetric, the matrix is filled in completely on return.</p>
</dd>
<dt>Precondition:</dt><dd><p>M is non-null and has the right size.</p>
</dd>
</dl>
<p>The algorithm used to build <code class="docutils literal notranslate"><span class="pre">M(q)</span></code> consists in computing one column
of <code class="docutils literal notranslate"><span class="pre">M(q)</span></code> at a time using inverse dynamics. The result from inverse
dynamics, with no applied forces, is the vector of generalized forces:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>tau = M(q)v̇ + C(q, v)v
</pre></div>
</div>
</details><p>where q and v are the generalized positions and velocities,
respectively. When <code class="docutils literal notranslate"><span class="pre">v</span> <span class="pre">=</span> <span class="pre">0</span></code> the Coriolis and gyroscopic forces term
<code class="docutils literal notranslate"><span class="pre">C(q,</span> <span class="pre">v)v</span></code> is zero. Therefore the <code class="docutils literal notranslate"><span class="pre">i-th</span></code> column of <code class="docutils literal notranslate"><span class="pre">M(q)</span></code> can be
obtained performing inverse dynamics with an acceleration vector <code class="docutils literal notranslate"><span class="pre">v̇</span>
<span class="pre">=</span> <span class="pre">eᵢ</span></code>, with <code class="docutils literal notranslate"><span class="pre">eᵢ</span></code> the standard (or natural) basis of <code class="docutils literal notranslate"><span class="pre">ℛⁿ</span></code> with n
the number of generalized velocities. We write this as:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">M</span><span class="p">.</span><span class="n">ᵢ</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">M</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">e_i</span><span class="w"></span>
</pre></div>
</div>
</details><p>where <code class="docutils literal notranslate"><span class="pre">M.ᵢ(q)</span></code> (notice the dot for the rows index) denotes the
<code class="docutils literal notranslate"><span class="pre">i-th</span></code> column in M(q).</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This is an O(n²) algorithm. Avoid the explicit computation of the
mass matrix whenever possible.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcMassMatrix(), CalcInverseDynamics()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcPointsPositions">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].CalcPointsPositions"></span><span class="sig-name descname"><span class="pre">CalcPointsPositions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame_" title="pydrake.multibody.tree.Frame_"><span class="pre">pydrake.multibody.tree.Frame_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_BQi</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.f_contiguous</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame_" title="pydrake.multibody.tree.Frame_"><span class="pre">pydrake.multibody.tree.Frame_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcPointsPositions" title="Permalink to this definition"></a></dt>
<dd><p>Given the positions <code class="docutils literal notranslate"><span class="pre">p_BQi</span></code> for a set of points <code class="docutils literal notranslate"><span class="pre">Qi</span></code> measured and
expressed in a frame B, this method computes the positions
<code class="docutils literal notranslate"><span class="pre">p_AQi(q)</span></code> of each point <code class="docutils literal notranslate"><span class="pre">Qi</span></code> in the set as measured and expressed
in another frame A, as a function of the generalized positions q of
the model.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context containing the state of the model. It stores the
generalized positions q of the model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_B</span></code>:</dt><dd><p>The frame B in which the positions <code class="docutils literal notranslate"><span class="pre">p_BQi</span></code> of a set of points
<code class="docutils literal notranslate"><span class="pre">Qi</span></code> are given.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BQi</span></code>:</dt><dd><p>The input positions of each point <code class="docutils literal notranslate"><span class="pre">Qi</span></code> in frame B. <code class="docutils literal notranslate"><span class="pre">p_BQi</span> <span class="pre">∈</span>
<span class="pre">ℝ³ˣⁿᵖ</span></code> with <code class="docutils literal notranslate"><span class="pre">np</span></code> the number of points in the set. Each column
of <code class="docutils literal notranslate"><span class="pre">p_BQi</span></code> corresponds to a vector in ℝ³ holding the position of
one of the points in the set as measured and expressed in frame B.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_A</span></code>:</dt><dd><p>The frame A in which it is desired to compute the positions
<code class="docutils literal notranslate"><span class="pre">p_AQi</span></code> of each point <code class="docutils literal notranslate"><span class="pre">Qi</span></code> in the set.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_AQi</span></code>:</dt><dd><p>The output positions of each point <code class="docutils literal notranslate"><span class="pre">Qi</span></code> now computed as measured
and expressed in frame A. The output <code class="docutils literal notranslate"><span class="pre">p_AQi</span></code> <strong>must</strong> have the
same size as the input <code class="docutils literal notranslate"><span class="pre">p_BQi</span></code> or otherwise this method aborts.
That is <code class="docutils literal notranslate"><span class="pre">p_AQi</span></code> <strong>must</strong> be in <code class="docutils literal notranslate"><span class="pre">ℝ³ˣⁿᵖ</span></code>.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Both <code class="docutils literal notranslate"><span class="pre">p_BQi</span></code> and <code class="docutils literal notranslate"><span class="pre">p_AQi</span></code> must have three rows. Otherwise this
method will throw a RuntimeError. This method also throws a
RuntimeError if <code class="docutils literal notranslate"><span class="pre">p_BQi</span></code> and <code class="docutils literal notranslate"><span class="pre">p_AQi</span></code> differ in the number of
columns.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcRelativeRotationMatrix">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].CalcRelativeRotationMatrix"></span><span class="sig-name descname"><span class="pre">CalcRelativeRotationMatrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame_" title="pydrake.multibody.tree.Frame_"><span class="pre">pydrake.multibody.tree.Frame_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame_" title="pydrake.multibody.tree.Frame_"><span class="pre">pydrake.multibody.tree.Frame_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.math.html#pydrake.math.RotationMatrix_" title="pydrake.math.RotationMatrix_"><span class="pre">pydrake.math.RotationMatrix_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcRelativeRotationMatrix" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the rotation matrix <code class="docutils literal notranslate"><span class="pre">R_AB</span></code> relating frame A and frame B.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The state of the multibody system, which includes the system’s
generalized positions q. Note: <code class="docutils literal notranslate"><span class="pre">R_AB</span></code> is a function of q.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_A</span></code>:</dt><dd><p>The frame A designated in the rigid transform <code class="docutils literal notranslate"><span class="pre">R_AB</span></code>.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_B</span></code>:</dt><dd><p>The frame G designated in the rigid transform <code class="docutils literal notranslate"><span class="pre">R_AB</span></code>.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">R_AB</span></code>:</dt><dd><p>The RigidTransform relating frame A and frame B.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcRelativeTransform">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].CalcRelativeTransform"></span><span class="sig-name descname"><span class="pre">CalcRelativeTransform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame_" title="pydrake.multibody.tree.Frame_"><span class="pre">pydrake.multibody.tree.Frame_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame_" title="pydrake.multibody.tree.Frame_"><span class="pre">pydrake.multibody.tree.Frame_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.math.html#pydrake.math.RigidTransform_" title="pydrake.math.RigidTransform_"><span class="pre">pydrake.math.RigidTransform_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcRelativeTransform" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the rigid transform (pose) <code class="docutils literal notranslate"><span class="pre">X_AB</span></code> relating frame A and
frame B.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The state of the multibody system, which includes the system’s
generalized positions q. Note: <code class="docutils literal notranslate"><span class="pre">X_AB</span></code> is a function of q.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_A</span></code>:</dt><dd><p>The frame A designated in the rigid transform <code class="docutils literal notranslate"><span class="pre">X_AB</span></code>.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_B</span></code>:</dt><dd><p>The frame G designated in the rigid transform <code class="docutils literal notranslate"><span class="pre">X_AB</span></code>.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">X_AB</span></code>:</dt><dd><p>The RigidTransform relating frame A and frame B.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcSpatialAccelerationsFromVdot">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].CalcSpatialAccelerationsFromVdot"></span><span class="sig-name descname"><span class="pre">CalcSpatialAccelerationsFromVdot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">known_vdot</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.multibody.math.html#pydrake.multibody.math.SpatialAcceleration_" title="pydrake.multibody.math.SpatialAcceleration_"><span class="pre">pydrake.multibody.math.SpatialAcceleration_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcSpatialAccelerationsFromVdot" title="Permalink to this definition"></a></dt>
<dd><p>Given the state of this model in <code class="docutils literal notranslate"><span class="pre">context</span></code> and a known vector of
generalized accelerations <code class="docutils literal notranslate"><span class="pre">known_vdot</span></code>, this method computes the
spatial acceleration <code class="docutils literal notranslate"><span class="pre">A_WB</span></code> for each body as measured and expressed
in the world frame W.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context containing the state of this model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">known_vdot</span></code>:</dt><dd><p>A vector with the generalized accelerations for the full model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">A_WB_array</span></code>:</dt><dd><p>A pointer to a valid, non nullptr, vector of spatial accelerations
containing the spatial acceleration <code class="docutils literal notranslate"><span class="pre">A_WB</span></code> for each body. It
must be of size equal to the number of bodies in the model. On
output, entries will be ordered by BodyIndex.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if A_WB_array is not of size num_bodies</strong><strong>(</strong><strong>)</strong><strong></strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcSpatialInertia">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].CalcSpatialInertia"></span><span class="sig-name descname"><span class="pre">CalcSpatialInertia</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_F</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame_" title="pydrake.multibody.tree.Frame_"><span class="pre">pydrake.multibody.tree.Frame_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body_indexes</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.BodyIndex" title="pydrake.multibody.tree.BodyIndex"><span class="pre">pydrake.multibody.tree.BodyIndex</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.SpatialInertia_" title="pydrake.multibody.tree.SpatialInertia_"><span class="pre">pydrake.multibody.tree.SpatialInertia_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcSpatialInertia" title="Permalink to this definition"></a></dt>
<dd><p>Returns M_SFo_F, the spatial inertia of a set S of bodies about point
Fo (the origin of a frame F), expressed in frame F. You may regard
M_SFo_F as measuring spatial inertia as if the set S of bodies were
welded into a single composite body at the configuration specified in
the <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>Contains the configuration of the set S of bodies.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_F</span></code>:</dt><dd><p>specifies the about-point Fo (frame_F’s origin) and the
expressed-in frame for the returned spatial inertia.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body_indexes</span></code>:</dt><dd><p>Array of selected bodies. This method does not distinguish between
welded bodies, joint-connected bodies, etc.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if body_indexes contains an invalid BodyIndex</strong><strong> or </strong><strong>if</strong> – </p></li>
<li><p><strong>there is a repeated BodyIndex.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The mass and inertia of the world_body() does not contribute to
the the returned spatial inertia.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcSpatialMomentumInWorldAboutPoint">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].CalcSpatialMomentumInWorldAboutPoint"></span><span class="sig-name descname"><span class="pre">CalcSpatialMomentumInWorldAboutPoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcSpatialMomentumInWorldAboutPoint" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>CalcSpatialMomentumInWorldAboutPoint(self: pydrake.multibody.plant.MultibodyPlant_[Expression], context: pydrake.systems.framework.Context_[Expression], p_WoP_W: numpy.ndarray[object[3, 1]]) -&gt; pydrake.multibody.math.SpatialMomentum_[Expression]</p></li>
</ol>
<p>This method returns the spatial momentum of <code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant in
the world frame W, about a designated point P, expressed in the world
frame W.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>Contains the state of the model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_WoP_W</span></code>:</dt><dd><p>Position from Wo (origin of the world frame W) to an arbitrary
point P, expressed in the world frame W.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">L_WSP_W</span></code>:</dt><dd><p>, spatial momentum of the system S represented by <code class="docutils literal notranslate"><span class="pre">this</span></code> plant,
measured in the world frame W, about point P, expressed in W.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>To calculate the spatial momentum of this system S in W about Scm
(the system’s center of mass), use something like:</p>
</div>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">plant</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="c1">// ... code to load a model ....</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">Vector3</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">p_WoScm_W</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">    </span><span class="n">plant</span><span class="p">.</span><span class="n">CalcCenterOfMassPositionInWorld</span><span class="p">(</span><span class="n">context</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">SpatialMomentum</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">L_WScm_W</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">    </span><span class="n">plant</span><span class="p">.</span><span class="n">CalcSpatialMomentumInWorldAboutPoint</span><span class="p">(</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="n">p_WoScm_W</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</details><ol class="arabic simple" start="2">
<li><p>CalcSpatialMomentumInWorldAboutPoint(self: pydrake.multibody.plant.MultibodyPlant_[Expression], context: pydrake.systems.framework.Context_[Expression], model_instances: List[pydrake.multibody.tree.ModelInstanceIndex], p_WoP_W: numpy.ndarray[object[3, 1]]) -&gt; pydrake.multibody.math.SpatialMomentum_[Expression]</p></li>
</ol>
<p>This method returns the spatial momentum of a set of model instances
in the world frame W, about a designated point P, expressed in frame
W.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>Contains the state of the model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">model_instances</span></code>:</dt><dd><p>Set of selected model instances.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_WoP_W</span></code>:</dt><dd><p>Position from Wo (origin of the world frame W) to an arbitrary
point P, expressed in the world frame W.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">L_WSP_W</span></code>:</dt><dd><p>, spatial momentum of the system S represented by the
model_instances, measured in world frame W, about point P,
expressed in W.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>To calculate the spatial momentum of this system S in W about Scm
(the system’s center of mass), use something like:</p>
</div>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">plant</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="c1">// ... code to create a set of selected model instances, e.g., ...</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">ModelInstanceIndex</span><span class="w"> </span><span class="n">gripper_model_instance</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">    </span><span class="n">plant</span><span class="p">.</span><span class="n">GetModelInstanceByName</span><span class="p">(</span><span class="s">&quot;gripper&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">ModelInstanceIndex</span><span class="w"> </span><span class="n">robot_model_instance</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">    </span><span class="n">plant</span><span class="p">.</span><span class="n">GetBodyByName</span><span class="p">(</span><span class="s">&quot;end_effector&quot;</span><span class="p">).</span><span class="n">model_instance</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ModelInstanceIndex</span><span class="o">&gt;</span><span class="w"> </span><span class="n">model_instances</span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">gripper_model_instance</span><span class="p">,</span><span class="w"> </span><span class="n">robot_model_instance</span><span class="p">};</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">Vector3</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">p_WoScm_W</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">    </span><span class="n">plant</span><span class="p">.</span><span class="n">CalcCenterOfMassPositionInWorld</span><span class="p">(</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="n">model_instances</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">SpatialMomentum</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">L_WScm_W</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">    </span><span class="n">plant</span><span class="p">.</span><span class="n">CalcSpatialMomentumInWorldAboutPoint</span><span class="p">(</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="n">model_instances</span><span class="p">,</span><span class="w"></span>
<span class="w">                                               </span><span class="n">p_WoScm_W</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</details><dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if model_instances contains an invalid</strong> – </p></li>
<li><p><strong>ModelInstanceIndex.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcTotalMass">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].CalcTotalMass"></span><span class="sig-name descname"><span class="pre">CalcTotalMass</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.CalcTotalMass" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>CalcTotalMass(self: pydrake.multibody.plant.MultibodyPlant_[Expression], context: pydrake.systems.framework.Context_[Expression]) -&gt; pydrake.symbolic.Expression</p></li>
</ol>
<p>Calculates the total mass of all bodies in this MultibodyPlant.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>Contains the state of the model.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">The</span></code>:</dt><dd><p>total mass of all bodies or 0 if there are none.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The mass of the world_body() does not contribute to the total
mass.</p>
</div>
<ol class="arabic simple" start="2">
<li><p>CalcTotalMass(self: pydrake.multibody.plant.MultibodyPlant_[Expression], context: pydrake.systems.framework.Context_[Expression], model_instances: List[pydrake.multibody.tree.ModelInstanceIndex]) -&gt; pydrake.symbolic.Expression</p></li>
</ol>
<p>Calculates the total mass of all bodies contained in model_instances.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>Contains the state of the model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">model_instances</span></code>:</dt><dd><p>Vector of selected model instances. This method does not
distinguish between welded, joint connected, or floating bodies.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">The</span></code>:</dt><dd><p>total mass of all bodies belonging to a model instance in
model_instances or 0 if model_instances is empty.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The mass of the world_body() does not contribute to the total mass
and each body only contributes to the total mass once, even if the
body has repeated occurrence (instance) in model_instances.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.CollectRegisteredGeometries">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].CollectRegisteredGeometries"></span><span class="sig-name descname"><span class="pre">CollectRegisteredGeometries</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bodies</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody_" title="pydrake.multibody.tree.RigidBody_"><span class="pre">pydrake.multibody.tree.RigidBody_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.GeometrySet" title="pydrake.geometry.GeometrySet"><span class="pre">pydrake.geometry.GeometrySet</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.CollectRegisteredGeometries" title="Permalink to this definition"></a></dt>
<dd><p>For each of the provided <code class="docutils literal notranslate"><span class="pre">bodies</span></code>, collects up all geometries that
have been registered to that body. Intended to be used in conjunction
with CollisionFilterDeclaration and CollisionFilterManager::Apply() to
filter collisions between the geometries registered to the bodies.</p>
<p>For example:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Don&#39;t report on collisions between geometries affixed to `body1`,</span>
<span class="c1">// `body2`, or `body3`.</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">RigidBody</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*&gt;</span><span class="w"> </span><span class="n">bodies</span><span class="p">{</span><span class="o">&amp;</span><span class="n">body1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">body2</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">body3</span><span class="p">};</span><span class="w"></span>
<span class="n">geometry</span><span class="o">::</span><span class="n">GeometrySet</span><span class="w"> </span><span class="n">set</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">plant</span><span class="p">.</span><span class="n">CollectRegisteredGeometries</span><span class="p">(</span><span class="n">bodies</span><span class="p">);</span><span class="w"></span>
<span class="n">scene_graph</span><span class="p">.</span><span class="n">collision_filter_manager</span><span class="p">().</span><span class="n">Apply</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">CollisionFilterDeclaration</span><span class="p">().</span><span class="n">ExcludeWithin</span><span class="p">(</span><span class="n">set</span><span class="p">));</span><span class="w"></span>
</pre></div>
</div>
</details><div class="admonition note">
<p class="admonition-title">Note</p>
<p>There is a <em>very</em> specific order of operations:</p>
</div>
<ol class="arabic simple">
<li><p>Bodies and geometries must be added to the MultibodyPlant.</p></li>
<li><p>Create GeometrySet instances from bodies (via this method).</p></li>
<li><p>Invoke SceneGraph::ExcludeCollisions*() to filter collisions.</p></li>
<li><p>Allocate context.</p></li>
</ol>
<p>Changing the order will cause exceptions to be thrown.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if this MultibodyPlant was not registered with a</strong> – </p></li>
<li><p><strong>SceneGraph.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.EvalBodyPoseInWorld">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].EvalBodyPoseInWorld"></span><span class="sig-name descname"><span class="pre">EvalBodyPoseInWorld</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody_" title="pydrake.multibody.tree.RigidBody_"><span class="pre">pydrake.multibody.tree.RigidBody_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.math.html#pydrake.math.RigidTransform_" title="pydrake.math.RigidTransform_"><span class="pre">pydrake.math.RigidTransform_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.EvalBodyPoseInWorld" title="Permalink to this definition"></a></dt>
<dd><p>Evaluate the pose <code class="docutils literal notranslate"><span class="pre">X_WB</span></code> of a body B in the world frame W.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context storing the state of the model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body_B</span></code>:</dt><dd><p>The body B for which the pose is requested.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">X_WB</span></code>:</dt><dd><p>The pose of body frame B in the world frame W.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if Finalize</strong><strong>(</strong><strong>) </strong><strong>was not called on this model</strong><strong> or </strong><strong>if</strong> – </p></li>
<li><p><strong>body_B` does not belong to this model</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.EvalBodySpatialAccelerationInWorld">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].EvalBodySpatialAccelerationInWorld"></span><span class="sig-name descname"><span class="pre">EvalBodySpatialAccelerationInWorld</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody_" title="pydrake.multibody.tree.RigidBody_"><span class="pre">pydrake.multibody.tree.RigidBody_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.math.html#pydrake.multibody.math.SpatialAcceleration_" title="pydrake.multibody.math.SpatialAcceleration_"><span class="pre">pydrake.multibody.math.SpatialAcceleration_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.EvalBodySpatialAccelerationInWorld" title="Permalink to this definition"></a></dt>
<dd><p>Evaluates A_WB, body B’s spatial acceleration in the world frame W.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context storing the state of the model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body_B</span></code>:</dt><dd><p>The body for which spatial acceleration is requested.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">A_WB_W</span></code>:</dt><dd><p>RigidBody B’s spatial acceleration in the world frame W, expressed
in W (for point Bo, the body’s origin).</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if Finalize</strong><strong>(</strong><strong>) </strong><strong>was not called on this model</strong><strong> or </strong><strong>if</strong> – </p></li>
<li><p><strong>body_B` does not belong to this model</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When cached values are out of sync with the state stored in
context, this method performs an expensive forward dynamics
computation, whereas once evaluated, successive calls to this
method are inexpensive.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.EvalBodySpatialVelocityInWorld">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].EvalBodySpatialVelocityInWorld"></span><span class="sig-name descname"><span class="pre">EvalBodySpatialVelocityInWorld</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody_" title="pydrake.multibody.tree.RigidBody_"><span class="pre">pydrake.multibody.tree.RigidBody_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.math.html#pydrake.multibody.math.SpatialVelocity_" title="pydrake.multibody.math.SpatialVelocity_"><span class="pre">pydrake.multibody.math.SpatialVelocity_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.EvalBodySpatialVelocityInWorld" title="Permalink to this definition"></a></dt>
<dd><p>Evaluates V_WB, body B’s spatial velocity in the world frame W.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context storing the state of the model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body_B</span></code>:</dt><dd><p>The body B for which the spatial velocity is requested.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">V_WB_W</span></code>:</dt><dd><p>RigidBody B’s spatial velocity in the world frame W, expressed in
W (for point Bo, the body’s origin).</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if Finalize</strong><strong>(</strong><strong>) </strong><strong>was not called on this model</strong><strong> or </strong><strong>if</strong> – </p></li>
<li><p><strong>body_B` does not belong to this model</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.Finalize">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].Finalize"></span><span class="sig-name descname"><span class="pre">Finalize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.Finalize" title="Permalink to this definition"></a></dt>
<dd><p>This method must be called after all elements in the model (joints,
bodies, force elements, constraints, etc.) are added and before any
computations are performed. It essentially compiles all the necessary
“topological information”, i.e. how bodies, joints and, any other
elements connect with each other, and performs all the required
pre-processing to enable computations at a later stage.</p>
<p>If the finalize stage is successful, the topology of this
MultibodyPlant is valid, meaning that the topology is up-to-date after
this call. No more multibody elements can be added after a call to
Finalize().</p>
<p>At Finalize(), state and input/output ports for <code class="docutils literal notranslate"><span class="pre">this</span></code> plant are
declared.</p>
<p>For a full account of the effects of Finalize(), see
mbp_finalize_stage “Finalize() stage”.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>is_finalized(), mbp_finalize_stage “Finalize() stage”.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if the MultibodyPlant has already been finalized.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.geometry_source_is_registered">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].geometry_source_is_registered"></span><span class="sig-name descname"><span class="pre">geometry_source_is_registered</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.geometry_source_is_registered" title="Permalink to this definition"></a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if <code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant was registered with a
SceneGraph. This method can be called at any time during the lifetime
of <code class="docutils literal notranslate"><span class="pre">this</span></code> plant to query if <code class="docutils literal notranslate"><span class="pre">this</span></code> plant has been registered with
a SceneGraph, either pre- or post-finalize, see Finalize().</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.get_actuation_input_port">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].get_actuation_input_port"></span><span class="sig-name descname"><span class="pre">get_actuation_input_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.get_actuation_input_port" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>get_actuation_input_port(self: pydrake.multibody.plant.MultibodyPlant_[Expression]) -&gt; pydrake.systems.framework.InputPort_[Expression]</p></li>
</ol>
<p>Returns a constant reference to the input port for external actuation
for all actuated dofs. This input port is a vector valued port and can
be set with JointActuator::set_actuation_vector(). The actuation value
for a particular actuator can be found at offset
JointActuator::input_start() in this vector. Refer to mbp_actuation
“Actuation” for further details.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>Finalize() was already called on <code class="docutils literal notranslate"><span class="pre">this</span></code> plant.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if called before Finalize</strong><strong>(</strong><strong>)</strong><strong></strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>get_actuation_input_port(self: pydrake.multibody.plant.MultibodyPlant_[Expression], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; pydrake.systems.framework.InputPort_[Expression]</p></li>
</ol>
<p>Returns a constant reference to the input port for external actuation
for a specific model instance. This is a vector valued port with
entries ordered by monotonically increasing JointActuatorIndex within
<code class="docutils literal notranslate"><span class="pre">model_instance</span></code>. Refer to mbp_actuation “Actuation” for further
details.</p>
<p>Every model instance in <code class="docutils literal notranslate"><span class="pre">this</span></code> plant model has an actuation input
port, even if zero sized (for model instance with no actuators).</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>GetJointActuatorIndices(), GetActuatedJointIndices().</p>
</div>
<dl class="simple">
<dt>Precondition:</dt><dd><p>Finalize() was already called on <code class="docutils literal notranslate"><span class="pre">this</span></code> plant.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if called before Finalize</strong><strong>(</strong><strong>)</strong><strong></strong> – </p></li>
<li><p><strong>RuntimeError if the model instance does not exist.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.get_adjacent_bodies_collision_filters">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].get_adjacent_bodies_collision_filters"></span><span class="sig-name descname"><span class="pre">get_adjacent_bodies_collision_filters</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.get_adjacent_bodies_collision_filters" title="Permalink to this definition"></a></dt>
<dd><p>Returns whether to apply collision filters to topologically adjacent
bodies at Finalize() time.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.get_applied_generalized_force_input_port">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].get_applied_generalized_force_input_port"></span><span class="sig-name descname"><span class="pre">get_applied_generalized_force_input_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.InputPort_" title="pydrake.systems.framework.InputPort_"><span class="pre">pydrake.systems.framework.InputPort_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.get_applied_generalized_force_input_port" title="Permalink to this definition"></a></dt>
<dd><p>Returns a constant reference to the vector-valued input port for
applied generalized forces, and the vector will be added directly into
<code class="docutils literal notranslate"><span class="pre">tau</span></code> (see mbp_equations_of_motion “System dynamics”). This vector
is ordered using the same convention as the plant velocities: you can
set the generalized forces that will be applied to model instance i
using, e.g., <code class="docutils literal notranslate"><span class="pre">SetVelocitiesInArray(i,</span> <span class="pre">model_forces,</span> <span class="pre">&amp;force_array)</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if called before Finalize</strong><strong>(</strong><strong>)</strong><strong></strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.get_applied_spatial_force_input_port">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].get_applied_spatial_force_input_port"></span><span class="sig-name descname"><span class="pre">get_applied_spatial_force_input_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.InputPort_" title="pydrake.systems.framework.InputPort_"><span class="pre">pydrake.systems.framework.InputPort_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.get_applied_spatial_force_input_port" title="Permalink to this definition"></a></dt>
<dd><p>Returns a constant reference to the input port for applying spatial
forces to bodies in the plant. The data type for the port is an
std::vector of ExternallyAppliedSpatialForce; any number of spatial
forces can be applied to any number of bodies in the plant.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.get_body">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].get_body"></span><span class="sig-name descname"><span class="pre">get_body</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.BodyIndex" title="pydrake.multibody.tree.BodyIndex"><span class="pre">pydrake.multibody.tree.BodyIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody_" title="pydrake.multibody.tree.RigidBody_"><span class="pre">pydrake.multibody.tree.RigidBody_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.get_body" title="Permalink to this definition"></a></dt>
<dd><p>Returns a constant reference to the body with unique index
<code class="docutils literal notranslate"><span class="pre">body_index</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if body_index does not correspond to a body in</strong> – </p></li>
<li><p><strong>this model.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.get_body_poses_output_port">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].get_body_poses_output_port"></span><span class="sig-name descname"><span class="pre">get_body_poses_output_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.OutputPort_" title="pydrake.systems.framework.OutputPort_"><span class="pre">pydrake.systems.framework.OutputPort_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.get_body_poses_output_port" title="Permalink to this definition"></a></dt>
<dd><p>Returns the output port of all body poses in the world frame. You can
obtain the pose <code class="docutils literal notranslate"><span class="pre">X_WB</span></code> of a body B in the world frame W with:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">X_WB_all</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">plant</span><span class="p">.</span><span class="n">get_body_poses_output_port</span><span class="p">().</span><span class="w"></span>
<span class="w">      </span><span class="p">.</span><span class="n">Eval</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">math</span><span class="o">::</span><span class="n">RigidTransform</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">plant_context</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">BodyIndex</span><span class="w"> </span><span class="n">arm_body_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">plant</span><span class="p">.</span><span class="n">GetBodyByName</span><span class="p">(</span><span class="s">&quot;arm&quot;</span><span class="p">).</span><span class="n">index</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">math</span><span class="o">::</span><span class="n">RigidTransform</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">X_WArm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">X_WB_all</span><span class="p">[</span><span class="n">arm_body_index</span><span class="p">];</span><span class="w"></span>
</pre></div>
</div>
</details><p>As shown in the example above, the resulting <code class="docutils literal notranslate"><span class="pre">std::vector</span></code> of body
poses is indexed by BodyIndex, and it has size num_bodies(). BodyIndex
“zero” (0) always corresponds to the world body, with pose equal to
the identity at all times.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.get_body_spatial_accelerations_output_port">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].get_body_spatial_accelerations_output_port"></span><span class="sig-name descname"><span class="pre">get_body_spatial_accelerations_output_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.OutputPort_" title="pydrake.systems.framework.OutputPort_"><span class="pre">pydrake.systems.framework.OutputPort_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.get_body_spatial_accelerations_output_port" title="Permalink to this definition"></a></dt>
<dd><p>Returns the output port of all body spatial accelerations in the world
frame. You can obtain the spatial acceleration <code class="docutils literal notranslate"><span class="pre">A_WB</span></code> of a body B in
the world frame W with:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">A_WB_all</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">  </span><span class="n">plant</span><span class="p">.</span><span class="n">get_body_spatial_accelerations_output_port</span><span class="p">().</span><span class="w"></span>
<span class="w">      </span><span class="p">.</span><span class="n">Eval</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SpatialAcceleration</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">plant_context</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">BodyIndex</span><span class="w"> </span><span class="n">arm_body_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">plant</span><span class="p">.</span><span class="n">GetBodyByName</span><span class="p">(</span><span class="s">&quot;arm&quot;</span><span class="p">).</span><span class="n">index</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">SpatialVelocity</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">A_WArm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A_WB_all</span><span class="p">[</span><span class="n">arm_body_index</span><span class="p">];</span><span class="w"></span>
</pre></div>
</div>
</details><p>As shown in the example above, the resulting <code class="docutils literal notranslate"><span class="pre">std::vector</span></code> of body
spatial accelerations is indexed by BodyIndex, and it has size
num_bodies(). BodyIndex “zero” (0) always corresponds to the world
body, with zero spatial acceleration at all times.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.get_body_spatial_velocities_output_port">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].get_body_spatial_velocities_output_port"></span><span class="sig-name descname"><span class="pre">get_body_spatial_velocities_output_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.OutputPort_" title="pydrake.systems.framework.OutputPort_"><span class="pre">pydrake.systems.framework.OutputPort_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.get_body_spatial_velocities_output_port" title="Permalink to this definition"></a></dt>
<dd><p>Returns the output port of all body spatial velocities in the world
frame. You can obtain the spatial velocity <code class="docutils literal notranslate"><span class="pre">V_WB</span></code> of a body B in the
world frame W with:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">V_WB_all</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">plant</span><span class="p">.</span><span class="n">get_body_spatial_velocities_output_port</span><span class="p">().</span><span class="w"></span>
<span class="w">      </span><span class="p">.</span><span class="n">Eval</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SpatialVelocity</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">plant_context</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">BodyIndex</span><span class="w"> </span><span class="n">arm_body_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">plant</span><span class="p">.</span><span class="n">GetBodyByName</span><span class="p">(</span><span class="s">&quot;arm&quot;</span><span class="p">).</span><span class="n">index</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">SpatialVelocity</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">V_WArm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">V_WB_all</span><span class="p">[</span><span class="n">arm_body_index</span><span class="p">];</span><span class="w"></span>
</pre></div>
</div>
</details><p>As shown in the example above, the resulting <code class="docutils literal notranslate"><span class="pre">std::vector</span></code> of body
spatial velocities is indexed by BodyIndex, and it has size
num_bodies(). BodyIndex “zero” (0) always corresponds to the world
body, with zero spatial velocity at all times.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.get_contact_model">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].get_contact_model"></span><span class="sig-name descname"><span class="pre">get_contact_model</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.multibody.plant.ContactModel" title="pydrake.multibody.plant.ContactModel"><span class="pre">pydrake.multibody.plant.ContactModel</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.get_contact_model" title="Permalink to this definition"></a></dt>
<dd><p>Returns the model used for contact. See documentation for
ContactModel.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.get_contact_penalty_method_time_scale">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].get_contact_penalty_method_time_scale"></span><span class="sig-name descname"><span class="pre">get_contact_penalty_method_time_scale</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.get_contact_penalty_method_time_scale" title="Permalink to this definition"></a></dt>
<dd><p>Returns a time-scale estimate <code class="docutils literal notranslate"><span class="pre">tc</span></code> based on the requested
penetration allowance δ set with set_penetration_allowance(). For the
compliant contact model to enforce non-penetration, this time scale
relates to the time it takes the relative normal velocity between two
bodies to go to zero. This time scale <code class="docutils literal notranslate"><span class="pre">tc</span></code> is a global estimate of
the dynamics introduced by the compliant contact model and goes to
zero in the limit to ideal rigid contact. Since numerical integration
methods for continuum systems must be able to resolve a system’s
dynamics, the time step used by an integrator must in general be much
smaller than the time scale <code class="docutils literal notranslate"><span class="pre">tc</span></code>. How much smaller will depend on
the details of the problem and the convergence characteristics of the
integrator and should be tuned appropriately. Another factor to take
into account for setting up the simulation’s time step is the speed of
the objects in your simulation. If <code class="docutils literal notranslate"><span class="pre">vn</span></code> represents a reference
velocity scale for the normal relative velocity between bodies, the
new time scale <code class="docutils literal notranslate"><span class="pre">tn</span> <span class="pre">=</span> <span class="pre">δ</span> <span class="pre">/</span> <span class="pre">vn</span></code> represents the time it would take for
the distance between two bodies approaching with relative normal
velocity <code class="docutils literal notranslate"><span class="pre">vn</span></code> to decrease by the penetration_allowance δ. In this
case a user should choose a time step for simulation that can resolve
the smallest of the two time scales <code class="docutils literal notranslate"><span class="pre">tc</span></code> and <code class="docutils literal notranslate"><span class="pre">tn</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.get_contact_results_output_port">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].get_contact_results_output_port"></span><span class="sig-name descname"><span class="pre">get_contact_results_output_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.OutputPort_" title="pydrake.systems.framework.OutputPort_"><span class="pre">pydrake.systems.framework.OutputPort_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.get_contact_results_output_port" title="Permalink to this definition"></a></dt>
<dd><p>Returns a constant reference to the port that outputs ContactResults.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize</strong><strong>, </strong><strong>see Finalize</strong><strong>(</strong><strong>)</strong><strong></strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.get_contact_surface_representation">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].get_contact_surface_representation"></span><span class="sig-name descname"><span class="pre">get_contact_surface_representation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.HydroelasticContactRepresentation" title="pydrake.geometry.HydroelasticContactRepresentation"><span class="pre">pydrake.geometry.HydroelasticContactRepresentation</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.get_contact_surface_representation" title="Permalink to this definition"></a></dt>
<dd><p>Gets the current representation of contact surfaces used by <code class="docutils literal notranslate"><span class="pre">this</span></code>
MultibodyPlant.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.get_deformable_body_configuration_output_port">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].get_deformable_body_configuration_output_port"></span><span class="sig-name descname"><span class="pre">get_deformable_body_configuration_output_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.OutputPort_" title="pydrake.systems.framework.OutputPort_"><span class="pre">pydrake.systems.framework.OutputPort_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.get_deformable_body_configuration_output_port" title="Permalink to this definition"></a></dt>
<dd><p>Returns the output port for vertex positions (configurations),
measured and expressed in the World frame, of the deformable bodies in
<code class="docutils literal notranslate"><span class="pre">this</span></code> plant as a GeometryConfigurationVector.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if this MultibodyPlant doesn't have a</strong> – </p></li>
<li><p><strong>DeformableModel. See AddPhysicalModel</strong><strong>(</strong><strong>)</strong><strong></strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.get_desired_state_input_port">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].get_desired_state_input_port"></span><span class="sig-name descname"><span class="pre">get_desired_state_input_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.InputPort_" title="pydrake.systems.framework.InputPort_"><span class="pre">pydrake.systems.framework.InputPort_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.get_desired_state_input_port" title="Permalink to this definition"></a></dt>
<dd><p>For models with PD controlled joint actuators, returns the port to
provide the desired state for the full <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>. Refer to
mbp_actuation “Actuation” for further details.</p>
<p>For consistency with get_actuation_input_port(), each model instance
in <code class="docutils literal notranslate"><span class="pre">this</span></code> plant model has a desired states input port, even if zero
sized (for model instance with no actuators.)</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is a vector valued port of size
2*num_actuators(model_instance), where we assumed 1-DOF actuated
joints. This is true even for unactuated models, for which this
port is zero sized. This port must provide one desired position
and one desired velocity per joint actuator. Desired state is
assumed to be packed as xd = [qd, vd] that is, configurations
first followed by velocities. The actuation value for a particular
actuator can be found at offset JointActuator::input_start() in
both qd and vd. For example:</p>
</div>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">qd_actuator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xd</span><span class="p">[</span><span class="n">actuator</span><span class="p">.</span><span class="n">input_start</span><span class="p">()];</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">vd_actuator</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">   </span><span class="n">xd</span><span class="p">[</span><span class="n">actuator</span><span class="p">.</span><span class="n">input_start</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">plant</span><span class="p">.</span><span class="n">num_actuated_dofs</span><span class="p">()];</span><span class="w"></span>
</pre></div>
</div>
</details><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>If a user specifies a PD controller for an actuator from a given
model instance, then all actuators of that model instance are
required to be PD controlled.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>It is required to connect this port for PD controlled model
instances.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.get_discrete_contact_approximation">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].get_discrete_contact_approximation"></span><span class="sig-name descname"><span class="pre">get_discrete_contact_approximation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.multibody.plant.DiscreteContactApproximation" title="pydrake.multibody.plant.DiscreteContactApproximation"><span class="pre">pydrake.multibody.plant.DiscreteContactApproximation</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.get_discrete_contact_approximation" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the discrete contact solver approximation.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.get_discrete_contact_solver">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].get_discrete_contact_solver"></span><span class="sig-name descname"><span class="pre">get_discrete_contact_solver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.multibody.plant.DiscreteContactSolver" title="pydrake.multibody.plant.DiscreteContactSolver"><span class="pre">pydrake.multibody.plant.DiscreteContactSolver</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.get_discrete_contact_solver" title="Permalink to this definition"></a></dt>
<dd><p>Returns the contact solver type used for discrete MultibodyPlant
models.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.get_force_element">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].get_force_element"></span><span class="sig-name descname"><span class="pre">get_force_element</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">force_element_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ForceElementIndex" title="pydrake.multibody.tree.ForceElementIndex"><span class="pre">pydrake.multibody.tree.ForceElementIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ForceElement_" title="pydrake.multibody.tree.ForceElement_"><span class="pre">pydrake.multibody.tree.ForceElement_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.get_force_element" title="Permalink to this definition"></a></dt>
<dd><p>Returns a constant reference to the force element with unique index
<code class="docutils literal notranslate"><span class="pre">force_element_index</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError when force_element_index does not correspond to a</strong> – </p></li>
<li><p><strong>force element in this model.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.get_frame">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].get_frame"></span><span class="sig-name descname"><span class="pre">get_frame</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.FrameIndex" title="pydrake.multibody.tree.FrameIndex"><span class="pre">pydrake.multibody.tree.FrameIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame_" title="pydrake.multibody.tree.Frame_"><span class="pre">pydrake.multibody.tree.Frame_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.get_frame" title="Permalink to this definition"></a></dt>
<dd><p>Returns a constant reference to the frame with unique index
<code class="docutils literal notranslate"><span class="pre">frame_index</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if frame_index does not correspond to a frame in</strong> – </p></li>
<li><p><strong>this plant.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.get_generalized_acceleration_output_port">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].get_generalized_acceleration_output_port"></span><span class="sig-name descname"><span class="pre">get_generalized_acceleration_output_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.get_generalized_acceleration_output_port" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>get_generalized_acceleration_output_port(self: pydrake.multibody.plant.MultibodyPlant_[Expression]) -&gt; pydrake.systems.framework.OutputPort_[Expression]</p></li>
</ol>
<p>Returns a constant reference to the output port for generalized
accelerations v̇ of the model.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>Finalize() was already called on <code class="docutils literal notranslate"><span class="pre">this</span></code> plant.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if called before Finalize</strong><strong>(</strong><strong>)</strong><strong></strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>get_generalized_acceleration_output_port(self: pydrake.multibody.plant.MultibodyPlant_[Expression], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; pydrake.systems.framework.OutputPort_[Expression]</p></li>
</ol>
<p>Returns a constant reference to the output port for the generalized
accelerations v̇ᵢ ⊆ v̇ for model instance i.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>Finalize() was already called on <code class="docutils literal notranslate"><span class="pre">this</span></code> plant.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if called before Finalize</strong><strong>(</strong><strong>)</strong><strong></strong> – </p></li>
<li><p><strong>RuntimeError if the model instance does not exist.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.get_generalized_contact_forces_output_port">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].get_generalized_contact_forces_output_port"></span><span class="sig-name descname"><span class="pre">get_generalized_contact_forces_output_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.OutputPort_" title="pydrake.systems.framework.OutputPort_"><span class="pre">pydrake.systems.framework.OutputPort_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.get_generalized_contact_forces_output_port" title="Permalink to this definition"></a></dt>
<dd><p>Returns a constant reference to the output port of generalized contact
forces for a specific model instance.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>Finalize() was already called on <code class="docutils literal notranslate"><span class="pre">this</span></code> plant.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if called before Finalize</strong><strong>(</strong><strong>)</strong><strong></strong> – </p></li>
<li><p><strong>RuntimeError if the model instance does not exist.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.get_geometry_poses_output_port">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].get_geometry_poses_output_port"></span><span class="sig-name descname"><span class="pre">get_geometry_poses_output_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.OutputPort_" title="pydrake.systems.framework.OutputPort_"><span class="pre">pydrake.systems.framework.OutputPort_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.get_geometry_poses_output_port" title="Permalink to this definition"></a></dt>
<dd><p>Returns the output port of frames’ poses to communicate with a
SceneGraph.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.get_geometry_query_input_port">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].get_geometry_query_input_port"></span><span class="sig-name descname"><span class="pre">get_geometry_query_input_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.InputPort_" title="pydrake.systems.framework.InputPort_"><span class="pre">pydrake.systems.framework.InputPort_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.get_geometry_query_input_port" title="Permalink to this definition"></a></dt>
<dd><p>Returns a constant reference to the input port used to perform
geometric queries on a SceneGraph. See
SceneGraph::get_query_output_port(). Refer to section mbp_geometry
“Geometry” of this class’s documentation for further details on
collision geometry registration and connection with a SceneGraph.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.get_joint">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].get_joint"></span><span class="sig-name descname"><span class="pre">get_joint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">joint_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JointIndex" title="pydrake.multibody.tree.JointIndex"><span class="pre">pydrake.multibody.tree.JointIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Joint_" title="pydrake.multibody.tree.Joint_"><span class="pre">pydrake.multibody.tree.Joint_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.get_joint" title="Permalink to this definition"></a></dt>
<dd><p>Returns a constant reference to the joint with unique index
<code class="docutils literal notranslate"><span class="pre">joint_index</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError when joint_index does not correspond to a joint</strong> – </p></li>
<li><p><strong>in this model.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.get_joint_actuator">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].get_joint_actuator"></span><span class="sig-name descname"><span class="pre">get_joint_actuator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">actuator_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JointActuatorIndex" title="pydrake.multibody.tree.JointActuatorIndex"><span class="pre">pydrake.multibody.tree.JointActuatorIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JointActuator_" title="pydrake.multibody.tree.JointActuator_"><span class="pre">pydrake.multibody.tree.JointActuator_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.get_joint_actuator" title="Permalink to this definition"></a></dt>
<dd><p>Returns a constant reference to the joint actuator with unique index
<code class="docutils literal notranslate"><span class="pre">actuator_index</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if actuator_index does not correspond to a joint</strong> – </p></li>
<li><p><strong>actuator in this tree.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.get_mutable_joint">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].get_mutable_joint"></span><span class="sig-name descname"><span class="pre">get_mutable_joint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">joint_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JointIndex" title="pydrake.multibody.tree.JointIndex"><span class="pre">pydrake.multibody.tree.JointIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Joint_" title="pydrake.multibody.tree.Joint_"><span class="pre">pydrake.multibody.tree.Joint_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.get_mutable_joint" title="Permalink to this definition"></a></dt>
<dd><p>Returns a mutable reference to the joint with unique index
<code class="docutils literal notranslate"><span class="pre">joint_index</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError when joint_index does not correspond to a joint</strong> – </p></li>
<li><p><strong>in this model.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.get_mutable_joint_actuator">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].get_mutable_joint_actuator"></span><span class="sig-name descname"><span class="pre">get_mutable_joint_actuator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">actuator_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JointActuatorIndex" title="pydrake.multibody.tree.JointActuatorIndex"><span class="pre">pydrake.multibody.tree.JointActuatorIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JointActuator_" title="pydrake.multibody.tree.JointActuator_"><span class="pre">pydrake.multibody.tree.JointActuator_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.get_mutable_joint_actuator" title="Permalink to this definition"></a></dt>
<dd><p>Returns a mutable reference to the joint actuator with unique index
<code class="docutils literal notranslate"><span class="pre">actuator_index</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if actuator_index does not correspond to a joint</strong> – </p></li>
<li><p><strong>actuator in this tree.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.get_net_actuation_output_port">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].get_net_actuation_output_port"></span><span class="sig-name descname"><span class="pre">get_net_actuation_output_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.get_net_actuation_output_port" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>get_net_actuation_output_port(self: pydrake.multibody.plant.MultibodyPlant_[Expression]) -&gt; pydrake.systems.framework.OutputPort_[Expression]</p></li>
</ol>
<p>Returns a constant reference to the output port that reports actuation
values applied through joint actuators. This output port is a vector
valued port. The actuation value for a particular actuator can be
found at offset JointActuator::input_start() in this vector. Models
that include PD controllers will include their contribution in this
port, refer to mbp_actuation “Actuation” for further details.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>PD controllers are not considered for actuators on locked joints,
see Joint::Lock(). Therefore they do not contribute to this port.</p>
</div>
<dl class="simple">
<dt>Precondition:</dt><dd><p>Finalize() was already called on <code class="docutils literal notranslate"><span class="pre">this</span></code> plant.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if called before Finalize</strong><strong>(</strong><strong>)</strong><strong></strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>get_net_actuation_output_port(self: pydrake.multibody.plant.MultibodyPlant_[Expression], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; pydrake.systems.framework.OutputPort_[Expression]</p></li>
</ol>
<p>Returns a constant reference to the output port that reports actuation
values applied through joint actuators, for a specific model instance.
Models that include PD controllers will include their contribution in
this port, refer to mbp_actuation “Actuation” for further details.
This is a vector valued port with entries ordered by monotonically
increasing JointActuatorIndex within <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>.</p>
<p>Every model instance in <code class="docutils literal notranslate"><span class="pre">this</span></code> plant model has a net actuation
output port, even if zero sized (for model instance with no
actuators).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>PD controllers are not considered for actuators on locked joints,
see Joint::Lock(). Therefore they do not contribute to this port.</p>
</div>
<dl class="simple">
<dt>Precondition:</dt><dd><p>Finalize() was already called on <code class="docutils literal notranslate"><span class="pre">this</span></code> plant.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if called before Finalize</strong><strong>(</strong><strong>)</strong><strong></strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.get_reaction_forces_output_port">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].get_reaction_forces_output_port"></span><span class="sig-name descname"><span class="pre">get_reaction_forces_output_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.OutputPort_" title="pydrake.systems.framework.OutputPort_"><span class="pre">pydrake.systems.framework.OutputPort_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.get_reaction_forces_output_port" title="Permalink to this definition"></a></dt>
<dd><p>Returns the port for joint reaction forces. A Joint models the
kinematical relationship which characterizes the possible relative
motion between two bodies. In Drake, a joint connects a frame <code class="docutils literal notranslate"><span class="pre">Jp</span></code>
on <em>parent</em> body P with a frame <code class="docutils literal notranslate"><span class="pre">Jc</span></code> on a <em>child</em> body C. This usage
of the terms <em>parent</em> and <em>child</em> is just a convention and implies
nothing about the inboard-outboard relationship between the bodies.
Since a Joint imposes a kinematical relationship which characterizes
the possible relative motion between frames Jp and Jc, reaction forces
on each body are established. That is, we could cut the model at the
joint and replace it with equivalent forces equal to these reaction
forces in order to attain the same motions of the mechanical system.</p>
<p>This output port allows to evaluate the reaction force <code class="docutils literal notranslate"><span class="pre">F_CJc_Jc</span></code> on
the <em>child</em> body C, at <code class="docutils literal notranslate"><span class="pre">Jc</span></code>, and expressed in Jc for all joints in
the model. This port evaluates to a vector of type
std::vector&lt;SpatialForce&lt;T&gt;&gt; and size num_joints() indexed by
JointIndex, see Joint::index(). Each entry corresponds to the spatial
force <code class="docutils literal notranslate"><span class="pre">F_CJc_Jc</span></code> applied on the joint’s child body C
(Joint::child_body()), at the joint’s child frame <code class="docutils literal notranslate"><span class="pre">Jc</span></code>
(Joint::frame_on_child()) and expressed in frame <code class="docutils literal notranslate"><span class="pre">Jc</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.get_sap_near_rigid_threshold">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].get_sap_near_rigid_threshold"></span><span class="sig-name descname"><span class="pre">get_sap_near_rigid_threshold</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.get_sap_near_rigid_threshold" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the SAP near rigid regime threshold.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>See set_sap_near_rigid_threshold().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.get_source_id">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].get_source_id"></span><span class="sig-name descname"><span class="pre">get_source_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.SourceId" title="pydrake.geometry.SourceId"><span class="pre">pydrake.geometry.SourceId</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.get_source_id" title="Permalink to this definition"></a></dt>
<dd><p>Returns the unique id identifying <code class="docutils literal notranslate"><span class="pre">this</span></code> plant as a source for a
SceneGraph. Returns <code class="docutils literal notranslate"><span class="pre">nullopt</span></code> if <code class="docutils literal notranslate"><span class="pre">this</span></code> plant did not register any
geometry. This method can be called at any time during the lifetime of
<code class="docutils literal notranslate"><span class="pre">this</span></code> plant to query if <code class="docutils literal notranslate"><span class="pre">this</span></code> plant has been registered with a
SceneGraph, either pre- or post-finalize, see Finalize(). However, a
geometry::SourceId is only assigned once at the first call of any of
this plant’s geometry registration methods, and it does not change
after that. Post-finalize calls will always return the same value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.get_state_output_port">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].get_state_output_port"></span><span class="sig-name descname"><span class="pre">get_state_output_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.get_state_output_port" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>get_state_output_port(self: pydrake.multibody.plant.MultibodyPlant_[Expression]) -&gt; pydrake.systems.framework.OutputPort_[Expression]</p></li>
</ol>
<p>Returns a constant reference to the output port for the multibody
state x = [q, v] of the model.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>Finalize() was already called on <code class="docutils literal notranslate"><span class="pre">this</span></code> plant.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if called before Finalize</strong><strong>(</strong><strong>)</strong><strong></strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>get_state_output_port(self: pydrake.multibody.plant.MultibodyPlant_[Expression], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; pydrake.systems.framework.OutputPort_[Expression]</p></li>
</ol>
<p>Returns a constant reference to the output port for the state xᵢ = [qᵢ
vᵢ] of model instance i. (Here qᵢ ⊆ q and vᵢ ⊆ v.)</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>Finalize() was already called on <code class="docutils literal notranslate"><span class="pre">this</span></code> plant.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if called before Finalize</strong><strong>(</strong><strong>)</strong><strong></strong> – </p></li>
<li><p><strong>RuntimeError if the model instance does not exist.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetAccelerationLowerLimits">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].GetAccelerationLowerLimits"></span><span class="sig-name descname"><span class="pre">GetAccelerationLowerLimits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetAccelerationLowerLimits" title="Permalink to this definition"></a></dt>
<dd><p>Returns a vector of size <code class="docutils literal notranslate"><span class="pre">num_velocities()</span></code> containing the lower
acceleration limits for every generalized velocity coordinate. These
include joint and free body coordinates. Any unbounded or unspecified
limits will be -infinity.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetAccelerationUpperLimits">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].GetAccelerationUpperLimits"></span><span class="sig-name descname"><span class="pre">GetAccelerationUpperLimits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetAccelerationUpperLimits" title="Permalink to this definition"></a></dt>
<dd><p>Upper limit analog of GetAccelerationsLowerLimits(), where any
unbounded or unspecified limits will be +infinity.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>GetAccelerationLowerLimits() for more information.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetActuatedJointIndices">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].GetActuatedJointIndices"></span><span class="sig-name descname"><span class="pre">GetActuatedJointIndices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JointIndex" title="pydrake.multibody.tree.JointIndex"><span class="pre">pydrake.multibody.tree.JointIndex</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetActuatedJointIndices" title="Permalink to this definition"></a></dt>
<dd><p>Returns a list of actuated joint indices associated with
<code class="docutils literal notranslate"><span class="pre">model_instance</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetActuatorNames">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].GetActuatorNames"></span><span class="sig-name descname"><span class="pre">GetActuatorNames</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetActuatorNames" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetActuatorNames(self: pydrake.multibody.plant.MultibodyPlant_[Expression], add_model_instance_prefix: bool = True) -&gt; List[str]</p></li>
</ol>
<p>Returns a list of string names corresponding to each element of the
actuation vector. These strings take the form
<code class="docutils literal notranslate"><span class="pre">{model_instance_name}_{joint_actuator_name}</span></code>, but the prefix may
optionally be withheld using <code class="docutils literal notranslate"><span class="pre">add_model_instance_prefix</span></code>.</p>
<p>The returned names are guaranteed to be unique if
<code class="docutils literal notranslate"><span class="pre">add_model_instance_prefix</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code> (the default).</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if the plant is not finalized.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>GetActuatorNames(self: pydrake.multibody.plant.MultibodyPlant_[Expression], model_instance: pydrake.multibody.tree.ModelInstanceIndex, add_model_instance_prefix: bool = False) -&gt; List[str]</p></li>
</ol>
<p>Returns a list of string names corresponding to each element of the
actuation vector. These strings take the form
<code class="docutils literal notranslate"><span class="pre">{model_instance_name}_{joint_actuator_name}</span></code>, but the prefix may
optionally be withheld using <code class="docutils literal notranslate"><span class="pre">add_model_instance_prefix</span></code>.</p>
<p>The returned names are guaranteed to be unique.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the plant is not finalized</strong><strong> or </strong><strong>if the</strong> – </p></li>
<li><p><strong>model_instance` is invalid</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetBodiesKinematicallyAffectedBy">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].GetBodiesKinematicallyAffectedBy"></span><span class="sig-name descname"><span class="pre">GetBodiesKinematicallyAffectedBy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">joint_indexes</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JointIndex" title="pydrake.multibody.tree.JointIndex"><span class="pre">pydrake.multibody.tree.JointIndex</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.BodyIndex" title="pydrake.multibody.tree.BodyIndex"><span class="pre">pydrake.multibody.tree.BodyIndex</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetBodiesKinematicallyAffectedBy" title="Permalink to this definition"></a></dt>
<dd><p>Returns all bodies whose kinematics are transitively affected by the
given vector of joints. The affected bodies are returned in increasing
order of body indexes. Note that this is a kinematic relationship
rather than a dynamic one. For example, if one of the inboard joints
is a free (6dof) joint, the kinematic influence is still felt even
though dynamically there would be no influence on the outboard body.
This function can be only be called post-finalize, see Finalize().</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if any of the given joint has an invalid index</strong><strong>,</strong> – </p></li>
<li><p><strong>doesn't correspond to a mobilizer</strong><strong>, or </strong><strong>is welded.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetBodiesWeldedTo">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].GetBodiesWeldedTo"></span><span class="sig-name descname"><span class="pre">GetBodiesWeldedTo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody_" title="pydrake.multibody.tree.RigidBody_"><span class="pre">pydrake.multibody.tree.RigidBody_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody_" title="pydrake.multibody.tree.RigidBody_"><span class="pre">pydrake.multibody.tree.RigidBody_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetBodiesWeldedTo" title="Permalink to this definition"></a></dt>
<dd><p>Returns all bodies that are transitively welded, or rigidly affixed,
to <code class="docutils literal notranslate"><span class="pre">body</span></code>, per these two definitions:</p>
<ol class="arabic simple">
<li><p>A body is always considered welded to itself.</p></li>
</ol>
<p>2. Two unique bodies are considered welded together exclusively by the
presence of a weld joint, not by other constructs that prevent mobility
(e.g. constraints).</p>
<p>This method can be called at any time during the lifetime of <code class="docutils literal notranslate"><span class="pre">this</span></code>
plant, either pre- or post-finalize, see Finalize().</p>
<p>Meant to be used with <code class="docutils literal notranslate"><span class="pre">CollectRegisteredGeometries</span></code>.</p>
<p>The following example demonstrates filtering collisions between all
bodies rigidly affixed to a door (which could be moving) and all
bodies rigidly affixed to the world:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">GeometrySet</span><span class="w"> </span><span class="n">g_world</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">plant</span><span class="p">.</span><span class="n">CollectRegisteredGeometries</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">plant</span><span class="p">.</span><span class="n">GetBodiesWeldedTo</span><span class="p">(</span><span class="n">plant</span><span class="p">.</span><span class="n">world_body</span><span class="p">()));</span><span class="w"></span>
<span class="n">GeometrySet</span><span class="w"> </span><span class="n">g_door</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">plant</span><span class="p">.</span><span class="n">CollectRegisteredGeometries</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">plant</span><span class="p">.</span><span class="n">GetBodiesWeldedTo</span><span class="p">(</span><span class="n">plant</span><span class="p">.</span><span class="n">GetBodyByName</span><span class="p">(</span><span class="s">&quot;door&quot;</span><span class="p">)));</span><span class="w"></span>
<span class="n">scene_graph</span><span class="p">.</span><span class="n">ExcludeCollisionsBetweeen</span><span class="p">(</span><span class="n">g_world</span><span class="p">,</span><span class="w"> </span><span class="n">g_door</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</details><div class="admonition note">
<p class="admonition-title">Note</p>
<p>Usages akin to this example may introduce redundant collision
filtering; this will not have a functional impact, but may have a
minor performance impact.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>all bodies rigidly fixed to <code class="docutils literal notranslate"><span class="pre">body</span></code>. This does not return the
bodies in any prescribed order.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>RuntimeError if body is not part of this plant.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetBodyByName">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].GetBodyByName"></span><span class="sig-name descname"><span class="pre">GetBodyByName</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetBodyByName" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetBodyByName(self: pydrake.multibody.plant.MultibodyPlant_[Expression], name: str) -&gt; pydrake.multibody.tree.RigidBody_[Expression]</p></li>
</ol>
<p>Returns a constant reference to a body that is identified by the
string <code class="docutils literal notranslate"><span class="pre">name</span></code> in <code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if there is no body with the requested name.</strong> – </p></li>
<li><p><strong>RuntimeError if the body name occurs in multiple model instances.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>HasBodyNamed() to query if there exists a body in <code class="docutils literal notranslate"><span class="pre">this</span></code>
MultibodyPlant with a given specified name.</p>
</div>
<ol class="arabic simple" start="2">
<li><p>GetBodyByName(self: pydrake.multibody.plant.MultibodyPlant_[Expression], name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; pydrake.multibody.tree.RigidBody_[Expression]</p></li>
</ol>
<p>Returns a constant reference to the body that is uniquely identified
by the string <code class="docutils literal notranslate"><span class="pre">name</span></code> and <code class="docutils literal notranslate"><span class="pre">model_instance</span></code> in <code class="docutils literal notranslate"><span class="pre">this</span></code>
MultibodyPlant.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if there is no body with the requested name.</strong> – </p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>HasBodyNamed() to query if there exists a body in <code class="docutils literal notranslate"><span class="pre">this</span></code>
MultibodyPlant with a given specified name.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetBodyFrameIdIfExists">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].GetBodyFrameIdIfExists"></span><span class="sig-name descname"><span class="pre">GetBodyFrameIdIfExists</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.BodyIndex" title="pydrake.multibody.tree.BodyIndex"><span class="pre">pydrake.multibody.tree.BodyIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.FrameId" title="pydrake.geometry.FrameId"><span class="pre">pydrake.geometry.FrameId</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetBodyFrameIdIfExists" title="Permalink to this definition"></a></dt>
<dd><p>If the body with <code class="docutils literal notranslate"><span class="pre">body_index</span></code> belongs to the called plant, it
returns the geometry::FrameId associated with it. Otherwise, it
returns nullopt.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetBodyFrameIdOrThrow">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].GetBodyFrameIdOrThrow"></span><span class="sig-name descname"><span class="pre">GetBodyFrameIdOrThrow</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.BodyIndex" title="pydrake.multibody.tree.BodyIndex"><span class="pre">pydrake.multibody.tree.BodyIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.FrameId" title="pydrake.geometry.FrameId"><span class="pre">pydrake.geometry.FrameId</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetBodyFrameIdOrThrow" title="Permalink to this definition"></a></dt>
<dd><p>If the body with <code class="docutils literal notranslate"><span class="pre">body_index</span></code> belongs to the called plant, it
returns the geometry::FrameId associated with it. Otherwise this
method throws an exception.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the called plant does not have the body indicated</strong> – </p></li>
<li><p><strong>by body_index.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetBodyFromFrameId">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].GetBodyFromFrameId"></span><span class="sig-name descname"><span class="pre">GetBodyFromFrameId</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.FrameId" title="pydrake.geometry.FrameId"><span class="pre">pydrake.geometry.FrameId</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody_" title="pydrake.multibody.tree.RigidBody_"><span class="pre">pydrake.multibody.tree.RigidBody_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetBodyFromFrameId" title="Permalink to this definition"></a></dt>
<dd><p>Given a geometry frame identifier, returns a pointer to the body
associated with that id (nullptr if there is no such body).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetBodyIndices">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].GetBodyIndices"></span><span class="sig-name descname"><span class="pre">GetBodyIndices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.BodyIndex" title="pydrake.multibody.tree.BodyIndex"><span class="pre">pydrake.multibody.tree.BodyIndex</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetBodyIndices" title="Permalink to this definition"></a></dt>
<dd><p>Returns a list of body indices associated with <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetCollisionGeometriesForBody">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].GetCollisionGeometriesForBody"></span><span class="sig-name descname"><span class="pre">GetCollisionGeometriesForBody</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody_" title="pydrake.multibody.tree.RigidBody_"><span class="pre">pydrake.multibody.tree.RigidBody_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.GeometryId" title="pydrake.geometry.GeometryId"><span class="pre">pydrake.geometry.GeometryId</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetCollisionGeometriesForBody" title="Permalink to this definition"></a></dt>
<dd><p>Returns an array of GeometryId’s identifying the different contact
geometries for <code class="docutils literal notranslate"><span class="pre">body</span></code> previously registered with a SceneGraph.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method can be called at any time during the lifetime of
<code class="docutils literal notranslate"><span class="pre">this</span></code> plant, either pre- or post-finalize, see Finalize().
Post-finalize calls will always return the same value.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>RegisterCollisionGeometry(), Finalize()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetConstraintActiveStatus">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].GetConstraintActiveStatus"></span><span class="sig-name descname"><span class="pre">GetConstraintActiveStatus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">id</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.MultibodyConstraintId" title="pydrake.multibody.tree.MultibodyConstraintId"><span class="pre">pydrake.multibody.tree.MultibodyConstraintId</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetConstraintActiveStatus" title="Permalink to this definition"></a></dt>
<dd><p>Returns the active status of the constraint given by <code class="docutils literal notranslate"><span class="pre">id</span></code> in
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the MultibodyPlant has not been finalized.</strong> – </p></li>
<li><p><strong>RuntimeError if id does not belong to any multibody constraint</strong> – </p></li>
<li><p><strong>in context.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetDefaultContactSurfaceRepresentation">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].GetDefaultContactSurfaceRepresentation"></span><em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">GetDefaultContactSurfaceRepresentation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">time_step</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.HydroelasticContactRepresentation" title="pydrake.geometry.HydroelasticContactRepresentation"><span class="pre">pydrake.geometry.HydroelasticContactRepresentation</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetDefaultContactSurfaceRepresentation" title="Permalink to this definition"></a></dt>
<dd><p>Return the default value for contact representation, given the desired
time step. Discrete systems default to use polygons; continuous
systems default to use triangles.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetDefaultFreeBodyPose">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].GetDefaultFreeBodyPose"></span><span class="sig-name descname"><span class="pre">GetDefaultFreeBodyPose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody_" title="pydrake.multibody.tree.RigidBody_"><span class="pre">pydrake.multibody.tree.RigidBody_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.math.html#pydrake.math.RigidTransform" title="pydrake.math.RigidTransform"><span class="pre">pydrake.math.RigidTransform</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetDefaultFreeBodyPose" title="Permalink to this definition"></a></dt>
<dd><p>Gets the default pose of <code class="docutils literal notranslate"><span class="pre">body</span></code> as set by SetDefaultFreeBodyPose().
If no pose is specified for the body, returns the identity pose.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body</span></code>:</dt><dd><p>RigidBody whose default pose will be retrieved.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetDefaultPositions">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].GetDefaultPositions"></span><span class="sig-name descname"><span class="pre">GetDefaultPositions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetDefaultPositions" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetDefaultPositions(self: pydrake.multibody.plant.MultibodyPlant_[Expression]) -&gt; numpy.ndarray[object[m, 1]]</p></li>
</ol>
<p>Gets the default positions for the plant, which can be changed via
SetDefaultPositions().</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if the plant is not finalized.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>GetDefaultPositions(self: pydrake.multibody.plant.MultibodyPlant_[Expression], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; numpy.ndarray[object[m, 1]]</p></li>
</ol>
<p>Gets the default positions for the plant for a given model instance,
which can be changed via SetDefaultPositions().</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the plant is not finalized</strong><strong>, or </strong><strong>if the</strong> – </p></li>
<li><p><strong>model_instance is invalid</strong><strong>,</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetEffortLowerLimits">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].GetEffortLowerLimits"></span><span class="sig-name descname"><span class="pre">GetEffortLowerLimits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetEffortLowerLimits" title="Permalink to this definition"></a></dt>
<dd><p>Returns a vector of size <code class="docutils literal notranslate"><span class="pre">num_actuated_dofs()</span></code> containing the lower
effort limits for every actuator. Any unbounded or unspecified limits
will be -∞. The returned vector is indexed by JointActuatorIndex, see
JointActuator::index().</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>GetEffortUpperLimits()</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetEffortUpperLimits">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].GetEffortUpperLimits"></span><span class="sig-name descname"><span class="pre">GetEffortUpperLimits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetEffortUpperLimits" title="Permalink to this definition"></a></dt>
<dd><p>Returns a vector of size <code class="docutils literal notranslate"><span class="pre">num_actuated_dofs()</span></code> containing the upper
effort limits for every actuator. Any unbounded or unspecified limits
will be +∞. The returned vector is indexed by JointActuatorIndex, see
JointActuator::index().</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>GetEffortLowerLimits()</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetFloatingBaseBodies">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].GetFloatingBaseBodies"></span><span class="sig-name descname"><span class="pre">GetFloatingBaseBodies</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Set</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.BodyIndex" title="pydrake.multibody.tree.BodyIndex"><span class="pre">pydrake.multibody.tree.BodyIndex</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetFloatingBaseBodies" title="Permalink to this definition"></a></dt>
<dd><p>Returns the set of body indexes corresponding to the free (floating)
bodies in the model, in no particular order.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize</strong><strong>, </strong><strong>see Finalize</strong><strong>(</strong><strong>)</strong><strong></strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetFrameByName">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].GetFrameByName"></span><span class="sig-name descname"><span class="pre">GetFrameByName</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetFrameByName" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetFrameByName(self: pydrake.multibody.plant.MultibodyPlant_[Expression], name: str) -&gt; pydrake.multibody.tree.Frame_[Expression]</p></li>
</ol>
<p>Returns a constant reference to a frame that is identified by the
string <code class="docutils literal notranslate"><span class="pre">name</span></code> in <code class="docutils literal notranslate"><span class="pre">this</span></code> model.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if there is no frame with the requested name.</strong> – </p></li>
<li><p><strong>RuntimeError if the frame name occurs in multiple model instances.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>HasFrameNamed() to query if there exists a frame in <code class="docutils literal notranslate"><span class="pre">this</span></code> model
with a given specified name.</p>
</div>
<ol class="arabic simple" start="2">
<li><p>GetFrameByName(self: pydrake.multibody.plant.MultibodyPlant_[Expression], name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; pydrake.multibody.tree.Frame_[Expression]</p></li>
</ol>
<p>Returns a constant reference to the frame that is uniquely identified
by the string <code class="docutils literal notranslate"><span class="pre">name</span></code> in <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if there is no frame with the requested name.</strong> – </p></li>
<li><p><strong>RuntimeError if model_instance is not valid for this model.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>HasFrameNamed() to query if there exists a frame in <code class="docutils literal notranslate"><span class="pre">this</span></code> model
with a given specified name.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetFrameIndices">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].GetFrameIndices"></span><span class="sig-name descname"><span class="pre">GetFrameIndices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.FrameIndex" title="pydrake.multibody.tree.FrameIndex"><span class="pre">pydrake.multibody.tree.FrameIndex</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetFrameIndices" title="Permalink to this definition"></a></dt>
<dd><p>Returns a list of frame indices associated with <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetFreeBodyPose">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].GetFreeBodyPose"></span><span class="sig-name descname"><span class="pre">GetFreeBodyPose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody_" title="pydrake.multibody.tree.RigidBody_"><span class="pre">pydrake.multibody.tree.RigidBody_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.math.html#pydrake.math.RigidTransform_" title="pydrake.math.RigidTransform_"><span class="pre">pydrake.math.RigidTransform_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetFreeBodyPose" title="Permalink to this definition"></a></dt>
<dd><p>Gets the pose of a given <code class="docutils literal notranslate"><span class="pre">body</span></code> in the world frame W.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In general getting the pose of a body in the model would involve
solving the kinematics. This method allows us to simplify this
process when we know the body is free in space.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if body is not a free body in the model.</strong> – </p></li>
<li><p><strong>RuntimeError if called pre-finalize.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetJointActuatorByName">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].GetJointActuatorByName"></span><span class="sig-name descname"><span class="pre">GetJointActuatorByName</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetJointActuatorByName" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetJointActuatorByName(self: pydrake.multibody.plant.MultibodyPlant_[Expression], name: str) -&gt; pydrake.multibody.tree.JointActuator_[Expression]</p></li>
</ol>
<p>Returns a constant reference to an actuator that is identified by the
string <code class="docutils literal notranslate"><span class="pre">name</span></code> in <code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if there is no actuator with the requested name.</strong> – </p></li>
<li><p><strong>RuntimeError if the actuator name occurs in multiple model</strong> – </p></li>
<li><p><strong>instances.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>HasJointActuatorNamed() to query if there exists an actuator in
<code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant with a given specified name.</p>
</div>
<ol class="arabic simple" start="2">
<li><p>GetJointActuatorByName(self: pydrake.multibody.plant.MultibodyPlant_[Expression], name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; pydrake.multibody.tree.JointActuator_[Expression]</p></li>
</ol>
<p>Returns a constant reference to the actuator that is uniquely
identified by the string <code class="docutils literal notranslate"><span class="pre">name</span></code> and <code class="docutils literal notranslate"><span class="pre">model_instance</span></code> in <code class="docutils literal notranslate"><span class="pre">this</span></code>
MultibodyPlant.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if there is no actuator with the requested name.</strong> – </p></li>
<li><p><strong>RuntimeError if model_instance is not valid for this model.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>HasJointActuatorNamed() to query if there exists an actuator in
<code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant with a given specified name.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetJointActuatorIndices">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].GetJointActuatorIndices"></span><span class="sig-name descname"><span class="pre">GetJointActuatorIndices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetJointActuatorIndices" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetJointActuatorIndices(self: pydrake.multibody.plant.MultibodyPlant_[Expression]) -&gt; List[pydrake.multibody.tree.JointActuatorIndex]</p></li>
</ol>
<p>Returns a list of all joint actuator indices. The vector is ordered by
monotonically increasing JointActuatorIndex, but the indexes will in
general not be consecutive due to actuators that were removed.</p>
<ol class="arabic simple" start="2">
<li><p>GetJointActuatorIndices(self: pydrake.multibody.plant.MultibodyPlant_[Expression], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; List[pydrake.multibody.tree.JointActuatorIndex]</p></li>
</ol>
<p>Returns a list of joint actuator indices associated with
<code class="docutils literal notranslate"><span class="pre">model_instance</span></code>. The vector is ordered by monotonically increasing
JointActuatorIndex.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetJointByName">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].GetJointByName"></span><span class="sig-name descname"><span class="pre">GetJointByName</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Joint_" title="pydrake.multibody.tree.Joint_"><span class="pre">pydrake.multibody.tree.Joint_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetJointByName" title="Permalink to this definition"></a></dt>
<dd><p>Returns a constant reference to a joint that is identified by the
string <code class="docutils literal notranslate"><span class="pre">name</span></code> in <code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant. If the optional template
argument is supplied, then the returned value is downcast to the
specified <code class="docutils literal notranslate"><span class="pre">JointType</span></code>.</p>
<dl class="simple">
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">JointType</span></code>:</dt><dd><p>The specific type of the Joint to be retrieved. It must be a
subclass of Joint.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the named joint is not of type JointType</strong><strong> or </strong><strong>if</strong> – </p></li>
<li><p><strong>there is no Joint with that name.</strong> – </p></li>
<li><p><strong>RuntimeError if model_instance is not valid for this model.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>HasJointNamed() to query if there exists a joint in <code class="docutils literal notranslate"><span class="pre">this</span></code>
MultibodyPlant with a given specified name.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetJointIndices">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].GetJointIndices"></span><span class="sig-name descname"><span class="pre">GetJointIndices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetJointIndices" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetJointIndices(self: pydrake.multibody.plant.MultibodyPlant_[Expression]) -&gt; List[pydrake.multibody.tree.JointIndex]</p></li>
</ol>
<p>Returns a list of all joint indices. The vector is ordered by
monotonically increasing JointIndex, but the indexes will in general
not be consecutive due to joints that were removed.</p>
<ol class="arabic simple" start="2">
<li><p>GetJointIndices(self: pydrake.multibody.plant.MultibodyPlant_[Expression], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; List[pydrake.multibody.tree.JointIndex]</p></li>
</ol>
<p>Returns a list of joint indices associated with <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetModelInstanceByName">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].GetModelInstanceByName"></span><span class="sig-name descname"><span class="pre">GetModelInstanceByName</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetModelInstanceByName" title="Permalink to this definition"></a></dt>
<dd><p>Returns the index to the model instance that is uniquely identified by
the string <code class="docutils literal notranslate"><span class="pre">name</span></code> in <code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if there is no instance with the requested name.</strong> – </p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>HasModelInstanceNamed() to query if there exists an instance in
<code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant with a given specified name.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetModelInstanceName">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].GetModelInstanceName"></span><span class="sig-name descname"><span class="pre">GetModelInstanceName</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">str</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetModelInstanceName" title="Permalink to this definition"></a></dt>
<dd><p>Returns the name of a <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError when model_instance does not correspond to a</strong> – </p></li>
<li><p><strong>model in this model.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetMutableJointByName">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].GetMutableJointByName"></span><span class="sig-name descname"><span class="pre">GetMutableJointByName</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Joint_" title="pydrake.multibody.tree.Joint_"><span class="pre">pydrake.multibody.tree.Joint_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetMutableJointByName" title="Permalink to this definition"></a></dt>
<dd><p>Returns a constant reference to a joint that is identified by the
string <code class="docutils literal notranslate"><span class="pre">name</span></code> in <code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant. If the optional template
argument is supplied, then the returned value is downcast to the
specified <code class="docutils literal notranslate"><span class="pre">JointType</span></code>.</p>
<dl class="simple">
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">JointType</span></code>:</dt><dd><p>The specific type of the Joint to be retrieved. It must be a
subclass of Joint.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the named joint is not of type JointType</strong><strong> or </strong><strong>if</strong> – </p></li>
<li><p><strong>there is no Joint with that name.</strong> – </p></li>
<li><p><strong>RuntimeError if model_instance is not valid for this model.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>HasJointNamed() to query if there exists a joint in <code class="docutils literal notranslate"><span class="pre">this</span></code>
MultibodyPlant with a given specified name.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetPositionLowerLimits">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].GetPositionLowerLimits"></span><span class="sig-name descname"><span class="pre">GetPositionLowerLimits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetPositionLowerLimits" title="Permalink to this definition"></a></dt>
<dd><p>Returns a vector of size <code class="docutils literal notranslate"><span class="pre">num_positions()</span></code> containing the lower
position limits for every generalized position coordinate. These
include joint and free body coordinates. Any unbounded or unspecified
limits will be -infinity.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetPositionNames">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].GetPositionNames"></span><span class="sig-name descname"><span class="pre">GetPositionNames</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetPositionNames" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetPositionNames(self: pydrake.multibody.plant.MultibodyPlant_[Expression], add_model_instance_prefix: bool = True, always_add_suffix: bool = True) -&gt; List[str]</p></li>
</ol>
<p>Returns a list of string names corresponding to each element of the
position vector. These strings take the form
<code class="docutils literal notranslate"><span class="pre">{model_instance_name}_{joint_name}_{joint_position_suffix}</span></code>, but
the prefix and suffix may optionally be withheld using
<code class="docutils literal notranslate"><span class="pre">add_model_instance_prefix</span></code> and <code class="docutils literal notranslate"><span class="pre">always_add_suffix</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">always_add_suffix</span></code>:</dt><dd><p>(optional). If true, then the suffix is always added. If false,
then the suffix is only added for joints that have more than one
position (in this case, not adding would lead to ambiguity).</p>
</dd>
</dl>
<p>The returned names are guaranteed to be unique if
<code class="docutils literal notranslate"><span class="pre">add_model_instance_prefix</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code> (the default).</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if the plant is not finalized.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>GetPositionNames(self: pydrake.multibody.plant.MultibodyPlant_[Expression], model_instance: pydrake.multibody.tree.ModelInstanceIndex, add_model_instance_prefix: bool = False, always_add_suffix: bool = True) -&gt; List[str]</p></li>
</ol>
<p>Returns a list of string names corresponding to each element of the
position vector. These strings take the form
<code class="docutils literal notranslate"><span class="pre">{model_instance_name}_{joint_name}_{joint_position_suffix}</span></code>, but
the prefix and suffix may optionally be withheld using
<code class="docutils literal notranslate"><span class="pre">add_model_instance_prefix</span></code> and <code class="docutils literal notranslate"><span class="pre">always_add_suffix</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">always_add_suffix</span></code>:</dt><dd><p>(optional). If true, then the suffix is always added. If false,
then the suffix is only added for joints that have more than one
position (in this case, not adding would lead to ambiguity).</p>
</dd>
</dl>
<p>The returned names are guaranteed to be unique.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the plant is not finalized</strong><strong> or </strong><strong>if the</strong> – </p></li>
<li><p><strong>model_instance` is invalid</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetPositions">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].GetPositions"></span><span class="sig-name descname"><span class="pre">GetPositions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetPositions" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetPositions(self: pydrake.multibody.plant.MultibodyPlant_[Expression], context: pydrake.systems.framework.Context_[Expression]) -&gt; numpy.ndarray[object[m, 1]]</p></li>
</ol>
<p>Returns a const vector reference to the vector of generalized
positions q in a given Context.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method returns a reference to existing data, exhibits
constant i.e., O(1) time complexity, and runs very quickly.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if context does not correspond to the Context for</strong> – </p></li>
<li><p><strong>a multibody model.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>GetPositions(self: pydrake.multibody.plant.MultibodyPlant_[Expression], context: pydrake.systems.framework.Context_[Expression], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; numpy.ndarray[object[m, 1]]</p></li>
</ol>
<p>Returns a vector containing the generalized positions q of a specified
model instance in a given Context.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Returns a dense vector of dimension
<code class="docutils literal notranslate"><span class="pre">num_positions(model_instance)</span></code> associated with
<code class="docutils literal notranslate"><span class="pre">model_instance</span></code> by copying from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if context does not correspond to the Context for</strong> – </p></li>
<li><p><strong>a multibody model</strong><strong> or </strong><strong>model_instance is invalid.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li><p>GetPositions(self: pydrake.multibody.plant.MultibodyPlant_[Expression], context: pydrake.systems.framework.Context_[Expression]) -&gt; numpy.ndarray[object[m, 1]]</p></li>
</ol>
<p>Returns a const vector reference to the vector of generalized
positions q in a given Context.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method returns a reference to existing data, exhibits
constant i.e., O(1) time complexity, and runs very quickly.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if context does not correspond to the Context for</strong> – </p></li>
<li><p><strong>a multibody model.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="4">
<li><p>GetPositions(self: pydrake.multibody.plant.MultibodyPlant_[Expression], context: pydrake.systems.framework.Context_[Expression], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; numpy.ndarray[object[m, 1]]</p></li>
</ol>
<p>Returns a vector containing the generalized positions q of a specified
model instance in a given Context.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Returns a dense vector of dimension
<code class="docutils literal notranslate"><span class="pre">num_positions(model_instance)</span></code> associated with
<code class="docutils literal notranslate"><span class="pre">model_instance</span></code> by copying from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if context does not correspond to the Context for</strong> – </p></li>
<li><p><strong>a multibody model</strong><strong> or </strong><strong>model_instance is invalid.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetPositionsAndVelocities">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].GetPositionsAndVelocities"></span><span class="sig-name descname"><span class="pre">GetPositionsAndVelocities</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetPositionsAndVelocities" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetPositionsAndVelocities(self: pydrake.multibody.plant.MultibodyPlant_[Expression], context: pydrake.systems.framework.Context_[Expression]) -&gt; numpy.ndarray[object[m, 1]]</p></li>
</ol>
<p>Returns a const vector reference <code class="docutils literal notranslate"><span class="pre">[q;</span> <span class="pre">v]</span></code> to the generalized
positions q and generalized velocities v in a given Context.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method returns a reference to existing data, exhibits
constant i.e., O(1) time complexity, and runs very quickly.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if context does not correspond to the Context for</strong> – </p></li>
<li><p><strong>a multibody model.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>GetPositionsAndVelocities(self: pydrake.multibody.plant.MultibodyPlant_[Expression], context: pydrake.systems.framework.Context_[Expression], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; numpy.ndarray[object[m, 1]]</p></li>
</ol>
<p>Returns a vector <code class="docutils literal notranslate"><span class="pre">[q;</span> <span class="pre">v]</span></code> containing the generalized positions q and
generalized velocities v of a specified model instance in a given
Context.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Returns a dense vector of dimension
<code class="docutils literal notranslate"><span class="pre">num_positions(model_instance)</span> <span class="pre">+</span> <span class="pre">num_velocities(model_instance)</span></code>
associated with <code class="docutils literal notranslate"><span class="pre">model_instance</span></code> by copying from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if context does not correspond to the Context for</strong> – </p></li>
<li><p><strong>a multibody model</strong><strong> or </strong><strong>model_instance is invalid.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetPositionsFromArray">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].GetPositionsFromArray"></span><span class="sig-name descname"><span class="pre">GetPositionsFromArray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetPositionsFromArray" title="Permalink to this definition"></a></dt>
<dd><p>Returns a vector of generalized positions for <code class="docutils literal notranslate"><span class="pre">model_instance</span></code> from
a vector <code class="docutils literal notranslate"><span class="pre">q_array</span></code> of generalized positions for the entire model
model. This method throws an exception if <code class="docutils literal notranslate"><span class="pre">q</span></code> is not of size
MultibodyPlant::num_positions().</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetPositionUpperLimits">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].GetPositionUpperLimits"></span><span class="sig-name descname"><span class="pre">GetPositionUpperLimits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetPositionUpperLimits" title="Permalink to this definition"></a></dt>
<dd><p>Upper limit analog of GetPositionLowerLimits(), where any unbounded or
unspecified limits will be +infinity.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>GetPositionLowerLimits() for more information.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetRigidBodyByName">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].GetRigidBodyByName"></span><span class="sig-name descname"><span class="pre">GetRigidBodyByName</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetRigidBodyByName" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetRigidBodyByName(self: pydrake.multibody.plant.MultibodyPlant_[Expression], name: str) -&gt; pydrake.multibody.tree.RigidBody_[Expression]</p></li>
</ol>
<p>Returns a constant reference to a rigid body that is identified by the
string <code class="docutils literal notranslate"><span class="pre">name</span></code> in <code class="docutils literal notranslate"><span class="pre">this</span></code> model.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if there is no body with the requested name.</strong> – </p></li>
<li><p><strong>RuntimeError if the body name occurs in multiple model instances.</strong> – </p></li>
<li><p><strong>RuntimeError if the requested body is not a RigidBody.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>HasBodyNamed() to query if there exists a body in <code class="docutils literal notranslate"><span class="pre">this</span></code> model
with a given specified name.</p>
</div>
<ol class="arabic simple" start="2">
<li><p>GetRigidBodyByName(self: pydrake.multibody.plant.MultibodyPlant_[Expression], name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; pydrake.multibody.tree.RigidBody_[Expression]</p></li>
</ol>
<p>Returns a constant reference to the rigid body that is uniquely
identified by the string <code class="docutils literal notranslate"><span class="pre">name</span></code> in <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if there is no body with the requested name.</strong> – </p></li>
<li><p><strong>RuntimeError if the requested body is not a RigidBody.</strong> – </p></li>
<li><p><strong>RuntimeError if model_instance is not valid for this model.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>HasBodyNamed() to query if there exists a body in <code class="docutils literal notranslate"><span class="pre">this</span></code> model
with a given specified name.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetStateNames">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].GetStateNames"></span><span class="sig-name descname"><span class="pre">GetStateNames</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetStateNames" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetStateNames(self: pydrake.multibody.plant.MultibodyPlant_[Expression], add_model_instance_prefix: bool = True) -&gt; List[str]</p></li>
</ol>
<p>Returns a list of string names corresponding to each element of the
multibody state vector. These strings take the form
<code class="docutils literal notranslate"><span class="pre">{model_instance_name}_{joint_name}_{joint_position_suffix</span> <span class="pre">|</span>
<span class="pre">joint_velocity_suffix}</span></code>, but the prefix may optionally be withheld
using <code class="docutils literal notranslate"><span class="pre">add_model_instance_prefix</span></code>.</p>
<p>The returned names are guaranteed to be unique if
<code class="docutils literal notranslate"><span class="pre">add_model_instance_prefix</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code> (the default).</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if the plant is not finalized.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>GetStateNames(self: pydrake.multibody.plant.MultibodyPlant_[Expression], model_instance: pydrake.multibody.tree.ModelInstanceIndex, add_model_instance_prefix: bool = False) -&gt; List[str]</p></li>
</ol>
<p>Returns a list of string names corresponding to each element of the
multibody state vector. These strings take the form
<code class="docutils literal notranslate"><span class="pre">{model_instance_name}_{joint_name}_{joint_position_suffix</span> <span class="pre">|</span>
<span class="pre">joint_velocity_suffix}</span></code>, but the prefix may optionally be withheld
using <code class="docutils literal notranslate"><span class="pre">add_model_instance_prefix</span></code>.</p>
<p>The returned names are guaranteed to be unique.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the plant is not finalized</strong><strong> or </strong><strong>if the</strong> – </p></li>
<li><p><strong>model_instance` is invalid</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetTopologyGraphvizString">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].GetTopologyGraphvizString"></span><span class="sig-name descname"><span class="pre">GetTopologyGraphvizString</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">str</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetTopologyGraphvizString" title="Permalink to this definition"></a></dt>
<dd><p>Returns a Graphviz string describing the topology of this plant. To
render the string, use the Graphviz tool, <code class="docutils literal notranslate"><span class="pre">dot</span></code>.
<a class="reference external" href="http://www.graphviz.org/">http://www.graphviz.org/</a></p>
<p>Note: this method can be called either before or after <code class="docutils literal notranslate"><span class="pre">Finalize()</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetUniqueFreeBaseBodyOrThrow">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].GetUniqueFreeBaseBodyOrThrow"></span><span class="sig-name descname"><span class="pre">GetUniqueFreeBaseBodyOrThrow</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody_" title="pydrake.multibody.tree.RigidBody_"><span class="pre">pydrake.multibody.tree.RigidBody_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetUniqueFreeBaseBodyOrThrow" title="Permalink to this definition"></a></dt>
<dd><p>If there exists a unique base body that belongs to the model given by
<code class="docutils literal notranslate"><span class="pre">model_instance</span></code> and that unique base body is free (see
HasUniqueBaseBody()), return that free body. Throw an exception
otherwise.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if called pre-finalize.</strong> – </p></li>
<li><p><strong>RuntimeError if model_instance is not valid.</strong> – </p></li>
<li><p><strong>RuntimeError if HasUniqueFreeBaseBody</strong><strong>(</strong><strong>model_instance</strong><strong>) </strong><strong>== false.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetVelocities">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].GetVelocities"></span><span class="sig-name descname"><span class="pre">GetVelocities</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetVelocities" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetVelocities(self: pydrake.multibody.plant.MultibodyPlant_[Expression], context: pydrake.systems.framework.Context_[Expression]) -&gt; numpy.ndarray[object[m, 1]]</p></li>
</ol>
<p>Returns a const vector reference to the generalized velocities v in a
given Context.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method returns a reference to existing data, exhibits
constant i.e., O(1) time complexity, and runs very quickly.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if context does not correspond to the Context for</strong> – </p></li>
<li><p><strong>a multibody model.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>GetVelocities(self: pydrake.multibody.plant.MultibodyPlant_[Expression], context: pydrake.systems.framework.Context_[Expression], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; numpy.ndarray[object[m, 1]]</p></li>
</ol>
<p>Returns a vector containing the generalized velocities v of a
specified model instance in a given Context.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>returns a dense vector of dimension
<code class="docutils literal notranslate"><span class="pre">num_velocities(model_instance)</span></code> associated with
<code class="docutils literal notranslate"><span class="pre">model_instance</span></code> by copying from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if context does not correspond to the Context for</strong> – </p></li>
<li><p><strong>a multibody model</strong><strong> or </strong><strong>model_instance is invalid.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li><p>GetVelocities(self: pydrake.multibody.plant.MultibodyPlant_[Expression], context: pydrake.systems.framework.Context_[Expression]) -&gt; numpy.ndarray[object[m, 1]]</p></li>
</ol>
<p>Returns a const vector reference to the generalized velocities v in a
given Context.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method returns a reference to existing data, exhibits
constant i.e., O(1) time complexity, and runs very quickly.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if context does not correspond to the Context for</strong> – </p></li>
<li><p><strong>a multibody model.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="4">
<li><p>GetVelocities(self: pydrake.multibody.plant.MultibodyPlant_[Expression], context: pydrake.systems.framework.Context_[Expression], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; numpy.ndarray[object[m, 1]]</p></li>
</ol>
<p>Returns a vector containing the generalized velocities v of a
specified model instance in a given Context.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>returns a dense vector of dimension
<code class="docutils literal notranslate"><span class="pre">num_velocities(model_instance)</span></code> associated with
<code class="docutils literal notranslate"><span class="pre">model_instance</span></code> by copying from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if context does not correspond to the Context for</strong> – </p></li>
<li><p><strong>a multibody model</strong><strong> or </strong><strong>model_instance is invalid.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetVelocitiesFromArray">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].GetVelocitiesFromArray"></span><span class="sig-name descname"><span class="pre">GetVelocitiesFromArray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetVelocitiesFromArray" title="Permalink to this definition"></a></dt>
<dd><p>Returns a vector of generalized velocities for <code class="docutils literal notranslate"><span class="pre">model_instance</span></code> from
a vector <code class="docutils literal notranslate"><span class="pre">v</span></code> of generalized velocities for the entire MultibodyPlant
model. This method throws an exception if the input array is not of
size MultibodyPlant::num_velocities().</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetVelocityLowerLimits">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].GetVelocityLowerLimits"></span><span class="sig-name descname"><span class="pre">GetVelocityLowerLimits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetVelocityLowerLimits" title="Permalink to this definition"></a></dt>
<dd><p>Returns a vector of size <code class="docutils literal notranslate"><span class="pre">num_velocities()</span></code> containing the lower
velocity limits for every generalized velocity coordinate. These
include joint and free body coordinates. Any unbounded or unspecified
limits will be -infinity.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetVelocityNames">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].GetVelocityNames"></span><span class="sig-name descname"><span class="pre">GetVelocityNames</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetVelocityNames" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetVelocityNames(self: pydrake.multibody.plant.MultibodyPlant_[Expression], add_model_instance_prefix: bool = True, always_add_suffix: bool = True) -&gt; List[str]</p></li>
</ol>
<p>Returns a list of string names corresponding to each element of the
velocity vector. These strings take the form
<code class="docutils literal notranslate"><span class="pre">{model_instance_name}_{joint_name}_{joint_velocity_suffix}</span></code>, but
the prefix and suffix may optionally be withheld using
<code class="docutils literal notranslate"><span class="pre">add_model_instance_prefix</span></code> and <code class="docutils literal notranslate"><span class="pre">always_add_suffix</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">always_add_suffix</span></code>:</dt><dd><p>(optional). If true, then the suffix is always added. If false,
then the suffix is only added for joints that have more than one
position (in this case, not adding would lead to ambiguity).</p>
</dd>
</dl>
<p>The returned names are guaranteed to be unique if
<code class="docutils literal notranslate"><span class="pre">add_model_instance_prefix</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code> (the default).</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if the plant is not finalized.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>GetVelocityNames(self: pydrake.multibody.plant.MultibodyPlant_[Expression], model_instance: pydrake.multibody.tree.ModelInstanceIndex, add_model_instance_prefix: bool = False, always_add_suffix: bool = True) -&gt; List[str]</p></li>
</ol>
<p>Returns a list of string names corresponding to each element of the
velocity vector. These strings take the form
<code class="docutils literal notranslate"><span class="pre">{model_instance_name}_{joint_name}_{joint_velocity_suffix}</span></code>, but
the prefix and suffix may optionally be withheld using
<code class="docutils literal notranslate"><span class="pre">add_model_instance_prefix</span></code> and <code class="docutils literal notranslate"><span class="pre">always_add_suffix</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">always_add_suffix</span></code>:</dt><dd><p>(optional). If true, then the suffix is always added. If false,
then the suffix is only added for joints that have more than one
position (in this case, not adding would lead to ambiguity).</p>
</dd>
</dl>
<p>The returned names are guaranteed to be unique.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the plant is not finalized</strong><strong> or </strong><strong>if the</strong> – </p></li>
<li><p><strong>model_instance` is invalid</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetVelocityUpperLimits">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].GetVelocityUpperLimits"></span><span class="sig-name descname"><span class="pre">GetVelocityUpperLimits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetVelocityUpperLimits" title="Permalink to this definition"></a></dt>
<dd><p>Upper limit analog of GetVelocitysLowerLimits(), where any unbounded
or unspecified limits will be +infinity.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>GetVelocityLowerLimits() for more information.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.GetVisualGeometriesForBody">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].GetVisualGeometriesForBody"></span><span class="sig-name descname"><span class="pre">GetVisualGeometriesForBody</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody_" title="pydrake.multibody.tree.RigidBody_"><span class="pre">pydrake.multibody.tree.RigidBody_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.GeometryId" title="pydrake.geometry.GeometryId"><span class="pre">pydrake.geometry.GeometryId</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.GetVisualGeometriesForBody" title="Permalink to this definition"></a></dt>
<dd><p>Returns an array of GeometryId’s identifying the different visual
geometries for <code class="docutils literal notranslate"><span class="pre">body</span></code> previously registered with a SceneGraph.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method can be called at any time during the lifetime of
<code class="docutils literal notranslate"><span class="pre">this</span></code> plant, either pre- or post-finalize, see Finalize().
Post-finalize calls will always return the same value.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>RegisterVisualGeometry(), Finalize()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.gravity_field">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].gravity_field"></span><span class="sig-name descname"><span class="pre">gravity_field</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.UniformGravityFieldElement_" title="pydrake.multibody.tree.UniformGravityFieldElement_"><span class="pre">pydrake.multibody.tree.UniformGravityFieldElement_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.gravity_field" title="Permalink to this definition"></a></dt>
<dd><p>An accessor to the current gravity field.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.has_joint">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].has_joint"></span><span class="sig-name descname"><span class="pre">has_joint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">joint_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JointIndex" title="pydrake.multibody.tree.JointIndex"><span class="pre">pydrake.multibody.tree.JointIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.has_joint" title="Permalink to this definition"></a></dt>
<dd><p>Returns true if plant has a joint with unique index <code class="docutils literal notranslate"><span class="pre">joint_index</span></code>.
The value could be false if the joint was removed using RemoveJoint().</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.has_joint_actuator">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].has_joint_actuator"></span><span class="sig-name descname"><span class="pre">has_joint_actuator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">actuator_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JointActuatorIndex" title="pydrake.multibody.tree.JointActuatorIndex"><span class="pre">pydrake.multibody.tree.JointActuatorIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.has_joint_actuator" title="Permalink to this definition"></a></dt>
<dd><p>Returns true if plant has a joint actuator with unique index
<code class="docutils literal notranslate"><span class="pre">actuator_index</span></code>. The value could be false if the actuator was
removed using RemoveJointActuator().</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.HasBodyNamed">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].HasBodyNamed"></span><span class="sig-name descname"><span class="pre">HasBodyNamed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.HasBodyNamed" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>HasBodyNamed(self: pydrake.multibody.plant.MultibodyPlant_[Expression], name: str) -&gt; bool</p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if a body named <code class="docutils literal notranslate"><span class="pre">name</span></code> was added to the MultibodyPlant.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddRigidBody().</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if the body name occurs in multiple model instances.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>HasBodyNamed(self: pydrake.multibody.plant.MultibodyPlant_[Expression], name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; bool</p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if a body named <code class="docutils literal notranslate"><span class="pre">name</span></code> was added to the MultibodyPlant
in <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddRigidBody().</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if model_instance is not valid for this model.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.HasFrameNamed">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].HasFrameNamed"></span><span class="sig-name descname"><span class="pre">HasFrameNamed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.HasFrameNamed" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>HasFrameNamed(self: pydrake.multibody.plant.MultibodyPlant_[Expression], name: str) -&gt; bool</p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if a frame named <code class="docutils literal notranslate"><span class="pre">name</span></code> was added to the model.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddFrame().</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if the frame name occurs in multiple model instances.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>HasFrameNamed(self: pydrake.multibody.plant.MultibodyPlant_[Expression], name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; bool</p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if a frame named <code class="docutils literal notranslate"><span class="pre">name</span></code> was added to
<code class="docutils literal notranslate"><span class="pre">model_instance</span></code>.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddFrame().</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if model_instance is not valid for this model.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.HasJointActuatorNamed">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].HasJointActuatorNamed"></span><span class="sig-name descname"><span class="pre">HasJointActuatorNamed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.HasJointActuatorNamed" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>HasJointActuatorNamed(self: pydrake.multibody.plant.MultibodyPlant_[Expression], name: str) -&gt; bool</p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if an actuator named <code class="docutils literal notranslate"><span class="pre">name</span></code> was added to this model.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddJointActuator().</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the actuator name occurs in multiple model</strong> – </p></li>
<li><p><strong>instances.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>HasJointActuatorNamed(self: pydrake.multibody.plant.MultibodyPlant_[Expression], name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; bool</p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if an actuator named <code class="docutils literal notranslate"><span class="pre">name</span></code> was added to
<code class="docutils literal notranslate"><span class="pre">model_instance</span></code>.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddJointActuator().</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if model_instance is not valid for this model.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.HasJointNamed">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].HasJointNamed"></span><span class="sig-name descname"><span class="pre">HasJointNamed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.HasJointNamed" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>HasJointNamed(self: pydrake.multibody.plant.MultibodyPlant_[Expression], name: str) -&gt; bool</p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if a joint named <code class="docutils literal notranslate"><span class="pre">name</span></code> was added to this model.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddJoint().</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if the joint name occurs in multiple model instances.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>HasJointNamed(self: pydrake.multibody.plant.MultibodyPlant_[Expression], name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; bool</p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if a joint named <code class="docutils literal notranslate"><span class="pre">name</span></code> was added to
<code class="docutils literal notranslate"><span class="pre">model_instance</span></code>.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddJoint().</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if model_instance is not valid for this model.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.HasModelInstanceNamed">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].HasModelInstanceNamed"></span><span class="sig-name descname"><span class="pre">HasModelInstanceNamed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.HasModelInstanceNamed" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if a model instance named <code class="docutils literal notranslate"><span class="pre">name</span></code> was added to this
model.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddModelInstance().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.HasUniqueFreeBaseBody">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].HasUniqueFreeBaseBody"></span><span class="sig-name descname"><span class="pre">HasUniqueFreeBaseBody</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.HasUniqueFreeBaseBody" title="Permalink to this definition"></a></dt>
<dd><p>Return true if there exists a unique base body in the model given by
<code class="docutils literal notranslate"><span class="pre">model_instance</span></code> and that unique base body is free.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if called pre-finalize.</strong> – </p></li>
<li><p><strong>RuntimeError if model_instance is not valid.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.is_finalized">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].is_finalized"></span><span class="sig-name descname"><span class="pre">is_finalized</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.is_finalized" title="Permalink to this definition"></a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if this MultibodyPlant was finalized with a call to
Finalize().</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>Finalize().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.is_gravity_enabled">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].is_gravity_enabled"></span><span class="sig-name descname"><span class="pre">is_gravity_enabled</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.is_gravity_enabled" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> iff gravity is enabled for <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>set_gravity_enabled().</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if the model instance is invalid.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.IsVelocityEqualToQDot">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].IsVelocityEqualToQDot"></span><span class="sig-name descname"><span class="pre">IsVelocityEqualToQDot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.IsVelocityEqualToQDot" title="Permalink to this definition"></a></dt>
<dd><p>Returns true iff the generalized velocity v is exactly the time
derivative q̇ of the generalized coordinates q. In this case
MapQDotToVelocity() and MapVelocityToQDot() implement the identity
map. This method is, in the worst case, O(n), where n is the number of
joints.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.MakeActuationMatrix">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].MakeActuationMatrix"></span><span class="sig-name descname"><span class="pre">MakeActuationMatrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.MakeActuationMatrix" title="Permalink to this definition"></a></dt>
<dd><p>This method creates an actuation matrix B mapping a vector of
actuation values u into generalized forces <code class="docutils literal notranslate"><span class="pre">tau_u</span> <span class="pre">=</span> <span class="pre">B</span> <span class="pre">*</span> <span class="pre">u</span></code>, where B
is a matrix of size <code class="docutils literal notranslate"><span class="pre">nv</span> <span class="pre">x</span> <span class="pre">nu</span></code> with <code class="docutils literal notranslate"><span class="pre">nu</span></code> equal to
num_actuated_dofs() and <code class="docutils literal notranslate"><span class="pre">nv</span></code> equal to num_velocities(). The vector u
of actuation values is of size num_actuated_dofs(). For a given
JointActuator, <code class="docutils literal notranslate"><span class="pre">u[JointActuator::input_start()]</span></code> stores the value
for the external actuation corresponding to that actuator. <code class="docutils literal notranslate"><span class="pre">tau_u</span></code>
on the other hand is indexed by generalized velocity indexes according
to <code class="docutils literal notranslate"><span class="pre">Joint::velocity_start()</span></code>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>B is a permutation matrix. While making a permutation has <code class="docutils literal notranslate"><span class="pre">O(n)</span></code>
complexity, making a full B matrix has <code class="docutils literal notranslate"><span class="pre">O(n²)</span></code> complexity. For
most applications this cost can be neglected but it could become
significant for very large systems.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.MakeActuationMatrixPseudoinverse">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].MakeActuationMatrixPseudoinverse"></span><span class="sig-name descname"><span class="pre">MakeActuationMatrixPseudoinverse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">scipy.sparse.csc_matrix</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.MakeActuationMatrixPseudoinverse" title="Permalink to this definition"></a></dt>
<dd><p>Creates the pseudoinverse of the actuation matrix B directly (without
requiring an explicit inverse calculation). See MakeActuationMatrix().</p>
<p>Notably, when B is full row rank (the system is fully actuated), then
the pseudoinverse is a true inverse.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.MakeActuatorSelectorMatrix">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].MakeActuatorSelectorMatrix"></span><span class="sig-name descname"><span class="pre">MakeActuatorSelectorMatrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.MakeActuatorSelectorMatrix" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>MakeActuatorSelectorMatrix(self: pydrake.multibody.plant.MultibodyPlant_[Expression], user_to_actuator_index_map: List[pydrake.multibody.tree.JointActuatorIndex]) -&gt; numpy.ndarray[numpy.float64[m, n]]</p></li>
</ol>
<p>This method allows user to map a vector <code class="docutils literal notranslate"><span class="pre">uₛ</span></code> containing the
actuation for a set of selected actuators into the vector u containing
the actuation values for <code class="docutils literal notranslate"><span class="pre">this</span></code> full model. The mapping, or
selection, is returned in the form of a selector matrix Su such that
<code class="docutils literal notranslate"><span class="pre">u</span> <span class="pre">=</span> <span class="pre">Su⋅uₛ</span></code>. The size nₛ of uₛ is always smaller or equal than the
size of the full vector of actuation values u. That is, a user might
be interested in only a given subset of actuators in the model.</p>
<p>This selection matrix is particularly useful when adding PID control
on a portion of the state, see systems::controllers::PidController.</p>
<p>A user specifies the preferred order in uₛ via
<code class="docutils literal notranslate"><span class="pre">user_to_actuator_index_map</span></code>. The actuation values in uₛ are a
concatenation of the values for each actuator in the order they appear
in <code class="docutils literal notranslate"><span class="pre">user_to_actuator_index_map</span></code>. The actuation value in the full
vector of actuation values <code class="docutils literal notranslate"><span class="pre">u</span></code> for a particular actuator can be
found at offset JointActuator::input_start().</p>
<ol class="arabic simple" start="2">
<li><p>MakeActuatorSelectorMatrix(self: pydrake.multibody.plant.MultibodyPlant_[Expression], user_to_joint_index_map: List[pydrake.multibody.tree.JointIndex]) -&gt; numpy.ndarray[numpy.float64[m, n]]</p></li>
</ol>
<p>Alternative signature to build an actuation selector matrix <code class="docutils literal notranslate"><span class="pre">Su</span></code>
such that <code class="docutils literal notranslate"><span class="pre">u</span> <span class="pre">=</span> <span class="pre">Su⋅uₛ</span></code>, where u is the vector of actuation values for
the full model (see get_actuation_input_port()) and uₛ is a vector of
actuation values for the actuators acting on the joints listed by
<code class="docutils literal notranslate"><span class="pre">user_to_joint_index_map</span></code>. It is assumed that all joints referenced
by <code class="docutils literal notranslate"><span class="pre">user_to_joint_index_map</span></code> are actuated. See
MakeActuatorSelectorMatrix(const std::vector&lt;JointActuatorIndex&gt;&amp;) for
details.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if any of the joints in user_to_joint_index_map</strong> – </p></li>
<li><p><strong>does not have an actuator.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.MakeStateSelectorMatrix">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].MakeStateSelectorMatrix"></span><span class="sig-name descname"><span class="pre">MakeStateSelectorMatrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">user_to_joint_index_map</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JointIndex" title="pydrake.multibody.tree.JointIndex"><span class="pre">pydrake.multibody.tree.JointIndex</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.MakeStateSelectorMatrix" title="Permalink to this definition"></a></dt>
<dd><p>This method allows users to map the state of <code class="docutils literal notranslate"><span class="pre">this</span></code> model, x, into a
vector of selected state xₛ with a given preferred ordering. The
mapping, or selection, is returned in the form of a selector matrix Sx
such that <code class="docutils literal notranslate"><span class="pre">xₛ</span> <span class="pre">=</span> <span class="pre">Sx⋅x</span></code>. The size nₛ of xₛ is always smaller or equal
than the size of the full state x. That is, a user might be interested
in only a given portion of the full state x.</p>
<p>This selection matrix is particularly useful when adding PID control
on a portion of the state, see systems::controllers::PidController.</p>
<p>A user specifies the preferred order in xₛ via
<code class="docutils literal notranslate"><span class="pre">user_to_joint_index_map</span></code>. The selected state is built such that
selected positions are followed by selected velocities, as in <code class="docutils literal notranslate"><span class="pre">xₛ</span> <span class="pre">=</span>
<span class="pre">[qₛ,</span> <span class="pre">vₛ]</span></code>. The positions in qₛ are a concatenation of the positions
for each joint in the order they appear in
<code class="docutils literal notranslate"><span class="pre">user_to_joint_index_map</span></code>. That is, the positions for
<code class="docutils literal notranslate"><span class="pre">user_to_joint_index_map[0]</span></code> are first, followed by the positions
for <code class="docutils literal notranslate"><span class="pre">user_to_joint_index_map[1]</span></code>, etc. Similarly for the selected
velocities vₛ.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if there are repeated indexes in</strong> – </p></li>
<li><p><strong>user_to_joint_index_map`</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.MapQDotToVelocity">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].MapQDotToVelocity"></span><span class="sig-name descname"><span class="pre">MapQDotToVelocity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qdot</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.MapQDotToVelocity" title="Permalink to this definition"></a></dt>
<dd><p>Transforms the time derivative <code class="docutils literal notranslate"><span class="pre">qdot</span></code> of the generalized positions
vector <code class="docutils literal notranslate"><span class="pre">q</span></code> (stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>) to generalized velocities <code class="docutils literal notranslate"><span class="pre">v</span></code>.
<cite>v</cite> and <code class="docutils literal notranslate"><span class="pre">q̇</span></code> are related linearly by <code class="docutils literal notranslate"><span class="pre">q̇</span> <span class="pre">=</span> <span class="pre">N(q)⋅v</span></code>. Although
<code class="docutils literal notranslate"><span class="pre">N(q)</span></code> is not necessarily square, its left pseudo-inverse <code class="docutils literal notranslate"><span class="pre">N⁺(q)</span></code>
can be used to invert that relationship without residual error,
provided that <code class="docutils literal notranslate"><span class="pre">qdot</span></code> is in the range space of <code class="docutils literal notranslate"><span class="pre">N(q)</span></code> (that is, if
it <em>could</em> have been produced as <code class="docutils literal notranslate"><span class="pre">q̇</span> <span class="pre">=</span> <span class="pre">N(q)⋅v</span></code> for some <code class="docutils literal notranslate"><span class="pre">v</span></code>).
Using the configuration <code class="docutils literal notranslate"><span class="pre">q</span></code> stored in the given <code class="docutils literal notranslate"><span class="pre">context</span></code> this
method calculates <code class="docutils literal notranslate"><span class="pre">v</span> <span class="pre">=</span> <span class="pre">N⁺(q)⋅q̇</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context containing the state of the model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">qdot</span></code>:</dt><dd><p>A vector containing the time derivatives of the generalized
positions. This method aborts if <code class="docutils literal notranslate"><span class="pre">qdot</span></code> is not of size
num_positions().</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">v</span></code>:</dt><dd><p>A valid (non-null) pointer to a vector in <code class="docutils literal notranslate"><span class="pre">ℛⁿ</span></code> with n the number
of generalized velocities. This method aborts if v is nullptr or
if it is not of size num_velocities().</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>MapVelocityToQDot()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>Mobilizer::MapQDotToVelocity()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.MapVelocityToQDot">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].MapVelocityToQDot"></span><span class="sig-name descname"><span class="pre">MapVelocityToQDot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.MapVelocityToQDot" title="Permalink to this definition"></a></dt>
<dd><p>Transforms generalized velocities v to time derivatives <code class="docutils literal notranslate"><span class="pre">qdot</span></code> of
the generalized positions vector <code class="docutils literal notranslate"><span class="pre">q</span></code> (stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>). <cite>v</cite>
and <code class="docutils literal notranslate"><span class="pre">qdot</span></code> are related linearly by <code class="docutils literal notranslate"><span class="pre">q̇</span> <span class="pre">=</span> <span class="pre">N(q)⋅v</span></code>. Using the
configuration <code class="docutils literal notranslate"><span class="pre">q</span></code> stored in the given <code class="docutils literal notranslate"><span class="pre">context</span></code> this method
calculates <code class="docutils literal notranslate"><span class="pre">q̇</span> <span class="pre">=</span> <span class="pre">N(q)⋅v</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context containing the state of the model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">v</span></code>:</dt><dd><p>A vector of generalized velocities for this model. This method
aborts if v is not of size num_velocities().</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">qdot</span></code>:</dt><dd><p>A valid (non-null) pointer to a vector in <code class="docutils literal notranslate"><span class="pre">ℝⁿ</span></code> with n being the
number of generalized positions in this model, given by
<code class="docutils literal notranslate"><span class="pre">num_positions()</span></code>. This method aborts if <code class="docutils literal notranslate"><span class="pre">qdot</span></code> is nullptr or
if it is not of size num_positions().</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>MapQDotToVelocity()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>Mobilizer::MapVelocityToQDot()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.mutable_gravity_field">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].mutable_gravity_field"></span><span class="sig-name descname"><span class="pre">mutable_gravity_field</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.UniformGravityFieldElement_" title="pydrake.multibody.tree.UniformGravityFieldElement_"><span class="pre">pydrake.multibody.tree.UniformGravityFieldElement_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.mutable_gravity_field" title="Permalink to this definition"></a></dt>
<dd><p>A mutable accessor to the current gravity field.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.num_actuated_dofs">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].num_actuated_dofs"></span><span class="sig-name descname"><span class="pre">num_actuated_dofs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.num_actuated_dofs" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>num_actuated_dofs(self: pydrake.multibody.plant.MultibodyPlant_[Expression]) -&gt; int</p></li>
</ol>
<p>Returns the total number of actuated degrees of freedom. That is, the
vector of actuation values u has this size. See AddJointActuator().</p>
<ol class="arabic simple" start="2">
<li><p>num_actuated_dofs(self: pydrake.multibody.plant.MultibodyPlant_[Expression], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; int</p></li>
</ol>
<p>Returns the total number of actuated degrees of freedom for a specific
model instance. That is, the vector of actuation values u has this
size. See AddJointActuator().</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.num_actuators">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].num_actuators"></span><span class="sig-name descname"><span class="pre">num_actuators</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.num_actuators" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>num_actuators(self: pydrake.multibody.plant.MultibodyPlant_[Expression]) -&gt; int</p></li>
</ol>
<p>Returns the number of joint actuators in the model.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddJointActuator().</p>
</div>
<ol class="arabic simple" start="2">
<li><p>num_actuators(self: pydrake.multibody.plant.MultibodyPlant_[Expression], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; int</p></li>
</ol>
<p>Returns the number of actuators for a specific model instance.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.num_bodies">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].num_bodies"></span><span class="sig-name descname"><span class="pre">num_bodies</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.num_bodies" title="Permalink to this definition"></a></dt>
<dd><p>Returns the number of bodies in the model, including the “world” body,
which is always part of the model.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddRigidBody().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.num_collision_geometries">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].num_collision_geometries"></span><span class="sig-name descname"><span class="pre">num_collision_geometries</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.num_collision_geometries" title="Permalink to this definition"></a></dt>
<dd><p>Returns the number of geometries registered for contact modeling. This
method can be called at any time during the lifetime of <code class="docutils literal notranslate"><span class="pre">this</span></code>
plant, either pre- or post-finalize, see Finalize(). Post-finalize
calls will always return the same value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.num_constraints">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].num_constraints"></span><span class="sig-name descname"><span class="pre">num_constraints</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.num_constraints" title="Permalink to this definition"></a></dt>
<dd><p>Returns the total number of constraints specified by the user.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.num_force_elements">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].num_force_elements"></span><span class="sig-name descname"><span class="pre">num_force_elements</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.num_force_elements" title="Permalink to this definition"></a></dt>
<dd><p>Returns the number of ForceElement objects.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddForceElement().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.num_frames">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].num_frames"></span><span class="sig-name descname"><span class="pre">num_frames</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.num_frames" title="Permalink to this definition"></a></dt>
<dd><p>Returns the number of Frame objects in this model. Frames include body
frames associated with each of the bodies, including the <em>world</em> body.
This means the minimum number of frames is one.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.num_joints">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].num_joints"></span><span class="sig-name descname"><span class="pre">num_joints</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.num_joints" title="Permalink to this definition"></a></dt>
<dd><p>Returns the number of joints in the model.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddJoint().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.num_model_instances">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].num_model_instances"></span><span class="sig-name descname"><span class="pre">num_model_instances</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.num_model_instances" title="Permalink to this definition"></a></dt>
<dd><p>Returns the number of model instances in the model.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddModelInstance().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.num_multibody_states">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].num_multibody_states"></span><span class="sig-name descname"><span class="pre">num_multibody_states</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.num_multibody_states" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>num_multibody_states(self: pydrake.multibody.plant.MultibodyPlant_[Expression]) -&gt; int</p></li>
</ol>
<p>Returns the size of the multibody system state vector x = [q v]. This
will be <code class="docutils literal notranslate"><span class="pre">num_positions()</span></code> plus <code class="docutils literal notranslate"><span class="pre">num_velocities()</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>num_multibody_states(self: pydrake.multibody.plant.MultibodyPlant_[Expression], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; int</p></li>
</ol>
<p>Returns the size of the multibody system state vector xᵢ = [qᵢ vᵢ] for
model instance i. (Here qᵢ ⊆ q and vᵢ ⊆ v.) will be
<code class="docutils literal notranslate"><span class="pre">num_positions(model_instance)</span></code> plus
<code class="docutils literal notranslate"><span class="pre">num_velocities(model_instance)</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.num_positions">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].num_positions"></span><span class="sig-name descname"><span class="pre">num_positions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.num_positions" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>num_positions(self: pydrake.multibody.plant.MultibodyPlant_[Expression]) -&gt; int</p></li>
</ol>
<p>Returns the size of the generalized position vector q for this model.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>num_positions(self: pydrake.multibody.plant.MultibodyPlant_[Expression], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; int</p></li>
</ol>
<p>Returns the size of the generalized position vector qᵢ for model
instance i.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.num_velocities">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].num_velocities"></span><span class="sig-name descname"><span class="pre">num_velocities</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.num_velocities" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>num_velocities(self: pydrake.multibody.plant.MultibodyPlant_[Expression]) -&gt; int</p></li>
</ol>
<p>Returns the size of the generalized velocity vector v for this model.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>num_velocities(self: pydrake.multibody.plant.MultibodyPlant_[Expression], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; int</p></li>
</ol>
<p>Returns the size of the generalized velocity vector vᵢ for model
instance i.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.physical_models">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].physical_models"></span><span class="sig-name descname"><span class="pre">physical_models</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List[drake::multibody::PhysicalModel&lt;drake::symbolic::Expression&gt;]</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.physical_models" title="Permalink to this definition"></a></dt>
<dd><p>Returns a vector of pointers to all physical models registered with
this MultibodyPlant. For use only by advanced developers.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This feature is considered to be <strong>experimental</strong> and may change
or be removed at any time, without any deprecation notice ahead of
time.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.RegisterAsSourceForSceneGraph">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].RegisterAsSourceForSceneGraph"></span><span class="sig-name descname"><span class="pre">RegisterAsSourceForSceneGraph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scene_graph</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.SceneGraph_" title="pydrake.geometry.SceneGraph_"><span class="pre">pydrake.geometry.SceneGraph_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.SourceId" title="pydrake.geometry.SourceId"><span class="pre">pydrake.geometry.SourceId</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.RegisterAsSourceForSceneGraph" title="Permalink to this definition"></a></dt>
<dd><p>Registers <code class="docutils literal notranslate"><span class="pre">this</span></code> plant to serve as a source for an instance of
SceneGraph. This registration allows MultibodyPlant to register
geometry with <code class="docutils literal notranslate"><span class="pre">scene_graph</span></code> for visualization and/or collision
queries. The string returned by <code class="docutils literal notranslate"><span class="pre">this-&gt;get_name()</span></code> is passed to
SceneGraph’s RegisterSource, so it is highly recommended that you give
the plant a recognizable name before calling this. Successive
registration calls with SceneGraph <strong>must</strong> be performed on the same
instance to which the pointer argument <code class="docutils literal notranslate"><span class="pre">scene_graph</span></code> points to.
Failure to do so will result in runtime exceptions.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">scene_graph</span></code>:</dt><dd><p>A valid non nullptr to the SceneGraph instance for which <code class="docutils literal notranslate"><span class="pre">this</span></code>
plant will sever as a source, see SceneGraph documentation for
further details.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the SourceId of <code class="docutils literal notranslate"><span class="pre">this</span></code> plant in <code class="docutils literal notranslate"><span class="pre">scene_graph</span></code>. It can also
later on be retrieved with get_source_id().</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>RuntimeError if called post-finalize.</strong> – </p></li>
<li><p><strong>RuntimeError if scene_graph is the nullptr.</strong> – </p></li>
<li><p><strong>RuntimeError if called more than once.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.RegisterCollisionGeometry">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].RegisterCollisionGeometry"></span><span class="sig-name descname"><span class="pre">RegisterCollisionGeometry</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.RegisterCollisionGeometry" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>RegisterCollisionGeometry(self: pydrake.multibody.plant.MultibodyPlant_[Expression], body: pydrake.multibody.tree.RigidBody_[Expression], X_BG: pydrake.math.RigidTransform, shape: pydrake.geometry.Shape, name: str, properties: pydrake.geometry.ProximityProperties) -&gt; pydrake.geometry.GeometryId</p></li>
</ol>
<p>Registers geometry in a SceneGraph with a given geometry::Shape to be
used for the contact modeling of a given <code class="docutils literal notranslate"><span class="pre">body</span></code>. More than one
geometry can be registered with a body, in which case the body’s
contact geometry is the union of all geometries registered to that
body.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body</span></code>:</dt><dd><p>The body for which geometry is being registered.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">X_BG</span></code>:</dt><dd><p>The fixed pose of the geometry frame G in the body frame B.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">shape</span></code>:</dt><dd><p>The geometry::Shape used for visualization. E.g.:
geometry::Sphere, geometry::Cylinder, etc.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">properties</span></code>:</dt><dd><p>The proximity properties associated with the collision geometry.
They <em>must</em> include the (<code class="docutils literal notranslate"><span class="pre">material</span></code>, <cite>coulomb_friction</cite>)
property of type CoulombFriction&lt;double&gt;.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if called post-finalize</strong><strong> or </strong><strong>if the properties are</strong> – </p></li>
<li><p><strong>missing the coulomb friction property</strong><strong> (or </strong><strong>if it is of the wrong</strong> – </p></li>
<li><p><strong>type</strong><strong>)</strong><strong></strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>RegisterCollisionGeometry(self: pydrake.multibody.plant.MultibodyPlant_[Expression], body: pydrake.multibody.tree.RigidBody_[Expression], X_BG: pydrake.math.RigidTransform, shape: pydrake.geometry.Shape, name: str, coulomb_friction: pydrake.multibody.plant.CoulombFriction) -&gt; pydrake.geometry.GeometryId</p></li>
</ol>
<p>Overload which specifies a single property: coulomb_friction.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.RegisterVisualGeometry">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].RegisterVisualGeometry"></span><span class="sig-name descname"><span class="pre">RegisterVisualGeometry</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody_" title="pydrake.multibody.tree.RigidBody_"><span class="pre">pydrake.multibody.tree.RigidBody_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X_BG</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.math.html#pydrake.math.RigidTransform" title="pydrake.math.RigidTransform"><span class="pre">pydrake.math.RigidTransform</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">shape</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.Shape" title="pydrake.geometry.Shape"><span class="pre">pydrake.geometry.Shape</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">diffuse_color</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">4</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.GeometryId" title="pydrake.geometry.GeometryId"><span class="pre">pydrake.geometry.GeometryId</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.RegisterVisualGeometry" title="Permalink to this definition"></a></dt>
<dd><p>Overload for visual geometry registration; it converts the
<code class="docutils literal notranslate"><span class="pre">diffuse_color</span></code> (RGBA with values in the range [0, 1]) into a
geometry::DrakeVisualizer-compatible set of
geometry::IllustrationProperties.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.RemoveConstraint">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].RemoveConstraint"></span><span class="sig-name descname"><span class="pre">RemoveConstraint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">id</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.MultibodyConstraintId" title="pydrake.multibody.tree.MultibodyConstraintId"><span class="pre">pydrake.multibody.tree.MultibodyConstraintId</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.RemoveConstraint" title="Permalink to this definition"></a></dt>
<dd><p>Removes the constraint <code class="docutils literal notranslate"><span class="pre">id</span></code> from the plant. Note that this will
<em>not</em> remove constraints registered directly with DeformableModel.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the MultibodyPlant has already been finalized.</strong> – </p></li>
<li><p><strong>RuntimeError if id does not identify any multibody constraint</strong> – </p></li>
<li><p><strong>in this plant.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.RemoveJoint">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].RemoveJoint"></span><span class="sig-name descname"><span class="pre">RemoveJoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">joint</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Joint_" title="pydrake.multibody.tree.Joint_"><span class="pre">pydrake.multibody.tree.Joint_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.RemoveJoint" title="Permalink to this definition"></a></dt>
<dd><p>Removes and deletes <code class="docutils literal notranslate"><span class="pre">joint</span></code> from this MultibodyPlant. Any existing
references to <code class="docutils literal notranslate"><span class="pre">joint</span></code> will become invalid, and future calls to
<code class="docutils literal notranslate"><span class="pre">get_joint(joint_index)</span></code> will throw an exception. Other elements of
the plant may depend on <code class="docutils literal notranslate"><span class="pre">joint</span></code> at the time of removal and should be
removed first. For example, a JointActuator that depends on <code class="docutils literal notranslate"><span class="pre">joint</span></code>
should be removed with RemoveJointActuator(). Currently, we do not
provide joint dependency tracking for force elements or constraints,
so this function will throw an exception if there are <em>any</em> user-added
force elements or constraints in the plant.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the plant is already finalized.</strong> – </p></li>
<li><p><strong>RuntimeError if the plant contains a non-zero number of user-added</strong> – </p></li>
<li><p><strong>force elements</strong><strong> or </strong><strong>user-added constraints.</strong> – </p></li>
<li><p><strong>RuntimeError if joint has a dependent JointActuator.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddJoint()</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is important to note that the JointIndex assigned to a joint is
immutable. New joint indices are assigned in increasing order,
even if a joint with a lower index has been removed. This has the
consequence that when a joint is removed from the plant, the
sequence <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">num_joints())</span></code> is not necessarily the correct set
of un-removed joint indices in the plant. Thus, it is important
<em>NOT</em> to loop over joint indices sequentially from <code class="docutils literal notranslate"><span class="pre">0</span></code> to
<code class="docutils literal notranslate"><span class="pre">num_joints()</span> <span class="pre">-</span> <span class="pre">1</span></code>. Instead users should use the provided
GetJointIndices() and GetJointIndices(ModelIndex) functions:</p>
</div>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">JointIndex</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">plant</span><span class="p">.</span><span class="n">GetJointIndices</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">Joint</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">joint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">plant</span><span class="p">.</span><span class="n">get_joint</span><span class="p">(</span><span class="n">index</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="w"> </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</details></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.RemoveJointActuator">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].RemoveJointActuator"></span><span class="sig-name descname"><span class="pre">RemoveJointActuator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">actuator</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.JointActuator_" title="pydrake.multibody.tree.JointActuator_"><span class="pre">pydrake.multibody.tree.JointActuator_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.RemoveJointActuator" title="Permalink to this definition"></a></dt>
<dd><p>Removes and deletes <code class="docutils literal notranslate"><span class="pre">actuator</span></code> from this MultibodyPlant. Any
existing references to <code class="docutils literal notranslate"><span class="pre">actuator</span></code> will become invalid, and future
calls to <code class="docutils literal notranslate"><span class="pre">get_joint_actuator(actuator_index)</span></code> will throw an
exception.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if the plant is already finalized.</strong> – </p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddJointActuator()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.RenameModelInstance">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].RenameModelInstance"></span><span class="sig-name descname"><span class="pre">RenameModelInstance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.RenameModelInstance" title="Permalink to this definition"></a></dt>
<dd><p>Renames an existing model instance.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>:</dt><dd><p>The instance to rename.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">name</span></code>:</dt><dd><p>A string that uniquely identifies the instance within <code class="docutils literal notranslate"><span class="pre">this</span></code>
model.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if called after Finalize</strong><strong>(</strong><strong>)</strong><strong></strong> – </p></li>
<li><p><strong>RuntimeError if model_instance is not a valid index.</strong> – </p></li>
<li><p><strong>RuntimeError if HasModelInstanceNamed</strong><strong>(</strong><strong>name</strong><strong>) </strong><strong>is true.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.set_adjacent_bodies_collision_filters">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].set_adjacent_bodies_collision_filters"></span><span class="sig-name descname"><span class="pre">set_adjacent_bodies_collision_filters</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.set_adjacent_bodies_collision_filters" title="Permalink to this definition"></a></dt>
<dd><p>Sets whether to apply collision filters to topologically adjacent
bodies at Finalize() time. Filters are applied when there exists a
joint between bodies, except in the case of 6-dof joints or joints in
which the parent body is <code class="docutils literal notranslate"><span class="pre">world</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError iff called post-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.set_contact_model">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].set_contact_model"></span><span class="sig-name descname"><span class="pre">set_contact_model</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.ContactModel" title="pydrake.multibody.plant.ContactModel"><span class="pre">pydrake.multibody.plant.ContactModel</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.set_contact_model" title="Permalink to this definition"></a></dt>
<dd><p>Sets the contact model to be used by <code class="docutils literal notranslate"><span class="pre">this</span></code> MultibodyPlant, see
ContactModel for available options. The default contact model is
ContactModel::kHydroelasticWithFallback.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError iff called post-finalize.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.set_contact_surface_representation">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].set_contact_surface_representation"></span><span class="sig-name descname"><span class="pre">set_contact_surface_representation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">surface_representation</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.HydroelasticContactRepresentation" title="pydrake.geometry.HydroelasticContactRepresentation"><span class="pre">pydrake.geometry.HydroelasticContactRepresentation</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.set_contact_surface_representation" title="Permalink to this definition"></a></dt>
<dd><p>Sets the representation of contact surfaces to be used by <code class="docutils literal notranslate"><span class="pre">this</span></code>
MultibodyPlant. See geometry::HydroelasticContactRepresentation for
available options. See GetDefaultContactSurfaceRepresentation() for
explanation of default values.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.set_discrete_contact_approximation">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].set_discrete_contact_approximation"></span><span class="sig-name descname"><span class="pre">set_discrete_contact_approximation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">approximation</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.DiscreteContactApproximation" title="pydrake.multibody.plant.DiscreteContactApproximation"><span class="pre">pydrake.multibody.plant.DiscreteContactApproximation</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.set_discrete_contact_approximation" title="Permalink to this definition"></a></dt>
<dd><p>Sets the discrete contact model approximation.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Calling this method also sets the contact solver type (see
set_discrete_contact_solver()) according to: -
DiscreteContactApproximation::kTamsi sets the solver to
DiscreteContactSolver::kTamsi. -
DiscreteContactApproximation::kSap,
DiscreteContactApproximation::kSimilar and
DiscreteContactApproximation::kLagged set the solver to
DiscreteContactSolver::kSap.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>iff this plant is continuous</strong><strong> (</strong><strong>i.e. is_discrete</strong><strong>(</strong><strong>) </strong><strong>is</strong> – </p></li>
<li><p><strong>False`.</strong> – </p></li>
<li><p><strong>RuntimeError iff called post-finalize.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.set_discrete_contact_solver">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].set_discrete_contact_solver"></span><span class="sig-name descname"><span class="pre">set_discrete_contact_solver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">contact_solver</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.DiscreteContactSolver" title="pydrake.multibody.plant.DiscreteContactSolver"><span class="pre">pydrake.multibody.plant.DiscreteContactSolver</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.set_discrete_contact_solver" title="Permalink to this definition"></a></dt>
<dd><p>Sets the contact solver type used for discrete MultibodyPlant models.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Calling this method also sets a default discrete approximation of
contact (see set_discrete_contact_approximation()) according to: -
DiscreteContactSolver::kTamsi sets the approximation to
DiscreteContactApproximation::kTamsi. -
DiscreteContactSolver::kSap sets the approximation to
DiscreteContactApproximation::kSap.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This function is a no-op for continuous models (when is_discrete()
is false.)</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError iff called post-finalize.</strong><strong> (</strong><strong>Deprecated.</strong><strong>)</strong> – </p>
</dd>
</dl>
<dl class="simple">
<dt>Deprecated:</dt><dd><p>Use set_discrete_contact_approximation() to set the contact model
approximation. The underlying solver will be inferred
automatically. This will be removed from Drake on or after
2024-04-01.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.set_gravity_enabled">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].set_gravity_enabled"></span><span class="sig-name descname"><span class="pre">set_gravity_enabled</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_enabled</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.set_gravity_enabled" title="Permalink to this definition"></a></dt>
<dd><p>Sets is_gravity_enabled() for <code class="docutils literal notranslate"><span class="pre">model_instance</span></code> to <code class="docutils literal notranslate"><span class="pre">is_enabled</span></code>.
The effect of <code class="docutils literal notranslate"><span class="pre">is_enabled</span> <span class="pre">=</span> <span class="pre">false</span></code> is effectively equivalent to
disabling (or making zero) gravity for all bodies in the specified
model instance. By default is_gravity_enabled() equals <code class="docutils literal notranslate"><span class="pre">True</span></code> for
all model instances.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if called post-finalize.</strong> – </p></li>
<li><p><strong>RuntimeError if the model instance is invalid.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.set_penetration_allowance">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].set_penetration_allowance"></span><span class="sig-name descname"><span class="pre">set_penetration_allowance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">penetration_allowance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.001</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.set_penetration_allowance" title="Permalink to this definition"></a></dt>
<dd><p>Sets the penetration allowance used to estimate the coefficients in
the penalty method used to impose non-penetration among bodies. Refer
to the section mbp_compliant_point_contact “Compliant point contact
model” for further details.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if penetration_allowance is not positive.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.set_sap_near_rigid_threshold">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].set_sap_near_rigid_threshold"></span><span class="sig-name descname"><span class="pre">set_sap_near_rigid_threshold</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">near_rigid_threshold</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.set_sap_near_rigid_threshold" title="Permalink to this definition"></a></dt>
<dd><p>Non-negative dimensionless number typically in the range [0.0, 1.0],
though larger values are allowed even if uncommon. This parameter
controls the “near rigid” regime of the SAP solver, β in section V.B
of [Castro et al., 2021]. It essentially controls a threshold value
for the maximum amount of stiffness SAP can handle robustly. Beyond
this value, stiffness saturates as explained in [Castro et al., 2021].
A value of 1.0 is a conservative choice to avoid ill-conditioning that
might lead to softer than expected contact. If this is your case,
consider turning off this approximation by setting this parameter to
zero. For difficult cases where ill-conditioning is a problem, a small
but non-zero number can be used, e.g. 1.0e-3.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if near_rigid_threshold is negative.</strong> – </p></li>
<li><p><strong>RuntimeError if called post-finalize.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.set_stiction_tolerance">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].set_stiction_tolerance"></span><span class="sig-name descname"><span class="pre">set_stiction_tolerance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v_stiction</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.001</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.set_stiction_tolerance" title="Permalink to this definition"></a></dt>
<dd><p><a href="#id87"><span class="problematic" id="id88">**</span></a>** Stribeck model of friction</p>
<p>Currently MultibodyPlant uses the Stribeck approximation to model dry
friction. The Stribeck model of friction is an approximation to
Coulomb’s law of friction that allows using continuous time
integration without the need to specify complementarity constraints.
While this results in a simpler model immediately tractable with
standard numerical methods for integration of ODE’s, it often leads to
stiff dynamics that require an explicit integrator to take very small
time steps. It is therefore recommended to use error controlled
integrators when using this model or the discrete time stepping (see
time_advancement_strategy “Choice of Time Advancement Strategy”). See
stribeck_approximation for a detailed discussion of the Stribeck
model.</p>
<p>Sets the stiction tolerance <code class="docutils literal notranslate"><span class="pre">v_stiction</span></code> for the Stribeck model,
where <code class="docutils literal notranslate"><span class="pre">v_stiction</span></code> must be specified in m/s (meters per second.)
<code class="docutils literal notranslate"><span class="pre">v_stiction</span></code> defaults to a value of 1 millimeter per second. In
selecting a value for <code class="docutils literal notranslate"><span class="pre">v_stiction</span></code>, you must ask yourself the
question, “When two objects are ostensibly in stiction, how much slip
am I willing to allow?” There are two opposing design issues in
picking a value for vₛ. On the one hand, small values of vₛ make the
problem numerically stiff during stiction, potentially increasing the
integration cost. On the other hand, it should be picked to be
appropriate for the scale of the problem. For example, a car
simulation could allow a “large” value for vₛ of 1 cm/s (1×10⁻² m/s),
but reasonable stiction for grasping a 10 cm box might require
limiting residual slip to 1×10⁻³ m/s or less. Ultimately, picking the
largest viable value will allow your simulation to run faster and more
robustly. Note that <code class="docutils literal notranslate"><span class="pre">v_stiction</span></code> is the slip velocity that we’d have
when we are at edge of the friction cone. For cases when the friction
force is well within the friction cone the slip velocity will always
be smaller than this value. See also stribeck_approximation.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if v_stiction is non-positive.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.SetActuationInArray">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].SetActuationInArray"></span><span class="sig-name descname"><span class="pre">SetActuationInArray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">u_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">u</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.writeable</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.SetActuationInArray" title="Permalink to this definition"></a></dt>
<dd><p>Given actuation values <code class="docutils literal notranslate"><span class="pre">u_instance</span></code> for the actuators in
<code class="docutils literal notranslate"><span class="pre">model_instance</span></code>, this function updates the actuation vector u for
the entire plant model to which this actuator belongs to. Refer to
mbp_actuation “Actuation” for further details.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">u_instance</span></code>:</dt><dd><p>Actuation values for the model instance. Values are ordered by
monotonically increasing JointActuatorIndex within the model
instance.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">u</span></code>:</dt><dd><p>Actuation values for the entire plant model. The actuation value
in <code class="docutils literal notranslate"><span class="pre">u</span></code> for a particular actuator must be found at offset
JointActuator::input_start(). Only values corresponding to
<code class="docutils literal notranslate"><span class="pre">model_instance</span></code> are changed.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the size of u_instance is not equal to the</strong> – </p></li>
<li><p><strong>number of actuation inputs for the joints of model_instance.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.SetConstraintActiveStatus">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].SetConstraintActiveStatus"></span><span class="sig-name descname"><span class="pre">SetConstraintActiveStatus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">id</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.MultibodyConstraintId" title="pydrake.multibody.tree.MultibodyConstraintId"><span class="pre">pydrake.multibody.tree.MultibodyConstraintId</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">status</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.SetConstraintActiveStatus" title="Permalink to this definition"></a></dt>
<dd><p>Sets the active status of the constraint given by <code class="docutils literal notranslate"><span class="pre">id</span></code> in
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the MultibodyPlant has not been finalized.</strong> – </p></li>
<li><p><strong>RuntimeError if context == nullptr</strong> – </p></li>
<li><p><strong>RuntimeError if id does not belong to any multibody constraint</strong> – </p></li>
<li><p><strong>in context.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.SetDefaultFreeBodyPose">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].SetDefaultFreeBodyPose"></span><span class="sig-name descname"><span class="pre">SetDefaultFreeBodyPose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody_" title="pydrake.multibody.tree.RigidBody_"><span class="pre">pydrake.multibody.tree.RigidBody_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X_WB</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.math.html#pydrake.math.RigidTransform" title="pydrake.math.RigidTransform"><span class="pre">pydrake.math.RigidTransform</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.SetDefaultFreeBodyPose" title="Permalink to this definition"></a></dt>
<dd><p>Sets the default pose of <code class="docutils literal notranslate"><span class="pre">body</span></code>. If <code class="docutils literal notranslate"><span class="pre">body.is_floating()</span></code> is true,
this will affect subsequent calls to SetDefaultState(); otherwise, the
only effect of the call is that the value will be echoed back in
GetDefaultFreeBodyPose().</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body</span></code>:</dt><dd><p>RigidBody whose default pose will be set.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">X_WB</span></code>:</dt><dd><p>Default pose of the body.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.SetDefaultPositions">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].SetDefaultPositions"></span><span class="sig-name descname"><span class="pre">SetDefaultPositions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.SetDefaultPositions" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>SetDefaultPositions(self: pydrake.multibody.plant.MultibodyPlant_[Expression], q: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</p></li>
</ol>
<p>Sets the default positions for the plant. Calls to
CreateDefaultContext or SetDefaultContext/SetDefaultState will return
a Context populated with these position values. They have no other
effects on the dynamics of the system.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the plant is not finalized</strong><strong> or </strong><strong>if q is not of size</strong> – </p></li>
<li><p><strong>num_positions</strong><strong>(</strong><strong>)</strong><strong></strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>SetDefaultPositions(self: pydrake.multibody.plant.MultibodyPlant_[Expression], model_instance: pydrake.multibody.tree.ModelInstanceIndex, q_instance: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</p></li>
</ol>
<p>Sets the default positions for the model instance. Calls to
CreateDefaultContext or SetDefaultContext/SetDefaultState will return
a Context populated with these position values. They have no other
effects on the dynamics of the system.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the plant is not finalized</strong><strong>, </strong><strong>if the model_instance</strong> – </p></li>
<li><p><strong>is invalid</strong><strong>, or </strong><strong>if the length of q_instance is not equal to</strong> – </p></li>
<li><p><strong>num_positions</strong><strong>(</strong><strong>model_instance</strong><strong>)</strong><strong>`</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.SetDefaultState">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].SetDefaultState"></span><span class="sig-name descname"><span class="pre">SetDefaultState</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">state</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.State_" title="pydrake.systems.framework.State_"><span class="pre">pydrake.systems.framework.State_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.SetDefaultState" title="Permalink to this definition"></a></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">state</span></code> according to defaults set by the user for joints (e.g.
RevoluteJoint::set_default_angle()) and free bodies
(SetDefaultFreeBodyPose()). If the user does not specify defaults, the
state corresponds to zero generalized positions and velocities.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize. See Finalize</strong><strong>(</strong><strong>)</strong><strong></strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.SetFreeBodyPose">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].SetFreeBodyPose"></span><span class="sig-name descname"><span class="pre">SetFreeBodyPose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody_" title="pydrake.multibody.tree.RigidBody_"><span class="pre">pydrake.multibody.tree.RigidBody_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X_WB</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.math.html#pydrake.math.RigidTransform_" title="pydrake.math.RigidTransform_"><span class="pre">pydrake.math.RigidTransform_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.SetFreeBodyPose" title="Permalink to this definition"></a></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">context</span></code> to store the pose <code class="docutils literal notranslate"><span class="pre">X_WB</span></code> of a given <code class="docutils literal notranslate"><span class="pre">body</span></code> B in
the world frame W.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In general setting the pose and/or velocity of a body in the model
would involve a complex inverse kinematics problem. This method
allows us to simplify this process when we know the body is free
in space.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if body is not a free body in the model.</strong> – </p></li>
<li><p><strong>RuntimeError if called pre-finalize.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.SetFreeBodySpatialVelocity">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].SetFreeBodySpatialVelocity"></span><span class="sig-name descname"><span class="pre">SetFreeBodySpatialVelocity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody_" title="pydrake.multibody.tree.RigidBody_"><span class="pre">pydrake.multibody.tree.RigidBody_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">V_WB</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.math.html#pydrake.multibody.math.SpatialVelocity_" title="pydrake.multibody.math.SpatialVelocity_"><span class="pre">pydrake.multibody.math.SpatialVelocity_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.SetFreeBodySpatialVelocity" title="Permalink to this definition"></a></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">context</span></code> to store the spatial velocity <code class="docutils literal notranslate"><span class="pre">V_WB</span></code> of a given
<code class="docutils literal notranslate"><span class="pre">body</span></code> B in the world frame W.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In general setting the pose and/or velocity of a body in the model
would involve a complex inverse kinematics problem. This method
allows us to simplify this process when we know the body is free
in space.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if body is not a free body in the model.</strong> – </p></li>
<li><p><strong>RuntimeError if called pre-finalize.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.SetPositions">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].SetPositions"></span><span class="sig-name descname"><span class="pre">SetPositions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.SetPositions" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>SetPositions(self: pydrake.multibody.plant.MultibodyPlant_[Expression], context: pydrake.systems.framework.Context_[Expression], q: numpy.ndarray[object[m, 1]]) -&gt; None</p></li>
</ol>
<p>Sets the generalized positions q in a given Context from a given
vector. Prefer this method over GetMutablePositions().</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if context is nullptr</strong><strong>, </strong><strong>if context does not</strong> – </p></li>
<li><p><strong>correspond to the Context for a multibody model</strong><strong>, or </strong><strong>if the length</strong> – </p></li>
<li><p><strong>of q is not equal to num_positions</strong><strong>(</strong><strong>)</strong><strong></strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>SetPositions(self: pydrake.multibody.plant.MultibodyPlant_[Expression], context: pydrake.systems.framework.Context_[Expression], model_instance: pydrake.multibody.tree.ModelInstanceIndex, q: numpy.ndarray[object[m, 1]]) -&gt; None</p></li>
</ol>
<p>Sets the generalized positions q in a given Context from a given
vector. Prefer this method over GetMutablePositions().</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if context is nullptr</strong><strong>, </strong><strong>if context does not</strong> – </p></li>
<li><p><strong>correspond to the Context for a multibody model</strong><strong>, or </strong><strong>if the length</strong> – </p></li>
<li><p><strong>of q is not equal to num_positions</strong><strong>(</strong><strong>)</strong><strong></strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.SetPositionsAndVelocities">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].SetPositionsAndVelocities"></span><span class="sig-name descname"><span class="pre">SetPositionsAndVelocities</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.SetPositionsAndVelocities" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>SetPositionsAndVelocities(self: pydrake.multibody.plant.MultibodyPlant_[Expression], context: pydrake.systems.framework.Context_[Expression], q_v: numpy.ndarray[object[m, 1]]) -&gt; None</p></li>
</ol>
<p>Sets generalized positions q and generalized velocities v in a given
Context from a given vector [q; v]. Prefer this method over
GetMutablePositionsAndVelocities().</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if context is nullptr</strong><strong>, </strong><strong>if context does not</strong> – </p></li>
<li><p><strong>correspond to the context for a multibody model</strong><strong>, or </strong><strong>if the length</strong> – </p></li>
<li><p><strong>of q_v is not equal to num_positions</strong><strong>(</strong><strong>) </strong><strong>+ num_velocities</strong><strong>(</strong><strong>)</strong><strong></strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>SetPositionsAndVelocities(self: pydrake.multibody.plant.MultibodyPlant_[Expression], context: pydrake.systems.framework.Context_[Expression], model_instance: pydrake.multibody.tree.ModelInstanceIndex, q_v: numpy.ndarray[object[m, 1]]) -&gt; None</p></li>
</ol>
<p>Sets generalized positions q and generalized velocities v from a given
vector [q; v] for a specified model instance in a given Context.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if context is nullptr</strong><strong>, </strong><strong>if context does not</strong> – </p></li>
<li><p><strong>correspond to the Context for a multibody model</strong><strong>, </strong><strong>if the model</strong> – </p></li>
<li><p><strong>instance index is invalid</strong><strong>, or </strong><strong>if the length of q_v is not</strong> – </p></li>
<li><p><strong>equal to ``num_positions</strong><strong>(</strong><strong>model_instance</strong><strong>) </strong><strong>+</strong> – </p></li>
<li><p><strong>num_velocities</strong><strong>(</strong><strong>model_instance</strong><strong>)</strong><strong>``.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.SetPositionsInArray">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].SetPositionsInArray"></span><span class="sig-name descname"><span class="pre">SetPositionsInArray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">q_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.writeable</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.SetPositionsInArray" title="Permalink to this definition"></a></dt>
<dd><p>Sets the vector of generalized positions for <code class="docutils literal notranslate"><span class="pre">model_instance</span></code> in
<code class="docutils literal notranslate"><span class="pre">q</span></code> using <code class="docutils literal notranslate"><span class="pre">q_instance</span></code>, leaving all other elements in the array
untouched. This method throws an exception if <code class="docutils literal notranslate"><span class="pre">q</span></code> is not of size
MultibodyPlant::num_positions() or <code class="docutils literal notranslate"><span class="pre">q_instance</span></code> is not of size
<code class="docutils literal notranslate"><span class="pre">MultibodyPlant::num_positions(model_instance)</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.SetVelocities">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].SetVelocities"></span><span class="sig-name descname"><span class="pre">SetVelocities</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.SetVelocities" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>SetVelocities(self: pydrake.multibody.plant.MultibodyPlant_[Expression], context: pydrake.systems.framework.Context_[Expression], v: numpy.ndarray[object[m, 1]]) -&gt; None</p></li>
</ol>
<p>Sets the generalized velocities v in a given Context from a given
vector. Prefer this method over GetMutableVelocities().</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the context is nullptr</strong><strong>, </strong><strong>if the context does</strong> – </p></li>
<li><p><strong>not correspond to the context for a multibody model</strong><strong>, or </strong><strong>if the</strong> – </p></li>
<li><p><strong>length of v is not equal to num_velocities</strong><strong>(</strong><strong>)</strong><strong></strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>SetVelocities(self: pydrake.multibody.plant.MultibodyPlant_[Expression], context: pydrake.systems.framework.Context_[Expression], model_instance: pydrake.multibody.tree.ModelInstanceIndex, v: numpy.ndarray[object[m, 1]]) -&gt; None</p></li>
</ol>
<p>Sets the generalized velocities v for a particular model instance in a
given Context from a given vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the context is nullptr</strong><strong>, </strong><strong>if context does</strong> – </p></li>
<li><p><strong>not correspond to the Context for a multibody model</strong><strong>, </strong><strong>if the model</strong> – </p></li>
<li><p><strong>instance index is invalid</strong><strong>, or </strong><strong>if the length of v_instance is</strong> – </p></li>
<li><p><strong>not equal to num_velocities</strong><strong>(</strong><strong>model_instance</strong><strong>)</strong><strong></strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.SetVelocitiesInArray">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].SetVelocitiesInArray"></span><span class="sig-name descname"><span class="pre">SetVelocitiesInArray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">v_instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.writeable</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.SetVelocitiesInArray" title="Permalink to this definition"></a></dt>
<dd><p>Sets the vector of generalized velocities for <code class="docutils literal notranslate"><span class="pre">model_instance</span></code> in
<code class="docutils literal notranslate"><span class="pre">v</span></code> using <code class="docutils literal notranslate"><span class="pre">v_instance</span></code>, leaving all other elements in the array
untouched. This method throws an exception if <code class="docutils literal notranslate"><span class="pre">v</span></code> is not of size
MultibodyPlant::num_velocities() or <code class="docutils literal notranslate"><span class="pre">v_instance</span></code> is not of size
<code class="docutils literal notranslate"><span class="pre">MultibodyPlant::num_positions(model_instance)</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.time_step">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].time_step"></span><span class="sig-name descname"><span class="pre">time_step</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.time_step" title="Permalink to this definition"></a></dt>
<dd><p>The time step (or period) used to model <code class="docutils literal notranslate"><span class="pre">this</span></code> plant as a discrete
system with periodic updates. Returns 0 (zero) if the plant is modeled
as a continuous system. This property of the plant is specified at
construction and therefore this query can be performed either pre- or
post-finalize, see Finalize().</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>MultibodyPlant::MultibodyPlant(double)</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.WeldFrames">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].WeldFrames"></span><span class="sig-name descname"><span class="pre">WeldFrames</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.WeldFrames" title="Permalink to this definition"></a></dt>
<dd><dl>
<dt>WeldFrames(self: pydrake.multibody.plant.MultibodyPlant_[Expression], frame_on_parent_F: pydrake.multibody.tree.Frame_[Expression], frame_on_child_M: pydrake.multibody.tree.Frame_[Expression], X_FM: pydrake.math.RigidTransform = RigidTransform(</dt><dd><dl class="simple">
<dt>R=RotationMatrix([</dt><dd><p>[1.0, 0.0, 0.0],
[0.0, 1.0, 0.0],
[0.0, 0.0, 1.0],</p>
</dd>
</dl>
<p>]),
p=[0.0, 0.0, 0.0],</p>
</dd>
</dl>
<p>)) -&gt; pydrake.multibody.tree.WeldJoint_[Expression]</p>
<p>Welds <code class="docutils literal notranslate"><span class="pre">frame_on_parent_F</span></code> and <code class="docutils literal notranslate"><span class="pre">frame_on_child_M</span></code> with relative
pose <code class="docutils literal notranslate"><span class="pre">X_FM</span></code>. That is, the pose of frame M in frame F is fixed, with
value <code class="docutils literal notranslate"><span class="pre">X_FM</span></code>. If <code class="docutils literal notranslate"><span class="pre">X_FM</span></code> is omitted, the identity transform will be
used. The call to this method creates and adds a new WeldJoint to the
model. The new WeldJoint is named as: frame_on_parent_F.name() +
“_welds_to_” + frame_on_child_M.name().</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a constant reference to the WeldJoint welding frames F and M.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>RuntimeError if the weld produces a duplicate joint name.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.world_body">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].world_body"></span><span class="sig-name descname"><span class="pre">world_body</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody_" title="pydrake.multibody.tree.RigidBody_"><span class="pre">pydrake.multibody.tree.RigidBody_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.world_body" title="Permalink to this definition"></a></dt>
<dd><p>Returns a constant reference to the <em>world</em> body.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlant_-Expression-.world_frame">
<span id="pydrake.multibody.plant.MultibodyPlant_[Expression].world_frame"></span><span class="sig-name descname"><span class="pre">world_frame</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBodyFrame_" title="pydrake.multibody.tree.RigidBodyFrame_"><span class="pre">pydrake.multibody.tree.RigidBodyFrame_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_-Expression-.world_frame" title="Permalink to this definition"></a></dt>
<dd><p>Returns a constant reference to the <em>world</em> frame.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlantConfig">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">MultibodyPlantConfig</span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlantConfig" title="Permalink to this definition"></a></dt>
<dd><p>The set of configurable properties on a MultibodyPlant.</p>
<p>The field names and defaults here match MultibodyPlant’s defaults
exactly, with the exception of time_step.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlantConfig.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlantConfig" title="pydrake.multibody.plant.MultibodyPlantConfig"><span class="pre">pydrake.multibody.plant.MultibodyPlantConfig</span></a></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlantConfig.__init__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlantConfig.adjacent_bodies_collision_filters">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">adjacent_bodies_collision_filters</span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlantConfig.adjacent_bodies_collision_filters" title="Permalink to this definition"></a></dt>
<dd><p>Configures the
MultibodyPlant::set_adjacent_bodies_collision_filters().</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlantConfig.contact_model">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">contact_model</span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlantConfig.contact_model" title="Permalink to this definition"></a></dt>
<dd><p>Configures the MultibodyPlant::set_contact_model(). Refer to
drake::multibody::ContactModel for details. Valid strings are: -
“point” - “hydroelastic” - “hydroelastic_with_fallback”</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlantConfig.contact_surface_representation">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">contact_surface_representation</span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlantConfig.contact_surface_representation" title="Permalink to this definition"></a></dt>
<dd><p>Configures the MultibodyPlant::set_contact_surface_representation().
Refer to drake::geometry::HydroelasticContactRepresentation for
details. Valid strings are: - “triangle” - “polygon”</p>
<p>The default value used here is consistent with the default time_step
chosen above; keep this consistent with
MultibodyPlant::GetDefaultContactSurfaceRepresentation().</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlantConfig.discrete_contact_approximation">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">discrete_contact_approximation</span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlantConfig.discrete_contact_approximation" title="Permalink to this definition"></a></dt>
<dd><p>Configures the MultibodyPlant::set_discrete_contact_approximation().
Refer to drake::multibody::DiscreteContactApproximation for details.
Valid strings are: - “tamsi” - “sap” - “similar” - “lagged”</p>
<p>Refer to MultibodyPlant::set_discrete_contact_approximation() and the
references therein for further details.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If empty, the contact approximation is determined by
discrete_contact_solver, see set_discrete_contact_solver(). If
both discrete_contact_solver and discrete_contact_approximation
are empty, the default model (and solver) is TAMSI.</p>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlantConfig.discrete_contact_solver">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">discrete_contact_solver</span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlantConfig.discrete_contact_solver" title="Permalink to this definition"></a></dt>
<dd><p>Configures the MultibodyPlant::set_discrete_contact_solver(). Refer to
drake::multibody::DiscreteContactSolver for details. Valid strings
are: - “tamsi”, uses the TAMSI model approximation. - “sap” , uses the
SAP model approximation.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If empty, the contact solver is determined by
discrete_contact_approximation, see
MultibodyPlant::set_discrete_contact_approximation(). If both
discrete_contact_solver and discrete_contact_approximation are
empty, the default model (and solver) is TAMSI.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>discrete_contact_solver is deprecated. Use
discrete_contact_approximation to set the contact model
approximation. The underlying solver will be inferred
automatically. The deprecated code will be removed from Drake on
or after 2024-04-01.</p>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlantConfig.penetration_allowance">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">penetration_allowance</span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlantConfig.penetration_allowance" title="Permalink to this definition"></a></dt>
<dd><p>Configures the MultibodyPlant::set_penetration_allowance().</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlantConfig.sap_near_rigid_threshold">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">sap_near_rigid_threshold</span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlantConfig.sap_near_rigid_threshold" title="Permalink to this definition"></a></dt>
<dd><p>Non-negative dimensionless number typically in the range [0.0, 1.0],
though larger values are allowed even if uncommon. This parameter
controls the “near rigid” regime of the SAP solver, β in section V.B
of [Castro et al., 2021]. It essentially controls a threshold value
for the maximum amount of stiffness SAP can handle robustly. Beyond
this value, stiffness saturates as explained in [Castro et al., 2021].
A value of 1.0 is a conservative choice to avoid numerical
ill-conditioning. However, this might introduce artificial softening
of the contact constraints. If this is your case try: 1. Set this
parameter to zero. 2. For difficult problems (hundreds of contacts for
instance), you might need to use a low value if the solver fails to
converge. For instance, set values in the range (1e-3, 1e-2).</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlantConfig.stiction_tolerance">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">stiction_tolerance</span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlantConfig.stiction_tolerance" title="Permalink to this definition"></a></dt>
<dd><p>Configures the MultibodyPlant::set_stiction_tolerance().</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.multibody.plant.MultibodyPlantConfig.time_step">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">time_step</span></span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlantConfig.time_step" title="Permalink to this definition"></a></dt>
<dd><p>Configures the MultibodyPlant::MultibodyPlant() constructor time_step.</p>
<p>There is no default value for this within MultibodyPlant itself, so
here we choose a nominal value (a discrete system, with a 1ms periodic
update) as a reasonably conservative estimate that works in many
cases.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.multibody.plant.PhysicalModel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">PhysicalModel</span></span><a class="headerlink" href="#pydrake.multibody.plant.PhysicalModel" title="Permalink to this definition"></a></dt>
<dd><p>(Internal) PhysicalModel provides the functionalities to extend the
type of physical model of MultibodyPlant. Developers can derive from
this PhysicalModel to incorporate additional model elements coupled
with the rigid body dynamics. For instance, simulation of deformable
objects requires additional state and ports to interact with externals
systems such as visualization.</p>
<p>Similar to the routine of adding multiple model elements in
MultibodyPlant, users should add all the model elements they wish to
add to a PhysicalModel before the owning MultibodyPlant calls
<code class="docutils literal notranslate"><span class="pre">Finalize()</span></code>. When <code class="docutils literal notranslate"><span class="pre">Finalize()</span></code> is invoked, MultibodyPlant will
allocate the system level context resources for each PhysicalModel it
owns. After the system resources are allocated, model mutation in the
PhysicalModels owned by MultibodyPlant is not allowed.</p>
<p>This class is for internal use only. Use derived concrete models (e.g.
DeformableModel) instead.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.PhysicalModel.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.PhysicalModel.__init__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.multibody.plant.PointPairContactInfo">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">PointPairContactInfo</span></span><a class="headerlink" href="#pydrake.multibody.plant.PointPairContactInfo" title="Permalink to this definition"></a></dt>
<dd><p>A class containing information regarding contact response between two
bodies including:</p>
<ul class="simple">
<li><p>The pair of bodies that are contacting, referenced by their BodyIndex.</p></li>
<li><p>A resultant contact force.</p></li>
<li><p>A contact point.</p></li>
<li><p>Separation speed.</p></li>
<li><p>Slip speed.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <a class="reference internal" href="#pydrake.multibody.plant.PointPairContactInfo_" title="pydrake.multibody.plant.PointPairContactInfo_"><code class="xref py py-class docutils literal notranslate"><span class="pre">PointPairContactInfo_</span></code></a>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.PointPairContactInfo.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.PointPairContactInfo" title="pydrake.multibody.plant.PointPairContactInfo"><span class="pre">pydrake.multibody.plant.PointPairContactInfo</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">bodyA_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.BodyIndex" title="pydrake.multibody.tree.BodyIndex"><span class="pre">pydrake.multibody.tree.BodyIndex</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">bodyB_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.BodyIndex" title="pydrake.multibody.tree.BodyIndex"><span class="pre">pydrake.multibody.tree.BodyIndex</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">f_Bc_W</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_WC</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">separation_speed</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slip_speed</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_pair</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.PenetrationAsPointPair" title="pydrake.geometry.PenetrationAsPointPair"><span class="pre">pydrake.geometry.PenetrationAsPointPair</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.PointPairContactInfo.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Constructs the contact information for a given pair of two colliding
bodies.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">bodyA_index</span></code>:</dt><dd><p>Index that references body A in <code class="docutils literal notranslate"><span class="pre">this</span></code> contact pair.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">bodyB_index</span></code>:</dt><dd><p>Index that references body B in <code class="docutils literal notranslate"><span class="pre">this</span></code> contact pair.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">f_Bc_W</span></code>:</dt><dd><p>Force on body B applied at contact point C, expressed in the world
frame W.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_WC</span></code>:</dt><dd><p>Position of the contact point C in the world frame W.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">separation_speed</span></code>:</dt><dd><p>Separation speed along the normal direction between body A and
body B, in meters per second. A positive value indicates bodies
are moving apart. A negative value indicates bodies are moving
towards each other.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">slip_speed</span></code>:</dt><dd><p>Slip speed, that is, the magnitude of the relative tangential
velocity at the contact point in meters per second. A non-negative
value always.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">point_pair</span></code>:</dt><dd><p>Additional point pair information for <code class="docutils literal notranslate"><span class="pre">this</span></code> contact info. Refer
to the documentation for PenetrationAsPointPair for further
details. It is expected that the body indexed by <code class="docutils literal notranslate"><span class="pre">bodyA_index</span></code>
is the same body that contains the geometry indexed by
<code class="docutils literal notranslate"><span class="pre">point_pair.id_A</span></code>. Likewise for the body indexed by
<code class="docutils literal notranslate"><span class="pre">bodyB_index</span></code> and the body contining geometry with id
<code class="docutils literal notranslate"><span class="pre">point_pair.id_B</span></code>.</p>
</dd>
<dt>Precondition:</dt><dd><p>The two body indexes must reference bodies from the same
MultibodyPlant. Contact values should likewise be generated by the
same MultibodyPlant.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.PointPairContactInfo.bodyA_index">
<span class="sig-name descname"><span class="pre">bodyA_index</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.PointPairContactInfo" title="pydrake.multibody.plant.PointPairContactInfo"><span class="pre">pydrake.multibody.plant.PointPairContactInfo</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.BodyIndex" title="pydrake.multibody.tree.BodyIndex"><span class="pre">pydrake.multibody.tree.BodyIndex</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.PointPairContactInfo.bodyA_index" title="Permalink to this definition"></a></dt>
<dd><p>Returns the index of body A in the contact pair.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.PointPairContactInfo.bodyB_index">
<span class="sig-name descname"><span class="pre">bodyB_index</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.PointPairContactInfo" title="pydrake.multibody.plant.PointPairContactInfo"><span class="pre">pydrake.multibody.plant.PointPairContactInfo</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.BodyIndex" title="pydrake.multibody.tree.BodyIndex"><span class="pre">pydrake.multibody.tree.BodyIndex</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.PointPairContactInfo.bodyB_index" title="Permalink to this definition"></a></dt>
<dd><p>Returns the index of body B in the contact pair.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.PointPairContactInfo.contact_force">
<span class="sig-name descname"><span class="pre">contact_force</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.PointPairContactInfo" title="pydrake.multibody.plant.PointPairContactInfo"><span class="pre">pydrake.multibody.plant.PointPairContactInfo</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.PointPairContactInfo.contact_force" title="Permalink to this definition"></a></dt>
<dd><p>Returns the contact force <code class="docutils literal notranslate"><span class="pre">f_Bc_W</span></code> on B at contact point C expressed
in the world frame W.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.PointPairContactInfo.contact_point">
<span class="sig-name descname"><span class="pre">contact_point</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.PointPairContactInfo" title="pydrake.multibody.plant.PointPairContactInfo"><span class="pre">pydrake.multibody.plant.PointPairContactInfo</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.PointPairContactInfo.contact_point" title="Permalink to this definition"></a></dt>
<dd><p>Returns the position <code class="docutils literal notranslate"><span class="pre">p_WC</span></code> of the contact point C in the world
frame W.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.PointPairContactInfo.point_pair">
<span class="sig-name descname"><span class="pre">point_pair</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.PointPairContactInfo" title="pydrake.multibody.plant.PointPairContactInfo"><span class="pre">pydrake.multibody.plant.PointPairContactInfo</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.PenetrationAsPointPair" title="pydrake.geometry.PenetrationAsPointPair"><span class="pre">pydrake.geometry.PenetrationAsPointPair</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.PointPairContactInfo.point_pair" title="Permalink to this definition"></a></dt>
<dd><p>Returns additional information for the geometric contact query for
<code class="docutils literal notranslate"><span class="pre">this</span></code> pair as a PenetrationAsPointPair. The body containing
<code class="docutils literal notranslate"><span class="pre">point_pair().id_A</span></code> is the same body indexed by <code class="docutils literal notranslate"><span class="pre">bodyA_index()</span></code>.
Likewise, the body containing <code class="docutils literal notranslate"><span class="pre">point_pair().id_B</span></code> is the same body
indexed by <code class="docutils literal notranslate"><span class="pre">bodyB_index()</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.PointPairContactInfo.separation_speed">
<span class="sig-name descname"><span class="pre">separation_speed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.PointPairContactInfo" title="pydrake.multibody.plant.PointPairContactInfo"><span class="pre">pydrake.multibody.plant.PointPairContactInfo</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.PointPairContactInfo.separation_speed" title="Permalink to this definition"></a></dt>
<dd><p>Returns the separation speed between body A and B along the normal
direction (see PenetrationAsPointPair::nhat_BA_W) at the contact
point. It is defined positive for bodies moving apart in the normal
direction.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.PointPairContactInfo.slip_speed">
<span class="sig-name descname"><span class="pre">slip_speed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.PointPairContactInfo" title="pydrake.multibody.plant.PointPairContactInfo"><span class="pre">pydrake.multibody.plant.PointPairContactInfo</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.PointPairContactInfo.slip_speed" title="Permalink to this definition"></a></dt>
<dd><p>Returns the slip speed between body A and B at contact point C.</p>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py" id="pydrake.multibody.plant.PointPairContactInfo_">
<em class="property"><span class="pre">template</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">PointPairContactInfo_</span></span><a class="headerlink" href="#pydrake.multibody.plant.PointPairContactInfo_" title="Permalink to this definition"></a></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">PointPairContactInfo_[float]</span></code>, <a class="reference internal" href="#pydrake.multibody.plant.PointPairContactInfo_-AutoDiffXd" title="pydrake.multibody.plant.PointPairContactInfo_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">PointPairContactInfo_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.plant.PointPairContactInfo_-Expression" title="pydrake.multibody.plant.PointPairContactInfo_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">PointPairContactInfo_[Expression]</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.multibody.plant.PointPairContactInfo_-AutoDiffXd">
<span id="pydrake.multibody.plant.PointPairContactInfo_[AutoDiffXd]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">PointPairContactInfo_[AutoDiffXd]</span></span><a class="headerlink" href="#pydrake.multibody.plant.PointPairContactInfo_-AutoDiffXd" title="Permalink to this definition"></a></dt>
<dd><p>A class containing information regarding contact response between two
bodies including:</p>
<ul class="simple">
<li><p>The pair of bodies that are contacting, referenced by their BodyIndex.</p></li>
<li><p>A resultant contact force.</p></li>
<li><p>A contact point.</p></li>
<li><p>Separation speed.</p></li>
<li><p>Slip speed.</p></li>
</ul>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.PointPairContactInfo_-AutoDiffXd-.__init__">
<span id="pydrake.multibody.plant.PointPairContactInfo_[AutoDiffXd].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.PointPairContactInfo_" title="pydrake.multibody.plant.PointPairContactInfo_"><span class="pre">pydrake.multibody.plant.PointPairContactInfo_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bodyA_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.BodyIndex" title="pydrake.multibody.tree.BodyIndex"><span class="pre">pydrake.multibody.tree.BodyIndex</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">bodyB_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.BodyIndex" title="pydrake.multibody.tree.BodyIndex"><span class="pre">pydrake.multibody.tree.BodyIndex</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">f_Bc_W</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_WC</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">separation_speed</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">pydrake.autodiffutils.AutoDiffXd</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">slip_speed</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">pydrake.autodiffutils.AutoDiffXd</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_pair</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.PenetrationAsPointPair_" title="pydrake.geometry.PenetrationAsPointPair_"><span class="pre">pydrake.geometry.PenetrationAsPointPair_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.PointPairContactInfo_-AutoDiffXd-.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Constructs the contact information for a given pair of two colliding
bodies.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">bodyA_index</span></code>:</dt><dd><p>Index that references body A in <code class="docutils literal notranslate"><span class="pre">this</span></code> contact pair.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">bodyB_index</span></code>:</dt><dd><p>Index that references body B in <code class="docutils literal notranslate"><span class="pre">this</span></code> contact pair.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">f_Bc_W</span></code>:</dt><dd><p>Force on body B applied at contact point C, expressed in the world
frame W.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_WC</span></code>:</dt><dd><p>Position of the contact point C in the world frame W.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">separation_speed</span></code>:</dt><dd><p>Separation speed along the normal direction between body A and
body B, in meters per second. A positive value indicates bodies
are moving apart. A negative value indicates bodies are moving
towards each other.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">slip_speed</span></code>:</dt><dd><p>Slip speed, that is, the magnitude of the relative tangential
velocity at the contact point in meters per second. A non-negative
value always.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">point_pair</span></code>:</dt><dd><p>Additional point pair information for <code class="docutils literal notranslate"><span class="pre">this</span></code> contact info. Refer
to the documentation for PenetrationAsPointPair for further
details. It is expected that the body indexed by <code class="docutils literal notranslate"><span class="pre">bodyA_index</span></code>
is the same body that contains the geometry indexed by
<code class="docutils literal notranslate"><span class="pre">point_pair.id_A</span></code>. Likewise for the body indexed by
<code class="docutils literal notranslate"><span class="pre">bodyB_index</span></code> and the body contining geometry with id
<code class="docutils literal notranslate"><span class="pre">point_pair.id_B</span></code>.</p>
</dd>
<dt>Precondition:</dt><dd><p>The two body indexes must reference bodies from the same
MultibodyPlant. Contact values should likewise be generated by the
same MultibodyPlant.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.PointPairContactInfo_-AutoDiffXd-.bodyA_index">
<span id="pydrake.multibody.plant.PointPairContactInfo_[AutoDiffXd].bodyA_index"></span><span class="sig-name descname"><span class="pre">bodyA_index</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.PointPairContactInfo_" title="pydrake.multibody.plant.PointPairContactInfo_"><span class="pre">pydrake.multibody.plant.PointPairContactInfo_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.BodyIndex" title="pydrake.multibody.tree.BodyIndex"><span class="pre">pydrake.multibody.tree.BodyIndex</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.PointPairContactInfo_-AutoDiffXd-.bodyA_index" title="Permalink to this definition"></a></dt>
<dd><p>Returns the index of body A in the contact pair.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.PointPairContactInfo_-AutoDiffXd-.bodyB_index">
<span id="pydrake.multibody.plant.PointPairContactInfo_[AutoDiffXd].bodyB_index"></span><span class="sig-name descname"><span class="pre">bodyB_index</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.PointPairContactInfo_" title="pydrake.multibody.plant.PointPairContactInfo_"><span class="pre">pydrake.multibody.plant.PointPairContactInfo_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.BodyIndex" title="pydrake.multibody.tree.BodyIndex"><span class="pre">pydrake.multibody.tree.BodyIndex</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.PointPairContactInfo_-AutoDiffXd-.bodyB_index" title="Permalink to this definition"></a></dt>
<dd><p>Returns the index of body B in the contact pair.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.PointPairContactInfo_-AutoDiffXd-.contact_force">
<span id="pydrake.multibody.plant.PointPairContactInfo_[AutoDiffXd].contact_force"></span><span class="sig-name descname"><span class="pre">contact_force</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.PointPairContactInfo_" title="pydrake.multibody.plant.PointPairContactInfo_"><span class="pre">pydrake.multibody.plant.PointPairContactInfo_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.PointPairContactInfo_-AutoDiffXd-.contact_force" title="Permalink to this definition"></a></dt>
<dd><p>Returns the contact force <code class="docutils literal notranslate"><span class="pre">f_Bc_W</span></code> on B at contact point C expressed
in the world frame W.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.PointPairContactInfo_-AutoDiffXd-.contact_point">
<span id="pydrake.multibody.plant.PointPairContactInfo_[AutoDiffXd].contact_point"></span><span class="sig-name descname"><span class="pre">contact_point</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.PointPairContactInfo_" title="pydrake.multibody.plant.PointPairContactInfo_"><span class="pre">pydrake.multibody.plant.PointPairContactInfo_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.PointPairContactInfo_-AutoDiffXd-.contact_point" title="Permalink to this definition"></a></dt>
<dd><p>Returns the position <code class="docutils literal notranslate"><span class="pre">p_WC</span></code> of the contact point C in the world
frame W.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.PointPairContactInfo_-AutoDiffXd-.point_pair">
<span id="pydrake.multibody.plant.PointPairContactInfo_[AutoDiffXd].point_pair"></span><span class="sig-name descname"><span class="pre">point_pair</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.PointPairContactInfo_" title="pydrake.multibody.plant.PointPairContactInfo_"><span class="pre">pydrake.multibody.plant.PointPairContactInfo_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.PenetrationAsPointPair_" title="pydrake.geometry.PenetrationAsPointPair_"><span class="pre">pydrake.geometry.PenetrationAsPointPair_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.PointPairContactInfo_-AutoDiffXd-.point_pair" title="Permalink to this definition"></a></dt>
<dd><p>Returns additional information for the geometric contact query for
<code class="docutils literal notranslate"><span class="pre">this</span></code> pair as a PenetrationAsPointPair. The body containing
<code class="docutils literal notranslate"><span class="pre">point_pair().id_A</span></code> is the same body indexed by <code class="docutils literal notranslate"><span class="pre">bodyA_index()</span></code>.
Likewise, the body containing <code class="docutils literal notranslate"><span class="pre">point_pair().id_B</span></code> is the same body
indexed by <code class="docutils literal notranslate"><span class="pre">bodyB_index()</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.PointPairContactInfo_-AutoDiffXd-.separation_speed">
<span id="pydrake.multibody.plant.PointPairContactInfo_[AutoDiffXd].separation_speed"></span><span class="sig-name descname"><span class="pre">separation_speed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.PointPairContactInfo_" title="pydrake.multibody.plant.PointPairContactInfo_"><span class="pre">pydrake.multibody.plant.PointPairContactInfo_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">pydrake.autodiffutils.AutoDiffXd</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.PointPairContactInfo_-AutoDiffXd-.separation_speed" title="Permalink to this definition"></a></dt>
<dd><p>Returns the separation speed between body A and B along the normal
direction (see PenetrationAsPointPair::nhat_BA_W) at the contact
point. It is defined positive for bodies moving apart in the normal
direction.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.PointPairContactInfo_-AutoDiffXd-.slip_speed">
<span id="pydrake.multibody.plant.PointPairContactInfo_[AutoDiffXd].slip_speed"></span><span class="sig-name descname"><span class="pre">slip_speed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.PointPairContactInfo_" title="pydrake.multibody.plant.PointPairContactInfo_"><span class="pre">pydrake.multibody.plant.PointPairContactInfo_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">pydrake.autodiffutils.AutoDiffXd</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.PointPairContactInfo_-AutoDiffXd-.slip_speed" title="Permalink to this definition"></a></dt>
<dd><p>Returns the slip speed between body A and B at contact point C.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.multibody.plant.PointPairContactInfo_-Expression">
<span id="pydrake.multibody.plant.PointPairContactInfo_[Expression]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">PointPairContactInfo_[Expression]</span></span><a class="headerlink" href="#pydrake.multibody.plant.PointPairContactInfo_-Expression" title="Permalink to this definition"></a></dt>
<dd><p>A class containing information regarding contact response between two
bodies including:</p>
<ul class="simple">
<li><p>The pair of bodies that are contacting, referenced by their BodyIndex.</p></li>
<li><p>A resultant contact force.</p></li>
<li><p>A contact point.</p></li>
<li><p>Separation speed.</p></li>
<li><p>Slip speed.</p></li>
</ul>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.PointPairContactInfo_-Expression-.__init__">
<span id="pydrake.multibody.plant.PointPairContactInfo_[Expression].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.PointPairContactInfo_" title="pydrake.multibody.plant.PointPairContactInfo_"><span class="pre">pydrake.multibody.plant.PointPairContactInfo_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bodyA_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.BodyIndex" title="pydrake.multibody.tree.BodyIndex"><span class="pre">pydrake.multibody.tree.BodyIndex</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">bodyB_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.BodyIndex" title="pydrake.multibody.tree.BodyIndex"><span class="pre">pydrake.multibody.tree.BodyIndex</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">f_Bc_W</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_WC</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">separation_speed</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">pydrake.symbolic.Expression</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">slip_speed</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">pydrake.symbolic.Expression</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_pair</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.PenetrationAsPointPair_" title="pydrake.geometry.PenetrationAsPointPair_"><span class="pre">pydrake.geometry.PenetrationAsPointPair_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.PointPairContactInfo_-Expression-.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Constructs the contact information for a given pair of two colliding
bodies.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">bodyA_index</span></code>:</dt><dd><p>Index that references body A in <code class="docutils literal notranslate"><span class="pre">this</span></code> contact pair.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">bodyB_index</span></code>:</dt><dd><p>Index that references body B in <code class="docutils literal notranslate"><span class="pre">this</span></code> contact pair.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">f_Bc_W</span></code>:</dt><dd><p>Force on body B applied at contact point C, expressed in the world
frame W.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_WC</span></code>:</dt><dd><p>Position of the contact point C in the world frame W.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">separation_speed</span></code>:</dt><dd><p>Separation speed along the normal direction between body A and
body B, in meters per second. A positive value indicates bodies
are moving apart. A negative value indicates bodies are moving
towards each other.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">slip_speed</span></code>:</dt><dd><p>Slip speed, that is, the magnitude of the relative tangential
velocity at the contact point in meters per second. A non-negative
value always.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">point_pair</span></code>:</dt><dd><p>Additional point pair information for <code class="docutils literal notranslate"><span class="pre">this</span></code> contact info. Refer
to the documentation for PenetrationAsPointPair for further
details. It is expected that the body indexed by <code class="docutils literal notranslate"><span class="pre">bodyA_index</span></code>
is the same body that contains the geometry indexed by
<code class="docutils literal notranslate"><span class="pre">point_pair.id_A</span></code>. Likewise for the body indexed by
<code class="docutils literal notranslate"><span class="pre">bodyB_index</span></code> and the body contining geometry with id
<code class="docutils literal notranslate"><span class="pre">point_pair.id_B</span></code>.</p>
</dd>
<dt>Precondition:</dt><dd><p>The two body indexes must reference bodies from the same
MultibodyPlant. Contact values should likewise be generated by the
same MultibodyPlant.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.PointPairContactInfo_-Expression-.bodyA_index">
<span id="pydrake.multibody.plant.PointPairContactInfo_[Expression].bodyA_index"></span><span class="sig-name descname"><span class="pre">bodyA_index</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.PointPairContactInfo_" title="pydrake.multibody.plant.PointPairContactInfo_"><span class="pre">pydrake.multibody.plant.PointPairContactInfo_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.BodyIndex" title="pydrake.multibody.tree.BodyIndex"><span class="pre">pydrake.multibody.tree.BodyIndex</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.PointPairContactInfo_-Expression-.bodyA_index" title="Permalink to this definition"></a></dt>
<dd><p>Returns the index of body A in the contact pair.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.PointPairContactInfo_-Expression-.bodyB_index">
<span id="pydrake.multibody.plant.PointPairContactInfo_[Expression].bodyB_index"></span><span class="sig-name descname"><span class="pre">bodyB_index</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.PointPairContactInfo_" title="pydrake.multibody.plant.PointPairContactInfo_"><span class="pre">pydrake.multibody.plant.PointPairContactInfo_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.BodyIndex" title="pydrake.multibody.tree.BodyIndex"><span class="pre">pydrake.multibody.tree.BodyIndex</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.PointPairContactInfo_-Expression-.bodyB_index" title="Permalink to this definition"></a></dt>
<dd><p>Returns the index of body B in the contact pair.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.PointPairContactInfo_-Expression-.contact_force">
<span id="pydrake.multibody.plant.PointPairContactInfo_[Expression].contact_force"></span><span class="sig-name descname"><span class="pre">contact_force</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.PointPairContactInfo_" title="pydrake.multibody.plant.PointPairContactInfo_"><span class="pre">pydrake.multibody.plant.PointPairContactInfo_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.PointPairContactInfo_-Expression-.contact_force" title="Permalink to this definition"></a></dt>
<dd><p>Returns the contact force <code class="docutils literal notranslate"><span class="pre">f_Bc_W</span></code> on B at contact point C expressed
in the world frame W.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.PointPairContactInfo_-Expression-.contact_point">
<span id="pydrake.multibody.plant.PointPairContactInfo_[Expression].contact_point"></span><span class="sig-name descname"><span class="pre">contact_point</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.PointPairContactInfo_" title="pydrake.multibody.plant.PointPairContactInfo_"><span class="pre">pydrake.multibody.plant.PointPairContactInfo_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.PointPairContactInfo_-Expression-.contact_point" title="Permalink to this definition"></a></dt>
<dd><p>Returns the position <code class="docutils literal notranslate"><span class="pre">p_WC</span></code> of the contact point C in the world
frame W.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.PointPairContactInfo_-Expression-.point_pair">
<span id="pydrake.multibody.plant.PointPairContactInfo_[Expression].point_pair"></span><span class="sig-name descname"><span class="pre">point_pair</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.PointPairContactInfo_" title="pydrake.multibody.plant.PointPairContactInfo_"><span class="pre">pydrake.multibody.plant.PointPairContactInfo_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.PenetrationAsPointPair_" title="pydrake.geometry.PenetrationAsPointPair_"><span class="pre">pydrake.geometry.PenetrationAsPointPair_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.PointPairContactInfo_-Expression-.point_pair" title="Permalink to this definition"></a></dt>
<dd><p>Returns additional information for the geometric contact query for
<code class="docutils literal notranslate"><span class="pre">this</span></code> pair as a PenetrationAsPointPair. The body containing
<code class="docutils literal notranslate"><span class="pre">point_pair().id_A</span></code> is the same body indexed by <code class="docutils literal notranslate"><span class="pre">bodyA_index()</span></code>.
Likewise, the body containing <code class="docutils literal notranslate"><span class="pre">point_pair().id_B</span></code> is the same body
indexed by <code class="docutils literal notranslate"><span class="pre">bodyB_index()</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.PointPairContactInfo_-Expression-.separation_speed">
<span id="pydrake.multibody.plant.PointPairContactInfo_[Expression].separation_speed"></span><span class="sig-name descname"><span class="pre">separation_speed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.PointPairContactInfo_" title="pydrake.multibody.plant.PointPairContactInfo_"><span class="pre">pydrake.multibody.plant.PointPairContactInfo_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">pydrake.symbolic.Expression</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.PointPairContactInfo_-Expression-.separation_speed" title="Permalink to this definition"></a></dt>
<dd><p>Returns the separation speed between body A and B along the normal
direction (see PenetrationAsPointPair::nhat_BA_W) at the contact
point. It is defined positive for bodies moving apart in the normal
direction.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.PointPairContactInfo_-Expression-.slip_speed">
<span id="pydrake.multibody.plant.PointPairContactInfo_[Expression].slip_speed"></span><span class="sig-name descname"><span class="pre">slip_speed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.PointPairContactInfo_" title="pydrake.multibody.plant.PointPairContactInfo_"><span class="pre">pydrake.multibody.plant.PointPairContactInfo_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">pydrake.symbolic.Expression</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.PointPairContactInfo_-Expression-.slip_speed" title="Permalink to this definition"></a></dt>
<dd><p>Returns the slip speed between body A and B at contact point C.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.multibody.plant.Propeller">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">Propeller</span></span><a class="headerlink" href="#pydrake.multibody.plant.Propeller" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.LeafSystem" title="pydrake.systems.framework.LeafSystem"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem</span></code></a></p>
<p>A System that connects to the MultibodyPlant in order to model the
effects of one or more controlled propellers acting on a Body.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">command&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">body_poses&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>Propeller</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; spatial_forces</td></tr></table></td></tr></table><ul class="simple">
<li><p>The command input is a BasicVector&lt;T&gt; with one element per propeller.</p></li>
<li><p>It is expected that the body_poses input should be connected to the</p></li>
</ul>
<p>MultibodyPlant::get_body_poses_output_port() “MultibodyPlant body_poses
output port”.
- The output is of type std::vector&lt;ExternallyAppliedSpatialForce&lt;T&gt;&gt;; it is
expected that this output will be connected to the MultibodyPlant::get_applied_spatial_force_input_port()
“externally_applied_spatial_force input port” of the MultibodyPlant.
- This system does not have any state.</p>
<p>The resulting iᵗʰ spatial force will have a force component in the
z-axis of the iᵗʰ propeller frame with magnitude <code class="docutils literal notranslate"><span class="pre">thrust_ratio</span> <span class="pre">*</span>
<span class="pre">command</span></code> Newtons, and a moment around the z-axis with magnitude
<code class="docutils literal notranslate"><span class="pre">moment_ratio</span> <span class="pre">*</span> <span class="pre">command</span></code> Newton-meters. (Including these moments
tends to be important – a quadrotor does not have a stabilizable
linearization around a hovering fixed point in 3D without them).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Set PropellerInfo::moment_ratio to zero if you want a simple
thruster which applies only a force (no moment) in the Propeller
coordinates.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <a class="reference internal" href="#pydrake.multibody.plant.Propeller_" title="pydrake.multibody.plant.Propeller_"><code class="xref py py-class docutils literal notranslate"><span class="pre">Propeller_</span></code></a>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.Propeller.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.Propeller.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.multibody.plant.Propeller, body_index: pydrake.multibody.tree.BodyIndex, X_BP: pydrake.math.RigidTransform = RigidTransform(</p></li>
</ol>
<blockquote>
<div><dl class="simple">
<dt>R=RotationMatrix([</dt><dd><p>[1.0, 0.0, 0.0],
[0.0, 1.0, 0.0],
[0.0, 0.0, 1.0],</p>
</dd>
</dl>
<p>]),
p=[0.0, 0.0, 0.0],</p>
</div></blockquote>
<p>), thrust_ratio: float = 1.0, moment_ratio: float = 0.0) -&gt; None</p>
<p>Constructs a system describing a single propeller.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>PropellerInfo for details on the arguments.</p>
</div>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.multibody.plant.Propeller, propeller_info: List[pydrake.multibody.plant.PropellerInfo]) -&gt; None</p></li>
</ol>
<p>Constructs a system describing multiple propellers.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>PropellerInfo.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.Propeller.get_body_poses_input_port">
<span class="sig-name descname"><span class="pre">get_body_poses_input_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.Propeller" title="pydrake.multibody.plant.Propeller"><span class="pre">pydrake.multibody.plant.Propeller</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.InputPort" title="pydrake.systems.framework.InputPort"><span class="pre">pydrake.systems.framework.InputPort</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.Propeller.get_body_poses_input_port" title="Permalink to this definition"></a></dt>
<dd><p>Returns a reference to the body_poses input port. It is anticipated
that this port will be connected the body_poses output port of a
MultibodyPlant.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.Propeller.get_command_input_port">
<span class="sig-name descname"><span class="pre">get_command_input_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.Propeller" title="pydrake.multibody.plant.Propeller"><span class="pre">pydrake.multibody.plant.Propeller</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.InputPort" title="pydrake.systems.framework.InputPort"><span class="pre">pydrake.systems.framework.InputPort</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.Propeller.get_command_input_port" title="Permalink to this definition"></a></dt>
<dd><p>Returns a reference to the vector-valued input port for the propeller
commands. It has size <code class="docutils literal notranslate"><span class="pre">num_propellers()</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.Propeller.get_spatial_forces_output_port">
<span class="sig-name descname"><span class="pre">get_spatial_forces_output_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.Propeller" title="pydrake.multibody.plant.Propeller"><span class="pre">pydrake.multibody.plant.Propeller</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.OutputPort" title="pydrake.systems.framework.OutputPort"><span class="pre">pydrake.systems.framework.OutputPort</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.Propeller.get_spatial_forces_output_port" title="Permalink to this definition"></a></dt>
<dd><p>Returns a reference to the spatial_forces output port. It is
anticipated that this port will be connected to the
MultibodyPlant::get_applied_spatial_force_input_port()
“applied_spatial_force” input port of a MultibodyPlant.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.Propeller.num_propellers">
<span class="sig-name descname"><span class="pre">num_propellers</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.Propeller" title="pydrake.multibody.plant.Propeller"><span class="pre">pydrake.multibody.plant.Propeller</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.Propeller.num_propellers" title="Permalink to this definition"></a></dt>
<dd><p>Returns the number of propellers modeled by this system.</p>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py" id="pydrake.multibody.plant.Propeller_">
<em class="property"><span class="pre">template</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">Propeller_</span></span><a class="headerlink" href="#pydrake.multibody.plant.Propeller_" title="Permalink to this definition"></a></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">Propeller_[float]</span></code>, <a class="reference internal" href="#pydrake.multibody.plant.Propeller_-AutoDiffXd" title="pydrake.multibody.plant.Propeller_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">Propeller_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.plant.Propeller_-Expression" title="pydrake.multibody.plant.Propeller_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">Propeller_[Expression]</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.multibody.plant.Propeller_-AutoDiffXd">
<span id="pydrake.multibody.plant.Propeller_[AutoDiffXd]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">Propeller_[AutoDiffXd]</span></span><a class="headerlink" href="#pydrake.multibody.plant.Propeller_-AutoDiffXd" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.LeafSystem_-AutoDiffXd" title="pydrake.systems.framework.LeafSystem_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem_[AutoDiffXd]</span></code></a></p>
<p>A System that connects to the MultibodyPlant in order to model the
effects of one or more controlled propellers acting on a Body.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">command&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">body_poses&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>Propeller</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; spatial_forces</td></tr></table></td></tr></table><ul class="simple">
<li><p>The command input is a BasicVector&lt;T&gt; with one element per propeller.</p></li>
<li><p>It is expected that the body_poses input should be connected to the</p></li>
</ul>
<p>MultibodyPlant::get_body_poses_output_port() “MultibodyPlant body_poses
output port”.
- The output is of type std::vector&lt;ExternallyAppliedSpatialForce&lt;T&gt;&gt;; it is
expected that this output will be connected to the MultibodyPlant::get_applied_spatial_force_input_port()
“externally_applied_spatial_force input port” of the MultibodyPlant.
- This system does not have any state.</p>
<p>The resulting iᵗʰ spatial force will have a force component in the
z-axis of the iᵗʰ propeller frame with magnitude <code class="docutils literal notranslate"><span class="pre">thrust_ratio</span> <span class="pre">*</span>
<span class="pre">command</span></code> Newtons, and a moment around the z-axis with magnitude
<code class="docutils literal notranslate"><span class="pre">moment_ratio</span> <span class="pre">*</span> <span class="pre">command</span></code> Newton-meters. (Including these moments
tends to be important – a quadrotor does not have a stabilizable
linearization around a hovering fixed point in 3D without them).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Set PropellerInfo::moment_ratio to zero if you want a simple
thruster which applies only a force (no moment) in the Propeller
coordinates.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.Propeller_-AutoDiffXd-.__init__">
<span id="pydrake.multibody.plant.Propeller_[AutoDiffXd].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.Propeller_-AutoDiffXd-.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.multibody.plant.Propeller_[AutoDiffXd], body_index: pydrake.multibody.tree.BodyIndex, X_BP: pydrake.math.RigidTransform = RigidTransform(</p></li>
</ol>
<blockquote>
<div><dl class="simple">
<dt>R=RotationMatrix([</dt><dd><p>[1.0, 0.0, 0.0],
[0.0, 1.0, 0.0],
[0.0, 0.0, 1.0],</p>
</dd>
</dl>
<p>]),
p=[0.0, 0.0, 0.0],</p>
</div></blockquote>
<p>), thrust_ratio: float = 1.0, moment_ratio: float = 0.0) -&gt; None</p>
<p>Constructs a system describing a single propeller.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>PropellerInfo for details on the arguments.</p>
</div>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.multibody.plant.Propeller_[AutoDiffXd], propeller_info: List[pydrake.multibody.plant.PropellerInfo]) -&gt; None</p></li>
</ol>
<p>Constructs a system describing multiple propellers.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>PropellerInfo.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.Propeller_-AutoDiffXd-.get_body_poses_input_port">
<span id="pydrake.multibody.plant.Propeller_[AutoDiffXd].get_body_poses_input_port"></span><span class="sig-name descname"><span class="pre">get_body_poses_input_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.Propeller_" title="pydrake.multibody.plant.Propeller_"><span class="pre">pydrake.multibody.plant.Propeller_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.InputPort_" title="pydrake.systems.framework.InputPort_"><span class="pre">pydrake.systems.framework.InputPort_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.Propeller_-AutoDiffXd-.get_body_poses_input_port" title="Permalink to this definition"></a></dt>
<dd><p>Returns a reference to the body_poses input port. It is anticipated
that this port will be connected the body_poses output port of a
MultibodyPlant.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.Propeller_-AutoDiffXd-.get_command_input_port">
<span id="pydrake.multibody.plant.Propeller_[AutoDiffXd].get_command_input_port"></span><span class="sig-name descname"><span class="pre">get_command_input_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.Propeller_" title="pydrake.multibody.plant.Propeller_"><span class="pre">pydrake.multibody.plant.Propeller_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.InputPort_" title="pydrake.systems.framework.InputPort_"><span class="pre">pydrake.systems.framework.InputPort_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.Propeller_-AutoDiffXd-.get_command_input_port" title="Permalink to this definition"></a></dt>
<dd><p>Returns a reference to the vector-valued input port for the propeller
commands. It has size <code class="docutils literal notranslate"><span class="pre">num_propellers()</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.Propeller_-AutoDiffXd-.get_spatial_forces_output_port">
<span id="pydrake.multibody.plant.Propeller_[AutoDiffXd].get_spatial_forces_output_port"></span><span class="sig-name descname"><span class="pre">get_spatial_forces_output_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.Propeller_" title="pydrake.multibody.plant.Propeller_"><span class="pre">pydrake.multibody.plant.Propeller_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.OutputPort_" title="pydrake.systems.framework.OutputPort_"><span class="pre">pydrake.systems.framework.OutputPort_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.Propeller_-AutoDiffXd-.get_spatial_forces_output_port" title="Permalink to this definition"></a></dt>
<dd><p>Returns a reference to the spatial_forces output port. It is
anticipated that this port will be connected to the
MultibodyPlant::get_applied_spatial_force_input_port()
“applied_spatial_force” input port of a MultibodyPlant.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.Propeller_-AutoDiffXd-.num_propellers">
<span id="pydrake.multibody.plant.Propeller_[AutoDiffXd].num_propellers"></span><span class="sig-name descname"><span class="pre">num_propellers</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.Propeller_" title="pydrake.multibody.plant.Propeller_"><span class="pre">pydrake.multibody.plant.Propeller_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.Propeller_-AutoDiffXd-.num_propellers" title="Permalink to this definition"></a></dt>
<dd><p>Returns the number of propellers modeled by this system.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.multibody.plant.Propeller_-Expression">
<span id="pydrake.multibody.plant.Propeller_[Expression]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">Propeller_[Expression]</span></span><a class="headerlink" href="#pydrake.multibody.plant.Propeller_-Expression" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.LeafSystem_-Expression" title="pydrake.systems.framework.LeafSystem_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem_[Expression]</span></code></a></p>
<p>A System that connects to the MultibodyPlant in order to model the
effects of one or more controlled propellers acting on a Body.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">command&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">body_poses&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>Propeller</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; spatial_forces</td></tr></table></td></tr></table><ul class="simple">
<li><p>The command input is a BasicVector&lt;T&gt; with one element per propeller.</p></li>
<li><p>It is expected that the body_poses input should be connected to the</p></li>
</ul>
<p>MultibodyPlant::get_body_poses_output_port() “MultibodyPlant body_poses
output port”.
- The output is of type std::vector&lt;ExternallyAppliedSpatialForce&lt;T&gt;&gt;; it is
expected that this output will be connected to the MultibodyPlant::get_applied_spatial_force_input_port()
“externally_applied_spatial_force input port” of the MultibodyPlant.
- This system does not have any state.</p>
<p>The resulting iᵗʰ spatial force will have a force component in the
z-axis of the iᵗʰ propeller frame with magnitude <code class="docutils literal notranslate"><span class="pre">thrust_ratio</span> <span class="pre">*</span>
<span class="pre">command</span></code> Newtons, and a moment around the z-axis with magnitude
<code class="docutils literal notranslate"><span class="pre">moment_ratio</span> <span class="pre">*</span> <span class="pre">command</span></code> Newton-meters. (Including these moments
tends to be important – a quadrotor does not have a stabilizable
linearization around a hovering fixed point in 3D without them).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Set PropellerInfo::moment_ratio to zero if you want a simple
thruster which applies only a force (no moment) in the Propeller
coordinates.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.Propeller_-Expression-.__init__">
<span id="pydrake.multibody.plant.Propeller_[Expression].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.Propeller_-Expression-.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.multibody.plant.Propeller_[Expression], body_index: pydrake.multibody.tree.BodyIndex, X_BP: pydrake.math.RigidTransform = RigidTransform(</p></li>
</ol>
<blockquote>
<div><dl class="simple">
<dt>R=RotationMatrix([</dt><dd><p>[1.0, 0.0, 0.0],
[0.0, 1.0, 0.0],
[0.0, 0.0, 1.0],</p>
</dd>
</dl>
<p>]),
p=[0.0, 0.0, 0.0],</p>
</div></blockquote>
<p>), thrust_ratio: float = 1.0, moment_ratio: float = 0.0) -&gt; None</p>
<p>Constructs a system describing a single propeller.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>PropellerInfo for details on the arguments.</p>
</div>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.multibody.plant.Propeller_[Expression], propeller_info: List[pydrake.multibody.plant.PropellerInfo]) -&gt; None</p></li>
</ol>
<p>Constructs a system describing multiple propellers.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>PropellerInfo.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.Propeller_-Expression-.get_body_poses_input_port">
<span id="pydrake.multibody.plant.Propeller_[Expression].get_body_poses_input_port"></span><span class="sig-name descname"><span class="pre">get_body_poses_input_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.Propeller_" title="pydrake.multibody.plant.Propeller_"><span class="pre">pydrake.multibody.plant.Propeller_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.InputPort_" title="pydrake.systems.framework.InputPort_"><span class="pre">pydrake.systems.framework.InputPort_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.Propeller_-Expression-.get_body_poses_input_port" title="Permalink to this definition"></a></dt>
<dd><p>Returns a reference to the body_poses input port. It is anticipated
that this port will be connected the body_poses output port of a
MultibodyPlant.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.Propeller_-Expression-.get_command_input_port">
<span id="pydrake.multibody.plant.Propeller_[Expression].get_command_input_port"></span><span class="sig-name descname"><span class="pre">get_command_input_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.Propeller_" title="pydrake.multibody.plant.Propeller_"><span class="pre">pydrake.multibody.plant.Propeller_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.InputPort_" title="pydrake.systems.framework.InputPort_"><span class="pre">pydrake.systems.framework.InputPort_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.Propeller_-Expression-.get_command_input_port" title="Permalink to this definition"></a></dt>
<dd><p>Returns a reference to the vector-valued input port for the propeller
commands. It has size <code class="docutils literal notranslate"><span class="pre">num_propellers()</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.Propeller_-Expression-.get_spatial_forces_output_port">
<span id="pydrake.multibody.plant.Propeller_[Expression].get_spatial_forces_output_port"></span><span class="sig-name descname"><span class="pre">get_spatial_forces_output_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.Propeller_" title="pydrake.multibody.plant.Propeller_"><span class="pre">pydrake.multibody.plant.Propeller_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.OutputPort_" title="pydrake.systems.framework.OutputPort_"><span class="pre">pydrake.systems.framework.OutputPort_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.Propeller_-Expression-.get_spatial_forces_output_port" title="Permalink to this definition"></a></dt>
<dd><p>Returns a reference to the spatial_forces output port. It is
anticipated that this port will be connected to the
MultibodyPlant::get_applied_spatial_force_input_port()
“applied_spatial_force” input port of a MultibodyPlant.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.Propeller_-Expression-.num_propellers">
<span id="pydrake.multibody.plant.Propeller_[Expression].num_propellers"></span><span class="sig-name descname"><span class="pre">num_propellers</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.Propeller_" title="pydrake.multibody.plant.Propeller_"><span class="pre">pydrake.multibody.plant.Propeller_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.multibody.plant.Propeller_-Expression-.num_propellers" title="Permalink to this definition"></a></dt>
<dd><p>Returns the number of propellers modeled by this system.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.multibody.plant.PropellerInfo">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">PropellerInfo</span></span><a class="headerlink" href="#pydrake.multibody.plant.PropellerInfo" title="Permalink to this definition"></a></dt>
<dd><p>Parameters that describe the kinematic frame and force-production
properties of a single propeller.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.PropellerInfo.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.PropellerInfo.__init__" title="Permalink to this definition"></a></dt>
<dd><dl>
<dt>__init__(self: pydrake.multibody.plant.PropellerInfo, body_index: pydrake.multibody.tree.BodyIndex, X_BP: pydrake.math.RigidTransform = RigidTransform(</dt><dd><dl class="simple">
<dt>R=RotationMatrix([</dt><dd><p>[1.0, 0.0, 0.0],
[0.0, 1.0, 0.0],
[0.0, 0.0, 1.0],</p>
</dd>
</dl>
<p>]),
p=[0.0, 0.0, 0.0],</p>
</dd>
</dl>
<p>), thrust_ratio: float = 1.0, moment_ratio: float = 0.0) -&gt; None</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.multibody.plant.PropellerInfo.body_index">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">body_index</span></span><a class="headerlink" href="#pydrake.multibody.plant.PropellerInfo.body_index" title="Permalink to this definition"></a></dt>
<dd><p>The BodyIndex of a RigidBody in the MultibodyPlant to which the
propeller is attached. The spatial forces will be applied to this
body.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.multibody.plant.PropellerInfo.moment_ratio">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">moment_ratio</span></span><a class="headerlink" href="#pydrake.multibody.plant.PropellerInfo.moment_ratio" title="Permalink to this definition"></a></dt>
<dd><p>The moment about the z axis (in frame P) of the spatial force will
have magnitude <code class="docutils literal notranslate"><span class="pre">moment_ratio*command</span></code> in Newton-meters. The default
is 0, which makes the propeller a simple Cartesian force generator.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.multibody.plant.PropellerInfo.thrust_ratio">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">thrust_ratio</span></span><a class="headerlink" href="#pydrake.multibody.plant.PropellerInfo.thrust_ratio" title="Permalink to this definition"></a></dt>
<dd><p>The z component (in frame P) of the spatial force will have magnitude
<code class="docutils literal notranslate"><span class="pre">thrust_ratio*command</span></code> in Newtons. The default is 1 (command in
Newtons), but this can also be used to scale an actuator command to
the resulting force.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.multibody.plant.PropellerInfo.X_BP">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">X_BP</span></span><a class="headerlink" href="#pydrake.multibody.plant.PropellerInfo.X_BP" title="Permalink to this definition"></a></dt>
<dd><p>Pose of the propeller frame P measured in the body frame B.
$*Default:* is the identity matrix.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.multibody.plant.Wing">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">Wing</span></span><a class="headerlink" href="#pydrake.multibody.plant.Wing" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.LeafSystem" title="pydrake.systems.framework.LeafSystem"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem</span></code></a></p>
<p>A System that connects to the MultibodyPlant in order to model the
simplified dynamics of an airfoil (or hydrofoil). Currently it only
supports a particular model of flat-plate aerodynamics with lift
coefficient = 2 sinα cosα, drag coefficient = 2 sin²α, moment
coefficient = 0, as documented for a number of NACA airfoils with
Reynolds number ≤ 10^5 in:</p>
<p>S. F. Hoerner and H. V. Borst, “Fluid-dynamic lift: practical
information on aerodynamic and hydrodynamic lift,” 1985 (Ch. 4,
Section 6).</p>
<p>This model was also empirically validated for a bird-scale UAV with
flat-plate wings (Reynolds number below 53000) in:</p>
<p>Rick Cory and Russ Tedrake, “Experiments in Fixed-Wing UAV Perching”,
Proceedings of the AIAA Guidance, Navigation, and Control Conference ,
pp. 1-12, 2008.</p>
<p>and may generalize well as a model for other wings in the post-stall
regime, but it should only be viewed as a simple / coarse
approximation. We aim to generalize this class to general
lift/drag/moment coefficients soon.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">body_poses&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">body_spatial_velocities&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">wind_velocity_at_aerodynamic_center (optional)&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">fluid_density (optional)&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>Wing</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; spatial_force</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; aerodynamic_center</td></tr></table></td></tr></table><ul class="simple">
<li><p>The optional wind velocity input is a three-element BasicVector&lt;T&gt;</p></li>
</ul>
<p>representing the translational velocity of the wind in world coordinates at
the aerodynamic center relative to the world origin.  See
get_aerodynamic_center_output_port() for more details.
- It is expected that the body_poses input should be connected to the
MultibodyPlant::get_body_poses_output_port() “MultibodyPlant body_poses
output port” and that body_spatial_velocities input should be connected to
the MultibodyPlant::get_body_spatial_velocities_output_port()
“MultibodyPlant body_spatial_velocities output port”
- The output is of type std::vector&lt;ExternallyAppliedSpatialForce&lt;T&gt;&gt;; it is
expected that this output will be connected to the MultibodyPlant::get_applied_spatial_force_input_port()
“externally_applied_spatial_force input port” of the MultibodyPlant.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <a class="reference internal" href="#pydrake.multibody.plant.Wing_" title="pydrake.multibody.plant.Wing_"><code class="xref py py-class docutils literal notranslate"><span class="pre">Wing_</span></code></a>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.Wing.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.Wing.__init__" title="Permalink to this definition"></a></dt>
<dd><dl>
<dt>__init__(self: pydrake.multibody.plant.Wing, body_index: pydrake.multibody.tree.BodyIndex, surface_area: float, X_BodyWing: pydrake.math.RigidTransform = RigidTransform(</dt><dd><dl class="simple">
<dt>R=RotationMatrix([</dt><dd><p>[1.0, 0.0, 0.0],
[0.0, 1.0, 0.0],
[0.0, 0.0, 1.0],</p>
</dd>
</dl>
<p>]),
p=[0.0, 0.0, 0.0],</p>
</dd>
</dl>
<p>), fluid_density: float = 1.204) -&gt; None</p>
<p>Constructs a system describing a single wing using flat-plate
aerodynamics as described in the class documentation.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body_index</span></code>:</dt><dd><p>indicates the body on which the aerodynamic forces are applied.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">surface_area</span></code>:</dt><dd><p>is the total surface area of the wing in meters squared.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">X_BodyWing</span></code>:</dt><dd><p>is the pose of wing frame relative to the body frame, whose origin
is at the aerodynamic center of the wing, the positive x-axis
points along the chord towards the leading edge (e.g. towards the
nose of the plane), the positive y-axis points along the span, and
the z-axis points up. According to thin airfoil theory, the
aerodynamic center of a symmetric wing (like this flat plate), is
located at a quarter-chord position behind the leading edge.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">fluid_density</span></code>:</dt><dd><p>is the density of the fluid in kg/m^3. The default value is the
density of dry air at 20 deg Celsius at sea-level. This value is
only used if the optional fluid_density input port is not
connected.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.Wing.AddToBuilder">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">AddToBuilder</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.Wing.AddToBuilder" title="Permalink to this definition"></a></dt>
<dd><dl>
<dt>AddToBuilder(builder: pydrake.systems.framework.DiagramBuilder, plant: pydrake.multibody.plant.MultibodyPlant, body_index: pydrake.multibody.tree.BodyIndex, surface_area: float, X_BodyWing: pydrake.math.RigidTransform = RigidTransform(</dt><dd><dl class="simple">
<dt>R=RotationMatrix([</dt><dd><p>[1.0, 0.0, 0.0],
[0.0, 1.0, 0.0],
[0.0, 0.0, 1.0],</p>
</dd>
</dl>
<p>]),
p=[0.0, 0.0, 0.0],</p>
</dd>
</dl>
<p>), fluid_density: float = 1.204) -&gt; pydrake.multibody.plant.Wing</p>
<p>Helper method that constructs a Wing and connects the input and output
ports to the MultibodyPlant.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">builder</span></code>:</dt><dd><p>is a DiagramBuilder that the Wing will be added to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">plant</span></code>:</dt><dd><p>is the MultibodyPlant containing the body referenced by
<code class="docutils literal notranslate"><span class="pre">body_index</span></code>, which the wing ports will be connected to.</p>
</dd>
</dl>
<p>See the Wing constructor for details on the remaining parameters.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.Wing.get_aerodynamic_center_output_port">
<span class="sig-name descname"><span class="pre">get_aerodynamic_center_output_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.Wing" title="pydrake.multibody.plant.Wing"><span class="pre">pydrake.multibody.plant.Wing</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.OutputPort" title="pydrake.systems.framework.OutputPort"><span class="pre">pydrake.systems.framework.OutputPort</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.Wing.get_aerodynamic_center_output_port" title="Permalink to this definition"></a></dt>
<dd><p>Returns a 3-element position of the aerodynamic center of the wing in
world coordinates. This output port does not depend on the optional
wind velocity input port, so it may be used to compute the wind
velocity at the aerodynamic center without causing any algebraic loops
in the Diagram. For instance, the following (sub-)Diagram could be
used to implement a wind field: ┌────────────┐ ┌──┤ Wind Field │◄─┐ │
└────────────┘ │ │ ┌──────────┐ │ └──►│ Wing ├───┘
wind_velocity_at_└──────────┘aerodynamic_center aerodynamic_center</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.Wing.get_body_poses_input_port">
<span class="sig-name descname"><span class="pre">get_body_poses_input_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.Wing" title="pydrake.multibody.plant.Wing"><span class="pre">pydrake.multibody.plant.Wing</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.InputPort" title="pydrake.systems.framework.InputPort"><span class="pre">pydrake.systems.framework.InputPort</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.Wing.get_body_poses_input_port" title="Permalink to this definition"></a></dt>
<dd><p>Returns a reference to the body_poses input port. It is anticipated
that this port will be connected the body_poses output port of a
MultibodyPlant.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.Wing.get_body_spatial_velocities_input_port">
<span class="sig-name descname"><span class="pre">get_body_spatial_velocities_input_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.Wing" title="pydrake.multibody.plant.Wing"><span class="pre">pydrake.multibody.plant.Wing</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.InputPort" title="pydrake.systems.framework.InputPort"><span class="pre">pydrake.systems.framework.InputPort</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.Wing.get_body_spatial_velocities_input_port" title="Permalink to this definition"></a></dt>
<dd><p>Returns a reference to the body_spatial_velocities input port. It is
anticipated that this port will be connected the
body_spatial_velocities output port of a MultibodyPlant.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.Wing.get_fluid_density_input_port">
<span class="sig-name descname"><span class="pre">get_fluid_density_input_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.Wing" title="pydrake.multibody.plant.Wing"><span class="pre">pydrake.multibody.plant.Wing</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.InputPort" title="pydrake.systems.framework.InputPort"><span class="pre">pydrake.systems.framework.InputPort</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.Wing.get_fluid_density_input_port" title="Permalink to this definition"></a></dt>
<dd><p>Returns a reference to the optional fluid_density input port, which
accepts a scalar vector in units kg/m^3. This port is provided to
support vehicles which must take into account variations in
atmospheric density; such as a spacecraft during re-entry. If left
unconnected, the aerodynamic forces will be calculated using the
default fluid density passed in the constructor.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.Wing.get_spatial_force_output_port">
<span class="sig-name descname"><span class="pre">get_spatial_force_output_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.Wing" title="pydrake.multibody.plant.Wing"><span class="pre">pydrake.multibody.plant.Wing</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.OutputPort" title="pydrake.systems.framework.OutputPort"><span class="pre">pydrake.systems.framework.OutputPort</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.Wing.get_spatial_force_output_port" title="Permalink to this definition"></a></dt>
<dd><p>Returns a reference to the spatial_forces output port. It is
anticipated that this port will be connected to the
MultibodyPlant::get_applied_spatial_force_input_port()
“applied_spatial_force” input port of a MultibodyPlant.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.Wing.get_wind_velocity_input_port">
<span class="sig-name descname"><span class="pre">get_wind_velocity_input_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.Wing" title="pydrake.multibody.plant.Wing"><span class="pre">pydrake.multibody.plant.Wing</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.InputPort" title="pydrake.systems.framework.InputPort"><span class="pre">pydrake.systems.framework.InputPort</span></a></span></span><a class="headerlink" href="#pydrake.multibody.plant.Wing.get_wind_velocity_input_port" title="Permalink to this definition"></a></dt>
<dd><p>Returns a reference to the input port for the optional three-element
BasicVector&lt;T&gt; representing the translational velocity of the wind in
world coordinates at the aerodynamic center relative to the world
origin. If this port is not connected, then the wind velocity is taken
to be zero.</p>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py" id="pydrake.multibody.plant.Wing_">
<em class="property"><span class="pre">template</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">Wing_</span></span><a class="headerlink" href="#pydrake.multibody.plant.Wing_" title="Permalink to this definition"></a></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">Wing_[float]</span></code>, <a class="reference internal" href="#pydrake.multibody.plant.Wing_-AutoDiffXd" title="pydrake.multibody.plant.Wing_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">Wing_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.plant.Wing_-Expression" title="pydrake.multibody.plant.Wing_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">Wing_[Expression]</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.multibody.plant.Wing_-AutoDiffXd">
<span id="pydrake.multibody.plant.Wing_[AutoDiffXd]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">Wing_[AutoDiffXd]</span></span><a class="headerlink" href="#pydrake.multibody.plant.Wing_-AutoDiffXd" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.LeafSystem_-AutoDiffXd" title="pydrake.systems.framework.LeafSystem_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem_[AutoDiffXd]</span></code></a></p>
<p>A System that connects to the MultibodyPlant in order to model the
simplified dynamics of an airfoil (or hydrofoil). Currently it only
supports a particular model of flat-plate aerodynamics with lift
coefficient = 2 sinα cosα, drag coefficient = 2 sin²α, moment
coefficient = 0, as documented for a number of NACA airfoils with
Reynolds number ≤ 10^5 in:</p>
<p>S. F. Hoerner and H. V. Borst, “Fluid-dynamic lift: practical
information on aerodynamic and hydrodynamic lift,” 1985 (Ch. 4,
Section 6).</p>
<p>This model was also empirically validated for a bird-scale UAV with
flat-plate wings (Reynolds number below 53000) in:</p>
<p>Rick Cory and Russ Tedrake, “Experiments in Fixed-Wing UAV Perching”,
Proceedings of the AIAA Guidance, Navigation, and Control Conference ,
pp. 1-12, 2008.</p>
<p>and may generalize well as a model for other wings in the post-stall
regime, but it should only be viewed as a simple / coarse
approximation. We aim to generalize this class to general
lift/drag/moment coefficients soon.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">body_poses&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">body_spatial_velocities&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">wind_velocity_at_aerodynamic_center (optional)&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">fluid_density (optional)&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>Wing</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; spatial_force</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; aerodynamic_center</td></tr></table></td></tr></table><ul class="simple">
<li><p>The optional wind velocity input is a three-element BasicVector&lt;T&gt;</p></li>
</ul>
<p>representing the translational velocity of the wind in world coordinates at
the aerodynamic center relative to the world origin.  See
get_aerodynamic_center_output_port() for more details.
- It is expected that the body_poses input should be connected to the
MultibodyPlant::get_body_poses_output_port() “MultibodyPlant body_poses
output port” and that body_spatial_velocities input should be connected to
the MultibodyPlant::get_body_spatial_velocities_output_port()
“MultibodyPlant body_spatial_velocities output port”
- The output is of type std::vector&lt;ExternallyAppliedSpatialForce&lt;T&gt;&gt;; it is
expected that this output will be connected to the MultibodyPlant::get_applied_spatial_force_input_port()
“externally_applied_spatial_force input port” of the MultibodyPlant.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.Wing_-AutoDiffXd-.__init__">
<span id="pydrake.multibody.plant.Wing_[AutoDiffXd].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.Wing_-AutoDiffXd-.__init__" title="Permalink to this definition"></a></dt>
<dd><dl>
<dt>__init__(self: pydrake.multibody.plant.Wing_[AutoDiffXd], body_index: pydrake.multibody.tree.BodyIndex, surface_area: float, X_BodyWing: pydrake.math.RigidTransform = RigidTransform(</dt><dd><dl class="simple">
<dt>R=RotationMatrix([</dt><dd><p>[1.0, 0.0, 0.0],
[0.0, 1.0, 0.0],
[0.0, 0.0, 1.0],</p>
</dd>
</dl>
<p>]),
p=[0.0, 0.0, 0.0],</p>
</dd>
</dl>
<p>), fluid_density: float = 1.204) -&gt; None</p>
<p>Constructs a system describing a single wing using flat-plate
aerodynamics as described in the class documentation.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body_index</span></code>:</dt><dd><p>indicates the body on which the aerodynamic forces are applied.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">surface_area</span></code>:</dt><dd><p>is the total surface area of the wing in meters squared.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">X_BodyWing</span></code>:</dt><dd><p>is the pose of wing frame relative to the body frame, whose origin
is at the aerodynamic center of the wing, the positive x-axis
points along the chord towards the leading edge (e.g. towards the
nose of the plane), the positive y-axis points along the span, and
the z-axis points up. According to thin airfoil theory, the
aerodynamic center of a symmetric wing (like this flat plate), is
located at a quarter-chord position behind the leading edge.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">fluid_density</span></code>:</dt><dd><p>is the density of the fluid in kg/m^3. The default value is the
density of dry air at 20 deg Celsius at sea-level. This value is
only used if the optional fluid_density input port is not
connected.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.Wing_-AutoDiffXd-.AddToBuilder">
<span id="pydrake.multibody.plant.Wing_[AutoDiffXd].AddToBuilder"></span><em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">AddToBuilder</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.Wing_-AutoDiffXd-.AddToBuilder" title="Permalink to this definition"></a></dt>
<dd><dl>
<dt>AddToBuilder(builder: pydrake.systems.framework.DiagramBuilder_[AutoDiffXd], plant: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], body_index: pydrake.multibody.tree.BodyIndex, surface_area: float, X_BodyWing: pydrake.math.RigidTransform = RigidTransform(</dt><dd><dl class="simple">
<dt>R=RotationMatrix([</dt><dd><p>[1.0, 0.0, 0.0],
[0.0, 1.0, 0.0],
[0.0, 0.0, 1.0],</p>
</dd>
</dl>
<p>]),
p=[0.0, 0.0, 0.0],</p>
</dd>
</dl>
<p>), fluid_density: float = 1.204) -&gt; pydrake.multibody.plant.Wing_[AutoDiffXd]</p>
<p>Helper method that constructs a Wing and connects the input and output
ports to the MultibodyPlant.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">builder</span></code>:</dt><dd><p>is a DiagramBuilder that the Wing will be added to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">plant</span></code>:</dt><dd><p>is the MultibodyPlant containing the body referenced by
<code class="docutils literal notranslate"><span class="pre">body_index</span></code>, which the wing ports will be connected to.</p>
</dd>
</dl>
<p>See the Wing constructor for details on the remaining parameters.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.Wing_-AutoDiffXd-.get_aerodynamic_center_output_port">
<span id="pydrake.multibody.plant.Wing_[AutoDiffXd].get_aerodynamic_center_output_port"></span><span class="sig-name descname"><span class="pre">get_aerodynamic_center_output_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.Wing_" title="pydrake.multibody.plant.Wing_"><span class="pre">pydrake.multibody.plant.Wing_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.OutputPort_" title="pydrake.systems.framework.OutputPort_"><span class="pre">pydrake.systems.framework.OutputPort_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.Wing_-AutoDiffXd-.get_aerodynamic_center_output_port" title="Permalink to this definition"></a></dt>
<dd><p>Returns a 3-element position of the aerodynamic center of the wing in
world coordinates. This output port does not depend on the optional
wind velocity input port, so it may be used to compute the wind
velocity at the aerodynamic center without causing any algebraic loops
in the Diagram. For instance, the following (sub-)Diagram could be
used to implement a wind field: ┌────────────┐ ┌──┤ Wind Field │◄─┐ │
└────────────┘ │ │ ┌──────────┐ │ └──►│ Wing ├───┘
wind_velocity_at_└──────────┘aerodynamic_center aerodynamic_center</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.Wing_-AutoDiffXd-.get_body_poses_input_port">
<span id="pydrake.multibody.plant.Wing_[AutoDiffXd].get_body_poses_input_port"></span><span class="sig-name descname"><span class="pre">get_body_poses_input_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.Wing_" title="pydrake.multibody.plant.Wing_"><span class="pre">pydrake.multibody.plant.Wing_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.InputPort_" title="pydrake.systems.framework.InputPort_"><span class="pre">pydrake.systems.framework.InputPort_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.Wing_-AutoDiffXd-.get_body_poses_input_port" title="Permalink to this definition"></a></dt>
<dd><p>Returns a reference to the body_poses input port. It is anticipated
that this port will be connected the body_poses output port of a
MultibodyPlant.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.Wing_-AutoDiffXd-.get_body_spatial_velocities_input_port">
<span id="pydrake.multibody.plant.Wing_[AutoDiffXd].get_body_spatial_velocities_input_port"></span><span class="sig-name descname"><span class="pre">get_body_spatial_velocities_input_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.Wing_" title="pydrake.multibody.plant.Wing_"><span class="pre">pydrake.multibody.plant.Wing_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.InputPort_" title="pydrake.systems.framework.InputPort_"><span class="pre">pydrake.systems.framework.InputPort_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.Wing_-AutoDiffXd-.get_body_spatial_velocities_input_port" title="Permalink to this definition"></a></dt>
<dd><p>Returns a reference to the body_spatial_velocities input port. It is
anticipated that this port will be connected the
body_spatial_velocities output port of a MultibodyPlant.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.Wing_-AutoDiffXd-.get_fluid_density_input_port">
<span id="pydrake.multibody.plant.Wing_[AutoDiffXd].get_fluid_density_input_port"></span><span class="sig-name descname"><span class="pre">get_fluid_density_input_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.Wing_" title="pydrake.multibody.plant.Wing_"><span class="pre">pydrake.multibody.plant.Wing_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.InputPort_" title="pydrake.systems.framework.InputPort_"><span class="pre">pydrake.systems.framework.InputPort_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.Wing_-AutoDiffXd-.get_fluid_density_input_port" title="Permalink to this definition"></a></dt>
<dd><p>Returns a reference to the optional fluid_density input port, which
accepts a scalar vector in units kg/m^3. This port is provided to
support vehicles which must take into account variations in
atmospheric density; such as a spacecraft during re-entry. If left
unconnected, the aerodynamic forces will be calculated using the
default fluid density passed in the constructor.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.Wing_-AutoDiffXd-.get_spatial_force_output_port">
<span id="pydrake.multibody.plant.Wing_[AutoDiffXd].get_spatial_force_output_port"></span><span class="sig-name descname"><span class="pre">get_spatial_force_output_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.Wing_" title="pydrake.multibody.plant.Wing_"><span class="pre">pydrake.multibody.plant.Wing_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.OutputPort_" title="pydrake.systems.framework.OutputPort_"><span class="pre">pydrake.systems.framework.OutputPort_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.Wing_-AutoDiffXd-.get_spatial_force_output_port" title="Permalink to this definition"></a></dt>
<dd><p>Returns a reference to the spatial_forces output port. It is
anticipated that this port will be connected to the
MultibodyPlant::get_applied_spatial_force_input_port()
“applied_spatial_force” input port of a MultibodyPlant.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.Wing_-AutoDiffXd-.get_wind_velocity_input_port">
<span id="pydrake.multibody.plant.Wing_[AutoDiffXd].get_wind_velocity_input_port"></span><span class="sig-name descname"><span class="pre">get_wind_velocity_input_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.Wing_" title="pydrake.multibody.plant.Wing_"><span class="pre">pydrake.multibody.plant.Wing_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.InputPort_" title="pydrake.systems.framework.InputPort_"><span class="pre">pydrake.systems.framework.InputPort_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.Wing_-AutoDiffXd-.get_wind_velocity_input_port" title="Permalink to this definition"></a></dt>
<dd><p>Returns a reference to the input port for the optional three-element
BasicVector&lt;T&gt; representing the translational velocity of the wind in
world coordinates at the aerodynamic center relative to the world
origin. If this port is not connected, then the wind velocity is taken
to be zero.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.multibody.plant.Wing_-Expression">
<span id="pydrake.multibody.plant.Wing_[Expression]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.multibody.plant.</span></span><span class="sig-name descname"><span class="pre">Wing_[Expression]</span></span><a class="headerlink" href="#pydrake.multibody.plant.Wing_-Expression" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.LeafSystem_-Expression" title="pydrake.systems.framework.LeafSystem_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem_[Expression]</span></code></a></p>
<p>A System that connects to the MultibodyPlant in order to model the
simplified dynamics of an airfoil (or hydrofoil). Currently it only
supports a particular model of flat-plate aerodynamics with lift
coefficient = 2 sinα cosα, drag coefficient = 2 sin²α, moment
coefficient = 0, as documented for a number of NACA airfoils with
Reynolds number ≤ 10^5 in:</p>
<p>S. F. Hoerner and H. V. Borst, “Fluid-dynamic lift: practical
information on aerodynamic and hydrodynamic lift,” 1985 (Ch. 4,
Section 6).</p>
<p>This model was also empirically validated for a bird-scale UAV with
flat-plate wings (Reynolds number below 53000) in:</p>
<p>Rick Cory and Russ Tedrake, “Experiments in Fixed-Wing UAV Perching”,
Proceedings of the AIAA Guidance, Navigation, and Control Conference ,
pp. 1-12, 2008.</p>
<p>and may generalize well as a model for other wings in the post-stall
regime, but it should only be viewed as a simple / coarse
approximation. We aim to generalize this class to general
lift/drag/moment coefficients soon.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">body_poses&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">body_spatial_velocities&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">wind_velocity_at_aerodynamic_center (optional)&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">fluid_density (optional)&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>Wing</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; spatial_force</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; aerodynamic_center</td></tr></table></td></tr></table><ul class="simple">
<li><p>The optional wind velocity input is a three-element BasicVector&lt;T&gt;</p></li>
</ul>
<p>representing the translational velocity of the wind in world coordinates at
the aerodynamic center relative to the world origin.  See
get_aerodynamic_center_output_port() for more details.
- It is expected that the body_poses input should be connected to the
MultibodyPlant::get_body_poses_output_port() “MultibodyPlant body_poses
output port” and that body_spatial_velocities input should be connected to
the MultibodyPlant::get_body_spatial_velocities_output_port()
“MultibodyPlant body_spatial_velocities output port”
- The output is of type std::vector&lt;ExternallyAppliedSpatialForce&lt;T&gt;&gt;; it is
expected that this output will be connected to the MultibodyPlant::get_applied_spatial_force_input_port()
“externally_applied_spatial_force input port” of the MultibodyPlant.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.Wing_-Expression-.__init__">
<span id="pydrake.multibody.plant.Wing_[Expression].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.Wing_-Expression-.__init__" title="Permalink to this definition"></a></dt>
<dd><dl>
<dt>__init__(self: pydrake.multibody.plant.Wing_[Expression], body_index: pydrake.multibody.tree.BodyIndex, surface_area: float, X_BodyWing: pydrake.math.RigidTransform = RigidTransform(</dt><dd><dl class="simple">
<dt>R=RotationMatrix([</dt><dd><p>[1.0, 0.0, 0.0],
[0.0, 1.0, 0.0],
[0.0, 0.0, 1.0],</p>
</dd>
</dl>
<p>]),
p=[0.0, 0.0, 0.0],</p>
</dd>
</dl>
<p>), fluid_density: float = 1.204) -&gt; None</p>
<p>Constructs a system describing a single wing using flat-plate
aerodynamics as described in the class documentation.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body_index</span></code>:</dt><dd><p>indicates the body on which the aerodynamic forces are applied.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">surface_area</span></code>:</dt><dd><p>is the total surface area of the wing in meters squared.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">X_BodyWing</span></code>:</dt><dd><p>is the pose of wing frame relative to the body frame, whose origin
is at the aerodynamic center of the wing, the positive x-axis
points along the chord towards the leading edge (e.g. towards the
nose of the plane), the positive y-axis points along the span, and
the z-axis points up. According to thin airfoil theory, the
aerodynamic center of a symmetric wing (like this flat plate), is
located at a quarter-chord position behind the leading edge.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">fluid_density</span></code>:</dt><dd><p>is the density of the fluid in kg/m^3. The default value is the
density of dry air at 20 deg Celsius at sea-level. This value is
only used if the optional fluid_density input port is not
connected.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.Wing_-Expression-.AddToBuilder">
<span id="pydrake.multibody.plant.Wing_[Expression].AddToBuilder"></span><em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">AddToBuilder</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.Wing_-Expression-.AddToBuilder" title="Permalink to this definition"></a></dt>
<dd><dl>
<dt>AddToBuilder(builder: pydrake.systems.framework.DiagramBuilder_[Expression], plant: pydrake.multibody.plant.MultibodyPlant_[Expression], body_index: pydrake.multibody.tree.BodyIndex, surface_area: float, X_BodyWing: pydrake.math.RigidTransform = RigidTransform(</dt><dd><dl class="simple">
<dt>R=RotationMatrix([</dt><dd><p>[1.0, 0.0, 0.0],
[0.0, 1.0, 0.0],
[0.0, 0.0, 1.0],</p>
</dd>
</dl>
<p>]),
p=[0.0, 0.0, 0.0],</p>
</dd>
</dl>
<p>), fluid_density: float = 1.204) -&gt; pydrake.multibody.plant.Wing_[Expression]</p>
<p>Helper method that constructs a Wing and connects the input and output
ports to the MultibodyPlant.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">builder</span></code>:</dt><dd><p>is a DiagramBuilder that the Wing will be added to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">plant</span></code>:</dt><dd><p>is the MultibodyPlant containing the body referenced by
<code class="docutils literal notranslate"><span class="pre">body_index</span></code>, which the wing ports will be connected to.</p>
</dd>
</dl>
<p>See the Wing constructor for details on the remaining parameters.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.Wing_-Expression-.get_aerodynamic_center_output_port">
<span id="pydrake.multibody.plant.Wing_[Expression].get_aerodynamic_center_output_port"></span><span class="sig-name descname"><span class="pre">get_aerodynamic_center_output_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.Wing_" title="pydrake.multibody.plant.Wing_"><span class="pre">pydrake.multibody.plant.Wing_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.OutputPort_" title="pydrake.systems.framework.OutputPort_"><span class="pre">pydrake.systems.framework.OutputPort_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.Wing_-Expression-.get_aerodynamic_center_output_port" title="Permalink to this definition"></a></dt>
<dd><p>Returns a 3-element position of the aerodynamic center of the wing in
world coordinates. This output port does not depend on the optional
wind velocity input port, so it may be used to compute the wind
velocity at the aerodynamic center without causing any algebraic loops
in the Diagram. For instance, the following (sub-)Diagram could be
used to implement a wind field: ┌────────────┐ ┌──┤ Wind Field │◄─┐ │
└────────────┘ │ │ ┌──────────┐ │ └──►│ Wing ├───┘
wind_velocity_at_└──────────┘aerodynamic_center aerodynamic_center</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.Wing_-Expression-.get_body_poses_input_port">
<span id="pydrake.multibody.plant.Wing_[Expression].get_body_poses_input_port"></span><span class="sig-name descname"><span class="pre">get_body_poses_input_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.Wing_" title="pydrake.multibody.plant.Wing_"><span class="pre">pydrake.multibody.plant.Wing_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.InputPort_" title="pydrake.systems.framework.InputPort_"><span class="pre">pydrake.systems.framework.InputPort_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.Wing_-Expression-.get_body_poses_input_port" title="Permalink to this definition"></a></dt>
<dd><p>Returns a reference to the body_poses input port. It is anticipated
that this port will be connected the body_poses output port of a
MultibodyPlant.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.Wing_-Expression-.get_body_spatial_velocities_input_port">
<span id="pydrake.multibody.plant.Wing_[Expression].get_body_spatial_velocities_input_port"></span><span class="sig-name descname"><span class="pre">get_body_spatial_velocities_input_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.Wing_" title="pydrake.multibody.plant.Wing_"><span class="pre">pydrake.multibody.plant.Wing_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.InputPort_" title="pydrake.systems.framework.InputPort_"><span class="pre">pydrake.systems.framework.InputPort_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.Wing_-Expression-.get_body_spatial_velocities_input_port" title="Permalink to this definition"></a></dt>
<dd><p>Returns a reference to the body_spatial_velocities input port. It is
anticipated that this port will be connected the
body_spatial_velocities output port of a MultibodyPlant.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.Wing_-Expression-.get_fluid_density_input_port">
<span id="pydrake.multibody.plant.Wing_[Expression].get_fluid_density_input_port"></span><span class="sig-name descname"><span class="pre">get_fluid_density_input_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.Wing_" title="pydrake.multibody.plant.Wing_"><span class="pre">pydrake.multibody.plant.Wing_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.InputPort_" title="pydrake.systems.framework.InputPort_"><span class="pre">pydrake.systems.framework.InputPort_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.Wing_-Expression-.get_fluid_density_input_port" title="Permalink to this definition"></a></dt>
<dd><p>Returns a reference to the optional fluid_density input port, which
accepts a scalar vector in units kg/m^3. This port is provided to
support vehicles which must take into account variations in
atmospheric density; such as a spacecraft during re-entry. If left
unconnected, the aerodynamic forces will be calculated using the
default fluid density passed in the constructor.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.Wing_-Expression-.get_spatial_force_output_port">
<span id="pydrake.multibody.plant.Wing_[Expression].get_spatial_force_output_port"></span><span class="sig-name descname"><span class="pre">get_spatial_force_output_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.Wing_" title="pydrake.multibody.plant.Wing_"><span class="pre">pydrake.multibody.plant.Wing_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.OutputPort_" title="pydrake.systems.framework.OutputPort_"><span class="pre">pydrake.systems.framework.OutputPort_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.Wing_-Expression-.get_spatial_force_output_port" title="Permalink to this definition"></a></dt>
<dd><p>Returns a reference to the spatial_forces output port. It is
anticipated that this port will be connected to the
MultibodyPlant::get_applied_spatial_force_input_port()
“applied_spatial_force” input port of a MultibodyPlant.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.multibody.plant.Wing_-Expression-.get_wind_velocity_input_port">
<span id="pydrake.multibody.plant.Wing_[Expression].get_wind_velocity_input_port"></span><span class="sig-name descname"><span class="pre">get_wind_velocity_input_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.multibody.plant.Wing_" title="pydrake.multibody.plant.Wing_"><span class="pre">pydrake.multibody.plant.Wing_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.InputPort_" title="pydrake.systems.framework.InputPort_"><span class="pre">pydrake.systems.framework.InputPort_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.multibody.plant.Wing_-Expression-.get_wind_velocity_input_port" title="Permalink to this definition"></a></dt>
<dd><p>Returns a reference to the input port for the optional three-element
BasicVector&lt;T&gt; representing the translational velocity of the wind in
world coordinates at the aerodynamic center relative to the world
origin. If this port is not connected, then the wind velocity is taken
to be zero.</p>
</dd></dl>

</dd></dl>

</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="pydrake.multibody.parsing.html" class="btn btn-neutral float-left" title="pydrake.multibody.parsing" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="pydrake.multibody.rational.html" class="btn btn-neutral float-right" title="pydrake.multibody.rational" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p></p>
  </div>

  
</footer>
<script>
  /* Enables clicking for the mobile "hamburger" (three-line) menu item. */
  const siteHeader = document.querySelector('.site-header')
  const mobileButton = document.querySelector('.menu-mobile-toggle')
  const body = document.querySelector('body')

  mobileButton.addEventListener('click', function(event) {
    siteHeader.classList.toggle('open');
    body.classList.toggle('overflow-hidden');
  })
</script>
<footer class="site-footer padding">
  <div class="contain">
    <a href="/" class="drake-logo">
      <img src="/images/drake-logo.svg">
    </a>
    <div class="footer-menu">
      <ul>
        <li>
          <a href="/doxygen_cxx/index.html" class="site-menu-item">C++</a>
        </li>
        <li>
          <a href="/pydrake/index.html" class="site-menu-item">Python</a>
        </li>
        <li class="github-link">
          <a href="https://github.com/RobotLocomotion/drake" class="site-menu-item">GitHub <img src="/third_party/images/GitHub-Mark-64px.png"></a>
        </li>
      </ul>
    </div>
  </div>


</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>