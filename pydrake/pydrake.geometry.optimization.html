<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>pydrake.geometry.optimization &mdash; pydrake  documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=86f27845" />
      <link rel="stylesheet" type="text/css" href="_static/css/custom.css?v=6b576c25" />

  
  
        <script src="_static/jquery.js?v=8dae8fb0"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="_static/documentation_options.js?v=7f41d439"></script>
        <script src="_static/doctools.js?v=888ff710"></script>
        <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="pydrake.gym" href="pydrake.gym.html" />
    <link rel="prev" title="pydrake.geometry.all" href="pydrake.geometry.all.html" /> 
</head>

<body class="wy-body-for-nav">
<header class="site-header">
  <div class="site-header-inner contain">
    <a class="drake-logo" href="/"><img src="/images/drake-logo-white.svg"></a>
    <div class="menu-mobile-toggle">
      <span></span>
    </div>
    <nav class="site-menu">
      <ul>
        <li class="site-menu-item site-menu-item-main">
          <a class="site-menu-item" href="/">Home</a>
        </li>
        <li class="site-menu-item site-menu-item-main">
          <a class="site-menu-item" href="/installation.html">Installation</a>
        </li>
        <li class="site-menu-item site-menu-item-main">
          <a class="site-menu-item" href="/gallery.html">Gallery</a>
        </li>
        <li class="site-menu-item site-menu-item-main">API Documentation
          <div class="sub">
            <a class="site-menu-item" href="/doxygen_cxx/index.html">C++</a> <a class="site-menu-item" href="/pydrake/index.html">Python</a>
          </div>
        </li>
        <li class="site-menu-item site-menu-item-main">Resources
          <div class="sub">
            <a class="site-menu-item" href="/getting_help.html">Getting Help</a> <a class="site-menu-item" href="https://deepnote.com/workspace/Drake-0b3b2c53-a7ad-441b-80f8-bf8350752305/project/Tutorials-2b4fc509-aef2-417d-a40d-6071dfed9199/%2Findex.ipynb">Tutorials</a> <a class="site-menu-item" href="/python_bindings.html">Python Bindings</a> <a class="site-menu-item" href="/developers.html">For Developers</a> <a class="site-menu-item" href="/credits.html">Credits</a>
          </div>
        </li>
        <li class="github-link">
          <a class="site-menu-item" href="https://github.com/RobotLocomotion/drake">GitHub <img src="/third_party/images/GitHub-Mark-Light-64px.png"></a>
        </li>
      </ul>
    </nav>
  </div>
</header>

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            pydrake
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search pydrake only…" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
  <form id="search_form" class="wy_form" action="https://google.com/search" method="get">
    <input type="text" name="q" placeholder="Search all of Drake…" />
    <input type="hidden" name="q" value="site:drake.mit.edu OR site:underactuated.csail.mit.edu OR site:manipulation.csail.mit.edu" />
  </form>
</div>

        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="pydrake.all.html">pydrake.all</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.autodiffutils.html">pydrake.autodiffutils</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.common.html">pydrake.common</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.examples.html">pydrake.examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.forwarddiff.html">pydrake.forwarddiff</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="pydrake.geometry.html">pydrake.geometry</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="pydrake.geometry.all.html">pydrake.geometry.all</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">pydrake.geometry.optimization</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.gym.html">pydrake.gym</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.lcm.html">pydrake.lcm</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.manipulation.html">pydrake.manipulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.math.html">pydrake.math</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.multibody.html">pydrake.multibody</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.perception.html">pydrake.perception</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.planning.html">pydrake.planning</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.polynomial.html">pydrake.polynomial</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.solvers.html">pydrake.solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.symbolic.html">pydrake.symbolic</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.systems.html">pydrake.systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.trajectories.html">pydrake.trajectories</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.tutorials.html">pydrake.tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.visualization.html">pydrake.visualization</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">pydrake</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="pydrake.geometry.html">pydrake.geometry</a></li>
      <li class="breadcrumb-item active">pydrake.geometry.optimization</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="module-pydrake.geometry.optimization">
<span id="pydrake-geometry-optimization"></span><h1>pydrake.geometry.optimization<a class="headerlink" href="#module-pydrake.geometry.optimization" title="Link to this heading"></a></h1>
<p>Local bindings for <cite>drake::geometry::optimization</cite></p>
<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AffineBall</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.geometry.optimization.ConvexSet</span></code></p>
<p>Implements an ellipsoidal convex set represented as an affine scaling
of the unit ball {Bu + center | <a href="#id1"><span class="problematic" id="id2">|</span></a>u|₂ ≤ 1}. B must be a square matrix.</p>
<p>Compare this with an alternative parametrization of the ellipsoid: {x
| (x-center)ᵀAᵀA(x-center) ≤ 1}, which utilizes a quadratic form. The
two representations are related by B = A⁻¹ if A and B are invertible.</p>
<p>The quadratic form parametrization is implemented in Hyperellipsoid.
It can represent unbounded sets, but not sets along a
lower-dimensional affine subspace. The AffineBall parametrization can
represent sets along a lower-dimensional affine subspace, but not
unbounded sets.</p>
<p>An AffineBall can never be empty – it always contains its center.
This includes the zero-dimensional case.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AffineBall.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.geometry.optimization.AffineBall) -&gt; None</p></li>
</ol>
<p>Constructs a default (zero-dimensional, nonempty) set.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.geometry.optimization.AffineBall, B: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], center: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</p></li>
</ol>
<p>Constructs the ellipsoid from a transformation matrix B and
translation center. B describes the linear transformation that is
applied to the unit ball in order to produce the ellipsoid, and center
describes the translation of the center of the ellipsoid from the
origin.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>B.rows() == B.cols().</p>
</dd>
<dt>Precondition:</dt><dd><p>B.cols() == center.size().</p>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li><p>__init__(self: pydrake.geometry.optimization.AffineBall, ellipsoid: pydrake.geometry.optimization.Hyperellipsoid) -&gt; None</p></li>
</ol>
<p>Constructs an AffineBall from a Hyperellipsoid.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>ellipsoid.IsBounded().</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AffineBall.B(self:</span> <span class="pre">pydrake.geometry.optimization.AffineBall)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n]]</span></span></dt>
<dd><p>Returns the affine transformation matrix B.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AffineBall.center(self:</span> <span class="pre">pydrake.geometry.optimization.AffineBall)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns the center of the ellipsoid.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AffineBall.Clone(self:</span> <span class="pre">pydrake.geometry.optimization.AffineBall)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.geometry.optimization.ConvexSet</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AffineBall.MakeAffineBallFromLineSegment(x_1:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]],</span> <span class="pre">x_2:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]],</span> <span class="pre">epsilon:</span> <span class="pre">float</span> <span class="pre">=</span> <span class="pre">0.001)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.geometry.optimization.AffineBall</span></span></dt>
<dd><p>Constructs an affine ball such that its main diameter is the line
segment from <code class="docutils literal notranslate"><span class="pre">x_1</span></code> to <code class="docutils literal notranslate"><span class="pre">x_2</span></code>, and the length of all other diameters
are 2 * <code class="docutils literal notranslate"><span class="pre">epsilon</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>x_1.size() == x_2.size().</p>
</dd>
<dt>Precondition:</dt><dd><p>epsilon &gt;= 0.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if ‖x_1 - x_2‖₂ is less than 1e-9.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AffineBall.MakeAxisAligned(radius:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]],</span> <span class="pre">center:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.geometry.optimization.AffineBall</span></span></dt>
<dd><p>Constructs an axis-aligned AffineBall with the implicit form
(x₀-c₀)²/r₀² + (x₁-c₁)²/r₁² + … + (x_N - c_N)²/r_N² ≤ 1, where c is
shorthand for <code class="docutils literal notranslate"><span class="pre">center</span></code> and r is shorthand for <code class="docutils literal notranslate"><span class="pre">radius</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>radius.size() == center.size().</p>
</dd>
<dt>Precondition:</dt><dd><p>radius[i] &gt;= 0, for all i.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AffineBall.MakeHypersphere(radius:</span> <span class="pre">float,</span> <span class="pre">center:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.geometry.optimization.AffineBall</span></span></dt>
<dd><p>Constructs a hypersphere with <code class="docutils literal notranslate"><span class="pre">radius</span></code> and <code class="docutils literal notranslate"><span class="pre">center</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>radius &gt;= 0.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AffineBall.MakeUnitBall(dim:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.geometry.optimization.AffineBall</span></span></dt>
<dd><p>Constructs the L₂-norm unit ball in <code class="docutils literal notranslate"><span class="pre">dim</span></code> dimensions, {x | <a href="#id3"><span class="problematic" id="id4">|</span></a>x|₂ &lt;= 1
}.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>dim &gt;= 0.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AffineBall.MinimumVolumeCircumscribedEllipsoid(points:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous],</span> <span class="pre">rank_tol:</span> <span class="pre">float</span> <span class="pre">=</span> <span class="pre">1e-06)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.geometry.optimization.AffineBall</span></span></dt>
<dd><p>Constructs the minimum-volume ellipsoid which contains all of the
given points. This is commonly referred to as the outer Löwner-John
ellipsoid.</p>
<p>If all of the points lie along a proper affine subspace, this method
instead computes the minimum-k-volume ellipsoid, where k is the affine
dimension of the convex hull of <code class="docutils literal notranslate"><span class="pre">points</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">points</span></code>:</dt><dd><p>is a d-by-n matrix, where d is the ambient dimension and each
column represents one point.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">rank_tol</span></code>:</dt><dd><p>the tolerance used to detect if the data lies in an affine
subspace. The affine ball is computed in the subspace spanned by
the left singular vectors of the data matrix whose associated
singular values are larger than <code class="docutils literal notranslate"><span class="pre">rank_tol</span></code> *
<code class="docutils literal notranslate"><span class="pre">max_singular_value</span></code>. The default is 1e-6 to be compatible with
common solver tolerances.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the MathematicalProgram fails to solve. This can</strong> – </p></li>
<li><p><strong>happen due to numerical issues caused by rank_tol being set</strong> – </p></li>
<li><p><strong>too low.</strong> – </p></li>
<li><p><strong>RuntimeError if points includes NaNs</strong><strong> or </strong><strong>infinite values.</strong> – </p></li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt>Precondition:</dt><dd><p>points.rows() &gt;= 1.</p>
</dd>
<dt>Precondition:</dt><dd><p>points.cols() &gt;= 1.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AffineSubspace</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.geometry.optimization.ConvexSet</span></code></p>
<p>An affine subspace (also known as a “flat”, a “linear variety”, or a
“linear manifold”) is a vector subspace of some Euclidean space,
potentially translated so as to not pass through the origin. Examples
include points, lines, and planes (not necessarily through the
origin).</p>
<p>An affine subspace is described by a basis of its corresponding vector
subspace, plus a translation. This description is not unique as any
point in the affine subspace can be used as a translation, and any
basis of the corresponding vector subspace is valid.</p>
<p>An affine subspace can never be empty, because a vector subspace can
never be empty. Thus, the translation will always be contained in the
flat. An affine subspace is bounded if it is a point, which is when
the basis has zero columns.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AffineSubspace.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.geometry.optimization.AffineSubspace) -&gt; None</p></li>
</ol>
<p>Constructs a default (zero-dimensional, nonempty) affine subspace.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.geometry.optimization.AffineSubspace, basis: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], translation: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</p></li>
</ol>
<p>Constructs the affine subspace from an n-by-m matrix describing the
basis, where n is the ambient dimension, and m is the dimension of the
subspace, and from an n-dimensional vector describing the translation.
The set is {x | x = translation + basis*y, y ∈ Rᵐ} The columns must be
linearly independent.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>basis.rows() == translation.size().</p>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li><p>__init__(self: pydrake.geometry.optimization.AffineSubspace, set: pydrake.geometry.optimization.ConvexSet, tol: float = 1e-12) -&gt; None</p></li>
</ol>
<p>Constructs an affine subspace as the affine hull of another convex
set. The generic approach is to find a feasible point in the set, and
then iteratively compute feasible vectors until we have a basis that
spans the set. If you pass in a convex set whose points are
matrix-valued (e.g. a Spectrahedron), then the affine subspace will
work over a flattened representation of those coordinates. (So a
Spectrahedron with n-by-n matrices will output an AffineSubspace with
ambient dimension (n * (n+1)) / 2.)</p>
<p><code class="docutils literal notranslate"><span class="pre">tol</span></code> sets the numerical precision of the computation. For each
dimension, a pair of feasible points are constructed, so as to
maximize the displacement in that dimension. If their displacement
along that dimension is larger than tol, then the vector connecting
the points is added as a basis vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if set is empty.</strong> – </p></li>
<li><p><strong>RuntimeError if tol &lt; 0.</strong> – </p></li>
</ul>
</dd>
</dl>
<p>For several subclasses of ConvexSet, there is a closed-form
computation (or more efficient numerical computation) that is
preferred. - AffineBall: Can be computed via a rank-revealing
decomposition; <code class="docutils literal notranslate"><span class="pre">tol</span></code> is used as the numerical tolerance for the rank
of the matrix. Pass <code class="docutils literal notranslate"><span class="pre">std::nullopt</span></code> for <code class="docutils literal notranslate"><span class="pre">tol</span></code> to use Eigen’s
automatic tolerance computation. - AffineSubspace: Equivalent to the
copy-constructor; <code class="docutils literal notranslate"><span class="pre">tol</span></code> is ignored. - CartesianProduct: Can compute
the affine hull of each factor individually; <code class="docutils literal notranslate"><span class="pre">tol</span></code> is propagated to
the constituent calls. (This is not done if the Cartesian product has
an associated affine transformation.) - Hyperellipsoid: Always equal
to the whole ambient space; <code class="docutils literal notranslate"><span class="pre">tol</span></code> is ignored. - Hyperrectangle: Can
be computed in closed-form; <code class="docutils literal notranslate"><span class="pre">tol</span></code> has the same meaning as in the
generic affine hull computation. - Point: Can be computed in
closed-form; <code class="docutils literal notranslate"><span class="pre">tol</span></code> is ignored. This also encompasses sets which are
obviously a singleton point, as determined via MaybeGetPoint. -
VPolytope: Can be computed via a singular value decomposition; <code class="docutils literal notranslate"><span class="pre">tol</span></code>
is used as the numerical tolerance for the rank of the matrix. Pass
<code class="docutils literal notranslate"><span class="pre">std::nullopt</span></code> for <code class="docutils literal notranslate"><span class="pre">tol</span></code> to use Eigen’s automatic tolerance
computation.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AffineSubspace.AffineDimension(self:</span> <span class="pre">pydrake.geometry.optimization.AffineSubspace)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the affine dimension of this set. For an affine subspace, this
is simply the number of columns in the <a href="#id19"><span class="problematic" id="id20">basis_</span></a> matrix. A point will
have affine dimension zero.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AffineSubspace.basis(self:</span> <span class="pre">pydrake.geometry.optimization.AffineSubspace)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n]]</span></span></dt>
<dd><p>Returns the basis in an n-by-m matrix, where n is the ambient
dimension, and m is the number of vectors in the basis.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AffineSubspace.Clone(self:</span> <span class="pre">pydrake.geometry.optimization.AffineSubspace)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.geometry.optimization.ConvexSet</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AffineSubspace.ContainedIn(self:</span> <span class="pre">pydrake.geometry.optimization.AffineSubspace,</span> <span class="pre">other:</span> <span class="pre">pydrake.geometry.optimization.AffineSubspace,</span> <span class="pre">tol:</span> <span class="pre">float</span> <span class="pre">=</span> <span class="pre">1e-15)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if <code class="docutils literal notranslate"><span class="pre">this</span></code> AffineSubspace is contained in <code class="docutils literal notranslate"><span class="pre">other</span></code>.
This is computed by checking if <code class="docutils literal notranslate"><span class="pre">translation()</span></code> is in <code class="docutils literal notranslate"><span class="pre">other</span></code> and
then checking if each basis vector is in the span of the basis of
<code class="docutils literal notranslate"><span class="pre">other</span></code>. The latter step requires finding a least-squares solution,
so a nonzero tolerance (<code class="docutils literal notranslate"><span class="pre">tol</span></code>) is almost always necessary. (You may
have to adjust the default tolerance depending on the dimension of
your space and the scale of your basis vectors.)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AffineSubspace.IsNearlyEqualTo(self:</span> <span class="pre">pydrake.geometry.optimization.AffineSubspace,</span> <span class="pre">other:</span> <span class="pre">pydrake.geometry.optimization.AffineSubspace,</span> <span class="pre">tol:</span> <span class="pre">float</span> <span class="pre">=</span> <span class="pre">1e-15)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if <code class="docutils literal notranslate"><span class="pre">this</span></code> AffineSubspace is contained in <code class="docutils literal notranslate"><span class="pre">other</span></code>.
This is computed by checking if <code class="docutils literal notranslate"><span class="pre">translation()</span></code> is in <code class="docutils literal notranslate"><span class="pre">other</span></code> and
then checking if each basis vector is in the span of the basis of
<code class="docutils literal notranslate"><span class="pre">other</span></code>. The latter step requires finding a least-squares solution,
so a nonzero tolerance (<code class="docutils literal notranslate"><span class="pre">tol</span></code>) is almost always necessary. (You may
have to adjust the default tolerance depending on the dimension of
your space and the scale of your basis vectors.)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AffineSubspace.OrthogonalComplementBasis(self:</span> <span class="pre">pydrake.geometry.optimization.AffineSubspace)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n]]</span></span></dt>
<dd><p>Returns an orthonormal basis of the vector subspace which is
orthogonal to this AffineSubspace.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AffineSubspace.ToGlobalCoordinates(self:</span> <span class="pre">pydrake.geometry.optimization.AffineSubspace,</span> <span class="pre">y:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n]]</span></span></dt>
<dd><p>Given a point y in the basis of the AffineSubspace, with the zero
point at <a href="#id21"><span class="problematic" id="id22">translation_</span></a>, returns the coordinates of y in the standard
basis of the ambient space. If the AffineSubspace is a point, it has
an empty basis, so the only possible local coordinates are also empty
(and should be passed in as a length-zero vector). Each column of the
input should be a vector in the affine subspace, represented in its
local coordinates, and the corresponding column of the output will be
its representation in the coordinate system of the ambient space.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>y.rows() == AffineDimension()</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AffineSubspace.ToLocalCoordinates(self:</span> <span class="pre">pydrake.geometry.optimization.AffineSubspace,</span> <span class="pre">x:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n]]</span></span></dt>
<dd><p>Given a point x in the standard basis of the ambient space, returns
the coordinates of x in the basis of the AffineSubspace, with the zero
point at <a href="#id23"><span class="problematic" id="id24">translation_</span></a>. The component of x that is orthogonal to the
AffineSubspace (if it exists) is discarded, so
ToGlobalCoordinates(ToLocalCoordinates(x)) is equivalent to
Project(x). Note that if the AffineSubspace is a point, the basis is
empty, so the local coordinates will also be empty (and returned as a
length-zero vector). Each column of the input should be a vector in
the ambient space, and the corresponding column of the output will be
its representation in the local coordinates of the affine subspace.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>x.rows() == ambient_dimension()</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AffineSubspace.translation(self:</span> <span class="pre">pydrake.geometry.optimization.AffineSubspace)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns the translation as a length n vector.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CartesianProduct</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.geometry.optimization.ConvexSet</span></code></p>
<p>The Cartesian product of convex sets is a convex set: S = X₁ × X₂ × ⋯
× Xₙ = {(x₁, x₂, …, xₙ) | x₁ ∈ X₁, x₂ ∈ X₂, …, xₙ ∈ Xₙ}.</p>
<p>This class also supports a generalization of this concept in which the
coordinates are transformed by the linear map, {x | y = Ax + b, y ∈ Y₁
× Y₂ × ⋯ × Yₙ}, with the default values set to the identity map. This
concept is required for reasoning about cylinders in arbitrary poses
as cartesian products, and more generally for describing any affine
transform of a CartesianProduct.</p>
<p>Special behavior for IsEmpty: If there are no sets in the product,
returns nonempty by convention. See:
<a class="reference external" href="https://en.wikipedia.org/wiki/Empty_product#Nullary_Cartesian_product">https://en.wikipedia.org/wiki/Empty_product#Nullary_Cartesian_product</a>
Otherwise, if any set in the cartesian product is empty, the whole
product is empty.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CartesianProduct.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.geometry.optimization.CartesianProduct) -&gt; None</p></li>
</ol>
<p>Constructs a default (zero-dimensional, nonempty) set.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.geometry.optimization.CartesianProduct, sets: list[pydrake.geometry.optimization.ConvexSet]) -&gt; None</p></li>
</ol>
<p>Constructs the product from a vector of convex sets.</p>
<ol class="arabic simple" start="3">
<li><p>__init__(self: pydrake.geometry.optimization.CartesianProduct, setA: pydrake.geometry.optimization.ConvexSet, setB: pydrake.geometry.optimization.ConvexSet) -&gt; None</p></li>
</ol>
<p>Constructs the product from a pair of convex sets.</p>
<ol class="arabic simple" start="4">
<li><p>__init__(self: pydrake.geometry.optimization.CartesianProduct, sets: list[pydrake.geometry.optimization.ConvexSet], A: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], b: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</p></li>
</ol>
<p>Constructs the product of convex sets in the transformed coordinates:
{x | y = Ax + b, y ∈ Y₁ × Y₂ × ⋯ × Yₙ}.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError when A is not full column rank.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="5">
<li><p>__init__(self: pydrake.geometry.optimization.CartesianProduct, query_object: pydrake.geometry.QueryObject, geometry_id: pydrake.geometry.GeometryId, reference_frame: Optional[pydrake.geometry.FrameId] = None) -&gt; None</p></li>
</ol>
<p>Constructs a CartesianProduct from a SceneGraph geometry and pose in
the <code class="docutils literal notranslate"><span class="pre">reference_frame</span></code> frame, obtained via the QueryObject. If
<code class="docutils literal notranslate"><span class="pre">reference_frame</span></code> frame is std::nullopt, then it will be expressed
in the world frame.</p>
<p>Although any geometry that can be used as a ConvexSet could also be a
(trivial) CartesianProduct, we restrict this constructor to handling
Cylinder geometry, which constructs the (non-trivial) Cartesian
product of a HyperEllipsoid and an HPolyhedron. Most other SceneGraph
geometry types are supported by at least one of the ConvexSet class
constructors.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if geometry_id does not correspond to a Cylinder.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CartesianProduct.A(self:</span> <span class="pre">pydrake.geometry.optimization.CartesianProduct)</span> <span class="pre">-&gt;</span> <span class="pre">Optional[numpy.ndarray[numpy.float64[m,</span> <span class="pre">n]]]</span></span></dt>
<dd><p>Returns a copy of the matrix A if it has been set, or nullopt
otherwise.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CartesianProduct.b(self:</span> <span class="pre">pydrake.geometry.optimization.CartesianProduct)</span> <span class="pre">-&gt;</span> <span class="pre">Optional[numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]]</span></span></dt>
<dd><p>Returns a copy of the vector b if it has been set, or nullopt
otherwise.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CartesianProduct.factor(self:</span> <span class="pre">pydrake.geometry.optimization.CartesianProduct,</span> <span class="pre">index:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.geometry.optimization.ConvexSet</span></span></dt>
<dd><p>Returns a reference to the ConvexSet defining the <code class="docutils literal notranslate"><span class="pre">index</span></code> factor in
the product.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CartesianProduct.num_factors(self:</span> <span class="pre">pydrake.geometry.optimization.CartesianProduct)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>The number of factors (or sets) used in the product.</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CheckIfSatisfiesConvexityRadius(convex_set:</span> <span class="pre">pydrake.geometry.optimization.ConvexSet,</span> <span class="pre">continuous_revolute_joints:</span> <span class="pre">list[int])</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Given a convex set, and a list of indices corresponding to continuous
revolute joints, checks whether or not the set satisfies the convexity
radius. See §6.5.3 of “A Panoramic View of Riemannian Geometry”,
Marcel Berger for a general definition of convexity radius. When
dealing with continuous revolute joints, respecting the convexity
radius entails that each convex set has a width of stricty less than π
along each dimension corresponding to a continuous revolute joint.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if continuous_revolute_joints has repeated entries</strong><strong>,</strong> – </p></li>
<li><p><strong>or if any entry is outside the interval</strong><strong> [</strong><strong>0</strong><strong>,</strong> – </p></li>
<li><p><strong>convex_set.ambient_dimension</strong><strong>(</strong><strong>)</strong><strong>)</strong><strong>.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CIrisCollisionGeometry</span></span></dt>
<dd><p>This class contains the necessary information about the collision
geometry used in C-IRIS. Most notably it transcribes the geometric
condition that the collision geometry is on one side of the plane to
mathematical constraints. For the detailed algorithm please refer to
the paper Certified Polyhedral Decompositions of Collision-Free
Configuration Space by Hongkai Dai*, Alexandre Amice*, Peter Werner,
Annan Zhang and Russ Tedrake.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CIrisCollisionGeometry.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CIrisCollisionGeometry.body_index(self:</span> <span class="pre">pydrake.geometry.optimization.CIrisCollisionGeometry)</span> <span class="pre">-&gt;</span> <span class="pre">drake::TypeSafeIndex&lt;drake::multibody::RigidBodyTag&gt;</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CIrisCollisionGeometry.geometry(self:</span> <span class="pre">pydrake.geometry.optimization.CIrisCollisionGeometry)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.geometry.Shape</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CIrisCollisionGeometry.id(self:</span> <span class="pre">pydrake.geometry.optimization.CIrisCollisionGeometry)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.geometry.GeometryId</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CIrisCollisionGeometry.num_rationals(self:</span> <span class="pre">pydrake.geometry.optimization.CIrisCollisionGeometry)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the number of rationals in the condition “this geometry is on
one side of the plane.”</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CIrisCollisionGeometry.type(self:</span> <span class="pre">pydrake.geometry.optimization.CIrisCollisionGeometry)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.geometry.optimization.CIrisGeometryType</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CIrisCollisionGeometry.X_BG(self:</span> <span class="pre">pydrake.geometry.optimization.CIrisCollisionGeometry)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.math.RigidTransform</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CIrisGeometryType</span></span></dt>
<dd><p>The supported type of geometries in C-IRIS.</p>
<p>Members:</p>
<blockquote>
<div><p>kPolytope :</p>
<p>kSphere :</p>
<p>kCylinder :</p>
<p>kCapsule :</p>
</div></blockquote>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CIrisGeometryType.__init__(self:</span> <span class="pre">pydrake.geometry.optimization.CIrisGeometryType,</span> <span class="pre">value:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CIrisGeometryType.kCapsule</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CIrisGeometryType.kCylinder</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CIrisGeometryType.kPolytope</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CIrisGeometryType.kSphere</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CIrisGeometryType.name</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CIrisGeometryType.value</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ComputePairwiseIntersections(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>ComputePairwiseIntersections(convex_sets_A: list[pydrake.geometry.optimization.ConvexSet], convex_sets_B: list[pydrake.geometry.optimization.ConvexSet], continuous_revolute_joints: list[int], preprocess_bbox: bool = True, parallelism: pydrake.common.Parallelism = Parallelism(num_threads=16)) -&gt; tuple[list[tuple[int, int]], list[numpy.ndarray[numpy.float64[m, 1]]]]</p></li>
</ol>
<p>Computes the pairwise intersections between two lists of convex sets,
returning a list of edges, and a list of their corresponding offsets.
Each edge is a tuple in the form [index_A, index_B], where index_A is
the index of the set in <code class="docutils literal notranslate"><span class="pre">convex_sets_A</span></code> and index_B is the index of
the set in <code class="docutils literal notranslate"><span class="pre">convex_sets_B</span></code>. The corresponding entry in the list of
offsets (i.e., the entry at the same index) is the translation that is
applied to all the points in the index_A’th set in <code class="docutils literal notranslate"><span class="pre">convex_sets_A</span></code>
to align them with the index_B’th set in <code class="docutils literal notranslate"><span class="pre">convex_sets_B</span></code>. This
translation may only have non-zero entries along the dimensions
corresponding to <code class="docutils literal notranslate"><span class="pre">continuous_revolute_joints</span></code>. All non-zero entries
are integer multiples of 2π as the translation of the sets still
represents the same configurations for the indices in
<code class="docutils literal notranslate"><span class="pre">continuous_revolute_joints</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">convex_sets_A</span></code>:</dt><dd><p>is a vector of convex sets. Pairwise intersections will be
computed between <code class="docutils literal notranslate"><span class="pre">convex_sets_A</span></code> and <code class="docutils literal notranslate"><span class="pre">convex_sets_B</span></code>.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">convex_sets_B</span></code>:</dt><dd><p>is the other vector of convex sets.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">continuous_revolute_joints</span></code>:</dt><dd><p>is a list of joint indices corresponding to continuous revolute
joints.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">preprocess_bbox</span></code>:</dt><dd><p>is a flag for whether the function should precompute axis-aligned
bounding boxes (AABBs) for every set. This can speed up the
pairwise intersection checks, by determining some sets to be
disjoint without needing to solve an optimization problem.
However, it does require some overhead to compute those bounding
boxes.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">parallelism</span></code>:</dt><dd><p>specifies the number of threads to use.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>if continuous_revolute_joints has repeated entries</strong><strong>, or </strong><strong>if any</strong> – </p></li>
<li><p><strong>entry is outside the interval</strong><strong> [</strong><strong>0</strong><strong>, </strong><strong>ambient_dimension</strong><strong>)</strong><strong>, </strong><strong>where</strong> – </p></li>
<li><p><strong>ambient_dimension is the ambient dimension</strong><strong> of </strong><strong>the convex sets in</strong> – </p></li>
<li><p><strong>convex_sets_A` and convex_sets_B</strong> – </p></li>
<li><p><strong>if convex_sets_A</strong><strong> or </strong><strong>convex_sets_B are empty.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>ComputePairwiseIntersections(convex_sets_A: list[pydrake.geometry.optimization.ConvexSet], convex_sets_B: list[pydrake.geometry.optimization.ConvexSet], continuous_revolute_joints: list[int], bboxes_A: list[pydrake.geometry.optimization.Hyperrectangle], bboxes_B: list[pydrake.geometry.optimization.Hyperrectangle], parallelism: pydrake.common.Parallelism = Parallelism(num_threads=16)) -&gt; tuple[list[tuple[int, int]], list[numpy.ndarray[numpy.float64[m, 1]]]]</p></li>
</ol>
<p>Overload of <code class="docutils literal notranslate"><span class="pre">ComputePairwiseIntersections</span></code> allowing the user to
supply axis- aligned bounding boxes if they’re known a priori, to save
on computation time.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">bboxes_A</span></code>:</dt><dd><p>is a vector of Hyperrectangles, allowing the user to manually pass
in the AABBs of each set in <code class="docutils literal notranslate"><span class="pre">convex_sets_A</span></code> to avoid
recomputation.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">bboxes_B</span></code>:</dt><dd><p>serves the same role to <code class="docutils literal notranslate"><span class="pre">convex_sets_B</span></code> as <code class="docutils literal notranslate"><span class="pre">bboxes_A</span></code> does to
<code class="docutils literal notranslate"><span class="pre">convex_sets_A</span></code>.</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The function does not check that the entries of bboxes_A are
indeed the AABBs corresponding to the sets in <code class="docutils literal notranslate"><span class="pre">convex_sets_A</span></code>
(and likewise for bboxes_B).</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>if convex_sets_A.size</strong><strong>(</strong><strong>) </strong><strong>!= bboxes_A.size</strong><strong>(</strong><strong>)</strong> – </p></li>
<li><p><strong>if convex_sets_B.size</strong><strong>(</strong><strong>) </strong><strong>!= bboxes_B.size</strong><strong>(</strong><strong>)</strong> – </p></li>
<li><p><strong>if not all entries</strong><strong> of </strong><strong>convex_sets_A</strong><strong>, </strong><strong>convex_sets_B</strong><strong>,</strong> – </p></li>
<li><p><strong>bboxes_A`</strong><strong>, </strong><strong>and bboxes_B have the same ambient dimension</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li><p>ComputePairwiseIntersections(convex_sets: list[pydrake.geometry.optimization.ConvexSet], continuous_revolute_joints: list[int], preprocess_bbox: bool = True, parallelism: pydrake.common.Parallelism = Parallelism(num_threads=16)) -&gt; tuple[list[tuple[int, int]], list[numpy.ndarray[numpy.float64[m, 1]]]]</p></li>
</ol>
<p>Convenience overload to compute pairwise intersections within a list
of convex sets. Equivalent to calling
ComputePairwiseIntersections(convex_sets, convex_sets,
continuous_revolute_joints).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">convex_sets</span></code>:</dt><dd><p>is a vector of convex sets. Pairwise intersections will be
computed within <code class="docutils literal notranslate"><span class="pre">convex_sets</span></code>.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">continuous_revolute_joints</span></code>:</dt><dd><p>is a list of joint indices corresponding to continuous revolute
joints.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">preprocess_bbox</span></code>:</dt><dd><p>is a flag for whether the function should precompute axis-aligned
bounding boxes for every set. This can speed up the pairwise
intersection checks, by determining some sets to be disjoint
without needing to solve an optimization problem.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">parallelism</span></code>:</dt><dd><p>specifies the number of threads to use.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>if continuous_revolute_joints has repeated entries</strong><strong>, or </strong><strong>if any</strong> – </p></li>
<li><p><strong>entry is outside the interval</strong><strong> [</strong><strong>0</strong><strong>, </strong><strong>ambient_dimension</strong><strong>)</strong><strong>, </strong><strong>where</strong> – </p></li>
<li><p><strong>ambient_dimension is the ambient dimension</strong><strong> of </strong><strong>the convex sets in</strong> – </p></li>
<li><p><strong>convex_sets`</strong> – </p></li>
<li><p><strong>if convex_sets is empty.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="4">
<li><p>ComputePairwiseIntersections(convex_sets: list[pydrake.geometry.optimization.ConvexSet], continuous_revolute_joints: list[int], bboxes: list[pydrake.geometry.optimization.Hyperrectangle] = [], parallelism: pydrake.common.Parallelism = Parallelism(num_threads=16)) -&gt; tuple[list[tuple[int, int]], list[numpy.ndarray[numpy.float64[m, 1]]]]</p></li>
</ol>
<p>Overload of <code class="docutils literal notranslate"><span class="pre">ComputePairwiseIntersections</span></code> allowing the user to
supply axis- aligned bounding boxes if they’re known a priori, to save
on computation time.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">bboxes</span></code>:</dt><dd><p>is a vector of Hyperrectangles, allowing the user to manually pass
in the AABBs of each set in <code class="docutils literal notranslate"><span class="pre">convex_sets</span></code> to avoid
recomputation.</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The function does not check that the entries are indeed the AABBs
corresponding to the sets in <code class="docutils literal notranslate"><span class="pre">convex_sets</span></code>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>if convex_sets.size</strong><strong>(</strong><strong>) </strong><strong>!= bboxes.size</strong><strong>(</strong><strong>)</strong> – </p></li>
<li><p><strong>if not all entries</strong><strong> of </strong><strong>convex_sets and bboxes have the same</strong> – </p></li>
<li><p><strong>ambient dimension.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ConvexHull</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.geometry.optimization.ConvexSet</span></code></p>
<p>Implements the convex hull of a set of convex sets. The convex hull of
multiple sets is defined as the smallest convex set that contains all
the sets. Given non-empty convex sets {X₁, X₂, …, Xₙ}, the convex
hull is the set of all convex combinations of points in the sets, i.e.
{∑ᵢ λᵢ xᵢ | xᵢ ∈ Xᵢ, λᵢ ≥ 0, ∑ᵢ λᵢ = 1}.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ConvexHull.__init__(self:</span> <span class="pre">pydrake.geometry.optimization.ConvexHull,</span> <span class="pre">sets:</span> <span class="pre">list[pydrake.geometry.optimization.ConvexSet],</span> <span class="pre">remove_empty_sets:</span> <span class="pre">bool</span> <span class="pre">=</span> <span class="pre">True)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructs the convex hull from a vector of convex sets.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">sets</span></code>:</dt><dd><p>A vector of convex sets that define the convex hull.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">remove_empty_sets</span></code>:</dt><dd><p>If true, the constructor will check if any of the sets are empty
and will not consider them. If false, the constructor will not
check if any of the sets are empty.</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>If remove_empty_sets is set to false, but some of the sets are in
fact empty, then unexpected and incorrect results may occur. Only
set this flag to false if you are sure that your sets are
non-empty and performance in the constructor is critical.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ConvexHull.element(self:</span> <span class="pre">pydrake.geometry.optimization.ConvexHull,</span> <span class="pre">index:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.geometry.optimization.ConvexSet</span></span></dt>
<dd><p>Returns a reference to the convex set at the given index (including
empty sets).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ConvexHull.empty_sets_removed(self:</span> <span class="pre">pydrake.geometry.optimization.ConvexHull)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns true if <code class="docutils literal notranslate"><span class="pre">this</span></code> was constructed with remove_empty_sets=true.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ConvexHull.num_elements(self:</span> <span class="pre">pydrake.geometry.optimization.ConvexHull)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the number of convex sets defining the convex hull (including
empty sets).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ConvexHull.participating_sets(self:</span> <span class="pre">pydrake.geometry.optimization.ConvexHull)</span> <span class="pre">-&gt;</span> <span class="pre">object</span></span></dt>
<dd><p>Returns the participating convex sets.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ConvexHull.sets(self:</span> <span class="pre">pydrake.geometry.optimization.ConvexHull)</span> <span class="pre">-&gt;</span> <span class="pre">object</span></span></dt>
<dd><p>Returns the participating convex sets.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ConvexSet</span></span></dt>
<dd><p>Abstract base class for defining a convex set.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ConvexSet.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ConvexSet.AddPointInNonnegativeScalingConstraints(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>AddPointInNonnegativeScalingConstraints(self: pydrake.geometry.optimization.ConvexSet, prog: pydrake.solvers.MathematicalProgram, x: numpy.ndarray[object[m, 1]], t: pydrake.symbolic.Variable) -&gt; list[pydrake.solvers.Binding[Constraint]]</p></li>
</ol>
<p>Let S be this convex set. When S is bounded, this method adds the
convex constraints to imply</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="w"> </span><span class="err">∈</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="n">S</span><span class="p">,</span>
<span class="n">t</span><span class="w"> </span><span class="err">≥</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
</pre></div>
</div>
</details><p>where x is a point in ℜⁿ (with n the ambient_dimension) and t is a
scalar.</p>
<p>When S is unbounded, then the behavior is almost identical, except
when t=0. In this case, the constraints imply t ≥ 0, x ∈ t S ⊕ rec(S),
where rec(S) is the recession cone of S (the asymptotic directions in
which S is not bounded) and ⊕ is the Minkowski sum. For t &gt; 0, this is
equivalent to x ∈ t S, but for t = 0, we have only x ∈ rec(S).</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if ambient_dimension</strong><strong>(</strong><strong>) </strong><strong>== 0</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>AddPointInNonnegativeScalingConstraints(self: pydrake.geometry.optimization.ConvexSet, prog: pydrake.solvers.MathematicalProgram, A: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], b: numpy.ndarray[numpy.float64[m, 1]], c: numpy.ndarray[numpy.float64[m, 1]], d: float, x: numpy.ndarray[object[m, 1]], t: numpy.ndarray[object[m, 1]]) -&gt; list[pydrake.solvers.Binding[Constraint]]</p></li>
</ol>
<p>Let S be this convex set. When S is bounded, this method adds the
convex constraints to imply</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">A</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="err">∈</span><span class="w"> </span><span class="p">(</span><span class="n">c</span><span class="err">&#39;</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">d</span><span class="p">)</span><span class="w"> </span><span class="n">S</span><span class="p">,</span>
<span class="n">c</span><span class="err">&#39;</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="err">≥</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
</pre></div>
</div>
</details><p>where A is an n-by-m matrix (with n the ambient_dimension), b is a
vector of size n, c is a vector of size p, x is a point in ℜᵐ, and t
is a point in ℜᵖ.</p>
<p>When S is unbounded, then the behavior is almost identical, except
when c’ * t+d=0. In this case, the constraints imply</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">A</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="err">∈</span><span class="w"> </span><span class="p">(</span><span class="n">c</span><span class="err">&#39;</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">d</span><span class="p">)</span><span class="w"> </span><span class="n">S</span><span class="w"> </span><span class="err">⊕</span><span class="w"> </span><span class="n">rec</span><span class="p">(</span><span class="n">S</span><span class="p">),</span>
<span class="n">c</span><span class="err">&#39;</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="err">≥</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
</pre></div>
</div>
</details><p>where rec(S) is the recession cone of S (the asymptotic directions in
which S is not bounded) and ⊕ is the Minkowski sum. For c’ * t + d &gt;
0, this is equivalent to A * x + b ∈ (c’ * t + d) S, but for c’ * t +
d = 0, we have only A * x + b ∈ rec(S).</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if ambient_dimension</strong><strong>(</strong><strong>) </strong><strong>== 0</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ConvexSet.AddPointInSetConstraints(self:</span> <span class="pre">pydrake.geometry.optimization.ConvexSet,</span> <span class="pre">prog:</span> <span class="pre">pydrake.solvers.MathematicalProgram,</span> <span class="pre">vars:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">tuple[numpy.ndarray[object[m,</span> <span class="pre">1]],</span> <span class="pre">list[pydrake.solvers.Binding[Constraint]]]</span></span></dt>
<dd><p>Adds a constraint to an existing MathematicalProgram enforcing that
the point defined by vars is inside the set.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>(new_vars, new_constraints) Some of the derived class will add new
decision variables to enforce this constraint, we return all the
newly added decision variables as new_vars. The meaning of these
new decision variables differs in each subclass. If no new
variables are added, then we return an empty Eigen vector. Also we
return all the newly added constraints to <code class="docutils literal notranslate"><span class="pre">prog</span></code> through this
function.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>RuntimeError if ambient_dimension</strong><strong>(</strong><strong>) </strong><strong>== 0</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ConvexSet.ambient_dimension(self:</span> <span class="pre">pydrake.geometry.optimization.ConvexSet)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the dimension of the vector space in which the elements of
this set are evaluated. Contrast this with the <code class="docutils literal notranslate"><span class="pre">affine</span> <span class="pre">dimension</span></code>:
the dimension of the smallest affine subset of the ambient space that
contains our set. For example, if we define a set using <code class="docutils literal notranslate"><span class="pre">A*x</span> <span class="pre">=</span> <span class="pre">b</span></code>,
where <code class="docutils literal notranslate"><span class="pre">A</span></code> has linearly independent rows, then the ambient dimension
is the dimension of <code class="docutils literal notranslate"><span class="pre">x</span></code>, but the affine dimension of the set is
<code class="docutils literal notranslate"><span class="pre">ambient_dimension()</span> <span class="pre">-</span> <span class="pre">rank(A)</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ConvexSet.CalcVolume(self:</span> <span class="pre">pydrake.geometry.optimization.ConvexSet)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Computes the exact volume for the convex set.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Not every convex set can report an exact volume. In that case, use
CalcVolumeViaSampling() instead.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if has_exact_volume</strong><strong>(</strong><strong>) </strong><strong>returns False.</strong> – </p></li>
<li><p><strong>if ambient_dimension</strong><strong>(</strong><strong>) </strong><strong>== 0.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ConvexSet.CalcVolumeViaSampling(self:</span> <span class="pre">pydrake.geometry.optimization.ConvexSet,</span> <span class="pre">generator:</span> <span class="pre">pydrake.common.RandomGenerator,</span> <span class="pre">desired_rel_accuracy:</span> <span class="pre">float</span> <span class="pre">=</span> <span class="pre">0.01,</span> <span class="pre">max_num_samples:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">10000.0)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.geometry.optimization.SampledVolume</span></span></dt>
<dd><p>Calculates an estimate of the volume of the convex set using sampling
and performing Monte Carlo integration.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>this method is intended to be used for low to moderate dimensions
(d&lt;15). For larger dimensions, a telescopic product approach has
yet to be implemented. See, e.g.,
<a class="reference external" href="https://proceedings.mlr.press/v151/chevallier22a/chevallier22a.pdf">https://proceedings.mlr.press/v151/chevallier22a/chevallier22a.pdf</a></p>
</div>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">generator</span></code>:</dt><dd><p>a random number generator.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">desired_rel_accuracy</span></code>:</dt><dd><p>the desired relative accuracy of the volume estimate in the sense
that the estimated volume is likely to be within the interval
defined by (1±2*desired_rel_accuracy)*true_volume with probability
of at least* 0.95 according to the Law of Large Numbers.
<a class="reference external" href="https://people.math.umass.edu/~lr7q/ps_files/teaching/math456/Chapter6.pdf">https://people.math.umass.edu/~lr7q/ps_files/teaching/math456/Chapter6.pdf</a>
The computation will terminate when the relative error is less
than rel_accuracy or when the maximum number of samples is
reached.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">max_num_samples</span></code>:</dt><dd><p>the maximum number of samples to use.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">desired_rel_accuracy</span></code> is in the range [0,1].</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a pair the estimated volume of the set and an upper bound for the
relative accuracy</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>if ambient_dimension</strong><strong>(</strong><strong>) </strong><strong>== 0.</strong> – </p></li>
<li><p><strong>if the minimum axis-aligned bounding box</strong><strong> of </strong><strong>the set cannot be</strong> – </p></li>
<li><p><strong>computed.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ConvexSet.Clone(self:</span> <span class="pre">pydrake.geometry.optimization.ConvexSet)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.geometry.optimization.ConvexSet</span></span></dt>
<dd><p>Creates a unique deep copy of this set.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ConvexSet.IntersectsWith(self:</span> <span class="pre">pydrake.geometry.optimization.ConvexSet,</span> <span class="pre">other:</span> <span class="pre">pydrake.geometry.optimization.ConvexSet)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns true iff the intersection between <code class="docutils literal notranslate"><span class="pre">this</span></code> and <code class="docutils literal notranslate"><span class="pre">other</span></code> is
non-empty.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the ambient dimension</strong><strong> of </strong><strong>other is not the same</strong> – </p></li>
<li><p><strong>as that</strong><strong> of </strong><strong>this.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ConvexSet.IsBounded(self:</span> <span class="pre">pydrake.geometry.optimization.ConvexSet,</span> <span class="pre">parallelism:</span> <span class="pre">pydrake.common.Parallelism</span> <span class="pre">=</span> <span class="pre">Parallelism(num_threads=1))</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns true iff the set is bounded, e.g., there exists an
element-wise finite lower and upper bound for the set. Note: for some
derived classes, this check is trivial, but for others it can require
solving a number of (typically small) optimization problems. Each
derived class documents the cost of its boundedness test and whether
it honors the request for parallelism. (Derived classes which do not
have a specialized check will, by default, honor parallelism
requests.) Note that the overhead of multithreading may lead to slower
runtimes for simple, low-dimensional sets, but can enable major
speedups for more challenging problems.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">parallelism</span></code>:</dt><dd><p>requests the number of cores to use when solving mathematical
programs to check boundedness, subject to whether a particular
derived class honors parallelism.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ConvexSet.IsEmpty(self:</span> <span class="pre">pydrake.geometry.optimization.ConvexSet)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns true iff the set is empty. Note: for some derived classes,
this check is trivial, but for others, it can require solving a
(typically small) optimization problem. Check the derived class
documentation for any notes. Zero-dimensional sets must be handled
specially. There are two possible sets in a zero-dimensional space –
the empty set, and the whole set (which is simply the “zero vector
space”, {0}.) For more details, see:
<a class="reference external" href="https://en.wikipedia.org/wiki/Examples_of_vector_spaces#Trivial_or_zero_vector_space">https://en.wikipedia.org/wiki/Examples_of_vector_spaces#Trivial_or_zero_vector_space</a>
Zero-dimensional sets are considered to be nonempty by default. Sets
which can be zero-dimensional and empty must handle this behavior in
their derived implementation of DoIsEmpty. An example of such a
subclass is VPolytope.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ConvexSet.MaybeGetFeasiblePoint(self:</span> <span class="pre">pydrake.geometry.optimization.ConvexSet)</span> <span class="pre">-&gt;</span> <span class="pre">Optional[numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]]</span></span></dt>
<dd><p>Returns a feasible point within this convex set if it is nonempty, and
nullopt otherwise.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ConvexSet.MaybeGetPoint(self:</span> <span class="pre">pydrake.geometry.optimization.ConvexSet)</span> <span class="pre">-&gt;</span> <span class="pre">Optional[numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]]</span></span></dt>
<dd><p>If this set trivially contains exactly one point, returns the value of
that point. Otherwise, returns nullopt. By “trivially”, we mean that
representation of the set structurally maps to a single point; if
checking for point-ness would require solving an optimization program,
returns nullopt. In other words, this is a relatively cheap function
to call.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ConvexSet.PointInSet(self:</span> <span class="pre">pydrake.geometry.optimization.ConvexSet,</span> <span class="pre">x:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]],</span> <span class="pre">tol:</span> <span class="pre">float</span> <span class="pre">=</span> <span class="pre">1e-08)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns true iff the point x is contained in the set. If the ambient
dimension is zero, then if the set is nonempty, the point is trivially
in the set, and if the set is empty, the point is trivially not in the
set.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ConvexSet.Projection(self:</span> <span class="pre">pydrake.geometry.optimization.ConvexSet,</span> <span class="pre">points:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous])</span> <span class="pre">-&gt;</span> <span class="pre">Optional[tuple[list[float],</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n]]]]</span></span></dt>
<dd><p>Computes in the L₂ norm the distance and the nearest point in this
convex set to every column of <code class="docutils literal notranslate"><span class="pre">points</span></code>. If this set is empty, we
return nullopt.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>points.rows() == ambient_dimension().</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>if the internal convex optimization solver fails.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ConvexSet.ToShapeWithPose(self:</span> <span class="pre">pydrake.geometry.optimization.ConvexSet)</span> <span class="pre">-&gt;</span> <span class="pre">tuple[pydrake.geometry.Shape,</span> <span class="pre">pydrake.math.RigidTransform]</span></span></dt>
<dd><p>Constructs a Shape and a pose of the set in the world frame for use in
the SceneGraph geometry ecosystem.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if ambient_dimension</strong><strong>(</strong><strong>) </strong><strong>!= 3</strong><strong> or </strong><strong>if the functionality</strong> – </p></li>
<li><p><strong>for a particular set has not been implemented yet.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CspaceFreePolytope</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.geometry.optimization.CspaceFreePolytopeBase</span></code></p>
<p>This class tries to find large convex polytopes in the
tangential-configuration space, such that all configurations in the
convex polytopes is collision free. By tangential-configuration space,
we mean the revolute joint angle θ is replaced by t = tan(θ/2). We
refer to the algorithm as C-IRIS. For more details, refer to the paper</p>
<p>Certified Polyhedral Decomposition of Collision-Free Configuration
Space by Hongkai Dai*, Alexandre Amice*, Peter Werner, Annan Zhang and
Russ Tedrake.</p>
<p>A conference version is published at</p>
<p>Finding and Optimizing Certified, Collision-Free Regions in
Configuration Space for Robot Manipulators by Alexandre Amice*,
Hongkai Dai*, Peter Werner, Annan Zhang and Russ Tedrake.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CspaceFreePolytope.__init__(self:</span> <span class="pre">pydrake.geometry.optimization.CspaceFreePolytope,</span> <span class="pre">plant:</span> <span class="pre">drake::multibody::MultibodyPlant&lt;double&gt;,</span> <span class="pre">scene_graph:</span> <span class="pre">pydrake.geometry.SceneGraph,</span> <span class="pre">plane_order:</span> <span class="pre">pydrake.geometry.optimization.SeparatingPlaneOrder,</span> <span class="pre">q_star:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]],</span> <span class="pre">options:</span> <span class="pre">pydrake.geometry.optimization.CspaceFreePolytopeBase.Options</span> <span class="pre">=</span> <span class="pre">Options(with_cross_y=False))</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">plant</span></code>:</dt><dd><p>The plant for which we compute the C-space free polytopes. It must
outlive this CspaceFreePolytope object.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">scene_graph</span></code>:</dt><dd><p>The scene graph that has been connected with <code class="docutils literal notranslate"><span class="pre">plant</span></code>. It must
outlive this CspaceFreePolytope object.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">plane_order</span></code>:</dt><dd><p>The order of the polynomials in the plane to separate a pair of
collision geometries.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">q_star</span></code>:</dt><dd><p>Refer to RationalForwardKinematics for its meaning.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>CspaceFreePolytope knows nothing about contexts. The plant and
scene_graph must be fully configured before instantiating this
class.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CspaceFreePolytope.BilinearAlternationOptions</span></span></dt>
<dd><p>Options for bilinear alternation.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CspaceFreePolytope.BilinearAlternationOptions.__init__(self:</span> <span class="pre">pydrake.geometry.optimization.CspaceFreePolytope.BilinearAlternationOptions)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CspaceFreePolytope.BilinearAlternationOptions.convergence_tol</span></span></dt>
<dd><p>When the change of the cost function between two consecutive
iterations in bilinear alternation is no larger than this number, stop
the bilinear alternation. Must be non-negative.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CspaceFreePolytope.BilinearAlternationOptions.ellipsoid_scaling</span></span></dt>
<dd><p>After finding the maximal inscribed ellipsoid in C-space polytope {s |
C*s&lt;=d, s_lower&lt;=s&lt;=s_upper}, we scale this ellipsoid by
ellipsoid_scaling, and require the new C-space polytope to contain
this scaled ellipsoid. ellipsoid_scaling=1 corresponds to no scaling.
Must be strictly positive and no greater than 1.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CspaceFreePolytope.BilinearAlternationOptions.find_lagrangian_options</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CspaceFreePolytope.BilinearAlternationOptions.find_polytope_options</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CspaceFreePolytope.BilinearAlternationOptions.max_iter</span></span></dt>
<dd><p>The maximum number of bilinear alternation iterations. Must be
non-negative.</p>
</dd></dl>

</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CspaceFreePolytope.BinarySearch(self:</span> <span class="pre">pydrake.geometry.optimization.CspaceFreePolytope,</span> <span class="pre">ignored_collision_pairs:</span> <span class="pre">set[Tuple[pydrake.geometry.GeometryId]],</span> <span class="pre">C:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous],</span> <span class="pre">d:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]],</span> <span class="pre">s_center:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]],</span> <span class="pre">options:</span> <span class="pre">pydrake.geometry.optimization.CspaceFreePolytope.BinarySearchOptions)</span> <span class="pre">-&gt;</span> <span class="pre">Optional[pydrake.geometry.optimization.CspaceFreePolytope.SearchResult]</span></span></dt>
<dd><p>Binary search on d such that the C-space polytope {s | C*s&lt;=d,
s_lower&lt;=s&lt;=s_upper} is collision free. We scale the polytope {s |
C*s&lt;=d_init} about its center <code class="docutils literal notranslate"><span class="pre">s_center</span></code> and search the scaling
factor.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>s_center is in the polytope {s | C*s&lt;=d_init, s_lower&lt;=s&lt;=s_upper}</p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CspaceFreePolytope.BinarySearchOptions</span></span></dt>
<dd><p>Options for binary search.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CspaceFreePolytope.BinarySearchOptions.__init__(self:</span> <span class="pre">pydrake.geometry.optimization.CspaceFreePolytope.BinarySearchOptions)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CspaceFreePolytope.BinarySearchOptions.convergence_tol</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CspaceFreePolytope.BinarySearchOptions.find_lagrangian_options</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CspaceFreePolytope.BinarySearchOptions.max_iter</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CspaceFreePolytope.BinarySearchOptions.scale_max</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CspaceFreePolytope.BinarySearchOptions.scale_min</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CspaceFreePolytope.EllipsoidMarginCost</span></span></dt>
<dd><p>The cost used when fixing the Lagrangian multiplier and search for C
and d in the C-space polytope {s | C*s &lt;=d, s_lower&lt;=s&lt;=s_upper}. We
denote δᵢ as the margin between the i’th face C.row(i)&lt;=d(i) to the
inscribed ellipsoid.</p>
<p>Members:</p>
<blockquote>
<div><p>kSum</p>
<p>kGeometricMean</p>
</div></blockquote>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CspaceFreePolytope.EllipsoidMarginCost.__init__(self:</span> <span class="pre">pydrake.geometry.optimization.CspaceFreePolytope.EllipsoidMarginCost,</span> <span class="pre">value:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CspaceFreePolytope.EllipsoidMarginCost.kGeometricMean</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CspaceFreePolytope.EllipsoidMarginCost.kSum</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CspaceFreePolytope.EllipsoidMarginCost.name</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CspaceFreePolytope.EllipsoidMarginCost.value</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CspaceFreePolytope.FindPolytopeGivenLagrangianOptions</span></span></dt>
<dd><p>Options for finding polytope with given Lagrangians.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CspaceFreePolytope.FindPolytopeGivenLagrangianOptions.__init__(self:</span> <span class="pre">pydrake.geometry.optimization.CspaceFreePolytope.FindPolytopeGivenLagrangianOptions)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CspaceFreePolytope.FindPolytopeGivenLagrangianOptions.backoff_scale</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CspaceFreePolytope.FindPolytopeGivenLagrangianOptions.ellipsoid_margin_cost</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CspaceFreePolytope.FindPolytopeGivenLagrangianOptions.ellipsoid_margin_epsilon</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CspaceFreePolytope.FindPolytopeGivenLagrangianOptions.s_inner_pts</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CspaceFreePolytope.FindPolytopeGivenLagrangianOptions.search_s_bounds_lagrangians</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CspaceFreePolytope.FindPolytopeGivenLagrangianOptions.solver_id</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CspaceFreePolytope.FindPolytopeGivenLagrangianOptions.solver_options</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CspaceFreePolytope.FindSeparationCertificateGivenPolytope(self:</span> <span class="pre">pydrake.geometry.optimization.CspaceFreePolytope,</span> <span class="pre">C:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous],</span> <span class="pre">d:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]],</span> <span class="pre">ignored_collision_pairs:</span> <span class="pre">set[Tuple[pydrake.geometry.GeometryId]],</span> <span class="pre">options:</span> <span class="pre">pydrake.geometry.optimization.CspaceFreePolytope.FindSeparationCertificateGivenPolytopeOptions)</span> <span class="pre">-&gt;</span> <span class="pre">tuple[bool,</span> <span class="pre">dict[Tuple[pydrake.geometry.GeometryId],</span> <span class="pre">pydrake.geometry.optimization.CspaceFreePolytope.SeparationCertificateResult]]</span></span></dt>
<dd><p>Finds the certificates that the C-space polytope {s | C*s&lt;=d, s_lower
&lt;= s &lt;= s_upper} is collision free.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">C</span></code>:</dt><dd><p>The C-space polytope is {s | C*s&lt;=d, s_lower&lt;=s&lt;=s_upper}</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">d</span></code>:</dt><dd><p>The C-space polytope is {s | C*s&lt;=d, s_lower&lt;=s&lt;=s_upper}</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">ignored_collision_pairs</span></code>:</dt><dd><p>We will ignore the pair of geometries in
<code class="docutils literal notranslate"><span class="pre">ignored_collision_pairs</span></code>.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">certificates</span></code>:</dt><dd><p>Contains the certificate we successfully found for each pair of
geometries. Notice that depending on <code class="docutils literal notranslate"><span class="pre">options</span></code>, the program
could search for the certificate for each geometry pair in
parallel, and will terminate the search once it fails to find the
certificate for any pair.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">success</span></code>:</dt><dd><p>If true, then we have certified that the C-space polytope {s |
C*s&lt;=d, s_lower&lt;=s&lt;=s_upper} is collision free. Otherwise
success=false.</p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CspaceFreePolytope.FindSeparationCertificateGivenPolytopeOptions</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.geometry.optimization.FindSeparationCertificateOptions</span></code></p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CspaceFreePolytope.FindSeparationCertificateGivenPolytopeOptions.__init__(self:</span> <span class="pre">pydrake.geometry.optimization.CspaceFreePolytope.FindSeparationCertificateGivenPolytopeOptions)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CspaceFreePolytope.FindSeparationCertificateGivenPolytopeOptions.ignore_redundant_C</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CspaceFreePolytope.MakeIsGeometrySeparableProgram(self:</span> <span class="pre">pydrake.geometry.optimization.CspaceFreePolytope,</span> <span class="pre">geometry_pair:</span> <span class="pre">Tuple[pydrake.geometry.GeometryId],</span> <span class="pre">C:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous],</span> <span class="pre">d:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.geometry.optimization.CspaceFreePolytope.SeparationCertificateProgram</span></span></dt>
<dd><p>Constructs the MathematicalProgram which searches for a separation
certificate for a pair of geometries for a C-space polytope. Search
for the separation certificate for a pair of geometries for a C-space
polytope {s | C*s&lt;=d, s_lower&lt;=s&lt;=s_upper}.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>an error if this geometry_pair doesn't need separation</strong> – </p></li>
<li><p><strong>certificate</strong><strong> (</strong><strong>for example</strong><strong>, </strong><strong>they are on the same body</strong><strong>)</strong><strong>.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CspaceFreePolytope.SearchResult</span></span></dt>
<dd><p>Result on searching the C-space polytope and separating planes.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CspaceFreePolytope.SearchResult.__init__(self:</span> <span class="pre">pydrake.geometry.optimization.CspaceFreePolytope.SearchResult)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CspaceFreePolytope.SearchResult.a(self:</span> <span class="pre">pydrake.geometry.optimization.CspaceFreePolytope.SearchResult)</span> <span class="pre">-&gt;</span> <span class="pre">dict[int,</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]]]</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CspaceFreePolytope.SearchResult.b(self:</span> <span class="pre">pydrake.geometry.optimization.CspaceFreePolytope.SearchResult)</span> <span class="pre">-&gt;</span> <span class="pre">dict[int,</span> <span class="pre">pydrake.symbolic.Polynomial]</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CspaceFreePolytope.SearchResult.C(self:</span> <span class="pre">pydrake.geometry.optimization.CspaceFreePolytope.SearchResult)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n]]</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CspaceFreePolytope.SearchResult.certified_polytope(self:</span> <span class="pre">pydrake.geometry.optimization.CspaceFreePolytope.SearchResult)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.geometry.optimization.HPolyhedron</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CspaceFreePolytope.SearchResult.d(self:</span> <span class="pre">pydrake.geometry.optimization.CspaceFreePolytope.SearchResult)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CspaceFreePolytope.SearchResult.num_iter(self:</span> <span class="pre">pydrake.geometry.optimization.CspaceFreePolytope.SearchResult)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CspaceFreePolytope.SearchWithBilinearAlternation(self:</span> <span class="pre">pydrake.geometry.optimization.CspaceFreePolytope,</span> <span class="pre">ignored_collision_pairs:</span> <span class="pre">set[Tuple[pydrake.geometry.GeometryId]],</span> <span class="pre">C_init:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous],</span> <span class="pre">d_init:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]],</span> <span class="pre">options:</span> <span class="pre">pydrake.geometry.optimization.CspaceFreePolytope.BilinearAlternationOptions)</span> <span class="pre">-&gt;</span> <span class="pre">list[pydrake.geometry.optimization.CspaceFreePolytope.SearchResult]</span></span></dt>
<dd><p>Search for a collision-free C-space polytope. {s | C*s&lt;=d,
s_lower&lt;=s&lt;=s_upper} through bilinear alternation. The goal is to
maximize the volume the C-space polytope. Since we can’t compute the
polytope volume in the closed form, we use the volume of the maximal
inscribed ellipsoid as a surrogate function of the polytope volume.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">ignored_collision_pairs</span></code>:</dt><dd><p>The pairs of geometries that we ignore when searching for
separation certificates.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">C_init</span></code>:</dt><dd><p>The initial value of C.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">d_init</span></code>:</dt><dd><p>The initial value of d.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">options</span></code>:</dt><dd><p>The options for the bilinear alternation.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">results</span></code>:</dt><dd><p>Stores the certification result in each iteration of the bilinear
alternation.</p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CspaceFreePolytope.SeparatingPlaneLagrangians</span></span></dt>
<dd><p>When searching for the separating plane, we want to certify that the
numerator of a rational is non-negative in the C-space region C*s&lt;=d,
s_lower &lt;= s &lt;= s_upper. Hence for each of the rational we will
introduce Lagrangian multipliers for the polytopic constraint d-C*s &gt;=
0, s - s_lower &gt;= 0, s_upper - s &gt;= 0.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CspaceFreePolytope.SeparatingPlaneLagrangians.__init__(self:</span> <span class="pre">pydrake.geometry.optimization.CspaceFreePolytope.SeparatingPlaneLagrangians,</span> <span class="pre">C_rows:</span> <span class="pre">int,</span> <span class="pre">s_size:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CspaceFreePolytope.SeparatingPlaneLagrangians.GetSolution(self:</span> <span class="pre">pydrake.geometry.optimization.CspaceFreePolytope.SeparatingPlaneLagrangians,</span> <span class="pre">result:</span> <span class="pre">pydrake.solvers.MathematicalProgramResult)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.geometry.optimization.CspaceFreePolytope.SeparatingPlaneLagrangians</span></span></dt>
<dd><p>Substitutes the decision variables in each Lagrangians with its value
in result, returns the substitution result.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CspaceFreePolytope.SeparatingPlaneLagrangians.polytope(self:</span> <span class="pre">pydrake.geometry.optimization.CspaceFreePolytope.SeparatingPlaneLagrangians)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]]</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CspaceFreePolytope.SeparatingPlaneLagrangians.s_lower(self:</span> <span class="pre">pydrake.geometry.optimization.CspaceFreePolytope.SeparatingPlaneLagrangians)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]]</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CspaceFreePolytope.SeparatingPlaneLagrangians.s_upper(self:</span> <span class="pre">pydrake.geometry.optimization.CspaceFreePolytope.SeparatingPlaneLagrangians)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]]</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CspaceFreePolytope.SeparationCertificate</span></span></dt>
<dd><p>This struct stores the necessary information to search for the
separating plane for the polytopic C-space region C*s &lt;= d, s_lower &lt;=
s &lt;= s_upper. We need to impose that N rationals are non-negative in
this C-space polytope. The denominator of each rational is always
positive hence we need to impose the N numerators are non-negative in
this C-space region. We impose the condition numerator_i(s) - λ(s)ᵀ *
(d - C*s) - λ_lower(s)ᵀ * (s - s_lower) -λ_upper(s)ᵀ * (s_upper - s)
is sos λ(s) are sos, λ_lower(s) are sos, λ_upper(s) are sos.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CspaceFreePolytope.SeparationCertificate.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CspaceFreePolytope.SeparationCertificate.GetSolution(self:</span> <span class="pre">pydrake.geometry.optimization.CspaceFreePolytope.SeparationCertificate,</span> <span class="pre">plane_index:</span> <span class="pre">int,</span> <span class="pre">a:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]],</span> <span class="pre">b:</span> <span class="pre">pydrake.symbolic.Polynomial,</span> <span class="pre">plane_decision_vars:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]],</span> <span class="pre">result:</span> <span class="pre">pydrake.solvers.MathematicalProgramResult)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.geometry.optimization.CspaceFreePolytope.SeparationCertificateResult</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CspaceFreePolytope.SeparationCertificate.negative_side_rational_lagrangians</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CspaceFreePolytope.SeparationCertificate.positive_side_rational_lagrangians</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CspaceFreePolytope.SeparationCertificateProgram</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.geometry.optimization.SeparationCertificateProgramBase</span></code></p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CspaceFreePolytope.SeparationCertificateProgram.__init__(self:</span> <span class="pre">pydrake.geometry.optimization.CspaceFreePolytope.SeparationCertificateProgram)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CspaceFreePolytope.SeparationCertificateProgram.certificate</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CspaceFreePolytope.SeparationCertificateProgram.plane_index</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CspaceFreePolytope.SeparationCertificateResult</span></span></dt>
<dd><p>We certify that a pair of geometries is collision free in the C-space
region {s | Cs&lt;=d, s_lower&lt;=s&lt;=s_upper} by finding the separating
plane and the Lagrangian multipliers. This struct contains the
certificate, that the separating plane {x | aᵀx+b=0 } separates the
two geometries in separating_planes()[plane_index] in the C-space
polytope.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CspaceFreePolytope.SeparationCertificateResult.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CspaceFreePolytope.SeparationCertificateResult.a</span></span></dt>
<dd><p>The separating plane is { x | aᵀx+b=0 }</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CspaceFreePolytope.SeparationCertificateResult.b</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CspaceFreePolytope.SeparationCertificateResult.negative_side_rational_lagrangians</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CspaceFreePolytope.SeparationCertificateResult.plane_decision_var_vals</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CspaceFreePolytope.SeparationCertificateResult.plane_index</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CspaceFreePolytope.SeparationCertificateResult.positive_side_rational_lagrangians</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CspaceFreePolytope.SeparationCertificateResult.result</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CspaceFreePolytope.SolveSeparationCertificateProgram(self:</span> <span class="pre">pydrake.geometry.optimization.CspaceFreePolytope,</span> <span class="pre">certificate_program:</span> <span class="pre">pydrake.geometry.optimization.CspaceFreePolytope.SeparationCertificateProgram,</span> <span class="pre">options:</span> <span class="pre">pydrake.geometry.optimization.CspaceFreePolytope.FindSeparationCertificateGivenPolytopeOptions)</span> <span class="pre">-&gt;</span> <span class="pre">Optional[pydrake.geometry.optimization.CspaceFreePolytope.SeparationCertificateResult]</span></span></dt>
<dd><p>Solves a SeparationCertificateProgram with the given options</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>result If we find the separation certificate, then <code class="docutils literal notranslate"><span class="pre">result</span></code>
contains the separation plane and the Lagrangian polynomials;
otherwise result is empty.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CspaceFreePolytopeBase</span></span></dt>
<dd><p>This virtual class is the base of CspaceFreePolytope and
CspaceFreeBox. We take the common functionality between these concrete
derived class to this shared parent class.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CspaceFreePolytopeBase.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CspaceFreePolytopeBase.map_geometries_to_separating_planes(self:</span> <span class="pre">pydrake.geometry.optimization.CspaceFreePolytopeBase)</span> <span class="pre">-&gt;</span> <span class="pre">dict[Tuple[pydrake.geometry.GeometryId],</span> <span class="pre">int]</span></span></dt>
<dd><p>separating_planes()[map_geometries_to_separating_planes.at(geometry1_id,
geometry2_id)] is the separating plane that separates geometry 1 and
geometry 2.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CspaceFreePolytopeBase.Options</span></span></dt>
<dd><p>Optional argument for constructing CspaceFreePolytopeBase</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CspaceFreePolytopeBase.Options.__init__(self:</span> <span class="pre">pydrake.geometry.optimization.CspaceFreePolytopeBase.Options)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CspaceFreePolytopeBase.Options.with_cross_y</span></span></dt>
<dd><p>For non-polytopic collision geometries, we will impose a matrix-sos
constraint X(s) being psd, with a slack indeterminates y, such that
the polynomial</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">p</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">⌈</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="err">⌉</span><span class="n">ᵀ</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">X</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="err">⌈</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="err">⌉</span>
<span class="err">⌊</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="err">⌋</span><span class="w">           </span><span class="err">⌊</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="err">⌋</span>
</pre></div>
</div>
</details><p>is positive. This p(s, y) polynomial doesn’t contain the cross term of
y (namely it doesn’t have y(i)*y(j), i≠j). When we select the monomial
basis for this polynomial, we can also exclude the cross term of y in
the monomial basis.</p>
<p>To illustrate the idea, let’s consider the following toy example: if
we want to certify that a(0) + a(1)*y₀ + a(2)*y₁ + a(3)*y₀² + a(4)*y₁²
is positive (this polynomial doesn’t have the cross term y₀*y₁), we
can write it as</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="err">⌈</span><span class="w"> </span><span class="mi">1</span><span class="err">⌉</span><span class="n">ᵀ</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">A₀</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="err">⌈</span><span class="w"> </span><span class="mi">1</span><span class="err">⌉</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="err">⌈</span><span class="w"> </span><span class="mi">1</span><span class="err">⌉</span><span class="n">ᵀ</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">A₁</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="err">⌈</span><span class="w"> </span><span class="mi">1</span><span class="err">⌉</span>
<span class="err">⌊</span><span class="n">y₀</span><span class="err">⌋</span><span class="w">         </span><span class="err">⌊</span><span class="n">y₀</span><span class="err">⌋</span><span class="w">   </span><span class="err">⌊</span><span class="n">y₁</span><span class="err">⌋</span><span class="w">         </span><span class="err">⌊</span><span class="n">y₁</span><span class="err">⌋</span>
</pre></div>
</div>
</details><p>with two small psd matrices A₀, A₁ Instead of</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="err">⌈</span><span class="w"> </span><span class="mi">1</span><span class="err">⌉</span><span class="n">ᵀ</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="err">⌈</span><span class="w"> </span><span class="mi">1</span><span class="err">⌉</span>
<span class="o">|</span><span class="n">y₀</span><span class="o">|</span><span class="w">        </span><span class="o">|</span><span class="n">y₀</span><span class="o">|</span>
<span class="err">⌊</span><span class="n">y₁</span><span class="err">⌋</span><span class="w">        </span><span class="err">⌊</span><span class="n">y₁</span><span class="err">⌋</span>
</pre></div>
</div>
</details><p>with one large psd matrix A. The first parameterization won’t have the
cross term y₀*y₁ by construction, while the second parameterization
requires imposing extra constraints on certain off-diagonal terms in A
so that the cross term vanishes.</p>
<p>If we set with_cross_y = false, then we will use the monomial basis
that doesn’t generate cross terms of y, leading to smaller size sos
problems. If we set with_cross_y = true, then we will use the monomial
basis that will generate cross terms of y, causing larger size sos
problems, but possibly able to certify a larger C-space polytope.</p>
</dd></dl>

</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CspaceFreePolytopeBase.separating_planes(self:</span> <span class="pre">pydrake.geometry.optimization.CspaceFreePolytopeBase)</span> <span class="pre">-&gt;</span> <span class="pre">list[pydrake.geometry.optimization.CSpaceSeparatingPlane_[Variable]]</span></span></dt>
<dd><p>All the separating planes between each pair of geometries.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CspaceFreePolytopeBase.y_slack(self:</span> <span class="pre">pydrake.geometry.optimization.CspaceFreePolytopeBase)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Get the slack variable used for non-polytopic collision geometries.
Check Options class for more details.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CSpaceSeparatingPlane</span></span></dt>
<dd><p>Wraps the information that a pair of collision geometries are
separated by a plane. One collision geometry is on the “positive” side
of the separating plane, namely {x| aᵀx + b ≥ δ} (with δ ≥ 0}, and the
other collision geometry is on the “negative” side of the separating
plane, namely {x|aᵀx+b ≤ −δ}.</p>
<dl class="simple">
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">T</span></code>:</dt><dd><p>The type of decision_variables. T= symbolic::Variable or double.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">CSpaceSeparatingPlane_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CSpaceSeparatingPlane.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CSpaceSeparatingPlane.a</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CSpaceSeparatingPlane.b</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CSpaceSeparatingPlane.decision_variables</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CSpaceSeparatingPlane.expressed_body</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CSpaceSeparatingPlane.negative_side_geometry</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CSpaceSeparatingPlane.plane_degree</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CSpaceSeparatingPlane.positive_side_geometry</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CSpaceSeparatingPlane_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">CSpaceSeparatingPlane_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">CSpaceSeparatingPlane_[Variable]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CSpaceSeparatingPlane_[Variable]</span></span></dt>
<dd><p>Wraps the information that a pair of collision geometries are
separated by a plane. One collision geometry is on the “positive” side
of the separating plane, namely {x| aᵀx + b ≥ δ} (with δ ≥ 0}, and the
other collision geometry is on the “negative” side of the separating
plane, namely {x|aᵀx+b ≤ −δ}.</p>
<dl class="simple">
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">T</span></code>:</dt><dd><p>The type of decision_variables. T= symbolic::Variable or double.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CSpaceSeparatingPlane_[Variable].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CSpaceSeparatingPlane_[Variable].a</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CSpaceSeparatingPlane_[Variable].b</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CSpaceSeparatingPlane_[Variable].decision_variables</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CSpaceSeparatingPlane_[Variable].expressed_body</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CSpaceSeparatingPlane_[Variable].negative_side_geometry</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CSpaceSeparatingPlane_[Variable].plane_degree</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CSpaceSeparatingPlane_[Variable].positive_side_geometry</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">FindSeparationCertificateOptions</span></span></dt>
<dd><dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">FindSeparationCertificateOptions.__init__(self:</span> <span class="pre">pydrake.geometry.optimization.FindSeparationCertificateOptions)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">FindSeparationCertificateOptions.parallelism</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">FindSeparationCertificateOptions.solver_id</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">FindSeparationCertificateOptions.solver_options</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">FindSeparationCertificateOptions.terminate_at_failure</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">FindSeparationCertificateOptions.verbose</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GcsGraphvizOptions</span></span></dt>
<dd><dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GcsGraphvizOptions.__init__(self:</span> <span class="pre">pydrake.geometry.optimization.GcsGraphvizOptions,</span> <span class="pre">**kwargs)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GcsGraphvizOptions.precision</span></span></dt>
<dd><p>Sets the floating point precision (how many digits are generated) of
the annotations.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GcsGraphvizOptions.scientific</span></span></dt>
<dd><p>Sets the floating point formatting to scientific (if true) or fixed
(if false).</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GcsGraphvizOptions.show_costs</span></span></dt>
<dd><p>Determines whether the cost value results are shown. This will show
both edge and vertex costs.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GcsGraphvizOptions.show_flows</span></span></dt>
<dd><p>Determines whether the flow value results are shown. The flow values
are shown both with a numeric value and through the transparency value
on the edge, where a flow of 0.0 will correspond to an (almost)
invisible edge, and a flow of 1.0 will display as a fully black edge.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GcsGraphvizOptions.show_slacks</span></span></dt>
<dd><p>Determines whether the values of the intermediate (slack) variables
are also displayed in the graph.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GcsGraphvizOptions.show_vars</span></span></dt>
<dd><p>Determines whether the solution values for decision variables in each
set are shown.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GraphOfConvexSets</span></span></dt>
<dd><p>GraphOfConvexSets (GCS) implements the design pattern and optimization
problems first introduced in the paper “Shortest Paths in Graphs of
Convex Sets”.</p>
<p>“Shortest Paths in Graphs of Convex Sets” by Tobia Marcucci, Jack
Umenberger, Pablo A. Parrilo, Russ Tedrake.
<a class="reference external" href="https://arxiv.org/abs/2101.11565">https://arxiv.org/abs/2101.11565</a></p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This feature is considered to be <strong>experimental</strong> and may change
or be removed at any time, without any deprecation notice ahead of
time.</p>
</div>
<p>Each vertex in the graph is associated with a convex set over
continuous variables, edges in the graph contain convex costs and
constraints on these continuous variables. We can then formulate
optimization problems over this graph, such as the shortest path
problem where each visit to a vertex also corresponds to selecting an
element from the convex set subject to the costs and constraints.
Behind the scenes, we construct efficient mixed-integer convex
transcriptions of the graph problem using MathematicalProgram.
However, we provide the option to solve an often tight convex
relaxation of the problem with
GraphOfConvexSetsOptions::convex_relaxation and employ a cheap
rounding stage which solves the convex restriction along potential
paths to find a feasible solution to the original problem.</p>
<p>Design note: This class avoids providing any direct access to the
MathematicalProgram that it constructs nor to the decision variables /
constraints. The users should be able to write constraints against
“placeholder” decision variables on the vertices and edges, but these
get translated in non-trivial ways to the underlying program.</p>
<p><strong>Advanced Usage: Guiding Non-convex Optimization with the
GraphOfConvexSets</strong></p>
<p>Solving a GCS problem using convex relaxation involves two components:
- Convex Relaxation: The relaxation of the binary variables (edge
activations) and perspective operations on the convex cost/constraints
leads to a convex problem that considers the graph as a whole. -
Rounding: After solving the relaxation, a randomized rounding scheme
is applied to obtain a feasible solution for the original problem. We
interpret the relaxed flow variables as edge probabilities to guide
the maximum likelyhood depth first search from the source to target
vertices. Each rounding is calling SolveConvexRestriction.</p>
<p>To handle non-convex constraints, one can provide convex surrogates to
the relaxation and the true non-convex constraints to the rounding
problem. These surrogates approximate the non-convex constraints,
making the relaxation solvable as a convex optimization to guide the
non-convex rounding. This can be controlled by the Transcription enum
in the AddConstraint method. We encourage users to provide a strong
convex surrogate, when possible, to better approximate the original
non-convex problem.</p>
<p>Users can also specify a GCS implicitly, which can be important for
very large or infinite graphs, by deriving from
ImplicitGraphOfConvexSets.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GraphOfConvexSets.__init__(self:</span> <span class="pre">pydrake.geometry.optimization.GraphOfConvexSets)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructs an empty graph.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GraphOfConvexSets.AddEdge(self:</span> <span class="pre">pydrake.geometry.optimization.GraphOfConvexSets,</span> <span class="pre">u:</span> <span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.Vertex,</span> <span class="pre">v:</span> <span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.Vertex,</span> <span class="pre">name:</span> <span class="pre">str</span> <span class="pre">=</span> <span class="pre">'')</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.Edge</span></span></dt>
<dd><p>Adds an edge to the graph from Vertex <code class="docutils literal notranslate"><span class="pre">u</span></code> to Vertex <code class="docutils literal notranslate"><span class="pre">v</span></code>. The
vertex references must refer to valid vertices in this graph. If
<code class="docutils literal notranslate"><span class="pre">name</span></code> is empty then a default name will be provided.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if u</strong><strong> or </strong><strong>v are not valid vertices in this</strong> – </p></li>
<li><p><strong>graph.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GraphOfConvexSets.AddEdgeFromTemplate(self:</span> <span class="pre">pydrake.geometry.optimization.GraphOfConvexSets,</span> <span class="pre">u:</span> <span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.Vertex,</span> <span class="pre">v:</span> <span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.Vertex,</span> <span class="pre">template_edge:</span> <span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.Edge)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.Edge</span></span></dt>
<dd><p>Adds an edge to the graph from Vertex <code class="docutils literal notranslate"><span class="pre">u</span></code> to Vertex <code class="docutils literal notranslate"><span class="pre">v</span></code> (and
assigns a new unique EdgeId), by taking the name, costs, and
constraints from <code class="docutils literal notranslate"><span class="pre">template_edge</span></code>. <cite>template_edge</cite> does not need to
be registered with this GCS instance; this method can be used to
effectively copy an Edge from another GCS instance into <code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if u</strong><strong> or </strong><strong>v are not valid vertices in this</strong> – </p></li>
<li><p><strong>graph.</strong> – </p></li>
<li><p><strong>RuntimeError if u</strong><strong> or </strong><strong>v do not match the sizes</strong><strong> of </strong><strong>the</strong> – </p></li>
<li><p><strong>template_edge.u</strong><strong>(</strong><strong>)</strong><strong>` and template_edge.v</strong><strong>(</strong><strong>) </strong><strong>vertices</strong> – </p></li>
<li><p><strong>RuntimeError if edges have slack variables. We can add this</strong> – </p></li>
<li><p><strong>support once it's needed.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GraphOfConvexSets.AddVertex(self:</span> <span class="pre">pydrake.geometry.optimization.GraphOfConvexSets,</span> <span class="pre">set:</span> <span class="pre">pydrake.geometry.optimization.ConvexSet,</span> <span class="pre">name:</span> <span class="pre">str</span> <span class="pre">=</span> <span class="pre">'')</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.Vertex</span></span></dt>
<dd><p>Adds a vertex to the graph. A copy of <code class="docutils literal notranslate"><span class="pre">set</span></code> is cloned and stored
inside the graph. If <code class="docutils literal notranslate"><span class="pre">name</span></code> is empty then a default name will be
provided.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GraphOfConvexSets.AddVertexFromTemplate(self:</span> <span class="pre">pydrake.geometry.optimization.GraphOfConvexSets,</span> <span class="pre">template_vertex:</span> <span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.Vertex)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.Vertex</span></span></dt>
<dd><p>Adds a new vertex to the graph (and assigns a new unique VertexId) by
taking the name, costs, and constraints (but not any edges) from
<code class="docutils literal notranslate"><span class="pre">template_vertex</span></code>. <cite>template_vertex</cite> does not need to be registered
with this GCS instance; this method can be used to effectively copy a
Vertex from another GCS instance into <code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GraphOfConvexSets.ClearAllPhiConstraints(self:</span> <span class="pre">pydrake.geometry.optimization.GraphOfConvexSets)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Removes all constraints added to any edge with AddPhiConstraint.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GraphOfConvexSets.Clone(self:</span> <span class="pre">pydrake.geometry.optimization.GraphOfConvexSets)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.geometry.optimization.GraphOfConvexSets</span></span></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GraphOfConvexSets.Edge</span></span></dt>
<dd><p>An edge in the graph connects between vertex <code class="docutils literal notranslate"><span class="pre">u</span></code> and vertex <code class="docutils literal notranslate"><span class="pre">v</span></code>.
The edge also holds a list of cost and constraints associated with the
continuous variables.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GraphOfConvexSets.Edge.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GraphOfConvexSets.Edge.AddConstraint(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>AddConstraint(self: pydrake.geometry.optimization.GraphOfConvexSets.Edge, f: pydrake.symbolic.Formula, use_in_transcription: set[pydrake.geometry.optimization.GraphOfConvexSets.Transcription] = {&lt;Transcription.kMIP: 0&gt;, &lt;Transcription.kRelaxation: 1&gt;, &lt;Transcription.kRestriction: 2&gt;}) -&gt; pydrake.solvers.Binding[Constraint]</p></li>
</ol>
<p>Adds a constraint to this edge.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">f</span></code>:</dt><dd><p>must contain <em>only</em> elements of xu() and xv() as variables.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">use_in_transcription</span></code>:</dt><dd><p>specifies the components of the problem to which the constraint
should be added.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if f.GetFreeVariables</strong><strong>(</strong><strong>) </strong><strong>is not a subset</strong><strong> of </strong><strong>xu</strong><strong>(</strong><strong>) </strong><strong>∪</strong> – </p></li>
<li><p><strong>xv</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p></li>
<li><p><strong>RuntimeError if xu</strong><strong>(</strong><strong>) </strong><strong>∪ xv</strong><strong>(</strong><strong>) </strong><strong>is empty</strong><strong>, </strong><strong>i.e.</strong><strong>, </strong><strong>when both vertices</strong> – </p></li>
<li><p><strong>have an ambient dimension</strong><strong> of </strong><strong>zero.</strong> – </p></li>
<li><p><strong>RuntimeError if no transcription is specified.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>AddConstraint(self: pydrake.geometry.optimization.GraphOfConvexSets.Edge, binding: pydrake.solvers.Binding[Constraint], use_in_transcription: set[pydrake.geometry.optimization.GraphOfConvexSets.Transcription] = {&lt;Transcription.kMIP: 0&gt;, &lt;Transcription.kRelaxation: 1&gt;, &lt;Transcription.kRestriction: 2&gt;}) -&gt; pydrake.solvers.Binding[Constraint]</p></li>
</ol>
<p>Adds a constraint to this edge.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">binding</span></code>:</dt><dd><p>must contain <em>only</em> elements of xu() and xv() as variables.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">use_in_transcription</span></code>:</dt><dd><p>specifies the components of the problem to which the constraint
should be added.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if binding.variables</strong><strong>(</strong><strong>) </strong><strong>is not a subset</strong><strong> of </strong><strong>xu</strong><strong>(</strong><strong>) </strong><strong>∪</strong> – </p></li>
<li><p><strong>xv</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p></li>
<li><p><strong>RuntimeError if xu</strong><strong>(</strong><strong>) </strong><strong>∪ xv</strong><strong>(</strong><strong>) </strong><strong>is empty</strong><strong>, </strong><strong>i.e.</strong><strong>, </strong><strong>when both vertices</strong> – </p></li>
<li><p><strong>have an ambient dimension</strong><strong> of </strong><strong>zero.</strong> – </p></li>
<li><p><strong>RuntimeError if no transcription is specified.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GraphOfConvexSets.Edge.AddCost(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>AddCost(self: pydrake.geometry.optimization.GraphOfConvexSets.Edge, e: pydrake.symbolic.Expression, use_in_transcription: set[pydrake.geometry.optimization.GraphOfConvexSets.Transcription] = {&lt;Transcription.kMIP: 0&gt;, &lt;Transcription.kRelaxation: 1&gt;, &lt;Transcription.kRestriction: 2&gt;}) -&gt; pydrake.solvers.Binding[Cost]</p></li>
</ol>
<p>Adds a cost to this edge, described by a symbolic::Expression <code class="docutils literal notranslate"><span class="pre">e</span></code>
containing <em>only</em> elements of xu() and xv() as variables. For
technical reasons relating to being able to “turn-off” the cost on
inactive edges, all costs are eventually implemented with a slack
variable and a constraint:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">min</span><span class="w"> </span><span class="n">g</span><span class="p">(</span><span class="n">xu</span><span class="p">,</span><span class="w"> </span><span class="n">xv</span><span class="p">)</span><span class="w"> </span><span class="err">⇒</span><span class="w"> </span><span class="n">min</span><span class="w"> </span><span class="n">ℓ</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">t</span><span class="p">.</span><span class="w"> </span><span class="n">ℓ</span><span class="w"> </span><span class="err">≥</span><span class="w"> </span><span class="n">g</span><span class="p">(</span><span class="n">xu</span><span class="p">,</span><span class="n">xv</span><span class="p">)</span>
</pre></div>
</div>
</details><p>You must use GetSolutionCost() to retrieve the cost of the solution,
rather than evaluating the cost directly, in order to get consistent
behavior when solving with the different GCS transcriptions.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">use_in_transcription</span></code>:</dt><dd><p>specifies the components of the problem to which the constraint
should be added.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Linear costs lead to negative costs if decision variables are not
properly constrained. Users may want to check that the solution
does not contain negative costs.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>the added cost, g(xu, xv).</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>RuntimeError if e.GetVariables</strong><strong>(</strong><strong>) </strong><strong>is not a subset</strong><strong> of </strong><strong>xu</strong><strong>(</strong><strong>) </strong><strong>∪ xv</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p></li>
<li><p><strong>RuntimeError if no transcription is specified.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>AddCost(self: pydrake.geometry.optimization.GraphOfConvexSets.Edge, binding: pydrake.solvers.Binding[Cost], use_in_transcription: set[pydrake.geometry.optimization.GraphOfConvexSets.Transcription] = {&lt;Transcription.kMIP: 0&gt;, &lt;Transcription.kRelaxation: 1&gt;, &lt;Transcription.kRestriction: 2&gt;}) -&gt; pydrake.solvers.Binding[Cost]</p></li>
</ol>
<p>Adds a cost to this edge. <code class="docutils literal notranslate"><span class="pre">binding</span></code> must contain <em>only</em> elements of
xu() and xv() as variables. For technical reasons relating to being
able to “turn-off” the cost on inactive edges, all costs are
eventually implemented with a slack variable and a constraint:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">min</span><span class="w"> </span><span class="n">g</span><span class="p">(</span><span class="n">xu</span><span class="p">,</span><span class="w"> </span><span class="n">xv</span><span class="p">)</span><span class="w"> </span><span class="err">⇒</span><span class="w"> </span><span class="n">min</span><span class="w"> </span><span class="n">ℓ</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">t</span><span class="p">.</span><span class="w"> </span><span class="n">ℓ</span><span class="w"> </span><span class="err">≥</span><span class="w"> </span><span class="n">g</span><span class="p">(</span><span class="n">xu</span><span class="p">,</span><span class="n">xv</span><span class="p">)</span>
</pre></div>
</div>
</details><p>You must use GetSolutionCost() to retrieve the cost of the solution,
rather than evaluating the cost directly, in order to get consistent
behavior when solving with the different GCS transcriptions.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">use_in_transcription</span></code>:</dt><dd><p>specifies the components of the problem to which the constraint
should be added.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Linear costs lead to negative costs if decision variables are not
properly constrained. Users may want to check that the solution
does not contain negative costs.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>the added cost, g(xu, xv).</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>RuntimeError if binding.variables</strong><strong>(</strong><strong>) </strong><strong>is not a subset</strong><strong> of </strong><strong>xu</strong><strong>(</strong><strong>) </strong><strong>∪</strong> – </p></li>
<li><p><strong>xv</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p></li>
<li><p><strong>RuntimeError if no transcription is specified.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GraphOfConvexSets.Edge.AddPhiConstraint(self:</span> <span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.Edge,</span> <span class="pre">phi_value:</span> <span class="pre">bool)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Adds a constraint on the binary variable associated with this edge.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>We intentionally do not return a binding to the constraint created
by this call, as that would allow the caller to make nonsensical
modifications to its bounds (i.e. requiring phi == 0.5).</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GraphOfConvexSets.Edge.ClearPhiConstraints(self:</span> <span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.Edge)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Removes any constraints added with AddPhiConstraint.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GraphOfConvexSets.Edge.GetConstraints(self:</span> <span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.Edge,</span> <span class="pre">used_in_transcription:</span> <span class="pre">set[pydrake.geometry.optimization.GraphOfConvexSets.Transcription]</span> <span class="pre">=</span> <span class="pre">{&lt;Transcription.kMIP:</span> <span class="pre">0&gt;,</span> <span class="pre">&lt;Transcription.kRelaxation:</span> <span class="pre">1&gt;,</span> <span class="pre">&lt;Transcription.kRestriction:</span> <span class="pre">2&gt;})</span> <span class="pre">-&gt;</span> <span class="pre">list[pydrake.solvers.Binding[Constraint]]</span></span></dt>
<dd><p>Returns constraints on this edge.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">used_in_transcription</span></code>:</dt><dd><p>specifies the components of the problem from which the constraint
should be retrieved.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if no transcription is specified.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GraphOfConvexSets.Edge.GetCosts(self:</span> <span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.Edge,</span> <span class="pre">used_in_transcription:</span> <span class="pre">set[pydrake.geometry.optimization.GraphOfConvexSets.Transcription]</span> <span class="pre">=</span> <span class="pre">{&lt;Transcription.kMIP:</span> <span class="pre">0&gt;,</span> <span class="pre">&lt;Transcription.kRelaxation:</span> <span class="pre">1&gt;,</span> <span class="pre">&lt;Transcription.kRestriction:</span> <span class="pre">2&gt;})</span> <span class="pre">-&gt;</span> <span class="pre">list[pydrake.solvers.Binding[Cost]]</span></span></dt>
<dd><p>Returns costs on this edge.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">used_in_transcription</span></code>:</dt><dd><p>specifies the components of the problem from which the constraint
should be retrieved.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if no transcription is specified.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GraphOfConvexSets.Edge.GetSolutionCost(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetSolutionCost(self: pydrake.geometry.optimization.GraphOfConvexSets.Edge, result: pydrake.solvers.MathematicalProgramResult) -&gt; Optional[float]</p></li>
</ol>
<p>Returns the sum of the costs associated with this edge in <code class="docutils literal notranslate"><span class="pre">result</span></code>,
or std::nullopt if no solution for this edge is available.</p>
<ol class="arabic simple" start="2">
<li><p>GetSolutionCost(self: pydrake.geometry.optimization.GraphOfConvexSets.Edge, result: pydrake.solvers.MathematicalProgramResult, cost: pydrake.solvers.Binding[Cost]) -&gt; Optional[float]</p></li>
</ol>
<p>Returns the cost associated with the <code class="docutils literal notranslate"><span class="pre">cost</span></code> binding on this edge in
<code class="docutils literal notranslate"><span class="pre">result</span></code>, or std::nullopt if no solution for this edge is available.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if cost is not associated with this edge.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GraphOfConvexSets.Edge.GetSolutionPhiXu(self:</span> <span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.Edge,</span> <span class="pre">result:</span> <span class="pre">pydrake.solvers.MathematicalProgramResult)</span> <span class="pre">-&gt;</span> <span class="pre">Optional[numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]]</span></span></dt>
<dd><p>Returns the vector value of the slack variables associated with ϕxᵤ in
<code class="docutils literal notranslate"><span class="pre">result</span></code>, or std::nullopt if no solution for this edge is available.
This can obtain a different value than the Vertex::GetSolution(), e.g.
from <code class="docutils literal notranslate"><span class="pre">edge-&gt;xu().GetSolution(result)</span></code>. First, a deactivated edge
(defined by Phi ~= 0) will return the zero vector here, while
Vertex::GetSolution() will return std::nullopt (rather than divide by
zero to recover Xu). Second, in the case of a loose convex relaxation,
the vertex version will return the averaged* value of the edge slacks
for all non-zero-flow edges.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GraphOfConvexSets.Edge.GetSolutionPhiXv(self:</span> <span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.Edge,</span> <span class="pre">result:</span> <span class="pre">pydrake.solvers.MathematicalProgramResult)</span> <span class="pre">-&gt;</span> <span class="pre">Optional[numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]]</span></span></dt>
<dd><p>Returns the vector value of the slack variables associated with ϕxᵥ in
<code class="docutils literal notranslate"><span class="pre">result</span></code>, or std::nullopt if no solution for this edge is available.
See GetSolutionPhiXu() for more details.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GraphOfConvexSets.Edge.id(self:</span> <span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.Edge)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.EdgeId</span></span></dt>
<dd><p>Returns the unique identifier associated with this Edge.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GraphOfConvexSets.Edge.name(self:</span> <span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.Edge)</span> <span class="pre">-&gt;</span> <span class="pre">str</span></span></dt>
<dd><p>Returns the string name associated with this edge.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GraphOfConvexSets.Edge.phi(self:</span> <span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.Edge)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.symbolic.Variable</span></span></dt>
<dd><p>Returns the binary variable associated with this edge. It can be used
to determine whether this edge was active in the solution to an
optimization problem, by calling GetSolution(phi()) on a returned
MathematicalProgramResult.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GraphOfConvexSets.Edge.u(self:</span> <span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.Edge)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.Vertex</span></span></dt>
<dd><p>Returns a mutable reference to the “left” Vertex that this edge
connects to.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GraphOfConvexSets.Edge.v(self:</span> <span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.Edge)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.Vertex</span></span></dt>
<dd><p>Returns a mutable reference to the “right” Vertex that this edge
connects to.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GraphOfConvexSets.Edge.xu(self:</span> <span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.Edge)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns the continuous decision variables associated with vertex
<code class="docutils literal notranslate"><span class="pre">u</span></code>. This can be used for constructing symbolic::Expression costs
and constraints.</p>
<p>See also GetSolutionPhiXu(); using <code class="docutils literal notranslate"><span class="pre">result.GetSolution(xu())</span></code> may
not be what you want.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GraphOfConvexSets.Edge.xv(self:</span> <span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.Edge)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns the continuous decision variables associated with vertex
<code class="docutils literal notranslate"><span class="pre">v</span></code>. This can be used for constructing symbolic::Expression costs
and constraints.</p>
<p>See also GetSolutionPhiXv(); using <code class="docutils literal notranslate"><span class="pre">result.GetSolution(xv())</span></code> may
not be what you want.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GraphOfConvexSets.EdgeId</span></span></dt>
<dd><dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GraphOfConvexSets.EdgeId.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GraphOfConvexSets.EdgeId.get_new_id()</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.EdgeId</span></span></dt>
<dd><p>Generates a new identifier for this id type. This new identifier will
be different from all previous identifiers created. This method does
<em>not</em> make any guarantees about the values of ids from successive
invocations. This method is guaranteed to be thread safe.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GraphOfConvexSets.EdgeId.get_value(self:</span> <span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.EdgeId)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Extracts the underlying representation from the identifier. This is
considered invalid for invalid ids and is strictly enforced in Debug
builds.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GraphOfConvexSets.EdgeId.is_valid(self:</span> <span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.EdgeId)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Reports if the id is valid.</p>
</dd></dl>

</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GraphOfConvexSets.Edges(self:</span> <span class="pre">pydrake.geometry.optimization.GraphOfConvexSets)</span> <span class="pre">-&gt;</span> <span class="pre">list[pydrake.geometry.optimization.GraphOfConvexSets.Edge]</span></span></dt>
<dd><p>Returns mutable pointers to the edges stored in the graph.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GraphOfConvexSets.GetEdgeByName(self:</span> <span class="pre">pydrake.geometry.optimization.GraphOfConvexSets,</span> <span class="pre">name:</span> <span class="pre">str)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.Edge</span></span></dt>
<dd><p>Returns the first edge (by the order added to <code class="docutils literal notranslate"><span class="pre">this</span></code>) with the given
name, or nullptr if no such edge exists.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GraphOfConvexSets.GetGraphvizString(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetGraphvizString(self: pydrake.geometry.optimization.GraphOfConvexSets, result: pydrake.solvers.MathematicalProgramResult = None, options: pydrake.geometry.optimization.GcsGraphvizOptions = GcsGraphvizOptions(show_slacks=True, show_vars=True, show_flows=True, show_costs=True, scientific=False, precision=3), active_path: list[pydrake.geometry.optimization.GraphOfConvexSets.Edge] = []) -&gt; str</p></li>
</ol>
<p>Returns a Graphviz string describing the graph vertices and edges. If
<code class="docutils literal notranslate"><span class="pre">result</span></code> is supplied, then the graph will be annotated with the
solution values, according to <code class="docutils literal notranslate"><span class="pre">options</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">result</span></code>:</dt><dd><p>the optional result from a solver.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">options</span></code>:</dt><dd><p>the struct containing various options for visualization.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">active_path</span></code>:</dt><dd><p>optionally highlights a given path in the graph. The path is
displayed as dashed edges in red, displayed in addition to the
original graph edges.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>GetGraphvizString(self: pydrake.geometry.optimization.GraphOfConvexSets, result: pydrake.solvers.MathematicalProgramResult = None, show_slacks: bool = True, show_vars: bool = True, show_flows: bool = True, show_costs: bool = True, scientific: bool = False, precision: int = 3, active_path: list[pydrake.geometry.optimization.GraphOfConvexSets.Edge] = []) -&gt; str</p></li>
</ol>
<p>Returns a Graphviz string describing the graph vertices and edges. If
<code class="docutils literal notranslate"><span class="pre">result</span></code> is supplied, then the graph will be annotated with the
solution values, according to <code class="docutils literal notranslate"><span class="pre">options</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">result</span></code>:</dt><dd><p>the optional result from a solver.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">options</span></code>:</dt><dd><p>the struct containing various options for visualization.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">active_path</span></code>:</dt><dd><p>optionally highlights a given path in the graph. The path is
displayed as dashed edges in red, displayed in addition to the
original graph edges.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GraphOfConvexSets.GetMutableEdgeByName(self:</span> <span class="pre">pydrake.geometry.optimization.GraphOfConvexSets,</span> <span class="pre">name:</span> <span class="pre">str)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.Edge</span></span></dt>
<dd><p>Returns the first edge (by the order added to <code class="docutils literal notranslate"><span class="pre">this</span></code>) with the given
name, or nullptr if no such edge exists.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GraphOfConvexSets.GetMutableVertexByName(self:</span> <span class="pre">pydrake.geometry.optimization.GraphOfConvexSets,</span> <span class="pre">name:</span> <span class="pre">str)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.Vertex</span></span></dt>
<dd><p>Returns the first vertex (by the order added to <code class="docutils literal notranslate"><span class="pre">this</span></code>) with the
given name, or nullptr if no such vertex exists.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GraphOfConvexSets.GetSolutionPath(self:</span> <span class="pre">pydrake.geometry.optimization.GraphOfConvexSets,</span> <span class="pre">source:</span> <span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.Vertex,</span> <span class="pre">target:</span> <span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.Vertex,</span> <span class="pre">result:</span> <span class="pre">pydrake.solvers.MathematicalProgramResult,</span> <span class="pre">tolerance:</span> <span class="pre">float</span> <span class="pre">=</span> <span class="pre">0.001)</span> <span class="pre">-&gt;</span> <span class="pre">list[pydrake.geometry.optimization.GraphOfConvexSets.Edge]</span></span></dt>
<dd><p>Extracts a path from <code class="docutils literal notranslate"><span class="pre">source</span></code> to <code class="docutils literal notranslate"><span class="pre">target</span></code> described by the
<code class="docutils literal notranslate"><span class="pre">result</span></code> returned by SolveShortestPath(), via depth-first search
following the largest values of the edge binary variables.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">tolerance</span></code>:</dt><dd><p>defines the threshold for checking the integrality conditions of
the binary variables for each edge. <code class="docutils literal notranslate"><span class="pre">tolerance</span></code> = 0 would demand
that the binary variables are exactly 1 for the edges on the path.
<code class="docutils literal notranslate"><span class="pre">tolerance</span></code> = 1 would allow the binary variables to be any value
in [0, 1]. The default value is 1e-3.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if !result.is_success</strong><strong>(</strong><strong>) or </strong><strong>no path from source to</strong> – </p></li>
<li><p><strong>target` can be found in the solution</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GraphOfConvexSets.GetVertexByName(self:</span> <span class="pre">pydrake.geometry.optimization.GraphOfConvexSets,</span> <span class="pre">name:</span> <span class="pre">str)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.Vertex</span></span></dt>
<dd><p>Returns the first vertex (by the order added to <code class="docutils literal notranslate"><span class="pre">this</span></code>) with the
given name, or nullptr if no such vertex exists.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GraphOfConvexSets.IsValid(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>IsValid(self: pydrake.geometry.optimization.GraphOfConvexSets, v: pydrake.geometry.optimization.GraphOfConvexSets.Vertex) -&gt; bool</p></li>
</ol>
<p>Returns true iff <code class="docutils literal notranslate"><span class="pre">v</span></code> is registered as a vertex with <code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
<ol class="arabic simple" start="2">
<li><p>IsValid(self: pydrake.geometry.optimization.GraphOfConvexSets, e: pydrake.geometry.optimization.GraphOfConvexSets.Edge) -&gt; bool</p></li>
</ol>
<p>Returns true iff <code class="docutils literal notranslate"><span class="pre">e</span></code> is registered as an edge with <code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GraphOfConvexSets.num_edges(self:</span> <span class="pre">pydrake.geometry.optimization.GraphOfConvexSets)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GraphOfConvexSets.num_vertices(self:</span> <span class="pre">pydrake.geometry.optimization.GraphOfConvexSets)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GraphOfConvexSets.RemoveEdge(self:</span> <span class="pre">pydrake.geometry.optimization.GraphOfConvexSets,</span> <span class="pre">edge:</span> <span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.Edge)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Removes edge <code class="docutils literal notranslate"><span class="pre">edge</span></code> from the graph.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>The edge must be part of the graph.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GraphOfConvexSets.RemoveVertex(self:</span> <span class="pre">pydrake.geometry.optimization.GraphOfConvexSets,</span> <span class="pre">vertex:</span> <span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.Vertex)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Removes vertex <code class="docutils literal notranslate"><span class="pre">vertex</span></code> from the graph as well as any edges from or
to the vertex. Runtime is O(nₑ) where nₑ is the number of edges
connected to <code class="docutils literal notranslate"><span class="pre">vertex</span></code></p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>The vertex must be part of the graph.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GraphOfConvexSets.SamplePaths(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>SamplePaths(self: pydrake.geometry.optimization.GraphOfConvexSets, source: pydrake.geometry.optimization.GraphOfConvexSets.Vertex, target: pydrake.geometry.optimization.GraphOfConvexSets.Vertex, flows: dict[pydrake.geometry.optimization.GraphOfConvexSets.Edge, float], options: pydrake.geometry.optimization.GraphOfConvexSetsOptions) -&gt; list[list[pydrake.geometry.optimization.GraphOfConvexSets.Edge]]</p></li>
</ol>
<p>Samples a collection of unique paths from <code class="docutils literal notranslate"><span class="pre">source</span></code> to <code class="docutils literal notranslate"><span class="pre">target</span></code>,
where the flow values (the relaxed binary variables associated with
each <code class="docutils literal notranslate"><span class="pre">Edge</span></code>) <cite>flows</cite> are interpreted as the probabilities of
transitioning an edge. The returned paths are guaranteed to be unique,
and the number of returned paths can be 0 if no paths are found. This
function implements the first part of the rounding scheme put forth in
Section 4.2 of “Motion Planning around Obstacles with Convex
Optimization”: <a class="reference external" href="https://arxiv.org/abs/2205.04422">https://arxiv.org/abs/2205.04422</a></p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">source</span></code>:</dt><dd><p>specifies the source vertex.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">target</span></code>:</dt><dd><p>specifies the target vertex.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">flows</span></code>:</dt><dd><p>specifies the edge flows, which are interprested as the
probability of transition an edge. Edge flows that are not
specified are taken to be zero.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">options</span></code>:</dt><dd><p>include all settings for sampling the paths. Specifically, the
behavior of this function is determined through
<code class="docutils literal notranslate"><span class="pre">options.rounding_seed</span></code>, <cite>options.max_rounded_paths</cite>,
<code class="docutils literal notranslate"><span class="pre">options.max_rounding_trials</span></code>, and <code class="docutils literal notranslate"><span class="pre">options.flow_tolerance</span></code>,
as described in <code class="docutils literal notranslate"><span class="pre">GraphOfConvexSetsOptions</span></code>.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A vector of paths, where each path is a vector of <a href="#id5"><span class="problematic" id="id6">`</span></a>Edge`s.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>RuntimeError if options.max_rounded_path &lt; 1.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>SamplePaths(self: pydrake.geometry.optimization.GraphOfConvexSets, source: pydrake.geometry.optimization.GraphOfConvexSets.Vertex, target: pydrake.geometry.optimization.GraphOfConvexSets.Vertex, result: pydrake.solvers.MathematicalProgramResult, options: pydrake.geometry.optimization.GraphOfConvexSetsOptions) -&gt; list[list[pydrake.geometry.optimization.GraphOfConvexSets.Edge]]</p></li>
</ol>
<p>Samples a collection of unique paths from <code class="docutils literal notranslate"><span class="pre">source</span></code> to <code class="docutils literal notranslate"><span class="pre">target</span></code>,
where the flow values (the relaxed binary variables associated with
each <code class="docutils literal notranslate"><span class="pre">Edge</span></code>) in <code class="docutils literal notranslate"><span class="pre">result</span></code> are interpreted as the probabilities of
transitioning an edge. The returned paths are guaranteed to be unique,
and the number of returned paths can be 0 if no paths are found. This
function implements the first part of the rounding scheme put forth in
Section 4.2 of “Motion Planning around Obstacles with Convex
Optimization”: <a class="reference external" href="https://arxiv.org/abs/2205.04422">https://arxiv.org/abs/2205.04422</a></p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">source</span></code>:</dt><dd><p>specifies the source vertex.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">target</span></code>:</dt><dd><p>specifies the target vertex.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">options</span></code>:</dt><dd><p>include all settings for sampling the paths. Specifically, the
behavior of this function is determined through
<code class="docutils literal notranslate"><span class="pre">options.rounding_seed</span></code>, <cite>options.max_rounded_paths</cite>,
<code class="docutils literal notranslate"><span class="pre">options.max_rounding_trials</span></code>, and <code class="docutils literal notranslate"><span class="pre">options.flow_tolerance</span></code>,
as described in <code class="docutils literal notranslate"><span class="pre">GraphOfConvexSetsOptions</span></code>.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A vector of paths, where each path is a vector of <a href="#id7"><span class="problematic" id="id8">`</span></a>Edge`s.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>RuntimeError if options.max_rounded_path &lt; 1.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GraphOfConvexSets.SolveConvexRestriction(self:</span> <span class="pre">pydrake.geometry.optimization.GraphOfConvexSets,</span> <span class="pre">active_edges:</span> <span class="pre">list[pydrake.geometry.optimization.GraphOfConvexSets.Edge],</span> <span class="pre">options:</span> <span class="pre">pydrake.geometry.optimization.GraphOfConvexSetsOptions</span> <span class="pre">=</span> <span class="pre">GraphOfConvexSetsOptions(convex_relaxation=None,</span> <span class="pre">preprocessing=None,</span> <span class="pre">max_rounded_paths=None,</span> <span class="pre">max_rounding_trials=100,</span> <span class="pre">flow_tolerance=1e-05,</span> <span class="pre">rounding_seed=0,</span> <span class="pre">solver=None,</span> <span class="pre">restriction_solver=None,</span> <span class="pre">preprocessing_solver=None,</span> <span class="pre">solver_options=SolverOptions(options={}),</span> <span class="pre">restriction_solver_options=None,</span> <span class="pre">preprocessing_solver_options=None,</span> <span class="pre">),</span> <span class="pre">initial_guess:</span> <span class="pre">pydrake.solvers.MathematicalProgramResult</span> <span class="pre">=</span> <span class="pre">None)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.solvers.MathematicalProgramResult</span></span></dt>
<dd><p>The non-convexity in a GCS problem comes from the binary variables
(phi) associated with the edges being active or inactive in the
solution. If those binary variables are fixed, then the problem is
convex – this is a so-called “convex restriction” of the original
problem.</p>
<p>The convex restriction can often be solved much more efficiently than
solving the full GCS problem with additional constraints to fix the
binaries; it can be written using less decision variables, and needs
only to include the vertices associated with at least one of the
active edges. Decision variables for all other convex sets will be set
to NaN.</p>
<p>Note that one can specify additional non-convex constraints, which may
be not supported by all solvers. In this case, the provided solver
will throw an exception.</p>
<p>If an <code class="docutils literal notranslate"><span class="pre">initial_guess</span></code> is provided, the solution inside this result
will be used to set the initial guess for the convex restriction.
Typically, this will be the result obtained by solving the convex
relaxation.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the initial_guess does not contain solutions</strong> – </p></li>
<li><p><strong>for the decision variables required in this convex restriction.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GraphOfConvexSets.SolveShortestPath(self:</span> <span class="pre">pydrake.geometry.optimization.GraphOfConvexSets,</span> <span class="pre">source:</span> <span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.Vertex,</span> <span class="pre">target:</span> <span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.Vertex,</span> <span class="pre">options:</span> <span class="pre">pydrake.geometry.optimization.GraphOfConvexSetsOptions</span> <span class="pre">=</span> <span class="pre">GraphOfConvexSetsOptions(convex_relaxation=None,</span> <span class="pre">preprocessing=None,</span> <span class="pre">max_rounded_paths=None,</span> <span class="pre">max_rounding_trials=100,</span> <span class="pre">flow_tolerance=1e-05,</span> <span class="pre">rounding_seed=0,</span> <span class="pre">solver=None,</span> <span class="pre">restriction_solver=None,</span> <span class="pre">preprocessing_solver=None,</span> <span class="pre">solver_options=SolverOptions(options={}),</span> <span class="pre">restriction_solver_options=None,</span> <span class="pre">preprocessing_solver_options=None,</span> <span class="pre">))</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.solvers.MathematicalProgramResult</span></span></dt>
<dd><p>Formulates and solves the mixed-integer convex formulation of the
shortest path problem on the graph, as discussed in detail in</p>
<p>“Shortest Paths in Graphs of Convex Sets” by Tobia Marcucci, Jack
Umenberger, Pablo A. Parrilo, Russ Tedrake.
<a class="reference external" href="https://arxiv.org/abs/2101.11565">https://arxiv.org/abs/2101.11565</a></p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">source</span></code>:</dt><dd><p>specifies the source set. The solver will choose any point in that
set; to start at a particular continuous state consider adding a
Point set to the graph and using that as the source.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">target</span></code>:</dt><dd><p>specifies the target set. The solver will choose any point in that
set.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">options</span></code>:</dt><dd><p>include all settings for solving the shortest path problem. See
<code class="docutils literal notranslate"><span class="pre">GraphOfConvexSetsOptions</span></code> for further details. The following
default options will be used if they are not provided in
<code class="docutils literal notranslate"><span class="pre">options</span></code>: - <cite>options.convex_relaxation = false</cite>, -
<code class="docutils literal notranslate"><span class="pre">options.max_rounded_paths</span> <span class="pre">=</span> <span class="pre">0</span></code>, - <cite>options.preprocessing =
false</cite>.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if any</strong><strong> of </strong><strong>the costs</strong><strong> or </strong><strong>constraints in the graph are</strong> – </p></li>
<li><p><strong>incompatible with the shortest path formulation</strong><strong> or </strong><strong>otherwise</strong> – </p></li>
<li><p><strong>unsupported. All costs must be non-negative for all values</strong><strong> of </strong><strong>the</strong> – </p></li>
<li><p><strong>continuous variables.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GraphOfConvexSets.Transcription</span></span></dt>
<dd><p>Specify the transcription of the optimization problem to which a
constraint or cost should be added, or from which they should be
retrieved.</p>
<p>Members:</p>
<blockquote>
<div><p>kMIP : The mixed integer formulation of the GCS problem.</p>
<p>kRelaxation : The relaxation of the GCS problem.</p>
<p>kRestriction : The restrction of the GCS problem where the path is fixed.</p>
</div></blockquote>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GraphOfConvexSets.Transcription.__init__(self:</span> <span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.Transcription,</span> <span class="pre">value:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GraphOfConvexSets.Transcription.kMIP</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GraphOfConvexSets.Transcription.kRelaxation</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GraphOfConvexSets.Transcription.kRestriction</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GraphOfConvexSets.Transcription.name</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GraphOfConvexSets.Transcription.value</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GraphOfConvexSets.Vertex</span></span></dt>
<dd><p>Each vertex in the graph has a corresponding ConvexSet, and a
std::string name.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GraphOfConvexSets.Vertex.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GraphOfConvexSets.Vertex.AddConstraint(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>AddConstraint(self: pydrake.geometry.optimization.GraphOfConvexSets.Vertex, f: pydrake.symbolic.Formula, use_in_transcription: set[pydrake.geometry.optimization.GraphOfConvexSets.Transcription] = {&lt;Transcription.kMIP: 0&gt;, &lt;Transcription.kRelaxation: 1&gt;, &lt;Transcription.kRestriction: 2&gt;}) -&gt; pydrake.solvers.Binding[Constraint]</p></li>
</ol>
<p>Adds a constraint to this vertex.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">f</span></code>:</dt><dd><p>must contain <em>only</em> elements of x() as variables.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">use_in_transcription</span></code>:</dt><dd><p>specifies the components of the problem to which the constraint
should be added.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if f.GetFreeVariables</strong><strong>(</strong><strong>) </strong><strong>is not a subset</strong><strong> of </strong><strong>x</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p></li>
<li><p><strong>RuntimeError if ambient_dimension</strong><strong>(</strong><strong>) </strong><strong>== 0.</strong> – </p></li>
<li><p><strong>RuntimeError if no transcription is specified.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>AddConstraint(self: pydrake.geometry.optimization.GraphOfConvexSets.Vertex, binding: pydrake.solvers.Binding[Constraint], use_in_transcription: set[pydrake.geometry.optimization.GraphOfConvexSets.Transcription] = {&lt;Transcription.kMIP: 0&gt;, &lt;Transcription.kRelaxation: 1&gt;, &lt;Transcription.kRestriction: 2&gt;}) -&gt; pydrake.solvers.Binding[Constraint]</p></li>
</ol>
<p>Adds a constraint to this vertex.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">binding</span></code>:</dt><dd><p>must contain <em>only</em> elements of x() as variables.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">use_in_transcription</span></code>:</dt><dd><p>specifies the components of the problem to which the constraint
should be added.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if binding.variables</strong><strong>(</strong><strong>) </strong><strong>is not a subset</strong><strong> of </strong><strong>x</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p></li>
<li><p><strong>RuntimeError if ambient_dimension</strong><strong>(</strong><strong>) </strong><strong>== 0.</strong> – </p></li>
<li><p><strong>RuntimeError if no transcription is specified.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GraphOfConvexSets.Vertex.AddCost(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>AddCost(self: pydrake.geometry.optimization.GraphOfConvexSets.Vertex, e: pydrake.symbolic.Expression, use_in_transcription: set[pydrake.geometry.optimization.GraphOfConvexSets.Transcription] = {&lt;Transcription.kMIP: 0&gt;, &lt;Transcription.kRelaxation: 1&gt;, &lt;Transcription.kRestriction: 2&gt;}) -&gt; pydrake.solvers.Binding[Cost]</p></li>
</ol>
<p>Adds a cost to this vertex, described by a symbolic::Expression <code class="docutils literal notranslate"><span class="pre">e</span></code>
containing <em>only</em> elements of x() as variables. For technical reasons
relating to being able to “turn-off” the cost on inactive vertices,
all costs are eventually implemented with a slack variable and a
constraint:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">min</span><span class="w"> </span><span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="err">⇒</span><span class="w"> </span><span class="n">min</span><span class="w"> </span><span class="n">ℓ</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">t</span><span class="p">.</span><span class="w"> </span><span class="n">ℓ</span><span class="w"> </span><span class="err">≥</span><span class="w"> </span><span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">).</span>
</pre></div>
</div>
</details><p>You must use GetSolutionCost() to retrieve the cost of the solution,
rather than evaluating the cost directly, in order to get consistent
behavior when solving with the different GCS transcriptions.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">use_in_transcription</span></code>:</dt><dd><p>specifies the components of the problem to which the constraint
should be added.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Linear costs lead to negative costs if decision variables are not
properly constrained. Users may want to check that the solution
does not contain negative costs.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>the added cost, g(x).</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>RuntimeError if e.GetVariables</strong><strong>(</strong><strong>) </strong><strong>is not a subset</strong><strong> of </strong><strong>x</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p></li>
<li><p><strong>RuntimeError if no transcription is specified.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>AddCost(self: pydrake.geometry.optimization.GraphOfConvexSets.Vertex, binding: pydrake.solvers.Binding[Cost], use_in_transcription: set[pydrake.geometry.optimization.GraphOfConvexSets.Transcription] = {&lt;Transcription.kMIP: 0&gt;, &lt;Transcription.kRelaxation: 1&gt;, &lt;Transcription.kRestriction: 2&gt;}) -&gt; pydrake.solvers.Binding[Cost]</p></li>
</ol>
<p>Adds a cost to this vertex. <code class="docutils literal notranslate"><span class="pre">binding</span></code> must contain <em>only</em> elements
of x() as variables. For technical reasons relating to being able to
“turn-off” the cost on inactive vertices, all costs are eventually
implemented with a slack variable and a constraint:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">min</span><span class="w"> </span><span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="err">⇒</span><span class="w"> </span><span class="n">min</span><span class="w"> </span><span class="n">ℓ</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">t</span><span class="p">.</span><span class="w"> </span><span class="n">ℓ</span><span class="w"> </span><span class="err">≥</span><span class="w"> </span><span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">).</span>
</pre></div>
</div>
</details><p>You must use GetSolutionCost() to retrieve the cost of the solution,
rather than evaluating the cost directly, in order to get consistent
behavior when solving with the different GCS transcriptions.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">use_in_transcription</span></code>:</dt><dd><p>specifies the components of the problem to which the constraint
should be added.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Linear costs lead to negative costs if decision variables are not
properly constrained. Users may want to check that the solution
does not contain negative costs.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>the added cost, g(x).</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>RuntimeError if binding.variables</strong><strong>(</strong><strong>) </strong><strong>is not a subset</strong><strong> of </strong><strong>x</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p></li>
<li><p><strong>RuntimeError if no transcription is specified.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GraphOfConvexSets.Vertex.ambient_dimension(self:</span> <span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.Vertex)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the ambient dimension of the ConvexSet.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GraphOfConvexSets.Vertex.GetConstraints(self:</span> <span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.Vertex,</span> <span class="pre">used_in_transcription:</span> <span class="pre">set[pydrake.geometry.optimization.GraphOfConvexSets.Transcription]</span> <span class="pre">=</span> <span class="pre">{&lt;Transcription.kMIP:</span> <span class="pre">0&gt;,</span> <span class="pre">&lt;Transcription.kRelaxation:</span> <span class="pre">1&gt;,</span> <span class="pre">&lt;Transcription.kRestriction:</span> <span class="pre">2&gt;})</span> <span class="pre">-&gt;</span> <span class="pre">list[pydrake.solvers.Binding[Constraint]]</span></span></dt>
<dd><p>Returns constraints on this vertex.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">used_in_transcription</span></code>:</dt><dd><p>specifies the components of the problem from which the constraint
should be retrieved.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if no transcription is specified.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GraphOfConvexSets.Vertex.GetCosts(self:</span> <span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.Vertex,</span> <span class="pre">used_in_transcription:</span> <span class="pre">set[pydrake.geometry.optimization.GraphOfConvexSets.Transcription]</span> <span class="pre">=</span> <span class="pre">{&lt;Transcription.kMIP:</span> <span class="pre">0&gt;,</span> <span class="pre">&lt;Transcription.kRelaxation:</span> <span class="pre">1&gt;,</span> <span class="pre">&lt;Transcription.kRestriction:</span> <span class="pre">2&gt;})</span> <span class="pre">-&gt;</span> <span class="pre">list[pydrake.solvers.Binding[Cost]]</span></span></dt>
<dd><p>Returns costs on this vertex.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">used_in_transcription</span></code>:</dt><dd><p>specifies the components of the problem from which the constraint
should be retrieved.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if no transcription is specified.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GraphOfConvexSets.Vertex.GetSolution(self:</span> <span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.Vertex,</span> <span class="pre">result:</span> <span class="pre">pydrake.solvers.MathematicalProgramResult)</span> <span class="pre">-&gt;</span> <span class="pre">Optional[numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]]</span></span></dt>
<dd><p>Returns the solution of x() in <code class="docutils literal notranslate"><span class="pre">result</span></code>, or std::nullopt if no
solution for this vertex is available. std::nullopt can happen if the
vertex is deactivated (e.g. not in the shorest path) in the solution.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GraphOfConvexSets.Vertex.GetSolutionCost(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetSolutionCost(self: pydrake.geometry.optimization.GraphOfConvexSets.Vertex, result: pydrake.solvers.MathematicalProgramResult) -&gt; Optional[float]</p></li>
</ol>
<p>Returns the sum of the costs associated with this vertex in
<code class="docutils literal notranslate"><span class="pre">result</span></code>, or std::nullopt if no solution for this vertex is
available.</p>
<ol class="arabic simple" start="2">
<li><p>GetSolutionCost(self: pydrake.geometry.optimization.GraphOfConvexSets.Vertex, result: pydrake.solvers.MathematicalProgramResult, cost: pydrake.solvers.Binding[Cost]) -&gt; Optional[float]</p></li>
</ol>
<p>Returns the cost associated with the <code class="docutils literal notranslate"><span class="pre">cost</span></code> binding on this vertex
in <code class="docutils literal notranslate"><span class="pre">result</span></code>, or std::nullopt if no solution for this vertex is
available.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if cost is not associated with this vertex.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GraphOfConvexSets.Vertex.id(self:</span> <span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.Vertex)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.VertexId</span></span></dt>
<dd><p>Returns the unique identifier associated with this Vertex.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GraphOfConvexSets.Vertex.incoming_edges(self:</span> <span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.Vertex)</span> <span class="pre">-&gt;</span> <span class="pre">list[drake::geometry::optimization::GraphOfConvexSets::Edge]</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GraphOfConvexSets.Vertex.name(self:</span> <span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.Vertex)</span> <span class="pre">-&gt;</span> <span class="pre">str</span></span></dt>
<dd><p>Returns the name of the vertex.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GraphOfConvexSets.Vertex.outgoing_edges(self:</span> <span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.Vertex)</span> <span class="pre">-&gt;</span> <span class="pre">list[drake::geometry::optimization::GraphOfConvexSets::Edge]</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GraphOfConvexSets.Vertex.set(self:</span> <span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.Vertex)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.geometry.optimization.ConvexSet</span></span></dt>
<dd><p>Returns a const reference to the underlying ConvexSet.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GraphOfConvexSets.Vertex.x(self:</span> <span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.Vertex)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns a decision variable corresponding to an element of the
ConvexSet, which can be used for constructing symbolic::Expression
costs and constraints.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GraphOfConvexSets.VertexId</span></span></dt>
<dd><dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GraphOfConvexSets.VertexId.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GraphOfConvexSets.VertexId.get_new_id()</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.VertexId</span></span></dt>
<dd><p>Generates a new identifier for this id type. This new identifier will
be different from all previous identifiers created. This method does
<em>not</em> make any guarantees about the values of ids from successive
invocations. This method is guaranteed to be thread safe.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GraphOfConvexSets.VertexId.get_value(self:</span> <span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.VertexId)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Extracts the underlying representation from the identifier. This is
considered invalid for invalid ids and is strictly enforced in Debug
builds.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GraphOfConvexSets.VertexId.is_valid(self:</span> <span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.VertexId)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Reports if the id is valid.</p>
</dd></dl>

</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GraphOfConvexSets.Vertices(self:</span> <span class="pre">pydrake.geometry.optimization.GraphOfConvexSets)</span> <span class="pre">-&gt;</span> <span class="pre">list[pydrake.geometry.optimization.GraphOfConvexSets.Vertex]</span></span></dt>
<dd><p>Returns mutable pointers to the vertices stored in the graph.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GraphOfConvexSetsOptions</span></span></dt>
<dd><dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GraphOfConvexSetsOptions.__init__(self:</span> <span class="pre">pydrake.geometry.optimization.GraphOfConvexSetsOptions)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GraphOfConvexSetsOptions.convex_relaxation</span></span></dt>
<dd><p>Flag to solve the relaxed version of the problem. As discussed in the
paper, we know that this relaxation cannot solve the original NP-hard
problem for all instances, but there are also many instances for which
the convex relaxation is tight. If convex_relaxation=nullopt, then
each GCS method is free to choose an appropriate default.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GraphOfConvexSetsOptions.flow_tolerance</span></span></dt>
<dd><p>Tolerance for ignoring flow along a given edge during random rounding.
If convex_relaxation is false or max_rounded_paths is less than or
equal to zero, this option is ignored.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GraphOfConvexSetsOptions.max_rounded_paths</span></span></dt>
<dd><p>Maximum number of distinct paths to compare during random rounding;
only the lowest cost path is returned. If convex_relaxation is false
or this is less than or equal to zero, rounding is not performed. If
max_rounded_paths=nullopt, then each GCS method is free to choose an
appropriate default.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GraphOfConvexSetsOptions.max_rounding_trials</span></span></dt>
<dd><p>Maximum number of trials to find a novel path during random rounding.
If convex_relaxation is false or max_rounded_paths is less than or
equal to zero, this option is ignored.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GraphOfConvexSetsOptions.parallelism</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GraphOfConvexSetsOptions.preprocessing</span></span></dt>
<dd><p>Performs a preprocessing step to remove edges that cannot lie on the
path from source to target. In most cases, preprocessing causes a net
reduction in computation by reducing the size of the optimization
solved. Note that this preprocessing is not exact. There may be edges
that cannot lie on the path from source to target that this does not
detect. If preprocessing=nullopt, then each GCS method is free to
choose an appropriate default.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GraphOfConvexSetsOptions.preprocessing_solver</span></span></dt>
<dd><p>Optimizer to be used in the preprocessing stage of GCS, which is
performed when SolveShortestPath is called when the <code class="docutils literal notranslate"><span class="pre">preprocessing</span></code>
setting has been set to true. If not set, the interface at .solver
will be used, if provided, otherwise the best solver for the given
problem is selected. Note that if the solver cannot handle the type of
optimization problem generated, then calling the
solvers::SolverInterface::Solve() method will throw.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GraphOfConvexSetsOptions.preprocessing_solver_options</span></span></dt>
<dd><p>Optional solver options to be used by preprocessing_solver in the
preprocessing stage of GCS, which is used in SolveShortestPath. If
preprocessing_solver is set but this parameter is not then
solver_options is used. For instance, one might want to print solver
logs for the main optimization, but not from the many smaller
preprocessing optimizations.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GraphOfConvexSetsOptions.restriction_solver</span></span></dt>
<dd><p>Optimizer to be used in SolveConvexRestriction(), which is also called
during the rounding stage of SolveShortestPath() given the relaxation.
If not set, the interface at .solver will be used, if provided,
otherwise the best solver for the given problem is selected. Note that
if the solver cannot handle the type of optimization problem
generated, then calling the solvers::SolverInterface::Solve() method
will throw.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GraphOfConvexSetsOptions.restriction_solver_options</span></span></dt>
<dd><p>Optional solver options to be used in SolveConvexRestriction(), which
is also used during the rounding stage of SolveShortestPath() given
the relaxation. If not set, solver_options is used. For instance, one
might want to set tighter (i.e., lower) tolerances for running the
relaxed problem and looser (i.e., higher) tolerances for final solves
during rounding.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GraphOfConvexSetsOptions.rounding_seed</span></span></dt>
<dd><p>Random seed to use for random rounding. If convex_relaxation is false
or max_rounded_paths is less than or equal to zero, this option is
ignored.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GraphOfConvexSetsOptions.solver</span></span></dt>
<dd><p>Optimizer to be used to solve the MIP, the relaxation of the shortest
path optimization problem and the convex restriction if no
restriction_solver is provided. If not set, the best solver for the
given problem is selected. Note that if the solver cannot handle the
type of optimization problem generated, the calling
solvers::SolverInterface::Solve() method will throw.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GraphOfConvexSetsOptions.solver_options</span></span></dt>
<dd><p>Options passed to the solver when solving the generated problem.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">HPolyhedron</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.geometry.optimization.ConvexSet</span></code></p>
<p>Implements a polyhedral convex set using the half-space
representation: <code class="docutils literal notranslate"><span class="pre">{x|</span> <span class="pre">A</span> <span class="pre">x</span> <span class="pre">≤</span> <span class="pre">b}</span></code>. Note: This set may be unbounded.</p>
<p>By convention, we treat a zero-dimensional HPolyhedron as nonempty.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">HPolyhedron.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.geometry.optimization.HPolyhedron) -&gt; None</p></li>
</ol>
<p>Constructs a default (zero-dimensional, nonempty) polyhedron.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.geometry.optimization.HPolyhedron, A: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], b: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</p></li>
</ol>
<p>Constructs the polyhedron.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>A.rows() == b.size().</p>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li><p>__init__(self: pydrake.geometry.optimization.HPolyhedron, query_object: pydrake.geometry.QueryObject, geometry_id: pydrake.geometry.GeometryId, reference_frame: Optional[pydrake.geometry.FrameId] = None) -&gt; None</p></li>
</ol>
<p>Constructs a new HPolyhedron from a SceneGraph geometry and pose in
the <code class="docutils literal notranslate"><span class="pre">reference_frame</span></code> frame, obtained via the QueryObject. If
<code class="docutils literal notranslate"><span class="pre">reference_frame</span></code> frame is std::nullopt, then it will be expressed
in the world frame.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError the geometry is not a convex polytope.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="4">
<li><p>__init__(self: pydrake.geometry.optimization.HPolyhedron, vpoly: pydrake.geometry.optimization.VPolytope, tol: float = 1e-09) -&gt; None</p></li>
</ol>
<p>Constructs a new HPolyedron from a VPolytope object. This function
will use qhull. If the VPolytope is empty, then the HPolyhedron will
also be empty. If the HPolyhedron is not full-dimensional, we perform
computations in a coordinate system of its affine hull. <code class="docutils literal notranslate"><span class="pre">tol</span></code>
specifies the numerical tolerance used in the computation of the
affine hull. (See the documentation of AffineSubspace.) A tighter
tolerance can be used with commercial solvers (e.g. Gurobi and Mosek).</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if vpoly is empty and zero dimensional.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="5">
<li><p>__init__(self: pydrake.geometry.optimization.HPolyhedron, prog: pydrake.solvers.MathematicalProgram) -&gt; None</p></li>
</ol>
<p>Constructs a new HPolyhedron describing the feasible set of a linear
program <code class="docutils literal notranslate"><span class="pre">prog</span></code>. The <code class="docutils literal notranslate"><span class="pre">i`th</span> <span class="pre">dimension</span> <span class="pre">in</span> <span class="pre">this</span> <span class="pre">representation</span>
<span class="pre">corresponds</span> <span class="pre">to</span> <span class="pre">the</span> <span class="pre">`i`th</span> <span class="pre">decision</span> <span class="pre">variable</span> <span class="pre">of</span> <span class="pre">`prog</span></code>. Note that if
<code class="docutils literal notranslate"><span class="pre">prog</span></code> is infeasible, then the constructed HPolyhedron will be
empty.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if prog has constraints which are not</strong><strong> of </strong><strong>type linear</strong> – </p></li>
<li><p><strong>inequality</strong><strong>, </strong><strong>linear equality</strong><strong>, or </strong><strong>bounding box.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">HPolyhedron.A(self:</span> <span class="pre">pydrake.geometry.optimization.HPolyhedron)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n]]</span></span></dt>
<dd><p>Returns the half-space representation matrix A.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">HPolyhedron.b(self:</span> <span class="pre">pydrake.geometry.optimization.HPolyhedron)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns the half-space representation vector b.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">HPolyhedron.CartesianPower(self:</span> <span class="pre">pydrake.geometry.optimization.HPolyhedron,</span> <span class="pre">n:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.geometry.optimization.HPolyhedron</span></span></dt>
<dd><p>Returns the <code class="docutils literal notranslate"><span class="pre">n</span></code>-ary Cartesian power of <code class="docutils literal notranslate"><span class="pre">this</span></code>. The n-ary Cartesian
power of a set H is the set H ⨉ H ⨉ … ⨉ H, where H is repeated n
times.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">HPolyhedron.CartesianProduct(self:</span> <span class="pre">pydrake.geometry.optimization.HPolyhedron,</span> <span class="pre">other:</span> <span class="pre">pydrake.geometry.optimization.HPolyhedron)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.geometry.optimization.HPolyhedron</span></span></dt>
<dd><p>Returns the Cartesian product of <code class="docutils literal notranslate"><span class="pre">this</span></code> and <code class="docutils literal notranslate"><span class="pre">other</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">HPolyhedron.ChebyshevCenter(self:</span> <span class="pre">pydrake.geometry.optimization.HPolyhedron)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Solves a linear program to compute the center of the largest inscribed
ball in the polyhedron. This is often the recommended way to find some
interior point of the set, for example, as a step towards computing
the convex hull or a vertex-representation of the set.</p>
<p>Note that the Chebyshev center is not necessarily unique, and may not
conform to the point that one might consider the “visual center” of
the set. For example, for a long thin rectangle, any point in the
center line segment illustrated below would be a valid center point.
The solver may return any point on that line segment.</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="err">┌──────────────────────────────────┐</span>
<span class="err">│</span><span class="w">                                  </span><span class="err">│</span>
<span class="err">│</span><span class="w">   </span><span class="err">────────────────────────────</span><span class="w">   </span><span class="err">│</span>
<span class="err">│</span><span class="w">                                  </span><span class="err">│</span>
<span class="err">└──────────────────────────────────┘</span>
</pre></div>
</div>
</details><p>To find the visual center, consider using the more expensive
MaximumVolumeInscribedEllipsoid() method, and then taking the center
of the returned Hyperellipsoid.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if the solver fails to solve the problem.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">HPolyhedron.ContainedIn(self:</span> <span class="pre">pydrake.geometry.optimization.HPolyhedron,</span> <span class="pre">other:</span> <span class="pre">pydrake.geometry.optimization.HPolyhedron,</span> <span class="pre">tol:</span> <span class="pre">float</span> <span class="pre">=</span> <span class="pre">1e-09)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns true iff this HPolyhedron is entirely contained in the
HPolyhedron other. This is done by checking whether every inequality
in <code class="docutils literal notranslate"><span class="pre">other</span></code> is redundant when added to this.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">tol</span></code>:</dt><dd><p>We check if this polyhedron is contained in
other.A().row(i).dot(x) &lt;= other.b()(i) + tol. The larger tol
value is, the more relaxation we add to the containment. If tol is
negative, then we check if a shrinked <code class="docutils literal notranslate"><span class="pre">other</span></code> contains this
polyheron.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">HPolyhedron.FindRedundant(self:</span> <span class="pre">pydrake.geometry.optimization.HPolyhedron,</span> <span class="pre">tol:</span> <span class="pre">float</span> <span class="pre">=</span> <span class="pre">1e-09)</span> <span class="pre">-&gt;</span> <span class="pre">set[int]</span></span></dt>
<dd><p>Finds the redundant inequalities in this polyhedron. Returns a set ℑ,
such that if we remove the rows of A * x &lt;= b in ℑ, the remaining
inequalities still define the same polyhedron, namely {x | A*x&lt;=b} =
{x | A.row(i)*x&lt;=b(i), ∀i ∉ ℑ}. This function solves a series of
linear programs. We say the jᵗʰ row A.row(j)*x &lt;= b(j) is redundant,
if {x | A.row(i) * x &lt;= b(i), ∀i ∉ ℑ} implies that A.row(j) * x &lt;=
b(j) + tol. Note that we do NOT guarantee that we find all the
redundant rows.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">HPolyhedron.Intersection(self:</span> <span class="pre">pydrake.geometry.optimization.HPolyhedron,</span> <span class="pre">other:</span> <span class="pre">pydrake.geometry.optimization.HPolyhedron,</span> <span class="pre">check_for_redundancy:</span> <span class="pre">bool</span> <span class="pre">=</span> <span class="pre">False,</span> <span class="pre">tol:</span> <span class="pre">float</span> <span class="pre">=</span> <span class="pre">1e-09)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.geometry.optimization.HPolyhedron</span></span></dt>
<dd><p>Constructs the intersection of two HPolyhedron by adding the rows of
inequalities from <code class="docutils literal notranslate"><span class="pre">other</span></code>. If <code class="docutils literal notranslate"><span class="pre">check_for_redundancy</span></code> is true then
only adds the rows of <code class="docutils literal notranslate"><span class="pre">other</span></code> other.A().row(i).dot(x)&lt;=other.b()(i)
to this HPolyhedron if the inequality
other.A().row(i).dot(x)&lt;=other.b()(i)+tol is not implied by the
inequalities from this HPolyhedron. A positive tol means it is more
likely to deem a constraint being redundant and remove it. A negative
tol means it is less likely to remove a constraint.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">HPolyhedron.MakeBox(lb:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]],</span> <span class="pre">ub:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.geometry.optimization.HPolyhedron</span></span></dt>
<dd><p>Constructs a polyhedron as an axis-aligned box from the lower and
upper corners.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">HPolyhedron.MakeL1Ball(dim:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.geometry.optimization.HPolyhedron</span></span></dt>
<dd><p>Constructs the L1-norm unit ball in <code class="docutils literal notranslate"><span class="pre">dim</span></code> dimensions, {x | <a href="#id9"><span class="problematic" id="id10">|</span></a>x|₁ &lt;= 1
}. This set is also known as the cross-polytope and is described by
the 2ᵈⁱᵐ signed unit vectors.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">HPolyhedron.MakeUnitBox(dim:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.geometry.optimization.HPolyhedron</span></span></dt>
<dd><p>Constructs the L∞-norm unit box in <code class="docutils literal notranslate"><span class="pre">dim</span></code> dimensions, {x | <a href="#id11"><span class="problematic" id="id12">|</span></a>x|∞ &lt;= 1
}. This is an axis-aligned box, centered at the origin, with edge
length 2.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">HPolyhedron.MaximumVolumeInscribedAffineTransformation(self:</span> <span class="pre">pydrake.geometry.optimization.HPolyhedron,</span> <span class="pre">circumbody:</span> <span class="pre">pydrake.geometry.optimization.HPolyhedron)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.geometry.optimization.HPolyhedron</span></span></dt>
<dd><p>Solves a semi-definite program to compute the maximum-volume affine
transformation of <code class="docutils literal notranslate"><span class="pre">this</span></code>, subject to being a subset of
<code class="docutils literal notranslate"><span class="pre">circumbody</span></code>, and subject to the transformation matrix being
positive semi-definite. The latter condition is necessary for
convexity of the program. We use the containment condition stated in
Lemma 1 of “Linear Encodings for Polytope Containment Problems” by
Sadra Sadraddini and Russ Tedrake, extended to apply to the affine
transformation of <code class="docutils literal notranslate"><span class="pre">this</span></code>. We solve</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">max_</span><span class="p">{</span><span class="n">T</span><span class="p">,</span><span class="n">t</span><span class="p">}</span><span class="w"> </span><span class="n">log</span><span class="w"> </span><span class="n">det</span><span class="w"> </span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
<span class="n">s</span><span class="p">.</span><span class="n">t</span><span class="p">.</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="err">≽</span><span class="w"> </span><span class="mi">0</span>
<span class="n">t</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">TX</span><span class="w"> </span><span class="err">⊆</span><span class="w"> </span><span class="n">Y</span>
</pre></div>
</div>
</details><p>where X is <code class="docutils literal notranslate"><span class="pre">this</span></code>, and Y is <code class="docutils literal notranslate"><span class="pre">circumbody</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>the transformed polyhedron, t + TX.</p>
</dd>
</dl>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">circumbody</span></code>:</dt><dd><p>is an HPolyhedron that must contain the returned inbody.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if the solver fails to solve the problem.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">HPolyhedron.MaximumVolumeInscribedEllipsoid(self:</span> <span class="pre">pydrake.geometry.optimization.HPolyhedron)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.geometry.optimization.Hyperellipsoid</span></span></dt>
<dd><p>Solves a semi-definite program to compute the inscribed ellipsoid.
This is also known as the inner Löwner-John ellipsoid. From Section
8.4.2 in Boyd and Vandenberghe, 2004, we solve</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">max_</span><span class="p">{</span><span class="n">C</span><span class="p">,</span><span class="n">d</span><span class="p">}</span><span class="w"> </span><span class="n">log</span><span class="w"> </span><span class="n">det</span><span class="w"> </span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
<span class="n">s</span><span class="p">.</span><span class="n">t</span><span class="p">.</span><span class="w"> </span><span class="o">|</span><span class="n">aᵢC</span><span class="o">|</span><span class="n">₂</span><span class="w"> </span><span class="err">≤</span><span class="w"> </span><span class="n">bᵢ</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">aᵢd</span><span class="p">,</span><span class="w"> </span><span class="err">∀</span><span class="n">i</span>
<span class="n">C</span><span class="w"> </span><span class="err">≽</span><span class="w"> </span><span class="mi">0</span>
</pre></div>
</div>
</details><p>where aᵢ and bᵢ denote the ith row. This defines the ellipsoid E = {
Cx + d | <a href="#id13"><span class="problematic" id="id14">|</span></a>x|₂ ≤ 1}.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>the HPolyhedron is bounded.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if the solver fails to solve the problem.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">HPolyhedron.PontryaginDifference(self:</span> <span class="pre">pydrake.geometry.optimization.HPolyhedron,</span> <span class="pre">other:</span> <span class="pre">pydrake.geometry.optimization.HPolyhedron)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.geometry.optimization.HPolyhedron</span></span></dt>
<dd><p>Returns the Pontryagin (Minkowski) Difference of <code class="docutils literal notranslate"><span class="pre">this</span></code> and
<code class="docutils literal notranslate"><span class="pre">other</span></code>. This is the set A ⊖ B = { a|a+ B ⊆ A }. The result is an
HPolyhedron with the same number of inequalities as A. Requires that
<code class="docutils literal notranslate"><span class="pre">this</span></code> and <code class="docutils literal notranslate"><span class="pre">other</span></code> both be bounded and have the same ambient
dimension. This method may throw a runtime error if <code class="docutils literal notranslate"><span class="pre">this</span></code> or
<code class="docutils literal notranslate"><span class="pre">other</span></code> are ill-conditioned.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">HPolyhedron.ReduceInequalities(self:</span> <span class="pre">pydrake.geometry.optimization.HPolyhedron,</span> <span class="pre">tol:</span> <span class="pre">float</span> <span class="pre">=</span> <span class="pre">1e-09)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.geometry.optimization.HPolyhedron</span></span></dt>
<dd><p>Reduces some (not necessarily all) redundant inequalities in the
HPolyhedron. This is not guaranteed to give the minimal representation
of the polyhedron but is a relatively fast way to reduce the number of
inequalities.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">tol</span></code>:</dt><dd><p>For a constraint c’x&lt;=d, if the halfspace c’x&lt;=d + tol contains
the hpolyhedron generated by the rest of the constraints, then we
remove this inequality. A positive tol means it is more likely to
remove a constraint, a negative tol means it is less likely to
remote a constraint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">HPolyhedron.Scale(self:</span> <span class="pre">pydrake.geometry.optimization.HPolyhedron,</span> <span class="pre">scale:</span> <span class="pre">float,</span> <span class="pre">center:</span> <span class="pre">Optional[numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]]</span> <span class="pre">=</span> <span class="pre">None)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.geometry.optimization.HPolyhedron</span></span></dt>
<dd><p>Results a new HPolyhedron that is a scaled version of <code class="docutils literal notranslate"><span class="pre">this</span></code>, by
scaling the distance from each face to the <code class="docutils literal notranslate"><span class="pre">center</span></code> by a factor of
<code class="docutils literal notranslate"><span class="pre">pow(scale,</span> <span class="pre">1/ambient_dimension())</span></code>, to have units of volume: -
<code class="docutils literal notranslate"><span class="pre">scale</span> <span class="pre">=</span> <span class="pre">0</span></code> will result in a point, - <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;</span> <span class="pre">scale</span> <span class="pre">&lt;</span> <span class="pre">1</span></code> shrinks the
region, - <code class="docutils literal notranslate"><span class="pre">scale</span> <span class="pre">=</span> <span class="pre">1</span></code> returns a copy of the <code class="docutils literal notranslate"><span class="pre">this</span></code>, and - <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">&lt;</span>
<span class="pre">scale</span></code> grows the region.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">center</span></code> is not provided, then the value returned by
ChebyshevCenter() will be used.</p>
<p><code class="docutils literal notranslate"><span class="pre">this</span></code> does not need to be bounded, nor have volume. <code class="docutils literal notranslate"><span class="pre">center</span></code> does
not need to be in the set.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">scale</span></code> &gt;= 0.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">center</span></code> has size equal to the ambient dimension.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">HPolyhedron.SimplifyByIncrementalFaceTranslation(self:</span> <span class="pre">pydrake.geometry.optimization.HPolyhedron,</span> <span class="pre">min_volume_ratio:</span> <span class="pre">float</span> <span class="pre">=</span> <span class="pre">0.1,</span> <span class="pre">do_affine_transformation:</span> <span class="pre">bool</span> <span class="pre">=</span> <span class="pre">True,</span> <span class="pre">max_iterations:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">10,</span> <span class="pre">points_to_contain:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n]]</span> <span class="pre">=</span> <span class="pre">array([],</span> <span class="pre">shape=(0,</span> <span class="pre">0),</span> <span class="pre">dtype=float64),</span> <span class="pre">intersecting_polytopes:</span> <span class="pre">list[pydrake.geometry.optimization.HPolyhedron]</span> <span class="pre">=</span> <span class="pre">[],</span> <span class="pre">keep_whole_intersection:</span> <span class="pre">bool</span> <span class="pre">=</span> <span class="pre">False,</span> <span class="pre">intersection_padding:</span> <span class="pre">float</span> <span class="pre">=</span> <span class="pre">0.0001,</span> <span class="pre">random_seed:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">0)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.geometry.optimization.HPolyhedron</span></span></dt>
<dd><p>Returns an inner approximation of <code class="docutils literal notranslate"><span class="pre">this</span></code>, aiming to use fewer faces.
Proceeds by incrementally translating faces inward and removing other
faces that become redundant upon doing so.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">min_volume_ratio</span></code>:</dt><dd><p>is a lower bound for the ratio of the volume of the returned
inbody and the volume of <code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">do_affine_transformation</span></code>:</dt><dd><p>specifies whether to call
MaximumVolumeInscribedAffineTransformation(), to take an affine
transformation of the inner approximation to maximize its volume.
The affine transformation is reverted if the resulting inner
approximation violates conditions related to <code class="docutils literal notranslate"><span class="pre">points_to_contain</span></code>
or <code class="docutils literal notranslate"><span class="pre">intersecting_polytopes</span></code>.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">max_iterations</span></code>:</dt><dd><p>is the maximum number of times to loop through all faces.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">points_to_contain</span></code>:</dt><dd><p>is an optional matrix whose columns are points that must be
contained in the returned inbody.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">intersecting_polytopes</span></code>:</dt><dd><p>is an optional list of HPolyhedrons that must intersect with the
returned inbody.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">keep_whole_intersection</span></code>:</dt><dd><p>specifies whether the face translation step of the algorithm is
prohibited from reducing the intersections with the HPolyhedrons
in <code class="docutils literal notranslate"><span class="pre">intersecting_polytopes</span></code>. Regardless of the value of this
parameter, the intersections may be reduced by the affine
transformation step if <code class="docutils literal notranslate"><span class="pre">do_affine_transformation</span></code> is true.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">intersection_padding</span></code>:</dt><dd><p>is a distance by which each hyperplane is translated back outward
after satisfing intersection constraints, subject to not
surpassing the original hyperplane position. In the case where
<code class="docutils literal notranslate"><span class="pre">keep_whole_intersection</span></code> is false, using a non-zero value for
this parameter prevents intersections from being single points.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">random_seed</span></code>:</dt><dd><p>is a seed for a random number generator used to shuffle the
ordering of hyperplanes in between iterations.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">min_volume_ratio</span></code> &gt; 0.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">max_iterations</span></code> &gt; 0.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">intersection_padding</span></code> &gt;= 0.</p>
</dd>
<dt>Precondition:</dt><dd><p>All columns of <code class="docutils literal notranslate"><span class="pre">points_to_contain</span></code> are points contained within
<code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
</dd>
<dt>Precondition:</dt><dd><p>All elements of <code class="docutils literal notranslate"><span class="pre">intersecting_polytopes</span></code> intersect with
<code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">HPolyhedron.UniformSample(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>UniformSample(self: pydrake.geometry.optimization.HPolyhedron, generator: pydrake.common.RandomGenerator, previous_sample: numpy.ndarray[numpy.float64[m, 1]], mixing_steps: int = 10, subspace: Optional[numpy.ndarray[numpy.float64[m, n], flags.f_contiguous]] = None, tol: float = 1e-08) -&gt; numpy.ndarray[numpy.float64[m, 1]]</p></li>
</ol>
<p>Draw an (approximately) uniform sample from the set using the hit and
run Markov-chain Monte-Carlo strategy described in
<a class="reference external" href="https://link.springer.com/article/10.1007/s101070050099">https://link.springer.com/article/10.1007/s101070050099</a>. To draw many
samples from the uniform distribution, pass the output of one
iteration in as the <code class="docutils literal notranslate"><span class="pre">previous_sample</span></code> to the next, with
<code class="docutils literal notranslate"><span class="pre">mixing_steps</span></code> set to a relatively low number. When drawing a single
sample, <code class="docutils literal notranslate"><span class="pre">mixing_steps</span></code> should be set relatively high in order to
obtain an approximately uniformly random point. The distribution of
samples will converge to the true uniform distribution at a geometric
rate in the total number of hit-and-run steps which is
<code class="docutils literal notranslate"><span class="pre">mixing_steps</span></code> * the number of times this function is called. If a
<code class="docutils literal notranslate"><span class="pre">subspace</span></code> is provided, the random samples are constrained to lie in
the affine subspace through <code class="docutils literal notranslate"><span class="pre">previous_sample</span></code>, spanned by the
columns of <code class="docutils literal notranslate"><span class="pre">subspace</span></code>. To obtain uniform samples, subspace should
have orthonormal, columns. This enables drawing uniform samples from
an HPolyhedron which is not full-dimensional – one can pass the basis
of the affine hull of the HPolyhedron, which can be computed with the
AffineSubspace class. <code class="docutils literal notranslate"><span class="pre">tol</span></code> is a numerical tolerance for checking if
any halfspaces in the given HPolyhedron are implied by the
<code class="docutils literal notranslate"><span class="pre">subspace</span></code> definition (and therefore can be ignored by the
hit-and-run sampler).</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>subspace.rows() == ambient_dimension().</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if previous_sample is not in the set.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>UniformSample(self: pydrake.geometry.optimization.HPolyhedron, generator: pydrake.common.RandomGenerator, mixing_steps: int = 10, subspace: Optional[numpy.ndarray[numpy.float64[m, n], flags.f_contiguous]] = None, tol: float = 1e-08) -&gt; numpy.ndarray[numpy.float64[m, 1]]</p></li>
</ol>
<p>Variant of UniformSample that uses the ChebyshevCenter() as the
previous_sample as a feasible point to start the Markov chain
sampling.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Hyperellipsoid</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.geometry.optimization.ConvexSet</span></code></p>
<p>Implements an ellipsoidal convex set represented by the quadratic form
<code class="docutils literal notranslate"><span class="pre">{x</span> <span class="pre">|</span> <span class="pre">(x-center)ᵀAᵀA(x-center)</span> <span class="pre">≤</span> <span class="pre">1}</span></code>. Note that <code class="docutils literal notranslate"><span class="pre">A</span></code> need not be
square; we require only that the matrix AᵀA is positive semi-definite.</p>
<p>Compare this with an alternative (very useful) parameterization of the
ellipsoid: <code class="docutils literal notranslate"><span class="pre">{Bu</span> <span class="pre">+</span> <span class="pre">center</span> <span class="pre">|</span> <span class="pre">|u|₂</span> <span class="pre">≤</span> <span class="pre">1}</span></code>, which is an affine scaling of
the unit ball. This is related to the quadratic form by <code class="docutils literal notranslate"><span class="pre">B</span> <span class="pre">=</span> <span class="pre">A⁻¹</span></code>,
when <code class="docutils literal notranslate"><span class="pre">A</span></code> is invertible, but the quadratic form can also represent
unbounded sets. The affine scaling of the unit ball representation is
available via the AffineBall class.</p>
<p>Note: the name Hyperellipsoid was taken here to avoid conflicting with
geometry::Ellipsoid and to distinguish that this class supports N
dimensions.</p>
<p>A hyperellipsoid can never be empty – it always contains its center.
This includes the zero-dimensional case.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Hyperellipsoid.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.geometry.optimization.Hyperellipsoid) -&gt; None</p></li>
</ol>
<p>Constructs a default (zero-dimensional, nonempty) set.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.geometry.optimization.Hyperellipsoid, A: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], center: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</p></li>
</ol>
<p>Constructs the ellipsoid.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>A.cols() == center.size().</p>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li><p>__init__(self: pydrake.geometry.optimization.Hyperellipsoid, query_object: pydrake.geometry.QueryObject, geometry_id: pydrake.geometry.GeometryId, reference_frame: Optional[pydrake.geometry.FrameId] = None) -&gt; None</p></li>
</ol>
<p>Constructs a Hyperellipsoid from a SceneGraph geometry and pose in the
<code class="docutils literal notranslate"><span class="pre">reference_frame</span></code> frame, obtained via the QueryObject. If
<code class="docutils literal notranslate"><span class="pre">reference_frame</span></code> frame is std::nullopt, then it will be expressed
in the world frame.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if geometry_id does not represent a shape that can be</strong> – </p></li>
<li><p><strong>described as an Hyperellipsoid.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="4">
<li><p>__init__(self: pydrake.geometry.optimization.Hyperellipsoid, ellipsoid: pydrake.geometry.optimization.AffineBall) -&gt; None</p></li>
</ol>
<p>Constructs a Hyperellipsoid from an AffineBall.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>ellipsoid.B() is invertible.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Hyperellipsoid.A(self:</span> <span class="pre">pydrake.geometry.optimization.Hyperellipsoid)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n]]</span></span></dt>
<dd><p>Returns the quadratic form matrix A.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Hyperellipsoid.center(self:</span> <span class="pre">pydrake.geometry.optimization.Hyperellipsoid)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns the center of the ellipsoid.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Hyperellipsoid.MakeAxisAligned(radius:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]],</span> <span class="pre">center:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.geometry.optimization.Hyperellipsoid</span></span></dt>
<dd><p>Constructs the an axis-aligned Hyperellipsoid with the implicit form
(x₀-c₀)²/r₀² + (x₁-c₁)²/r₁² + … + (x_N - c_N)²/r_N² ≤ 1, where c is
shorthand for <code class="docutils literal notranslate"><span class="pre">center</span></code> and r is shorthand for <code class="docutils literal notranslate"><span class="pre">radius</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Hyperellipsoid.MakeHypersphere(radius:</span> <span class="pre">float,</span> <span class="pre">center:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.geometry.optimization.Hyperellipsoid</span></span></dt>
<dd><p>Constructs a hypersphere with <code class="docutils literal notranslate"><span class="pre">radius</span></code> and <code class="docutils literal notranslate"><span class="pre">center</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Hyperellipsoid.MakeUnitBall(dim:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.geometry.optimization.Hyperellipsoid</span></span></dt>
<dd><p>Constructs the L₂-norm unit ball in <code class="docutils literal notranslate"><span class="pre">dim</span></code> dimensions, {x | <a href="#id15"><span class="problematic" id="id16">|</span></a>x|₂ &lt;= 1
}.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Hyperellipsoid.MinimumUniformScalingToTouch(self:</span> <span class="pre">pydrake.geometry.optimization.Hyperellipsoid,</span> <span class="pre">other:</span> <span class="pre">pydrake.geometry.optimization.ConvexSet)</span> <span class="pre">-&gt;</span> <span class="pre">tuple[float,</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]]</span></span></dt>
<dd><p>Computes the smallest uniform scaling of this ellipsoid for which it
still intersects <code class="docutils literal notranslate"><span class="pre">other</span></code>. √ minₓ (x-center)ᵀAᵀA(x-center) s.t. x ∈
other. Note that if center ∈ other, then we expect scaling = 0 and x =
center (up to precision).</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">other</span></code> must have the same ambient_dimension as this.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>the minimal scaling and the witness point, x, on other.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>RuntimeError if other is empty.</strong> – </p></li>
<li><p><strong>RuntimeError if ambient_dimension</strong><strong>(</strong><strong>) </strong><strong>== 0</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Hyperellipsoid.MinimumVolumeCircumscribedEllipsoid(points:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous],</span> <span class="pre">rank_tol:</span> <span class="pre">float</span> <span class="pre">=</span> <span class="pre">1e-06)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.geometry.optimization.Hyperellipsoid</span></span></dt>
<dd><p>Constructs the minimum-volume ellipsoid which contains all of the
<code class="docutils literal notranslate"><span class="pre">points</span></code>. This is commonly referred to as the outer Löwner-John
ellipsoid.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">points</span></code>:</dt><dd><p>is a d-by-n matrix, where d is the ambient dimension and each
column represents one point.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">rank_tol</span></code>:</dt><dd><p>the singular values of the data matrix will be considered non-zero
if they are strictly greater than <code class="docutils literal notranslate"><span class="pre">rank_tol</span></code> *
<code class="docutils literal notranslate"><span class="pre">max_singular_value</span></code>. The default is 1e-6 to be compatible with
common solver tolerances. This is used to detect if the data lies
on a lower-dimensional affine space than the ambient dimension of
the ellipsoid. If this is the case, then use
AffineBall::MinimumVolumeCircumscribedEllipsoid instead.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the MathematicalProgram fails to solve. If this</strong> – </p></li>
<li><p><strong>were to happen</strong><strong> (</strong><strong>due to numerical issues</strong><strong>)</strong><strong>, </strong><strong>then increasing</strong> – </p></li>
<li><p><strong>rank_tol` should provide a mitigation</strong> – </p></li>
<li><p><strong>RuntimeError if points includes NaNs</strong><strong> or </strong><strong>infinite values.</strong> – </p></li>
<li><p><strong>RuntimeError if the numerical data rank</strong><strong> of </strong><strong>points is less than d.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Hyperrectangle</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.geometry.optimization.ConvexSet</span></code></p>
<p>Axis-aligned hyperrectangle in Rᵈ defined by its lower bounds and
upper bounds as {x| lb ≤ x ≤ ub}</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Hyperrectangle.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.geometry.optimization.Hyperrectangle) -&gt; None</p></li>
</ol>
<p>Constructs a default (zero-dimensional, nonempty) hyperrectangle.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.geometry.optimization.Hyperrectangle, lb: numpy.ndarray[numpy.float64[m, 1]], ub: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</p></li>
</ol>
<p>Constructs a hyperrectangle from its lower and upper bounds.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>lb.size() == ub.size()</p>
</dd>
<dt>Precondition:</dt><dd><p>lb and ub are finite.</p>
</dd>
<dt>Precondition:</dt><dd><p>lb(i) &lt;= ub(i) for all i</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Hyperrectangle.Center(self:</span> <span class="pre">pydrake.geometry.optimization.Hyperrectangle)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Get the center of the hyperrectangle.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Hyperrectangle.lb(self:</span> <span class="pre">pydrake.geometry.optimization.Hyperrectangle)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Get the lower bounds of the hyperrectangle.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Hyperrectangle.MakeHPolyhedron(self:</span> <span class="pre">pydrake.geometry.optimization.Hyperrectangle)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.geometry.optimization.HPolyhedron</span></span></dt>
<dd><p>Helper to convert this hyperrectangle to an HPolyhedron.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Hyperrectangle.MaybeCalcAxisAlignedBoundingBox(set:</span> <span class="pre">pydrake.geometry.optimization.ConvexSet)</span> <span class="pre">-&gt;</span> <span class="pre">Optional[pydrake.geometry.optimization.Hyperrectangle]</span></span></dt>
<dd><p>Returns the minimum axis-aligned bounding box of a convex set, for
sets with finite volume. (std::nullopt otherwise).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Hyperrectangle.MaybeGetIntersection(self:</span> <span class="pre">pydrake.geometry.optimization.Hyperrectangle,</span> <span class="pre">arg0:</span> <span class="pre">pydrake.geometry.optimization.Hyperrectangle)</span> <span class="pre">-&gt;</span> <span class="pre">Optional[pydrake.geometry.optimization.Hyperrectangle]</span></span></dt>
<dd><p>Constructs the intersection of two Hyperrectangle by taking the
pointwise maximum of the lower bounds and the pointwise minimums of
the upper bounds. Returns std::nullopt if the intersection is empty.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>this and other need to have the same ambient dimension.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Hyperrectangle.ub(self:</span> <span class="pre">pydrake.geometry.optimization.Hyperrectangle)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Get the upper bounds of the hyperrectangle.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Hyperrectangle.UniformSample(self:</span> <span class="pre">pydrake.geometry.optimization.Hyperrectangle,</span> <span class="pre">generator:</span> <span class="pre">pydrake.common.RandomGenerator)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Draws a uniform sample from the set.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ImplicitGraphOfConvexSets</span></span></dt>
<dd><p>A base class to define the interface to an implicit graph of convex
sets.</p>
<p>Implementations of this class must implement DoSuccesors() and provide
some method of accessing at least one vertex in the graph.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This feature is considered to be <strong>experimental</strong> and may change
or be removed at any time, without any deprecation notice ahead of
time.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ImplicitGraphOfConvexSets.__init__(self:</span> <span class="pre">pydrake.geometry.optimization.ImplicitGraphOfConvexSets)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructs the (empty) implicit GCS.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ImplicitGraphOfConvexSets.ExpandRecursively(self:</span> <span class="pre">pydrake.geometry.optimization.ImplicitGraphOfConvexSets,</span> <span class="pre">start:</span> <span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.Vertex,</span> <span class="pre">max_successor_calls:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">1000)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Makes repeated recursive calls to Successors() until no new vertices
will be added to the graph, or <code class="docutils literal notranslate"><span class="pre">max_successor_calls</span></code> has been
reached.</p>
<p>Note: <code class="docutils literal notranslate"><span class="pre">v</span></code> is mutable because expanding a vertex requires changes to
the underlying vertex object.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if v is not already registered with the graph.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ImplicitGraphOfConvexSets.gcs(self:</span> <span class="pre">pydrake.geometry.optimization.ImplicitGraphOfConvexSets)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.geometry.optimization.GraphOfConvexSets</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ImplicitGraphOfConvexSets.mutable_gcs(self:</span> <span class="pre">pydrake.geometry.optimization.ImplicitGraphOfConvexSets)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.geometry.optimization.GraphOfConvexSets</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ImplicitGraphOfConvexSets.Successors(self:</span> <span class="pre">pydrake.geometry.optimization.ImplicitGraphOfConvexSets,</span> <span class="pre">v:</span> <span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.Vertex)</span> <span class="pre">-&gt;</span> <span class="pre">list[pydrake.geometry.optimization.GraphOfConvexSets.Edge]</span></span></dt>
<dd><p>Returns the outgoing edges from <code class="docutils literal notranslate"><span class="pre">v</span></code>, which defines the “successors”
of <code class="docutils literal notranslate"><span class="pre">v</span></code> in the common notation of implicit graph search. The internal
gcs() object is expanded as needed to include the edges (and the
vertices they point to) that are returned.</p>
<p>Note: The input arguments are mutable because expanding a vertex
requires changes to the underlying vertex object. Similarly, the
output is mutable because callers will need to get mutable vertex
pointers from the returned edges to expand them further.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if v is not already registered with the graph.</strong> – </p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ImplicitGraphOfConvexSetsFromExplicit</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.geometry.optimization.ImplicitGraphOfConvexSets</span></code></p>
<p>Provides an implicit GCS interface given an explicit GCS. Vertices and
edges are cloned into the implicit GCS as they are expanded.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ImplicitGraphOfConvexSetsFromExplicit.__init__(self:</span> <span class="pre">pydrake.geometry.optimization.ImplicitGraphOfConvexSetsFromExplicit,</span> <span class="pre">gcs:</span> <span class="pre">pydrake.geometry.optimization.GraphOfConvexSets)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructs an implicit GCS from an explicit GCS. <code class="docutils literal notranslate"><span class="pre">gcs</span></code> must remain
valid for the lifetime of this object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ImplicitGraphOfConvexSetsFromExplicit.ImplicitVertexFromExplicit(self:</span> <span class="pre">pydrake.geometry.optimization.ImplicitGraphOfConvexSetsFromExplicit,</span> <span class="pre">v_explicit:</span> <span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.Vertex)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.Vertex</span></span></dt>
<dd><p>Looks up the implicit vertex corresponding to <code class="docutils literal notranslate"><span class="pre">v</span></code>. If <code class="docutils literal notranslate"><span class="pre">v</span></code> is not
already in the implicit GCS, it is added.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if v is not registered with the explicit GCS</strong> – </p></li>
<li><p><strong>passed in the constructor.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Intersection</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.geometry.optimization.ConvexSet</span></code></p>
<p>A convex set that represents the intersection of multiple sets: S = X₁
∩ X₂ ∩ … ∩ Xₙ = {x | x ∈ X₁, x ∈ X₂, …, x ∈ Xₙ}</p>
<p>Special behavior for IsEmpty: The intersection of zero sets (i.e. when
we have <a href="#id25"><span class="problematic" id="id26">sets_</span></a>.size() == 0) is always nonempty. This includes the
zero-dimensional case, which we treat as being {0}, the unique
zero-dimensional vector space.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Intersection.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.geometry.optimization.Intersection) -&gt; None</p></li>
</ol>
<p>Constructs a default (zero-dimensional, nonempty) set.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.geometry.optimization.Intersection, sets: list[pydrake.geometry.optimization.ConvexSet]) -&gt; None</p></li>
</ol>
<p>Constructs the intersection from a vector of convex sets.</p>
<ol class="arabic simple" start="3">
<li><p>__init__(self: pydrake.geometry.optimization.Intersection, setA: pydrake.geometry.optimization.ConvexSet, setB: pydrake.geometry.optimization.ConvexSet) -&gt; None</p></li>
</ol>
<p>Constructs the intersection from a pair of convex sets.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Intersection.element(self:</span> <span class="pre">pydrake.geometry.optimization.Intersection,</span> <span class="pre">index:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.geometry.optimization.ConvexSet</span></span></dt>
<dd><p>Returns a reference to the ConvexSet defining the <code class="docutils literal notranslate"><span class="pre">index</span></code> element in
the intersection.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Intersection.num_elements(self:</span> <span class="pre">pydrake.geometry.optimization.Intersection)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>The number of elements (or sets) used in the intersection.</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Iris(obstacles:</span> <span class="pre">list[pydrake.geometry.optimization.ConvexSet],</span> <span class="pre">sample:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]],</span> <span class="pre">domain:</span> <span class="pre">pydrake.geometry.optimization.HPolyhedron,</span> <span class="pre">options:</span> <span class="pre">pydrake.geometry.optimization.IrisOptions</span> <span class="pre">=</span> <span class="pre">IrisOptions(require_sample_point_is_contained=False,</span> <span class="pre">iteration_limit=100,</span> <span class="pre">termination_threshold=0.02,</span> <span class="pre">relative_termination_threshold=0.001,</span> <span class="pre">configuration_space_margin=0.01,</span> <span class="pre">num_collision_infeasible_samples=5,</span> <span class="pre">configuration_obstacles</span> <span class="pre">[],</span> <span class="pre">prog_with_additional_constraints</span> <span class="pre">is</span> <span class="pre">not</span> <span class="pre">set,</span> <span class="pre">num_additional_constraint_infeasible_samples=5,</span> <span class="pre">random_seed=1234,</span> <span class="pre">mixing_steps=10))</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.geometry.optimization.HPolyhedron</span></span></dt>
<dd><p>The IRIS (Iterative Region Inflation by Semidefinite programming)
algorithm, as described in</p>
<p>R. L. H. Deits and R. Tedrake, “Computing large convex regions of
obstacle-free space through semidefinite programming,” Workshop on the
Algorithmic Fundamentals of Robotics, Istanbul, Aug. 2014.
<a class="reference external" href="http://groups.csail.mit.edu/robotics-center/public_papers/Deits14.pdf">http://groups.csail.mit.edu/robotics-center/public_papers/Deits14.pdf</a></p>
<p>This algorithm attempts to locally maximize the volume of a convex
polytope representing obstacle-free space given a sample point and
list of convex obstacles. Rather than compute the volume of the
polytope directly, the algorithm maximizes the volume of an inscribed
ellipsoid. It alternates between finding separating hyperplanes
between the ellipsoid and the obstacles and then finding a new
maximum-volume inscribed ellipsoid.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">obstacles</span></code>:</dt><dd><p>is a vector of convex sets representing the occupied space.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">sample</span></code>:</dt><dd><p>provides a point in the space; the algorithm is initialized using
a tiny sphere around this point. The algorithm is only guaranteed
to succeed if this sample point is collision free (outside of all
obstacles), but in practice the algorithm can often escape bad
initialization (assuming the require_sample_point_is_contained
option is false).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">domain</span></code>:</dt><dd><p>describes the total region of interest; computed IRIS regions will
be inside this domain. It must be bounded, and is typically a
simple bounding box (e.g. from HPolyhedron::MakeBox).</p>
</dd>
</dl>
<p>The <code class="docutils literal notranslate"><span class="pre">obstacles</span></code>, <code class="docutils literal notranslate"><span class="pre">sample</span></code>, and the <code class="docutils literal notranslate"><span class="pre">domain</span></code> must describe
elements in the same ambient dimension (but that dimension can be any
positive integer).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Some members of <code class="docutils literal notranslate"><span class="pre">options</span></code> are only applicable to IrisNp. The
members relevant for this function are starting_ellipse,
termination_func, bounding_region, verify_domain_boundedness,
require_sample_point_is_contained, iteration_limit,
termination_threshold, relative_termination_threshold.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">IrisInConfigurationSpace(plant:</span> <span class="pre">drake::multibody::MultibodyPlant&lt;double&gt;,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">options:</span> <span class="pre">pydrake.geometry.optimization.IrisOptions</span> <span class="pre">=</span> <span class="pre">IrisOptions(require_sample_point_is_contained=False,</span> <span class="pre">iteration_limit=100,</span> <span class="pre">termination_threshold=0.02,</span> <span class="pre">relative_termination_threshold=0.001,</span> <span class="pre">configuration_space_margin=0.01,</span> <span class="pre">num_collision_infeasible_samples=5,</span> <span class="pre">configuration_obstacles</span> <span class="pre">[],</span> <span class="pre">prog_with_additional_constraints</span> <span class="pre">is</span> <span class="pre">not</span> <span class="pre">set,</span> <span class="pre">num_additional_constraint_infeasible_samples=5,</span> <span class="pre">random_seed=1234,</span> <span class="pre">mixing_steps=10))</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.geometry.optimization.HPolyhedron</span></span></dt>
<dd><p>(Deprecated.)</p>
<dl class="simple">
<dt>Deprecated:</dt><dd><p>Use IrisNp instead. This will be removed from Drake on or after
2025-12-01.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">IrisNp(plant:</span> <span class="pre">drake::multibody::MultibodyPlant&lt;double&gt;,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">options:</span> <span class="pre">pydrake.geometry.optimization.IrisOptions</span> <span class="pre">=</span> <span class="pre">IrisOptions(require_sample_point_is_contained=False,</span> <span class="pre">iteration_limit=100,</span> <span class="pre">termination_threshold=0.02,</span> <span class="pre">relative_termination_threshold=0.001,</span> <span class="pre">configuration_space_margin=0.01,</span> <span class="pre">num_collision_infeasible_samples=5,</span> <span class="pre">configuration_obstacles</span> <span class="pre">[],</span> <span class="pre">prog_with_additional_constraints</span> <span class="pre">is</span> <span class="pre">not</span> <span class="pre">set,</span> <span class="pre">num_additional_constraint_infeasible_samples=5,</span> <span class="pre">random_seed=1234,</span> <span class="pre">mixing_steps=10))</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.geometry.optimization.HPolyhedron</span></span></dt>
<dd><p>A variation of the Iris (Iterative Region Inflation by Semidefinite
programming) algorithm which finds collision-free regions in the
<em>configuration space</em> of <code class="docutils literal notranslate"><span class="pre">plant</span></code>.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>Iris for details on the original algorithm. This variant uses
nonlinear optimization (instead of convex optimization) to find
collisions in configuration space; each potential collision is
probabilistically “certified” by restarting the nonlinear
optimization from random initial seeds inside the candidate IRIS
region until it fails to find a collision in
<code class="docutils literal notranslate"><span class="pre">options.num_collision_infeasible_samples</span></code> consecutive attempts.</p>
</div>
<p>This method constructs a single Iris region in the configuration space
of <code class="docutils literal notranslate"><span class="pre">plant</span></code>.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>planning::IrisInConfigurationSpaceFromCliqueCover for a method to
automatically cover the configuration space with multiple Iris
regions.</p>
</div>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">plant</span></code>:</dt><dd><p>describes the kinematics of configuration space. It must be
connected to a SceneGraph in a systems::Diagram.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>is a context of the <code class="docutils literal notranslate"><span class="pre">plant</span></code>. The context must have the positions
of the plant set to the initialIRIS seed configuration.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">options</span></code>:</dt><dd><p>provides additional configuration options. In particular,
increasing <code class="docutils literal notranslate"><span class="pre">options.num_collision_infeasible_samples</span></code> increases
the chances that the IRIS regions are collision free but can also
significantly increase the run-time of the algorithm. The same
goes for
<code class="docutils literal notranslate"><span class="pre">options.num_additional_constraints_infeasible_samples</span></code>.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the sample configuration in context is</strong> – </p></li>
<li><p><strong>infeasible.</strong> – </p></li>
<li><p><strong>RuntimeError if termination_func is invalid on the domain. See</strong> – </p></li>
<li><p><strong>IrisOptions.termination_func for more details.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">IrisOptions</span></span></dt>
<dd><p>Configuration options for the IRIS algorithm.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">IrisOptions.__init__(self:</span> <span class="pre">pydrake.geometry.optimization.IrisOptions,</span> <span class="pre">**kwargs)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">IrisOptions.bounding_region</span></span></dt>
<dd><p>Optionally allows the caller to restrict the space within which IRIS
regions are allowed to grow. By default, IRIS regions are bounded by
the <code class="docutils literal notranslate"><span class="pre">domain</span></code> argument in the case of <code class="docutils literal notranslate"><span class="pre">Iris</span></code> or the joint limits of
the input <code class="docutils literal notranslate"><span class="pre">plant</span></code> in the case of <code class="docutils literal notranslate"><span class="pre">IrisNp</span></code>. If this option is
specified, IRIS regions will be confined to the intersection between
the domain and <code class="docutils literal notranslate"><span class="pre">bounding_region</span></code>.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">IrisOptions.configuration_obstacles</span></span></dt>
<dd><p>For IrisNp, it can be beneficial to not only specify task-space
obstacles (passed in through the plant) but also obstacles that are
defined by convex sets in the configuration space. This option can be
used to pass in such configuration space obstacles.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">IrisOptions.configuration_space_margin</span></span></dt>
<dd><p>For IrisNp, we retreat by this margin from each C-space obstacle in
order to avoid the possibility of requiring an infinite number of
faces to approximate a curved boundary.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">IrisOptions.iteration_limit</span></span></dt>
<dd><p>Maximum number of iterations.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">IrisOptions.mixing_steps</span></span></dt>
<dd><p>The <code class="docutils literal notranslate"><span class="pre">mixing_steps</span></code> parameters is passed to
HPolyhedron::UniformSample to control the total number of hit-and-run
steps taken for each new random sample.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">IrisOptions.num_additional_constraint_infeasible_samples</span></span></dt>
<dd><p>For each constraint in <code class="docutils literal notranslate"><span class="pre">prog_with_additional_constraints</span></code>, IRIS will
search for a counter-example by formulating a (likely nonconvex)
optimization problem. The initial guess for this optimization is taken
by sampling uniformly inside the current IRIS region. This option
controls the termination condition for that counter-example search,
defining the number of consecutive failures to find a counter-example
requested before moving on to the next constraint.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">IrisOptions.num_collision_infeasible_samples</span></span></dt>
<dd><p>For each possible collision, IRIS will search for a counter-example by
formulating a (likely nonconvex) optimization problem. The initial
guess for this optimization is taken by sampling uniformly inside the
current IRIS region. This option controls the termination condition
for that counter-example search, defining the number of consecutive
failures to find a counter-example requested before moving on to the
next constraint.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">IrisOptions.prog_with_additional_constraints</span></span></dt>
<dd><p>By default, IrisNp certifies regions for collision avoidance
constraints and joint limits. This option can be used to pass
additional constraints that should be satisfied by the IRIS region. We
accept these in the form of a MathematicalProgram:</p>
<p>find q subject to g(q) ≤ 0.</p>
<p>The decision_variables() for the program are taken to define <code class="docutils literal notranslate"><span class="pre">q</span></code>.
IRIS will silently ignore any costs in
<code class="docutils literal notranslate"><span class="pre">prog_with_additional_constraints</span></code>, and will throw RuntimeError if
it contains any unsupported constraints.</p>
<p>For example, one could create an InverseKinematics problem with rich
kinematic constraints, and then pass <code class="docutils literal notranslate"><span class="pre">InverseKinematics::prog()</span></code>
into this option.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">IrisOptions.random_seed</span></span></dt>
<dd><p>The only randomization in IRIS is the random sampling done to find
counter-examples for the additional constraints using in IrisNp. Use
this option to set the initial seed.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">IrisOptions.relative_termination_threshold</span></span></dt>
<dd><p>IRIS will terminate if the change in the <em>volume</em> of the
hyperellipsoid between iterations is less that this percent of the
previous best volume. This termination condition can be disabled by
setting to a negative value.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">IrisOptions.require_sample_point_is_contained</span></span></dt>
<dd><p>The initial polytope is guaranteed to contain the point if that point
is collision-free. However, the IRIS alternation objectives do not
include (and can not easily include) a constraint that the original
sample point is contained. Therefore, the IRIS paper recommends that
if containment is a requirement, then the algorithm should simply
terminate early if alternations would ever cause the set to not
contain the point.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">IrisOptions.solver_options</span></span></dt>
<dd><p>The SolverOptions used in the optimization program.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">IrisOptions.starting_ellipse</span></span></dt>
<dd><p>The initial hyperellipsoid that IRIS will use for calculating
hyperplanes in the first iteration. If no hyperellipsoid is provided,
a small hypershpere centered at the given sample will be used.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">IrisOptions.termination_threshold</span></span></dt>
<dd><p>IRIS will terminate if the change in the <em>volume</em> of the
hyperellipsoid between iterations is less that this threshold. This
termination condition can be disabled by setting to a negative value.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">IrisOptions.verify_domain_boundedness</span></span></dt>
<dd><p>If the user knows the intersection of bounding_region and the domain
(for IRIS) or plant joint limits (for IrisNp) is bounded, setting this
flag to <code class="docutils literal notranslate"><span class="pre">False</span></code> will skip the boundedness check that IRIS and IrisNp
perform (leading to a small speedup, as checking boundedness requires
solving optimization problems). If the intersection turns out to be
unbounded, this will lead to undefined behavior.</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LoadIrisRegionsYamlFile(filename:</span> <span class="pre">os.PathLike,</span> <span class="pre">child_name:</span> <span class="pre">Optional[str]</span> <span class="pre">=</span> <span class="pre">None)</span> <span class="pre">-&gt;</span> <span class="pre">dict[str,</span> <span class="pre">pydrake.geometry.optimization.HPolyhedron]</span></span></dt>
<dd><p>Calls LoadYamlFile() to deserialize an IrisRegions object.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MakeIrisObstacles(query_object:</span> <span class="pre">pydrake.geometry.QueryObject,</span> <span class="pre">reference_frame:</span> <span class="pre">Optional[pydrake.geometry.FrameId]</span> <span class="pre">=</span> <span class="pre">None)</span> <span class="pre">-&gt;</span> <span class="pre">list[pydrake.geometry.optimization.ConvexSet]</span></span></dt>
<dd><p>Constructs ConvexSet representations of obstacles for IRIS in 3D using
the geometry from a SceneGraph QueryObject. All geometry in the scene
with a proximity role, both anchored and dynamic, are consider to be
<em>fixed</em> obstacles frozen in the poses captured in the context used to
create the QueryObject.</p>
<p>When multiple representations are available for a particular geometry
(e.g. a Box can be represented as either an HPolyhedron or a
VPolytope), then this method will prioritize the representation that
we expect is most performant for the current implementation of the
IRIS algorithm.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MinkowskiSum</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.geometry.optimization.ConvexSet</span></code></p>
<p>A convex set that represents the Minkowski sum of multiple sets: S =
X₁ ⨁ X₂ ⨁ … ⨁ Xₙ = {x₁ + x₂ + … + xₙ | x₁ ∈ X₁, x₂ ∈ X₂, …, xₙ ∈
Xₙ}</p>
<p>Special behavior for IsEmpty: The Minkowski sum of zero sets (i.e.
when we have <a href="#id27"><span class="problematic" id="id28">sets_</span></a>.size() == 0) is treated as the singleton {0}, which
is nonempty. This includes the zero-dimensional case.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MinkowskiSum.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.geometry.optimization.MinkowskiSum) -&gt; None</p></li>
</ol>
<p>Constructs a default (zero-dimensional, nonempty) set.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.geometry.optimization.MinkowskiSum, sets: list[pydrake.geometry.optimization.ConvexSet]) -&gt; None</p></li>
</ol>
<p>Constructs the sum from a vector of convex sets.</p>
<ol class="arabic simple" start="3">
<li><p>__init__(self: pydrake.geometry.optimization.MinkowskiSum, setA: pydrake.geometry.optimization.ConvexSet, setB: pydrake.geometry.optimization.ConvexSet) -&gt; None</p></li>
</ol>
<p>Constructs the sum from a pair of convex sets.</p>
<ol class="arabic simple" start="4">
<li><p>__init__(self: pydrake.geometry.optimization.MinkowskiSum, query_object: pydrake.geometry.QueryObject, geometry_id: pydrake.geometry.GeometryId, reference_frame: Optional[pydrake.geometry.FrameId] = None) -&gt; None</p></li>
</ol>
<p>Constructs a MinkowskiSum from a SceneGraph geometry and pose in the
<code class="docutils literal notranslate"><span class="pre">reference_frame</span></code> frame, obtained via the QueryObject. If
<code class="docutils literal notranslate"><span class="pre">reference_frame</span></code> frame is std::nullopt, then it will be expressed
in the world frame.</p>
<p>Although in principle a MinkowskiSum can represent any ConvexSet as
the sum of a single set, here we only support Capsule geometry, which
will be represented as the (non-trivial) Minkowski sum of a sphere
with a line segment. Most SceneGraph geometry types are supported by
at least one of the ConvexSet class constructors.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if geometry_id does not correspond to a Capsule.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MinkowskiSum.num_terms(self:</span> <span class="pre">pydrake.geometry.optimization.MinkowskiSum)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>The number of terms (or sets) used in the sum.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MinkowskiSum.term(self:</span> <span class="pre">pydrake.geometry.optimization.MinkowskiSum,</span> <span class="pre">index:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.geometry.optimization.ConvexSet</span></span></dt>
<dd><p>Returns a reference to the ConvexSet defining the <code class="docutils literal notranslate"><span class="pre">index</span></code> term in
the sum.</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PartitionConvexSet(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>PartitionConvexSet(convex_set: pydrake.geometry.optimization.ConvexSet, continuous_revolute_joints: list[int], epsilon: float = 1e-05) -&gt; list[pydrake.geometry.optimization.ConvexSet]</p></li>
</ol>
<p>Partitions a convex set into (smaller) convex sets whose union is the
original set and that each respect the convexity radius as in
CheckIfSatisfiesConvexityRadius. In practice, this is implemented as
partitioning sets into pieces whose width is less than or equal to
π-ϵ. Each entry in continuous_revolute_joints must be non-negative,
less than num_positions, and unique.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">epsilon</span></code>:</dt><dd><p>is the ϵ value used for the convexity radius inequality. The
partitioned sets are made by intersecting convex_set with
axis-aligned bounding boxes that respect the convexity radius.
These boxes are made to overlap by ϵ radians along each dimension,
for numerical purposes.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>the vector of convex sets that each respect convexity radius.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>RuntimeError if ϵ &lt;= 0</strong><strong> or </strong><strong>ϵ &gt;= π.</strong> – </p></li>
<li><p><strong>RuntimeError if the input convex set is unbounded along dimensions</strong> – </p></li>
<li><p><strong>corresponding to continuous revolute joints.</strong> – </p></li>
<li><p><strong>RuntimeError if continuous_revolute_joints has repeated entries</strong><strong>,</strong> – </p></li>
<li><p><strong>or if any entry is outside the interval</strong><strong> [</strong><strong>0</strong><strong>,</strong> – </p></li>
<li><p><strong>convex_set.ambient_dimension</strong><strong>(</strong><strong>)</strong><strong>)</strong><strong>.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>PartitionConvexSet(convex_sets: list[pydrake.geometry.optimization.ConvexSet], continuous_revolute_joints: list[int], epsilon: float = 1e-05) -&gt; list[pydrake.geometry.optimization.ConvexSet]</p></li>
</ol>
<p>Function overload to take in a list of convex sets, and partition all
so as to respect the convexity radius. Every set must be bounded and
have the same ambient dimension. Each entry in
continuous_revolute_joints must be non-negative, less than
num_positions, and unique.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError unless every ConvexSet in convex_sets has the same</strong> – </p></li>
<li><p><strong>ambient_dimension.</strong> – </p></li>
<li><p><strong>RuntimeError if ϵ &lt;= 0</strong><strong> or </strong><strong>ϵ &gt;= π.</strong> – </p></li>
<li><p><strong>RuntimeError if any input convex set is unbounded along dimensions</strong> – </p></li>
<li><p><strong>corresponding to continuous revolute joints.</strong> – </p></li>
<li><p><strong>RuntimeError if continuous_revolute_joints has repeated entries</strong><strong>,</strong> – </p></li>
<li><p><strong>or if any entry is outside the interval</strong><strong> [</strong><strong>0</strong><strong>, </strong><strong>ambient_dimension</strong><strong>)</strong><strong>.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PlaneSide</span></span></dt>
<dd><p>Members:</p>
<blockquote>
<div><p>kPositive</p>
<p>kNegative</p>
</div></blockquote>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PlaneSide.__init__(self:</span> <span class="pre">pydrake.geometry.optimization.PlaneSide,</span> <span class="pre">value:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PlaneSide.kNegative</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PlaneSide.kPositive</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PlaneSide.name</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PlaneSide.value</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Point</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.geometry.optimization.ConvexSet</span></code></p>
<p>A convex set that contains exactly one element. Also known as a
singleton or unit set.</p>
<p>This set is always nonempty, even in the zero-dimensional case.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Point.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.geometry.optimization.Point) -&gt; None</p></li>
</ol>
<p>Constructs a default (zero-dimensional, nonempty) set.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.geometry.optimization.Point, x: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</p></li>
</ol>
<p>Constructs a Point.</p>
<ol class="arabic simple" start="3">
<li><p>__init__(self: pydrake.geometry.optimization.Point, query_object: pydrake.geometry.QueryObject, geometry_id: pydrake.geometry.GeometryId, reference_frame: Optional[pydrake.geometry.FrameId] = None, maximum_allowable_radius: float = 0.0) -&gt; None</p></li>
</ol>
<p>Constructs a Point from a SceneGraph geometry and pose in the
<code class="docutils literal notranslate"><span class="pre">reference_frame</span></code> frame, obtained via the QueryObject. If
<code class="docutils literal notranslate"><span class="pre">reference_frame</span></code> frame is std::nullopt, then it will be expressed
in the world frame.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if geometry_id does not correspond to a Sphere</strong><strong> or </strong><strong>if</strong> – </p></li>
<li><p><strong>the Sphere has radius greater than maximum_allowable_radius.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Point.set_x(self:</span> <span class="pre">pydrake.geometry.optimization.Point,</span> <span class="pre">x:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Changes the element <code class="docutils literal notranslate"><span class="pre">x</span></code> describing the set.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>x must be of size ambient_dimension().</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Point.x(self:</span> <span class="pre">pydrake.geometry.optimization.Point)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Retrieves the point.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SampledVolume</span></span></dt>
<dd><p>The result of a volume calculation from CalcVolumeViaSampling().</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SampledVolume.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SampledVolume.num_samples</span></span></dt>
<dd><p>The number of samples used to compute the volume estimate.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SampledVolume.rel_accuracy</span></span></dt>
<dd><p>An upper bound for the relative accuracy of the volume estimate. When
not evaluated, this value is NaN.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SampledVolume.volume</span></span></dt>
<dd><p>The estimated volume of the set.</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SaveIrisRegionsYamlFile(filename:</span> <span class="pre">os.PathLike,</span> <span class="pre">regions:</span> <span class="pre">dict[str,</span> <span class="pre">pydrake.geometry.optimization.HPolyhedron],</span> <span class="pre">child_name:</span> <span class="pre">Optional[str]</span> <span class="pre">=</span> <span class="pre">None)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Calls SaveYamlFile() to serialize an IrisRegions object.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SeparatingPlaneOrder</span></span></dt>
<dd><p>The separating plane aᵀx + b ≥ δ, aᵀx + b ≤ −δ has parameters a and b.
These parameterize a polynomial function of <code class="docutils literal notranslate"><span class="pre">s_for_plane</span></code> with the
specified order. <code class="docutils literal notranslate"><span class="pre">s_for_plane</span></code> is a sub set of the
configuration-space variable <code class="docutils literal notranslate"><span class="pre">s</span></code>, please refer to the
RationalForwardKinematics class or the paper above on the meaning of
s.</p>
<p>Members:</p>
<blockquote>
<div><p>kAffine : a and b are affine functions of s.</p>
</div></blockquote>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SeparatingPlaneOrder.__init__(self:</span> <span class="pre">pydrake.geometry.optimization.SeparatingPlaneOrder,</span> <span class="pre">value:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SeparatingPlaneOrder.kAffine</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SeparatingPlaneOrder.name</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SeparatingPlaneOrder.value</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SeparationCertificateProgramBase</span></span></dt>
<dd><dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SeparationCertificateProgramBase.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SeparationCertificateProgramBase.plane_index</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SeparationCertificateProgramBase.prog(self:</span> <span class="pre">pydrake.geometry.optimization.SeparationCertificateProgramBase)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.solvers.MathematicalProgram</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SeparationCertificateResultBase</span></span></dt>
<dd><p>We certify that a pair of geometries is collision free by finding the
separating plane over a range of configuration. The Lagrangian
multipliers used for certifying this condition will differ in derived
classes. This struct contains the the separating plane {x | aᵀx+b=0 }
and derived classes may store the Lagrangians certifying that the
plane separates the two geometries in separating_planes()[plane_index]
in the C-space region.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SeparationCertificateResultBase.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SeparationCertificateResultBase.a</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SeparationCertificateResultBase.b</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SeparationCertificateResultBase.plane_decision_var_vals</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SeparationCertificateResultBase.result</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Spectrahedron</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.geometry.optimization.ConvexSet</span></code></p>
<p>Implements a spectrahedron (the feasible set of a semidefinite
program). The ambient dimension of the set is N(N+1)/2; the number of
variables required to describe the N-by-N semidefinite matrix.</p>
<p>By convention, a zero-dimensional spectrahedron is considered
nonempty.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Spectrahedron.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.geometry.optimization.Spectrahedron) -&gt; None</p></li>
</ol>
<p>Default constructor (yields the zero-dimensional nonempty set).</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.geometry.optimization.Spectrahedron, prog: pydrake.solvers.MathematicalProgram) -&gt; None</p></li>
</ol>
<p>Constructs the spectrahedron from a MathematicalProgram.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if prog.required_capabilities</strong><strong>(</strong><strong>) </strong><strong>is not a subset</strong> – </p></li>
<li><p><strong>of supported_attributes</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VPolytope</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.geometry.optimization.ConvexSet</span></code></p>
<p>A polytope described using the vertex representation. The set is
defined as the convex hull of the vertices. The vertices are not
guaranteed to be in any particular order, nor to be minimal (some
vertices could be strictly in the interior of the set).</p>
<p>Note: Unlike the half-space representation, this definition means the
set is always bounded (hence the name polytope, instead of
polyhedron).</p>
<p>A VPolytope is empty if and only if it is composed of zero vertices,
i.e., if <a href="#id29"><span class="problematic" id="id30">vertices_</span></a>.cols() == 0. This includes the zero-dimensional
case. If <a href="#id31"><span class="problematic" id="id32">vertices_</span></a>.rows() == 0 but <a href="#id33"><span class="problematic" id="id34">vertices_</span></a>.cols() &gt; 0, we treat this
as having one or more copies of 0 in the zero-dimensional vector space
{0}. If <a href="#id35"><span class="problematic" id="id36">vertices_</span></a>.rows() and <a href="#id37"><span class="problematic" id="id38">vertices_</span></a>.cols() are zero, we treat this
as no points in {0}, which is empty.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VPolytope.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.geometry.optimization.VPolytope) -&gt; None</p></li>
</ol>
<p>Constructs a set with no vertices in the zero-dimensional space, which
is empty (by convention).</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.geometry.optimization.VPolytope, vertices: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous]) -&gt; None</p></li>
</ol>
<p>Constructs the polytope from a d-by-n matrix, where d is the ambient
dimension, and n is the number of vertices. The vertices do not have
to be ordered, nor minimal (they can contain points inside their
convex hull).</p>
<ol class="arabic simple" start="3">
<li><p>__init__(self: pydrake.geometry.optimization.VPolytope, H: pydrake.geometry.optimization.HPolyhedron, tol: float = 1e-09) -&gt; None</p></li>
</ol>
<p>Constructs the polytope from a bounded polyhedron (using Qhull). If
the HPolyhedron is not full-dimensional, we perform computations in a
coordinate system of its affine hull. <code class="docutils literal notranslate"><span class="pre">tol</span></code> specifies the numerical
tolerance used in the computation of the affine hull. See the
documentation of AffineSubspace for more details. A loose tolerance is
necessary for the built-in solvers, but a tighter tolerance can be
used with commercial solvers (e.g. Gurobi and Mosek).</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if H is unbounded</strong><strong> or </strong><strong>if Qhull terminates with an</strong> – </p></li>
<li><p><strong>error.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="4">
<li><p>__init__(self: pydrake.geometry.optimization.VPolytope, query_object: pydrake.geometry.QueryObject, geometry_id: pydrake.geometry.GeometryId, reference_frame: Optional[pydrake.geometry.FrameId] = None) -&gt; None</p></li>
</ol>
<p>Constructs the polytope from a SceneGraph geometry.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VPolytope.GetMinimalRepresentation(self:</span> <span class="pre">pydrake.geometry.optimization.VPolytope,</span> <span class="pre">tol:</span> <span class="pre">float</span> <span class="pre">=</span> <span class="pre">1e-09)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.geometry.optimization.VPolytope</span></span></dt>
<dd><p>Creates a new VPolytope whose vertices are guaranteed to be minimal,
i.e., if we remove any point from its vertices, then the convex hull
of the remaining vertices is a strict subset of the polytope. In the
2D case the vertices of the new VPolytope are ordered
counter-clockwise from the negative X axis. For all other cases an
order is not guaranteed. If the VPolytope is not full-dimensional, we
perform computations in a coordinate system of its affine hull.
<code class="docutils literal notranslate"><span class="pre">tol</span></code> specifies the numerical tolerance used in the computation of
the affine hull.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VPolytope.MakeBox(lb:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]],</span> <span class="pre">ub:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.geometry.optimization.VPolytope</span></span></dt>
<dd><p>Constructs a polyhedron as an axis-aligned box from the lower and
upper corners.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VPolytope.MakeUnitBox(dim:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.geometry.optimization.VPolytope</span></span></dt>
<dd><p>Constructs the L∞-norm unit box in <code class="docutils literal notranslate"><span class="pre">dim</span></code> dimensions, {x | <a href="#id17"><span class="problematic" id="id18">|</span></a>x|∞ &lt;= 1
}. This is an axis-aligned box, centered at the origin, with edge
length 2.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VPolytope.ToShapeConvex(self:</span> <span class="pre">pydrake.geometry.optimization.VPolytope,</span> <span class="pre">convex_label:</span> <span class="pre">str</span> <span class="pre">=</span> <span class="pre">'convex_from_vpolytope')</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.geometry.Convex</span></span></dt>
<dd><p>Creates a geometry::Convex shape using the vertices of this VPolytope.
The convex_label is passed as the ‘label’ of the Convex object.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>ambient_dimension() == 3.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VPolytope.vertices(self:</span> <span class="pre">pydrake.geometry.optimization.VPolytope)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n]]</span></span></dt>
<dd><p>Returns the vertices in a d-by-n matrix, where d is the ambient
dimension, and n is the number of vertices.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VPolytope.WriteObj(self:</span> <span class="pre">pydrake.geometry.optimization.VPolytope,</span> <span class="pre">filename:</span> <span class="pre">os.PathLike)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Uses qhull to compute the Delaunay triangulation and then writes the
vertices and faces to <code class="docutils literal notranslate"><span class="pre">filename</span></code> in the Wavefront Obj format. Note
that the extension <code class="docutils literal notranslate"><span class="pre">.obj</span></code> is not automatically added to the
<code class="docutils literal notranslate"><span class="pre">filename</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>ambient_dimension() == 3.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="pydrake.geometry.all.html" class="btn btn-neutral float-left" title="pydrake.geometry.all" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="pydrake.gym.html" class="btn btn-neutral float-right" title="pydrake.gym" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p></p>
  </div>

  
</footer>
<script>
  /* Enables clicking for the mobile "hamburger" (three-line) menu item. */
  const siteHeader = document.querySelector('.site-header')
  const mobileButton = document.querySelector('.menu-mobile-toggle')
  const body = document.querySelector('body')

  mobileButton.addEventListener('click', function(event) {
    siteHeader.classList.toggle('open');
    body.classList.toggle('overflow-hidden');
  })
</script>
<footer class="site-footer padding">
  <div class="contain">
    <a href="/" class="drake-logo">
      <img src="/images/drake-logo.svg">
    </a>
    <div class="footer-menu">
      <ul>
        <li>
          <a href="/doxygen_cxx/index.html" class="site-menu-item">C++</a>
        </li>
        <li>
          <a href="/pydrake/index.html" class="site-menu-item">Python</a>
        </li>
        <li class="github-link">
          <a href="https://github.com/RobotLocomotion/drake" class="site-menu-item">GitHub <img src="/third_party/images/GitHub-Mark-64px.png"></a>
        </li>
      </ul>
    </div>
  </div>


</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>