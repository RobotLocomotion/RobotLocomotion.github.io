

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>pydrake.geometry.optimization &mdash; pydrake  documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="_static/css/custom.css" type="text/css" />
  

  
        <link rel="index" title="Index"
              href="genindex.html"/>
        <link rel="search" title="Search" href="search.html"/>
    <link rel="top" title="pydrake  documentation" href="index.html"/>
        <link rel="up" title="pydrake.geometry" href="pydrake.geometry.html"/>
        <link rel="next" title="pydrake.geometry.render" href="pydrake.geometry.render.html"/>
        <link rel="prev" title="pydrake.geometry.all" href="pydrake.geometry.all.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> pydrake
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="pydrake.all.html">pydrake.all</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.autodiffutils.html">pydrake.autodiffutils</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.common.html">pydrake.common</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.examples.html">pydrake.examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.forwarddiff.html">pydrake.forwarddiff</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="pydrake.geometry.html">pydrake.geometry</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="pydrake.geometry.all.html">pydrake.geometry.all</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">pydrake.geometry.optimization</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.geometry.render.html">pydrake.geometry.render</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.lcm.html">pydrake.lcm</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.manipulation.html">pydrake.manipulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.math.html">pydrake.math</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.multibody.html">pydrake.multibody</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.perception.html">pydrake.perception</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.polynomial.html">pydrake.polynomial</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.solvers.html">pydrake.solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.symbolic.html">pydrake.symbolic</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.systems.html">pydrake.systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.trajectories.html">pydrake.trajectories</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.visualization.html">pydrake.visualization</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">pydrake</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
          <li><a href="pydrake.geometry.html">pydrake.geometry</a> &raquo;</li>
        
      <li>pydrake.geometry.optimization</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="module-pydrake.geometry.optimization">
<span id="pydrake-geometry-optimization"></span><h1>pydrake.geometry.optimization<a class="headerlink" href="#module-pydrake.geometry.optimization" title="Permalink to this headline">¶</a></h1>
<p>Local bindings for <cite>drake::geometry::optimization</cite></p>
<dl class="class">
<dt id="pydrake.geometry.optimization.CartesianProduct">
<em class="property">class </em><code class="descclassname">pydrake.geometry.optimization.</code><code class="descname">CartesianProduct</code><a class="headerlink" href="#pydrake.geometry.optimization.CartesianProduct" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.geometry.optimization.ConvexSet" title="pydrake.geometry.optimization.ConvexSet"><code class="xref py py-class docutils literal"><span class="pre">pydrake.geometry.optimization.ConvexSet</span></code></a></p>
<p>The Cartesian product of convex sets is a convex set: S = X₁ × X₂ × ⋯
× Xₙ = {(x₁, x₂, …, xₙ) | x₁ ∈ X₁, x₂ ∈ X₂, …, xₙ ∈ Xₙ} We
currently require the sets X to be bounded.</p>
<p>This class also supports a generalization of this concept in which the
coordinates are transformed by the linear map, {x | y = Ax + b, y ∈ Y₁
× Y₂ × ⋯ × Yₙ}, with the default values set to the identity map. This
concept is required for reasoning about cylinders in arbitrary poses
as cartesian products, and more generally for describing any affine
transform of a CartesianProduct.</p>
<dl class="method">
<dt id="pydrake.geometry.optimization.CartesianProduct.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.geometry.optimization.CartesianProduct.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.geometry.optimization.CartesianProduct, sets: List[pydrake.geometry.optimization.CopyableUniquePtrConvexSet]) -&gt; None</li>
</ol>
<p>Constructs the product from a vector of convex sets. All of the sets
must be bounded.</p>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.geometry.optimization.CartesianProduct, setA: pydrake.geometry.optimization.ConvexSet, setB: pydrake.geometry.optimization.ConvexSet) -&gt; None</li>
</ol>
<p>Constructs the product from a pair of convex sets. <code class="docutils literal"><span class="pre">setA</span></code> and
<code class="docutils literal"><span class="pre">setB</span></code> must be bounded.</p>
<ol class="arabic simple" start="3">
<li>__init__(self: pydrake.geometry.optimization.CartesianProduct, sets: List[pydrake.geometry.optimization.CopyableUniquePtrConvexSet], A: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], b: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</li>
</ol>
<p>Constructs the product of convex sets in the transformed coordinates:
{x | y = Ax + b, y ∈ Y₁ × Y₂ × ⋯ × Yₙ}. <code class="docutils literal"><span class="pre">A</span></code> must be full column
rank, and all of the sets must be bounded.</p>
<ol class="arabic simple" start="4">
<li>__init__(self: pydrake.geometry.optimization.CartesianProduct, query_object: pydrake.geometry.QueryObject_[float], geometry_id: pydrake.geometry.GeometryId, reference_frame: Optional[pydrake.geometry.FrameId] = None) -&gt; None</li>
</ol>
<p>Constructs a CartesianProduct from a SceneGraph geometry and pose in
the <code class="docutils literal"><span class="pre">reference_frame</span></code> frame, obtained via the QueryObject. If
<code class="docutils literal"><span class="pre">reference_frame</span></code> frame is std::nullopt, then it will be expressed
in the world frame.</p>
<p>Although any geometry that can be used as a ConvexSet could also be a
(trivial) CartesianProduct, we restrict this constructor to handling
Cylinder geometry, which constructs the (non-trivial) Cartesian
product of a HyperEllipsoid and an HPolyhedron. Most other SceneGraph
geometry types are supported by at least one of the ConvexSet class
constructors.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if geometry_id does not correspond to a Cylinder.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.CartesianProduct.factor">
<code class="descname">factor</code><span class="sig-paren">(</span><em>self: pydrake.geometry.optimization.CartesianProduct</em>, <em>index: int</em><span class="sig-paren">)</span> &#x2192; pydrake.geometry.optimization.ConvexSet<a class="headerlink" href="#pydrake.geometry.optimization.CartesianProduct.factor" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a reference to the ConvexSet defining the <code class="docutils literal"><span class="pre">index</span></code> factor in
the product.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.CartesianProduct.num_factors">
<code class="descname">num_factors</code><span class="sig-paren">(</span><em>self: pydrake.geometry.optimization.CartesianProduct</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.geometry.optimization.CartesianProduct.num_factors" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of factors (or sets) used in the product.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.geometry.optimization.ConvexSet">
<em class="property">class </em><code class="descclassname">pydrake.geometry.optimization.</code><code class="descname">ConvexSet</code><a class="headerlink" href="#pydrake.geometry.optimization.ConvexSet" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract base class for defining a convex set.</p>
<dl class="attribute">
<dt id="pydrake.geometry.optimization.ConvexSet.__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.geometry.optimization.ConvexSet.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.ConvexSet.AddPointInNonnegativeScalingConstraints">
<code class="descname">AddPointInNonnegativeScalingConstraints</code><span class="sig-paren">(</span><em>self: pydrake.geometry.optimization.ConvexSet, prog: drake::solvers::MathematicalProgram, x: numpy.ndarray[object[m, 1]], t: pydrake.symbolic.Variable</em><span class="sig-paren">)</span> &#x2192; List[drake::solvers::Binding&lt;drake::solvers::Constraint&gt;]<a class="headerlink" href="#pydrake.geometry.optimization.ConvexSet.AddPointInNonnegativeScalingConstraints" title="Permalink to this definition">¶</a></dt>
<dd><p>Let S be this convex set. When S is bounded, this method adds the
convex constraints to imply</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>x ∈ t S,
t ≥ 0,
</pre></div>
</div>
<p>where x is a point in ℜⁿ (with n the ambient_dimension) and t is a
scalar.</p>
<p>When S is unbounded, then the behavior is almost identical, except
when t=0. In this case, the constraints imply t ≥ 0, x ∈ t S ⊕ rec(S),
where rec(S) is the recession cone of S (the asymptotic directions in
which S is not bounded) and ⊕ is the Minkowski sum. For t &gt; 0, this is
equivalent to x ∈ t S, but for t = 0, we have only x ∈ rec(S).</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.ConvexSet.AddPointInSetConstraints">
<code class="descname">AddPointInSetConstraints</code><span class="sig-paren">(</span><em>self: pydrake.geometry.optimization.ConvexSet, prog: drake::solvers::MathematicalProgram, vars: numpy.ndarray[object[m, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.geometry.optimization.ConvexSet.AddPointInSetConstraints" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a constraint to an existing MathematicalProgram enforcing that
the point defined by vars is inside the set.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.ConvexSet.ambient_dimension">
<code class="descname">ambient_dimension</code><span class="sig-paren">(</span><em>self: pydrake.geometry.optimization.ConvexSet</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.geometry.optimization.ConvexSet.ambient_dimension" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the dimension of the vector space in which the elements of
this set are evaluated. Contrast this with the <code class="docutils literal"><span class="pre">affine</span> <span class="pre">dimension</span></code>:
the dimension of the smallest affine subset of the ambient space that
contains our set. For example, if we define a set using <code class="docutils literal"><span class="pre">A*x</span> <span class="pre">=</span> <span class="pre">b</span></code>,
where <code class="docutils literal"><span class="pre">A</span></code> has linearly independent rows, then the ambient dimension
is the dimension of <code class="docutils literal"><span class="pre">x</span></code>, but the affine dimension of the set is
<code class="docutils literal"><span class="pre">ambient_dimension()</span> <span class="pre">-</span> <span class="pre">rank(A)</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.ConvexSet.Clone">
<code class="descname">Clone</code><span class="sig-paren">(</span><em>self: pydrake.geometry.optimization.ConvexSet</em><span class="sig-paren">)</span> &#x2192; pydrake.geometry.optimization.ConvexSet<a class="headerlink" href="#pydrake.geometry.optimization.ConvexSet.Clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a unique deep copy of this set.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.ConvexSet.IsBounded">
<code class="descname">IsBounded</code><span class="sig-paren">(</span><em>self: pydrake.geometry.optimization.ConvexSet</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.geometry.optimization.ConvexSet.IsBounded" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true iff the set is bounded, e.g. there exists an element-wise
finite lower and upper bound for the set. Note: for some derived
classes, this check is trivial, but for others it can require solving
an (typically small) optimization problem. Check the derived class
documentation for any notes.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.ConvexSet.PointInSet">
<code class="descname">PointInSet</code><span class="sig-paren">(</span><em>self: pydrake.geometry.optimization.ConvexSet, x: numpy.ndarray[numpy.float64[m, 1]], tol: float = 1e-08</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.geometry.optimization.ConvexSet.PointInSet" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true iff the point x is contained in the set.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.ConvexSet.ToShapeWithPose">
<code class="descname">ToShapeWithPose</code><span class="sig-paren">(</span><em>self: pydrake.geometry.optimization.ConvexSet</em><span class="sig-paren">)</span> &#x2192; Tuple[pydrake.geometry.Shape, pydrake.math.RigidTransform_[float]]<a class="headerlink" href="#pydrake.geometry.optimization.ConvexSet.ToShapeWithPose" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs a Shape and a pose of the set in the world frame for use in
the SceneGraph geometry ecosystem.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if ambient_dimension() != 3 or if the functionality</li>
<li>for a particular set has not been implemented yet.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.geometry.optimization.CopyableUniquePtrConvexSet">
<em class="property">class </em><code class="descclassname">pydrake.geometry.optimization.</code><code class="descname">CopyableUniquePtrConvexSet</code><a class="headerlink" href="#pydrake.geometry.optimization.CopyableUniquePtrConvexSet" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="pydrake.geometry.optimization.CopyableUniquePtrConvexSet.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.geometry.optimization.CopyableUniquePtrConvexSet</em>, <em>arg0: pydrake.geometry.optimization.ConvexSet</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.geometry.optimization.CopyableUniquePtrConvexSet.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.geometry.optimization.HPolyhedron">
<em class="property">class </em><code class="descclassname">pydrake.geometry.optimization.</code><code class="descname">HPolyhedron</code><a class="headerlink" href="#pydrake.geometry.optimization.HPolyhedron" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.geometry.optimization.ConvexSet" title="pydrake.geometry.optimization.ConvexSet"><code class="xref py py-class docutils literal"><span class="pre">pydrake.geometry.optimization.ConvexSet</span></code></a></p>
<p>Implements a polyhedral convex set using the half-space
representation: <code class="docutils literal"><span class="pre">{x|</span> <span class="pre">A</span> <span class="pre">x</span> <span class="pre">≤</span> <span class="pre">b}</span></code>. Note: This set may be unbounded.</p>
<dl class="method">
<dt id="pydrake.geometry.optimization.HPolyhedron.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.geometry.optimization.HPolyhedron.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.geometry.optimization.HPolyhedron, A: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], b: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</li>
</ol>
<p>Constructs the polyhedron.</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd>A.rows() == b.size().</dd>
</dl>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.geometry.optimization.HPolyhedron, query_object: pydrake.geometry.QueryObject_[float], geometry_id: pydrake.geometry.GeometryId, reference_frame: Optional[pydrake.geometry.FrameId] = None) -&gt; None</li>
</ol>
<p>Constructs a new HPolyhedron from a SceneGraph geometry and pose in
the <code class="docutils literal"><span class="pre">reference_frame</span></code> frame, obtained via the QueryObject. If
<code class="docutils literal"><span class="pre">reference_frame</span></code> frame is std::nullopt, then it will be expressed
in the world frame.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError the geometry is not a convex polytope.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.HPolyhedron.A">
<code class="descname">A</code><span class="sig-paren">(</span><em>self: pydrake.geometry.optimization.HPolyhedron</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, n]]<a class="headerlink" href="#pydrake.geometry.optimization.HPolyhedron.A" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the half-space representation matrix A.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.HPolyhedron.b">
<code class="descname">b</code><span class="sig-paren">(</span><em>self: pydrake.geometry.optimization.HPolyhedron</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.geometry.optimization.HPolyhedron.b" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the half-space representation vector b.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.HPolyhedron.ChebyshevCenter">
<code class="descname">ChebyshevCenter</code><span class="sig-paren">(</span><em>self: pydrake.geometry.optimization.HPolyhedron</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.geometry.optimization.HPolyhedron.ChebyshevCenter" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves a linear program to compute the center of the largest inscribed
ball in the polyhedron. This is often the recommended way to find some
interior point of the set, for example, as a step towards computing
the convex hull or a vertex-representation of the set.</p>
<p>Note that the Chebyshev center is not necessarily unique, and may not
conform to the point that one might consider the “visual center” of
the set. For example, for a long thin rectangle, any point in the
center line segment illustrated below would be a valid center point.
The solver may return any point on that line segment.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>┌──────────────────────────────────┐
│                                  │
│   ────────────────────────────   │
│                                  │
└──────────────────────────────────┘
</pre></div>
</div>
<p>To find the visual center, consider using the more expensive
MaximumVolumeInscribedEllipsoid() method, and then taking the center
of the returned Hyperellipsoid.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the solver fails to solve the problem.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.geometry.optimization.HPolyhedron.MakeBox">
<em class="property">static </em><code class="descname">MakeBox</code><span class="sig-paren">(</span><em>lb: numpy.ndarray[numpy.float64[m, 1]], ub: numpy.ndarray[numpy.float64[m, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.geometry.optimization.HPolyhedron<a class="headerlink" href="#pydrake.geometry.optimization.HPolyhedron.MakeBox" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs a polyhedron as an axis-aligned box from the lower and
upper corners.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.geometry.optimization.HPolyhedron.MakeUnitBox">
<em class="property">static </em><code class="descname">MakeUnitBox</code><span class="sig-paren">(</span><em>dim: int</em><span class="sig-paren">)</span> &#x2192; pydrake.geometry.optimization.HPolyhedron<a class="headerlink" href="#pydrake.geometry.optimization.HPolyhedron.MakeUnitBox" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs the L∞-norm unit box in <code class="docutils literal"><span class="pre">dim</span></code> dimensions, {x | <a href="#id1"><span class="problematic" id="id2">|</span></a>x|∞ &lt;= 1
}. This is an axis-aligned box, centered at the origin, with edge
length 2.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.HPolyhedron.MaximumVolumeInscribedEllipsoid">
<code class="descname">MaximumVolumeInscribedEllipsoid</code><span class="sig-paren">(</span><em>self: pydrake.geometry.optimization.HPolyhedron</em><span class="sig-paren">)</span> &#x2192; drake::geometry::optimization::Hyperellipsoid<a class="headerlink" href="#pydrake.geometry.optimization.HPolyhedron.MaximumVolumeInscribedEllipsoid" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves a semi-definite program to compute the inscribed ellipsoid.
From Section 8.4.2 in Boyd and Vandenberghe, 2004, we solve</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>max_{C,d} log det (C)
s.t. |aᵢC|₂ ≤ bᵢ - aᵢd, ∀i
C ≽ 0
</pre></div>
</div>
<p>where aᵢ and bᵢ denote the ith row. This defines the ellipsoid E = {
Cx + d | <a href="#id3"><span class="problematic" id="id4">|</span></a>x|₂ ≤ 1}.</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd>the HPolyhedron is bounded.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the solver fails to solve the problem.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.geometry.optimization.Hyperellipsoid">
<em class="property">class </em><code class="descclassname">pydrake.geometry.optimization.</code><code class="descname">Hyperellipsoid</code><a class="headerlink" href="#pydrake.geometry.optimization.Hyperellipsoid" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.geometry.optimization.ConvexSet" title="pydrake.geometry.optimization.ConvexSet"><code class="xref py py-class docutils literal"><span class="pre">pydrake.geometry.optimization.ConvexSet</span></code></a></p>
<p>Implements an ellipsoidal convex set represented by the quadratic form
<code class="docutils literal"><span class="pre">{x</span> <span class="pre">|</span> <span class="pre">(x-center)ᵀAᵀA(x-center)</span> <span class="pre">≤</span> <span class="pre">1}</span></code>. Note that <code class="docutils literal"><span class="pre">A</span></code> need not be
square; we require only that the matrix AᵀA is positive semi-definite.</p>
<p>Compare this with an alternative (very useful) parameterization of the
ellipsoid: <code class="docutils literal"><span class="pre">{Bu</span> <span class="pre">+</span> <span class="pre">center</span> <span class="pre">|</span> <span class="pre">|u|₂</span> <span class="pre">≤</span> <span class="pre">1}</span></code>, which is an affine scaling of
the unit ball. This is related to the quadratic form by <code class="docutils literal"><span class="pre">B</span> <span class="pre">=</span> <span class="pre">A⁻¹</span></code>,
when <code class="docutils literal"><span class="pre">A</span></code> is invertible, but the quadratic form can also represent
unbounded sets.</p>
<p>Note: the name Hyperellipsoid was taken here to avoid conflicting with
geometry::Ellipsoid and to distinguish that this class supports N
dimensions.</p>
<dl class="method">
<dt id="pydrake.geometry.optimization.Hyperellipsoid.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.geometry.optimization.Hyperellipsoid.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.geometry.optimization.Hyperellipsoid, A: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], center: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</li>
</ol>
<p>Constructs the ellipsoid.</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd>A.cols() == center.size().</dd>
</dl>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.geometry.optimization.Hyperellipsoid, query_object: pydrake.geometry.QueryObject_[float], geometry_id: pydrake.geometry.GeometryId, reference_frame: Optional[pydrake.geometry.FrameId] = None) -&gt; None</li>
</ol>
<p>Constructs a Hyperellipsoid from a SceneGraph geometry and pose in the
<code class="docutils literal"><span class="pre">reference_frame</span></code> frame, obtained via the QueryObject. If
<code class="docutils literal"><span class="pre">reference_frame</span></code> frame is std::nullopt, then it will be expressed
in the world frame.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if geometry_id does not represent a shape that can be</li>
<li>described as an Hyperellipsoid.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.Hyperellipsoid.A">
<code class="descname">A</code><span class="sig-paren">(</span><em>self: pydrake.geometry.optimization.Hyperellipsoid</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, n]]<a class="headerlink" href="#pydrake.geometry.optimization.Hyperellipsoid.A" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the quadratic form matrix A.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.Hyperellipsoid.center">
<code class="descname">center</code><span class="sig-paren">(</span><em>self: pydrake.geometry.optimization.Hyperellipsoid</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.geometry.optimization.Hyperellipsoid.center" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the center of the ellipsoid.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.geometry.optimization.Hyperellipsoid.MakeAxisAligned">
<em class="property">static </em><code class="descname">MakeAxisAligned</code><span class="sig-paren">(</span><em>radius: numpy.ndarray[numpy.float64[m, 1]], center: numpy.ndarray[numpy.float64[m, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.geometry.optimization.Hyperellipsoid<a class="headerlink" href="#pydrake.geometry.optimization.Hyperellipsoid.MakeAxisAligned" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs the an axis-aligned Hyperellipsoid with the implicit form
(x₀-c₀)²/r₀² + (x₁-c₁)²/r₁² + … + (x_N - c_N)²/r_N² ≤ 1, where c is
shorthand for <code class="docutils literal"><span class="pre">center</span></code> and r is shorthand for <code class="docutils literal"><span class="pre">radius</span></code>.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.geometry.optimization.Hyperellipsoid.MakeHypersphere">
<em class="property">static </em><code class="descname">MakeHypersphere</code><span class="sig-paren">(</span><em>radius: float, center: numpy.ndarray[numpy.float64[m, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.geometry.optimization.Hyperellipsoid<a class="headerlink" href="#pydrake.geometry.optimization.Hyperellipsoid.MakeHypersphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs a hypersphere with <code class="docutils literal"><span class="pre">radius</span></code> and <code class="docutils literal"><span class="pre">center</span></code>.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.geometry.optimization.Hyperellipsoid.MakeUnitBall">
<em class="property">static </em><code class="descname">MakeUnitBall</code><span class="sig-paren">(</span><em>dim: int</em><span class="sig-paren">)</span> &#x2192; pydrake.geometry.optimization.Hyperellipsoid<a class="headerlink" href="#pydrake.geometry.optimization.Hyperellipsoid.MakeUnitBall" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs the L₂-norm unit ball in <code class="docutils literal"><span class="pre">dim</span></code> dimensions, {x | <a href="#id5"><span class="problematic" id="id6">|</span></a>x|₂ &lt;= 1
}.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.Hyperellipsoid.MinimumUniformScalingToTouch">
<code class="descname">MinimumUniformScalingToTouch</code><span class="sig-paren">(</span><em>self: pydrake.geometry.optimization.Hyperellipsoid</em>, <em>other: pydrake.geometry.optimization.ConvexSet</em><span class="sig-paren">)</span> &#x2192; Tuple[float, numpy.ndarray[numpy.float64[m, 1]]]<a class="headerlink" href="#pydrake.geometry.optimization.Hyperellipsoid.MinimumUniformScalingToTouch" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the smallest uniform scaling of this ellipsoid for which it
still intersects <code class="docutils literal"><span class="pre">other</span></code>. √ minₓ (x-center)ᵀAᵀA(x-center) s.t. x ∈
other. Note that if center ∈ other, then we expect scaling = 0 and x =
center (up to precision).</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd><code class="docutils literal"><span class="pre">other</span></code> must have the same ambient_dimension as this.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">the minimal scaling and the witness point, x, on other.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.Hyperellipsoid.Volume">
<code class="descname">Volume</code><span class="sig-paren">(</span><em>self: pydrake.geometry.optimization.Hyperellipsoid</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.geometry.optimization.Hyperellipsoid.Volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the volume of the hyperellipsoid (in Euclidean space).</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pydrake.geometry.optimization.Iris">
<code class="descclassname">pydrake.geometry.optimization.</code><code class="descname">Iris</code><span class="sig-paren">(</span><em>obstacles: List[pydrake.geometry.optimization.CopyableUniquePtrConvexSet], sample: numpy.ndarray[numpy.float64[m, 1]], domain: pydrake.geometry.optimization.HPolyhedron, options: pydrake.geometry.optimization.IrisOptions = &lt;pydrake.geometry.optimization.IrisOptions object at 0x7f4581970bb0&gt;</em><span class="sig-paren">)</span> &#x2192; pydrake.geometry.optimization.HPolyhedron<a class="headerlink" href="#pydrake.geometry.optimization.Iris" title="Permalink to this definition">¶</a></dt>
<dd><p>The IRIS (Iterative Region Inflation by Semidefinite programming)
algorithm, as described in</p>
<p>R. L. H. Deits and R. Tedrake, “Computing large convex regions of
obstacle-free space through semidefinite programming,” Workshop on the
Algorithmic Fundamentals of Robotics, Istanbul, Aug. 2014.
<a class="reference external" href="http://groups.csail.mit.edu/robotics-center/public_papers/Deits14.pdf">http://groups.csail.mit.edu/robotics-center/public_papers/Deits14.pdf</a></p>
<p>This algorithm attempts to locally maximize the volume of a convex
polytope representing obstacle-free space given a sample point and
list of convex obstacles. Rather than compute the volume of the
polytope directly, the algorithm maximizes the volume of an inscribed
ellipsoid. It alternates between finding separating hyperplanes
between the ellipsoid and the obstacles and then finding a new
maximum-volume inscribed ellipsoid.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">obstacles</span></code>:</dt>
<dd>is a vector of convex sets representing the occupied space.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">sample</span></code>:</dt>
<dd>provides a point in the space; the algorithm is initialized using
a tiny sphere around this point. The algorithm is only guaranteed
to succeed if this sample point is collision free (outside of all
obstacles), but in practice the algorithm can often escape bad
initialization (assuming the require_sample_point_is_contained
option is false).</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">domain</span></code>:</dt>
<dd>describes the total region of interest; computed IRIS regions will
be inside this domain. It must be bounded, and is typically a
simple bounding box (e.g. from HPolyhedron::MakeBox).</dd>
</dl>
<p>The <code class="docutils literal"><span class="pre">obstacles</span></code>, <code class="docutils literal"><span class="pre">sample</span></code>, and the <code class="docutils literal"><span class="pre">domain</span></code> must describe
elements in the same ambient dimension (but that dimension can be any
positive integer).</p>
</dd></dl>

<dl class="class">
<dt id="pydrake.geometry.optimization.IrisOptions">
<em class="property">class </em><code class="descclassname">pydrake.geometry.optimization.</code><code class="descname">IrisOptions</code><a class="headerlink" href="#pydrake.geometry.optimization.IrisOptions" title="Permalink to this definition">¶</a></dt>
<dd><p>Configuration options for the IRIS algorithm.</p>
<dl class="method">
<dt id="pydrake.geometry.optimization.IrisOptions.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.geometry.optimization.IrisOptions</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.geometry.optimization.IrisOptions.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.geometry.optimization.IrisOptions.iteration_limit">
<code class="descname">iteration_limit</code><a class="headerlink" href="#pydrake.geometry.optimization.IrisOptions.iteration_limit" title="Permalink to this definition">¶</a></dt>
<dd><p>Maximum number of iterations.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.geometry.optimization.IrisOptions.require_sample_point_is_contained">
<code class="descname">require_sample_point_is_contained</code><a class="headerlink" href="#pydrake.geometry.optimization.IrisOptions.require_sample_point_is_contained" title="Permalink to this definition">¶</a></dt>
<dd><p>The initial polytope is guaranteed to contain the point if that point
is collision-free. However, the IRIS alternation objectives do not
include (and can not easily include) a constraint that the original
sample point is contained. Therefore, the IRIS paper recommends that
if containment is a requirement, then the algorithm should simply
terminate early if alternations would ever cause the set to not
contain the point.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.geometry.optimization.IrisOptions.termination_threshold">
<code class="descname">termination_threshold</code><a class="headerlink" href="#pydrake.geometry.optimization.IrisOptions.termination_threshold" title="Permalink to this definition">¶</a></dt>
<dd><p>IRIS will terminate if the change in the <em>volume</em> of the
hyperellipsoid between iterations is less that this threshold.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pydrake.geometry.optimization.MakeIrisObstacles">
<code class="descclassname">pydrake.geometry.optimization.</code><code class="descname">MakeIrisObstacles</code><span class="sig-paren">(</span><em>query_object: pydrake.geometry.QueryObject_[float], reference_frame: Optional[pydrake.geometry.FrameId] = None</em><span class="sig-paren">)</span> &#x2192; List[pydrake.geometry.optimization.CopyableUniquePtrConvexSet]<a class="headerlink" href="#pydrake.geometry.optimization.MakeIrisObstacles" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs ConvexSet representations of obstacles for IRIS in 3D using
the geometry from a SceneGraph QueryObject. All geometry in the scene
with a proximity role, both anchored and dynamic, are consider to be
<em>fixed</em> obstacles frozen in the poses captured in the context used to
create the QueryObject.</p>
<p>When multiple representations are available for a particular geometry
(e.g. a Box can be represented as either an HPolyhedron or a
VPolytope), then this method will prioritize the representation that
we expect is most performant for the current implementation of the
IRIS algorithm.</p>
</dd></dl>

<dl class="class">
<dt id="pydrake.geometry.optimization.MinkowskiSum">
<em class="property">class </em><code class="descclassname">pydrake.geometry.optimization.</code><code class="descname">MinkowskiSum</code><a class="headerlink" href="#pydrake.geometry.optimization.MinkowskiSum" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.geometry.optimization.ConvexSet" title="pydrake.geometry.optimization.ConvexSet"><code class="xref py py-class docutils literal"><span class="pre">pydrake.geometry.optimization.ConvexSet</span></code></a></p>
<p>A convex set that represents the Minkowski sum of multiple sets: S =
X₁ ⨁ X₂ ⨁ … ⨁ Xₙ = {x₁ + x₂ + … + xₙ | x₁ ∈ X₁, x₂ ∈ X₂, …, xₙ ∈
Xₙ}</p>
<dl class="method">
<dt id="pydrake.geometry.optimization.MinkowskiSum.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.geometry.optimization.MinkowskiSum.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.geometry.optimization.MinkowskiSum, sets: List[pydrake.geometry.optimization.CopyableUniquePtrConvexSet]) -&gt; None</li>
</ol>
<p>Constructs the sum from a vector of convex sets.</p>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.geometry.optimization.MinkowskiSum, setA: pydrake.geometry.optimization.ConvexSet, setB: pydrake.geometry.optimization.ConvexSet) -&gt; None</li>
</ol>
<p>Constructs the sum from a pair of convex sets.</p>
<ol class="arabic simple" start="3">
<li>__init__(self: pydrake.geometry.optimization.MinkowskiSum, query_object: pydrake.geometry.QueryObject_[float], geometry_id: pydrake.geometry.GeometryId, reference_frame: Optional[pydrake.geometry.FrameId] = None) -&gt; None</li>
</ol>
<p>Constructs a MinkowskiSum from a SceneGraph geometry and pose in the
<code class="docutils literal"><span class="pre">reference_frame</span></code> frame, obtained via the QueryObject. If
<code class="docutils literal"><span class="pre">reference_frame</span></code> frame is std::nullopt, then it will be expressed
in the world frame.</p>
<p>Although in principle a MinkowskiSum can represent any ConvexSet as
the sum of a single set, here we only support Capsule geometry, which
will be represented as the (non-trivial) Minkowski sum of a sphere
with a line segment. Most SceneGraph geometry types are supported by
at least one of the ConvexSet class constructors.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if geometry_id does not correspond to a Capsule.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.MinkowskiSum.num_terms">
<code class="descname">num_terms</code><span class="sig-paren">(</span><em>self: pydrake.geometry.optimization.MinkowskiSum</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.geometry.optimization.MinkowskiSum.num_terms" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of terms (or sets) used in the sum.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.MinkowskiSum.term">
<code class="descname">term</code><span class="sig-paren">(</span><em>self: pydrake.geometry.optimization.MinkowskiSum</em>, <em>index: int</em><span class="sig-paren">)</span> &#x2192; pydrake.geometry.optimization.ConvexSet<a class="headerlink" href="#pydrake.geometry.optimization.MinkowskiSum.term" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a reference to the ConvexSet defining the <code class="docutils literal"><span class="pre">index</span></code> term in
the sum.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.geometry.optimization.Point">
<em class="property">class </em><code class="descclassname">pydrake.geometry.optimization.</code><code class="descname">Point</code><a class="headerlink" href="#pydrake.geometry.optimization.Point" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.geometry.optimization.ConvexSet" title="pydrake.geometry.optimization.ConvexSet"><code class="xref py py-class docutils literal"><span class="pre">pydrake.geometry.optimization.ConvexSet</span></code></a></p>
<p>A convex set that contains exactly one element. Also known as a
singleton or unit set.</p>
<dl class="method">
<dt id="pydrake.geometry.optimization.Point.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.geometry.optimization.Point.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.geometry.optimization.Point, x: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</li>
</ol>
<p>Constructs a Point.</p>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.geometry.optimization.Point, query_object: pydrake.geometry.QueryObject_[float], geometry_id: pydrake.geometry.GeometryId, reference_frame: Optional[pydrake.geometry.FrameId] = None, maximum_allowable_radius: float = 0.0) -&gt; None</li>
</ol>
<p>Constructs a Point from a SceneGraph geometry and pose in the
<code class="docutils literal"><span class="pre">reference_frame</span></code> frame, obtained via the QueryObject. If
<code class="docutils literal"><span class="pre">reference_frame</span></code> frame is std::nullopt, then it will be expressed
in the world frame.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if geometry_id does not correspond to a Sphere or if</li>
<li>the Sphere has radius greater than <code class="docutils literal"><span class="pre">maximum_allowable_radius</span></code>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.Point.set_x">
<code class="descname">set_x</code><span class="sig-paren">(</span><em>self: pydrake.geometry.optimization.Point, x: numpy.ndarray[numpy.float64[m, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.geometry.optimization.Point.set_x" title="Permalink to this definition">¶</a></dt>
<dd><p>Changes the element <code class="docutils literal"><span class="pre">x</span></code> describing the set.</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd><code class="docutils literal"><span class="pre">x</span></code> must be of size ambient_dimension().</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.Point.x">
<code class="descname">x</code><span class="sig-paren">(</span><em>self: pydrake.geometry.optimization.Point</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.geometry.optimization.Point.x" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves the point.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.geometry.optimization.VPolytope">
<em class="property">class </em><code class="descclassname">pydrake.geometry.optimization.</code><code class="descname">VPolytope</code><a class="headerlink" href="#pydrake.geometry.optimization.VPolytope" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.geometry.optimization.ConvexSet" title="pydrake.geometry.optimization.ConvexSet"><code class="xref py py-class docutils literal"><span class="pre">pydrake.geometry.optimization.ConvexSet</span></code></a></p>
<p>A polytope described using the vertex representation. The set is
defined as the convex hull of the vertices. The vertices are not
guaranteed to be in any particular order, nor to be minimal (some
vertices could be strictly in the interior of the set).</p>
<p>Note: Unlike the half-space representation, this definition means the
set is always bounded (hence the name polytope, instead of
polyhedron).</p>
<dl class="method">
<dt id="pydrake.geometry.optimization.VPolytope.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.geometry.optimization.VPolytope.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.geometry.optimization.VPolytope, vertices: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous]) -&gt; None</li>
</ol>
<p>Constructs the polytope from a d-by-n matrix, where d is the ambient
dimension, and n is the number of vertices. The vertices do not have
to be ordered, nor minimal (they can contain points inside their
convex hull).</p>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.geometry.optimization.VPolytope, query_object: pydrake.geometry.QueryObject_[float], geometry_id: pydrake.geometry.GeometryId, reference_frame: Optional[pydrake.geometry.FrameId] = None) -&gt; None</li>
</ol>
<p>Construct the polytope from a SceneGraph geometry.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.geometry.optimization.VPolytope.MakeBox">
<em class="property">static </em><code class="descname">MakeBox</code><span class="sig-paren">(</span><em>lb: numpy.ndarray[numpy.float64[m, 1]], ub: numpy.ndarray[numpy.float64[m, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.geometry.optimization.VPolytope<a class="headerlink" href="#pydrake.geometry.optimization.VPolytope.MakeBox" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs a polyhedron as an axis-aligned box from the lower and
upper corners.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.geometry.optimization.VPolytope.MakeUnitBox">
<em class="property">static </em><code class="descname">MakeUnitBox</code><span class="sig-paren">(</span><em>dim: int</em><span class="sig-paren">)</span> &#x2192; pydrake.geometry.optimization.VPolytope<a class="headerlink" href="#pydrake.geometry.optimization.VPolytope.MakeUnitBox" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs the L∞-norm unit box in <code class="docutils literal"><span class="pre">dim</span></code> dimensions, {x | <a href="#id7"><span class="problematic" id="id8">|</span></a>x|∞ &lt;= 1
}. This is an axis-aligned box, centered at the origin, with edge
length 2.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.VPolytope.vertices">
<code class="descname">vertices</code><span class="sig-paren">(</span><em>self: pydrake.geometry.optimization.VPolytope</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, n]]<a class="headerlink" href="#pydrake.geometry.optimization.VPolytope.vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the vertices in a d-by-n matrix, where d is the ambient
dimension, and n is the number of vertices.</p>
</dd></dl>

</dd></dl>

</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="pydrake.geometry.render.html" class="btn btn-neutral float-right" title="pydrake.geometry.render" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="pydrake.geometry.all.html" class="btn btn-neutral" title="pydrake.geometry.all" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  false,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>