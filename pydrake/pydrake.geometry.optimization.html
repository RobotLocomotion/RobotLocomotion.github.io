<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>pydrake.geometry.optimization &mdash; pydrake  documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/custom.css" type="text/css" />
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="pydrake.gym" href="pydrake.gym.html" />
    <link rel="prev" title="pydrake.geometry.all" href="pydrake.geometry.all.html" /> 
</head>

<body class="wy-body-for-nav">
<header class="site-header">
  <div class="site-header-inner contain">
    <a class="drake-logo" href="/"><img src="/images/drake-logo-white.svg"></a>
    <div class="menu-mobile-toggle">
      <span></span>
    </div>
    <nav class="site-menu">
      <ul>
        <li class="site-menu-item site-menu-item-main">
          <a class="site-menu-item" href="/">Home</a>
        </li>
        <li class="site-menu-item site-menu-item-main">
          <a class="site-menu-item" href="/installation.html">Installation</a>
        </li>
        <li class="site-menu-item site-menu-item-main">
          <a class="site-menu-item" href="/gallery.html">Gallery</a>
        </li>
        <li class="site-menu-item site-menu-item-main">API Documentation
          <div class="sub">
            <a class="site-menu-item" href="/doxygen_cxx/index.html">C++</a> <a class="site-menu-item" href="/pydrake/index.html">Python</a>
          </div>
        </li>
        <li class="site-menu-item site-menu-item-main">Resources
          <div class="sub">
            <a class="site-menu-item" href="/getting_help.html">Getting Help</a> <a class="site-menu-item" href="https://deepnote.com/workspace/Drake-0b3b2c53-a7ad-441b-80f8-bf8350752305/project/Tutorials-2b4fc509-aef2-417d-a40d-6071dfed9199/%2Findex.ipynb">Tutorials</a> <a class="site-menu-item" href="/python_bindings.html">Python Bindings</a> <a class="site-menu-item" href="/developers.html">For Developers</a> <a class="site-menu-item" href="/credits.html">Credits</a>
          </div>
        </li>
        <li class="github-link">
          <a class="site-menu-item" href="https://github.com/RobotLocomotion/drake">GitHub <img src="/third_party/images/GitHub-Mark-Light-64px.png"></a>
        </li>
      </ul>
    </nav>
  </div>
</header>

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> pydrake
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search pydrake only…" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
  <form id="search_form" class="wy_form" action="https://google.com/search" method="get">
    <input type="text" name="q" placeholder="Search all of Drake…" />
    <input type="hidden" name="q" value="site:drake.mit.edu OR site:underactuated.csail.mit.edu OR site:manipulation.csail.mit.edu" />
  </form>
</div>

        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="pydrake.all.html">pydrake.all</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.autodiffutils.html">pydrake.autodiffutils</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.common.html">pydrake.common</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.examples.html">pydrake.examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.forwarddiff.html">pydrake.forwarddiff</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="pydrake.geometry.html">pydrake.geometry</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="pydrake.geometry.all.html">pydrake.geometry.all</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">pydrake.geometry.optimization</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.gym.html">pydrake.gym</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.lcm.html">pydrake.lcm</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.manipulation.html">pydrake.manipulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.math.html">pydrake.math</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.multibody.html">pydrake.multibody</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.perception.html">pydrake.perception</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.planning.html">pydrake.planning</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.polynomial.html">pydrake.polynomial</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.solvers.html">pydrake.solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.symbolic.html">pydrake.symbolic</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.systems.html">pydrake.systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.trajectories.html">pydrake.trajectories</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.tutorials.html">pydrake.tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.visualization.html">pydrake.visualization</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">pydrake</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="pydrake.geometry.html">pydrake.geometry</a> &raquo;</li>
      <li>pydrake.geometry.optimization</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="module-pydrake.geometry.optimization">
<span id="pydrake-geometry-optimization"></span><h1>pydrake.geometry.optimization<a class="headerlink" href="#module-pydrake.geometry.optimization" title="Permalink to this headline"></a></h1>
<p>Local bindings for <cite>drake::geometry::optimization</cite></p>
<dl class="py class">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.AffineBall">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.geometry.optimization.</span></span><span class="sig-name descname"><span class="pre">AffineBall</span></span><a class="headerlink" href="#pydrake.geometry.optimization.AffineBall" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.geometry.optimization.ConvexSet" title="pydrake.geometry.optimization.ConvexSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.geometry.optimization.ConvexSet</span></code></a></p>
<p>Implements an ellipsoidal convex set represented as an affine scaling
of the unit ball {Bu + center | <a href="#id1"><span class="problematic" id="id2">|</span></a>u|₂ ≤ 1}. B must be a square matrix.</p>
<p>Compare this with an alternative parametrization of the ellipsoid: {x
| (x-center)ᵀAᵀA(x-center) ≤ 1}, which utilizes a quadratic form. The
two representations are related by B = A⁻¹ if A and B are invertible.</p>
<p>The quadratic form parametrization is implemented in Hyperellipsoid.
It can represent unbounded sets, but not sets along a
lower-dimensional affine subspace. The AffineBall parametrization can
represent sets along a lower-dimensional affine subspace, but not
unbounded sets.</p>
<p>An AffineBall can never be empty – it always contains its center.
This includes the zero-dimensional case.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.AffineBall.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.geometry.optimization.AffineBall.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.geometry.optimization.AffineBall) -&gt; None</p></li>
</ol>
<p>Constructs a default (zero-dimensional, nonempty) set.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.geometry.optimization.AffineBall, B: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], center: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</p></li>
</ol>
<p>Constructs the ellipsoid from a transformation matrix B and
translation center. B describes the linear transformation that is
applied to the unit ball in order to produce the ellipsoid, and center
describes the translation of the center of the ellipsoid from the
origin.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>B.rows() == B.cols().</p>
</dd>
<dt>Precondition:</dt><dd><p>B.cols() == center.size().</p>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li><p>__init__(self: pydrake.geometry.optimization.AffineBall, ellipsoid: pydrake.geometry.optimization.Hyperellipsoid) -&gt; None</p></li>
</ol>
<p>Constructs an AffineBall from a Hyperellipsoid.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>ellipsoid.IsBounded().</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.AffineBall.B">
<span class="sig-name descname"><span class="pre">B</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.AffineBall" title="pydrake.geometry.optimization.AffineBall"><span class="pre">pydrake.geometry.optimization.AffineBall</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.AffineBall.B" title="Permalink to this definition"></a></dt>
<dd><p>Returns the affine transformation matrix B.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.AffineBall.center">
<span class="sig-name descname"><span class="pre">center</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.AffineBall" title="pydrake.geometry.optimization.AffineBall"><span class="pre">pydrake.geometry.optimization.AffineBall</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.AffineBall.center" title="Permalink to this definition"></a></dt>
<dd><p>Returns the center of the ellipsoid.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.AffineBall.Clone">
<span class="sig-name descname"><span class="pre">Clone</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.AffineBall" title="pydrake.geometry.optimization.AffineBall"><span class="pre">pydrake.geometry.optimization.AffineBall</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.geometry.optimization.ConvexSet" title="pydrake.geometry.optimization.ConvexSet"><span class="pre">pydrake.geometry.optimization.ConvexSet</span></a></span></span><a class="headerlink" href="#pydrake.geometry.optimization.AffineBall.Clone" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.AffineBall.MakeAxisAligned">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">MakeAxisAligned</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">radius</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.geometry.optimization.AffineBall" title="pydrake.geometry.optimization.AffineBall"><span class="pre">pydrake.geometry.optimization.AffineBall</span></a></span></span><a class="headerlink" href="#pydrake.geometry.optimization.AffineBall.MakeAxisAligned" title="Permalink to this definition"></a></dt>
<dd><p>Constructs an axis-aligned AffineBall with the implicit form
(x₀-c₀)²/r₀² + (x₁-c₁)²/r₁² + … + (x_N - c_N)²/r_N² ≤ 1, where c is
shorthand for <code class="docutils literal notranslate"><span class="pre">center</span></code> and r is shorthand for <code class="docutils literal notranslate"><span class="pre">radius</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>radius.size() == center.size().</p>
</dd>
<dt>Precondition:</dt><dd><p>radius[i] &gt;= 0, for all i.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.AffineBall.MakeHypersphere">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">MakeHypersphere</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">radius</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.geometry.optimization.AffineBall" title="pydrake.geometry.optimization.AffineBall"><span class="pre">pydrake.geometry.optimization.AffineBall</span></a></span></span><a class="headerlink" href="#pydrake.geometry.optimization.AffineBall.MakeHypersphere" title="Permalink to this definition"></a></dt>
<dd><p>Constructs a hypersphere with <code class="docutils literal notranslate"><span class="pre">radius</span></code> and <code class="docutils literal notranslate"><span class="pre">center</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>radius &gt;= 0.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.AffineBall.MakeUnitBall">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">MakeUnitBall</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.geometry.optimization.AffineBall" title="pydrake.geometry.optimization.AffineBall"><span class="pre">pydrake.geometry.optimization.AffineBall</span></a></span></span><a class="headerlink" href="#pydrake.geometry.optimization.AffineBall.MakeUnitBall" title="Permalink to this definition"></a></dt>
<dd><p>Constructs the L₂-norm unit ball in <code class="docutils literal notranslate"><span class="pre">dim</span></code> dimensions, {x | <a href="#id3"><span class="problematic" id="id4">|</span></a>x|₂ &lt;= 1
}.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>dim &gt;= 0.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.AffineBall.MinimumVolumeCircumscribedEllipsoid">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">MinimumVolumeCircumscribedEllipsoid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">points</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.f_contiguous</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rank_tol</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1e-06</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.geometry.optimization.AffineBall" title="pydrake.geometry.optimization.AffineBall"><span class="pre">pydrake.geometry.optimization.AffineBall</span></a></span></span><a class="headerlink" href="#pydrake.geometry.optimization.AffineBall.MinimumVolumeCircumscribedEllipsoid" title="Permalink to this definition"></a></dt>
<dd><p>Constructs the minimum-volume ellipsoid which contains all of the
given points. This is commonly referred to as the outer Löwner-John
ellipsoid.</p>
<p>If all of the points lie along a proper affine subspace, this method
instead computes the minimum-k-volume ellipsoid, where k is the affine
dimension of the convex hull of <code class="docutils literal notranslate"><span class="pre">points</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">points</span></code>:</dt><dd><p>is a d-by-n matrix, where d is the ambient dimension and each
column represents one point.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">rank_tol</span></code>:</dt><dd><p>the tolerance used to detect if the data lies in an affine
subspace. The affine ball is computed in the subspace spanned by
the left singular vectors of the data matrix whose associated
singular values are larger than <code class="docutils literal notranslate"><span class="pre">rank_tol</span></code> *
<code class="docutils literal notranslate"><span class="pre">max_singular_value</span></code>. The default is 1e-6 to be compatible with
common solver tolerances.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the MathematicalProgram fails to solve. This can</strong> – </p></li>
<li><p><strong>happen due to numerical issues caused by rank_tol being set</strong> – </p></li>
<li><p><strong>too low.</strong> – </p></li>
<li><p><strong>RuntimeError if points includes NaNs</strong><strong> or </strong><strong>infinite values.</strong> – </p></li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt>Precondition:</dt><dd><p>points.rows() &gt;= 1.</p>
</dd>
<dt>Precondition:</dt><dd><p>points.cols() &gt;= 1.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.AffineSubspace">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.geometry.optimization.</span></span><span class="sig-name descname"><span class="pre">AffineSubspace</span></span><a class="headerlink" href="#pydrake.geometry.optimization.AffineSubspace" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.geometry.optimization.ConvexSet" title="pydrake.geometry.optimization.ConvexSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.geometry.optimization.ConvexSet</span></code></a></p>
<p>An affine subspace (also known as a “flat”, a “linear variety”, or a
“linear manifold”) is a vector subspace of some Euclidean space,
potentially translated so as to not pass through the origin. Examples
include points, lines, and planes (not necessarily through the
origin).</p>
<p>An affine subspace is described by a basis of its corresponding vector
subspace, plus a translation. This description is not unique as any
point in the affine subspace can be used as a translation, and any
basis of the corresponding vector subspace is valid.</p>
<p>An affine subspace can never be empty, because a vector subspace can
never be empty. Thus, the translation will always be contained in the
flat. An affine subspace is bounded if it is a point, which is when
the basis has zero columns.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.AffineSubspace.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.geometry.optimization.AffineSubspace.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.geometry.optimization.AffineSubspace) -&gt; None</p></li>
</ol>
<p>Constructs a default (zero-dimensional, nonempty) affine subspace.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.geometry.optimization.AffineSubspace, basis: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], translation: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</p></li>
</ol>
<p>Constructs the affine subspace from an n-by-m matrix describing the
basis, where n is the ambient dimension, and m is the dimension of the
subspace, and from an n-dimensional vector describing the translation.
The set is {x | x = translation + basis*y, y ∈ Rᵐ} The columns must be
linearly independent.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>basis.rows() == translation.size().</p>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li><p>__init__(self: pydrake.geometry.optimization.AffineSubspace, set: pydrake.geometry.optimization.ConvexSet, tol: float = 0) -&gt; None</p></li>
</ol>
<p>Constructs an affine subspace as the affine hull of another convex
set. This is done by finding a feasible point in the set, and then
iteratively computing feasible vectors until we have a basis that
spans the set. If you pass in a convex set whose points are
matrix-valued (e.g. a Spectrahedron), then the affine subspace will
work over a flattened representation of those coordinates. (So a
Spectrahedron with n-by-n matrices will output an AffineSubspace with
ambient dimension (n * (n+1)) / 2.)</p>
<p><code class="docutils literal notranslate"><span class="pre">tol</span></code> sets the numerical precision of the computation. For each
dimension, a pair of feasible points are constructed, so as to
maximize the displacement in that dimension. If their displacement
along that dimension is larger than tol, then the vector connecting
the points is added as a basis vector.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>!set.IsEmpty()</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.AffineSubspace.AffineDimension">
<span class="sig-name descname"><span class="pre">AffineDimension</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.AffineSubspace" title="pydrake.geometry.optimization.AffineSubspace"><span class="pre">pydrake.geometry.optimization.AffineSubspace</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.AffineSubspace.AffineDimension" title="Permalink to this definition"></a></dt>
<dd><p>Returns the affine dimension of this set. For an affine subspace, this
is simply the number of columns in the <a href="#id15"><span class="problematic" id="id16">basis_</span></a> matrix. A point will
have affine dimension zero.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.AffineSubspace.basis">
<span class="sig-name descname"><span class="pre">basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.AffineSubspace" title="pydrake.geometry.optimization.AffineSubspace"><span class="pre">pydrake.geometry.optimization.AffineSubspace</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.AffineSubspace.basis" title="Permalink to this definition"></a></dt>
<dd><p>Returns the basis in an n-by-m matrix, where n is the ambient
dimension, and m is the number of vectors in the basis.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.AffineSubspace.Clone">
<span class="sig-name descname"><span class="pre">Clone</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.AffineSubspace" title="pydrake.geometry.optimization.AffineSubspace"><span class="pre">pydrake.geometry.optimization.AffineSubspace</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.geometry.optimization.ConvexSet" title="pydrake.geometry.optimization.ConvexSet"><span class="pre">pydrake.geometry.optimization.ConvexSet</span></a></span></span><a class="headerlink" href="#pydrake.geometry.optimization.AffineSubspace.Clone" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.AffineSubspace.ContainedIn">
<span class="sig-name descname"><span class="pre">ContainedIn</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.AffineSubspace" title="pydrake.geometry.optimization.AffineSubspace"><span class="pre">pydrake.geometry.optimization.AffineSubspace</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.AffineSubspace" title="pydrake.geometry.optimization.AffineSubspace"><span class="pre">pydrake.geometry.optimization.AffineSubspace</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1e-15</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.AffineSubspace.ContainedIn" title="Permalink to this definition"></a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if <code class="docutils literal notranslate"><span class="pre">this</span></code> AffineSubspace is contained in <code class="docutils literal notranslate"><span class="pre">other</span></code>.
This is computed by checking if <code class="docutils literal notranslate"><span class="pre">translation()</span></code> is in <code class="docutils literal notranslate"><span class="pre">other</span></code> and
then checking if each basis vector is in the span of the basis of
<code class="docutils literal notranslate"><span class="pre">other</span></code>. The latter step requires finding a least-squares solution,
so a nonzero tolerance (<code class="docutils literal notranslate"><span class="pre">tol</span></code>) is almost always necessary. (You may
have to adjust the default tolerance depending on the dimension of
your space and the scale of your basis vectors.)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.AffineSubspace.IsNearlyEqualTo">
<span class="sig-name descname"><span class="pre">IsNearlyEqualTo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.AffineSubspace" title="pydrake.geometry.optimization.AffineSubspace"><span class="pre">pydrake.geometry.optimization.AffineSubspace</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.AffineSubspace" title="pydrake.geometry.optimization.AffineSubspace"><span class="pre">pydrake.geometry.optimization.AffineSubspace</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1e-15</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.AffineSubspace.IsNearlyEqualTo" title="Permalink to this definition"></a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if <code class="docutils literal notranslate"><span class="pre">this</span></code> AffineSubspace is contained in <code class="docutils literal notranslate"><span class="pre">other</span></code>.
This is computed by checking if <code class="docutils literal notranslate"><span class="pre">translation()</span></code> is in <code class="docutils literal notranslate"><span class="pre">other</span></code> and
then checking if each basis vector is in the span of the basis of
<code class="docutils literal notranslate"><span class="pre">other</span></code>. The latter step requires finding a least-squares solution,
so a nonzero tolerance (<code class="docutils literal notranslate"><span class="pre">tol</span></code>) is almost always necessary. (You may
have to adjust the default tolerance depending on the dimension of
your space and the scale of your basis vectors.)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.AffineSubspace.OrthogonalComplementBasis">
<span class="sig-name descname"><span class="pre">OrthogonalComplementBasis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.AffineSubspace" title="pydrake.geometry.optimization.AffineSubspace"><span class="pre">pydrake.geometry.optimization.AffineSubspace</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.AffineSubspace.OrthogonalComplementBasis" title="Permalink to this definition"></a></dt>
<dd><p>Returns an orthonormal basis of the vector subspace which is
perpendicular to this AffineSubspace.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.AffineSubspace.Project">
<span class="sig-name descname"><span class="pre">Project</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.AffineSubspace" title="pydrake.geometry.optimization.AffineSubspace"><span class="pre">pydrake.geometry.optimization.AffineSubspace</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.f_contiguous</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.AffineSubspace.Project" title="Permalink to this definition"></a></dt>
<dd><p>Computes the orthogonal projection of x onto the AffineSubspace. This
is achieved by finding the least squares solution y for y to x =
<a href="#id17"><span class="problematic" id="id18">translation_</span></a> + basis_*y, and returning <a href="#id19"><span class="problematic" id="id20">translation_</span></a> + basis_*y. Each
column of the input should be a vector in the ambient space, and the
corresponding column of the output will be its projection onto the
affine subspace.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>x.rows() == ambient_dimension()</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.AffineSubspace.ToGlobalCoordinates">
<span class="sig-name descname"><span class="pre">ToGlobalCoordinates</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.AffineSubspace" title="pydrake.geometry.optimization.AffineSubspace"><span class="pre">pydrake.geometry.optimization.AffineSubspace</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.f_contiguous</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.AffineSubspace.ToGlobalCoordinates" title="Permalink to this definition"></a></dt>
<dd><p>Given a point y in the basis of the AffineSubspace, with the zero
point at <a href="#id21"><span class="problematic" id="id22">translation_</span></a>, returns the coordinates of y in the standard
basis of the ambient space. If the AffineSubspace is a point, it has
an empty basis, so the only possible local coordinates are also empty
(and should be passed in as a length-zero vector). Each column of the
input should be a vector in the affine subspace, represented in its
local coordinates, and the corresponding column of the output will be
its representation in the coordinate system of the ambient space.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>y.rows() == AffineDimension()</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.AffineSubspace.ToLocalCoordinates">
<span class="sig-name descname"><span class="pre">ToLocalCoordinates</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.AffineSubspace" title="pydrake.geometry.optimization.AffineSubspace"><span class="pre">pydrake.geometry.optimization.AffineSubspace</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.f_contiguous</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.AffineSubspace.ToLocalCoordinates" title="Permalink to this definition"></a></dt>
<dd><p>Given a point x in the standard basis of the ambient space, returns
the coordinates of x in the basis of the AffineSubspace, with the zero
point at <a href="#id23"><span class="problematic" id="id24">translation_</span></a>. The component of x that is orthogonal to the
AffineSubspace (if it exists) is discarded, so
ToGlobalCoordinates(ToLocalCoordinates(x)) is equivalent to
Project(x). Note that if the AffineSubspace is a point, the basis is
empty, so the local coordinates will also be empty (and returned as a
length-zero vector). Each column of the input should be a vector in
the ambient space, and the corresponding column of the output will be
its representation in the local coordinates of the affine subspace.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>x.rows() == ambient_dimension()</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.AffineSubspace.translation">
<span class="sig-name descname"><span class="pre">translation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.AffineSubspace" title="pydrake.geometry.optimization.AffineSubspace"><span class="pre">pydrake.geometry.optimization.AffineSubspace</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.AffineSubspace.translation" title="Permalink to this definition"></a></dt>
<dd><p>Returns the translation as a length n vector.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CartesianProduct">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.geometry.optimization.</span></span><span class="sig-name descname"><span class="pre">CartesianProduct</span></span><a class="headerlink" href="#pydrake.geometry.optimization.CartesianProduct" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.geometry.optimization.ConvexSet" title="pydrake.geometry.optimization.ConvexSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.geometry.optimization.ConvexSet</span></code></a></p>
<p>The Cartesian product of convex sets is a convex set: S = X₁ × X₂ × ⋯
× Xₙ = {(x₁, x₂, …, xₙ) | x₁ ∈ X₁, x₂ ∈ X₂, …, xₙ ∈ Xₙ}.</p>
<p>This class also supports a generalization of this concept in which the
coordinates are transformed by the linear map, {x | y = Ax + b, y ∈ Y₁
× Y₂ × ⋯ × Yₙ}, with the default values set to the identity map. This
concept is required for reasoning about cylinders in arbitrary poses
as cartesian products, and more generally for describing any affine
transform of a CartesianProduct.</p>
<p>Special behavior for IsEmpty: If there are no sets in the product,
returns nonempty by convention. See:
<a class="reference external" href="https://en.wikipedia.org/wiki/Empty_product#Nullary_Cartesian_product">https://en.wikipedia.org/wiki/Empty_product#Nullary_Cartesian_product</a>
Otherwise, if any set in the cartesian product is empty, the whole
product is empty.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CartesianProduct.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.geometry.optimization.CartesianProduct.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.geometry.optimization.CartesianProduct) -&gt; None</p></li>
</ol>
<p>Constructs a default (zero-dimensional, nonempty) set.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.geometry.optimization.CartesianProduct, sets: List[pydrake.geometry.optimization.ConvexSet]) -&gt; None</p></li>
</ol>
<p>Constructs the product from a vector of convex sets.</p>
<ol class="arabic simple" start="3">
<li><p>__init__(self: pydrake.geometry.optimization.CartesianProduct, setA: pydrake.geometry.optimization.ConvexSet, setB: pydrake.geometry.optimization.ConvexSet) -&gt; None</p></li>
</ol>
<p>Constructs the product from a pair of convex sets.</p>
<ol class="arabic simple" start="4">
<li><p>__init__(self: pydrake.geometry.optimization.CartesianProduct, sets: List[pydrake.geometry.optimization.ConvexSet], A: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], b: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</p></li>
</ol>
<p>Constructs the product of convex sets in the transformed coordinates:
{x | y = Ax + b, y ∈ Y₁ × Y₂ × ⋯ × Yₙ}.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError when A is not full column rank.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="5">
<li><p>__init__(self: pydrake.geometry.optimization.CartesianProduct, query_object: pydrake.geometry.QueryObject, geometry_id: pydrake.geometry.GeometryId, reference_frame: Optional[pydrake.geometry.FrameId] = None) -&gt; None</p></li>
</ol>
<p>Constructs a CartesianProduct from a SceneGraph geometry and pose in
the <code class="docutils literal notranslate"><span class="pre">reference_frame</span></code> frame, obtained via the QueryObject. If
<code class="docutils literal notranslate"><span class="pre">reference_frame</span></code> frame is std::nullopt, then it will be expressed
in the world frame.</p>
<p>Although any geometry that can be used as a ConvexSet could also be a
(trivial) CartesianProduct, we restrict this constructor to handling
Cylinder geometry, which constructs the (non-trivial) Cartesian
product of a HyperEllipsoid and an HPolyhedron. Most other SceneGraph
geometry types are supported by at least one of the ConvexSet class
constructors.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if geometry_id does not correspond to a Cylinder.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CartesianProduct.factor">
<span class="sig-name descname"><span class="pre">factor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.CartesianProduct" title="pydrake.geometry.optimization.CartesianProduct"><span class="pre">pydrake.geometry.optimization.CartesianProduct</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.geometry.optimization.ConvexSet" title="pydrake.geometry.optimization.ConvexSet"><span class="pre">pydrake.geometry.optimization.ConvexSet</span></a></span></span><a class="headerlink" href="#pydrake.geometry.optimization.CartesianProduct.factor" title="Permalink to this definition"></a></dt>
<dd><p>Returns a reference to the ConvexSet defining the <code class="docutils literal notranslate"><span class="pre">index</span></code> factor in
the product.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CartesianProduct.num_factors">
<span class="sig-name descname"><span class="pre">num_factors</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.CartesianProduct" title="pydrake.geometry.optimization.CartesianProduct"><span class="pre">pydrake.geometry.optimization.CartesianProduct</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.CartesianProduct.num_factors" title="Permalink to this definition"></a></dt>
<dd><p>The number of factors (or sets) used in the product.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CIrisCollisionGeometry">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.geometry.optimization.</span></span><span class="sig-name descname"><span class="pre">CIrisCollisionGeometry</span></span><a class="headerlink" href="#pydrake.geometry.optimization.CIrisCollisionGeometry" title="Permalink to this definition"></a></dt>
<dd><p>This class contains the necessary information about the collision
geometry used in C-IRIS. Most notably it transcribes the geometric
condition that the collision geometry is on one side of the plane to
mathematical constraints. For the detailed algorithm please refer to
the paper Certified Polyhedral Decompositions of Collision-Free
Configuration Space by Hongkai Dai*, Alexandre Amice*, Peter Werner,
Annan Zhang and Russ Tedrake.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CIrisCollisionGeometry.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.geometry.optimization.CIrisCollisionGeometry.__init__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CIrisCollisionGeometry.body_index">
<span class="sig-name descname"><span class="pre">body_index</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.CIrisCollisionGeometry" title="pydrake.geometry.optimization.CIrisCollisionGeometry"><span class="pre">pydrake.geometry.optimization.CIrisCollisionGeometry</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">drake::TypeSafeIndex&lt;drake::multibody::BodyTag&gt;</span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.CIrisCollisionGeometry.body_index" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CIrisCollisionGeometry.geometry">
<span class="sig-name descname"><span class="pre">geometry</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.CIrisCollisionGeometry" title="pydrake.geometry.optimization.CIrisCollisionGeometry"><span class="pre">pydrake.geometry.optimization.CIrisCollisionGeometry</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.Shape" title="pydrake.geometry.Shape"><span class="pre">pydrake.geometry.Shape</span></a></span></span><a class="headerlink" href="#pydrake.geometry.optimization.CIrisCollisionGeometry.geometry" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CIrisCollisionGeometry.id">
<span class="sig-name descname"><span class="pre">id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.CIrisCollisionGeometry" title="pydrake.geometry.optimization.CIrisCollisionGeometry"><span class="pre">pydrake.geometry.optimization.CIrisCollisionGeometry</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.GeometryId" title="pydrake.geometry.GeometryId"><span class="pre">pydrake.geometry.GeometryId</span></a></span></span><a class="headerlink" href="#pydrake.geometry.optimization.CIrisCollisionGeometry.id" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CIrisCollisionGeometry.num_rationals">
<span class="sig-name descname"><span class="pre">num_rationals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.CIrisCollisionGeometry" title="pydrake.geometry.optimization.CIrisCollisionGeometry"><span class="pre">pydrake.geometry.optimization.CIrisCollisionGeometry</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.CIrisCollisionGeometry.num_rationals" title="Permalink to this definition"></a></dt>
<dd><p>Returns the number of rationals in the condition “this geometry is on
one side of the plane.”</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CIrisCollisionGeometry.type">
<span class="sig-name descname"><span class="pre">type</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.CIrisCollisionGeometry" title="pydrake.geometry.optimization.CIrisCollisionGeometry"><span class="pre">pydrake.geometry.optimization.CIrisCollisionGeometry</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.geometry.optimization.CIrisGeometryType" title="pydrake.geometry.optimization.CIrisGeometryType"><span class="pre">pydrake.geometry.optimization.CIrisGeometryType</span></a></span></span><a class="headerlink" href="#pydrake.geometry.optimization.CIrisCollisionGeometry.type" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CIrisCollisionGeometry.X_BG">
<span class="sig-name descname"><span class="pre">X_BG</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.CIrisCollisionGeometry" title="pydrake.geometry.optimization.CIrisCollisionGeometry"><span class="pre">pydrake.geometry.optimization.CIrisCollisionGeometry</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.math.html#pydrake.math.RigidTransform" title="pydrake.math.RigidTransform"><span class="pre">pydrake.math.RigidTransform</span></a></span></span><a class="headerlink" href="#pydrake.geometry.optimization.CIrisCollisionGeometry.X_BG" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CIrisGeometryType">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.geometry.optimization.</span></span><span class="sig-name descname"><span class="pre">CIrisGeometryType</span></span><a class="headerlink" href="#pydrake.geometry.optimization.CIrisGeometryType" title="Permalink to this definition"></a></dt>
<dd><p>The supported type of geometries in C-IRIS.</p>
<p>Members:</p>
<blockquote>
<div><p>kPolytope :</p>
<p>kSphere :</p>
<p>kCylinder :</p>
<p>kCapsule :</p>
</div></blockquote>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CIrisGeometryType.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.CIrisGeometryType" title="pydrake.geometry.optimization.CIrisGeometryType"><span class="pre">pydrake.geometry.optimization.CIrisGeometryType</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.CIrisGeometryType.__init__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CIrisGeometryType.kCapsule">
<span class="sig-name descname"><span class="pre">kCapsule</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;CIrisGeometryType.kCapsule:</span> <span class="pre">3&gt;</span></em><a class="headerlink" href="#pydrake.geometry.optimization.CIrisGeometryType.kCapsule" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CIrisGeometryType.kCylinder">
<span class="sig-name descname"><span class="pre">kCylinder</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;CIrisGeometryType.kCylinder:</span> <span class="pre">2&gt;</span></em><a class="headerlink" href="#pydrake.geometry.optimization.CIrisGeometryType.kCylinder" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CIrisGeometryType.kPolytope">
<span class="sig-name descname"><span class="pre">kPolytope</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;CIrisGeometryType.kPolytope:</span> <span class="pre">1&gt;</span></em><a class="headerlink" href="#pydrake.geometry.optimization.CIrisGeometryType.kPolytope" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CIrisGeometryType.kSphere">
<span class="sig-name descname"><span class="pre">kSphere</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;CIrisGeometryType.kSphere:</span> <span class="pre">0&gt;</span></em><a class="headerlink" href="#pydrake.geometry.optimization.CIrisGeometryType.kSphere" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CIrisGeometryType.name">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">name</span></span><a class="headerlink" href="#pydrake.geometry.optimization.CIrisGeometryType.name" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CIrisGeometryType.value">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">value</span></span><a class="headerlink" href="#pydrake.geometry.optimization.CIrisGeometryType.value" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.ConvexSet">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.geometry.optimization.</span></span><span class="sig-name descname"><span class="pre">ConvexSet</span></span><a class="headerlink" href="#pydrake.geometry.optimization.ConvexSet" title="Permalink to this definition"></a></dt>
<dd><p>Abstract base class for defining a convex set.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.ConvexSet.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.geometry.optimization.ConvexSet.__init__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.ConvexSet.AddPointInNonnegativeScalingConstraints">
<span class="sig-name descname"><span class="pre">AddPointInNonnegativeScalingConstraints</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.geometry.optimization.ConvexSet.AddPointInNonnegativeScalingConstraints" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>AddPointInNonnegativeScalingConstraints(self: pydrake.geometry.optimization.ConvexSet, prog: pydrake.solvers.MathematicalProgram, x: numpy.ndarray[object[m, 1]], t: pydrake.symbolic.Variable) -&gt; List[pydrake.solvers.Binding[Constraint]]</p></li>
</ol>
<p>Let S be this convex set. When S is bounded, this method adds the
convex constraints to imply</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>x ∈ t S,
t ≥ 0,
</pre></div>
</div>
</details><p>where x is a point in ℜⁿ (with n the ambient_dimension) and t is a
scalar.</p>
<p>When S is unbounded, then the behavior is almost identical, except
when t=0. In this case, the constraints imply t ≥ 0, x ∈ t S ⊕ rec(S),
where rec(S) is the recession cone of S (the asymptotic directions in
which S is not bounded) and ⊕ is the Minkowski sum. For t &gt; 0, this is
equivalent to x ∈ t S, but for t = 0, we have only x ∈ rec(S).</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if ambient_dimension</strong><strong>(</strong><strong>) </strong><strong>== 0</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>AddPointInNonnegativeScalingConstraints(self: pydrake.geometry.optimization.ConvexSet, prog: pydrake.solvers.MathematicalProgram, A: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], b: numpy.ndarray[numpy.float64[m, 1]], c: numpy.ndarray[numpy.float64[m, 1]], d: float, x: numpy.ndarray[object[m, 1]], t: numpy.ndarray[object[m, 1]]) -&gt; List[pydrake.solvers.Binding[Constraint]]</p></li>
</ol>
<p>Let S be this convex set. When S is bounded, this method adds the
convex constraints to imply</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>A * x + b ∈ (c&#39; * t + d) S,
c&#39; * t + d ≥ 0,
</pre></div>
</div>
</details><p>where A is an n-by-m matrix (with n the ambient_dimension), b is a
vector of size n, c is a vector of size p, x is a point in ℜᵐ, and t
is a point in ℜᵖ.</p>
<p>When S is unbounded, then the behavior is almost identical, except
when c’ * t+d=0. In this case, the constraints imply</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>A * x + b ∈ (c&#39; * t + d) S ⊕ rec(S),
c&#39; * t + d ≥ 0,
</pre></div>
</div>
</details><p>where rec(S) is the recession cone of S (the asymptotic directions in
which S is not bounded) and ⊕ is the Minkowski sum. For c’ * t + d &gt;
0, this is equivalent to A * x + b ∈ (c’ * t + d) S, but for c’ * t +
d = 0, we have only A * x + b ∈ rec(S).</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if ambient_dimension</strong><strong>(</strong><strong>) </strong><strong>== 0</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.ConvexSet.AddPointInSetConstraints">
<span class="sig-name descname"><span class="pre">AddPointInSetConstraints</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.ConvexSet" title="pydrake.geometry.optimization.ConvexSet"><span class="pre">pydrake.geometry.optimization.ConvexSet</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">prog</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.solvers.html#pydrake.solvers.MathematicalProgram" title="pydrake.solvers.MathematicalProgram"><span class="pre">pydrake.solvers.MathematicalProgram</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">vars</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.solvers.html#pydrake.solvers.Binding" title="pydrake.solvers.Binding"><span class="pre">pydrake.solvers.Binding</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Constraint</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.ConvexSet.AddPointInSetConstraints" title="Permalink to this definition"></a></dt>
<dd><p>Adds a constraint to an existing MathematicalProgram enforcing that
the point defined by vars is inside the set.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>(new_vars, new_constraints) Some of the derived class will add new
decision variables to enforce this constraint, we return all the
newly added decision variables as new_vars. The meaning of these
new decision variables differs in each subclass. If no new
variables are added, then we return an empty Eigen vector. Also we
return all the newly added constraints to <code class="docutils literal notranslate"><span class="pre">prog</span></code> through this
function.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>RuntimeError if ambient_dimension</strong><strong>(</strong><strong>) </strong><strong>== 0</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.ConvexSet.ambient_dimension">
<span class="sig-name descname"><span class="pre">ambient_dimension</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.ConvexSet" title="pydrake.geometry.optimization.ConvexSet"><span class="pre">pydrake.geometry.optimization.ConvexSet</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.ConvexSet.ambient_dimension" title="Permalink to this definition"></a></dt>
<dd><p>Returns the dimension of the vector space in which the elements of
this set are evaluated. Contrast this with the <code class="docutils literal notranslate"><span class="pre">affine</span> <span class="pre">dimension</span></code>:
the dimension of the smallest affine subset of the ambient space that
contains our set. For example, if we define a set using <code class="docutils literal notranslate"><span class="pre">A*x</span> <span class="pre">=</span> <span class="pre">b</span></code>,
where <code class="docutils literal notranslate"><span class="pre">A</span></code> has linearly independent rows, then the ambient dimension
is the dimension of <code class="docutils literal notranslate"><span class="pre">x</span></code>, but the affine dimension of the set is
<code class="docutils literal notranslate"><span class="pre">ambient_dimension()</span> <span class="pre">-</span> <span class="pre">rank(A)</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.ConvexSet.CalcVolume">
<span class="sig-name descname"><span class="pre">CalcVolume</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.ConvexSet" title="pydrake.geometry.optimization.ConvexSet"><span class="pre">pydrake.geometry.optimization.ConvexSet</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.ConvexSet.CalcVolume" title="Permalink to this definition"></a></dt>
<dd><p>Computes the exact volume for the convex set.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Not every convex set can report an exact volume. In that case, use
CalcVolumeViaSampling() instead.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if has_exact_volume</strong><strong>(</strong><strong>) </strong><strong>returns False.</strong> – </p></li>
<li><p><strong>if ambient_dimension</strong><strong>(</strong><strong>) </strong><strong>== 0.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.ConvexSet.Clone">
<span class="sig-name descname"><span class="pre">Clone</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.ConvexSet" title="pydrake.geometry.optimization.ConvexSet"><span class="pre">pydrake.geometry.optimization.ConvexSet</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.geometry.optimization.ConvexSet" title="pydrake.geometry.optimization.ConvexSet"><span class="pre">pydrake.geometry.optimization.ConvexSet</span></a></span></span><a class="headerlink" href="#pydrake.geometry.optimization.ConvexSet.Clone" title="Permalink to this definition"></a></dt>
<dd><p>Creates a unique deep copy of this set.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.ConvexSet.IntersectsWith">
<span class="sig-name descname"><span class="pre">IntersectsWith</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.ConvexSet" title="pydrake.geometry.optimization.ConvexSet"><span class="pre">pydrake.geometry.optimization.ConvexSet</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.ConvexSet" title="pydrake.geometry.optimization.ConvexSet"><span class="pre">pydrake.geometry.optimization.ConvexSet</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.ConvexSet.IntersectsWith" title="Permalink to this definition"></a></dt>
<dd><p>Returns true iff the intersection between <code class="docutils literal notranslate"><span class="pre">this</span></code> and <code class="docutils literal notranslate"><span class="pre">other</span></code> is
non-empty.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the ambient dimension of other is not the same</strong> – </p></li>
<li><p><strong>as that of this.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.ConvexSet.IsBounded">
<span class="sig-name descname"><span class="pre">IsBounded</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.ConvexSet" title="pydrake.geometry.optimization.ConvexSet"><span class="pre">pydrake.geometry.optimization.ConvexSet</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.ConvexSet.IsBounded" title="Permalink to this definition"></a></dt>
<dd><p>Returns true iff the set is bounded, e.g., there exists an
element-wise finite lower and upper bound for the set. Note: for some
derived classes, this check is trivial, but for others it can require
solving an (typically small) optimization problem. Check the derived
class documentation for any notes.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.ConvexSet.IsEmpty">
<span class="sig-name descname"><span class="pre">IsEmpty</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.ConvexSet" title="pydrake.geometry.optimization.ConvexSet"><span class="pre">pydrake.geometry.optimization.ConvexSet</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.ConvexSet.IsEmpty" title="Permalink to this definition"></a></dt>
<dd><p>Returns true iff the set is empty. Note: for some derived classes,
this check is trivial, but for others, it can require solving a
(typically small) optimization problem. Check the derived class
documentation for any notes. Zero-dimensional sets must be handled
specially. There are two possible sets in a zero-dimensional space –
the empty set, and the whole set (which is simply the “zero vector
space”, {0}.) For more details, see:
<a class="reference external" href="https://en.wikipedia.org/wiki/Examples_of_vector_spaces#Trivial_or_zero_vector_space">https://en.wikipedia.org/wiki/Examples_of_vector_spaces#Trivial_or_zero_vector_space</a>
Zero-dimensional sets are considered to be nonempty by default. Sets
which can be zero-dimensional and empty must handle this behavior in
their derived implementation of DoIsEmpty. An example of such a
subclass is VPolytope.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.ConvexSet.MaybeGetFeasiblePoint">
<span class="sig-name descname"><span class="pre">MaybeGetFeasiblePoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.ConvexSet" title="pydrake.geometry.optimization.ConvexSet"><span class="pre">pydrake.geometry.optimization.ConvexSet</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.ConvexSet.MaybeGetFeasiblePoint" title="Permalink to this definition"></a></dt>
<dd><p>Returns a feasible point within this convex set if it is nonempty, and
nullopt otherwise.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.ConvexSet.MaybeGetPoint">
<span class="sig-name descname"><span class="pre">MaybeGetPoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.ConvexSet" title="pydrake.geometry.optimization.ConvexSet"><span class="pre">pydrake.geometry.optimization.ConvexSet</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.ConvexSet.MaybeGetPoint" title="Permalink to this definition"></a></dt>
<dd><p>If this set trivially contains exactly one point, returns the value of
that point. Otherwise, returns nullopt. By “trivially”, we mean that
representation of the set structurally maps to a single point; if
checking for point-ness would require solving an optimization program,
returns nullopt. In other words, this is a relatively cheap function
to call.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.ConvexSet.PointInSet">
<span class="sig-name descname"><span class="pre">PointInSet</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.ConvexSet" title="pydrake.geometry.optimization.ConvexSet"><span class="pre">pydrake.geometry.optimization.ConvexSet</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1e-08</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.ConvexSet.PointInSet" title="Permalink to this definition"></a></dt>
<dd><p>Returns true iff the point x is contained in the set. If the ambient
dimension is zero, then if the set is nonempty, the point is trivially
in the set, and if the set is empty, the point is trivially not in the
set.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.ConvexSet.ToShapeWithPose">
<span class="sig-name descname"><span class="pre">ToShapeWithPose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.ConvexSet" title="pydrake.geometry.optimization.ConvexSet"><span class="pre">pydrake.geometry.optimization.ConvexSet</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.Shape" title="pydrake.geometry.Shape"><span class="pre">pydrake.geometry.Shape</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="pydrake.math.html#pydrake.math.RigidTransform" title="pydrake.math.RigidTransform"><span class="pre">pydrake.math.RigidTransform</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.ConvexSet.ToShapeWithPose" title="Permalink to this definition"></a></dt>
<dd><p>Constructs a Shape and a pose of the set in the world frame for use in
the SceneGraph geometry ecosystem.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if ambient_dimension</strong><strong>(</strong><strong>) </strong><strong>!= 3</strong><strong> or </strong><strong>if the functionality</strong> – </p></li>
<li><p><strong>for a particular set has not been implemented yet.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CspaceFreePolytope">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.geometry.optimization.</span></span><span class="sig-name descname"><span class="pre">CspaceFreePolytope</span></span><a class="headerlink" href="#pydrake.geometry.optimization.CspaceFreePolytope" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.geometry.optimization.CspaceFreePolytopeBase" title="pydrake.geometry.optimization.CspaceFreePolytopeBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.geometry.optimization.CspaceFreePolytopeBase</span></code></a></p>
<p>This class tries to find large convex polytopes in the
tangential-configuration space, such that all configurations in the
convex polytopes is collision free. By tangential-configuration space,
we mean the revolute joint angle θ is replaced by t = tan(θ/2). For
more details, refer to the paper</p>
<p>Certified Polyhedral Decomposition of Collisoin-Free Configuration
Space by Hongkai Dai*, Alexandre Amice*, Peter Werner, Annan Zhang and
Russ Tedrake.</p>
<p>A conference version is published at</p>
<p>Finding and Optimizing Certified, Colision-Free Regions in
Configuration Space for Robot Manipulators by Alexandre Amice*,
Hongkai Dai*, Peter Werner, Annan Zhang and Russ Tedrake.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CspaceFreePolytope.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">self:</span> <span class="pre">pydrake.geometry.optimization.CspaceFreePolytope,</span> <span class="pre">plant:</span> <span class="pre">drake::multibody::MultibodyPlant&lt;double&gt;,</span> <span class="pre">scene_graph:</span> <span class="pre">pydrake.geometry.SceneGraph,</span> <span class="pre">plane_order:</span> <span class="pre">pydrake.geometry.optimization.SeparatingPlaneOrder,</span> <span class="pre">q_star:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]],</span> <span class="pre">options:</span> <span class="pre">pydrake.geometry.optimization.CspaceFreePolytopeBase.Options</span> <span class="pre">=</span> <span class="pre">Options(with_cross_y=False)</span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.CspaceFreePolytope.__init__" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">plant</span></code>:</dt><dd><p>The plant for which we compute the C-space free polytopes. It must
outlive this CspaceFreePolytope object.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">scene_graph</span></code>:</dt><dd><p>The scene graph that has been connected with <code class="docutils literal notranslate"><span class="pre">plant</span></code>. It must
outlive this CspaceFreePolytope object.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">plane_order</span></code>:</dt><dd><p>The order of the polynomials in the plane to separate a pair of
collision geometries.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">q_star</span></code>:</dt><dd><p>Refer to RationalForwardKinematics for its meaning.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>CspaceFreePolytope knows nothing about contexts. The plant and
scene_graph must be fully configured before instantiating this
class.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CspaceFreePolytope.BilinearAlternationOptions">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">BilinearAlternationOptions</span></span><a class="headerlink" href="#pydrake.geometry.optimization.CspaceFreePolytope.BilinearAlternationOptions" title="Permalink to this definition"></a></dt>
<dd><p>Options for bilinear alternation.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CspaceFreePolytope.BilinearAlternationOptions.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.CspaceFreePolytope.BilinearAlternationOptions" title="pydrake.geometry.optimization.CspaceFreePolytope.BilinearAlternationOptions"><span class="pre">pydrake.geometry.optimization.CspaceFreePolytope.BilinearAlternationOptions</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.CspaceFreePolytope.BilinearAlternationOptions.__init__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CspaceFreePolytope.BilinearAlternationOptions.convergence_tol">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">convergence_tol</span></span><a class="headerlink" href="#pydrake.geometry.optimization.CspaceFreePolytope.BilinearAlternationOptions.convergence_tol" title="Permalink to this definition"></a></dt>
<dd><p>When the change of the cost function between two consecutive
iterations in bilinear alternation is no larger than this number, stop
the bilinear alternation. Must be non-negative.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CspaceFreePolytope.BilinearAlternationOptions.ellipsoid_scaling">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ellipsoid_scaling</span></span><a class="headerlink" href="#pydrake.geometry.optimization.CspaceFreePolytope.BilinearAlternationOptions.ellipsoid_scaling" title="Permalink to this definition"></a></dt>
<dd><p>After finding the maximal inscribed ellipsoid in C-space polytope {s |
C*s&lt;=d, s_lower&lt;=s&lt;=s_upper}, we scale this ellipsoid by
ellipsoid_scaling, and require the new C-space polytope to contain
this scaled ellipsoid. ellipsoid_scaling=1 corresponds to no scaling.
Must be strictly positive and no greater than 1.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CspaceFreePolytope.BilinearAlternationOptions.find_lagrangian_options">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">find_lagrangian_options</span></span><a class="headerlink" href="#pydrake.geometry.optimization.CspaceFreePolytope.BilinearAlternationOptions.find_lagrangian_options" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CspaceFreePolytope.BilinearAlternationOptions.find_polytope_options">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">find_polytope_options</span></span><a class="headerlink" href="#pydrake.geometry.optimization.CspaceFreePolytope.BilinearAlternationOptions.find_polytope_options" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CspaceFreePolytope.BilinearAlternationOptions.max_iter">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">max_iter</span></span><a class="headerlink" href="#pydrake.geometry.optimization.CspaceFreePolytope.BilinearAlternationOptions.max_iter" title="Permalink to this definition"></a></dt>
<dd><p>The maximum number of bilinear alternation iterations. Must be
non-negative.</p>
</dd></dl>

</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CspaceFreePolytope.BinarySearch">
<span class="sig-name descname"><span class="pre">BinarySearch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">self:</span> <span class="pre">pydrake.geometry.optimization.CspaceFreePolytope,</span> <span class="pre">ignored_collision_pairs:</span> <span class="pre">Set[Tuple[pydrake.geometry.GeometryId]],</span> <span class="pre">C:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous],</span> <span class="pre">d:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]],</span> <span class="pre">s_center:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]],</span> <span class="pre">options:</span> <span class="pre">drake::geometry::optimization::CspaceFreePolytope::BinarySearchOptions</span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Optional[drake::geometry::optimization::CspaceFreePolytope::SearchResult]</span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.CspaceFreePolytope.BinarySearch" title="Permalink to this definition"></a></dt>
<dd><p>Binary search on d such that the C-space polytope {s | C*s&lt;=d,
s_lower&lt;=s&lt;=s_upper} is collision free. We scale the polytope {s |
C*s&lt;=d_init} about its center <code class="docutils literal notranslate"><span class="pre">s_center</span></code> and search the scaling
factor.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>s_center is in the polytope {s | C*s&lt;=d_init, s_lower&lt;=s&lt;=s_upper}</p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CspaceFreePolytope.BinarySearchOptions">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">BinarySearchOptions</span></span><a class="headerlink" href="#pydrake.geometry.optimization.CspaceFreePolytope.BinarySearchOptions" title="Permalink to this definition"></a></dt>
<dd><p>Options for binary search.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CspaceFreePolytope.BinarySearchOptions.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.CspaceFreePolytope.BinarySearchOptions" title="pydrake.geometry.optimization.CspaceFreePolytope.BinarySearchOptions"><span class="pre">pydrake.geometry.optimization.CspaceFreePolytope.BinarySearchOptions</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.CspaceFreePolytope.BinarySearchOptions.__init__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CspaceFreePolytope.BinarySearchOptions.convergence_tol">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">convergence_tol</span></span><a class="headerlink" href="#pydrake.geometry.optimization.CspaceFreePolytope.BinarySearchOptions.convergence_tol" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CspaceFreePolytope.BinarySearchOptions.find_lagrangian_options">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">find_lagrangian_options</span></span><a class="headerlink" href="#pydrake.geometry.optimization.CspaceFreePolytope.BinarySearchOptions.find_lagrangian_options" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CspaceFreePolytope.BinarySearchOptions.max_iter">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">max_iter</span></span><a class="headerlink" href="#pydrake.geometry.optimization.CspaceFreePolytope.BinarySearchOptions.max_iter" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CspaceFreePolytope.BinarySearchOptions.scale_max">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">scale_max</span></span><a class="headerlink" href="#pydrake.geometry.optimization.CspaceFreePolytope.BinarySearchOptions.scale_max" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CspaceFreePolytope.BinarySearchOptions.scale_min">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">scale_min</span></span><a class="headerlink" href="#pydrake.geometry.optimization.CspaceFreePolytope.BinarySearchOptions.scale_min" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CspaceFreePolytope.EllipsoidMarginCost">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">EllipsoidMarginCost</span></span><a class="headerlink" href="#pydrake.geometry.optimization.CspaceFreePolytope.EllipsoidMarginCost" title="Permalink to this definition"></a></dt>
<dd><p>The cost used when fixing the Lagrangian multiplier and search for C
and d in the C-space polytope {s | C*s &lt;=d, s_lower&lt;=s&lt;=s_upper}. We
denote δᵢ as the margin between the i’th face C.row(i)&lt;=d(i) to the
inscribed ellipsoid.</p>
<p>Members:</p>
<blockquote>
<div><p>kSum</p>
<p>kGeometricMean</p>
</div></blockquote>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CspaceFreePolytope.EllipsoidMarginCost.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.CspaceFreePolytope.EllipsoidMarginCost" title="pydrake.geometry.optimization.CspaceFreePolytope.EllipsoidMarginCost"><span class="pre">pydrake.geometry.optimization.CspaceFreePolytope.EllipsoidMarginCost</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.CspaceFreePolytope.EllipsoidMarginCost.__init__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CspaceFreePolytope.EllipsoidMarginCost.kGeometricMean">
<span class="sig-name descname"><span class="pre">kGeometricMean</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;EllipsoidMarginCost.kGeometricMean:</span> <span class="pre">1&gt;</span></em><a class="headerlink" href="#pydrake.geometry.optimization.CspaceFreePolytope.EllipsoidMarginCost.kGeometricMean" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CspaceFreePolytope.EllipsoidMarginCost.kSum">
<span class="sig-name descname"><span class="pre">kSum</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;EllipsoidMarginCost.kSum:</span> <span class="pre">0&gt;</span></em><a class="headerlink" href="#pydrake.geometry.optimization.CspaceFreePolytope.EllipsoidMarginCost.kSum" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CspaceFreePolytope.EllipsoidMarginCost.name">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">name</span></span><a class="headerlink" href="#pydrake.geometry.optimization.CspaceFreePolytope.EllipsoidMarginCost.name" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CspaceFreePolytope.EllipsoidMarginCost.value">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">value</span></span><a class="headerlink" href="#pydrake.geometry.optimization.CspaceFreePolytope.EllipsoidMarginCost.value" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CspaceFreePolytope.FindPolytopeGivenLagrangianOptions">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">FindPolytopeGivenLagrangianOptions</span></span><a class="headerlink" href="#pydrake.geometry.optimization.CspaceFreePolytope.FindPolytopeGivenLagrangianOptions" title="Permalink to this definition"></a></dt>
<dd><p>Options for finding polytope with given Lagrangians.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CspaceFreePolytope.FindPolytopeGivenLagrangianOptions.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.CspaceFreePolytope.FindPolytopeGivenLagrangianOptions" title="pydrake.geometry.optimization.CspaceFreePolytope.FindPolytopeGivenLagrangianOptions"><span class="pre">pydrake.geometry.optimization.CspaceFreePolytope.FindPolytopeGivenLagrangianOptions</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.CspaceFreePolytope.FindPolytopeGivenLagrangianOptions.__init__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CspaceFreePolytope.FindPolytopeGivenLagrangianOptions.backoff_scale">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">backoff_scale</span></span><a class="headerlink" href="#pydrake.geometry.optimization.CspaceFreePolytope.FindPolytopeGivenLagrangianOptions.backoff_scale" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CspaceFreePolytope.FindPolytopeGivenLagrangianOptions.ellipsoid_margin_cost">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ellipsoid_margin_cost</span></span><a class="headerlink" href="#pydrake.geometry.optimization.CspaceFreePolytope.FindPolytopeGivenLagrangianOptions.ellipsoid_margin_cost" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CspaceFreePolytope.FindPolytopeGivenLagrangianOptions.ellipsoid_margin_epsilon">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ellipsoid_margin_epsilon</span></span><a class="headerlink" href="#pydrake.geometry.optimization.CspaceFreePolytope.FindPolytopeGivenLagrangianOptions.ellipsoid_margin_epsilon" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CspaceFreePolytope.FindPolytopeGivenLagrangianOptions.s_inner_pts">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">s_inner_pts</span></span><a class="headerlink" href="#pydrake.geometry.optimization.CspaceFreePolytope.FindPolytopeGivenLagrangianOptions.s_inner_pts" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CspaceFreePolytope.FindPolytopeGivenLagrangianOptions.search_s_bounds_lagrangians">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">search_s_bounds_lagrangians</span></span><a class="headerlink" href="#pydrake.geometry.optimization.CspaceFreePolytope.FindPolytopeGivenLagrangianOptions.search_s_bounds_lagrangians" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CspaceFreePolytope.FindPolytopeGivenLagrangianOptions.solver_id">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">solver_id</span></span><a class="headerlink" href="#pydrake.geometry.optimization.CspaceFreePolytope.FindPolytopeGivenLagrangianOptions.solver_id" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CspaceFreePolytope.FindPolytopeGivenLagrangianOptions.solver_options">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">solver_options</span></span><a class="headerlink" href="#pydrake.geometry.optimization.CspaceFreePolytope.FindPolytopeGivenLagrangianOptions.solver_options" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CspaceFreePolytope.FindSeparationCertificateGivenPolytope">
<span class="sig-name descname"><span class="pre">FindSeparationCertificateGivenPolytope</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">self:</span> <span class="pre">pydrake.geometry.optimization.CspaceFreePolytope,</span> <span class="pre">C:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous],</span> <span class="pre">d:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]],</span> <span class="pre">ignored_collision_pairs:</span> <span class="pre">Set[Tuple[pydrake.geometry.GeometryId]],</span> <span class="pre">options:</span> <span class="pre">drake::geometry::optimization::CspaceFreePolytope::FindSeparationCertificateGivenPolytopeOptions</span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tuple[bool,</span> <span class="pre">Dict[Tuple[pydrake.geometry.GeometryId],</span> <span class="pre">drake::geometry::optimization::CspaceFreePolytope::SeparationCertificateResult]]</span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.CspaceFreePolytope.FindSeparationCertificateGivenPolytope" title="Permalink to this definition"></a></dt>
<dd><p>Finds the certificates that the C-space polytope {s | C*s&lt;=d, s_lower
&lt;= s &lt;= s_upper} is collision free.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">C</span></code>:</dt><dd><p>The C-space polytope is {s | C*s&lt;=d, s_lower&lt;=s&lt;=s_upper}</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">d</span></code>:</dt><dd><p>The C-space polytope is {s | C*s&lt;=d, s_lower&lt;=s&lt;=s_upper}</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">ignored_collision_pairs</span></code>:</dt><dd><p>We will ignore the pair of geometries in
<code class="docutils literal notranslate"><span class="pre">ignored_collision_pairs</span></code>.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">certificates</span></code>:</dt><dd><p>Contains the certificate we successfully found for each pair of
geometries. Notice that depending on <code class="docutils literal notranslate"><span class="pre">options</span></code>, the program
could search for the certificate for each geometry pair in
parallel, and will terminate the search once it fails to find the
certificate for any pair.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">success</span></code>:</dt><dd><p>If true, then we have certified that the C-space polytope {s |
C*s&lt;=d, s_lower&lt;=s&lt;=s_upper} is collision free. Otherwise
success=false.</p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CspaceFreePolytope.FindSeparationCertificateGivenPolytopeOptions">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">FindSeparationCertificateGivenPolytopeOptions</span></span><a class="headerlink" href="#pydrake.geometry.optimization.CspaceFreePolytope.FindSeparationCertificateGivenPolytopeOptions" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.geometry.optimization.FindSeparationCertificateOptions" title="pydrake.geometry.optimization.FindSeparationCertificateOptions"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.geometry.optimization.FindSeparationCertificateOptions</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CspaceFreePolytope.FindSeparationCertificateGivenPolytopeOptions.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.CspaceFreePolytope.FindSeparationCertificateGivenPolytopeOptions" title="pydrake.geometry.optimization.CspaceFreePolytope.FindSeparationCertificateGivenPolytopeOptions"><span class="pre">pydrake.geometry.optimization.CspaceFreePolytope.FindSeparationCertificateGivenPolytopeOptions</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.CspaceFreePolytope.FindSeparationCertificateGivenPolytopeOptions.__init__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CspaceFreePolytope.FindSeparationCertificateGivenPolytopeOptions.ignore_redundant_C">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ignore_redundant_C</span></span><a class="headerlink" href="#pydrake.geometry.optimization.CspaceFreePolytope.FindSeparationCertificateGivenPolytopeOptions.ignore_redundant_C" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CspaceFreePolytope.MakeIsGeometrySeparableProgram">
<span class="sig-name descname"><span class="pre">MakeIsGeometrySeparableProgram</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.CspaceFreePolytope" title="pydrake.geometry.optimization.CspaceFreePolytope"><span class="pre">pydrake.geometry.optimization.CspaceFreePolytope</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">geometry_pair</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.GeometryId" title="pydrake.geometry.GeometryId"><span class="pre">pydrake.geometry.GeometryId</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">C</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.f_contiguous</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">drake::geometry::optimization::CspaceFreePolytope::SeparationCertificateProgram</span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.CspaceFreePolytope.MakeIsGeometrySeparableProgram" title="Permalink to this definition"></a></dt>
<dd><p>Constructs the MathematicalProgram which searches for a separation
certificate for a pair of geometries for a C-space polytope. Search
for the separation certificate for a pair of geometries for a C-space
polytope {s | C*s&lt;=d, s_lower&lt;=s&lt;=s_upper}.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>an error if this geometry_pair doesn't need separation</strong> – </p></li>
<li><p><strong>certificate</strong><strong> (</strong><strong>for example</strong><strong>, </strong><strong>they are on the same body</strong><strong>)</strong><strong></strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CspaceFreePolytope.SearchResult">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">SearchResult</span></span><a class="headerlink" href="#pydrake.geometry.optimization.CspaceFreePolytope.SearchResult" title="Permalink to this definition"></a></dt>
<dd><p>Result on searching the C-space polytope and separating planes.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CspaceFreePolytope.SearchResult.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.CspaceFreePolytope.SearchResult" title="pydrake.geometry.optimization.CspaceFreePolytope.SearchResult"><span class="pre">pydrake.geometry.optimization.CspaceFreePolytope.SearchResult</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.CspaceFreePolytope.SearchResult.__init__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CspaceFreePolytope.SearchResult.a">
<span class="sig-name descname"><span class="pre">a</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.CspaceFreePolytope.SearchResult" title="pydrake.geometry.optimization.CspaceFreePolytope.SearchResult"><span class="pre">pydrake.geometry.optimization.CspaceFreePolytope.SearchResult</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Dict</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.CspaceFreePolytope.SearchResult.a" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CspaceFreePolytope.SearchResult.b">
<span class="sig-name descname"><span class="pre">b</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.CspaceFreePolytope.SearchResult" title="pydrake.geometry.optimization.CspaceFreePolytope.SearchResult"><span class="pre">pydrake.geometry.optimization.CspaceFreePolytope.SearchResult</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Dict</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Polynomial" title="pydrake.symbolic.Polynomial"><span class="pre">pydrake.symbolic.Polynomial</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.CspaceFreePolytope.SearchResult.b" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CspaceFreePolytope.SearchResult.C">
<span class="sig-name descname"><span class="pre">C</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.CspaceFreePolytope.SearchResult" title="pydrake.geometry.optimization.CspaceFreePolytope.SearchResult"><span class="pre">pydrake.geometry.optimization.CspaceFreePolytope.SearchResult</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.CspaceFreePolytope.SearchResult.C" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CspaceFreePolytope.SearchResult.certified_polytope">
<span class="sig-name descname"><span class="pre">certified_polytope</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.CspaceFreePolytope.SearchResult" title="pydrake.geometry.optimization.CspaceFreePolytope.SearchResult"><span class="pre">pydrake.geometry.optimization.CspaceFreePolytope.SearchResult</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.geometry.optimization.HPolyhedron" title="pydrake.geometry.optimization.HPolyhedron"><span class="pre">pydrake.geometry.optimization.HPolyhedron</span></a></span></span><a class="headerlink" href="#pydrake.geometry.optimization.CspaceFreePolytope.SearchResult.certified_polytope" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CspaceFreePolytope.SearchResult.d">
<span class="sig-name descname"><span class="pre">d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.CspaceFreePolytope.SearchResult" title="pydrake.geometry.optimization.CspaceFreePolytope.SearchResult"><span class="pre">pydrake.geometry.optimization.CspaceFreePolytope.SearchResult</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.CspaceFreePolytope.SearchResult.d" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CspaceFreePolytope.SearchResult.num_iter">
<span class="sig-name descname"><span class="pre">num_iter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.CspaceFreePolytope.SearchResult" title="pydrake.geometry.optimization.CspaceFreePolytope.SearchResult"><span class="pre">pydrake.geometry.optimization.CspaceFreePolytope.SearchResult</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.CspaceFreePolytope.SearchResult.num_iter" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CspaceFreePolytope.SearchWithBilinearAlternation">
<span class="sig-name descname"><span class="pre">SearchWithBilinearAlternation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">self:</span> <span class="pre">pydrake.geometry.optimization.CspaceFreePolytope,</span> <span class="pre">ignored_collision_pairs:</span> <span class="pre">Set[Tuple[pydrake.geometry.GeometryId]],</span> <span class="pre">C_init:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous],</span> <span class="pre">d_init:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]],</span> <span class="pre">options:</span> <span class="pre">drake::geometry::optimization::CspaceFreePolytope::BilinearAlternationOptions</span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List[drake::geometry::optimization::CspaceFreePolytope::SearchResult]</span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.CspaceFreePolytope.SearchWithBilinearAlternation" title="Permalink to this definition"></a></dt>
<dd><p>Search for a collision-free C-space polytope. {s | C*s&lt;=d,
s_lower&lt;=s&lt;=s_upper} through bilinear alternation. The goal is to
maximize the volume the C-space polytope. Since we can’t compute the
polytope volume in the closed form, we use the volume of the maximal
inscribed ellipsoid as a surrogate function of the polytope volume.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">ignored_collision_pairs</span></code>:</dt><dd><p>The pairs of geometries that we ignore when searching for
separation certificates.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">C_init</span></code>:</dt><dd><p>The initial value of C.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">d_init</span></code>:</dt><dd><p>The initial value of d.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">options</span></code>:</dt><dd><p>The options for the bilinear alternation.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">results</span></code>:</dt><dd><p>Stores the certification result in each iteration of the bilinear
alternation.</p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CspaceFreePolytope.SeparatingPlaneLagrangians">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">SeparatingPlaneLagrangians</span></span><a class="headerlink" href="#pydrake.geometry.optimization.CspaceFreePolytope.SeparatingPlaneLagrangians" title="Permalink to this definition"></a></dt>
<dd><p>When searching for the separating plane, we want to certify that the
numerator of a rational is non-negative in the C-space region C*s&lt;=d,
s_lower &lt;= s &lt;= s_upper. Hence for each of the rational we will
introduce Lagrangian multipliers for the polytopic constraint d-C*s &gt;=
0, s - s_lower &gt;= 0, s_upper - s &gt;= 0.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CspaceFreePolytope.SeparatingPlaneLagrangians.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.CspaceFreePolytope.SeparatingPlaneLagrangians" title="pydrake.geometry.optimization.CspaceFreePolytope.SeparatingPlaneLagrangians"><span class="pre">pydrake.geometry.optimization.CspaceFreePolytope.SeparatingPlaneLagrangians</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">C_rows</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.CspaceFreePolytope.SeparatingPlaneLagrangians.__init__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CspaceFreePolytope.SeparatingPlaneLagrangians.GetSolution">
<span class="sig-name descname"><span class="pre">GetSolution</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.CspaceFreePolytope.SeparatingPlaneLagrangians" title="pydrake.geometry.optimization.CspaceFreePolytope.SeparatingPlaneLagrangians"><span class="pre">pydrake.geometry.optimization.CspaceFreePolytope.SeparatingPlaneLagrangians</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">result</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.solvers.html#pydrake.solvers.MathematicalProgramResult" title="pydrake.solvers.MathematicalProgramResult"><span class="pre">pydrake.solvers.MathematicalProgramResult</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.geometry.optimization.CspaceFreePolytope.SeparatingPlaneLagrangians" title="pydrake.geometry.optimization.CspaceFreePolytope.SeparatingPlaneLagrangians"><span class="pre">pydrake.geometry.optimization.CspaceFreePolytope.SeparatingPlaneLagrangians</span></a></span></span><a class="headerlink" href="#pydrake.geometry.optimization.CspaceFreePolytope.SeparatingPlaneLagrangians.GetSolution" title="Permalink to this definition"></a></dt>
<dd><p>Substitutes the decision variables in each Lagrangians with its value
in result, returns the substitution result.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CspaceFreePolytope.SeparatingPlaneLagrangians.polytope">
<span class="sig-name descname"><span class="pre">polytope</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.CspaceFreePolytope.SeparatingPlaneLagrangians" title="pydrake.geometry.optimization.CspaceFreePolytope.SeparatingPlaneLagrangians"><span class="pre">pydrake.geometry.optimization.CspaceFreePolytope.SeparatingPlaneLagrangians</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.CspaceFreePolytope.SeparatingPlaneLagrangians.polytope" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CspaceFreePolytope.SeparatingPlaneLagrangians.s_lower">
<span class="sig-name descname"><span class="pre">s_lower</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.CspaceFreePolytope.SeparatingPlaneLagrangians" title="pydrake.geometry.optimization.CspaceFreePolytope.SeparatingPlaneLagrangians"><span class="pre">pydrake.geometry.optimization.CspaceFreePolytope.SeparatingPlaneLagrangians</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.CspaceFreePolytope.SeparatingPlaneLagrangians.s_lower" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CspaceFreePolytope.SeparatingPlaneLagrangians.s_upper">
<span class="sig-name descname"><span class="pre">s_upper</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.CspaceFreePolytope.SeparatingPlaneLagrangians" title="pydrake.geometry.optimization.CspaceFreePolytope.SeparatingPlaneLagrangians"><span class="pre">pydrake.geometry.optimization.CspaceFreePolytope.SeparatingPlaneLagrangians</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.CspaceFreePolytope.SeparatingPlaneLagrangians.s_upper" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CspaceFreePolytope.SeparationCertificate">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">SeparationCertificate</span></span><a class="headerlink" href="#pydrake.geometry.optimization.CspaceFreePolytope.SeparationCertificate" title="Permalink to this definition"></a></dt>
<dd><p>This struct stores the necessary information to search for the
separating plane for the polytopic C-space region C*s &lt;= d, s_lower &lt;=
s &lt;= s_upper. We need to impose that N rationals are non-negative in
this C-space polytope. The denominator of each rational is always
positive hence we need to impose the N numerators are non-negative in
this C-space region. We impose the condition numerator_i(s) - λ(s)ᵀ *
(d - C*s) - λ_lower(s)ᵀ * (s - s_lower) -λ_upper(s)ᵀ * (s_upper - s)
is sos λ(s) are sos, λ_lower(s) are sos, λ_upper(s) are sos.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CspaceFreePolytope.SeparationCertificate.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.geometry.optimization.CspaceFreePolytope.SeparationCertificate.__init__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CspaceFreePolytope.SeparationCertificate.GetSolution">
<span class="sig-name descname"><span class="pre">GetSolution</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.CspaceFreePolytope.SeparationCertificate" title="pydrake.geometry.optimization.CspaceFreePolytope.SeparationCertificate"><span class="pre">pydrake.geometry.optimization.CspaceFreePolytope.SeparationCertificate</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">plane_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Polynomial" title="pydrake.symbolic.Polynomial"><span class="pre">pydrake.symbolic.Polynomial</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">plane_decision_vars</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">result</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.solvers.html#pydrake.solvers.MathematicalProgramResult" title="pydrake.solvers.MathematicalProgramResult"><span class="pre">pydrake.solvers.MathematicalProgramResult</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.geometry.optimization.CspaceFreePolytope.SeparationCertificateResult" title="pydrake.geometry.optimization.CspaceFreePolytope.SeparationCertificateResult"><span class="pre">pydrake.geometry.optimization.CspaceFreePolytope.SeparationCertificateResult</span></a></span></span><a class="headerlink" href="#pydrake.geometry.optimization.CspaceFreePolytope.SeparationCertificate.GetSolution" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CspaceFreePolytope.SeparationCertificate.negative_side_rational_lagrangians">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">negative_side_rational_lagrangians</span></span><a class="headerlink" href="#pydrake.geometry.optimization.CspaceFreePolytope.SeparationCertificate.negative_side_rational_lagrangians" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CspaceFreePolytope.SeparationCertificate.positive_side_rational_lagrangians">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">positive_side_rational_lagrangians</span></span><a class="headerlink" href="#pydrake.geometry.optimization.CspaceFreePolytope.SeparationCertificate.positive_side_rational_lagrangians" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CspaceFreePolytope.SeparationCertificateProgram">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">SeparationCertificateProgram</span></span><a class="headerlink" href="#pydrake.geometry.optimization.CspaceFreePolytope.SeparationCertificateProgram" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.geometry.optimization.SeparationCertificateProgramBase" title="pydrake.geometry.optimization.SeparationCertificateProgramBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.geometry.optimization.SeparationCertificateProgramBase</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CspaceFreePolytope.SeparationCertificateProgram.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.CspaceFreePolytope.SeparationCertificateProgram" title="pydrake.geometry.optimization.CspaceFreePolytope.SeparationCertificateProgram"><span class="pre">pydrake.geometry.optimization.CspaceFreePolytope.SeparationCertificateProgram</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.CspaceFreePolytope.SeparationCertificateProgram.__init__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CspaceFreePolytope.SeparationCertificateProgram.certificate">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">certificate</span></span><a class="headerlink" href="#pydrake.geometry.optimization.CspaceFreePolytope.SeparationCertificateProgram.certificate" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CspaceFreePolytope.SeparationCertificateProgram.plane_index">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">plane_index</span></span><a class="headerlink" href="#pydrake.geometry.optimization.CspaceFreePolytope.SeparationCertificateProgram.plane_index" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CspaceFreePolytope.SeparationCertificateResult">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">SeparationCertificateResult</span></span><a class="headerlink" href="#pydrake.geometry.optimization.CspaceFreePolytope.SeparationCertificateResult" title="Permalink to this definition"></a></dt>
<dd><p>We certify that a pair of geometries is collision free in the C-space
region {s | Cs&lt;=d, s_lower&lt;=s&lt;=s_upper} by finding the separating
plane and the Lagrangian multipliers. This struct contains the
certificate, that the separating plane {x | aᵀx+b=0 } separates the
two geometries in separating_planes()[plane_index] in the C-space
polytope.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CspaceFreePolytope.SeparationCertificateResult.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.geometry.optimization.CspaceFreePolytope.SeparationCertificateResult.__init__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CspaceFreePolytope.SeparationCertificateResult.a">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">a</span></span><a class="headerlink" href="#pydrake.geometry.optimization.CspaceFreePolytope.SeparationCertificateResult.a" title="Permalink to this definition"></a></dt>
<dd><p>The separating plane is { x | aᵀx+b=0 }</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CspaceFreePolytope.SeparationCertificateResult.b">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">b</span></span><a class="headerlink" href="#pydrake.geometry.optimization.CspaceFreePolytope.SeparationCertificateResult.b" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CspaceFreePolytope.SeparationCertificateResult.negative_side_rational_lagrangians">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">negative_side_rational_lagrangians</span></span><a class="headerlink" href="#pydrake.geometry.optimization.CspaceFreePolytope.SeparationCertificateResult.negative_side_rational_lagrangians" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CspaceFreePolytope.SeparationCertificateResult.plane_decision_var_vals">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">plane_decision_var_vals</span></span><a class="headerlink" href="#pydrake.geometry.optimization.CspaceFreePolytope.SeparationCertificateResult.plane_decision_var_vals" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CspaceFreePolytope.SeparationCertificateResult.plane_index">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">plane_index</span></span><a class="headerlink" href="#pydrake.geometry.optimization.CspaceFreePolytope.SeparationCertificateResult.plane_index" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CspaceFreePolytope.SeparationCertificateResult.positive_side_rational_lagrangians">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">positive_side_rational_lagrangians</span></span><a class="headerlink" href="#pydrake.geometry.optimization.CspaceFreePolytope.SeparationCertificateResult.positive_side_rational_lagrangians" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CspaceFreePolytope.SeparationCertificateResult.result">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">result</span></span><a class="headerlink" href="#pydrake.geometry.optimization.CspaceFreePolytope.SeparationCertificateResult.result" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CspaceFreePolytope.SolveSeparationCertificateProgram">
<span class="sig-name descname"><span class="pre">SolveSeparationCertificateProgram</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self:</span> <span class="pre">pydrake.geometry.optimization.CspaceFreePolytope</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">certificate_program:</span> <span class="pre">drake::geometry::optimization::CspaceFreePolytope::SeparationCertificateProgram</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options:</span> <span class="pre">drake::geometry::optimization::CspaceFreePolytope::FindSeparationCertificateGivenPolytopeOptions</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Optional[drake::geometry::optimization::CspaceFreePolytope::SeparationCertificateResult]</span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.CspaceFreePolytope.SolveSeparationCertificateProgram" title="Permalink to this definition"></a></dt>
<dd><p>Solves a SeparationCertificateProgram with the given options</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>result If we find the separation certificate, then <code class="docutils literal notranslate"><span class="pre">result</span></code>
contains the separation plane and the Lagrangian polynomials;
otherwise result is empty.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CspaceFreePolytopeBase">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.geometry.optimization.</span></span><span class="sig-name descname"><span class="pre">CspaceFreePolytopeBase</span></span><a class="headerlink" href="#pydrake.geometry.optimization.CspaceFreePolytopeBase" title="Permalink to this definition"></a></dt>
<dd><p>This virtual class is the base of CspaceFreePolytope and
CspaceFreeBox. We take the common functionality between these concrete
derived class to this shared parent class.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CspaceFreePolytopeBase.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.geometry.optimization.CspaceFreePolytopeBase.__init__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CspaceFreePolytopeBase.map_geometries_to_separating_planes">
<span class="sig-name descname"><span class="pre">map_geometries_to_separating_planes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.CspaceFreePolytopeBase" title="pydrake.geometry.optimization.CspaceFreePolytopeBase"><span class="pre">pydrake.geometry.optimization.CspaceFreePolytopeBase</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Dict</span><span class="p"><span class="pre">[</span></span><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.GeometryId" title="pydrake.geometry.GeometryId"><span class="pre">pydrake.geometry.GeometryId</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.CspaceFreePolytopeBase.map_geometries_to_separating_planes" title="Permalink to this definition"></a></dt>
<dd><p>separating_planes()[map_geometries_to_separating_planes.at(geometry1_id,
geometry2_id)] is the separating plane that separates geometry 1 and
geometry 2.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CspaceFreePolytopeBase.Options">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Options</span></span><a class="headerlink" href="#pydrake.geometry.optimization.CspaceFreePolytopeBase.Options" title="Permalink to this definition"></a></dt>
<dd><p>Optional argument for constructing CspaceFreePolytopeBase</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CspaceFreePolytopeBase.Options.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.CspaceFreePolytopeBase.Options" title="pydrake.geometry.optimization.CspaceFreePolytopeBase.Options"><span class="pre">pydrake.geometry.optimization.CspaceFreePolytopeBase.Options</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.CspaceFreePolytopeBase.Options.__init__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CspaceFreePolytopeBase.Options.with_cross_y">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">with_cross_y</span></span><a class="headerlink" href="#pydrake.geometry.optimization.CspaceFreePolytopeBase.Options.with_cross_y" title="Permalink to this definition"></a></dt>
<dd><p>For non-polytopic collision geometries, we will impose a matrix-sos
constraint X(s) being psd, with a slack indeterminates y, such that
the polynomial</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>p(s, y) = ⌈ 1 ⌉ᵀ * X(s) * ⌈ 1 ⌉
⌊ y ⌋           ⌊ y ⌋
</pre></div>
</div>
</details><p>is positive. This p(s, y) polynomial doesn’t contain the cross term of
y (namely it doesn’t have y(i)*y(j), i≠j). When we select the monomial
basis for this polynomial, we can also exclude the cross term of y in
the monomial basis.</p>
<p>To illustrate the idea, let’s consider the following toy example: if
we want to certify that a(0) + a(1)*y₀ + a(2)*y₁ + a(3)*y₀² + a(4)*y₁²
is positive (this polynomial doesn’t have the cross term y₀*y₁), we
can write it as</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>⌈ 1⌉ᵀ * A₀ * ⌈ 1⌉ + ⌈ 1⌉ᵀ * A₁ * ⌈ 1⌉
⌊y₀⌋         ⌊y₀⌋   ⌊y₁⌋         ⌊y₁⌋
</pre></div>
</div>
</details><p>with two small psd matrices A₀, A₁ Instead of</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>⌈ 1⌉ᵀ * A * ⌈ 1⌉
|y₀|        |y₀|
⌊y₁⌋        ⌊y₁⌋
</pre></div>
</div>
</details><p>with one large psd matrix A. The first parameterization won’t have the
cross term y₀*y₁ by construction, while the second parameterization
requires imposing extra constraints on certain off-diagonal terms in A
so that the cross term vanishes.</p>
<p>If we set with_cross_y = false, then we will use the monomial basis
that doesn’t generate cross terms of y, leading to smaller size sos
problems. If we set with_cross_y = true, then we will use the monomial
basis that will generate cross terms of y, causing larger size sos
problems, but possibly able to certify a larger C-space polytope.</p>
</dd></dl>

</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CspaceFreePolytopeBase.separating_planes">
<span class="sig-name descname"><span class="pre">separating_planes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.CspaceFreePolytopeBase" title="pydrake.geometry.optimization.CspaceFreePolytopeBase"><span class="pre">pydrake.geometry.optimization.CspaceFreePolytopeBase</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#pydrake.geometry.optimization.CSpaceSeparatingPlane_" title="pydrake.geometry.optimization.CSpaceSeparatingPlane_"><span class="pre">pydrake.geometry.optimization.CSpaceSeparatingPlane_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Variable</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.CspaceFreePolytopeBase.separating_planes" title="Permalink to this definition"></a></dt>
<dd><p>All the separating planes between each pair of geometries.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CspaceFreePolytopeBase.y_slack">
<span class="sig-name descname"><span class="pre">y_slack</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.CspaceFreePolytopeBase" title="pydrake.geometry.optimization.CspaceFreePolytopeBase"><span class="pre">pydrake.geometry.optimization.CspaceFreePolytopeBase</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.CspaceFreePolytopeBase.y_slack" title="Permalink to this definition"></a></dt>
<dd><p>Get the slack variable used for non-polytopic collision geometries.
Check Options class for more details.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CSpaceSeparatingPlane">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.geometry.optimization.</span></span><span class="sig-name descname"><span class="pre">CSpaceSeparatingPlane</span></span><a class="headerlink" href="#pydrake.geometry.optimization.CSpaceSeparatingPlane" title="Permalink to this definition"></a></dt>
<dd><p>Wraps the information that a pair of collision geometries are
separated by a plane. One collision geometry is on the “positive” side
of the separating plane, namely {x| aᵀx + b ≥ δ} (with δ ≥ 0}, and the
other collision geometry is on the “negative” side of the separating
plane, namely {x|aᵀx+b ≤ −δ}.</p>
<dl class="simple">
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">T</span></code>:</dt><dd><p>The type of decision_variables. T= symbolic::Variable or double.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <a class="reference internal" href="#pydrake.geometry.optimization.CSpaceSeparatingPlane_" title="pydrake.geometry.optimization.CSpaceSeparatingPlane_"><code class="xref py py-class docutils literal notranslate"><span class="pre">CSpaceSeparatingPlane_</span></code></a>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CSpaceSeparatingPlane.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.geometry.optimization.CSpaceSeparatingPlane.__init__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CSpaceSeparatingPlane.a">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">a</span></span><a class="headerlink" href="#pydrake.geometry.optimization.CSpaceSeparatingPlane.a" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CSpaceSeparatingPlane.b">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">b</span></span><a class="headerlink" href="#pydrake.geometry.optimization.CSpaceSeparatingPlane.b" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CSpaceSeparatingPlane.decision_variables">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">decision_variables</span></span><a class="headerlink" href="#pydrake.geometry.optimization.CSpaceSeparatingPlane.decision_variables" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CSpaceSeparatingPlane.expressed_body">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">expressed_body</span></span><a class="headerlink" href="#pydrake.geometry.optimization.CSpaceSeparatingPlane.expressed_body" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CSpaceSeparatingPlane.negative_side_geometry">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">negative_side_geometry</span></span><a class="headerlink" href="#pydrake.geometry.optimization.CSpaceSeparatingPlane.negative_side_geometry" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CSpaceSeparatingPlane.plane_degree">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">plane_degree</span></span><a class="headerlink" href="#pydrake.geometry.optimization.CSpaceSeparatingPlane.plane_degree" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CSpaceSeparatingPlane.positive_side_geometry">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">positive_side_geometry</span></span><a class="headerlink" href="#pydrake.geometry.optimization.CSpaceSeparatingPlane.positive_side_geometry" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CSpaceSeparatingPlane_">
<em class="property"><span class="pre">template</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.geometry.optimization.</span></span><span class="sig-name descname"><span class="pre">CSpaceSeparatingPlane_</span></span><a class="headerlink" href="#pydrake.geometry.optimization.CSpaceSeparatingPlane_" title="Permalink to this definition"></a></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">CSpaceSeparatingPlane_[float]</span></code>, <a class="reference internal" href="#pydrake.geometry.optimization.CSpaceSeparatingPlane_-Variable" title="pydrake.geometry.optimization.CSpaceSeparatingPlane_[Variable]"><code class="xref py py-class docutils literal notranslate"><span class="pre">CSpaceSeparatingPlane_[Variable]</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CSpaceSeparatingPlane_-Variable">
<span id="pydrake.geometry.optimization.CSpaceSeparatingPlane_[Variable]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.geometry.optimization.</span></span><span class="sig-name descname"><span class="pre">CSpaceSeparatingPlane_[Variable]</span></span><a class="headerlink" href="#pydrake.geometry.optimization.CSpaceSeparatingPlane_-Variable" title="Permalink to this definition"></a></dt>
<dd><p>Wraps the information that a pair of collision geometries are
separated by a plane. One collision geometry is on the “positive” side
of the separating plane, namely {x| aᵀx + b ≥ δ} (with δ ≥ 0}, and the
other collision geometry is on the “negative” side of the separating
plane, namely {x|aᵀx+b ≤ −δ}.</p>
<dl class="simple">
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">T</span></code>:</dt><dd><p>The type of decision_variables. T= symbolic::Variable or double.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CSpaceSeparatingPlane_-Variable-.__init__">
<span id="pydrake.geometry.optimization.CSpaceSeparatingPlane_[Variable].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.geometry.optimization.CSpaceSeparatingPlane_-Variable-.__init__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CSpaceSeparatingPlane_-Variable-.a">
<span id="pydrake.geometry.optimization.CSpaceSeparatingPlane_[Variable].a"></span><em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">a</span></span><a class="headerlink" href="#pydrake.geometry.optimization.CSpaceSeparatingPlane_-Variable-.a" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CSpaceSeparatingPlane_-Variable-.b">
<span id="pydrake.geometry.optimization.CSpaceSeparatingPlane_[Variable].b"></span><em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">b</span></span><a class="headerlink" href="#pydrake.geometry.optimization.CSpaceSeparatingPlane_-Variable-.b" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CSpaceSeparatingPlane_-Variable-.decision_variables">
<span id="pydrake.geometry.optimization.CSpaceSeparatingPlane_[Variable].decision_variables"></span><em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">decision_variables</span></span><a class="headerlink" href="#pydrake.geometry.optimization.CSpaceSeparatingPlane_-Variable-.decision_variables" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CSpaceSeparatingPlane_-Variable-.expressed_body">
<span id="pydrake.geometry.optimization.CSpaceSeparatingPlane_[Variable].expressed_body"></span><em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">expressed_body</span></span><a class="headerlink" href="#pydrake.geometry.optimization.CSpaceSeparatingPlane_-Variable-.expressed_body" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CSpaceSeparatingPlane_-Variable-.negative_side_geometry">
<span id="pydrake.geometry.optimization.CSpaceSeparatingPlane_[Variable].negative_side_geometry"></span><em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">negative_side_geometry</span></span><a class="headerlink" href="#pydrake.geometry.optimization.CSpaceSeparatingPlane_-Variable-.negative_side_geometry" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CSpaceSeparatingPlane_-Variable-.plane_degree">
<span id="pydrake.geometry.optimization.CSpaceSeparatingPlane_[Variable].plane_degree"></span><em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">plane_degree</span></span><a class="headerlink" href="#pydrake.geometry.optimization.CSpaceSeparatingPlane_-Variable-.plane_degree" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.CSpaceSeparatingPlane_-Variable-.positive_side_geometry">
<span id="pydrake.geometry.optimization.CSpaceSeparatingPlane_[Variable].positive_side_geometry"></span><em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">positive_side_geometry</span></span><a class="headerlink" href="#pydrake.geometry.optimization.CSpaceSeparatingPlane_-Variable-.positive_side_geometry" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.FindSeparationCertificateOptions">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.geometry.optimization.</span></span><span class="sig-name descname"><span class="pre">FindSeparationCertificateOptions</span></span><a class="headerlink" href="#pydrake.geometry.optimization.FindSeparationCertificateOptions" title="Permalink to this definition"></a></dt>
<dd><dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.FindSeparationCertificateOptions.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.FindSeparationCertificateOptions" title="pydrake.geometry.optimization.FindSeparationCertificateOptions"><span class="pre">pydrake.geometry.optimization.FindSeparationCertificateOptions</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.FindSeparationCertificateOptions.__init__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.FindSeparationCertificateOptions.num_threads">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">num_threads</span></span><a class="headerlink" href="#pydrake.geometry.optimization.FindSeparationCertificateOptions.num_threads" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.FindSeparationCertificateOptions.parallelism">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">parallelism</span></span><a class="headerlink" href="#pydrake.geometry.optimization.FindSeparationCertificateOptions.parallelism" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.FindSeparationCertificateOptions.solver_id">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">solver_id</span></span><a class="headerlink" href="#pydrake.geometry.optimization.FindSeparationCertificateOptions.solver_id" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.FindSeparationCertificateOptions.solver_options">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">solver_options</span></span><a class="headerlink" href="#pydrake.geometry.optimization.FindSeparationCertificateOptions.solver_options" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.FindSeparationCertificateOptions.terminate_at_failure">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">terminate_at_failure</span></span><a class="headerlink" href="#pydrake.geometry.optimization.FindSeparationCertificateOptions.terminate_at_failure" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.FindSeparationCertificateOptions.verbose">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">verbose</span></span><a class="headerlink" href="#pydrake.geometry.optimization.FindSeparationCertificateOptions.verbose" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.GraphOfConvexSets">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.geometry.optimization.</span></span><span class="sig-name descname"><span class="pre">GraphOfConvexSets</span></span><a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets" title="Permalink to this definition"></a></dt>
<dd><p>GraphOfConvexSets (GCS) implements the design pattern and optimization
problems first introduced in the paper “Shortest Paths in Graphs of
Convex Sets”.</p>
<p>“Shortest Paths in Graphs of Convex Sets” by Tobia Marcucci, Jack
Umenberger, Pablo A. Parrilo, Russ Tedrake.
<a class="reference external" href="https://arxiv.org/abs/2101.11565">https://arxiv.org/abs/2101.11565</a></p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This feature is considered to be <strong>experimental</strong> and may change
or be removed at any time, without any deprecation notice ahead of
time.</p>
</div>
<p>Each vertex in the graph is associated with a convex set over
continuous variables, edges in the graph contain convex costs and
constraints on these continuous variables. We can then formulate
optimization problems over this graph, such as the shortest path
problem where each visit to a vertex also corresponds to selecting an
element from the convex set subject to the costs and constraints.
Behind the scenes, we construct efficient mixed-integer convex
transcriptions of the graph problem using MathematicalProgram.</p>
<p>Design note: This class avoids providing any direct access to the
MathematicalProgram that it constructs nor to the decision variables /
constraints. The users should be able to write constraints against
“placeholder” decision variables on the vertices and edges, but these
get translated in non-trivial ways to the underlying program.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.GraphOfConvexSets.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.GraphOfConvexSets" title="pydrake.geometry.optimization.GraphOfConvexSets"><span class="pre">pydrake.geometry.optimization.GraphOfConvexSets</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Constructs an empty graph.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.GraphOfConvexSets.AddEdge">
<span class="sig-name descname"><span class="pre">AddEdge</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.GraphOfConvexSets" title="pydrake.geometry.optimization.GraphOfConvexSets"><span class="pre">pydrake.geometry.optimization.GraphOfConvexSets</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">u</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.GraphOfConvexSets.Vertex" title="pydrake.geometry.optimization.GraphOfConvexSets.Vertex"><span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.Vertex</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.GraphOfConvexSets.Vertex" title="pydrake.geometry.optimization.GraphOfConvexSets.Vertex"><span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.Vertex</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">''</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.geometry.optimization.GraphOfConvexSets.Edge" title="pydrake.geometry.optimization.GraphOfConvexSets.Edge"><span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.Edge</span></a></span></span><a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.AddEdge" title="Permalink to this definition"></a></dt>
<dd><p>Adds an edge to the graph from Vertex <code class="docutils literal notranslate"><span class="pre">u</span></code> to Vertex <code class="docutils literal notranslate"><span class="pre">v</span></code>. The
vertex references must refer to valid vertices in this graph. If
<code class="docutils literal notranslate"><span class="pre">name</span></code> is empty then a default name will be provided.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.GraphOfConvexSets.AddVertex">
<span class="sig-name descname"><span class="pre">AddVertex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.GraphOfConvexSets" title="pydrake.geometry.optimization.GraphOfConvexSets"><span class="pre">pydrake.geometry.optimization.GraphOfConvexSets</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">set</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.ConvexSet" title="pydrake.geometry.optimization.ConvexSet"><span class="pre">pydrake.geometry.optimization.ConvexSet</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">''</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.geometry.optimization.GraphOfConvexSets.Vertex" title="pydrake.geometry.optimization.GraphOfConvexSets.Vertex"><span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.Vertex</span></a></span></span><a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.AddVertex" title="Permalink to this definition"></a></dt>
<dd><p>Adds a vertex to the graph. A copy of <code class="docutils literal notranslate"><span class="pre">set</span></code> is cloned and stored
inside the graph. If <code class="docutils literal notranslate"><span class="pre">name</span></code> is empty then a default name will be
provided.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.GraphOfConvexSets.ClearAllPhiConstraints">
<span class="sig-name descname"><span class="pre">ClearAllPhiConstraints</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.GraphOfConvexSets" title="pydrake.geometry.optimization.GraphOfConvexSets"><span class="pre">pydrake.geometry.optimization.GraphOfConvexSets</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.ClearAllPhiConstraints" title="Permalink to this definition"></a></dt>
<dd><p>Removes all constraints added to any edge with AddPhiConstraint.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.GraphOfConvexSets.Edge">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Edge</span></span><a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.Edge" title="Permalink to this definition"></a></dt>
<dd><p>An edge in the graph connects between vertex <code class="docutils literal notranslate"><span class="pre">u</span></code> and vertex <code class="docutils literal notranslate"><span class="pre">v</span></code>.
The edge also holds a list of cost and constraints associated with the
continuous variables.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.GraphOfConvexSets.Edge.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.Edge.__init__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.GraphOfConvexSets.Edge.AddConstraint">
<span class="sig-name descname"><span class="pre">AddConstraint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.Edge.AddConstraint" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>AddConstraint(self: pydrake.geometry.optimization.GraphOfConvexSets.Edge, f: pydrake.symbolic.Formula) -&gt; pydrake.solvers.Binding[Constraint]</p></li>
</ol>
<p>Adds a constraint to this edge, described by a symbolic::Formula <code class="docutils literal notranslate"><span class="pre">f</span></code>
containing <em>only</em> elements of xu() and xv() as variables.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if f.GetFreeVariables</strong><strong>(</strong><strong>) </strong><strong>is not a subset of xu</strong><strong>(</strong><strong>) </strong><strong>∪</strong> – </p></li>
<li><p><strong>xv</strong><strong>(</strong><strong>)</strong><strong></strong> – </p></li>
<li><p><strong>RuntimeError if xu</strong><strong>(</strong><strong>) </strong><strong>∪ xv</strong><strong>(</strong><strong>) </strong><strong>is empty</strong><strong>, </strong><strong>i.e.</strong><strong>, </strong><strong>when both vertices</strong> – </p></li>
<li><p><strong>have an ambient dimension of zero.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>AddConstraint(self: pydrake.geometry.optimization.GraphOfConvexSets.Edge, binding: pydrake.solvers.Binding[Constraint]) -&gt; pydrake.solvers.Binding[Constraint]</p></li>
</ol>
<p>Adds a cost to this edge. <code class="docutils literal notranslate"><span class="pre">binding</span></code> must contain <em>only</em> elements of
xu() and xv() as variables. For technical reasons relating to being
able to “turn-off” the cost on inactive edges, all costs are
eventually implemented with a slack variable and a constraint:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>min g(xu, xv) ⇒ min ℓ, s.t. ℓ ≥ g(xu,xv)
</pre></div>
</div>
</details><div class="admonition note">
<p class="admonition-title">Note</p>
<p>Linear costs lead to negative costs if decision variables are not
properly constrained. Users may want to check that the solution
does not contain negative costs.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the pair &lt;ℓ, g(xu, xv)&gt;.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>RuntimeError if binding.variables</strong><strong>(</strong><strong>) </strong><strong>is not a subset of xu</strong><strong>(</strong><strong>) </strong><strong>∪</strong> – </p></li>
<li><p><strong>xv</strong><strong>(</strong><strong>)</strong><strong></strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.GraphOfConvexSets.Edge.AddCost">
<span class="sig-name descname"><span class="pre">AddCost</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.Edge.AddCost" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>AddCost(self: pydrake.geometry.optimization.GraphOfConvexSets.Edge, e: pydrake.symbolic.Expression) -&gt; Tuple[pydrake.symbolic.Variable, pydrake.solvers.Binding[Cost]]</p></li>
</ol>
<p>Adds a cost to this edge, described by a symbolic::Expression <code class="docutils literal notranslate"><span class="pre">e</span></code>
containing <em>only</em> elements of xu() and xv() as variables. For
technical reasons relating to being able to “turn-off” the cost on
inactive edges, all costs are eventually implemented with a slack
variable and a constraint:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>min g(xu, xv) ⇒ min ℓ, s.t. ℓ ≥ g(xu,xv)
</pre></div>
</div>
</details><div class="admonition note">
<p class="admonition-title">Note</p>
<p>Linear costs lead to negative costs if decision variables are not
properly constrained. Users may want to check that the solution
does not contain negative costs.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the pair &lt;ℓ, g(xu, xv)&gt;.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>RuntimeError if e.GetVariables</strong><strong>(</strong><strong>) </strong><strong>is not a subset of xu</strong><strong>(</strong><strong>) </strong><strong>∪ xv</strong><strong>(</strong><strong>)</strong><strong></strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>AddCost(self: pydrake.geometry.optimization.GraphOfConvexSets.Edge, binding: pydrake.solvers.Binding[Cost]) -&gt; Tuple[pydrake.symbolic.Variable, pydrake.solvers.Binding[Cost]]</p></li>
</ol>
<p>Adds a cost to this edge. <code class="docutils literal notranslate"><span class="pre">binding</span></code> must contain <em>only</em> elements of
xu() and xv() as variables. For technical reasons relating to being
able to “turn-off” the cost on inactive edges, all costs are
eventually implemented with a slack variable and a constraint:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>min g(xu, xv) ⇒ min ℓ, s.t. ℓ ≥ g(xu,xv)
</pre></div>
</div>
</details><div class="admonition note">
<p class="admonition-title">Note</p>
<p>Linear costs lead to negative costs if decision variables are not
properly constrained. Users may want to check that the solution
does not contain negative costs.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the pair &lt;ℓ, g(xu, xv)&gt;.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>RuntimeError if binding.variables</strong><strong>(</strong><strong>) </strong><strong>is not a subset of xu</strong><strong>(</strong><strong>) </strong><strong>∪</strong> – </p></li>
<li><p><strong>xv</strong><strong>(</strong><strong>)</strong><strong></strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.GraphOfConvexSets.Edge.AddPhiConstraint">
<span class="sig-name descname"><span class="pre">AddPhiConstraint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.GraphOfConvexSets.Edge" title="pydrake.geometry.optimization.GraphOfConvexSets.Edge"><span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.Edge</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi_value</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.Edge.AddPhiConstraint" title="Permalink to this definition"></a></dt>
<dd><p>Adds a constraint on the binary variable associated with this edge.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>We intentionally do not return a binding to the constraint created
by this call, as that would allow the caller to make nonsensical
modifications to its bounds (i.e. requiring phi == 0.5).</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.GraphOfConvexSets.Edge.ClearPhiConstraints">
<span class="sig-name descname"><span class="pre">ClearPhiConstraints</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.GraphOfConvexSets.Edge" title="pydrake.geometry.optimization.GraphOfConvexSets.Edge"><span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.Edge</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.Edge.ClearPhiConstraints" title="Permalink to this definition"></a></dt>
<dd><p>Removes any constraints added with AddPhiConstraint.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.GraphOfConvexSets.Edge.GetConstraints">
<span class="sig-name descname"><span class="pre">GetConstraints</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.GraphOfConvexSets.Edge" title="pydrake.geometry.optimization.GraphOfConvexSets.Edge"><span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.Edge</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.solvers.html#pydrake.solvers.Binding" title="pydrake.solvers.Binding"><span class="pre">pydrake.solvers.Binding</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Constraint</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.Edge.GetConstraints" title="Permalink to this definition"></a></dt>
<dd><p>Returns all constraints on this edge.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.GraphOfConvexSets.Edge.GetCosts">
<span class="sig-name descname"><span class="pre">GetCosts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.GraphOfConvexSets.Edge" title="pydrake.geometry.optimization.GraphOfConvexSets.Edge"><span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.Edge</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.solvers.html#pydrake.solvers.Binding" title="pydrake.solvers.Binding"><span class="pre">pydrake.solvers.Binding</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Cost</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.Edge.GetCosts" title="Permalink to this definition"></a></dt>
<dd><p>Returns all costs on this edge.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.GraphOfConvexSets.Edge.GetSolutionCost">
<span class="sig-name descname"><span class="pre">GetSolutionCost</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.GraphOfConvexSets.Edge" title="pydrake.geometry.optimization.GraphOfConvexSets.Edge"><span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.Edge</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">result</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.solvers.html#pydrake.solvers.MathematicalProgramResult" title="pydrake.solvers.MathematicalProgramResult"><span class="pre">pydrake.solvers.MathematicalProgramResult</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.Edge.GetSolutionCost" title="Permalink to this definition"></a></dt>
<dd><p>Returns the sum of the costs associated with this edge in a
solvers::MathematicalProgramResult.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.GraphOfConvexSets.Edge.GetSolutionPhiXu">
<span class="sig-name descname"><span class="pre">GetSolutionPhiXu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.GraphOfConvexSets.Edge" title="pydrake.geometry.optimization.GraphOfConvexSets.Edge"><span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.Edge</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">result</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.solvers.html#pydrake.solvers.MathematicalProgramResult" title="pydrake.solvers.MathematicalProgramResult"><span class="pre">pydrake.solvers.MathematicalProgramResult</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.Edge.GetSolutionPhiXu" title="Permalink to this definition"></a></dt>
<dd><p>Returns the vector value of the slack variables associated with ϕxᵤ in
a solvers::MathematicalProgramResult. This can obtain a different
value than <code class="docutils literal notranslate"><span class="pre">result.GetSolution(edge-&gt;xu())</span></code>, which is equivalent to
<code class="docutils literal notranslate"><span class="pre">result.GetSolution(edge-&gt;u()-&gt;x())</span></code>; in the case of a loose convex
relaxation <code class="docutils literal notranslate"><span class="pre">result.GetSolution(edge-&gt;xu())</span></code> will be the <em>averaged</em>
value of the edge slacks for all non-zero-flow edges.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.GraphOfConvexSets.Edge.GetSolutionPhiXv">
<span class="sig-name descname"><span class="pre">GetSolutionPhiXv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.GraphOfConvexSets.Edge" title="pydrake.geometry.optimization.GraphOfConvexSets.Edge"><span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.Edge</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">result</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.solvers.html#pydrake.solvers.MathematicalProgramResult" title="pydrake.solvers.MathematicalProgramResult"><span class="pre">pydrake.solvers.MathematicalProgramResult</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.Edge.GetSolutionPhiXv" title="Permalink to this definition"></a></dt>
<dd><p>Returns the vector value of the slack variables associated with ϕxᵥ in
a solvers::MathematicalProgramResult. See GetSolutionPhiXu().</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.GraphOfConvexSets.Edge.id">
<span class="sig-name descname"><span class="pre">id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.GraphOfConvexSets.Edge" title="pydrake.geometry.optimization.GraphOfConvexSets.Edge"><span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.Edge</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.geometry.optimization.GraphOfConvexSets.EdgeId" title="pydrake.geometry.optimization.GraphOfConvexSets.EdgeId"><span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.EdgeId</span></a></span></span><a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.Edge.id" title="Permalink to this definition"></a></dt>
<dd><p>Returns the unique identifier associated with this Edge.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.GraphOfConvexSets.Edge.name">
<span class="sig-name descname"><span class="pre">name</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.GraphOfConvexSets.Edge" title="pydrake.geometry.optimization.GraphOfConvexSets.Edge"><span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.Edge</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">str</span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.Edge.name" title="Permalink to this definition"></a></dt>
<dd><p>Returns the string name associated with this edge.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.GraphOfConvexSets.Edge.phi">
<span class="sig-name descname"><span class="pre">phi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.GraphOfConvexSets.Edge" title="pydrake.geometry.optimization.GraphOfConvexSets.Edge"><span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.Edge</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Variable" title="pydrake.symbolic.Variable"><span class="pre">pydrake.symbolic.Variable</span></a></span></span><a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.Edge.phi" title="Permalink to this definition"></a></dt>
<dd><p>Returns the binary variable associated with this edge. It can be used
to determine whether this edge was active in the solution to an
optimization problem, by calling GetSolution(phi()) on a returned
MathematicalProgramResult.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.GraphOfConvexSets.Edge.u">
<span class="sig-name descname"><span class="pre">u</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.GraphOfConvexSets.Edge" title="pydrake.geometry.optimization.GraphOfConvexSets.Edge"><span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.Edge</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.geometry.optimization.GraphOfConvexSets.Vertex" title="pydrake.geometry.optimization.GraphOfConvexSets.Vertex"><span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.Vertex</span></a></span></span><a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.Edge.u" title="Permalink to this definition"></a></dt>
<dd><p>Returns a mutable reference to the “left” Vertex that this edge
connects to.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.GraphOfConvexSets.Edge.v">
<span class="sig-name descname"><span class="pre">v</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.GraphOfConvexSets.Edge" title="pydrake.geometry.optimization.GraphOfConvexSets.Edge"><span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.Edge</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.geometry.optimization.GraphOfConvexSets.Vertex" title="pydrake.geometry.optimization.GraphOfConvexSets.Vertex"><span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.Vertex</span></a></span></span><a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.Edge.v" title="Permalink to this definition"></a></dt>
<dd><p>Returns a mutable reference to the “right” Vertex that this edge
connects to.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.GraphOfConvexSets.Edge.xu">
<span class="sig-name descname"><span class="pre">xu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.GraphOfConvexSets.Edge" title="pydrake.geometry.optimization.GraphOfConvexSets.Edge"><span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.Edge</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.Edge.xu" title="Permalink to this definition"></a></dt>
<dd><p>Returns the continuous decision variables associated with vertex
<code class="docutils literal notranslate"><span class="pre">u</span></code>. This can be used for constructing symbolic::Expression costs
and constraints.</p>
<p>See also GetSolutionPhiXu(); using <code class="docutils literal notranslate"><span class="pre">result.GetSolution(xu())</span></code> may
not be what you want.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.GraphOfConvexSets.Edge.xv">
<span class="sig-name descname"><span class="pre">xv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.GraphOfConvexSets.Edge" title="pydrake.geometry.optimization.GraphOfConvexSets.Edge"><span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.Edge</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.Edge.xv" title="Permalink to this definition"></a></dt>
<dd><p>Returns the continuous decision variables associated with vertex
<code class="docutils literal notranslate"><span class="pre">v</span></code>. This can be used for constructing symbolic::Expression costs
and constraints.</p>
<p>See also GetSolutionPhiXv(); using <code class="docutils literal notranslate"><span class="pre">result.GetSolution(xv())</span></code> may
not be what you want.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.GraphOfConvexSets.EdgeId">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">EdgeId</span></span><a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.EdgeId" title="Permalink to this definition"></a></dt>
<dd><dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.GraphOfConvexSets.EdgeId.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.EdgeId.__init__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.GraphOfConvexSets.EdgeId.get_new_id">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">get_new_id</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.geometry.optimization.GraphOfConvexSets.EdgeId" title="pydrake.geometry.optimization.GraphOfConvexSets.EdgeId"><span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.EdgeId</span></a></span></span><a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.EdgeId.get_new_id" title="Permalink to this definition"></a></dt>
<dd><p>Generates a new identifier for this id type. This new identifier will
be different from all previous identifiers created. This method does
<em>not</em> make any guarantees about the values of ids from successive
invocations. This method is guaranteed to be thread safe.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.GraphOfConvexSets.EdgeId.get_value">
<span class="sig-name descname"><span class="pre">get_value</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.GraphOfConvexSets.EdgeId" title="pydrake.geometry.optimization.GraphOfConvexSets.EdgeId"><span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.EdgeId</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.EdgeId.get_value" title="Permalink to this definition"></a></dt>
<dd><p>Extracts the underlying representation from the identifier. This is
considered invalid for invalid ids and is strictly enforced in Debug
builds.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.GraphOfConvexSets.EdgeId.is_valid">
<span class="sig-name descname"><span class="pre">is_valid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.GraphOfConvexSets.EdgeId" title="pydrake.geometry.optimization.GraphOfConvexSets.EdgeId"><span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.EdgeId</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.EdgeId.is_valid" title="Permalink to this definition"></a></dt>
<dd><p>Reports if the id is valid.</p>
</dd></dl>

</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.GraphOfConvexSets.Edges">
<span class="sig-name descname"><span class="pre">Edges</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.GraphOfConvexSets" title="pydrake.geometry.optimization.GraphOfConvexSets"><span class="pre">pydrake.geometry.optimization.GraphOfConvexSets</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#pydrake.geometry.optimization.GraphOfConvexSets.Edge" title="pydrake.geometry.optimization.GraphOfConvexSets.Edge"><span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.Edge</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.Edges" title="Permalink to this definition"></a></dt>
<dd><p>Returns mutable pointers to the edges stored in the graph.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.GraphOfConvexSets.GetGraphvizString">
<span class="sig-name descname"><span class="pre">GetGraphvizString</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.GraphOfConvexSets" title="pydrake.geometry.optimization.GraphOfConvexSets"><span class="pre">pydrake.geometry.optimization.GraphOfConvexSets</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">result</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.solvers.html#pydrake.solvers.MathematicalProgramResult" title="pydrake.solvers.MathematicalProgramResult"><span class="pre">pydrake.solvers.MathematicalProgramResult</span></a><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show_slacks</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">precision</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scientific</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">str</span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.GetGraphvizString" title="Permalink to this definition"></a></dt>
<dd><p>Returns a Graphviz string describing the graph vertices and edges. If
<code class="docutils literal notranslate"><span class="pre">results</span></code> is supplied, then the graph will be annotated with the
solution values.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">show_slacks</span></code>:</dt><dd><p>determines whether the values of the intermediate (slack)
variables are also displayed in the graph.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">precision</span></code>:</dt><dd><p>sets the floating point precision (how many digits are generated)
of the annotations.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">scientific</span></code>:</dt><dd><p>sets the floating point formatting to scientific (if true) or
fixed (if false).</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.GraphOfConvexSets.GetSolutionPath">
<span class="sig-name descname"><span class="pre">GetSolutionPath</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.GraphOfConvexSets" title="pydrake.geometry.optimization.GraphOfConvexSets"><span class="pre">pydrake.geometry.optimization.GraphOfConvexSets</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">source</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.GraphOfConvexSets.Vertex" title="pydrake.geometry.optimization.GraphOfConvexSets.Vertex"><span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.Vertex</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.GraphOfConvexSets.Vertex" title="pydrake.geometry.optimization.GraphOfConvexSets.Vertex"><span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.Vertex</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">result</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.solvers.html#pydrake.solvers.MathematicalProgramResult" title="pydrake.solvers.MathematicalProgramResult"><span class="pre">pydrake.solvers.MathematicalProgramResult</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.001</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#pydrake.geometry.optimization.GraphOfConvexSets.Edge" title="pydrake.geometry.optimization.GraphOfConvexSets.Edge"><span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.Edge</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.GetSolutionPath" title="Permalink to this definition"></a></dt>
<dd><p>Extracts a path from <code class="docutils literal notranslate"><span class="pre">source</span></code> to <code class="docutils literal notranslate"><span class="pre">target</span></code> described by the
<code class="docutils literal notranslate"><span class="pre">result</span></code> returned by SolveShortestPath(), via depth-first search
following the largest values of the edge binary variables.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">tolerance</span></code>:</dt><dd><p>defines the threshold for checking the integrality conditions of
the binary variables for each edge. <code class="docutils literal notranslate"><span class="pre">tolerance</span></code> = 0 would demand
that the binary variables are exactly 1 for the edges on the path.
<code class="docutils literal notranslate"><span class="pre">tolerance</span></code> = 1 would allow the binary variables to be any value
in [0, 1]. The default value is 1e-3.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if !result.is_success</strong><strong>(</strong><strong>) or </strong><strong>no path from source to</strong> – </p></li>
<li><p><strong>target` can be found in the solution</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.GraphOfConvexSets.RemoveEdge">
<span class="sig-name descname"><span class="pre">RemoveEdge</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.GraphOfConvexSets" title="pydrake.geometry.optimization.GraphOfConvexSets"><span class="pre">pydrake.geometry.optimization.GraphOfConvexSets</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.GraphOfConvexSets.Edge" title="pydrake.geometry.optimization.GraphOfConvexSets.Edge"><span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.Edge</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.RemoveEdge" title="Permalink to this definition"></a></dt>
<dd><p>Removes edge <code class="docutils literal notranslate"><span class="pre">edge</span></code> from the graph.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>The edge must be part of the graph.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.GraphOfConvexSets.RemoveVertex">
<span class="sig-name descname"><span class="pre">RemoveVertex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.GraphOfConvexSets" title="pydrake.geometry.optimization.GraphOfConvexSets"><span class="pre">pydrake.geometry.optimization.GraphOfConvexSets</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertex</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.GraphOfConvexSets.Vertex" title="pydrake.geometry.optimization.GraphOfConvexSets.Vertex"><span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.Vertex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.RemoveVertex" title="Permalink to this definition"></a></dt>
<dd><p>Removes vertex <code class="docutils literal notranslate"><span class="pre">vertex</span></code> from the graph as well as any edges from or
to the vertex. Runtime is O(nₑ) where nₑ is the number of edges in the
graph.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>The vertex must be part of the graph.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.GraphOfConvexSets.SolveConvexRestriction">
<span class="sig-name descname"><span class="pre">SolveConvexRestriction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">self:</span> <span class="pre">pydrake.geometry.optimization.GraphOfConvexSets,</span> <span class="pre">active_edges:</span> <span class="pre">List[pydrake.geometry.optimization.GraphOfConvexSets.Edge],</span> <span class="pre">options:</span> <span class="pre">pydrake.geometry.optimization.GraphOfConvexSetsOptions</span> <span class="pre">=</span> <span class="pre">GraphOfConvexSetsOptions(convex_relaxation=None,</span> <span class="pre">preprocessing=None,</span> <span class="pre">max_rounded_paths=None,</span> <span class="pre">max_rounding_trials=100,</span> <span class="pre">flow_tolerance=1e-05,</span> <span class="pre">rounding_seed=0,</span> <span class="pre">solver=None,</span> <span class="pre">solver_options=&lt;SolverOptions&gt;,</span> <span class="pre">rounding_solver_options=None,</span> <span class="pre">)</span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.solvers.html#pydrake.solvers.MathematicalProgramResult" title="pydrake.solvers.MathematicalProgramResult"><span class="pre">pydrake.solvers.MathematicalProgramResult</span></a></span></span><a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.SolveConvexRestriction" title="Permalink to this definition"></a></dt>
<dd><p>The non-convexity in a GCS problem comes from the binary variables
(phi) associated with the edges being active or inactive in the
solution. If those binary variables are fixed, then the problem is
convex – this is a so-called “convex restriction” of the original
problem.</p>
<p>The convex restriction can often be solved much more efficiently than
solving the full GCS problem with additional constraints to fix the
binaries; it can be written using less decision variables, and needs
only to include the vertices associated with at least one of the
active edges. Decision variables for all other convex sets will be set
to NaN.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the program cannot be written as a convex</strong> – </p></li>
<li><p><strong>optimization consumable by one of the standard solvers.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.GraphOfConvexSets.SolveShortestPath">
<span class="sig-name descname"><span class="pre">SolveShortestPath</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self:</span> <span class="pre">pydrake.geometry.optimization.GraphOfConvexSets</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source:</span> <span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.Vertex</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target:</span> <span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.Vertex</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options:</span> <span class="pre">pydrake.geometry.optimization.GraphOfConvexSetsOptions</span> <span class="pre">=</span> <span class="pre">GraphOfConvexSetsOptions(convex_relaxation=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preprocessing=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_rounded_paths=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_rounding_trials=100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flow_tolerance=1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rounding_seed=0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver_options=&lt;SolverOptions&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rounding_solver_options=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">)</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.solvers.html#pydrake.solvers.MathematicalProgramResult" title="pydrake.solvers.MathematicalProgramResult"><span class="pre">pydrake.solvers.MathematicalProgramResult</span></a></span></span><a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.SolveShortestPath" title="Permalink to this definition"></a></dt>
<dd><p>Formulates and solves the mixed-integer convex formulation of the
shortest path problem on the graph, as discussed in detail in</p>
<p>“Shortest Paths in Graphs of Convex Sets” by Tobia Marcucci, Jack
Umenberger, Pablo A. Parrilo, Russ Tedrake.
<a class="reference external" href="https://arxiv.org/abs/2101.11565">https://arxiv.org/abs/2101.11565</a></p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">source</span></code>:</dt><dd><p>specifies the source set. The solver will choose any point in that
set; to start at a particular continuous state consider adding a
Point set to the graph and using that as the source.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">target</span></code>:</dt><dd><p>specifies the target set. The solver will choose any point in that
set.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">options</span></code>:</dt><dd><p>include all settings for solving the shortest path problem. See
<code class="docutils literal notranslate"><span class="pre">GraphOfConvexSetsOptions</span></code> for further details. The following
default options will be used if they are not provided in
<code class="docutils literal notranslate"><span class="pre">options</span></code>: - <cite>options.convex_relaxation = false</cite>, -
<code class="docutils literal notranslate"><span class="pre">options.max_rounded_paths</span> <span class="pre">=</span> <span class="pre">0</span></code>, - <cite>options.preprocessing =
false</cite>.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if any of the costs</strong><strong> or </strong><strong>constraints in the graph are</strong> – </p></li>
<li><p><strong>incompatible with the shortest path formulation</strong><strong> or </strong><strong>otherwise</strong> – </p></li>
<li><p><strong>unsupported. All costs must be non-negative for all values of the</strong> – </p></li>
<li><p><strong>continuous variables.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.GraphOfConvexSets.Vertex">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Vertex</span></span><a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.Vertex" title="Permalink to this definition"></a></dt>
<dd><p>Each vertex in the graph has a corresponding ConvexSet, and a
std::string name.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.GraphOfConvexSets.Vertex.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.Vertex.__init__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.GraphOfConvexSets.Vertex.AddConstraint">
<span class="sig-name descname"><span class="pre">AddConstraint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.Vertex.AddConstraint" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>AddConstraint(self: pydrake.geometry.optimization.GraphOfConvexSets.Vertex, f: pydrake.symbolic.Formula) -&gt; pydrake.solvers.Binding[Constraint]</p></li>
</ol>
<p>Adds a constraint to this vertex, described by a symbolic::Formula
<code class="docutils literal notranslate"><span class="pre">f</span></code> containing <em>only</em> elements of x() as variables.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if f.GetFreeVariables</strong><strong>(</strong><strong>) </strong><strong>is not a subset of x</strong><strong>(</strong><strong>)</strong><strong></strong> – </p></li>
<li><p><strong>RuntimeError if ambient_dimension</strong><strong>(</strong><strong>) </strong><strong>== 0.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>AddConstraint(self: pydrake.geometry.optimization.GraphOfConvexSets.Vertex, binding: pydrake.solvers.Binding[Constraint]) -&gt; pydrake.solvers.Binding[Constraint]</p></li>
</ol>
<p>Adds a cost to this vertex. <code class="docutils literal notranslate"><span class="pre">binding</span></code> must contain <em>only</em> elements
of x() as variables. For technical reasons relating to being able to
“turn-off” the cost on inactive vertices, all costs are eventually
implemented with a slack variable and a constraint:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>min g(x) ⇒ min ℓ, s.t. ℓ ≥ g(x)
</pre></div>
</div>
</details><div class="admonition note">
<p class="admonition-title">Note</p>
<p>Linear costs lead to negative costs if decision variables are not
properly constrained. Users may want to check that the solution
does not contain negative costs.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the pair &lt;ℓ, g(x)&gt;.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>RuntimeError if binding.variables</strong><strong>(</strong><strong>) </strong><strong>is not a subset of x</strong><strong>(</strong><strong>)</strong><strong></strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.GraphOfConvexSets.Vertex.AddCost">
<span class="sig-name descname"><span class="pre">AddCost</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.Vertex.AddCost" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>AddCost(self: pydrake.geometry.optimization.GraphOfConvexSets.Vertex, e: pydrake.symbolic.Expression) -&gt; Tuple[pydrake.symbolic.Variable, pydrake.solvers.Binding[Cost]]</p></li>
</ol>
<p>Adds a cost to this vertex, described by a symbolic::Expression <code class="docutils literal notranslate"><span class="pre">e</span></code>
containing <em>only</em> elements of x() as variables. For technical reasons
relating to being able to “turn-off” the cost on inactive vertices,
all costs are eventually implemented with a slack variable and a
constraint:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>min g(x) ⇒ min ℓ, s.t. ℓ ≥ g(x)
</pre></div>
</div>
</details><div class="admonition note">
<p class="admonition-title">Note</p>
<p>Linear costs lead to negative costs if decision variables are not
properly constrained. Users may want to check that the solution
does not contain negative costs.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the pair &lt;ℓ, g(x)&gt;.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>RuntimeError if e.GetVariables</strong><strong>(</strong><strong>) </strong><strong>is not a subset of x</strong><strong>(</strong><strong>)</strong><strong></strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>AddCost(self: pydrake.geometry.optimization.GraphOfConvexSets.Vertex, binding: pydrake.solvers.Binding[Cost]) -&gt; Tuple[pydrake.symbolic.Variable, pydrake.solvers.Binding[Cost]]</p></li>
</ol>
<p>Adds a cost to this vertex. <code class="docutils literal notranslate"><span class="pre">binding</span></code> must contain <em>only</em> elements
of x() as variables. For technical reasons relating to being able to
“turn-off” the cost on inactive vertices, all costs are eventually
implemented with a slack variable and a constraint:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>min g(x) ⇒ min ℓ, s.t. ℓ ≥ g(x)
</pre></div>
</div>
</details><div class="admonition note">
<p class="admonition-title">Note</p>
<p>Linear costs lead to negative costs if decision variables are not
properly constrained. Users may want to check that the solution
does not contain negative costs.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the pair &lt;ℓ, g(x)&gt;.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>RuntimeError if binding.variables</strong><strong>(</strong><strong>) </strong><strong>is not a subset of x</strong><strong>(</strong><strong>)</strong><strong></strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.GraphOfConvexSets.Vertex.ambient_dimension">
<span class="sig-name descname"><span class="pre">ambient_dimension</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.GraphOfConvexSets.Vertex" title="pydrake.geometry.optimization.GraphOfConvexSets.Vertex"><span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.Vertex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.Vertex.ambient_dimension" title="Permalink to this definition"></a></dt>
<dd><p>Returns the ambient dimension of the ConvexSet.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.GraphOfConvexSets.Vertex.GetConstraints">
<span class="sig-name descname"><span class="pre">GetConstraints</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.GraphOfConvexSets.Vertex" title="pydrake.geometry.optimization.GraphOfConvexSets.Vertex"><span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.Vertex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.solvers.html#pydrake.solvers.Binding" title="pydrake.solvers.Binding"><span class="pre">pydrake.solvers.Binding</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Constraint</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.Vertex.GetConstraints" title="Permalink to this definition"></a></dt>
<dd><p>Returns all constraints on this vertex.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.GraphOfConvexSets.Vertex.GetCosts">
<span class="sig-name descname"><span class="pre">GetCosts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.GraphOfConvexSets.Vertex" title="pydrake.geometry.optimization.GraphOfConvexSets.Vertex"><span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.Vertex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.solvers.html#pydrake.solvers.Binding" title="pydrake.solvers.Binding"><span class="pre">pydrake.solvers.Binding</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Cost</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.Vertex.GetCosts" title="Permalink to this definition"></a></dt>
<dd><p>Returns all costs on this vertex.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.GraphOfConvexSets.Vertex.GetSolution">
<span class="sig-name descname"><span class="pre">GetSolution</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.GraphOfConvexSets.Vertex" title="pydrake.geometry.optimization.GraphOfConvexSets.Vertex"><span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.Vertex</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">result</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.solvers.html#pydrake.solvers.MathematicalProgramResult" title="pydrake.solvers.MathematicalProgramResult"><span class="pre">pydrake.solvers.MathematicalProgramResult</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.Vertex.GetSolution" title="Permalink to this definition"></a></dt>
<dd><p>Returns the solution of x() in a MathematicalProgramResult. This
solution is NaN if the vertex is not in the shortest path (or if we
are solving the the convex relaxation and the total flow through this
vertex at the solution is numerically close to zero). We prefer to
return NaN than a value not contained in set().</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.GraphOfConvexSets.Vertex.GetSolutionCost">
<span class="sig-name descname"><span class="pre">GetSolutionCost</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.GraphOfConvexSets.Vertex" title="pydrake.geometry.optimization.GraphOfConvexSets.Vertex"><span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.Vertex</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">result</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.solvers.html#pydrake.solvers.MathematicalProgramResult" title="pydrake.solvers.MathematicalProgramResult"><span class="pre">pydrake.solvers.MathematicalProgramResult</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.Vertex.GetSolutionCost" title="Permalink to this definition"></a></dt>
<dd><p>Returns the sum of the costs associated with this vertex in a
solvers::MathematicalProgramResult.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.GraphOfConvexSets.Vertex.id">
<span class="sig-name descname"><span class="pre">id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.GraphOfConvexSets.Vertex" title="pydrake.geometry.optimization.GraphOfConvexSets.Vertex"><span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.Vertex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.geometry.optimization.GraphOfConvexSets.VertexId" title="pydrake.geometry.optimization.GraphOfConvexSets.VertexId"><span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.VertexId</span></a></span></span><a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.Vertex.id" title="Permalink to this definition"></a></dt>
<dd><p>Returns the unique identifier associated with this Vertex.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.GraphOfConvexSets.Vertex.incoming_edges">
<span class="sig-name descname"><span class="pre">incoming_edges</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.GraphOfConvexSets.Vertex" title="pydrake.geometry.optimization.GraphOfConvexSets.Vertex"><span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.Vertex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List[drake::geometry::optimization::GraphOfConvexSets::Edge]</span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.Vertex.incoming_edges" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.GraphOfConvexSets.Vertex.name">
<span class="sig-name descname"><span class="pre">name</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.GraphOfConvexSets.Vertex" title="pydrake.geometry.optimization.GraphOfConvexSets.Vertex"><span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.Vertex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">str</span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.Vertex.name" title="Permalink to this definition"></a></dt>
<dd><p>Returns the name of the vertex.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.GraphOfConvexSets.Vertex.outgoing_edges">
<span class="sig-name descname"><span class="pre">outgoing_edges</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.GraphOfConvexSets.Vertex" title="pydrake.geometry.optimization.GraphOfConvexSets.Vertex"><span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.Vertex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List[drake::geometry::optimization::GraphOfConvexSets::Edge]</span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.Vertex.outgoing_edges" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.GraphOfConvexSets.Vertex.set">
<span class="sig-name descname"><span class="pre">set</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.GraphOfConvexSets.Vertex" title="pydrake.geometry.optimization.GraphOfConvexSets.Vertex"><span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.Vertex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.geometry.optimization.ConvexSet" title="pydrake.geometry.optimization.ConvexSet"><span class="pre">pydrake.geometry.optimization.ConvexSet</span></a></span></span><a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.Vertex.set" title="Permalink to this definition"></a></dt>
<dd><p>Returns a const reference to the underlying ConvexSet.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.GraphOfConvexSets.Vertex.x">
<span class="sig-name descname"><span class="pre">x</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.GraphOfConvexSets.Vertex" title="pydrake.geometry.optimization.GraphOfConvexSets.Vertex"><span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.Vertex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.Vertex.x" title="Permalink to this definition"></a></dt>
<dd><p>Returns a decision variable corresponding to an element of the
ConvexSet, which can be used for constructing symbolic::Expression
costs and constraints.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.GraphOfConvexSets.VertexId">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">VertexId</span></span><a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.VertexId" title="Permalink to this definition"></a></dt>
<dd><dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.GraphOfConvexSets.VertexId.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.VertexId.__init__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.GraphOfConvexSets.VertexId.get_new_id">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">get_new_id</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.geometry.optimization.GraphOfConvexSets.VertexId" title="pydrake.geometry.optimization.GraphOfConvexSets.VertexId"><span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.VertexId</span></a></span></span><a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.VertexId.get_new_id" title="Permalink to this definition"></a></dt>
<dd><p>Generates a new identifier for this id type. This new identifier will
be different from all previous identifiers created. This method does
<em>not</em> make any guarantees about the values of ids from successive
invocations. This method is guaranteed to be thread safe.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.GraphOfConvexSets.VertexId.get_value">
<span class="sig-name descname"><span class="pre">get_value</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.GraphOfConvexSets.VertexId" title="pydrake.geometry.optimization.GraphOfConvexSets.VertexId"><span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.VertexId</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.VertexId.get_value" title="Permalink to this definition"></a></dt>
<dd><p>Extracts the underlying representation from the identifier. This is
considered invalid for invalid ids and is strictly enforced in Debug
builds.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.GraphOfConvexSets.VertexId.is_valid">
<span class="sig-name descname"><span class="pre">is_valid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.GraphOfConvexSets.VertexId" title="pydrake.geometry.optimization.GraphOfConvexSets.VertexId"><span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.VertexId</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.VertexId.is_valid" title="Permalink to this definition"></a></dt>
<dd><p>Reports if the id is valid.</p>
</dd></dl>

</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.GraphOfConvexSets.Vertices">
<span class="sig-name descname"><span class="pre">Vertices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.GraphOfConvexSets" title="pydrake.geometry.optimization.GraphOfConvexSets"><span class="pre">pydrake.geometry.optimization.GraphOfConvexSets</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#pydrake.geometry.optimization.GraphOfConvexSets.Vertex" title="pydrake.geometry.optimization.GraphOfConvexSets.Vertex"><span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.Vertex</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.Vertices" title="Permalink to this definition"></a></dt>
<dd><p>Returns mutable pointers to the vertices stored in the graph.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.GraphOfConvexSetsOptions">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.geometry.optimization.</span></span><span class="sig-name descname"><span class="pre">GraphOfConvexSetsOptions</span></span><a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSetsOptions" title="Permalink to this definition"></a></dt>
<dd><dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.GraphOfConvexSetsOptions.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.GraphOfConvexSetsOptions" title="pydrake.geometry.optimization.GraphOfConvexSetsOptions"><span class="pre">pydrake.geometry.optimization.GraphOfConvexSetsOptions</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSetsOptions.__init__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.GraphOfConvexSetsOptions.convex_relaxation">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">convex_relaxation</span></span><a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSetsOptions.convex_relaxation" title="Permalink to this definition"></a></dt>
<dd><p>Flag to solve the relaxed version of the problem. As discussed in the
paper, we know that this relaxation cannot solve the original NP-hard
problem for all instances, but there are also many instances for which
the convex relaxation is tight.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.GraphOfConvexSetsOptions.flow_tolerance">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">flow_tolerance</span></span><a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSetsOptions.flow_tolerance" title="Permalink to this definition"></a></dt>
<dd><p>Tolerance for ignoring flow along a given edge during random rounding.
If convex_relaxation is false or max_rounded_paths is less than or
equal to zero, this option is ignored.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.GraphOfConvexSetsOptions.max_rounded_paths">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">max_rounded_paths</span></span><a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSetsOptions.max_rounded_paths" title="Permalink to this definition"></a></dt>
<dd><p>Maximum number of distinct paths to compare during random rounding;
only the lowest cost path is returned. If convex_relaxation is false
or this is less than or equal to zero, rounding is not performed.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.GraphOfConvexSetsOptions.max_rounding_trials">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">max_rounding_trials</span></span><a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSetsOptions.max_rounding_trials" title="Permalink to this definition"></a></dt>
<dd><p>Maximum number of trials to find a novel path during random rounding.
If convex_relaxation is false or max_rounded_paths is less than or
equal to zero, this option is ignored.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.GraphOfConvexSetsOptions.preprocessing">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">preprocessing</span></span><a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSetsOptions.preprocessing" title="Permalink to this definition"></a></dt>
<dd><p>Performs a preprocessing step to remove edges that cannot lie on the
path from source to target. In most cases, preprocessing causes a net
reduction in computation by reducing the size of the optimization
solved. Note that this preprocessing is not exact. There may be edges
that cannot lie on the path from source to target that this does not
detect.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.GraphOfConvexSetsOptions.rounding_seed">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">rounding_seed</span></span><a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSetsOptions.rounding_seed" title="Permalink to this definition"></a></dt>
<dd><p>Random seed to use for random rounding. If convex_relaxation is false
or max_rounded_paths is less than or equal to zero, this option is
ignored.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.GraphOfConvexSetsOptions.rounding_solver_options">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">rounding_solver_options</span></span><a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSetsOptions.rounding_solver_options" title="Permalink to this definition"></a></dt>
<dd><p>Optional solver options for the rounded problems. If not set,
solver_options is used. For instance, one might want to set tighter
(i.e., lower) tolerances for running the relaxed problem and looser
(i.e., higher) tolerances for final solves during rounding.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.GraphOfConvexSetsOptions.solver">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">solver</span></span><a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSetsOptions.solver" title="Permalink to this definition"></a></dt>
<dd><p>Optimizer to be used to solve the shortest path optimization problem.
If not set, the best solver for the given problem is selected. Note
that if the solver cannot handle the type of optimization problem
generated, the calling solve method will throw.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.GraphOfConvexSetsOptions.solver_options">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">solver_options</span></span><a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSetsOptions.solver_options" title="Permalink to this definition"></a></dt>
<dd><p>Options passed to the solver when solving the generated problem.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.HPolyhedron">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.geometry.optimization.</span></span><span class="sig-name descname"><span class="pre">HPolyhedron</span></span><a class="headerlink" href="#pydrake.geometry.optimization.HPolyhedron" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.geometry.optimization.ConvexSet" title="pydrake.geometry.optimization.ConvexSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.geometry.optimization.ConvexSet</span></code></a></p>
<p>Implements a polyhedral convex set using the half-space
representation: <code class="docutils literal notranslate"><span class="pre">{x|</span> <span class="pre">A</span> <span class="pre">x</span> <span class="pre">≤</span> <span class="pre">b}</span></code>. Note: This set may be unbounded.</p>
<p>By convention, we treat a zero-dimensional HPolyhedron as nonempty.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.HPolyhedron.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.geometry.optimization.HPolyhedron.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.geometry.optimization.HPolyhedron) -&gt; None</p></li>
</ol>
<p>Constructs a default (zero-dimensional, nonempty) polyhedron.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.geometry.optimization.HPolyhedron, A: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], b: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</p></li>
</ol>
<p>Constructs the polyhedron.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>A.rows() == b.size().</p>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li><p>__init__(self: pydrake.geometry.optimization.HPolyhedron, query_object: pydrake.geometry.QueryObject, geometry_id: pydrake.geometry.GeometryId, reference_frame: Optional[pydrake.geometry.FrameId] = None) -&gt; None</p></li>
</ol>
<p>Constructs a new HPolyhedron from a SceneGraph geometry and pose in
the <code class="docutils literal notranslate"><span class="pre">reference_frame</span></code> frame, obtained via the QueryObject. If
<code class="docutils literal notranslate"><span class="pre">reference_frame</span></code> frame is std::nullopt, then it will be expressed
in the world frame.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError the geometry is not a convex polytope.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="4">
<li><p>__init__(self: pydrake.geometry.optimization.HPolyhedron, vpoly: drake::geometry::optimization::VPolytope) -&gt; None</p></li>
</ol>
<p>Constructs a new HPolyedron from a VPolytope object. This function
will use qhull. If the VPolytope is empty, then the HPolyhedron will
also be empty.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if vpoly is empty and zero dimensional.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.HPolyhedron.A">
<span class="sig-name descname"><span class="pre">A</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.HPolyhedron" title="pydrake.geometry.optimization.HPolyhedron"><span class="pre">pydrake.geometry.optimization.HPolyhedron</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.HPolyhedron.A" title="Permalink to this definition"></a></dt>
<dd><p>Returns the half-space representation matrix A.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.HPolyhedron.b">
<span class="sig-name descname"><span class="pre">b</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.HPolyhedron" title="pydrake.geometry.optimization.HPolyhedron"><span class="pre">pydrake.geometry.optimization.HPolyhedron</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.HPolyhedron.b" title="Permalink to this definition"></a></dt>
<dd><p>Returns the half-space representation vector b.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.HPolyhedron.CartesianPower">
<span class="sig-name descname"><span class="pre">CartesianPower</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.HPolyhedron" title="pydrake.geometry.optimization.HPolyhedron"><span class="pre">pydrake.geometry.optimization.HPolyhedron</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.geometry.optimization.HPolyhedron" title="pydrake.geometry.optimization.HPolyhedron"><span class="pre">pydrake.geometry.optimization.HPolyhedron</span></a></span></span><a class="headerlink" href="#pydrake.geometry.optimization.HPolyhedron.CartesianPower" title="Permalink to this definition"></a></dt>
<dd><p>Returns the <code class="docutils literal notranslate"><span class="pre">n</span></code>-ary Cartesian power of <code class="docutils literal notranslate"><span class="pre">this</span></code>. The n-ary Cartesian
power of a set H is the set H ⨉ H ⨉ … ⨉ H, where H is repeated n
times.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.HPolyhedron.CartesianProduct">
<span class="sig-name descname"><span class="pre">CartesianProduct</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.HPolyhedron" title="pydrake.geometry.optimization.HPolyhedron"><span class="pre">pydrake.geometry.optimization.HPolyhedron</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.HPolyhedron" title="pydrake.geometry.optimization.HPolyhedron"><span class="pre">pydrake.geometry.optimization.HPolyhedron</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.geometry.optimization.HPolyhedron" title="pydrake.geometry.optimization.HPolyhedron"><span class="pre">pydrake.geometry.optimization.HPolyhedron</span></a></span></span><a class="headerlink" href="#pydrake.geometry.optimization.HPolyhedron.CartesianProduct" title="Permalink to this definition"></a></dt>
<dd><p>Returns the Cartesian product of <code class="docutils literal notranslate"><span class="pre">this</span></code> and <code class="docutils literal notranslate"><span class="pre">other</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.HPolyhedron.ChebyshevCenter">
<span class="sig-name descname"><span class="pre">ChebyshevCenter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.HPolyhedron" title="pydrake.geometry.optimization.HPolyhedron"><span class="pre">pydrake.geometry.optimization.HPolyhedron</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.HPolyhedron.ChebyshevCenter" title="Permalink to this definition"></a></dt>
<dd><p>Solves a linear program to compute the center of the largest inscribed
ball in the polyhedron. This is often the recommended way to find some
interior point of the set, for example, as a step towards computing
the convex hull or a vertex-representation of the set.</p>
<p>Note that the Chebyshev center is not necessarily unique, and may not
conform to the point that one might consider the “visual center” of
the set. For example, for a long thin rectangle, any point in the
center line segment illustrated below would be a valid center point.
The solver may return any point on that line segment.</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>┌──────────────────────────────────┐
│                                  │
│   ────────────────────────────   │
│                                  │
└──────────────────────────────────┘
</pre></div>
</div>
</details><p>To find the visual center, consider using the more expensive
MaximumVolumeInscribedEllipsoid() method, and then taking the center
of the returned Hyperellipsoid.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if the solver fails to solve the problem.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.HPolyhedron.ContainedIn">
<span class="sig-name descname"><span class="pre">ContainedIn</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.HPolyhedron" title="pydrake.geometry.optimization.HPolyhedron"><span class="pre">pydrake.geometry.optimization.HPolyhedron</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.HPolyhedron" title="pydrake.geometry.optimization.HPolyhedron"><span class="pre">pydrake.geometry.optimization.HPolyhedron</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1e-09</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.HPolyhedron.ContainedIn" title="Permalink to this definition"></a></dt>
<dd><p>Returns true iff this HPolyhedron is entirely contained in the
HPolyhedron other. This is done by checking whether every inequality
in <code class="docutils literal notranslate"><span class="pre">other</span></code> is redundant when added to this.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">tol</span></code>:</dt><dd><p>We check if this polyhedron is contained in
other.A().row(i).dot(x) &lt;= other.b()(i) + tol. The larger tol
value is, the more relaxation we add to the containment. If tol is
negative, then we check if a shrinked <code class="docutils literal notranslate"><span class="pre">other</span></code> contains this
polyheron.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.HPolyhedron.FindRedundant">
<span class="sig-name descname"><span class="pre">FindRedundant</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.HPolyhedron" title="pydrake.geometry.optimization.HPolyhedron"><span class="pre">pydrake.geometry.optimization.HPolyhedron</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1e-09</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Set</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.HPolyhedron.FindRedundant" title="Permalink to this definition"></a></dt>
<dd><p>Finds the redundant inequalities in this polyhedron. Returns a set ℑ,
such that if we remove the rows of A * x &lt;= b in ℑ, the remaining
inequalities still define the same polyhedron, namely {x | A*x&lt;=b} =
{x | A.row(i)*x&lt;=b(i), ∀i ∉ ℑ}. This function solves a series of
linear programs. We say the jᵗʰ row A.row(j)*x &lt;= b(j) is redundant,
if {x | A.row(i) * x &lt;= b(i), ∀i ∉ ℑ} implies that A.row(j) * x &lt;=
b(j) + tol. Note that we do NOT guarantee that we find all the
redundant rows.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.HPolyhedron.Intersection">
<span class="sig-name descname"><span class="pre">Intersection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.HPolyhedron" title="pydrake.geometry.optimization.HPolyhedron"><span class="pre">pydrake.geometry.optimization.HPolyhedron</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.HPolyhedron" title="pydrake.geometry.optimization.HPolyhedron"><span class="pre">pydrake.geometry.optimization.HPolyhedron</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_for_redundancy</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1e-09</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.geometry.optimization.HPolyhedron" title="pydrake.geometry.optimization.HPolyhedron"><span class="pre">pydrake.geometry.optimization.HPolyhedron</span></a></span></span><a class="headerlink" href="#pydrake.geometry.optimization.HPolyhedron.Intersection" title="Permalink to this definition"></a></dt>
<dd><p>Constructs the intersection of two HPolyhedron by adding the rows of
inequalities from <code class="docutils literal notranslate"><span class="pre">other</span></code>. If <code class="docutils literal notranslate"><span class="pre">check_for_redundancy</span></code> is true then
only adds the rows of <code class="docutils literal notranslate"><span class="pre">other</span></code> other.A().row(i).dot(x)&lt;=other.b()(i)
to this HPolyhedron if the inequality
other.A().row(i).dot(x)&lt;=other.b()(i)+tol is not implied by the
inequalities from this HPolyhedron. A positive tol means it is more
likely to deem a constraint being redundant and remove it. A negative
tol means it is less likely to remove a constraint.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.HPolyhedron.MakeBox">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">MakeBox</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lb</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ub</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.geometry.optimization.HPolyhedron" title="pydrake.geometry.optimization.HPolyhedron"><span class="pre">pydrake.geometry.optimization.HPolyhedron</span></a></span></span><a class="headerlink" href="#pydrake.geometry.optimization.HPolyhedron.MakeBox" title="Permalink to this definition"></a></dt>
<dd><p>Constructs a polyhedron as an axis-aligned box from the lower and
upper corners.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.HPolyhedron.MakeL1Ball">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">MakeL1Ball</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.geometry.optimization.HPolyhedron" title="pydrake.geometry.optimization.HPolyhedron"><span class="pre">pydrake.geometry.optimization.HPolyhedron</span></a></span></span><a class="headerlink" href="#pydrake.geometry.optimization.HPolyhedron.MakeL1Ball" title="Permalink to this definition"></a></dt>
<dd><p>Constructs the L1-norm unit ball in <code class="docutils literal notranslate"><span class="pre">dim</span></code> dimensions, {x | <a href="#id5"><span class="problematic" id="id6">|</span></a>x|₁ &lt;= 1
}. This set is also known as the cross-polytope and is described by
the 2ᵈⁱᵐ signed unit vectors.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.HPolyhedron.MakeUnitBox">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">MakeUnitBox</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.geometry.optimization.HPolyhedron" title="pydrake.geometry.optimization.HPolyhedron"><span class="pre">pydrake.geometry.optimization.HPolyhedron</span></a></span></span><a class="headerlink" href="#pydrake.geometry.optimization.HPolyhedron.MakeUnitBox" title="Permalink to this definition"></a></dt>
<dd><p>Constructs the L∞-norm unit box in <code class="docutils literal notranslate"><span class="pre">dim</span></code> dimensions, {x | <a href="#id7"><span class="problematic" id="id8">|</span></a>x|∞ &lt;= 1
}. This is an axis-aligned box, centered at the origin, with edge
length 2.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.HPolyhedron.MaximumVolumeInscribedEllipsoid">
<span class="sig-name descname"><span class="pre">MaximumVolumeInscribedEllipsoid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.HPolyhedron" title="pydrake.geometry.optimization.HPolyhedron"><span class="pre">pydrake.geometry.optimization.HPolyhedron</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.geometry.optimization.Hyperellipsoid" title="pydrake.geometry.optimization.Hyperellipsoid"><span class="pre">pydrake.geometry.optimization.Hyperellipsoid</span></a></span></span><a class="headerlink" href="#pydrake.geometry.optimization.HPolyhedron.MaximumVolumeInscribedEllipsoid" title="Permalink to this definition"></a></dt>
<dd><p>Solves a semi-definite program to compute the inscribed ellipsoid.
This is also known as the inner Löwner-John ellipsoid. From Section
8.4.2 in Boyd and Vandenberghe, 2004, we solve</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>max_{C,d} log det (C)
s.t. |aᵢC|₂ ≤ bᵢ - aᵢd, ∀i
C ≽ 0
</pre></div>
</div>
</details><p>where aᵢ and bᵢ denote the ith row. This defines the ellipsoid E = {
Cx + d | <a href="#id9"><span class="problematic" id="id10">|</span></a>x|₂ ≤ 1}.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>the HPolyhedron is bounded.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if the solver fails to solve the problem.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.HPolyhedron.PontryaginDifference">
<span class="sig-name descname"><span class="pre">PontryaginDifference</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.HPolyhedron" title="pydrake.geometry.optimization.HPolyhedron"><span class="pre">pydrake.geometry.optimization.HPolyhedron</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.HPolyhedron" title="pydrake.geometry.optimization.HPolyhedron"><span class="pre">pydrake.geometry.optimization.HPolyhedron</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.geometry.optimization.HPolyhedron" title="pydrake.geometry.optimization.HPolyhedron"><span class="pre">pydrake.geometry.optimization.HPolyhedron</span></a></span></span><a class="headerlink" href="#pydrake.geometry.optimization.HPolyhedron.PontryaginDifference" title="Permalink to this definition"></a></dt>
<dd><p>Returns the Pontryagin (Minkowski) Difference of <code class="docutils literal notranslate"><span class="pre">this</span></code> and
<code class="docutils literal notranslate"><span class="pre">other</span></code>. This is the set A ⊖ B = { a|a+ B ⊆ A }. The result is an
HPolyhedron with the same number of inequalities as A. Requires that
<code class="docutils literal notranslate"><span class="pre">this</span></code> and <code class="docutils literal notranslate"><span class="pre">other</span></code> both be bounded and have the same ambient
dimension. This method may throw a runtime error if <code class="docutils literal notranslate"><span class="pre">this</span></code> or
<code class="docutils literal notranslate"><span class="pre">other</span></code> are ill-conditioned.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.HPolyhedron.ReduceInequalities">
<span class="sig-name descname"><span class="pre">ReduceInequalities</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.HPolyhedron" title="pydrake.geometry.optimization.HPolyhedron"><span class="pre">pydrake.geometry.optimization.HPolyhedron</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1e-09</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.geometry.optimization.HPolyhedron" title="pydrake.geometry.optimization.HPolyhedron"><span class="pre">pydrake.geometry.optimization.HPolyhedron</span></a></span></span><a class="headerlink" href="#pydrake.geometry.optimization.HPolyhedron.ReduceInequalities" title="Permalink to this definition"></a></dt>
<dd><p>Reduces some (not necessarily all) redundant inequalities in the
HPolyhedron. This is not guaranteed to give the minimal representation
of the polyhedron but is a relatively fast way to reduce the number of
inequalities.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">tol</span></code>:</dt><dd><p>For a constraint c’x&lt;=d, if the halfspace c’x&lt;=d + tol contains
the hpolyhedron generated by the rest of the constraints, then we
remove this inequality. A positive tol means it is more likely to
remove a constraint, a negative tol means it is less likely to
remote a constraint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.HPolyhedron.Scale">
<span class="sig-name descname"><span class="pre">Scale</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.HPolyhedron" title="pydrake.geometry.optimization.HPolyhedron"><span class="pre">pydrake.geometry.optimization.HPolyhedron</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.geometry.optimization.HPolyhedron" title="pydrake.geometry.optimization.HPolyhedron"><span class="pre">pydrake.geometry.optimization.HPolyhedron</span></a></span></span><a class="headerlink" href="#pydrake.geometry.optimization.HPolyhedron.Scale" title="Permalink to this definition"></a></dt>
<dd><p>Results a new HPolyhedron that is a scaled version of <code class="docutils literal notranslate"><span class="pre">this</span></code>, by
scaling the distance from each face to the <code class="docutils literal notranslate"><span class="pre">center</span></code> by a factor of
<code class="docutils literal notranslate"><span class="pre">pow(scale,</span> <span class="pre">1/ambient_dimension())</span></code>, to have units of volume: -
<code class="docutils literal notranslate"><span class="pre">scale</span> <span class="pre">=</span> <span class="pre">0</span></code> will result in a point, - <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;</span> <span class="pre">scale</span> <span class="pre">&lt;</span> <span class="pre">1</span></code> shrinks the
region, - <code class="docutils literal notranslate"><span class="pre">scale</span> <span class="pre">=</span> <span class="pre">1</span></code> returns a copy of the <code class="docutils literal notranslate"><span class="pre">this</span></code>, and - <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">&lt;</span>
<span class="pre">scale</span></code> grows the region.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">center</span></code> is not provided, then the value returned by
ChebyshevCenter() will be used.</p>
<p><code class="docutils literal notranslate"><span class="pre">this</span></code> does not need to be bounded, nor have volume. <code class="docutils literal notranslate"><span class="pre">center</span></code> does
not need to be in the set.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">scale</span></code> &gt;= 0.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">center</span></code> has size equal to the ambient dimension.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.HPolyhedron.UniformSample">
<span class="sig-name descname"><span class="pre">UniformSample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.geometry.optimization.HPolyhedron.UniformSample" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>UniformSample(self: pydrake.geometry.optimization.HPolyhedron, generator: pydrake.common.RandomGenerator, previous_sample: numpy.ndarray[numpy.float64[m, 1]]) -&gt; numpy.ndarray[numpy.float64[m, 1]]</p></li>
</ol>
<p>Draw an (approximately) uniform sample from the set using the hit and
run Markov-chain Monte-Carlo strategy described at
<a class="reference external" href="https://mathoverflow.net/a/162327">https://mathoverflow.net/a/162327</a> and the cited paper. To generate
many samples, pass the output of one iteration in as the
<code class="docutils literal notranslate"><span class="pre">previous_sample</span></code> to the next; in this case the distribution of
samples will converge to the true uniform distribution in total
variation at a geometric rate. If <code class="docutils literal notranslate"><span class="pre">previous_sample</span></code> is not set, then
the ChebyshevCenter() will be used to seed the algorithm.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if previous_sample is not in the set.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>UniformSample(self: pydrake.geometry.optimization.HPolyhedron, generator: pydrake.common.RandomGenerator) -&gt; numpy.ndarray[numpy.float64[m, 1]]</p></li>
</ol>
<p>Variant of UniformSample that uses the ChebyshevCenter() as the
previous_sample as a feasible point to start the Markov chain
sampling.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.Hyperellipsoid">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.geometry.optimization.</span></span><span class="sig-name descname"><span class="pre">Hyperellipsoid</span></span><a class="headerlink" href="#pydrake.geometry.optimization.Hyperellipsoid" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.geometry.optimization.ConvexSet" title="pydrake.geometry.optimization.ConvexSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.geometry.optimization.ConvexSet</span></code></a></p>
<p>Implements an ellipsoidal convex set represented by the quadratic form
<code class="docutils literal notranslate"><span class="pre">{x</span> <span class="pre">|</span> <span class="pre">(x-center)ᵀAᵀA(x-center)</span> <span class="pre">≤</span> <span class="pre">1}</span></code>. Note that <code class="docutils literal notranslate"><span class="pre">A</span></code> need not be
square; we require only that the matrix AᵀA is positive semi-definite.</p>
<p>Compare this with an alternative (very useful) parameterization of the
ellipsoid: <code class="docutils literal notranslate"><span class="pre">{Bu</span> <span class="pre">+</span> <span class="pre">center</span> <span class="pre">|</span> <span class="pre">|u|₂</span> <span class="pre">≤</span> <span class="pre">1}</span></code>, which is an affine scaling of
the unit ball. This is related to the quadratic form by <code class="docutils literal notranslate"><span class="pre">B</span> <span class="pre">=</span> <span class="pre">A⁻¹</span></code>,
when <code class="docutils literal notranslate"><span class="pre">A</span></code> is invertible, but the quadratic form can also represent
unbounded sets. The affine scaling of the unit ball representation is
available via the AffineBall class.</p>
<p>Note: the name Hyperellipsoid was taken here to avoid conflicting with
geometry::Ellipsoid and to distinguish that this class supports N
dimensions.</p>
<p>A hyperellipsoid can never be empty – it always contains its center.
This includes the zero-dimensional case.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.Hyperellipsoid.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.geometry.optimization.Hyperellipsoid.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.geometry.optimization.Hyperellipsoid) -&gt; None</p></li>
</ol>
<p>Constructs a default (zero-dimensional, nonempty) set.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.geometry.optimization.Hyperellipsoid, A: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], center: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</p></li>
</ol>
<p>Constructs the ellipsoid.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>A.cols() == center.size().</p>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li><p>__init__(self: pydrake.geometry.optimization.Hyperellipsoid, query_object: pydrake.geometry.QueryObject, geometry_id: pydrake.geometry.GeometryId, reference_frame: Optional[pydrake.geometry.FrameId] = None) -&gt; None</p></li>
</ol>
<p>Constructs a Hyperellipsoid from a SceneGraph geometry and pose in the
<code class="docutils literal notranslate"><span class="pre">reference_frame</span></code> frame, obtained via the QueryObject. If
<code class="docutils literal notranslate"><span class="pre">reference_frame</span></code> frame is std::nullopt, then it will be expressed
in the world frame.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if geometry_id does not represent a shape that can be</strong> – </p></li>
<li><p><strong>described as an Hyperellipsoid.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="4">
<li><p>__init__(self: pydrake.geometry.optimization.Hyperellipsoid, ellipsoid: pydrake.geometry.optimization.AffineBall) -&gt; None</p></li>
</ol>
<p>Constructs a Hyperellipsoid from an AffineBall.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>ellipsoid.B() is invertible.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.Hyperellipsoid.A">
<span class="sig-name descname"><span class="pre">A</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.Hyperellipsoid" title="pydrake.geometry.optimization.Hyperellipsoid"><span class="pre">pydrake.geometry.optimization.Hyperellipsoid</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.Hyperellipsoid.A" title="Permalink to this definition"></a></dt>
<dd><p>Returns the quadratic form matrix A.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.Hyperellipsoid.center">
<span class="sig-name descname"><span class="pre">center</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.Hyperellipsoid" title="pydrake.geometry.optimization.Hyperellipsoid"><span class="pre">pydrake.geometry.optimization.Hyperellipsoid</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.Hyperellipsoid.center" title="Permalink to this definition"></a></dt>
<dd><p>Returns the center of the ellipsoid.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.Hyperellipsoid.MakeAxisAligned">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">MakeAxisAligned</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">radius</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.geometry.optimization.Hyperellipsoid" title="pydrake.geometry.optimization.Hyperellipsoid"><span class="pre">pydrake.geometry.optimization.Hyperellipsoid</span></a></span></span><a class="headerlink" href="#pydrake.geometry.optimization.Hyperellipsoid.MakeAxisAligned" title="Permalink to this definition"></a></dt>
<dd><p>Constructs the an axis-aligned Hyperellipsoid with the implicit form
(x₀-c₀)²/r₀² + (x₁-c₁)²/r₁² + … + (x_N - c_N)²/r_N² ≤ 1, where c is
shorthand for <code class="docutils literal notranslate"><span class="pre">center</span></code> and r is shorthand for <code class="docutils literal notranslate"><span class="pre">radius</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.Hyperellipsoid.MakeHypersphere">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">MakeHypersphere</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">radius</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.geometry.optimization.Hyperellipsoid" title="pydrake.geometry.optimization.Hyperellipsoid"><span class="pre">pydrake.geometry.optimization.Hyperellipsoid</span></a></span></span><a class="headerlink" href="#pydrake.geometry.optimization.Hyperellipsoid.MakeHypersphere" title="Permalink to this definition"></a></dt>
<dd><p>Constructs a hypersphere with <code class="docutils literal notranslate"><span class="pre">radius</span></code> and <code class="docutils literal notranslate"><span class="pre">center</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.Hyperellipsoid.MakeUnitBall">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">MakeUnitBall</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.geometry.optimization.Hyperellipsoid" title="pydrake.geometry.optimization.Hyperellipsoid"><span class="pre">pydrake.geometry.optimization.Hyperellipsoid</span></a></span></span><a class="headerlink" href="#pydrake.geometry.optimization.Hyperellipsoid.MakeUnitBall" title="Permalink to this definition"></a></dt>
<dd><p>Constructs the L₂-norm unit ball in <code class="docutils literal notranslate"><span class="pre">dim</span></code> dimensions, {x | <a href="#id11"><span class="problematic" id="id12">|</span></a>x|₂ &lt;= 1
}.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.Hyperellipsoid.MinimumUniformScalingToTouch">
<span class="sig-name descname"><span class="pre">MinimumUniformScalingToTouch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.Hyperellipsoid" title="pydrake.geometry.optimization.Hyperellipsoid"><span class="pre">pydrake.geometry.optimization.Hyperellipsoid</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.ConvexSet" title="pydrake.geometry.optimization.ConvexSet"><span class="pre">pydrake.geometry.optimization.ConvexSet</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.Hyperellipsoid.MinimumUniformScalingToTouch" title="Permalink to this definition"></a></dt>
<dd><p>Computes the smallest uniform scaling of this ellipsoid for which it
still intersects <code class="docutils literal notranslate"><span class="pre">other</span></code>. √ minₓ (x-center)ᵀAᵀA(x-center) s.t. x ∈
other. Note that if center ∈ other, then we expect scaling = 0 and x =
center (up to precision).</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">other</span></code> must have the same ambient_dimension as this.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the minimal scaling and the witness point, x, on other.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>RuntimeError if other is empty.</strong> – </p></li>
<li><p><strong>RuntimeError if ambient_dimension</strong><strong>(</strong><strong>) </strong><strong>== 0</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.Hyperellipsoid.MinimumVolumeCircumscribedEllipsoid">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">MinimumVolumeCircumscribedEllipsoid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">points</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.f_contiguous</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rank_tol</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1e-06</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.geometry.optimization.Hyperellipsoid" title="pydrake.geometry.optimization.Hyperellipsoid"><span class="pre">pydrake.geometry.optimization.Hyperellipsoid</span></a></span></span><a class="headerlink" href="#pydrake.geometry.optimization.Hyperellipsoid.MinimumVolumeCircumscribedEllipsoid" title="Permalink to this definition"></a></dt>
<dd><p>Constructs the minimum-volume ellipsoid which contains all of the
<code class="docutils literal notranslate"><span class="pre">points</span></code>. This is commonly referred to as the outer Löwner-John
ellipsoid.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">points</span></code>:</dt><dd><p>is a d-by-n matrix, where d is the ambient dimension and each
column represents one point.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">rank_tol</span></code>:</dt><dd><p>the singular values of the data matrix will be considered non-zero
if they are strictly greater than <code class="docutils literal notranslate"><span class="pre">rank_tol</span></code> *
<code class="docutils literal notranslate"><span class="pre">max_singular_value</span></code>. The default is 1e-6 to be compatible with
common solver tolerances. This is used to detect if the data lies
on a lower-dimensional affine space than the ambient dimension of
the ellipsoid. If this is the case, then use
AffineBall::MinimumVolumeCircumscribedEllipsoid instead.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the MathematicalProgram fails to solve. If this</strong> – </p></li>
<li><p><strong>were to happen</strong><strong> (</strong><strong>due to numerical issues</strong><strong>)</strong><strong>, </strong><strong>then increasing</strong> – </p></li>
<li><p><strong>rank_tol` should provide a mitigation</strong> – </p></li>
<li><p><strong>RuntimeError if points includes NaNs</strong><strong> or </strong><strong>infinite values.</strong> – </p></li>
<li><p><strong>RuntimeError if the numerical data rank of points is less than d.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.Hyperrectangle">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.geometry.optimization.</span></span><span class="sig-name descname"><span class="pre">Hyperrectangle</span></span><a class="headerlink" href="#pydrake.geometry.optimization.Hyperrectangle" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.geometry.optimization.ConvexSet" title="pydrake.geometry.optimization.ConvexSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.geometry.optimization.ConvexSet</span></code></a></p>
<p>Axis-aligned hyperrectangle in Rᵈ defined by its lower bounds and
upper bounds as {x| lb ≤ x ≤ ub}</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.Hyperrectangle.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.geometry.optimization.Hyperrectangle.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.geometry.optimization.Hyperrectangle) -&gt; None</p></li>
</ol>
<p>Constructs a default (zero-dimensional, nonempty) hyperrectangle.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.geometry.optimization.Hyperrectangle, lb: numpy.ndarray[numpy.float64[m, 1]], ub: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</p></li>
</ol>
<p>Constructs a hyperrectangle from its lower and upper bounds.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>lb.size() == ub.size()</p>
</dd>
<dt>Precondition:</dt><dd><p>lb(i) &lt;= ub(i) for all i</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.Hyperrectangle.Center">
<span class="sig-name descname"><span class="pre">Center</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.Hyperrectangle" title="pydrake.geometry.optimization.Hyperrectangle"><span class="pre">pydrake.geometry.optimization.Hyperrectangle</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.Hyperrectangle.Center" title="Permalink to this definition"></a></dt>
<dd><p>Get the center of the hyperrectangle.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.Hyperrectangle.lb">
<span class="sig-name descname"><span class="pre">lb</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.Hyperrectangle" title="pydrake.geometry.optimization.Hyperrectangle"><span class="pre">pydrake.geometry.optimization.Hyperrectangle</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.Hyperrectangle.lb" title="Permalink to this definition"></a></dt>
<dd><p>Get the lower bounds of the hyperrectangle.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.Hyperrectangle.MakeHPolyhedron">
<span class="sig-name descname"><span class="pre">MakeHPolyhedron</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.Hyperrectangle" title="pydrake.geometry.optimization.Hyperrectangle"><span class="pre">pydrake.geometry.optimization.Hyperrectangle</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.geometry.optimization.HPolyhedron" title="pydrake.geometry.optimization.HPolyhedron"><span class="pre">pydrake.geometry.optimization.HPolyhedron</span></a></span></span><a class="headerlink" href="#pydrake.geometry.optimization.Hyperrectangle.MakeHPolyhedron" title="Permalink to this definition"></a></dt>
<dd><p>Helper to convert this hyperrectangle to an HPolyhedron.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.Hyperrectangle.ub">
<span class="sig-name descname"><span class="pre">ub</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.Hyperrectangle" title="pydrake.geometry.optimization.Hyperrectangle"><span class="pre">pydrake.geometry.optimization.Hyperrectangle</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.Hyperrectangle.ub" title="Permalink to this definition"></a></dt>
<dd><p>Get the upper bounds of the hyperrectangle.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.Hyperrectangle.UniformSample">
<span class="sig-name descname"><span class="pre">UniformSample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.Hyperrectangle" title="pydrake.geometry.optimization.Hyperrectangle"><span class="pre">pydrake.geometry.optimization.Hyperrectangle</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">generator</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.common.html#pydrake.common.RandomGenerator" title="pydrake.common.RandomGenerator"><span class="pre">pydrake.common.RandomGenerator</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.Hyperrectangle.UniformSample" title="Permalink to this definition"></a></dt>
<dd><p>Draws a uniform sample from the set.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.Intersection">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.geometry.optimization.</span></span><span class="sig-name descname"><span class="pre">Intersection</span></span><a class="headerlink" href="#pydrake.geometry.optimization.Intersection" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.geometry.optimization.ConvexSet" title="pydrake.geometry.optimization.ConvexSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.geometry.optimization.ConvexSet</span></code></a></p>
<p>A convex set that represents the intersection of multiple sets: S = X₁
∩ X₂ ∩ … ∩ Xₙ = {x | x ∈ X₁, x ∈ X₂, …, x ∈ Xₙ}</p>
<p>Special behavior for IsEmpty: The intersection of zero sets (i.e. when
we have <a href="#id25"><span class="problematic" id="id26">sets_</span></a>.size() == 0) is always nonempty. This includes the
zero-dimensional case, which we treat as being {0}, the unique
zero-dimensional vector space.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.Intersection.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.geometry.optimization.Intersection.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.geometry.optimization.Intersection) -&gt; None</p></li>
</ol>
<p>Constructs a default (zero-dimensional, nonempty) set.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.geometry.optimization.Intersection, sets: List[pydrake.geometry.optimization.ConvexSet]) -&gt; None</p></li>
</ol>
<p>Constructs the intersection from a vector of convex sets.</p>
<ol class="arabic simple" start="3">
<li><p>__init__(self: pydrake.geometry.optimization.Intersection, setA: pydrake.geometry.optimization.ConvexSet, setB: pydrake.geometry.optimization.ConvexSet) -&gt; None</p></li>
</ol>
<p>Constructs the intersection from a pair of convex sets.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.Intersection.element">
<span class="sig-name descname"><span class="pre">element</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.Intersection" title="pydrake.geometry.optimization.Intersection"><span class="pre">pydrake.geometry.optimization.Intersection</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.geometry.optimization.ConvexSet" title="pydrake.geometry.optimization.ConvexSet"><span class="pre">pydrake.geometry.optimization.ConvexSet</span></a></span></span><a class="headerlink" href="#pydrake.geometry.optimization.Intersection.element" title="Permalink to this definition"></a></dt>
<dd><p>Returns a reference to the ConvexSet defining the <code class="docutils literal notranslate"><span class="pre">index</span></code> element in
the intersection.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.Intersection.num_elements">
<span class="sig-name descname"><span class="pre">num_elements</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.Intersection" title="pydrake.geometry.optimization.Intersection"><span class="pre">pydrake.geometry.optimization.Intersection</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.Intersection.num_elements" title="Permalink to this definition"></a></dt>
<dd><p>The number of elements (or sets) used in the intersection.</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.Iris">
<span class="sig-prename descclassname"><span class="pre">pydrake.geometry.optimization.</span></span><span class="sig-name descname"><span class="pre">Iris</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">obstacles:</span> <span class="pre">List[pydrake.geometry.optimization.ConvexSet],</span> <span class="pre">sample:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]],</span> <span class="pre">domain:</span> <span class="pre">pydrake.geometry.optimization.HPolyhedron,</span> <span class="pre">options:</span> <span class="pre">pydrake.geometry.optimization.IrisOptions</span> <span class="pre">=</span> <span class="pre">IrisOptions(require_sample_point_is_contained=False,</span> <span class="pre">iteration_limit=100,</span> <span class="pre">termination_threshold=0.02,</span> <span class="pre">relative_termination_threshold=0.001,</span> <span class="pre">configuration_space_margin=0.01,</span> <span class="pre">num_collision_infeasible_samples=5,</span> <span class="pre">configuration_obstacles</span> <span class="pre">[],</span> <span class="pre">prog_with_additional_constraints</span> <span class="pre">is</span> <span class="pre">not</span> <span class="pre">set,</span> <span class="pre">num_additional_constraint_infeasible_samples=5,</span> <span class="pre">random_seed=1234)</span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.geometry.optimization.HPolyhedron" title="pydrake.geometry.optimization.HPolyhedron"><span class="pre">pydrake.geometry.optimization.HPolyhedron</span></a></span></span><a class="headerlink" href="#pydrake.geometry.optimization.Iris" title="Permalink to this definition"></a></dt>
<dd><p>The IRIS (Iterative Region Inflation by Semidefinite programming)
algorithm, as described in</p>
<p>R. L. H. Deits and R. Tedrake, “Computing large convex regions of
obstacle-free space through semidefinite programming,” Workshop on the
Algorithmic Fundamentals of Robotics, Istanbul, Aug. 2014.
<a class="reference external" href="http://groups.csail.mit.edu/robotics-center/public_papers/Deits14.pdf">http://groups.csail.mit.edu/robotics-center/public_papers/Deits14.pdf</a></p>
<p>This algorithm attempts to locally maximize the volume of a convex
polytope representing obstacle-free space given a sample point and
list of convex obstacles. Rather than compute the volume of the
polytope directly, the algorithm maximizes the volume of an inscribed
ellipsoid. It alternates between finding separating hyperplanes
between the ellipsoid and the obstacles and then finding a new
maximum-volume inscribed ellipsoid.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">obstacles</span></code>:</dt><dd><p>is a vector of convex sets representing the occupied space.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">sample</span></code>:</dt><dd><p>provides a point in the space; the algorithm is initialized using
a tiny sphere around this point. The algorithm is only guaranteed
to succeed if this sample point is collision free (outside of all
obstacles), but in practice the algorithm can often escape bad
initialization (assuming the require_sample_point_is_contained
option is false).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">domain</span></code>:</dt><dd><p>describes the total region of interest; computed IRIS regions will
be inside this domain. It must be bounded, and is typically a
simple bounding box (e.g. from HPolyhedron::MakeBox).</p>
</dd>
</dl>
<p>The <code class="docutils literal notranslate"><span class="pre">obstacles</span></code>, <code class="docutils literal notranslate"><span class="pre">sample</span></code>, and the <code class="docutils literal notranslate"><span class="pre">domain</span></code> must describe
elements in the same ambient dimension (but that dimension can be any
positive integer).</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.IrisInConfigurationSpace">
<span class="sig-prename descclassname"><span class="pre">pydrake.geometry.optimization.</span></span><span class="sig-name descname"><span class="pre">IrisInConfigurationSpace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">plant:</span> <span class="pre">drake::multibody::MultibodyPlant&lt;double&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options:</span> <span class="pre">pydrake.geometry.optimization.IrisOptions</span> <span class="pre">=</span> <span class="pre">IrisOptions(require_sample_point_is_contained=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iteration_limit=100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">termination_threshold=0.02</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">relative_termination_threshold=0.001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">configuration_space_margin=0.01</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_collision_infeasible_samples=5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">configuration_obstacles</span> <span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prog_with_additional_constraints</span> <span class="pre">is</span> <span class="pre">not</span> <span class="pre">set</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_additional_constraint_infeasible_samples=5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_seed=1234)</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.geometry.optimization.HPolyhedron" title="pydrake.geometry.optimization.HPolyhedron"><span class="pre">pydrake.geometry.optimization.HPolyhedron</span></a></span></span><a class="headerlink" href="#pydrake.geometry.optimization.IrisInConfigurationSpace" title="Permalink to this definition"></a></dt>
<dd><p>A variation of the Iris (Iterative Region Inflation by Semidefinite
programming) algorithm which finds collision-free regions in the
<em>configuration space</em> of <code class="docutils literal notranslate"><span class="pre">plant</span></code>.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>Iris for details on the original algorithm. This variant uses
nonlinear optimization (instead of convex optimization) to find
collisions in configuration space; each potential collision is
probabilistically “certified” by restarting the nonlinear
optimization from random initial seeds inside the candidate IRIS
region until it fails to find a collision in
<code class="docutils literal notranslate"><span class="pre">options.num_collision_infeasible_samples</span></code> consecutive attempts.</p>
</div>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">plant</span></code>:</dt><dd><p>describes the kinematics of configuration space. It must be
connected to a SceneGraph in a systems::Diagram.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>is a context of the <code class="docutils literal notranslate"><span class="pre">plant</span></code>. The context must have the positions
of the plant set to the initialIRIS seed configuration.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">options</span></code>:</dt><dd><p>provides additional configuration options. In particular,
increasing <code class="docutils literal notranslate"><span class="pre">options.num_collision_infeasible_samples</span></code> increases
the chances that the IRIS regions are collision free but can also
significantly increase the run-time of the algorithm. The same
goes for
<code class="docutils literal notranslate"><span class="pre">options.num_additional_constraints_infeasible_samples</span></code>.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the sample configuration in context is</strong> – </p></li>
<li><p><strong>infeasible.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.IrisOptions">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.geometry.optimization.</span></span><span class="sig-name descname"><span class="pre">IrisOptions</span></span><a class="headerlink" href="#pydrake.geometry.optimization.IrisOptions" title="Permalink to this definition"></a></dt>
<dd><p>Configuration options for the IRIS algorithm.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.IrisOptions.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.IrisOptions" title="pydrake.geometry.optimization.IrisOptions"><span class="pre">pydrake.geometry.optimization.IrisOptions</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.IrisOptions.__init__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.IrisOptions.bounding_region">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">bounding_region</span></span><a class="headerlink" href="#pydrake.geometry.optimization.IrisOptions.bounding_region" title="Permalink to this definition"></a></dt>
<dd><p>Optionally allows the caller to restrict the space within which IRIS
regions are allowed to grow. By default, IRIS regions are bounded by
the <code class="docutils literal notranslate"><span class="pre">domain</span></code> argument in the case of <code class="docutils literal notranslate"><span class="pre">Iris</span></code> or the joint limits of
the input <code class="docutils literal notranslate"><span class="pre">plant</span></code> in the case of <code class="docutils literal notranslate"><span class="pre">IrisInConfigurationSpace</span></code>. If
this option is specified, IRIS regions will be confined to the
intersection between the domain and <code class="docutils literal notranslate"><span class="pre">bounding_region</span></code></p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.IrisOptions.configuration_obstacles">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">configuration_obstacles</span></span><a class="headerlink" href="#pydrake.geometry.optimization.IrisOptions.configuration_obstacles" title="Permalink to this definition"></a></dt>
<dd><p>For IRIS in configuration space, it can be beneficial to not only
specify task-space obstacles (passed in through the plant) but also
obstacles that are defined by convex sets in the configuration space.
This option can be used to pass in such configuration space obstacles.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.IrisOptions.configuration_space_margin">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">configuration_space_margin</span></span><a class="headerlink" href="#pydrake.geometry.optimization.IrisOptions.configuration_space_margin" title="Permalink to this definition"></a></dt>
<dd><p>For IRIS in configuration space, we retreat by this margin from each
C-space obstacle in order to avoid the possibility of requiring an
infinite number of faces to approximate a curved boundary.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.IrisOptions.iteration_limit">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">iteration_limit</span></span><a class="headerlink" href="#pydrake.geometry.optimization.IrisOptions.iteration_limit" title="Permalink to this definition"></a></dt>
<dd><p>Maximum number of iterations.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.IrisOptions.num_additional_constraint_infeasible_samples">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">num_additional_constraint_infeasible_samples</span></span><a class="headerlink" href="#pydrake.geometry.optimization.IrisOptions.num_additional_constraint_infeasible_samples" title="Permalink to this definition"></a></dt>
<dd><p>For each constraint in <code class="docutils literal notranslate"><span class="pre">prog_with_additional_constraints</span></code>, IRIS will
search for a counter-example by formulating a (likely nonconvex)
optimization problem. The initial guess for this optimization is taken
by sampling uniformly inside the current IRIS region. This option
controls the termination condition for that counter-example search,
defining the number of consecutive failures to find a counter-example
requested before moving on to the next constraint.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.IrisOptions.num_collision_infeasible_samples">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">num_collision_infeasible_samples</span></span><a class="headerlink" href="#pydrake.geometry.optimization.IrisOptions.num_collision_infeasible_samples" title="Permalink to this definition"></a></dt>
<dd><p>For each possible collision, IRIS will search for a counter-example by
formulating a (likely nonconvex) optimization problem. The initial
guess for this optimization is taken by sampling uniformly inside the
current IRIS region. This option controls the termination condition
for that counter-example search, defining the number of consecutive
failures to find a counter-example requested before moving on to the
next constraint.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.IrisOptions.prog_with_additional_constraints">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">prog_with_additional_constraints</span></span><a class="headerlink" href="#pydrake.geometry.optimization.IrisOptions.prog_with_additional_constraints" title="Permalink to this definition"></a></dt>
<dd><p>By default, IRIS in configuration space certifies regions for
collision avoidance constraints and joint limits. This option can be
used to pass additional constraints that should be satisfied by the
IRIS region. We accept these in the form of a MathematicalProgram:</p>
<p>find q subject to g(q) ≤ 0.</p>
<p>The decision_variables() for the program are taken to define <code class="docutils literal notranslate"><span class="pre">q</span></code>.
IRIS will silently ignore any costs in
<code class="docutils literal notranslate"><span class="pre">prog_with_additional_constraints</span></code>, and will throw RuntimeError if
it contains any unsupported constraints.</p>
<p>For example, one could create an InverseKinematics problem with rich
kinematic constraints, and then pass <code class="docutils literal notranslate"><span class="pre">InverseKinematics::prog()</span></code>
into this option.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.IrisOptions.random_seed">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">random_seed</span></span><a class="headerlink" href="#pydrake.geometry.optimization.IrisOptions.random_seed" title="Permalink to this definition"></a></dt>
<dd><p>The only randomization in IRIS is the random sampling done to find
counter-examples for the additional constraints using in
IrisInConfigurationSpace. Use this option to set the initial seed.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.IrisOptions.relative_termination_threshold">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">relative_termination_threshold</span></span><a class="headerlink" href="#pydrake.geometry.optimization.IrisOptions.relative_termination_threshold" title="Permalink to this definition"></a></dt>
<dd><p>IRIS will terminate if the change in the <em>volume</em> of the
hyperellipsoid between iterations is less that this percent of the
previous best volume. This termination condition can be disabled by
setting to a negative value.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.IrisOptions.require_sample_point_is_contained">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">require_sample_point_is_contained</span></span><a class="headerlink" href="#pydrake.geometry.optimization.IrisOptions.require_sample_point_is_contained" title="Permalink to this definition"></a></dt>
<dd><p>The initial polytope is guaranteed to contain the point if that point
is collision-free. However, the IRIS alternation objectives do not
include (and can not easily include) a constraint that the original
sample point is contained. Therefore, the IRIS paper recommends that
if containment is a requirement, then the algorithm should simply
terminate early if alternations would ever cause the set to not
contain the point.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.IrisOptions.starting_ellipse">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">starting_ellipse</span></span><a class="headerlink" href="#pydrake.geometry.optimization.IrisOptions.starting_ellipse" title="Permalink to this definition"></a></dt>
<dd><p>The initial hyperepllipsoid that IRIS will use for calculating
hyperplanes in the first iteration. If no hyperellipsoid is provided,
a small hypershpere centered at the given sample will be used.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.IrisOptions.termination_threshold">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">termination_threshold</span></span><a class="headerlink" href="#pydrake.geometry.optimization.IrisOptions.termination_threshold" title="Permalink to this definition"></a></dt>
<dd><p>IRIS will terminate if the change in the <em>volume</em> of the
hyperellipsoid between iterations is less that this threshold. This
termination condition can be disabled by setting to a negative value.</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.LoadIrisRegionsYamlFile">
<span class="sig-prename descclassname"><span class="pre">pydrake.geometry.optimization.</span></span><span class="sig-name descname"><span class="pre">LoadIrisRegionsYamlFile</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">os.PathLike</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">child_name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Dict</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="#pydrake.geometry.optimization.HPolyhedron" title="pydrake.geometry.optimization.HPolyhedron"><span class="pre">pydrake.geometry.optimization.HPolyhedron</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.LoadIrisRegionsYamlFile" title="Permalink to this definition"></a></dt>
<dd><p>Calls LoadYamlFile() to deserialize an IrisRegions object.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.MakeIrisObstacles">
<span class="sig-prename descclassname"><span class="pre">pydrake.geometry.optimization.</span></span><span class="sig-name descname"><span class="pre">MakeIrisObstacles</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">query_object</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.QueryObject" title="pydrake.geometry.QueryObject"><span class="pre">pydrake.geometry.QueryObject</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">reference_frame</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.FrameId" title="pydrake.geometry.FrameId"><span class="pre">pydrake.geometry.FrameId</span></a><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#pydrake.geometry.optimization.ConvexSet" title="pydrake.geometry.optimization.ConvexSet"><span class="pre">pydrake.geometry.optimization.ConvexSet</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.MakeIrisObstacles" title="Permalink to this definition"></a></dt>
<dd><p>Constructs ConvexSet representations of obstacles for IRIS in 3D using
the geometry from a SceneGraph QueryObject. All geometry in the scene
with a proximity role, both anchored and dynamic, are consider to be
<em>fixed</em> obstacles frozen in the poses captured in the context used to
create the QueryObject.</p>
<p>When multiple representations are available for a particular geometry
(e.g. a Box can be represented as either an HPolyhedron or a
VPolytope), then this method will prioritize the representation that
we expect is most performant for the current implementation of the
IRIS algorithm.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.MinkowskiSum">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.geometry.optimization.</span></span><span class="sig-name descname"><span class="pre">MinkowskiSum</span></span><a class="headerlink" href="#pydrake.geometry.optimization.MinkowskiSum" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.geometry.optimization.ConvexSet" title="pydrake.geometry.optimization.ConvexSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.geometry.optimization.ConvexSet</span></code></a></p>
<p>A convex set that represents the Minkowski sum of multiple sets: S =
X₁ ⨁ X₂ ⨁ … ⨁ Xₙ = {x₁ + x₂ + … + xₙ | x₁ ∈ X₁, x₂ ∈ X₂, …, xₙ ∈
Xₙ}</p>
<p>Special behavior for IsEmpty: The Minkowski sum of zero sets (i.e.
when we have <a href="#id27"><span class="problematic" id="id28">sets_</span></a>.size() == 0) is treated as the singleton {0}, which
is nonempty. This includes the zero-dimensional case.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.MinkowskiSum.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.geometry.optimization.MinkowskiSum.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.geometry.optimization.MinkowskiSum) -&gt; None</p></li>
</ol>
<p>Constructs a default (zero-dimensional, nonempty) set.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.geometry.optimization.MinkowskiSum, sets: List[pydrake.geometry.optimization.ConvexSet]) -&gt; None</p></li>
</ol>
<p>Constructs the sum from a vector of convex sets.</p>
<ol class="arabic simple" start="3">
<li><p>__init__(self: pydrake.geometry.optimization.MinkowskiSum, setA: pydrake.geometry.optimization.ConvexSet, setB: pydrake.geometry.optimization.ConvexSet) -&gt; None</p></li>
</ol>
<p>Constructs the sum from a pair of convex sets.</p>
<ol class="arabic simple" start="4">
<li><p>__init__(self: pydrake.geometry.optimization.MinkowskiSum, query_object: pydrake.geometry.QueryObject, geometry_id: pydrake.geometry.GeometryId, reference_frame: Optional[pydrake.geometry.FrameId] = None) -&gt; None</p></li>
</ol>
<p>Constructs a MinkowskiSum from a SceneGraph geometry and pose in the
<code class="docutils literal notranslate"><span class="pre">reference_frame</span></code> frame, obtained via the QueryObject. If
<code class="docutils literal notranslate"><span class="pre">reference_frame</span></code> frame is std::nullopt, then it will be expressed
in the world frame.</p>
<p>Although in principle a MinkowskiSum can represent any ConvexSet as
the sum of a single set, here we only support Capsule geometry, which
will be represented as the (non-trivial) Minkowski sum of a sphere
with a line segment. Most SceneGraph geometry types are supported by
at least one of the ConvexSet class constructors.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if geometry_id does not correspond to a Capsule.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.MinkowskiSum.num_terms">
<span class="sig-name descname"><span class="pre">num_terms</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.MinkowskiSum" title="pydrake.geometry.optimization.MinkowskiSum"><span class="pre">pydrake.geometry.optimization.MinkowskiSum</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.MinkowskiSum.num_terms" title="Permalink to this definition"></a></dt>
<dd><p>The number of terms (or sets) used in the sum.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.MinkowskiSum.term">
<span class="sig-name descname"><span class="pre">term</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.MinkowskiSum" title="pydrake.geometry.optimization.MinkowskiSum"><span class="pre">pydrake.geometry.optimization.MinkowskiSum</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.geometry.optimization.ConvexSet" title="pydrake.geometry.optimization.ConvexSet"><span class="pre">pydrake.geometry.optimization.ConvexSet</span></a></span></span><a class="headerlink" href="#pydrake.geometry.optimization.MinkowskiSum.term" title="Permalink to this definition"></a></dt>
<dd><p>Returns a reference to the ConvexSet defining the <code class="docutils literal notranslate"><span class="pre">index</span></code> term in
the sum.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.PlaneSide">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.geometry.optimization.</span></span><span class="sig-name descname"><span class="pre">PlaneSide</span></span><a class="headerlink" href="#pydrake.geometry.optimization.PlaneSide" title="Permalink to this definition"></a></dt>
<dd><p>Members:</p>
<blockquote>
<div><p>kPositive</p>
<p>kNegative</p>
</div></blockquote>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.PlaneSide.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.PlaneSide" title="pydrake.geometry.optimization.PlaneSide"><span class="pre">pydrake.geometry.optimization.PlaneSide</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.PlaneSide.__init__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.PlaneSide.kNegative">
<span class="sig-name descname"><span class="pre">kNegative</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;PlaneSide.kNegative:</span> <span class="pre">1&gt;</span></em><a class="headerlink" href="#pydrake.geometry.optimization.PlaneSide.kNegative" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.PlaneSide.kPositive">
<span class="sig-name descname"><span class="pre">kPositive</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;PlaneSide.kPositive:</span> <span class="pre">0&gt;</span></em><a class="headerlink" href="#pydrake.geometry.optimization.PlaneSide.kPositive" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.PlaneSide.name">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">name</span></span><a class="headerlink" href="#pydrake.geometry.optimization.PlaneSide.name" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.PlaneSide.value">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">value</span></span><a class="headerlink" href="#pydrake.geometry.optimization.PlaneSide.value" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.Point">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.geometry.optimization.</span></span><span class="sig-name descname"><span class="pre">Point</span></span><a class="headerlink" href="#pydrake.geometry.optimization.Point" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.geometry.optimization.ConvexSet" title="pydrake.geometry.optimization.ConvexSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.geometry.optimization.ConvexSet</span></code></a></p>
<p>A convex set that contains exactly one element. Also known as a
singleton or unit set.</p>
<p>This set is always nonempty, even in the zero-dimensional case.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.Point.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.geometry.optimization.Point.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.geometry.optimization.Point) -&gt; None</p></li>
</ol>
<p>Constructs a default (zero-dimensional, nonempty) set.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.geometry.optimization.Point, x: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</p></li>
</ol>
<p>Constructs a Point.</p>
<ol class="arabic simple" start="3">
<li><p>__init__(self: pydrake.geometry.optimization.Point, query_object: pydrake.geometry.QueryObject, geometry_id: pydrake.geometry.GeometryId, reference_frame: Optional[pydrake.geometry.FrameId] = None, maximum_allowable_radius: float = 0.0) -&gt; None</p></li>
</ol>
<p>Constructs a Point from a SceneGraph geometry and pose in the
<code class="docutils literal notranslate"><span class="pre">reference_frame</span></code> frame, obtained via the QueryObject. If
<code class="docutils literal notranslate"><span class="pre">reference_frame</span></code> frame is std::nullopt, then it will be expressed
in the world frame.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if geometry_id does not correspond to a Sphere</strong><strong> or </strong><strong>if</strong> – </p></li>
<li><p><strong>the Sphere has radius greater than maximum_allowable_radius.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.Point.set_x">
<span class="sig-name descname"><span class="pre">set_x</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.Point" title="pydrake.geometry.optimization.Point"><span class="pre">pydrake.geometry.optimization.Point</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.Point.set_x" title="Permalink to this definition"></a></dt>
<dd><p>Changes the element <code class="docutils literal notranslate"><span class="pre">x</span></code> describing the set.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>x must be of size ambient_dimension().</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.Point.x">
<span class="sig-name descname"><span class="pre">x</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.Point" title="pydrake.geometry.optimization.Point"><span class="pre">pydrake.geometry.optimization.Point</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.Point.x" title="Permalink to this definition"></a></dt>
<dd><p>Retrieves the point.</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.SaveIrisRegionsYamlFile">
<span class="sig-prename descclassname"><span class="pre">pydrake.geometry.optimization.</span></span><span class="sig-name descname"><span class="pre">SaveIrisRegionsYamlFile</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">os.PathLike</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">regions</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Dict</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="#pydrake.geometry.optimization.HPolyhedron" title="pydrake.geometry.optimization.HPolyhedron"><span class="pre">pydrake.geometry.optimization.HPolyhedron</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">child_name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.SaveIrisRegionsYamlFile" title="Permalink to this definition"></a></dt>
<dd><p>Calls SaveYamlFile() to serialize an IrisRegions object.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.SeparatingPlaneOrder">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.geometry.optimization.</span></span><span class="sig-name descname"><span class="pre">SeparatingPlaneOrder</span></span><a class="headerlink" href="#pydrake.geometry.optimization.SeparatingPlaneOrder" title="Permalink to this definition"></a></dt>
<dd><p>The separating plane aᵀx + b ≥ δ, aᵀx + b ≤ −δ has parameters a and b.
These parameterize a polynomial function of <code class="docutils literal notranslate"><span class="pre">s_for_plane</span></code> with the
specified order. <code class="docutils literal notranslate"><span class="pre">s_for_plane</span></code> is a sub set of the
configuration-space variable <code class="docutils literal notranslate"><span class="pre">s</span></code>, please refer to the
RationalForwardKinematics class or the paper above on the meaning of
s.</p>
<p>Members:</p>
<blockquote>
<div><p>kAffine : a and b are affine functions of s.</p>
</div></blockquote>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.SeparatingPlaneOrder.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.SeparatingPlaneOrder" title="pydrake.geometry.optimization.SeparatingPlaneOrder"><span class="pre">pydrake.geometry.optimization.SeparatingPlaneOrder</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.SeparatingPlaneOrder.__init__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.SeparatingPlaneOrder.kAffine">
<span class="sig-name descname"><span class="pre">kAffine</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;SeparatingPlaneOrder.kAffine:</span> <span class="pre">1&gt;</span></em><a class="headerlink" href="#pydrake.geometry.optimization.SeparatingPlaneOrder.kAffine" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.SeparatingPlaneOrder.name">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">name</span></span><a class="headerlink" href="#pydrake.geometry.optimization.SeparatingPlaneOrder.name" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.SeparatingPlaneOrder.value">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">value</span></span><a class="headerlink" href="#pydrake.geometry.optimization.SeparatingPlaneOrder.value" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.SeparationCertificateProgramBase">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.geometry.optimization.</span></span><span class="sig-name descname"><span class="pre">SeparationCertificateProgramBase</span></span><a class="headerlink" href="#pydrake.geometry.optimization.SeparationCertificateProgramBase" title="Permalink to this definition"></a></dt>
<dd><dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.SeparationCertificateProgramBase.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.geometry.optimization.SeparationCertificateProgramBase.__init__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.SeparationCertificateProgramBase.plane_index">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">plane_index</span></span><a class="headerlink" href="#pydrake.geometry.optimization.SeparationCertificateProgramBase.plane_index" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.SeparationCertificateProgramBase.prog">
<span class="sig-name descname"><span class="pre">prog</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.SeparationCertificateProgramBase" title="pydrake.geometry.optimization.SeparationCertificateProgramBase"><span class="pre">pydrake.geometry.optimization.SeparationCertificateProgramBase</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.solvers.html#pydrake.solvers.MathematicalProgram" title="pydrake.solvers.MathematicalProgram"><span class="pre">pydrake.solvers.MathematicalProgram</span></a></span></span><a class="headerlink" href="#pydrake.geometry.optimization.SeparationCertificateProgramBase.prog" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.SeparationCertificateResultBase">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.geometry.optimization.</span></span><span class="sig-name descname"><span class="pre">SeparationCertificateResultBase</span></span><a class="headerlink" href="#pydrake.geometry.optimization.SeparationCertificateResultBase" title="Permalink to this definition"></a></dt>
<dd><p>We certify that a pair of geometries is collision free by finding the
separating plane over a range of configuration. The Lagrangian
multipliers used for certifying this condition will differ in derived
classes. This struct contains the the separating plane {x | aᵀx+b=0 }
and derived classes may store the Lagrangians certifying that the
plane separates the two geometries in separating_planes()[plane_index]
in the C-space region.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.SeparationCertificateResultBase.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.geometry.optimization.SeparationCertificateResultBase.__init__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.SeparationCertificateResultBase.a">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">a</span></span><a class="headerlink" href="#pydrake.geometry.optimization.SeparationCertificateResultBase.a" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.SeparationCertificateResultBase.b">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">b</span></span><a class="headerlink" href="#pydrake.geometry.optimization.SeparationCertificateResultBase.b" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.SeparationCertificateResultBase.plane_decision_var_vals">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">plane_decision_var_vals</span></span><a class="headerlink" href="#pydrake.geometry.optimization.SeparationCertificateResultBase.plane_decision_var_vals" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.SeparationCertificateResultBase.result">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">result</span></span><a class="headerlink" href="#pydrake.geometry.optimization.SeparationCertificateResultBase.result" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.Spectrahedron">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.geometry.optimization.</span></span><span class="sig-name descname"><span class="pre">Spectrahedron</span></span><a class="headerlink" href="#pydrake.geometry.optimization.Spectrahedron" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.geometry.optimization.ConvexSet" title="pydrake.geometry.optimization.ConvexSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.geometry.optimization.ConvexSet</span></code></a></p>
<p>Implements a spectrahedron (the feasible set of a semidefinite
program). The ambient dimension of the set is N(N+1)/2; the number of
variables required to describe the N-by-N semidefinite matrix.</p>
<p>By convention, a zero-dimensional spectrahedron is considered
nonempty.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.Spectrahedron.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.geometry.optimization.Spectrahedron.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.geometry.optimization.Spectrahedron) -&gt; None</p></li>
</ol>
<p>Default constructor (yields the zero-dimensional nonempty set).</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.geometry.optimization.Spectrahedron, prog: pydrake.solvers.MathematicalProgram) -&gt; None</p></li>
</ol>
<p>Constructs the spectrahedron from a MathematicalProgram.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if prog.required_capabilities</strong><strong>(</strong><strong>) </strong><strong>is not a subset</strong> – </p></li>
<li><p><strong>of supported_attributes</strong><strong>(</strong><strong>)</strong><strong></strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.VPolytope">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.geometry.optimization.</span></span><span class="sig-name descname"><span class="pre">VPolytope</span></span><a class="headerlink" href="#pydrake.geometry.optimization.VPolytope" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.geometry.optimization.ConvexSet" title="pydrake.geometry.optimization.ConvexSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.geometry.optimization.ConvexSet</span></code></a></p>
<p>A polytope described using the vertex representation. The set is
defined as the convex hull of the vertices. The vertices are not
guaranteed to be in any particular order, nor to be minimal (some
vertices could be strictly in the interior of the set).</p>
<p>Note: Unlike the half-space representation, this definition means the
set is always bounded (hence the name polytope, instead of
polyhedron).</p>
<p>A VPolytope is empty if and only if it is composed of zero vertices,
i.e., if <a href="#id29"><span class="problematic" id="id30">vertices_</span></a>.cols() == 0. This includes the zero-dimensional
case. If <a href="#id31"><span class="problematic" id="id32">vertices_</span></a>.rows() == 0 but <a href="#id33"><span class="problematic" id="id34">vertices_</span></a>.cols() &gt; 0, we treat this
as having one or more copies of 0 in the zero-dimensional vector space
{0}. If <a href="#id35"><span class="problematic" id="id36">vertices_</span></a>.rows() and <a href="#id37"><span class="problematic" id="id38">vertices_</span></a>.cols() are zero, we treat this
as no points in {0}, which is empty.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.VPolytope.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.geometry.optimization.VPolytope.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.geometry.optimization.VPolytope) -&gt; None</p></li>
</ol>
<p>Constructs a set with no vertices in the zero-dimensional space, which
is empty (by convention).</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.geometry.optimization.VPolytope, vertices: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous]) -&gt; None</p></li>
</ol>
<p>Constructs the polytope from a d-by-n matrix, where d is the ambient
dimension, and n is the number of vertices. The vertices do not have
to be ordered, nor minimal (they can contain points inside their
convex hull).</p>
<ol class="arabic simple" start="3">
<li><p>__init__(self: pydrake.geometry.optimization.VPolytope, H: pydrake.geometry.optimization.HPolyhedron) -&gt; None</p></li>
</ol>
<p>Constructs the polytope from a bounded polyhedron (using Qhull). If
the HPolyhedron is not full-dimensional, we perform computations in a
coordinate system of its affine hull. <code class="docutils literal notranslate"><span class="pre">tol</span></code> specifies the numerical
tolerance used in the computation of the affine hull. See the
documentation of AffineSubspace for more details. A loose tolerance is
necessary for the built-in solvers, but a tighter tolerance can be
used with commercial solvers (e.g. Gurobi and Mosek).</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if H is unbounded</strong><strong> or </strong><strong>if Qhull terminates with an</strong> – </p></li>
<li><p><strong>error.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="4">
<li><p>__init__(self: pydrake.geometry.optimization.VPolytope, query_object: pydrake.geometry.QueryObject, geometry_id: pydrake.geometry.GeometryId, reference_frame: Optional[pydrake.geometry.FrameId] = None) -&gt; None</p></li>
</ol>
<p>Constructs the polytope from a SceneGraph geometry.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.VPolytope.GetMinimalRepresentation">
<span class="sig-name descname"><span class="pre">GetMinimalRepresentation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.VPolytope" title="pydrake.geometry.optimization.VPolytope"><span class="pre">pydrake.geometry.optimization.VPolytope</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.geometry.optimization.VPolytope" title="pydrake.geometry.optimization.VPolytope"><span class="pre">pydrake.geometry.optimization.VPolytope</span></a></span></span><a class="headerlink" href="#pydrake.geometry.optimization.VPolytope.GetMinimalRepresentation" title="Permalink to this definition"></a></dt>
<dd><p>Creates a new VPolytope whose vertices are guaranteed to be minimal,
i.e., if we remove any point from its vertices, then the convex hull
of the remaining vertices is a strict subset of the polytope. In the
2D case the vertices of the new VPolytope are ordered
counter-clockwise from the negative X axis. For all other cases an
order is not guaranteed.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.VPolytope.MakeBox">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">MakeBox</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lb</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ub</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.geometry.optimization.VPolytope" title="pydrake.geometry.optimization.VPolytope"><span class="pre">pydrake.geometry.optimization.VPolytope</span></a></span></span><a class="headerlink" href="#pydrake.geometry.optimization.VPolytope.MakeBox" title="Permalink to this definition"></a></dt>
<dd><p>Constructs a polyhedron as an axis-aligned box from the lower and
upper corners.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.VPolytope.MakeUnitBox">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">MakeUnitBox</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.geometry.optimization.VPolytope" title="pydrake.geometry.optimization.VPolytope"><span class="pre">pydrake.geometry.optimization.VPolytope</span></a></span></span><a class="headerlink" href="#pydrake.geometry.optimization.VPolytope.MakeUnitBox" title="Permalink to this definition"></a></dt>
<dd><p>Constructs the L∞-norm unit box in <code class="docutils literal notranslate"><span class="pre">dim</span></code> dimensions, {x | <a href="#id13"><span class="problematic" id="id14">|</span></a>x|∞ &lt;= 1
}. This is an axis-aligned box, centered at the origin, with edge
length 2.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.VPolytope.vertices">
<span class="sig-name descname"><span class="pre">vertices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.VPolytope" title="pydrake.geometry.optimization.VPolytope"><span class="pre">pydrake.geometry.optimization.VPolytope</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.VPolytope.vertices" title="Permalink to this definition"></a></dt>
<dd><p>Returns the vertices in a d-by-n matrix, where d is the ambient
dimension, and n is the number of vertices.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.geometry.optimization.VPolytope.WriteObj">
<span class="sig-name descname"><span class="pre">WriteObj</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.geometry.optimization.VPolytope" title="pydrake.geometry.optimization.VPolytope"><span class="pre">pydrake.geometry.optimization.VPolytope</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">os.PathLike</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.geometry.optimization.VPolytope.WriteObj" title="Permalink to this definition"></a></dt>
<dd><p>Uses qhull to compute the Delaunay triangulation and then writes the
vertices and faces to <code class="docutils literal notranslate"><span class="pre">filename</span></code> in the Wavefront Obj format. Note
that the extension <code class="docutils literal notranslate"><span class="pre">.obj</span></code> is not automatically added to the
<code class="docutils literal notranslate"><span class="pre">filename</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>ambient_dimension() == 3.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="pydrake.geometry.all.html" class="btn btn-neutral float-left" title="pydrake.geometry.all" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="pydrake.gym.html" class="btn btn-neutral float-right" title="pydrake.gym" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p></p>
  </div>

  
</footer>
<script>
  /* Enables clicking for the mobile "hamburger" (three-line) menu item. */
  const siteHeader = document.querySelector('.site-header')
  const mobileButton = document.querySelector('.menu-mobile-toggle')
  const body = document.querySelector('body')

  mobileButton.addEventListener('click', function(event) {
    siteHeader.classList.toggle('open');
    body.classList.toggle('overflow-hidden');
  })
</script>
<footer class="site-footer padding">
  <div class="contain">
    <a href="/" class="drake-logo">
      <img src="/images/drake-logo.svg">
    </a>
    <div class="footer-menu">
      <ul>
        <li>
          <a href="/doxygen_cxx/index.html" class="site-menu-item">C++</a>
        </li>
        <li>
          <a href="/pydrake/index.html" class="site-menu-item">Python</a>
        </li>
        <li class="github-link">
          <a href="https://github.com/RobotLocomotion/drake" class="site-menu-item">GitHub <img src="/third_party/images/GitHub-Mark-64px.png"></a>
        </li>
      </ul>
    </div>
  </div>


</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>