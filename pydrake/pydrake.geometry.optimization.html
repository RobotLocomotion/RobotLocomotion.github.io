

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>pydrake.geometry.optimization &mdash; pydrake  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/custom.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="pydrake.geometry.render" href="pydrake.geometry.render.html" />
    <link rel="prev" title="pydrake.geometry.all" href="pydrake.geometry.all.html" /> 
</head>

<body class="wy-body-for-nav">

  
<header class="site-header">
  <div class="site-header-inner contain">
    <a class="drake-logo" href="/"><img src="/images/drake-logo-white.svg"></a>
    <div class="menu-mobile-toggle">
      <span></span>
    </div>
    <nav class="site-menu">
      <ul>
        <li class="site-menu-item site-menu-item-main">
          <a class="site-menu-item" href="/">Home</a>
        </li>
        <li class="site-menu-item site-menu-item-main">
          <a class="site-menu-item" href="/installation.html">Installation</a>
        </li>
        <li class="site-menu-item site-menu-item-main">
          <a class="site-menu-item" href="/gallery.html">Gallery</a>
        </li>
        <li class="site-menu-item site-menu-item-main">API Documentation
          <div class="sub">
            <a class="site-menu-item" href="https://drake.mit.edu/doxygen_cxx/index.html">C++</a> <a class="site-menu-item" href="https://drake.mit.edu/pydrake/index.html">Python</a>
          </div>
        </li>
        <li class="site-menu-item site-menu-item-main">Resources
          <div class="sub">
            <a class="site-menu-item" href="/getting_help.html">Getting Help</a> <a class="site-menu-item" href="https://deepnote.com/workspace/Drake-0b3b2c53-a7ad-441b-80f8-bf8350752305/project/Tutorials-2b4fc509-aef2-417d-a40d-6071dfed9199/%2Findex.ipynb">Tutorials</a> <a class="site-menu-item" href="/python_bindings.html">Python Bindings</a> <a class="site-menu-item" href="/developers.html">For Developers</a> <a class="site-menu-item" href="/credits.html">Credits</a>
          </div>
        </li>
        <li class="github-link">
          <a class="site-menu-item" href="https://github.com/RobotLocomotion/drake">GitHub <img src="/third_party/images/GitHub-Mark-Light-64px.png"></a>
        </li>
      </ul>
    </nav>
  </div>
</header>

  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> pydrake
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search pydrake only…" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
  <form id="ddg-search-form" class="wy_form" action="https://duckduckgo.com/" method="get">
    <input type="text" name="q" placeholder="Search all of Drake…" />
    <input type="hidden" name="sites" value="drake.mit.edu" />
  </form>
</div>


          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="pydrake.all.html">pydrake.all</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.autodiffutils.html">pydrake.autodiffutils</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.common.html">pydrake.common</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.examples.html">pydrake.examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.forwarddiff.html">pydrake.forwarddiff</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="pydrake.geometry.html">pydrake.geometry</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="pydrake.geometry.all.html">pydrake.geometry.all</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">pydrake.geometry.optimization</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.geometry.render.html">pydrake.geometry.render</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.lcm.html">pydrake.lcm</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.manipulation.html">pydrake.manipulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.math.html">pydrake.math</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.multibody.html">pydrake.multibody</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.perception.html">pydrake.perception</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.polynomial.html">pydrake.polynomial</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.solvers.html">pydrake.solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.symbolic.html">pydrake.symbolic</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.systems.html">pydrake.systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.trajectories.html">pydrake.trajectories</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.tutorials.html">pydrake.tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.visualization.html">pydrake.visualization</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">pydrake</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
          <li><a href="pydrake.geometry.html">pydrake.geometry</a> &raquo;</li>
        
      <li>pydrake.geometry.optimization</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="module-pydrake.geometry.optimization">
<span id="pydrake-geometry-optimization"></span><h1>pydrake.geometry.optimization<a class="headerlink" href="#module-pydrake.geometry.optimization" title="Permalink to this headline">¶</a></h1>
<p>Local bindings for <cite>drake::geometry::optimization</cite></p>
<dl class="class">
<dt id="pydrake.geometry.optimization.CartesianProduct">
<em class="property">class </em><code class="descclassname">pydrake.geometry.optimization.</code><code class="descname">CartesianProduct</code><a class="headerlink" href="#pydrake.geometry.optimization.CartesianProduct" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.geometry.optimization.ConvexSet" title="pydrake.geometry.optimization.ConvexSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.geometry.optimization.ConvexSet</span></code></a></p>
<p>The Cartesian product of convex sets is a convex set: S = X₁ × X₂ × ⋯
× Xₙ = {(x₁, x₂, …, xₙ) | x₁ ∈ X₁, x₂ ∈ X₂, …, xₙ ∈ Xₙ}.</p>
<p>This class also supports a generalization of this concept in which the
coordinates are transformed by the linear map, {x | y = Ax + b, y ∈ Y₁
× Y₂ × ⋯ × Yₙ}, with the default values set to the identity map. This
concept is required for reasoning about cylinders in arbitrary poses
as cartesian products, and more generally for describing any affine
transform of a CartesianProduct.</p>
<dl class="method">
<dt id="pydrake.geometry.optimization.CartesianProduct.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.geometry.optimization.CartesianProduct.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.geometry.optimization.CartesianProduct, sets: List[pydrake.geometry.optimization.CopyableUniquePtrConvexSet]) -&gt; None</li>
</ol>
<p>Constructs the product from a vector of convex sets.</p>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.geometry.optimization.CartesianProduct, setA: pydrake.geometry.optimization.ConvexSet, setB: pydrake.geometry.optimization.ConvexSet) -&gt; None</li>
</ol>
<p>Constructs the product from a pair of convex sets.</p>
<ol class="arabic simple" start="3">
<li>__init__(self: pydrake.geometry.optimization.CartesianProduct, sets: List[pydrake.geometry.optimization.CopyableUniquePtrConvexSet], A: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], b: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</li>
</ol>
<p>Constructs the product of convex sets in the transformed coordinates:
{x | y = Ax + b, y ∈ Y₁ × Y₂ × ⋯ × Yₙ}. <code class="docutils literal notranslate"><span class="pre">A</span></code> must be full column
rank.</p>
<ol class="arabic simple" start="4">
<li>__init__(self: pydrake.geometry.optimization.CartesianProduct, query_object: pydrake.geometry.QueryObject_[float], geometry_id: pydrake.geometry.GeometryId, reference_frame: Optional[pydrake.geometry.FrameId] = None) -&gt; None</li>
</ol>
<p>Constructs a CartesianProduct from a SceneGraph geometry and pose in
the <code class="docutils literal notranslate"><span class="pre">reference_frame</span></code> frame, obtained via the QueryObject. If
<code class="docutils literal notranslate"><span class="pre">reference_frame</span></code> frame is std::nullopt, then it will be expressed
in the world frame.</p>
<p>Although any geometry that can be used as a ConvexSet could also be a
(trivial) CartesianProduct, we restrict this constructor to handling
Cylinder geometry, which constructs the (non-trivial) Cartesian
product of a HyperEllipsoid and an HPolyhedron. Most other SceneGraph
geometry types are supported by at least one of the ConvexSet class
constructors.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if geometry_id does not correspond to a Cylinder.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.CartesianProduct.factor">
<code class="descname">factor</code><span class="sig-paren">(</span><em>self: pydrake.geometry.optimization.CartesianProduct</em>, <em>index: int</em><span class="sig-paren">)</span> &#x2192; pydrake.geometry.optimization.ConvexSet<a class="headerlink" href="#pydrake.geometry.optimization.CartesianProduct.factor" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a reference to the ConvexSet defining the <code class="docutils literal notranslate"><span class="pre">index</span></code> factor in
the product.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.CartesianProduct.num_factors">
<code class="descname">num_factors</code><span class="sig-paren">(</span><em>self: pydrake.geometry.optimization.CartesianProduct</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.geometry.optimization.CartesianProduct.num_factors" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of factors (or sets) used in the product.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.geometry.optimization.ConvexSet">
<em class="property">class </em><code class="descclassname">pydrake.geometry.optimization.</code><code class="descname">ConvexSet</code><a class="headerlink" href="#pydrake.geometry.optimization.ConvexSet" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract base class for defining a convex set.</p>
<dl class="attribute">
<dt id="pydrake.geometry.optimization.ConvexSet.__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.geometry.optimization.ConvexSet.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.ConvexSet.AddPointInNonnegativeScalingConstraints">
<code class="descname">AddPointInNonnegativeScalingConstraints</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.geometry.optimization.ConvexSet.AddPointInNonnegativeScalingConstraints" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>AddPointInNonnegativeScalingConstraints(self: pydrake.geometry.optimization.ConvexSet, prog: pydrake.solvers.MathematicalProgram, x: numpy.ndarray[object[m, 1]], t: pydrake.symbolic.Variable) -&gt; List[pydrake.solvers.Binding[Constraint]]</li>
</ol>
<p>Let S be this convex set. When S is bounded, this method adds the
convex constraints to imply</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>x ∈ t S,
t ≥ 0,
</pre></div>
</div>
<p>where x is a point in ℜⁿ (with n the ambient_dimension) and t is a
scalar.</p>
<p>When S is unbounded, then the behavior is almost identical, except
when t=0. In this case, the constraints imply t ≥ 0, x ∈ t S ⊕ rec(S),
where rec(S) is the recession cone of S (the asymptotic directions in
which S is not bounded) and ⊕ is the Minkowski sum. For t &gt; 0, this is
equivalent to x ∈ t S, but for t = 0, we have only x ∈ rec(S).</p>
<ol class="arabic simple" start="2">
<li>AddPointInNonnegativeScalingConstraints(self: pydrake.geometry.optimization.ConvexSet, prog: pydrake.solvers.MathematicalProgram, A: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], b: numpy.ndarray[numpy.float64[m, 1]], c: numpy.ndarray[numpy.float64[m, 1]], d: float, x: numpy.ndarray[object[m, 1]], t: numpy.ndarray[object[m, 1]]) -&gt; List[pydrake.solvers.Binding[Constraint]]</li>
</ol>
<p>Let S be this convex set. When S is bounded, this method adds the
convex constraints to imply</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>A * x + b ∈ (c&#39; * t + d) S,
c * t + d ≥ 0,
</pre></div>
</div>
<p>where A is an n-by-m matrix (with n the ambient_dimension), b is a
vector of size n, c is a vector of size p, x is a point in ℜᵐ, and t
is a point in ℜᵖ.</p>
<p>When S is unbounded, then the behavior is almost identical, except
when c’ * t+d=0. In this case, the constraints imply</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>A * x + b ∈ (c&#39; * t + d) S ⊕ rec(S),
c&#39; * t + d ≥ 0,
</pre></div>
</div>
<p>where rec(S) is the recession cone of S (the asymptotic directions in
which S is not bounded) and ⊕ is the Minkowski sum. For c’ * t + d &gt;
0, this is equivalent to A * x + b ∈ (c’ * t + d) S, but for c’ * t +
d = 0, we have only A * x + b ∈ rec(S).</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.ConvexSet.AddPointInSetConstraints">
<code class="descname">AddPointInSetConstraints</code><span class="sig-paren">(</span><em>self: pydrake.geometry.optimization.ConvexSet, prog: pydrake.solvers.MathematicalProgram, vars: numpy.ndarray[object[m, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.geometry.optimization.ConvexSet.AddPointInSetConstraints" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a constraint to an existing MathematicalProgram enforcing that
the point defined by vars is inside the set.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.ConvexSet.ambient_dimension">
<code class="descname">ambient_dimension</code><span class="sig-paren">(</span><em>self: pydrake.geometry.optimization.ConvexSet</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.geometry.optimization.ConvexSet.ambient_dimension" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the dimension of the vector space in which the elements of
this set are evaluated. Contrast this with the <code class="docutils literal notranslate"><span class="pre">affine</span> <span class="pre">dimension</span></code>:
the dimension of the smallest affine subset of the ambient space that
contains our set. For example, if we define a set using <code class="docutils literal notranslate"><span class="pre">A*x</span> <span class="pre">=</span> <span class="pre">b</span></code>,
where <code class="docutils literal notranslate"><span class="pre">A</span></code> has linearly independent rows, then the ambient dimension
is the dimension of <code class="docutils literal notranslate"><span class="pre">x</span></code>, but the affine dimension of the set is
<code class="docutils literal notranslate"><span class="pre">ambient_dimension()</span> <span class="pre">-</span> <span class="pre">rank(A)</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.ConvexSet.Clone">
<code class="descname">Clone</code><span class="sig-paren">(</span><em>self: pydrake.geometry.optimization.ConvexSet</em><span class="sig-paren">)</span> &#x2192; pydrake.geometry.optimization.ConvexSet<a class="headerlink" href="#pydrake.geometry.optimization.ConvexSet.Clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a unique deep copy of this set.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.ConvexSet.IntersectsWith">
<code class="descname">IntersectsWith</code><span class="sig-paren">(</span><em>self: pydrake.geometry.optimization.ConvexSet</em>, <em>other: pydrake.geometry.optimization.ConvexSet</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.geometry.optimization.ConvexSet.IntersectsWith" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true iff the intersection between <code class="docutils literal notranslate"><span class="pre">this</span></code> and <code class="docutils literal notranslate"><span class="pre">other</span></code> is
non-empty.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the ambient dimension of <code class="docutils literal notranslate"><span class="pre">other</span></code> is not the same</li>
<li>as that of <code class="docutils literal notranslate"><span class="pre">this</span></code>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.ConvexSet.IsBounded">
<code class="descname">IsBounded</code><span class="sig-paren">(</span><em>self: pydrake.geometry.optimization.ConvexSet</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.geometry.optimization.ConvexSet.IsBounded" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true iff the set is bounded, e.g. there exists an element-wise
finite lower and upper bound for the set. Note: for some derived
classes, this check is trivial, but for others it can require solving
an (typically small) optimization problem. Check the derived class
documentation for any notes.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.ConvexSet.PointInSet">
<code class="descname">PointInSet</code><span class="sig-paren">(</span><em>self: pydrake.geometry.optimization.ConvexSet, x: numpy.ndarray[numpy.float64[m, 1]], tol: float = 1e-08</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.geometry.optimization.ConvexSet.PointInSet" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true iff the point x is contained in the set.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.ConvexSet.ToShapeWithPose">
<code class="descname">ToShapeWithPose</code><span class="sig-paren">(</span><em>self: pydrake.geometry.optimization.ConvexSet</em><span class="sig-paren">)</span> &#x2192; Tuple[pydrake.geometry.Shape, pydrake.math.RigidTransform_[float]]<a class="headerlink" href="#pydrake.geometry.optimization.ConvexSet.ToShapeWithPose" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs a Shape and a pose of the set in the world frame for use in
the SceneGraph geometry ecosystem.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if ambient_dimension() != 3 or if the functionality</li>
<li>for a particular set has not been implemented yet.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.geometry.optimization.CopyableUniquePtrConvexSet">
<em class="property">class </em><code class="descclassname">pydrake.geometry.optimization.</code><code class="descname">CopyableUniquePtrConvexSet</code><a class="headerlink" href="#pydrake.geometry.optimization.CopyableUniquePtrConvexSet" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="pydrake.geometry.optimization.CopyableUniquePtrConvexSet.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.geometry.optimization.CopyableUniquePtrConvexSet</em>, <em>arg0: pydrake.geometry.optimization.ConvexSet</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.geometry.optimization.CopyableUniquePtrConvexSet.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.geometry.optimization.GraphOfConvexSets">
<em class="property">class </em><code class="descclassname">pydrake.geometry.optimization.</code><code class="descname">GraphOfConvexSets</code><a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets" title="Permalink to this definition">¶</a></dt>
<dd><p>GraphOfConvexSets implements the design pattern and optimization
problems first introduced in the paper “Shortest Paths in Graphs of
Convex Sets”.</p>
<p>“Shortest Paths in Graphs of Convex Sets” by Tobia Marcucci, Jack
Umenberger, Pablo A. Parrilo, Russ Tedrake.
<a class="reference external" href="https://arxiv.org/abs/2101.11565">https://arxiv.org/abs/2101.11565</a></p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This feature is considered to be <strong>experimental</strong> and may change
or be removed at any time, without any deprecation notice ahead of
time.</p>
</div>
<p>Each vertex in the graph is associated with a convex set over
continuous variables, edges in the graph contain convex costs and
constraints on these continuous variables. We can then formulate
optimization problems over this graph, such as the shortest path
problem where each visit to a vertex also corresponds to selecting an
element from the convex set subject to the costs and constraints.
Behind the scenes, we construct efficient mixed-integer convex
transcriptions of the graph problem using MathematicalProgram.</p>
<p>Design note: This class avoids providing any direct access to the
MathematicalProgram that it constructs nor to the decision variables /
constraints. The users should be able to write constraints against
“placeholder” decision variables on the vertices and edges, but these
get translated in non-trivial ways to the underlying program.</p>
<dl class="method">
<dt id="pydrake.geometry.optimization.GraphOfConvexSets.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.geometry.optimization.GraphOfConvexSets</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs an empty graph.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.GraphOfConvexSets.AddEdge">
<code class="descname">AddEdge</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.AddEdge" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>AddEdge(self: pydrake.geometry.optimization.GraphOfConvexSets, u_id: drake::Identifier&lt;drake::geometry::optimization::VertexTag&gt;, v_id: drake::Identifier&lt;drake::geometry::optimization::VertexTag&gt;, name: str = ‘’) -&gt; drake::geometry::optimization::GraphOfConvexSets::Edge</li>
</ol>
<p>Adds an edge to the graph from VertexId <code class="docutils literal notranslate"><span class="pre">u_id</span></code> to VertexId <code class="docutils literal notranslate"><span class="pre">v_id</span></code>.
The ids must refer to valid vertices in this graph. If <code class="docutils literal notranslate"><span class="pre">name</span></code> is
empty then a default name will be provided.</p>
<ol class="arabic simple" start="2">
<li>AddEdge(self: pydrake.geometry.optimization.GraphOfConvexSets, u: drake::geometry::optimization::GraphOfConvexSets::Vertex, v: drake::geometry::optimization::GraphOfConvexSets::Vertex, name: str = ‘’) -&gt; drake::geometry::optimization::GraphOfConvexSets::Edge</li>
</ol>
<p>Adds an edge to the graph from Vertex <code class="docutils literal notranslate"><span class="pre">u</span></code> to Vertex <code class="docutils literal notranslate"><span class="pre">v</span></code>. The
vertex references must refer to valid vertices in this graph. If
<code class="docutils literal notranslate"><span class="pre">name</span></code> is empty then a default name will be provided.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.GraphOfConvexSets.AddVertex">
<code class="descname">AddVertex</code><span class="sig-paren">(</span><em>self: pydrake.geometry.optimization.GraphOfConvexSets</em>, <em>set: pydrake.geometry.optimization.ConvexSet</em>, <em>name: str = ''</em><span class="sig-paren">)</span> &#x2192; drake::geometry::optimization::GraphOfConvexSets::Vertex<a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.AddVertex" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a vertex to the graph. A copy of <code class="docutils literal notranslate"><span class="pre">set</span></code> is cloned and stored
inside the graph. If <code class="docutils literal notranslate"><span class="pre">name</span></code> is empty then a default name will be
provided.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.GraphOfConvexSets.ClearAllPhiConstraints">
<code class="descname">ClearAllPhiConstraints</code><span class="sig-paren">(</span><em>self: pydrake.geometry.optimization.GraphOfConvexSets</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.ClearAllPhiConstraints" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes all constraints added to any edge with AddPhiConstraint.</p>
</dd></dl>

<dl class="class">
<dt id="pydrake.geometry.optimization.GraphOfConvexSets.Edge">
<em class="property">class </em><code class="descname">Edge</code><a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.Edge" title="Permalink to this definition">¶</a></dt>
<dd><p>An edge in the graph connects between vertex <code class="docutils literal notranslate"><span class="pre">u</span></code> and vertex <code class="docutils literal notranslate"><span class="pre">v</span></code>.
The edge also holds a list of cost and constraints associated with the
continuous variables.</p>
<dl class="attribute">
<dt id="pydrake.geometry.optimization.GraphOfConvexSets.Edge.__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.Edge.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.GraphOfConvexSets.Edge.AddConstraint">
<code class="descname">AddConstraint</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.Edge.AddConstraint" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>AddConstraint(self: pydrake.geometry.optimization.GraphOfConvexSets.Edge, f: pydrake.symbolic.Formula) -&gt; pydrake.solvers.Binding[Constraint]</li>
</ol>
<p>Adds a constraint to this edge, described by a symbolic::Formula <code class="docutils literal notranslate"><span class="pre">f</span></code>
containing <em>only</em> elements of xu() and xv() as variables.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if f.GetFreeVariables() is not a subset of xu() ∪</li>
<li><code class="xref py py-exc docutils literal notranslate"><span class="pre">xv().</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>AddConstraint(self: pydrake.geometry.optimization.GraphOfConvexSets.Edge, binding: pydrake.solvers.Binding[Constraint]) -&gt; pydrake.solvers.Binding[Constraint]</li>
</ol>
<p>Adds a cost to this edge. <code class="docutils literal notranslate"><span class="pre">binding</span></code> must contain <em>only</em> elements of
xu() and xv() as variables. For technical reasons relating to being
able to “turn-off” the cost on inactive edges, all costs are
eventually implemented with a slack variable and a constraint:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>min g(xu, xv) ⇒ min ℓ, s.t. ℓ ≥ g(xu,xv)
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Linear costs lead to negative costs if decision variables are not
properly constrained. Users may want to check that the solution
does not contain negative costs.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">the pair &lt;ℓ, g(xu, xv)&gt;.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if binding.variables() is not a subset of xu() ∪</li>
<li><code class="xref py py-exc docutils literal notranslate"><span class="pre">xv().</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.GraphOfConvexSets.Edge.AddCost">
<code class="descname">AddCost</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.Edge.AddCost" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>AddCost(self: pydrake.geometry.optimization.GraphOfConvexSets.Edge, e: pydrake.symbolic.Expression) -&gt; Tuple[pydrake.symbolic.Variable, pydrake.solvers.Binding[Cost]]</li>
</ol>
<p>Adds a cost to this edge, described by a symbolic::Expression <code class="docutils literal notranslate"><span class="pre">e</span></code>
containing <em>only</em> elements of xu() and xv() as variables. For
technical reasons relating to being able to “turn-off” the cost on
inactive edges, all costs are eventually implemented with a slack
variable and a constraint:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>min g(xu, xv) ⇒ min ℓ, s.t. ℓ ≥ g(xu,xv)
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Linear costs lead to negative costs if decision variables are not
properly constrained. Users may want to check that the solution
does not contain negative costs.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">the pair &lt;ℓ, g(xu, xv)&gt;.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if e.GetVariables() is not a subset of xu() ∪ xv().</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>AddCost(self: pydrake.geometry.optimization.GraphOfConvexSets.Edge, binding: pydrake.solvers.Binding[Cost]) -&gt; Tuple[pydrake.symbolic.Variable, pydrake.solvers.Binding[Cost]]</li>
</ol>
<p>Adds a cost to this edge. <code class="docutils literal notranslate"><span class="pre">binding</span></code> must contain <em>only</em> elements of
xu() and xv() as variables. For technical reasons relating to being
able to “turn-off” the cost on inactive edges, all costs are
eventually implemented with a slack variable and a constraint:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>min g(xu, xv) ⇒ min ℓ, s.t. ℓ ≥ g(xu,xv)
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Linear costs lead to negative costs if decision variables are not
properly constrained. Users may want to check that the solution
does not contain negative costs.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">the pair &lt;ℓ, g(xu, xv)&gt;.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if binding.variables() is not a subset of xu() ∪</li>
<li><code class="xref py py-exc docutils literal notranslate"><span class="pre">xv().</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.GraphOfConvexSets.Edge.AddPhiConstraint">
<code class="descname">AddPhiConstraint</code><span class="sig-paren">(</span><em>self: pydrake.geometry.optimization.GraphOfConvexSets.Edge</em>, <em>phi_value: bool</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.Edge.AddPhiConstraint" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a constraint on the binary variable associated with this edge.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">We intentionally do not return a binding to the constraint created
by this call, as that would allow the caller to make nonsensical
modifications to its bounds (i.e. requiring phi == 0.5).</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.GraphOfConvexSets.Edge.ClearPhiConstraints">
<code class="descname">ClearPhiConstraints</code><span class="sig-paren">(</span><em>self: pydrake.geometry.optimization.GraphOfConvexSets.Edge</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.Edge.ClearPhiConstraints" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes any constraints added with AddPhiConstraint.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.GraphOfConvexSets.Edge.GetConstraints">
<code class="descname">GetConstraints</code><span class="sig-paren">(</span><em>self: pydrake.geometry.optimization.GraphOfConvexSets.Edge</em><span class="sig-paren">)</span> &#x2192; List[pydrake.solvers.Binding[Constraint]]<a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.Edge.GetConstraints" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns all constraints on this edge.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.GraphOfConvexSets.Edge.GetCosts">
<code class="descname">GetCosts</code><span class="sig-paren">(</span><em>self: pydrake.geometry.optimization.GraphOfConvexSets.Edge</em><span class="sig-paren">)</span> &#x2192; List[pydrake.solvers.Binding[Cost]]<a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.Edge.GetCosts" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns all costs on this edge.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.GraphOfConvexSets.Edge.GetSolutionCost">
<code class="descname">GetSolutionCost</code><span class="sig-paren">(</span><em>self: pydrake.geometry.optimization.GraphOfConvexSets.Edge</em>, <em>result: pydrake.solvers.MathematicalProgramResult</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.Edge.GetSolutionCost" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the sum of the costs associated with this edge in a
solvers::MathematicalProgramResult.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.GraphOfConvexSets.Edge.GetSolutionPhiXu">
<code class="descname">GetSolutionPhiXu</code><span class="sig-paren">(</span><em>self: pydrake.geometry.optimization.GraphOfConvexSets.Edge</em>, <em>result: pydrake.solvers.MathematicalProgramResult</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.Edge.GetSolutionPhiXu" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the vector value of the slack variables associated with ϕxᵤ in
a solvers::MathematicalProgramResult.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.GraphOfConvexSets.Edge.GetSolutionPhiXv">
<code class="descname">GetSolutionPhiXv</code><span class="sig-paren">(</span><em>self: pydrake.geometry.optimization.GraphOfConvexSets.Edge</em>, <em>result: pydrake.solvers.MathematicalProgramResult</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.Edge.GetSolutionPhiXv" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the vector value of the slack variables associated with ϕxᵥ in
a solvers::MathematicalProgramResult.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.GraphOfConvexSets.Edge.id">
<code class="descname">id</code><span class="sig-paren">(</span><em>self: pydrake.geometry.optimization.GraphOfConvexSets.Edge</em><span class="sig-paren">)</span> &#x2192; pydrake.geometry.optimization.GraphOfConvexSets.EdgeId<a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.Edge.id" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the unique identifier associated with this Edge.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.GraphOfConvexSets.Edge.name">
<code class="descname">name</code><span class="sig-paren">(</span><em>self: pydrake.geometry.optimization.GraphOfConvexSets.Edge</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.Edge.name" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the string name associated with this edge.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.GraphOfConvexSets.Edge.phi">
<code class="descname">phi</code><span class="sig-paren">(</span><em>self: pydrake.geometry.optimization.GraphOfConvexSets.Edge</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Variable<a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.Edge.phi" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the binary variable associated with this edge. It can be used
to determine whether this edge was active in the solution to an
optimization problem, by calling GetSolution(phi()) on a returned
MathematicalProgramResult.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.GraphOfConvexSets.Edge.u">
<code class="descname">u</code><span class="sig-paren">(</span><em>self: pydrake.geometry.optimization.GraphOfConvexSets.Edge</em><span class="sig-paren">)</span> &#x2192; pydrake.geometry.optimization.GraphOfConvexSets.Vertex<a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.Edge.u" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a const reference to the “left” Vertex that this edge connects
to.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.GraphOfConvexSets.Edge.v">
<code class="descname">v</code><span class="sig-paren">(</span><em>self: pydrake.geometry.optimization.GraphOfConvexSets.Edge</em><span class="sig-paren">)</span> &#x2192; pydrake.geometry.optimization.GraphOfConvexSets.Vertex<a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.Edge.v" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a const reference to the “right” Vertex that this edge
connects to.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.GraphOfConvexSets.Edge.xu">
<code class="descname">xu</code><span class="sig-paren">(</span><em>self: pydrake.geometry.optimization.GraphOfConvexSets.Edge</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, 1]]<a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.Edge.xu" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the continuous decision variables associated with vertex
<code class="docutils literal notranslate"><span class="pre">u</span></code>. This can be used for constructing symbolic::Expression costs
and constraints.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.GraphOfConvexSets.Edge.xv">
<code class="descname">xv</code><span class="sig-paren">(</span><em>self: pydrake.geometry.optimization.GraphOfConvexSets.Edge</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, 1]]<a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.Edge.xv" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the continuous decision variables associated with vertex
<code class="docutils literal notranslate"><span class="pre">v</span></code>. This can be used for constructing symbolic::Expression costs
and constraints.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.geometry.optimization.GraphOfConvexSets.EdgeId">
<em class="property">class </em><code class="descname">EdgeId</code><a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.EdgeId" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="pydrake.geometry.optimization.GraphOfConvexSets.EdgeId.__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.EdgeId.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.geometry.optimization.GraphOfConvexSets.EdgeId.get_new_id">
<em class="property">static </em><code class="descname">get_new_id</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pydrake.geometry.optimization.GraphOfConvexSets.EdgeId<a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.EdgeId.get_new_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a new identifier for this id type. This new identifier will
be different from all previous identifiers created. This method does
<em>not</em> make any guarantees about the values of ids from successive
invocations. This method is guaranteed to be thread safe.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.GraphOfConvexSets.EdgeId.get_value">
<code class="descname">get_value</code><span class="sig-paren">(</span><em>self: pydrake.geometry.optimization.GraphOfConvexSets.EdgeId</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.EdgeId.get_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Extracts the underlying representation from the identifier. This is
considered invalid for invalid ids and is strictly enforced in Debug
builds.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.GraphOfConvexSets.EdgeId.is_valid">
<code class="descname">is_valid</code><span class="sig-paren">(</span><em>self: pydrake.geometry.optimization.GraphOfConvexSets.EdgeId</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.EdgeId.is_valid" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports if the id is valid.</p>
</dd></dl>

</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.GraphOfConvexSets.Edges">
<code class="descname">Edges</code><span class="sig-paren">(</span><em>self: pydrake.geometry.optimization.GraphOfConvexSets</em><span class="sig-paren">)</span> &#x2192; list<a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.Edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns mutable pointers to the edges stored in the graph.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.GraphOfConvexSets.GetGraphvizString">
<code class="descname">GetGraphvizString</code><span class="sig-paren">(</span><em>self: pydrake.geometry.optimization.GraphOfConvexSets</em>, <em>result: Optional[pydrake.solvers.MathematicalProgramResult] = None</em>, <em>show_slacks: bool = True</em>, <em>precision: int = 3</em>, <em>scientific: bool = False</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.GetGraphvizString" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a Graphviz string describing the graph vertices and edges. If
<code class="docutils literal notranslate"><span class="pre">results</span></code> is supplied, then the graph will be annotated with the
solution values.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">show_slacks</span></code>:</dt>
<dd>determines whether the values of the intermediate (slack)
variables are also displayed in the graph.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">precision</span></code>:</dt>
<dd>sets the floating point precision (how many digits are generated)
of the annotations.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">scientific</span></code>:</dt>
<dd>sets the floating point formatting to scientific (if true) or
fixed (if false).</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.GraphOfConvexSets.RemoveEdge">
<code class="descname">RemoveEdge</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.RemoveEdge" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>RemoveEdge(self: pydrake.geometry.optimization.GraphOfConvexSets, edge_id: drake::Identifier&lt;drake::geometry::optimization::EdgeTag&gt;) -&gt; None</li>
</ol>
<p>Removes edge <code class="docutils literal notranslate"><span class="pre">edge_id</span></code> from the graph.</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd>The edge must be part of the graph.</dd>
</dl>
<ol class="arabic simple" start="2">
<li>RemoveEdge(self: pydrake.geometry.optimization.GraphOfConvexSets, edge: drake::geometry::optimization::GraphOfConvexSets::Edge) -&gt; None</li>
</ol>
<p>Removes edge <code class="docutils literal notranslate"><span class="pre">edge</span></code> from the graph.</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd>The edge must be part of the graph.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.GraphOfConvexSets.RemoveVertex">
<code class="descname">RemoveVertex</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.RemoveVertex" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>RemoveVertex(self: pydrake.geometry.optimization.GraphOfConvexSets, vertex_id: drake::Identifier&lt;drake::geometry::optimization::VertexTag&gt;) -&gt; None</li>
</ol>
<p>Removes vertex <code class="docutils literal notranslate"><span class="pre">vertex_id</span></code> from the graph as well as any edges from
or to the vertex. Runtime is O(nₑ) where nₑ is the number of edges in
the graph.</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd>The vertex must be part of the graph.</dd>
</dl>
<ol class="arabic simple" start="2">
<li>RemoveVertex(self: pydrake.geometry.optimization.GraphOfConvexSets, vertex: drake::geometry::optimization::GraphOfConvexSets::Vertex) -&gt; None</li>
</ol>
<p>Removes vertex <code class="docutils literal notranslate"><span class="pre">vertex</span></code> from the graph as well as any edges from or
to the vertex. Runtime is O(nₑ) where nₑ is the number of edges in the
graph.</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd>The vertex must be part of the graph.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.GraphOfConvexSets.SolveShortestPath">
<code class="descname">SolveShortestPath</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.SolveShortestPath" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>SolveShortestPath(self: pydrake.geometry.optimization.GraphOfConvexSets, source_id: drake::Identifier&lt;drake::geometry::optimization::VertexTag&gt;, target_id: drake::Identifier&lt;drake::geometry::optimization::VertexTag&gt;, options: pydrake.geometry.optimization.GraphOfConvexSetsOptions = GraphOfConvexSetsOptions(convex_relaxation=True, preprocessing=False, max_rounded_paths=0, max_rounding_trials=100, flow_tolerance=1e-05, rounding_seed=0, solver=None, solver_options=&lt;pydrake.solvers.SolverOptions object at 0x7f8e68c283f0&gt;, )) -&gt; pydrake.solvers.MathematicalProgramResult</li>
</ol>
<p>Formulates and solves the mixed-integer convex formulation of the
shortest path problem on the graph, as discussed in detail in</p>
<p>“Shortest Paths in Graphs of Convex Sets” by Tobia Marcucci, Jack
Umenberger, Pablo A. Parrilo, Russ Tedrake.
<a class="reference external" href="https://arxiv.org/abs/2101.11565">https://arxiv.org/abs/2101.11565</a></p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">source</span></code>:</dt>
<dd>specifies the source set. The solver will choose any point in that
set; to start at a particular continuous state consider adding a
Point set to the graph and using that as the source.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">target</span></code>:</dt>
<dd>specifies the target set. The solver will choose any point in that
set.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">options</span></code>:</dt>
<dd>include all settings for solving the shortest path problem. See
<code class="docutils literal notranslate"><span class="pre">GraphOfConvexSetsOptions</span></code> for further details.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if any of the costs or constraints in the graph are</li>
<li>incompatible with the shortest path formulation or otherwise</li>
<li>unsupported. All costs must be non-negative for all values of the</li>
<li>continuous variables.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>SolveShortestPath(self: pydrake.geometry.optimization.GraphOfConvexSets, source: drake::geometry::optimization::GraphOfConvexSets::Vertex, target: drake::geometry::optimization::GraphOfConvexSets::Vertex, options: pydrake.geometry.optimization.GraphOfConvexSetsOptions = GraphOfConvexSetsOptions(convex_relaxation=True, preprocessing=False, max_rounded_paths=0, max_rounding_trials=100, flow_tolerance=1e-05, rounding_seed=0, solver=None, solver_options=&lt;pydrake.solvers.SolverOptions object at 0x7f8e68f12f70&gt;, )) -&gt; pydrake.solvers.MathematicalProgramResult</li>
</ol>
<p>Convenience overload that takes const reference arguments for source
and target.</p>
<ol class="arabic simple" start="3">
<li>SolveShortestPath(self: pydrake.geometry.optimization.GraphOfConvexSets, source_id: drake::Identifier&lt;drake::geometry::optimization::VertexTag&gt;, target_id: drake::Identifier&lt;drake::geometry::optimization::VertexTag&gt;, convex_relaxation: bool, solver: pydrake.solvers.SolverInterface = None, solver_options: Optional[pydrake.solvers.SolverOptions] = None) -&gt; pydrake.solvers.MathematicalProgramResult</li>
</ol>
<p>Formulates and solves the mixed-integer convex formulation of the
shortest path problem on the graph, as discussed in detail in</p>
<p>“Shortest Paths in Graphs of Convex Sets” by Tobia Marcucci, Jack
Umenberger, Pablo A. Parrilo, Russ Tedrake.
<a class="reference external" href="https://arxiv.org/abs/2101.11565">https://arxiv.org/abs/2101.11565</a></p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">source</span></code>:</dt>
<dd>specifies the source set. The solver will choose any point in that
set; to start at a particular continuous state consider adding a
Point set to the graph and using that as the source.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">target</span></code>:</dt>
<dd>specifies the target set. The solver will choose any point in that
set.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">convex_relaxation</span></code>:</dt>
<dd>will solve the relaxed version of the problem. As discussed in the
paper, we know that this relaxation cannot solve the original
NP-hard problem for all instances, but there are also many
instances for which the convex relaxation is tight.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">solver</span></code>:</dt>
<dd>provides the optimizer to be used to solve the shortest path
optimization problem. If not set, the best solver for the given
problem is selected. Note that if the solver cannot handle the
type of optimization problem generated, it will throw.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">solver_options</span></code>:</dt>
<dd>are passed to the solver once the problem is generated to set the
solver settings.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first simple">
<li><dl class="first docutils">
<dt>RuntimeError if any of the costs or constraints in the graph are</dt>
<dd><ul class="first last">
<li>incompatible with the shortest path formulation or otherwise</li>
<li>unsupported. All costs must be non-negative for all values of the</li>
<li>continuous variables.</li>
</ul>
</dd>
</dl>
</li>
</ul>
<p class="last">/ (Deprecated.)</p>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Deprecated:</dt>
<dd>Use version with GraphOfConvexSetsOptions This will be removed
from Drake on or after 2022-12-01.</dd>
</dl>
<ol class="arabic simple" start="4">
<li>SolveShortestPath(self: pydrake.geometry.optimization.GraphOfConvexSets, source: drake::geometry::optimization::GraphOfConvexSets::Vertex, target: drake::geometry::optimization::GraphOfConvexSets::Vertex, convex_relaxation: bool, solver: pydrake.solvers.SolverInterface = None, solver_options: Optional[pydrake.solvers.SolverOptions] = None) -&gt; pydrake.solvers.MathematicalProgramResult</li>
</ol>
<p>Convenience overload that takes const reference arguments for source
and target.  /
(Deprecated.)</p>
<dl class="docutils">
<dt>Deprecated:</dt>
<dd>Use version with GraphOfConvexSetsOptions This will be removed
from Drake on or after 2022-12-01.</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="pydrake.geometry.optimization.GraphOfConvexSets.Vertex">
<em class="property">class </em><code class="descname">Vertex</code><a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.Vertex" title="Permalink to this definition">¶</a></dt>
<dd><p>Each vertex in the graph has a corresponding ConvexSet, and a
std::string name.</p>
<dl class="attribute">
<dt id="pydrake.geometry.optimization.GraphOfConvexSets.Vertex.__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.Vertex.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.GraphOfConvexSets.Vertex.AddConstraint">
<code class="descname">AddConstraint</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.Vertex.AddConstraint" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>AddConstraint(self: pydrake.geometry.optimization.GraphOfConvexSets.Vertex, f: pydrake.symbolic.Formula) -&gt; pydrake.solvers.Binding[Constraint]</li>
</ol>
<p>Adds a constraint to this vertex, described by a symbolic::Formula
<code class="docutils literal notranslate"><span class="pre">f</span></code> containing <em>only</em> elements of x() as variables.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if f.GetFreeVariables() is not a subset of x().</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>AddConstraint(self: pydrake.geometry.optimization.GraphOfConvexSets.Vertex, binding: pydrake.solvers.Binding[Constraint]) -&gt; pydrake.solvers.Binding[Constraint]</li>
</ol>
<p>Adds a cost to this vertex. <code class="docutils literal notranslate"><span class="pre">binding</span></code> must contain <em>only</em> elements
of x() as variables. For technical reasons relating to being able to
“turn-off” the cost on inactive vertices, all costs are eventually
implemented with a slack variable and a constraint:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>min g(x) ⇒ min ℓ, s.t. ℓ ≥ g(x)
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Linear costs lead to negative costs if decision variables are not
properly constrained. Users may want to check that the solution
does not contain negative costs.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">the pair &lt;ℓ, g(x)&gt;.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if binding.variables() is not a subset of x().</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.GraphOfConvexSets.Vertex.AddCost">
<code class="descname">AddCost</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.Vertex.AddCost" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>AddCost(self: pydrake.geometry.optimization.GraphOfConvexSets.Vertex, e: pydrake.symbolic.Expression) -&gt; Tuple[pydrake.symbolic.Variable, pydrake.solvers.Binding[Cost]]</li>
</ol>
<p>Adds a cost to this vertex, described by a symbolic::Expression <code class="docutils literal notranslate"><span class="pre">e</span></code>
containing <em>only</em> elements of x() as variables. For technical reasons
relating to being able to “turn-off” the cost on inactive vertices,
all costs are eventually implemented with a slack variable and a
constraint:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>min g(x) ⇒ min ℓ, s.t. ℓ ≥ g(x)
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Linear costs lead to negative costs if decision variables are not
properly constrained. Users may want to check that the solution
does not contain negative costs.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">the pair &lt;ℓ, g(x)&gt;.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if e.GetVariables() is not a subset of x().</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>AddCost(self: pydrake.geometry.optimization.GraphOfConvexSets.Vertex, binding: pydrake.solvers.Binding[Cost]) -&gt; Tuple[pydrake.symbolic.Variable, pydrake.solvers.Binding[Cost]]</li>
</ol>
<p>Adds a cost to this vertex. <code class="docutils literal notranslate"><span class="pre">binding</span></code> must contain <em>only</em> elements
of x() as variables. For technical reasons relating to being able to
“turn-off” the cost on inactive vertices, all costs are eventually
implemented with a slack variable and a constraint:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>min g(x) ⇒ min ℓ, s.t. ℓ ≥ g(x)
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Linear costs lead to negative costs if decision variables are not
properly constrained. Users may want to check that the solution
does not contain negative costs.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">the pair &lt;ℓ, g(x)&gt;.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if binding.variables() is not a subset of x().</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.GraphOfConvexSets.Vertex.ambient_dimension">
<code class="descname">ambient_dimension</code><span class="sig-paren">(</span><em>self: pydrake.geometry.optimization.GraphOfConvexSets.Vertex</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.Vertex.ambient_dimension" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the ambient dimension of the ConvexSet.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.GraphOfConvexSets.Vertex.GetConstraints">
<code class="descname">GetConstraints</code><span class="sig-paren">(</span><em>self: pydrake.geometry.optimization.GraphOfConvexSets.Vertex</em><span class="sig-paren">)</span> &#x2192; List[pydrake.solvers.Binding[Constraint]]<a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.Vertex.GetConstraints" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns all constraints on this vertex.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.GraphOfConvexSets.Vertex.GetCosts">
<code class="descname">GetCosts</code><span class="sig-paren">(</span><em>self: pydrake.geometry.optimization.GraphOfConvexSets.Vertex</em><span class="sig-paren">)</span> &#x2192; List[pydrake.solvers.Binding[Cost]]<a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.Vertex.GetCosts" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns all costs on this vertex.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.GraphOfConvexSets.Vertex.GetSolution">
<code class="descname">GetSolution</code><span class="sig-paren">(</span><em>self: pydrake.geometry.optimization.GraphOfConvexSets.Vertex</em>, <em>result: pydrake.solvers.MathematicalProgramResult</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.Vertex.GetSolution" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the solution of x() in a MathematicalProgramResult. This
solution is NaN if the vertex is not in the shortest path (or if we
are solving the the convex relaxation and the total flow through this
vertex at the solution is numerically close to zero). We prefer to
return NaN than a value not contained in set().</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.GraphOfConvexSets.Vertex.GetSolutionCost">
<code class="descname">GetSolutionCost</code><span class="sig-paren">(</span><em>self: pydrake.geometry.optimization.GraphOfConvexSets.Vertex</em>, <em>result: pydrake.solvers.MathematicalProgramResult</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.Vertex.GetSolutionCost" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the sum of the costs associated with this vertex in a
solvers::MathematicalProgramResult.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.GraphOfConvexSets.Vertex.id">
<code class="descname">id</code><span class="sig-paren">(</span><em>self: pydrake.geometry.optimization.GraphOfConvexSets.Vertex</em><span class="sig-paren">)</span> &#x2192; pydrake.geometry.optimization.GraphOfConvexSets.VertexId<a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.Vertex.id" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the unique identifier associated with this Vertex.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.GraphOfConvexSets.Vertex.name">
<code class="descname">name</code><span class="sig-paren">(</span><em>self: pydrake.geometry.optimization.GraphOfConvexSets.Vertex</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.Vertex.name" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the name of the vertex.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.GraphOfConvexSets.Vertex.set">
<code class="descname">set</code><span class="sig-paren">(</span><em>self: pydrake.geometry.optimization.GraphOfConvexSets.Vertex</em><span class="sig-paren">)</span> &#x2192; pydrake.geometry.optimization.ConvexSet<a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.Vertex.set" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a const reference to the underlying ConvexSet.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.GraphOfConvexSets.Vertex.x">
<code class="descname">x</code><span class="sig-paren">(</span><em>self: pydrake.geometry.optimization.GraphOfConvexSets.Vertex</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, 1]]<a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.Vertex.x" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a decision variable corresponding to an element of the
ConvexSet, which can be used for constructing symbolic::Expression
costs and constraints.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.geometry.optimization.GraphOfConvexSets.VertexId">
<em class="property">class </em><code class="descname">VertexId</code><a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.VertexId" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="pydrake.geometry.optimization.GraphOfConvexSets.VertexId.__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.VertexId.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.geometry.optimization.GraphOfConvexSets.VertexId.get_new_id">
<em class="property">static </em><code class="descname">get_new_id</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pydrake.geometry.optimization.GraphOfConvexSets.VertexId<a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.VertexId.get_new_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a new identifier for this id type. This new identifier will
be different from all previous identifiers created. This method does
<em>not</em> make any guarantees about the values of ids from successive
invocations. This method is guaranteed to be thread safe.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.GraphOfConvexSets.VertexId.get_value">
<code class="descname">get_value</code><span class="sig-paren">(</span><em>self: pydrake.geometry.optimization.GraphOfConvexSets.VertexId</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.VertexId.get_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Extracts the underlying representation from the identifier. This is
considered invalid for invalid ids and is strictly enforced in Debug
builds.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.GraphOfConvexSets.VertexId.is_valid">
<code class="descname">is_valid</code><span class="sig-paren">(</span><em>self: pydrake.geometry.optimization.GraphOfConvexSets.VertexId</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.VertexId.is_valid" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports if the id is valid.</p>
</dd></dl>

</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.GraphOfConvexSets.Vertices">
<code class="descname">Vertices</code><span class="sig-paren">(</span><em>self: pydrake.geometry.optimization.GraphOfConvexSets</em><span class="sig-paren">)</span> &#x2192; list<a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSets.Vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns mutable pointers to the vertices stored in the graph.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.geometry.optimization.GraphOfConvexSetsOptions">
<em class="property">class </em><code class="descclassname">pydrake.geometry.optimization.</code><code class="descname">GraphOfConvexSetsOptions</code><a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSetsOptions" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="pydrake.geometry.optimization.GraphOfConvexSetsOptions.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.geometry.optimization.GraphOfConvexSetsOptions</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSetsOptions.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.geometry.optimization.GraphOfConvexSetsOptions.convex_relaxation">
<code class="descname">convex_relaxation</code><a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSetsOptions.convex_relaxation" title="Permalink to this definition">¶</a></dt>
<dd><p>Flag to solve the relaxed version of the problem. As discussed in the
paper, we know that this relaxation cannot solve the original NP-hard
problem for all instances, but there are also many instances for which
the convex relaxation is tight.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.geometry.optimization.GraphOfConvexSetsOptions.flow_tolerance">
<code class="descname">flow_tolerance</code><a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSetsOptions.flow_tolerance" title="Permalink to this definition">¶</a></dt>
<dd><p>Tolerance for ignoring flow along a given edge during random rounding.
If convex_relaxation is false or max_rounded_paths is less than or
equal to zero, this option is ignored.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.geometry.optimization.GraphOfConvexSetsOptions.max_rounded_paths">
<code class="descname">max_rounded_paths</code><a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSetsOptions.max_rounded_paths" title="Permalink to this definition">¶</a></dt>
<dd><p>Maximum number of distinct paths to compare during random rounding;
only the lowest cost path is returned. If convex_relaxation is false
or this is less than or equal to zero, rounding is not performed.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.geometry.optimization.GraphOfConvexSetsOptions.max_rounding_trials">
<code class="descname">max_rounding_trials</code><a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSetsOptions.max_rounding_trials" title="Permalink to this definition">¶</a></dt>
<dd><p>Maximum number of trials to find a novel path during random rounding.
If convex_relaxation is false or max_rounded_paths is less than or
equal to zero, this option is ignored.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.geometry.optimization.GraphOfConvexSetsOptions.preprocessing">
<code class="descname">preprocessing</code><a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSetsOptions.preprocessing" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs a preprocessing step to remove edges that cannot lie on the
path from source to target. In most cases, preprocessing causes a net
reduction in computation by reducing the size of the optimization
solved. Note that this preprocessing is not exact. There may be edges
that cannot lie on the path from source to target that this does not
detect.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.geometry.optimization.GraphOfConvexSetsOptions.rounding_seed">
<code class="descname">rounding_seed</code><a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSetsOptions.rounding_seed" title="Permalink to this definition">¶</a></dt>
<dd><p>Random seed to use for random rounding. If convex_relaxation is false
or max_rounded_paths is less than or equal to zero, this option is
ignored.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.geometry.optimization.GraphOfConvexSetsOptions.solver">
<code class="descname">solver</code><a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSetsOptions.solver" title="Permalink to this definition">¶</a></dt>
<dd><p>Optimizer to be used to solve the shortest path optimization problem.
If not set, the best solver for the given problem is selected. Note
that if the solver cannot handle the type of optimization problem
generated, the calling solve method will throw.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.geometry.optimization.GraphOfConvexSetsOptions.solver_options">
<code class="descname">solver_options</code><a class="headerlink" href="#pydrake.geometry.optimization.GraphOfConvexSetsOptions.solver_options" title="Permalink to this definition">¶</a></dt>
<dd><p>Options passed to the solver when solving the generated problem.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.geometry.optimization.HPolyhedron">
<em class="property">class </em><code class="descclassname">pydrake.geometry.optimization.</code><code class="descname">HPolyhedron</code><a class="headerlink" href="#pydrake.geometry.optimization.HPolyhedron" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.geometry.optimization.ConvexSet" title="pydrake.geometry.optimization.ConvexSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.geometry.optimization.ConvexSet</span></code></a></p>
<p>Implements a polyhedral convex set using the half-space
representation: <code class="docutils literal notranslate"><span class="pre">{x|</span> <span class="pre">A</span> <span class="pre">x</span> <span class="pre">≤</span> <span class="pre">b}</span></code>. Note: This set may be unbounded.</p>
<dl class="method">
<dt id="pydrake.geometry.optimization.HPolyhedron.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.geometry.optimization.HPolyhedron.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.geometry.optimization.HPolyhedron, A: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], b: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</li>
</ol>
<p>Constructs the polyhedron.</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd>A.rows() == b.size().</dd>
</dl>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.geometry.optimization.HPolyhedron, query_object: pydrake.geometry.QueryObject_[float], geometry_id: pydrake.geometry.GeometryId, reference_frame: Optional[pydrake.geometry.FrameId] = None) -&gt; None</li>
</ol>
<p>Constructs a new HPolyhedron from a SceneGraph geometry and pose in
the <code class="docutils literal notranslate"><span class="pre">reference_frame</span></code> frame, obtained via the QueryObject. If
<code class="docutils literal notranslate"><span class="pre">reference_frame</span></code> frame is std::nullopt, then it will be expressed
in the world frame.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError the geometry is not a convex polytope.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.HPolyhedron.A">
<code class="descname">A</code><span class="sig-paren">(</span><em>self: pydrake.geometry.optimization.HPolyhedron</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, n]]<a class="headerlink" href="#pydrake.geometry.optimization.HPolyhedron.A" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the half-space representation matrix A.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.HPolyhedron.b">
<code class="descname">b</code><span class="sig-paren">(</span><em>self: pydrake.geometry.optimization.HPolyhedron</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.geometry.optimization.HPolyhedron.b" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the half-space representation vector b.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.HPolyhedron.CartesianPower">
<code class="descname">CartesianPower</code><span class="sig-paren">(</span><em>self: pydrake.geometry.optimization.HPolyhedron</em>, <em>n: int</em><span class="sig-paren">)</span> &#x2192; pydrake.geometry.optimization.HPolyhedron<a class="headerlink" href="#pydrake.geometry.optimization.HPolyhedron.CartesianPower" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the <code class="docutils literal notranslate"><span class="pre">n</span></code>-ary Cartesian power of <code class="docutils literal notranslate"><span class="pre">this</span></code>. The n-ary Cartesian
power of a set H is the set H ⨉ H ⨉ … ⨉ H, where H is repeated n
times.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.HPolyhedron.CartesianProduct">
<code class="descname">CartesianProduct</code><span class="sig-paren">(</span><em>self: pydrake.geometry.optimization.HPolyhedron</em>, <em>other: pydrake.geometry.optimization.HPolyhedron</em><span class="sig-paren">)</span> &#x2192; pydrake.geometry.optimization.HPolyhedron<a class="headerlink" href="#pydrake.geometry.optimization.HPolyhedron.CartesianProduct" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the Cartesian product of <code class="docutils literal notranslate"><span class="pre">this</span></code> and <code class="docutils literal notranslate"><span class="pre">other</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.HPolyhedron.ChebyshevCenter">
<code class="descname">ChebyshevCenter</code><span class="sig-paren">(</span><em>self: pydrake.geometry.optimization.HPolyhedron</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.geometry.optimization.HPolyhedron.ChebyshevCenter" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves a linear program to compute the center of the largest inscribed
ball in the polyhedron. This is often the recommended way to find some
interior point of the set, for example, as a step towards computing
the convex hull or a vertex-representation of the set.</p>
<p>Note that the Chebyshev center is not necessarily unique, and may not
conform to the point that one might consider the “visual center” of
the set. For example, for a long thin rectangle, any point in the
center line segment illustrated below would be a valid center point.
The solver may return any point on that line segment.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>┌──────────────────────────────────┐
│                                  │
│   ────────────────────────────   │
│                                  │
└──────────────────────────────────┘
</pre></div>
</div>
<p>To find the visual center, consider using the more expensive
MaximumVolumeInscribedEllipsoid() method, and then taking the center
of the returned Hyperellipsoid.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the solver fails to solve the problem.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.HPolyhedron.ContainedIn">
<code class="descname">ContainedIn</code><span class="sig-paren">(</span><em>self: pydrake.geometry.optimization.HPolyhedron</em>, <em>other: pydrake.geometry.optimization.HPolyhedron</em>, <em>tol: float = 1e-09</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.geometry.optimization.HPolyhedron.ContainedIn" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true iff this HPolyhedron is entirely contained in the
HPolyhedron other. This is done by checking whether every inequality
in <code class="docutils literal notranslate"><span class="pre">other</span></code> is redundant when added to this.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">tol</span></code>:</dt>
<dd>We check if this polyhedron is contained in
other.A().row(i).dot(x) &lt;= other.b()(i) + tol. The larger tol
value is, the more relaxation we add to the containment. If tol is
negative, then we check if a shrinked <code class="docutils literal notranslate"><span class="pre">other</span></code> contains this
polyheron.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.HPolyhedron.Intersection">
<code class="descname">Intersection</code><span class="sig-paren">(</span><em>self: pydrake.geometry.optimization.HPolyhedron</em>, <em>other: pydrake.geometry.optimization.HPolyhedron</em>, <em>check_for_redundancy: bool = False</em>, <em>tol: float = 1e-09</em><span class="sig-paren">)</span> &#x2192; pydrake.geometry.optimization.HPolyhedron<a class="headerlink" href="#pydrake.geometry.optimization.HPolyhedron.Intersection" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs the intersection of two HPolyhedron by adding the rows of
inequalities from <code class="docutils literal notranslate"><span class="pre">other</span></code>. If <code class="docutils literal notranslate"><span class="pre">check_for_redundancy</span></code> is true then
only adds the rows of <code class="docutils literal notranslate"><span class="pre">other</span></code> other.A().row(i).dot(x)&lt;=other.b()(i)
to this HPolyhedron if the inequality
other.A().row(i).dot(x)&lt;=other.b()(i)+tol is not implied by the
inequalities from this HPolyhedron. A positive tol means it is more
likely to deem a constraint being redundant and remove it. A negative
tol means it is less likely to remove a constraint.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.HPolyhedron.IsEmpty">
<code class="descname">IsEmpty</code><span class="sig-paren">(</span><em>self: pydrake.geometry.optimization.HPolyhedron</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.geometry.optimization.HPolyhedron.IsEmpty" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks if this HPolyhedron defines an empty set.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.geometry.optimization.HPolyhedron.MakeBox">
<em class="property">static </em><code class="descname">MakeBox</code><span class="sig-paren">(</span><em>lb: numpy.ndarray[numpy.float64[m, 1]], ub: numpy.ndarray[numpy.float64[m, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.geometry.optimization.HPolyhedron<a class="headerlink" href="#pydrake.geometry.optimization.HPolyhedron.MakeBox" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs a polyhedron as an axis-aligned box from the lower and
upper corners.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.geometry.optimization.HPolyhedron.MakeL1Ball">
<em class="property">static </em><code class="descname">MakeL1Ball</code><span class="sig-paren">(</span><em>dim: int</em><span class="sig-paren">)</span> &#x2192; pydrake.geometry.optimization.HPolyhedron<a class="headerlink" href="#pydrake.geometry.optimization.HPolyhedron.MakeL1Ball" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs the L1-norm unit ball in <code class="docutils literal notranslate"><span class="pre">dim</span></code> dimensions, {x | <a href="#id1"><span class="problematic" id="id2">|</span></a>x|₁ &lt;= 1
}. This set is also known as the cross-polytope and is described by
the 2ᵈⁱᵐ signed unit vectors.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.geometry.optimization.HPolyhedron.MakeUnitBox">
<em class="property">static </em><code class="descname">MakeUnitBox</code><span class="sig-paren">(</span><em>dim: int</em><span class="sig-paren">)</span> &#x2192; pydrake.geometry.optimization.HPolyhedron<a class="headerlink" href="#pydrake.geometry.optimization.HPolyhedron.MakeUnitBox" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs the L∞-norm unit box in <code class="docutils literal notranslate"><span class="pre">dim</span></code> dimensions, {x | <a href="#id3"><span class="problematic" id="id4">|</span></a>x|∞ &lt;= 1
}. This is an axis-aligned box, centered at the origin, with edge
length 2.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.HPolyhedron.MaximumVolumeInscribedEllipsoid">
<code class="descname">MaximumVolumeInscribedEllipsoid</code><span class="sig-paren">(</span><em>self: pydrake.geometry.optimization.HPolyhedron</em><span class="sig-paren">)</span> &#x2192; drake::geometry::optimization::Hyperellipsoid<a class="headerlink" href="#pydrake.geometry.optimization.HPolyhedron.MaximumVolumeInscribedEllipsoid" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves a semi-definite program to compute the inscribed ellipsoid.
From Section 8.4.2 in Boyd and Vandenberghe, 2004, we solve</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>max_{C,d} log det (C)
s.t. |aᵢC|₂ ≤ bᵢ - aᵢd, ∀i
C ≽ 0
</pre></div>
</div>
<p>where aᵢ and bᵢ denote the ith row. This defines the ellipsoid E = {
Cx + d | <a href="#id5"><span class="problematic" id="id6">|</span></a>x|₂ ≤ 1}.</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd>the HPolyhedron is bounded.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the solver fails to solve the problem.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.HPolyhedron.PontryaginDifference">
<code class="descname">PontryaginDifference</code><span class="sig-paren">(</span><em>self: pydrake.geometry.optimization.HPolyhedron</em>, <em>other: pydrake.geometry.optimization.HPolyhedron</em><span class="sig-paren">)</span> &#x2192; pydrake.geometry.optimization.HPolyhedron<a class="headerlink" href="#pydrake.geometry.optimization.HPolyhedron.PontryaginDifference" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the Pontryagin (Minkowski) Difference of <code class="docutils literal notranslate"><span class="pre">this</span></code> and
<code class="docutils literal notranslate"><span class="pre">other</span></code>. This is the set A ⊖ B = { a|a+ B ⊆ A }. The result is an
HPolyhedron with the same number of inequalities as A. Requires that
<code class="docutils literal notranslate"><span class="pre">this</span></code> and <code class="docutils literal notranslate"><span class="pre">other</span></code> both be bounded and have the same ambient
dimension. This method may throw a runtime error if <code class="docutils literal notranslate"><span class="pre">this</span></code> or
<code class="docutils literal notranslate"><span class="pre">other</span></code> are ill-conditioned.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.HPolyhedron.ReduceInequalities">
<code class="descname">ReduceInequalities</code><span class="sig-paren">(</span><em>self: pydrake.geometry.optimization.HPolyhedron</em>, <em>tol: float = 1e-09</em><span class="sig-paren">)</span> &#x2192; pydrake.geometry.optimization.HPolyhedron<a class="headerlink" href="#pydrake.geometry.optimization.HPolyhedron.ReduceInequalities" title="Permalink to this definition">¶</a></dt>
<dd><p>Reduces some (not necessarily all) redundant inequalities in the
HPolyhedron. This is not guaranteed to give the minimal representation
of the polyhedron but is a relatively fast way to reduce the number of
inequalities.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">tol</span></code>:</dt>
<dd>For a constraint c’x&lt;=d, if the halfspace c’x&lt;=d + tol contains
the hpolyhedron generated by the rest of the constraints, then we
remove this inequality. A positive tol means it is more likely to
remove a constraint, a negative tol means it is less likey to
remote a constraint.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.HPolyhedron.UniformSample">
<code class="descname">UniformSample</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.geometry.optimization.HPolyhedron.UniformSample" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>UniformSample(self: pydrake.geometry.optimization.HPolyhedron, generator: pydrake.common._module_py.RandomGenerator, previous_sample: numpy.ndarray[numpy.float64[m, 1]]) -&gt; numpy.ndarray[numpy.float64[m, 1]]</li>
</ol>
<p>Draw an (approximately) uniform sample from the set using the hit and
run Markov-chain Monte-Carlo strategy described at
<a class="reference external" href="https://mathoverflow.net/a/162327">https://mathoverflow.net/a/162327</a> and the cited paper.</p>
<p>To generate many samples, pass the output of one iteration in as the
<code class="docutils literal notranslate"><span class="pre">previous_sample</span></code> to the next; in this case the distribution of
samples will converge to the true uniform distribution in total
variation at a geometric rate. If <code class="docutils literal notranslate"><span class="pre">previous_sample</span></code> is not set, then
the ChebyshevCenter() will be used to seed the algorithm.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if previous_sample is not in the set.</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>UniformSample(self: pydrake.geometry.optimization.HPolyhedron, generator: pydrake.common._module_py.RandomGenerator) -&gt; numpy.ndarray[numpy.float64[m, 1]]</li>
</ol>
<p>Variant of UniformSample that uses the ChebyshevCenter() as the
previous_sample as a feasible point to start the Markov chain
sampling.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.geometry.optimization.Hyperellipsoid">
<em class="property">class </em><code class="descclassname">pydrake.geometry.optimization.</code><code class="descname">Hyperellipsoid</code><a class="headerlink" href="#pydrake.geometry.optimization.Hyperellipsoid" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.geometry.optimization.ConvexSet" title="pydrake.geometry.optimization.ConvexSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.geometry.optimization.ConvexSet</span></code></a></p>
<p>Implements an ellipsoidal convex set represented by the quadratic form
<code class="docutils literal notranslate"><span class="pre">{x</span> <span class="pre">|</span> <span class="pre">(x-center)ᵀAᵀA(x-center)</span> <span class="pre">≤</span> <span class="pre">1}</span></code>. Note that <code class="docutils literal notranslate"><span class="pre">A</span></code> need not be
square; we require only that the matrix AᵀA is positive semi-definite.</p>
<p>Compare this with an alternative (very useful) parameterization of the
ellipsoid: <code class="docutils literal notranslate"><span class="pre">{Bu</span> <span class="pre">+</span> <span class="pre">center</span> <span class="pre">|</span> <span class="pre">|u|₂</span> <span class="pre">≤</span> <span class="pre">1}</span></code>, which is an affine scaling of
the unit ball. This is related to the quadratic form by <code class="docutils literal notranslate"><span class="pre">B</span> <span class="pre">=</span> <span class="pre">A⁻¹</span></code>,
when <code class="docutils literal notranslate"><span class="pre">A</span></code> is invertible, but the quadratic form can also represent
unbounded sets.</p>
<p>Note: the name Hyperellipsoid was taken here to avoid conflicting with
geometry::Ellipsoid and to distinguish that this class supports N
dimensions.</p>
<dl class="method">
<dt id="pydrake.geometry.optimization.Hyperellipsoid.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.geometry.optimization.Hyperellipsoid.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.geometry.optimization.Hyperellipsoid, A: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], center: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</li>
</ol>
<p>Constructs the ellipsoid.</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd>A.cols() == center.size().</dd>
</dl>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.geometry.optimization.Hyperellipsoid, query_object: pydrake.geometry.QueryObject_[float], geometry_id: pydrake.geometry.GeometryId, reference_frame: Optional[pydrake.geometry.FrameId] = None) -&gt; None</li>
</ol>
<p>Constructs a Hyperellipsoid from a SceneGraph geometry and pose in the
<code class="docutils literal notranslate"><span class="pre">reference_frame</span></code> frame, obtained via the QueryObject. If
<code class="docutils literal notranslate"><span class="pre">reference_frame</span></code> frame is std::nullopt, then it will be expressed
in the world frame.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if geometry_id does not represent a shape that can be</li>
<li>described as an Hyperellipsoid.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.Hyperellipsoid.A">
<code class="descname">A</code><span class="sig-paren">(</span><em>self: pydrake.geometry.optimization.Hyperellipsoid</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, n]]<a class="headerlink" href="#pydrake.geometry.optimization.Hyperellipsoid.A" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the quadratic form matrix A.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.Hyperellipsoid.center">
<code class="descname">center</code><span class="sig-paren">(</span><em>self: pydrake.geometry.optimization.Hyperellipsoid</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.geometry.optimization.Hyperellipsoid.center" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the center of the ellipsoid.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.geometry.optimization.Hyperellipsoid.MakeAxisAligned">
<em class="property">static </em><code class="descname">MakeAxisAligned</code><span class="sig-paren">(</span><em>radius: numpy.ndarray[numpy.float64[m, 1]], center: numpy.ndarray[numpy.float64[m, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.geometry.optimization.Hyperellipsoid<a class="headerlink" href="#pydrake.geometry.optimization.Hyperellipsoid.MakeAxisAligned" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs the an axis-aligned Hyperellipsoid with the implicit form
(x₀-c₀)²/r₀² + (x₁-c₁)²/r₁² + … + (x_N - c_N)²/r_N² ≤ 1, where c is
shorthand for <code class="docutils literal notranslate"><span class="pre">center</span></code> and r is shorthand for <code class="docutils literal notranslate"><span class="pre">radius</span></code>.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.geometry.optimization.Hyperellipsoid.MakeHypersphere">
<em class="property">static </em><code class="descname">MakeHypersphere</code><span class="sig-paren">(</span><em>radius: float, center: numpy.ndarray[numpy.float64[m, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.geometry.optimization.Hyperellipsoid<a class="headerlink" href="#pydrake.geometry.optimization.Hyperellipsoid.MakeHypersphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs a hypersphere with <code class="docutils literal notranslate"><span class="pre">radius</span></code> and <code class="docutils literal notranslate"><span class="pre">center</span></code>.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.geometry.optimization.Hyperellipsoid.MakeUnitBall">
<em class="property">static </em><code class="descname">MakeUnitBall</code><span class="sig-paren">(</span><em>dim: int</em><span class="sig-paren">)</span> &#x2192; pydrake.geometry.optimization.Hyperellipsoid<a class="headerlink" href="#pydrake.geometry.optimization.Hyperellipsoid.MakeUnitBall" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs the L₂-norm unit ball in <code class="docutils literal notranslate"><span class="pre">dim</span></code> dimensions, {x | <a href="#id7"><span class="problematic" id="id8">|</span></a>x|₂ &lt;= 1
}.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.Hyperellipsoid.MinimumUniformScalingToTouch">
<code class="descname">MinimumUniformScalingToTouch</code><span class="sig-paren">(</span><em>self: pydrake.geometry.optimization.Hyperellipsoid</em>, <em>other: pydrake.geometry.optimization.ConvexSet</em><span class="sig-paren">)</span> &#x2192; Tuple[float, numpy.ndarray[numpy.float64[m, 1]]]<a class="headerlink" href="#pydrake.geometry.optimization.Hyperellipsoid.MinimumUniformScalingToTouch" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the smallest uniform scaling of this ellipsoid for which it
still intersects <code class="docutils literal notranslate"><span class="pre">other</span></code>. √ minₓ (x-center)ᵀAᵀA(x-center) s.t. x ∈
other. Note that if center ∈ other, then we expect scaling = 0 and x =
center (up to precision).</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd><code class="docutils literal notranslate"><span class="pre">other</span></code> must have the same ambient_dimension as this.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">the minimal scaling and the witness point, x, on other.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.Hyperellipsoid.Volume">
<code class="descname">Volume</code><span class="sig-paren">(</span><em>self: pydrake.geometry.optimization.Hyperellipsoid</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.geometry.optimization.Hyperellipsoid.Volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the volume of the hyperellipsoid (in Euclidean space).</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.geometry.optimization.Intersection">
<em class="property">class </em><code class="descclassname">pydrake.geometry.optimization.</code><code class="descname">Intersection</code><a class="headerlink" href="#pydrake.geometry.optimization.Intersection" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.geometry.optimization.ConvexSet" title="pydrake.geometry.optimization.ConvexSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.geometry.optimization.ConvexSet</span></code></a></p>
<p>A convex set that represents the intersection of multiple sets: S = X₁
∩ X₂ ∩ … ∩ Xₙ = {x | x ∈ X₁, x ∈ X₂, …, x ∈ Xₙ}</p>
<dl class="method">
<dt id="pydrake.geometry.optimization.Intersection.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.geometry.optimization.Intersection.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.geometry.optimization.Intersection, sets: List[pydrake.geometry.optimization.CopyableUniquePtrConvexSet]) -&gt; None</li>
</ol>
<p>Constructs the intersection from a vector of convex sets.</p>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.geometry.optimization.Intersection, setA: pydrake.geometry.optimization.ConvexSet, setB: pydrake.geometry.optimization.ConvexSet) -&gt; None</li>
</ol>
<p>Constructs the intersection from a pair of convex sets.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.Intersection.element">
<code class="descname">element</code><span class="sig-paren">(</span><em>self: pydrake.geometry.optimization.Intersection</em>, <em>index: int</em><span class="sig-paren">)</span> &#x2192; pydrake.geometry.optimization.ConvexSet<a class="headerlink" href="#pydrake.geometry.optimization.Intersection.element" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a reference to the ConvexSet defining the <code class="docutils literal notranslate"><span class="pre">index</span></code> element in
the intersection.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.Intersection.num_elements">
<code class="descname">num_elements</code><span class="sig-paren">(</span><em>self: pydrake.geometry.optimization.Intersection</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.geometry.optimization.Intersection.num_elements" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of elements (or sets) used in the intersection.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pydrake.geometry.optimization.Iris">
<code class="descclassname">pydrake.geometry.optimization.</code><code class="descname">Iris</code><span class="sig-paren">(</span><em>obstacles: List[pydrake.geometry.optimization.CopyableUniquePtrConvexSet], sample: numpy.ndarray[numpy.float64[m, 1]], domain: pydrake.geometry.optimization.HPolyhedron, options: pydrake.geometry.optimization.IrisOptions = IrisOptions(require_sample_point_is_contained=False, iteration_limit=100, termination_threshold=0.02, relative_termination_threshold=0.001, configuration_space_margin=0.01, num_collision_infeasible_samples=5, configuration_obstacles [], prog_with_additional_constraints is not set, num_additional_constraint_infeasible_samples=5, random_seed=1234)</em><span class="sig-paren">)</span> &#x2192; pydrake.geometry.optimization.HPolyhedron<a class="headerlink" href="#pydrake.geometry.optimization.Iris" title="Permalink to this definition">¶</a></dt>
<dd><p>The IRIS (Iterative Region Inflation by Semidefinite programming)
algorithm, as described in</p>
<p>R. L. H. Deits and R. Tedrake, “Computing large convex regions of
obstacle-free space through semidefinite programming,” Workshop on the
Algorithmic Fundamentals of Robotics, Istanbul, Aug. 2014.
<a class="reference external" href="http://groups.csail.mit.edu/robotics-center/public_papers/Deits14.pdf">http://groups.csail.mit.edu/robotics-center/public_papers/Deits14.pdf</a></p>
<p>This algorithm attempts to locally maximize the volume of a convex
polytope representing obstacle-free space given a sample point and
list of convex obstacles. Rather than compute the volume of the
polytope directly, the algorithm maximizes the volume of an inscribed
ellipsoid. It alternates between finding separating hyperplanes
between the ellipsoid and the obstacles and then finding a new
maximum-volume inscribed ellipsoid.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">obstacles</span></code>:</dt>
<dd>is a vector of convex sets representing the occupied space.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">sample</span></code>:</dt>
<dd>provides a point in the space; the algorithm is initialized using
a tiny sphere around this point. The algorithm is only guaranteed
to succeed if this sample point is collision free (outside of all
obstacles), but in practice the algorithm can often escape bad
initialization (assuming the require_sample_point_is_contained
option is false).</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">domain</span></code>:</dt>
<dd>describes the total region of interest; computed IRIS regions will
be inside this domain. It must be bounded, and is typically a
simple bounding box (e.g. from HPolyhedron::MakeBox).</dd>
</dl>
<p>The <code class="docutils literal notranslate"><span class="pre">obstacles</span></code>, <code class="docutils literal notranslate"><span class="pre">sample</span></code>, and the <code class="docutils literal notranslate"><span class="pre">domain</span></code> must describe
elements in the same ambient dimension (but that dimension can be any
positive integer).</p>
</dd></dl>

<dl class="function">
<dt id="pydrake.geometry.optimization.IrisInConfigurationSpace">
<code class="descclassname">pydrake.geometry.optimization.</code><code class="descname">IrisInConfigurationSpace</code><span class="sig-paren">(</span><em>plant: drake::multibody::MultibodyPlant&lt;double&gt;, context: pydrake.systems.framework.Context_[float], options: pydrake.geometry.optimization.IrisOptions = IrisOptions(require_sample_point_is_contained=False, iteration_limit=100, termination_threshold=0.02, relative_termination_threshold=0.001, configuration_space_margin=0.01, num_collision_infeasible_samples=5, configuration_obstacles [], prog_with_additional_constraints is not set, num_additional_constraint_infeasible_samples=5, random_seed=1234)</em><span class="sig-paren">)</span> &#x2192; pydrake.geometry.optimization.HPolyhedron<a class="headerlink" href="#pydrake.geometry.optimization.IrisInConfigurationSpace" title="Permalink to this definition">¶</a></dt>
<dd><p>A variation of the Iris (Iterative Region Inflation by Semidefinite
programming) algorithm which finds collision-free regions in the
<em>configuration space</em> of <code class="docutils literal notranslate"><span class="pre">plant</span></code>.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">Iris for details on the original algorithm. This variant uses
nonlinear optimization (instead of convex optimization) to find
collisions in configuration space; each potential collision is
probabilistically “certified” by restarting the nonlinear
optimization from random initial seeds inside the candidate IRIS
region until it fails to find a collision in
<code class="docutils literal notranslate"><span class="pre">options.num_collision_infeasible_samples</span></code> consecutive attempts.</p>
</div>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">plant</span></code>:</dt>
<dd>describes the kinematics of configuration space. It must be
connected to a SceneGraph in a systems::Diagram.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>is a context of the <code class="docutils literal notranslate"><span class="pre">plant</span></code>. The context must have the positions
of the plant set to the initialIRIS seed configuration.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">options</span></code>:</dt>
<dd>provides additional configuration options. In particular,
increasing <code class="docutils literal notranslate"><span class="pre">options.num_collision_infeasible_samples</span></code> increases
the chances that the IRIS regions are collision free but can also
significantly increase the run-time of the algorithm. The same
goes for
<code class="docutils literal notranslate"><span class="pre">options.num_additional_constraints_infeasible_samples</span></code>.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the sample configuration in <code class="docutils literal notranslate"><span class="pre">context</span></code> is</li>
<li><code class="xref py py-exc docutils literal notranslate"><span class="pre">infeasible.</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="pydrake.geometry.optimization.IrisOptions">
<em class="property">class </em><code class="descclassname">pydrake.geometry.optimization.</code><code class="descname">IrisOptions</code><a class="headerlink" href="#pydrake.geometry.optimization.IrisOptions" title="Permalink to this definition">¶</a></dt>
<dd><p>Configuration options for the IRIS algorithm.</p>
<dl class="method">
<dt id="pydrake.geometry.optimization.IrisOptions.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.geometry.optimization.IrisOptions</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.geometry.optimization.IrisOptions.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.geometry.optimization.IrisOptions.configuration_obstacles">
<code class="descname">configuration_obstacles</code><a class="headerlink" href="#pydrake.geometry.optimization.IrisOptions.configuration_obstacles" title="Permalink to this definition">¶</a></dt>
<dd><p>For IRIS in configuration space, it can be beneficial to not only
specify task-space obstacles (passed in through the plant) but also
obstacles that are defined by convex sets in the configuration space.
This option can be used to pass in such configuration space obstacles.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.geometry.optimization.IrisOptions.configuration_space_margin">
<code class="descname">configuration_space_margin</code><a class="headerlink" href="#pydrake.geometry.optimization.IrisOptions.configuration_space_margin" title="Permalink to this definition">¶</a></dt>
<dd><p>For IRIS in configuration space, we retreat by this margin from each
C-space obstacle in order to avoid the possibility of requiring an
infinite number of faces to approximate a curved boundary.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.geometry.optimization.IrisOptions.iteration_limit">
<code class="descname">iteration_limit</code><a class="headerlink" href="#pydrake.geometry.optimization.IrisOptions.iteration_limit" title="Permalink to this definition">¶</a></dt>
<dd><p>Maximum number of iterations.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.geometry.optimization.IrisOptions.num_additional_constraint_infeasible_samples">
<code class="descname">num_additional_constraint_infeasible_samples</code><a class="headerlink" href="#pydrake.geometry.optimization.IrisOptions.num_additional_constraint_infeasible_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>For each constraint in <code class="docutils literal notranslate"><span class="pre">prog_with_additional_constraints</span></code>, IRIS will
search for a counter-example by formulating a (likely nonconvex)
optimization problem. The initial guess for this optimization is taken
by sampling uniformly inside the current IRIS region. This option
controls the termination condition for that counter-example search,
defining the number of consecutive failures to find a counter-example
requested before moving on to the next constraint.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.geometry.optimization.IrisOptions.num_collision_infeasible_samples">
<code class="descname">num_collision_infeasible_samples</code><a class="headerlink" href="#pydrake.geometry.optimization.IrisOptions.num_collision_infeasible_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>For each possible collision, IRIS will search for a counter-example by
formulating a (likely nonconvex) optimization problem. The initial
guess for this optimization is taken by sampling uniformly inside the
current IRIS region. This option controls the termination condition
for that counter-example search, defining the number of consecutive
failures to find a counter-example requested before moving on to the
next constraint.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.geometry.optimization.IrisOptions.prog_with_additional_constraints">
<code class="descname">prog_with_additional_constraints</code><a class="headerlink" href="#pydrake.geometry.optimization.IrisOptions.prog_with_additional_constraints" title="Permalink to this definition">¶</a></dt>
<dd><p>By default, IRIS in configuration space certifies regions for
collision avoidance constraints and joint limits. This option can be
used to pass additional constraints that should be satisfied by the
IRIS region. We accept these in the form of a MathematicalProgram:</p>
<p>find q subject to g(q) ≤ 0.</p>
<p>The decision_variables() for the program are taken to define <code class="docutils literal notranslate"><span class="pre">q</span></code>.
IRIS will silently ignore any costs in
<code class="docutils literal notranslate"><span class="pre">prog_with_additional_constraints</span></code>, and will throw RuntimeError if
it contains any unsupported constraints.</p>
<p>For example, one could create an InverseKinematics problem with rich
kinematic constraints, and then pass <code class="docutils literal notranslate"><span class="pre">InverseKinematics::prog()</span></code>
into this option.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.geometry.optimization.IrisOptions.random_seed">
<code class="descname">random_seed</code><a class="headerlink" href="#pydrake.geometry.optimization.IrisOptions.random_seed" title="Permalink to this definition">¶</a></dt>
<dd><p>The only randomization in IRIS is the random sampling done to find
counter-examples for the additional constraints using in
IrisInConfigurationSpace. Use this option to set the initial seed.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.geometry.optimization.IrisOptions.relative_termination_threshold">
<code class="descname">relative_termination_threshold</code><a class="headerlink" href="#pydrake.geometry.optimization.IrisOptions.relative_termination_threshold" title="Permalink to this definition">¶</a></dt>
<dd><p>IRIS will terminate if the change in the <em>volume</em> of the
hyperellipsoid between iterations is less that this percent of the
previouse best volume. This termination condition can be disabled by
setting to a negative value.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.geometry.optimization.IrisOptions.require_sample_point_is_contained">
<code class="descname">require_sample_point_is_contained</code><a class="headerlink" href="#pydrake.geometry.optimization.IrisOptions.require_sample_point_is_contained" title="Permalink to this definition">¶</a></dt>
<dd><p>The initial polytope is guaranteed to contain the point if that point
is collision-free. However, the IRIS alternation objectives do not
include (and can not easily include) a constraint that the original
sample point is contained. Therefore, the IRIS paper recommends that
if containment is a requirement, then the algorithm should simply
terminate early if alternations would ever cause the set to not
contain the point.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.geometry.optimization.IrisOptions.termination_threshold">
<code class="descname">termination_threshold</code><a class="headerlink" href="#pydrake.geometry.optimization.IrisOptions.termination_threshold" title="Permalink to this definition">¶</a></dt>
<dd><p>IRIS will terminate if the change in the <em>volume</em> of the
hyperellipsoid between iterations is less that this threshold. This
termination condition can be disabled by setting to a negative value.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pydrake.geometry.optimization.MakeIrisObstacles">
<code class="descclassname">pydrake.geometry.optimization.</code><code class="descname">MakeIrisObstacles</code><span class="sig-paren">(</span><em>query_object: pydrake.geometry.QueryObject_[float], reference_frame: Optional[pydrake.geometry.FrameId] = None</em><span class="sig-paren">)</span> &#x2192; List[pydrake.geometry.optimization.CopyableUniquePtrConvexSet]<a class="headerlink" href="#pydrake.geometry.optimization.MakeIrisObstacles" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs ConvexSet representations of obstacles for IRIS in 3D using
the geometry from a SceneGraph QueryObject. All geometry in the scene
with a proximity role, both anchored and dynamic, are consider to be
<em>fixed</em> obstacles frozen in the poses captured in the context used to
create the QueryObject.</p>
<p>When multiple representations are available for a particular geometry
(e.g. a Box can be represented as either an HPolyhedron or a
VPolytope), then this method will prioritize the representation that
we expect is most performant for the current implementation of the
IRIS algorithm.</p>
</dd></dl>

<dl class="class">
<dt id="pydrake.geometry.optimization.MinkowskiSum">
<em class="property">class </em><code class="descclassname">pydrake.geometry.optimization.</code><code class="descname">MinkowskiSum</code><a class="headerlink" href="#pydrake.geometry.optimization.MinkowskiSum" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.geometry.optimization.ConvexSet" title="pydrake.geometry.optimization.ConvexSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.geometry.optimization.ConvexSet</span></code></a></p>
<p>A convex set that represents the Minkowski sum of multiple sets: S =
X₁ ⨁ X₂ ⨁ … ⨁ Xₙ = {x₁ + x₂ + … + xₙ | x₁ ∈ X₁, x₂ ∈ X₂, …, xₙ ∈
Xₙ}</p>
<dl class="method">
<dt id="pydrake.geometry.optimization.MinkowskiSum.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.geometry.optimization.MinkowskiSum.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.geometry.optimization.MinkowskiSum, sets: List[pydrake.geometry.optimization.CopyableUniquePtrConvexSet]) -&gt; None</li>
</ol>
<p>Constructs the sum from a vector of convex sets.</p>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.geometry.optimization.MinkowskiSum, setA: pydrake.geometry.optimization.ConvexSet, setB: pydrake.geometry.optimization.ConvexSet) -&gt; None</li>
</ol>
<p>Constructs the sum from a pair of convex sets.</p>
<ol class="arabic simple" start="3">
<li>__init__(self: pydrake.geometry.optimization.MinkowskiSum, query_object: pydrake.geometry.QueryObject_[float], geometry_id: pydrake.geometry.GeometryId, reference_frame: Optional[pydrake.geometry.FrameId] = None) -&gt; None</li>
</ol>
<p>Constructs a MinkowskiSum from a SceneGraph geometry and pose in the
<code class="docutils literal notranslate"><span class="pre">reference_frame</span></code> frame, obtained via the QueryObject. If
<code class="docutils literal notranslate"><span class="pre">reference_frame</span></code> frame is std::nullopt, then it will be expressed
in the world frame.</p>
<p>Although in principle a MinkowskiSum can represent any ConvexSet as
the sum of a single set, here we only support Capsule geometry, which
will be represented as the (non-trivial) Minkowski sum of a sphere
with a line segment. Most SceneGraph geometry types are supported by
at least one of the ConvexSet class constructors.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if geometry_id does not correspond to a Capsule.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.MinkowskiSum.num_terms">
<code class="descname">num_terms</code><span class="sig-paren">(</span><em>self: pydrake.geometry.optimization.MinkowskiSum</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.geometry.optimization.MinkowskiSum.num_terms" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of terms (or sets) used in the sum.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.MinkowskiSum.term">
<code class="descname">term</code><span class="sig-paren">(</span><em>self: pydrake.geometry.optimization.MinkowskiSum</em>, <em>index: int</em><span class="sig-paren">)</span> &#x2192; pydrake.geometry.optimization.ConvexSet<a class="headerlink" href="#pydrake.geometry.optimization.MinkowskiSum.term" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a reference to the ConvexSet defining the <code class="docutils literal notranslate"><span class="pre">index</span></code> term in
the sum.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.geometry.optimization.Point">
<em class="property">class </em><code class="descclassname">pydrake.geometry.optimization.</code><code class="descname">Point</code><a class="headerlink" href="#pydrake.geometry.optimization.Point" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.geometry.optimization.ConvexSet" title="pydrake.geometry.optimization.ConvexSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.geometry.optimization.ConvexSet</span></code></a></p>
<p>A convex set that contains exactly one element. Also known as a
singleton or unit set.</p>
<dl class="method">
<dt id="pydrake.geometry.optimization.Point.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.geometry.optimization.Point.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.geometry.optimization.Point, x: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</li>
</ol>
<p>Constructs a Point.</p>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.geometry.optimization.Point, query_object: pydrake.geometry.QueryObject_[float], geometry_id: pydrake.geometry.GeometryId, reference_frame: Optional[pydrake.geometry.FrameId] = None, maximum_allowable_radius: float = 0.0) -&gt; None</li>
</ol>
<p>Constructs a Point from a SceneGraph geometry and pose in the
<code class="docutils literal notranslate"><span class="pre">reference_frame</span></code> frame, obtained via the QueryObject. If
<code class="docutils literal notranslate"><span class="pre">reference_frame</span></code> frame is std::nullopt, then it will be expressed
in the world frame.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if geometry_id does not correspond to a Sphere or if</li>
<li>the Sphere has radius greater than <code class="docutils literal notranslate"><span class="pre">maximum_allowable_radius</span></code>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.Point.set_x">
<code class="descname">set_x</code><span class="sig-paren">(</span><em>self: pydrake.geometry.optimization.Point, x: numpy.ndarray[numpy.float64[m, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.geometry.optimization.Point.set_x" title="Permalink to this definition">¶</a></dt>
<dd><p>Changes the element <code class="docutils literal notranslate"><span class="pre">x</span></code> describing the set.</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd><code class="docutils literal notranslate"><span class="pre">x</span></code> must be of size ambient_dimension().</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.Point.x">
<code class="descname">x</code><span class="sig-paren">(</span><em>self: pydrake.geometry.optimization.Point</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.geometry.optimization.Point.x" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves the point.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.geometry.optimization.VPolytope">
<em class="property">class </em><code class="descclassname">pydrake.geometry.optimization.</code><code class="descname">VPolytope</code><a class="headerlink" href="#pydrake.geometry.optimization.VPolytope" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.geometry.optimization.ConvexSet" title="pydrake.geometry.optimization.ConvexSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.geometry.optimization.ConvexSet</span></code></a></p>
<p>A polytope described using the vertex representation. The set is
defined as the convex hull of the vertices. The vertices are not
guaranteed to be in any particular order, nor to be minimal (some
vertices could be strictly in the interior of the set).</p>
<p>Note: Unlike the half-space representation, this definition means the
set is always bounded (hence the name polytope, instead of
polyhedron).</p>
<dl class="method">
<dt id="pydrake.geometry.optimization.VPolytope.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.geometry.optimization.VPolytope.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.geometry.optimization.VPolytope, vertices: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous]) -&gt; None</li>
</ol>
<p>Constructs the polytope from a d-by-n matrix, where d is the ambient
dimension, and n is the number of vertices. The vertices do not have
to be ordered, nor minimal (they can contain points inside their
convex hull).</p>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.geometry.optimization.VPolytope, H: pydrake.geometry.optimization.HPolyhedron) -&gt; None</li>
</ol>
<p>Constructs the polytope from a bounded polyhedron (using Qhull).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if H is unbounded or if Qhull terminates with an</li>
<li><code class="xref py py-exc docutils literal notranslate"><span class="pre">error.</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="3">
<li>__init__(self: pydrake.geometry.optimization.VPolytope, query_object: pydrake.geometry.QueryObject_[float], geometry_id: pydrake.geometry.GeometryId, reference_frame: Optional[pydrake.geometry.FrameId] = None) -&gt; None</li>
</ol>
<p>Constructs the polytope from a SceneGraph geometry.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.VPolytope.CalcVolume">
<code class="descname">CalcVolume</code><span class="sig-paren">(</span><em>self: pydrake.geometry.optimization.VPolytope</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.geometry.optimization.VPolytope.CalcVolume" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the volume of this V-Polytope.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">this function calls qhull to compute the volume.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.VPolytope.GetMinimalRepresentation">
<code class="descname">GetMinimalRepresentation</code><span class="sig-paren">(</span><em>self: pydrake.geometry.optimization.VPolytope</em><span class="sig-paren">)</span> &#x2192; pydrake.geometry.optimization.VPolytope<a class="headerlink" href="#pydrake.geometry.optimization.VPolytope.GetMinimalRepresentation" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a new VPolytope whose vertices are guaranteed to be minimal,
i.e. if we remove any point from its vertices, then the convex hull of
the remaining vertices is a strict subset of the polytope. In the 2D
case the vertices of the new VPolytope are ordered counter-clockwise
from the negative X axis. For all other cases an order is not
guaranteed.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.geometry.optimization.VPolytope.MakeBox">
<em class="property">static </em><code class="descname">MakeBox</code><span class="sig-paren">(</span><em>lb: numpy.ndarray[numpy.float64[m, 1]], ub: numpy.ndarray[numpy.float64[m, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.geometry.optimization.VPolytope<a class="headerlink" href="#pydrake.geometry.optimization.VPolytope.MakeBox" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs a polyhedron as an axis-aligned box from the lower and
upper corners.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.geometry.optimization.VPolytope.MakeUnitBox">
<em class="property">static </em><code class="descname">MakeUnitBox</code><span class="sig-paren">(</span><em>dim: int</em><span class="sig-paren">)</span> &#x2192; pydrake.geometry.optimization.VPolytope<a class="headerlink" href="#pydrake.geometry.optimization.VPolytope.MakeUnitBox" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs the L∞-norm unit box in <code class="docutils literal notranslate"><span class="pre">dim</span></code> dimensions, {x | <a href="#id9"><span class="problematic" id="id10">|</span></a>x|∞ &lt;= 1
}. This is an axis-aligned box, centered at the origin, with edge
length 2.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.optimization.VPolytope.vertices">
<code class="descname">vertices</code><span class="sig-paren">(</span><em>self: pydrake.geometry.optimization.VPolytope</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, n]]<a class="headerlink" href="#pydrake.geometry.optimization.VPolytope.vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the vertices in a d-by-n matrix, where d is the ambient
dimension, and n is the number of vertices.</p>
</dd></dl>

</dd></dl>

</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="pydrake.geometry.render.html" class="btn btn-neutral float-right" title="pydrake.geometry.render" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="pydrake.geometry.all.html" class="btn btn-neutral float-left" title="pydrake.geometry.all" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>

    </p>
  </div>
</footer>
<script>
  /* Enables clicking for the mobile "hamburger" (three-line) menu item. */
  const siteHeader = document.querySelector('.site-header')
  const mobileButton = document.querySelector('.menu-mobile-toggle')
  const body = document.querySelector('body')

  mobileButton.addEventListener('click', function(event) {
    siteHeader.classList.toggle('open');
    body.classList.toggle('overflow-hidden');
  })
</script>
<footer class="site-footer padding">
  <div class="contain">
    <a href="/" class="drake-logo">
      <img src="/images/drake-logo.svg">
    </a>
    <div class="footer-menu">
      <ul>
        <li>
          <a href="/doxygen_cxx/index.html" class="site-menu-item">C++</a>
        </li>
        <li>
          <a href="/pydrake/index.html" class="site-menu-item">Python</a>
        </li>
        <li class="github-link">
          <a href="https://github.com/RobotLocomotion/drake" class="site-menu-item">GitHub <img src="/third_party/images/GitHub-Mark-64px.png"></a>
        </li>
      </ul>
    </div>
  </div>


</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>