<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: PolygonSurfaceMesh&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Drake
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classdrake_1_1geometry_1_1_polygon_surface_mesh.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classdrake_1_1geometry_1_1_polygon_surface_mesh-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">PolygonSurfaceMesh&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T&gt;<br />
class drake::geometry::PolygonSurfaceMesh&lt; T &gt;</h3>

<p>PolygonSurfaceMesh represents a surface comprised of <em>polygonal</em> elements (three or more sides). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The scalar type, which must be one of the <a class="el" href="group__default__scalars.html">default nonsymbolic scalars</a>. </td></tr>
  </table>
  </dd>
</dl>
</div>
<p><code>#include &lt;drake/geometry/proximity/polygon_surface_mesh.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a486408b1605b8530c7d09dd862b8e570"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_polygon_surface_mesh.html#a486408b1605b8530c7d09dd862b8e570">PolygonSurfaceMesh</a> ()</td></tr>
<tr class="memdesc:a486408b1605b8530c7d09dd862b8e570"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advanced() Constructs an <em>empty</em> mesh.  <a href="#a486408b1605b8530c7d09dd862b8e570">More...</a><br /></td></tr>
<tr class="separator:a486408b1605b8530c7d09dd862b8e570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa7aaf728aed0085ee1462355559fabc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_polygon_surface_mesh.html#aaa7aaf728aed0085ee1462355559fabc">PolygonSurfaceMesh</a> (std::vector&lt; <a class="el" href="classint.html">int</a> &gt; <a class="el" href="classdrake_1_1geometry_1_1_polygon_surface_mesh.html#a88623e38c6b1b2d533a8a480067fee21">face_data</a>, std::vector&lt; <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt;&gt; vertices)</td></tr>
<tr class="memdesc:aaa7aaf728aed0085ee1462355559fabc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a mesh from specified vertex and mesh data.  <a href="#aaa7aaf728aed0085ee1462355559fabc">More...</a><br /></td></tr>
<tr class="separator:aaa7aaf728aed0085ee1462355559fabc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a505ea28f0f6274285a379c870c44bb37"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_polygon_surface_mesh.html#a505ea28f0f6274285a379c870c44bb37">TransformVertices</a> (const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; T &gt; &amp;X_NM)</td></tr>
<tr class="memdesc:a505ea28f0f6274285a379c870c44bb37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms the vertices of this mesh from its initial frame M to the new frame N.  <a href="#a505ea28f0f6274285a379c870c44bb37">More...</a><br /></td></tr>
<tr class="separator:a505ea28f0f6274285a379c870c44bb37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c9e33a8f7704980ea0a0f3a4455eaf7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_polygon_surface_mesh.html#a3c9e33a8f7704980ea0a0f3a4455eaf7">ReverseFaceWinding</a> ()</td></tr>
<tr class="memdesc:a3c9e33a8f7704980ea0a0f3a4455eaf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses the ordering of all the faces' indices.  <a href="#a3c9e33a8f7704980ea0a0f3a4455eaf7">More...</a><br /></td></tr>
<tr class="separator:a3c9e33a8f7704980ea0a0f3a4455eaf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a132d1bbcbcc1ac76319da744805bd865"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_polygon_surface_mesh.html#a132d1bbcbcc1ac76319da744805bd865">num_faces</a> () const</td></tr>
<tr class="memdesc:a132d1bbcbcc1ac76319da744805bd865"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of polygonal elements in the mesh.  <a href="#a132d1bbcbcc1ac76319da744805bd865">More...</a><br /></td></tr>
<tr class="separator:a132d1bbcbcc1ac76319da744805bd865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a563798979d1f16337b662d90ccede642"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_polygon_surface_mesh.html#a563798979d1f16337b662d90ccede642">area</a> (<a class="el" href="classint.html">int</a> f) const</td></tr>
<tr class="memdesc:a563798979d1f16337b662d90ccede642"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns area of a polygonal element.  <a href="#a563798979d1f16337b662d90ccede642">More...</a><br /></td></tr>
<tr class="separator:a563798979d1f16337b662d90ccede642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d8645defeea4264d39cf1bdf5a66f79"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_polygon_surface_mesh.html#a5d8645defeea4264d39cf1bdf5a66f79">total_area</a> () const</td></tr>
<tr class="memdesc:a5d8645defeea4264d39cf1bdf5a66f79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total area of all the faces of this surface mesh.  <a href="#a5d8645defeea4264d39cf1bdf5a66f79">More...</a><br /></td></tr>
<tr class="separator:a5d8645defeea4264d39cf1bdf5a66f79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7744f912c3286ddc8f2a755e527c2e23"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_polygon_surface_mesh.html#a7744f912c3286ddc8f2a755e527c2e23">face_normal</a> (<a class="el" href="classint.html">int</a> f) const</td></tr>
<tr class="memdesc:a7744f912c3286ddc8f2a755e527c2e23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the unit face normal vector of a polygon.  <a href="#a7744f912c3286ddc8f2a755e527c2e23">More...</a><br /></td></tr>
<tr class="separator:a7744f912c3286ddc8f2a755e527c2e23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a342c3c95a27ab249ff49c4431206b8a4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_polygon_surface_mesh.html#a342c3c95a27ab249ff49c4431206b8a4">element_centroid</a> (<a class="el" href="classint.html">int</a> e) const</td></tr>
<tr class="memdesc:a342c3c95a27ab249ff49c4431206b8a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the geometric centroid of the element indicated be index <code>e</code>, measured and expressed in the mesh's frame M.  <a href="#a342c3c95a27ab249ff49c4431206b8a4">More...</a><br /></td></tr>
<tr class="separator:a342c3c95a27ab249ff49c4431206b8a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a819bca2023eaa88015e3e51f6e9f557e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_polygon_surface_mesh.html#a819bca2023eaa88015e3e51f6e9f557e">centroid</a> () const</td></tr>
<tr class="memdesc:a819bca2023eaa88015e3e51f6e9f557e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the geometric centroid of this mesh measured and expressed in the mesh's frame M.  <a href="#a819bca2023eaa88015e3e51f6e9f557e">More...</a><br /></td></tr>
<tr class="separator:a819bca2023eaa88015e3e51f6e9f557e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a5b426d341fbe015c98e1373a253b26"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:a2a5b426d341fbe015c98e1373a253b26"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1geometry_1_1_polygon_surface_mesh.html#a9ec52d4217b88f37e7a782129bf52372">Barycentric</a>&lt; <a class="el" href="namespacedrake_1_1geometry.html#a74b8d905842571b365085fdd17378772">promoted_numerical_t</a>&lt; T, C &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_polygon_surface_mesh.html#a2a5b426d341fbe015c98e1373a253b26">CalcBarycentric</a> (const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; C &gt; &amp;p_MQ, <a class="el" href="classint.html">int</a> p) const</td></tr>
<tr class="memdesc:a2a5b426d341fbe015c98e1373a253b26"><td class="mdescLeft">&#160;</td><td class="mdescRight">See TriangleSurfaceMesh::CalcBaryCentric().  <a href="#a2a5b426d341fbe015c98e1373a253b26">More...</a><br /></td></tr>
<tr class="separator:a2a5b426d341fbe015c98e1373a253b26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a972cf7cd80fb7a8357c8202a6c163612"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt;, <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_polygon_surface_mesh.html#a972cf7cd80fb7a8357c8202a6c163612">CalcBoundingBox</a> () const</td></tr>
<tr class="memdesc:a972cf7cd80fb7a8357c8202a6c163612"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the axis-aligned bounding box of this surface mesh M.  <a href="#a972cf7cd80fb7a8357c8202a6c163612">More...</a><br /></td></tr>
<tr class="separator:a972cf7cd80fb7a8357c8202a6c163612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73802b68cb8f52b2161fe1915928341f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_polygon_surface_mesh.html#a73802b68cb8f52b2161fe1915928341f">Equal</a> (const <a class="el" href="classdrake_1_1geometry_1_1_polygon_surface_mesh.html">PolygonSurfaceMesh</a>&lt; T &gt; &amp;mesh) const</td></tr>
<tr class="memdesc:a73802b68cb8f52b2161fe1915928341f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see whether the given <a class="el" href="classdrake_1_1geometry_1_1_polygon_surface_mesh.html" title="PolygonSurfaceMesh represents a surface comprised of polygonal elements (three or more sides).">PolygonSurfaceMesh</a> object is equal via deep exact comparison.  <a href="#a73802b68cb8f52b2161fe1915928341f">More...</a><br /></td></tr>
<tr class="separator:a73802b68cb8f52b2161fe1915928341f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88623e38c6b1b2d533a8a480067fee21"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_polygon_surface_mesh.html#a88623e38c6b1b2d533a8a480067fee21">face_data</a> () const</td></tr>
<tr class="separator:a88623e38c6b1b2d533a8a480067fee21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a731026bbdfdf20f7d65e197c730f8576"><td class="memTemplParams" colspan="2">template&lt;typename FieldValue &gt; </td></tr>
<tr class="memitem:a731026bbdfdf20f7d65e197c730f8576"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; FieldValue &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_polygon_surface_mesh.html#a731026bbdfdf20f7d65e197c730f8576">CalcGradientVectorOfLinearField</a> (const std::array&lt; FieldValue, 3 &gt; &amp;field_value, <a class="el" href="classint.html">int</a> p) const</td></tr>
<tr class="memdesc:a731026bbdfdf20f7d65e197c730f8576"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a stub method.  <a href="#a731026bbdfdf20f7d65e197c730f8576">More...</a><br /></td></tr>
<tr class="separator:a731026bbdfdf20f7d65e197c730f8576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Implements CopyConstructible, CopyAssignable, MoveConstructible, MoveAssignable</div></td></tr>
<tr class="memitem:aed01f43de73ada1fe1b687e113efe612"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_polygon_surface_mesh.html#aed01f43de73ada1fe1b687e113efe612">PolygonSurfaceMesh</a> (const <a class="el" href="classdrake_1_1geometry_1_1_polygon_surface_mesh.html">PolygonSurfaceMesh</a> &amp;)=default</td></tr>
<tr class="separator:aed01f43de73ada1fe1b687e113efe612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13b0cf1ca7ffa5d2e6f7745d7988d37c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1geometry_1_1_polygon_surface_mesh.html">PolygonSurfaceMesh</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_polygon_surface_mesh.html#a13b0cf1ca7ffa5d2e6f7745d7988d37c">operator=</a> (const <a class="el" href="classdrake_1_1geometry_1_1_polygon_surface_mesh.html">PolygonSurfaceMesh</a> &amp;)=default</td></tr>
<tr class="separator:a13b0cf1ca7ffa5d2e6f7745d7988d37c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae370de5092aa6686239bd0840d5acad5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_polygon_surface_mesh.html#ae370de5092aa6686239bd0840d5acad5">PolygonSurfaceMesh</a> (<a class="el" href="classdrake_1_1geometry_1_1_polygon_surface_mesh.html">PolygonSurfaceMesh</a> &amp;&amp;)=default</td></tr>
<tr class="separator:ae370de5092aa6686239bd0840d5acad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22da11d92003ac4ad72bbd6331287dbe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1geometry_1_1_polygon_surface_mesh.html">PolygonSurfaceMesh</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_polygon_surface_mesh.html#a22da11d92003ac4ad72bbd6331287dbe">operator=</a> (<a class="el" href="classdrake_1_1geometry_1_1_polygon_surface_mesh.html">PolygonSurfaceMesh</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a22da11d92003ac4ad72bbd6331287dbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Mesh type traits</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpfc37eb5631f33a34b4f8b7fd41bb2a6b"></a>A collection of type traits to enable mesh consumers to be templated on mesh type.</p>
<p>Each mesh type provides specific definitions of <em>element</em> and <em>barycentric coordinates</em>. For PolygonSurfaceMesh, an element is a polygon. </p>
</td></tr>
<tr class="memitem:a6aec7d49d25322d8fae54028059d27aa"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_polygon_surface_mesh.html#a6aec7d49d25322d8fae54028059d27aa">ScalarType</a> = T</td></tr>
<tr class="separator:a6aec7d49d25322d8fae54028059d27aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ec52d4217b88f37e7a782129bf52372"><td class="memTemplParams" colspan="2">template&lt;typename U  = T&gt; </td></tr>
<tr class="memitem:a9ec52d4217b88f37e7a782129bf52372"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_polygon_surface_mesh.html#a9ec52d4217b88f37e7a782129bf52372">Barycentric</a> = <a class="el" href="namespacedrake.html#a01ae662d5635b7c9efe03d15d976f7a8">Vector</a>&lt; U, 0 &gt;</td></tr>
<tr class="memdesc:a9ec52d4217b88f37e7a782129bf52372"><td class="mdescLeft">&#160;</td><td class="mdescRight">PolygonSurfaceMesh doesn't actually support barycentric coordinates.  <a href="#a9ec52d4217b88f37e7a782129bf52372">More...</a><br /></td></tr>
<tr class="separator:a9ec52d4217b88f37e7a782129bf52372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39b0509ce7179535d6b30f11fb305dc6"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_polygon_surface_mesh.html#a39b0509ce7179535d6b30f11fb305dc6">kVertexPerElement</a> = -1</td></tr>
<tr class="memdesc:a39b0509ce7179535d6b30f11fb305dc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">A definition that satisfies the interface that <a class="el" href="classdrake_1_1geometry_1_1_mesh_field_linear.html" title="MeshFieldLinear represents a continuous piecewise-linear scalar field f defined on a (triangular or t...">MeshFieldLinear</a> requires.  <a href="#a39b0509ce7179535d6b30f11fb305dc6">More...</a><br /></td></tr>
<tr class="separator:a39b0509ce7179535d6b30f11fb305dc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9709fac7886877fc597e4a8117b4e549"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1geometry_1_1_surface_polygon.html">SurfacePolygon</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_polygon_surface_mesh.html#a9709fac7886877fc597e4a8117b4e549">element</a> (<a class="el" href="classint.html">int</a> e) const</td></tr>
<tr class="memdesc:a9709fac7886877fc597e4a8117b4e549"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the polygonal element identified by the given index <code>e</code>.  <a href="#a9709fac7886877fc597e4a8117b4e549">More...</a><br /></td></tr>
<tr class="separator:a9709fac7886877fc597e4a8117b4e549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8388a3f4417bdec45042a7fd2166a6a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_polygon_surface_mesh.html#aa8388a3f4417bdec45042a7fd2166a6a">vertex</a> (<a class="el" href="classint.html">int</a> v) const</td></tr>
<tr class="memdesc:aa8388a3f4417bdec45042a7fd2166a6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the vertex identified by the given index <code>v</code>.  <a href="#aa8388a3f4417bdec45042a7fd2166a6a">More...</a><br /></td></tr>
<tr class="separator:aa8388a3f4417bdec45042a7fd2166a6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a319e621fc359dd8daad48247f95b12fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_polygon_surface_mesh.html#a319e621fc359dd8daad48247f95b12fa">num_vertices</a> () const</td></tr>
<tr class="memdesc:a319e621fc359dd8daad48247f95b12fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of vertices in the mesh.  <a href="#a319e621fc359dd8daad48247f95b12fa">More...</a><br /></td></tr>
<tr class="separator:a319e621fc359dd8daad48247f95b12fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98f8a4ac27c2c8008728ae504e8e68bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_polygon_surface_mesh.html#a98f8a4ac27c2c8008728ae504e8e68bc">num_elements</a> () const</td></tr>
<tr class="memdesc:a98f8a4ac27c2c8008728ae504e8e68bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in the mesh.  <a href="#a98f8a4ac27c2c8008728ae504e8e68bc">More...</a><br /></td></tr>
<tr class="separator:a98f8a4ac27c2c8008728ae504e8e68bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a9ec52d4217b88f37e7a782129bf52372"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ec52d4217b88f37e7a782129bf52372">&#9670;&nbsp;</a></span>Barycentric</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classdrake_1_1geometry_1_1_polygon_surface_mesh.html#a9ec52d4217b88f37e7a782129bf52372">Barycentric</a> =  <a class="el" href="namespacedrake.html#a01ae662d5635b7c9efe03d15d976f7a8">Vector</a>&lt;U, 0&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>PolygonSurfaceMesh doesn't actually support barycentric coordinates. </p>
<p>This is here to satisfy the <a class="el" href="classdrake_1_1geometry_1_1_mesh_field_linear.html" title="MeshFieldLinear represents a continuous piecewise-linear scalar field f defined on a (triangular or t...">MeshFieldLinear</a> interface. The dimension is selected to be zero to minimize memory footprint in case one is inadvertently instantiated. </p>

</div>
</div>
<a id="a6aec7d49d25322d8fae54028059d27aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6aec7d49d25322d8fae54028059d27aa">&#9670;&nbsp;</a></span>ScalarType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classdrake_1_1geometry_1_1_polygon_surface_mesh.html#a6aec7d49d25322d8fae54028059d27aa">ScalarType</a> =  T</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aed01f43de73ada1fe1b687e113efe612"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed01f43de73ada1fe1b687e113efe612">&#9670;&nbsp;</a></span>PolygonSurfaceMesh() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1_polygon_surface_mesh.html">PolygonSurfaceMesh</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1_polygon_surface_mesh.html">PolygonSurfaceMesh</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae370de5092aa6686239bd0840d5acad5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae370de5092aa6686239bd0840d5acad5">&#9670;&nbsp;</a></span>PolygonSurfaceMesh() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1_polygon_surface_mesh.html">PolygonSurfaceMesh</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1geometry_1_1_polygon_surface_mesh.html">PolygonSurfaceMesh</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a486408b1605b8530c7d09dd862b8e570"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a486408b1605b8530c7d09dd862b8e570">&#9670;&nbsp;</a></span>PolygonSurfaceMesh() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1_polygon_surface_mesh.html">PolygonSurfaceMesh</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Advanced() Constructs an <em>empty</em> mesh. </p>
<p>This enables compatibility with STL container types and facilitates some unit tests. Otherwise, it shouldn't be used. </p>

</div>
</div>
<a id="aaa7aaf728aed0085ee1462355559fabc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa7aaf728aed0085ee1462355559fabc">&#9670;&nbsp;</a></span>PolygonSurfaceMesh() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1_polygon_surface_mesh.html">PolygonSurfaceMesh</a> </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classint.html">int</a> &gt;&#160;</td>
          <td class="paramname"><em>face_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>vertices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a mesh from specified vertex and mesh data. </p>
<p>The vertices are simply a vector of position vectors (interpreted as being measured and expressed in the mesh's frame M).</p>
<p>The polygon data is more complex. Syntactically, it is a sequence of integers which <em>encodes</em> P polygons. Each polygon can have an arbitrary number of vertices. The encoding of the P polygons is as follows: </p><pre class="fragment">|c₁|v₁₀|v₁₁|...|cᵢ|cᵢ₀|cᵢ₁|...|cₚ|cₚ₀|cₚ₁|...|
</pre><p>Each polygon is defined in sequence. The definition consists of an integer indicating the <em>number</em> of vertices in that polygon (c₁, cᵢ, and cₘ in the illustration above). The next cᵢ integers in the sequence are zero-based indices into the vector of vertex positions (indicating which vertices the polygon spans). The vertex indices are sorted such that the plane normal found by applying the right-handed rule is used as the face normal.</p>
<p>This implies the following: Polygon one: Located at index i₁ = 0 in <code>face_data</code>. c₁ = face_data[i₁] is the number of vertices in polygon one. Polygon two: Located at index i₂ = i₁ + c₁ + 1 in <code>face_data</code>. c₂ = face_data[i₂] is the number of vertices in polygon zero. Polygon j: Located at index iⱼ = iⱼ₋₁ + cⱼ₋₁ + 1 cⱼ = face_data[iⱼ]</p>
<p>The polygons must all be planar and convex.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">face_data</td><td>The sequence of counts and indices which encode the faces of the mesh (see above). </td></tr>
    <tr><td class="paramname">vertices</td><td>The vertex positions, measured and expressed in this mesh's frame. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The indices in <code>face_data</code> all refer to valid indices into <code>vertices</code>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If <code>face_data</code> includes a zero-area polygon, that polygon will have a non-NaN centroid chosen arbitrarily. For hydroelastics, this is acceptable because its zero area will neutralize its contribution to computation of contact wrench. If all polygons have zero area, the mesh's centroid will be chosen arbitrarily as well. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a563798979d1f16337b662d90ccede642"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a563798979d1f16337b662d90ccede642">&#9670;&nbsp;</a></span>area()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; area </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns area of a polygonal element. </p>
<dl class="section pre"><dt>Precondition</dt><dd>f ∈ {0, 1, 2, ..., <a class="el" href="classdrake_1_1geometry_1_1_polygon_surface_mesh.html#a132d1bbcbcc1ac76319da744805bd865" title="Returns the number of polygonal elements in the mesh.">num_faces()</a>-1}. </dd></dl>

</div>
</div>
<a id="a2a5b426d341fbe015c98e1373a253b26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a5b426d341fbe015c98e1373a253b26">&#9670;&nbsp;</a></span>CalcBarycentric()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1_polygon_surface_mesh.html#a9ec52d4217b88f37e7a782129bf52372">Barycentric</a>&lt;<a class="el" href="namespacedrake_1_1geometry.html#a74b8d905842571b365085fdd17378772">promoted_numerical_t</a>&lt;T, C&gt; &gt; CalcBarycentric </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; C &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_MQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See TriangleSurfaceMesh::CalcBaryCentric(). </p>
<p>This implementation is provided to maintain compatibility with <a class="el" href="classdrake_1_1geometry_1_1_mesh_field_linear.html" title="MeshFieldLinear represents a continuous piecewise-linear scalar field f defined on a (triangular or t...">MeshFieldLinear</a>. However, it only throws. PolygonSurfaceMesh does not support barycentric coordinates. </p>

</div>
</div>
<a id="a972cf7cd80fb7a8357c8202a6c163612"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a972cf7cd80fb7a8357c8202a6c163612">&#9670;&nbsp;</a></span>CalcBoundingBox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt;T&gt;, <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt;T&gt; &gt; CalcBoundingBox </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the axis-aligned bounding box of this surface mesh M. </p>
<dl class="section return"><dt>Returns</dt><dd>the center and the size vector of the box expressed in M's frame. </dd></dl>

</div>
</div>
<a id="a731026bbdfdf20f7d65e197c730f8576"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a731026bbdfdf20f7d65e197c730f8576">&#9670;&nbsp;</a></span>CalcGradientVectorOfLinearField()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt;FieldValue&gt; CalcGradientVectorOfLinearField </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; FieldValue, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>field_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a stub method. </p>
<p>It is provided so that <a class="el" href="classdrake_1_1geometry_1_1_polygon_surface_mesh.html" title="PolygonSurfaceMesh represents a surface comprised of polygonal elements (three or more sides).">PolygonSurfaceMesh</a> provides a sufficient API to compile against <a class="el" href="classdrake_1_1geometry_1_1_mesh_field_linear.html" title="MeshFieldLinear represents a continuous piecewise-linear scalar field f defined on a (triangular or t...">MeshFieldLinear</a>. However, we expect that the gradients of the field will always be provided when defining a <a class="el" href="classdrake_1_1geometry_1_1_mesh_field_linear.html" title="MeshFieldLinear represents a continuous piecewise-linear scalar field f defined on a (triangular or t...">MeshFieldLinear</a> with a <a class="el" href="classdrake_1_1geometry_1_1_polygon_surface_mesh.html" title="PolygonSurfaceMesh represents a surface comprised of polygonal elements (three or more sides).">PolygonSurfaceMesh</a>. Failure to provide those gradients will cause <em>this</em> method to be invoked which will, in turn, throw. </p>

</div>
</div>
<a id="a819bca2023eaa88015e3e51f6e9f557e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a819bca2023eaa88015e3e51f6e9f557e">&#9670;&nbsp;</a></span>centroid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt;T&gt;&amp; centroid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the geometric centroid of this mesh measured and expressed in the mesh's frame M. </p>
<p>(M is the frame in which this mesh's vertices are measured and expressed.) Note that the centroid is not necessarily a point on the surface. If the total mesh area is exactly zero, we define the centroid to be (0,0,0). </p>

</div>
</div>
<a id="a9709fac7886877fc597e4a8117b4e549"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9709fac7886877fc597e4a8117b4e549">&#9670;&nbsp;</a></span>element()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1_surface_polygon.html">SurfacePolygon</a> element </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the polygonal element identified by the given index <code>e</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>e ∈ {0, 1, 2, ..., <a class="el" href="classdrake_1_1geometry_1_1_polygon_surface_mesh.html#a132d1bbcbcc1ac76319da744805bd865" title="Returns the number of polygonal elements in the mesh.">num_faces()</a>-1}. </dd></dl>

</div>
</div>
<a id="a342c3c95a27ab249ff49c4431206b8a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a342c3c95a27ab249ff49c4431206b8a4">&#9670;&nbsp;</a></span>element_centroid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt;T&gt;&amp; element_centroid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the geometric centroid of the element indicated be index <code>e</code>, measured and expressed in the mesh's frame M. </p>
<dl class="section pre"><dt>Precondition</dt><dd>f ∈ {0, 1, 2, ..., <a class="el" href="classdrake_1_1geometry_1_1_polygon_surface_mesh.html#a132d1bbcbcc1ac76319da744805bd865" title="Returns the number of polygonal elements in the mesh.">num_faces()</a>-1}. </dd></dl>

</div>
</div>
<a id="a73802b68cb8f52b2161fe1915928341f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73802b68cb8f52b2161fe1915928341f">&#9670;&nbsp;</a></span>Equal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1_polygon_surface_mesh.html">PolygonSurfaceMesh</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks to see whether the given <a class="el" href="classdrake_1_1geometry_1_1_polygon_surface_mesh.html" title="PolygonSurfaceMesh represents a surface comprised of polygonal elements (three or more sides).">PolygonSurfaceMesh</a> object is equal via deep exact comparison. </p>
<p>NaNs are treated as not equal as per the IEEE standard. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>The mesh for comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the given mesh is equal. </dd></dl>

</div>
</div>
<a id="a88623e38c6b1b2d533a8a480067fee21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88623e38c6b1b2d533a8a480067fee21">&#9670;&nbsp;</a></span>face_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classint.html">int</a>&gt;&amp; face_data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7744f912c3286ddc8f2a755e527c2e23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7744f912c3286ddc8f2a755e527c2e23">&#9670;&nbsp;</a></span>face_normal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt;T&gt;&amp; face_normal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the unit face normal vector of a polygon. </p>
<p>It respects the right-handed normal rule. A near-zero-area triangle may get an unreliable normal vector. A zero-area triangle will get a zero vector. </p><dl class="section pre"><dt>Precondition</dt><dd>f ∈ {0, 1, 2, ..., <a class="el" href="classdrake_1_1geometry_1_1_polygon_surface_mesh.html#a132d1bbcbcc1ac76319da744805bd865" title="Returns the number of polygonal elements in the mesh.">num_faces()</a>-1}. </dd></dl>

</div>
</div>
<a id="a98f8a4ac27c2c8008728ae504e8e68bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98f8a4ac27c2c8008728ae504e8e68bc">&#9670;&nbsp;</a></span>num_elements()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> num_elements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of elements in the mesh. </p>
<p>For PolygonSurfaceMesh, an element is a polygon. Returns the same number as <a class="el" href="classdrake_1_1geometry_1_1_polygon_surface_mesh.html#a132d1bbcbcc1ac76319da744805bd865" title="Returns the number of polygonal elements in the mesh.">num_faces()</a> and enables mesh consumers to be templated on mesh type. </p>

</div>
</div>
<a id="a132d1bbcbcc1ac76319da744805bd865"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a132d1bbcbcc1ac76319da744805bd865">&#9670;&nbsp;</a></span>num_faces()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> num_faces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of polygonal elements in the mesh. </p>

</div>
</div>
<a id="a319e621fc359dd8daad48247f95b12fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a319e621fc359dd8daad48247f95b12fa">&#9670;&nbsp;</a></span>num_vertices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> num_vertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of vertices in the mesh. </p>

</div>
</div>
<a id="a22da11d92003ac4ad72bbd6331287dbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22da11d92003ac4ad72bbd6331287dbe">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1_polygon_surface_mesh.html">PolygonSurfaceMesh</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1geometry_1_1_polygon_surface_mesh.html">PolygonSurfaceMesh</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a13b0cf1ca7ffa5d2e6f7745d7988d37c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13b0cf1ca7ffa5d2e6f7745d7988d37c">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1_polygon_surface_mesh.html">PolygonSurfaceMesh</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1_polygon_surface_mesh.html">PolygonSurfaceMesh</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3c9e33a8f7704980ea0a0f3a4455eaf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c9e33a8f7704980ea0a0f3a4455eaf7">&#9670;&nbsp;</a></span>ReverseFaceWinding()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ReverseFaceWinding </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reverses the ordering of all the faces' indices. </p>

</div>
</div>
<a id="a5d8645defeea4264d39cf1bdf5a66f79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d8645defeea4264d39cf1bdf5a66f79">&#9670;&nbsp;</a></span>total_area()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; total_area </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the total area of all the faces of this surface mesh. </p>

</div>
</div>
<a id="a505ea28f0f6274285a379c870c44bb37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a505ea28f0f6274285a379c870c44bb37">&#9670;&nbsp;</a></span>TransformVertices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TransformVertices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>X_NM</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transforms the vertices of this mesh from its initial frame M to the new frame N. </p>

</div>
</div>
<a id="aa8388a3f4417bdec45042a7fd2166a6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8388a3f4417bdec45042a7fd2166a6a">&#9670;&nbsp;</a></span>vertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt;T&gt;&amp; vertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the vertex identified by the given index <code>v</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>v ∈ {0, 1, 2, ..., <a class="el" href="classdrake_1_1geometry_1_1_polygon_surface_mesh.html#a319e621fc359dd8daad48247f95b12fa" title="Returns the number of vertices in the mesh.">num_vertices()</a>-1}. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a39b0509ce7179535d6b30f11fb305dc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39b0509ce7179535d6b30f11fb305dc6">&#9670;&nbsp;</a></span>kVertexPerElement</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classint.html">int</a> kVertexPerElement = -1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A definition that satisfies the interface that <a class="el" href="classdrake_1_1geometry_1_1_mesh_field_linear.html" title="MeshFieldLinear represents a continuous piecewise-linear scalar field f defined on a (triangular or t...">MeshFieldLinear</a> requires. </p>
<p>The value -1 indicates "unbounded" (as opposed to 3 for <a class="el" href="classdrake_1_1geometry_1_1_triangle_surface_mesh.html" title="TriangleSurfaceMesh represents a union of triangles.">TriangleSurfaceMesh</a> or 4 for <a class="el" href="classdrake_1_1geometry_1_1_volume_mesh.html" title="VolumeMesh represents a tetrahedral volume mesh.">VolumeMesh</a>). It is up to <a class="el" href="classdrake_1_1geometry_1_1_mesh_field_linear.html" title="MeshFieldLinear represents a continuous piecewise-linear scalar field f defined on a (triangular or t...">MeshFieldLinear</a> (and any other MeshType-compatible classes that pair with <a class="el" href="classdrake_1_1geometry_1_1_polygon_surface_mesh.html" title="PolygonSurfaceMesh represents a surface comprised of polygonal elements (three or more sides).">PolygonSurfaceMesh</a>) to decide how they handle this unbounded value. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>drake/geometry/proximity/<a class="el" href="polygon__surface__mesh_8h.html">polygon_surface_mesh.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- footer -->
<div id="nav-path" class="navpath">
  <ul>
    <li class="navelem"><a class="el" href="namespacedrake.html">drake</a></li><li class="navelem"><a class="el" href="namespacedrake_1_1geometry.html">geometry</a></li><li class="navelem"><a class="el" href="classdrake_1_1geometry_1_1_polygon_surface_mesh.html">PolygonSurfaceMesh</a></li>
  </ul>
</div>
</body>
</html>
