<!-- HTML header for doxygen 1.15.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: PolygonSurfaceMesh&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(function() { init_search(); });
</script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@4/tex-chtml.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<header class="site-header">
 <div class="site-header-inner contain">
  <a class="drake-logo" href="/"><img src="/images/drake-logo-white.svg"></a>
  <div class="menu-mobile-toggle">
   <span></span>
  </div>
  <nav class="site-menu">
   <ul>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/">Home</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/installation.html">Installation</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/gallery.html">Gallery</a>
    </li>
    <li class="site-menu-item site-menu-item-main">API Documentation
     <div class="sub">
      <a class="site-menu-item" href="/doxygen_cxx/index.html">C++</a>
      <a class="site-menu-item" href="/pydrake/index.html">Python</a>
     </div>
    </li>
    <li class="site-menu-item site-menu-item-main">Resources
     <div class="sub">
      <a class="site-menu-item" href="/getting_help.html">Getting Help</a>
      <a class="site-menu-item" href="https://deepnote.com/workspace/Drake-0b3b2c53-a7ad-441b-80f8-bf8350752305/project/Tutorials-2b4fc509-aef2-417d-a40d-6071dfed9199/notebook/index-753e3c9d261247ba9f0eb1d7868c18c8">Tutorials</a>
      <a class="site-menu-item" href="/python_bindings.html">Python Bindings</a>
      <a class="site-menu-item" href="/developers.html">For Developers</a>
      <a class="site-menu-item" href="/credits.html">Credits</a>
     </div>
    </li>
    <li class="github-link">
     <a class="site-menu-item" href="https://github.com/RobotLocomotion/drake">GitHub <img src="/third_party/images/GitHub-Mark-Light-64px.png"></a>
    </li>
   </ul>
  </nav>
 </div>
</header>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<div class="title-banner">
 <div class="title-banner__title">
  Drake C++ Documentation
 </div>
 <div id="DDGSearch">
  <form id="search_form_cpp" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search C++ API only…">
   <input type="hidden" name="q" value="site:drake.mit.edu/doxygen_cxx">
  </form>
  <form id="search_form" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search all of Drake…">
   <input type="hidden" name="q" value="site:drake.mit.edu OR site:underactuated.csail.mit.edu OR site:manipulation.csail.mit.edu">
  </form>
 </div>
 <div id="MSearchBoxContainer">
  <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect" class="search-icon" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"><span class="search-icon-dropdown"></span></span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><div id="MSearchCloseImg" class="close-icon"></div></a>
          </span>
        </div>
</td>
 </div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('classdrake_1_1geometry_1_1_polygon_surface_mesh.html','','classdrake_1_1geometry_1_1_polygon_surface_mesh-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">PolygonSurfaceMesh&lt; T &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class T&gt;<br />
class drake::geometry::PolygonSurfaceMesh&lt; T &gt;</div><p>PolygonSurfaceMesh represents a surface comprised of <em>polygonal</em> elements (three or more sides). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The scalar type, which must be one of the <a class="el" href="group__default__scalars.html">default nonsymbolic scalars</a>. </td></tr>
  </table>
  </dd>
</dl>
</div>
<p><code>#include &lt;drake/geometry/proximity/polygon_surface_mesh.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr id="pub-methods-0" class="groupHeader"><td colspan="2"><div class="groupHeader">Implements CopyConstructible, CopyAssignable, MoveConstructible, MoveAssignable</div></td></tr>
<tr class="memitem:aed01f43de73ada1fe1b687e113efe612" id="r_aed01f43de73ada1fe1b687e113efe612"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aed01f43de73ada1fe1b687e113efe612">PolygonSurfaceMesh</a> (const PolygonSurfaceMesh &amp;)=default</td></tr>
<tr class="memitem:a055063927702c7c55f00261dd6452e0c" id="r_a055063927702c7c55f00261dd6452e0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#aed01f43de73ada1fe1b687e113efe612">PolygonSurfaceMesh</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a055063927702c7c55f00261dd6452e0c">operator=</a> (const <a class="el" href="#aed01f43de73ada1fe1b687e113efe612">PolygonSurfaceMesh</a> &amp;)=default</td></tr>
<tr class="memitem:ae370de5092aa6686239bd0840d5acad5" id="r_ae370de5092aa6686239bd0840d5acad5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae370de5092aa6686239bd0840d5acad5">PolygonSurfaceMesh</a> (PolygonSurfaceMesh &amp;&amp;)=default</td></tr>
<tr class="memitem:aab6d2d8b2c74e0052e3706b3d834ff6d" id="r_aab6d2d8b2c74e0052e3706b3d834ff6d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#aed01f43de73ada1fe1b687e113efe612">PolygonSurfaceMesh</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aab6d2d8b2c74e0052e3706b3d834ff6d">operator=</a> (<a class="el" href="#aed01f43de73ada1fe1b687e113efe612">PolygonSurfaceMesh</a> &amp;&amp;)=default</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-member-group" class="groupheader"><a id="member-group" name="member-group"></a>
Mesh type traits</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>A collection of type traits to enable mesh consumers to be templated on mesh type.</p>
<p>Each mesh type provides specific definitions of <em>element</em> and <em>barycentric coordinates</em>. For PolygonSurfaceMesh, an element is a polygon. </p>
</td></tr>
<tr class="memitem:a6aec7d49d25322d8fae54028059d27aa" id="r_a6aec7d49d25322d8fae54028059d27aa"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6aec7d49d25322d8fae54028059d27aa">ScalarType</a> = T</td></tr>
<tr class="memitem:a9ec52d4217b88f37e7a782129bf52372" id="r_a9ec52d4217b88f37e7a782129bf52372"><td class="memTemplParams" colspan="2">template&lt;typename U = T&gt; </td></tr>
<tr class="memitem:a9ec52d4217b88f37e7a782129bf52372 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9ec52d4217b88f37e7a782129bf52372">Barycentric</a> = <a class="el" href="namespacedrake.html#a01ae662d5635b7c9efe03d15d976f7a8">Vector</a>&lt;U, 0&gt;</td></tr>
<tr class="memdesc:a9ec52d4217b88f37e7a782129bf52372"><td class="mdescLeft">&#160;</td><td class="mdescRight">PolygonSurfaceMesh doesn't actually support barycentric coordinates.  <br /></td></tr>
<tr class="memitem:a39b0509ce7179535d6b30f11fb305dc6" id="r_a39b0509ce7179535d6b30f11fb305dc6"><td class="memItemLeft" align="right" valign="top">static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a39b0509ce7179535d6b30f11fb305dc6">kVertexPerElement</a> = -1</td></tr>
<tr class="memdesc:a39b0509ce7179535d6b30f11fb305dc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">A definition that satisfies the interface that <a class="el" href="classdrake_1_1geometry_1_1_mesh_field_linear.html" title="MeshFieldLinear represents a continuous piecewise-linear scalar field f defined on a (triangular or t...">MeshFieldLinear</a> requires.  <br /></td></tr>
<tr class="memitem:ade68f034b5e1bf4d14f0821fb144a22a" id="r_ade68f034b5e1bf4d14f0821fb144a22a"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ade68f034b5e1bf4d14f0821fb144a22a">PolygonSurfaceMeshTest&lt; T &gt;</a></td></tr>
<tr class="memitem:a9709fac7886877fc597e4a8117b4e549" id="r_a9709fac7886877fc597e4a8117b4e549"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1geometry_1_1_surface_polygon.html">SurfacePolygon</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9709fac7886877fc597e4a8117b4e549">element</a> (int e) const</td></tr>
<tr class="memdesc:a9709fac7886877fc597e4a8117b4e549"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the polygonal element identified by the given index <span class="tt">e</span>.  <br /></td></tr>
<tr class="memitem:a9b2499cdcce87e9f015529d89fe61dba" id="r_a9b2499cdcce87e9f015529d89fe61dba"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9b2499cdcce87e9f015529d89fe61dba">vertex</a> (int v) const</td></tr>
<tr class="memdesc:a9b2499cdcce87e9f015529d89fe61dba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the vertex identified by the given index <span class="tt">v</span>.  <br /></td></tr>
<tr class="memitem:a319e621fc359dd8daad48247f95b12fa" id="r_a319e621fc359dd8daad48247f95b12fa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a319e621fc359dd8daad48247f95b12fa">num_vertices</a> () const</td></tr>
<tr class="memdesc:a319e621fc359dd8daad48247f95b12fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of vertices in the mesh.  <br /></td></tr>
<tr class="memitem:a98f8a4ac27c2c8008728ae504e8e68bc" id="r_a98f8a4ac27c2c8008728ae504e8e68bc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a98f8a4ac27c2c8008728ae504e8e68bc">num_elements</a> () const</td></tr>
<tr class="memdesc:a98f8a4ac27c2c8008728ae504e8e68bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in the mesh.  <br /></td></tr>
<tr class="memitem:a486408b1605b8530c7d09dd862b8e570" id="r_a486408b1605b8530c7d09dd862b8e570"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a486408b1605b8530c7d09dd862b8e570">PolygonSurfaceMesh</a> ()</td></tr>
<tr class="memdesc:a486408b1605b8530c7d09dd862b8e570"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advanced() Constructs an <em>empty</em> mesh.  <br /></td></tr>
<tr class="memitem:acbb0142b4362313e73575fb984c8fdf1" id="r_acbb0142b4362313e73575fb984c8fdf1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acbb0142b4362313e73575fb984c8fdf1">PolygonSurfaceMesh</a> (std::vector&lt; int &gt; <a class="el" href="#a54b2908008b4b846a8c9e4f127d55451">face_data</a>, std::vector&lt; <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &gt; vertices)</td></tr>
<tr class="memdesc:acbb0142b4362313e73575fb984c8fdf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a mesh from specified vertex and mesh data.  <br /></td></tr>
<tr class="memitem:a505ea28f0f6274285a379c870c44bb37" id="r_a505ea28f0f6274285a379c870c44bb37"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a505ea28f0f6274285a379c870c44bb37">TransformVertices</a> (const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; T &gt; &amp;X_NM)</td></tr>
<tr class="memdesc:a505ea28f0f6274285a379c870c44bb37"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) Transforms the vertices of this mesh from its initial frame M to the new frame N.  <br /></td></tr>
<tr class="memitem:a3c9e33a8f7704980ea0a0f3a4455eaf7" id="r_a3c9e33a8f7704980ea0a0f3a4455eaf7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3c9e33a8f7704980ea0a0f3a4455eaf7">ReverseFaceWinding</a> ()</td></tr>
<tr class="memdesc:a3c9e33a8f7704980ea0a0f3a4455eaf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) Reverses the ordering of all the faces' indices.  <br /></td></tr>
<tr class="memitem:a132d1bbcbcc1ac76319da744805bd865" id="r_a132d1bbcbcc1ac76319da744805bd865"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a132d1bbcbcc1ac76319da744805bd865">num_faces</a> () const</td></tr>
<tr class="memdesc:a132d1bbcbcc1ac76319da744805bd865"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of polygonal elements in the mesh.  <br /></td></tr>
<tr class="memitem:a4f5f9c758771f00b881783f6627bb769" id="r_a4f5f9c758771f00b881783f6627bb769"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4f5f9c758771f00b881783f6627bb769">area</a> (int f) const</td></tr>
<tr class="memdesc:a4f5f9c758771f00b881783f6627bb769"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns area of a polygonal element.  <br /></td></tr>
<tr class="memitem:a2308d95ee36082f222b032f3abbbf7d6" id="r_a2308d95ee36082f222b032f3abbbf7d6"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2308d95ee36082f222b032f3abbbf7d6">total_area</a> () const</td></tr>
<tr class="memdesc:a2308d95ee36082f222b032f3abbbf7d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total area of all the faces of this surface mesh.  <br /></td></tr>
<tr class="memitem:a64d4bb522a94137b6d42bb4cff6609b7" id="r_a64d4bb522a94137b6d42bb4cff6609b7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a64d4bb522a94137b6d42bb4cff6609b7">face_normal</a> (int f) const</td></tr>
<tr class="memdesc:a64d4bb522a94137b6d42bb4cff6609b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the unit face normal vector of a polygon.  <br /></td></tr>
<tr class="memitem:a337a16f92775c049bf2b7767ddf905dd" id="r_a337a16f92775c049bf2b7767ddf905dd"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a337a16f92775c049bf2b7767ddf905dd">element_centroid</a> (int e) const</td></tr>
<tr class="memdesc:a337a16f92775c049bf2b7767ddf905dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the geometric centroid of the element indicated be index <span class="tt">e</span>, measured and expressed in the mesh's frame M.  <br /></td></tr>
<tr class="memitem:a3c4c114c452d2aecee2b06bc801b5f7c" id="r_a3c4c114c452d2aecee2b06bc801b5f7c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3c4c114c452d2aecee2b06bc801b5f7c">centroid</a> () const</td></tr>
<tr class="memdesc:a3c4c114c452d2aecee2b06bc801b5f7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the geometric centroid of this mesh measured and expressed in the mesh's frame M.  <br /></td></tr>
<tr class="memitem:a9f61bd2b46e590cb45ae9ff7bb520f85" id="r_a9f61bd2b46e590cb45ae9ff7bb520f85"><td class="memTemplParams" colspan="2">template&lt;typename C&gt; </td></tr>
<tr class="memitem:a9f61bd2b46e590cb45ae9ff7bb520f85 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a9ec52d4217b88f37e7a782129bf52372">Barycentric</a>&lt; <a class="el" href="namespacedrake_1_1geometry.html#a74b8d905842571b365085fdd17378772">promoted_numerical_t</a>&lt; T, C &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9f61bd2b46e590cb45ae9ff7bb520f85">CalcBarycentric</a> (const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; C &gt; &amp;p_MQ, int p) const</td></tr>
<tr class="memdesc:a9f61bd2b46e590cb45ae9ff7bb520f85"><td class="mdescLeft">&#160;</td><td class="mdescRight">See TriangleSurfaceMesh::CalcBaryCentric().  <br /></td></tr>
<tr class="memitem:a990e84c8845ff9859cc4897c122c218f" id="r_a990e84c8845ff9859cc4897c122c218f"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt;, <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a990e84c8845ff9859cc4897c122c218f">CalcBoundingBox</a> () const</td></tr>
<tr class="memdesc:a990e84c8845ff9859cc4897c122c218f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the axis-aligned bounding box of this surface mesh M.  <br /></td></tr>
<tr class="memitem:a73802b68cb8f52b2161fe1915928341f" id="r_a73802b68cb8f52b2161fe1915928341f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a73802b68cb8f52b2161fe1915928341f">Equal</a> (const <a class="el" href="#aed01f43de73ada1fe1b687e113efe612">PolygonSurfaceMesh</a>&lt; T &gt; &amp;mesh) const</td></tr>
<tr class="memdesc:a73802b68cb8f52b2161fe1915928341f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see whether the given <a class="el" href="classdrake_1_1geometry_1_1_polygon_surface_mesh.html" title="PolygonSurfaceMesh represents a surface comprised of polygonal elements (three or more sides).">PolygonSurfaceMesh</a> object is equal via deep exact comparison.  <br /></td></tr>
<tr class="memitem:a54b2908008b4b846a8c9e4f127d55451" id="r_a54b2908008b4b846a8c9e4f127d55451"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; int &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a54b2908008b4b846a8c9e4f127d55451">face_data</a> () const</td></tr>
<tr class="memitem:a0b4fef921e399131df9fd6bf3b2dcda3" id="r_a0b4fef921e399131df9fd6bf3b2dcda3"><td class="memTemplParams" colspan="2">template&lt;typename FieldValue&gt; </td></tr>
<tr class="memitem:a0b4fef921e399131df9fd6bf3b2dcda3 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; FieldValue &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0b4fef921e399131df9fd6bf3b2dcda3">CalcGradientVectorOfLinearField</a> (const std::array&lt; FieldValue, 3 &gt; &amp;field_value, int p) const</td></tr>
<tr class="memdesc:a0b4fef921e399131df9fd6bf3b2dcda3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a stub method.  <br /></td></tr>
<tr class="memitem:a82f784452844b14acdc970cf85f7772b" id="r_a82f784452844b14acdc970cf85f7772b"><td class="memTemplParams" colspan="2">template&lt;typename FieldValue&gt; </td></tr>
<tr class="memitem:a82f784452844b14acdc970cf85f7772b template"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; FieldValue &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a82f784452844b14acdc970cf85f7772b">MaybeCalcGradientVectorOfLinearField</a> (const std::array&lt; FieldValue, 3 &gt; &amp;, int) const</td></tr>
<tr class="memdesc:a82f784452844b14acdc970cf85f7772b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like CalcGradientVectorOfLinearField above, this is a stub method, provided for compatibility with <a class="el" href="classdrake_1_1geometry_1_1_mesh_field_linear.html" title="MeshFieldLinear represents a continuous piecewise-linear scalar field f defined on a (triangular or t...">MeshFieldLinear</a>.  <br /></td></tr>
<tr class="memitem:aa2e4721da8dfb51c381f11eba33a48b3" id="r_aa2e4721da8dfb51c381f11eba33a48b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa2e4721da8dfb51c381f11eba33a48b3">SetAllPositions</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; &amp;p_MVs)</td></tr>
<tr class="memdesc:aa2e4721da8dfb51c381f11eba33a48b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the position of all vertices in the mesh.  <br /></td></tr>
</table>
<a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Member Typedef Documentation</h2>
<a id="a9ec52d4217b88f37e7a782129bf52372" name="a9ec52d4217b88f37e7a782129bf52372"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ec52d4217b88f37e7a782129bf52372">&#9670;&#160;</a></span>Barycentric</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;typename U = T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a9ec52d4217b88f37e7a782129bf52372">Barycentric</a> = <a class="el" href="namespacedrake.html#a01ae662d5635b7c9efe03d15d976f7a8">Vector</a>&lt;U, 0&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>PolygonSurfaceMesh doesn't actually support barycentric coordinates. </p>
<p>This is here to satisfy the <a class="el" href="classdrake_1_1geometry_1_1_mesh_field_linear.html" title="MeshFieldLinear represents a continuous piecewise-linear scalar field f defined on a (triangular or t...">MeshFieldLinear</a> interface. The dimension is selected to be zero to minimize memory footprint in case one is inadvertently instantiated. </p>

</div>
</div>
<a id="a6aec7d49d25322d8fae54028059d27aa" name="a6aec7d49d25322d8fae54028059d27aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6aec7d49d25322d8fae54028059d27aa">&#9670;&#160;</a></span>ScalarType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a6aec7d49d25322d8fae54028059d27aa">ScalarType</a> = T</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aed01f43de73ada1fe1b687e113efe612" name="aed01f43de73ada1fe1b687e113efe612"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed01f43de73ada1fe1b687e113efe612">&#9670;&#160;</a></span>PolygonSurfaceMesh() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PolygonSurfaceMesh </td>
          <td>(</td>
          <td class="paramtype">const PolygonSurfaceMesh&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae370de5092aa6686239bd0840d5acad5" name="ae370de5092aa6686239bd0840d5acad5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae370de5092aa6686239bd0840d5acad5">&#9670;&#160;</a></span>PolygonSurfaceMesh() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PolygonSurfaceMesh </td>
          <td>(</td>
          <td class="paramtype">PolygonSurfaceMesh&lt; T &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a486408b1605b8530c7d09dd862b8e570" name="a486408b1605b8530c7d09dd862b8e570"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a486408b1605b8530c7d09dd862b8e570">&#9670;&#160;</a></span>PolygonSurfaceMesh() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">PolygonSurfaceMesh </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Advanced() Constructs an <em>empty</em> mesh. </p>
<p>This enables compatibility with STL container types and facilitates some unit tests. Otherwise, it shouldn't be used. </p>

</div>
</div>
<a id="acbb0142b4362313e73575fb984c8fdf1" name="acbb0142b4362313e73575fb984c8fdf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbb0142b4362313e73575fb984c8fdf1">&#9670;&#160;</a></span>PolygonSurfaceMesh() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">PolygonSurfaceMesh </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt;</td>          <td class="paramname"><span class="paramname"><em>face_data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>vertices</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a mesh from specified vertex and mesh data. </p>
<p>The vertices are simply a vector of position vectors (interpreted as being measured and expressed in the mesh's frame M).</p>
<p>The polygon data is more complex. Syntactically, it is a sequence of integers which <em>encodes</em> P polygons. Each polygon can have an arbitrary number of vertices. The encoding of the P polygons is as follows: </p><pre class="fragment">|c₁|v₁₀|v₁₁|...|cᵢ|cᵢ₀|cᵢ₁|...|cₚ|cₚ₀|cₚ₁|...|
</pre><p>Each polygon is defined in sequence. The definition consists of an integer indicating the <em>number</em> of vertices in that polygon (c₁, cᵢ, and cₘ in the illustration above). The next cᵢ integers in the sequence are zero-based indices into the vector of vertex positions (indicating which vertices the polygon spans). The vertex indices are sorted such that the plane normal found by applying the right-handed rule is used as the face normal.</p>
<p>This implies the following: Polygon one: Located at index i₁ = 0 in <span class="tt"><a class="el" href="#a54b2908008b4b846a8c9e4f127d55451">face_data</a></span>. c₁ = face_data[i₁] is the number of vertices in polygon one. Polygon two: Located at index i₂ = i₁ + c₁ + 1 in <span class="tt"><a class="el" href="#a54b2908008b4b846a8c9e4f127d55451">face_data</a></span>. c₂ = face_data[i₂] is the number of vertices in polygon zero. Polygon j: Located at index iⱼ = iⱼ₋₁ + cⱼ₋₁ + 1 cⱼ = face_data[iⱼ]</p>
<p>The polygons must all be planar and convex.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">face_data</td><td>The sequence of counts and indices which encode the faces of the mesh (see above). </td></tr>
    <tr><td class="paramname">vertices</td><td>The vertex positions, measured and expressed in this mesh's frame. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The indices in <span class="tt"><a class="el" href="#a54b2908008b4b846a8c9e4f127d55451">face_data</a></span> all refer to valid indices into <span class="tt">vertices</span>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If <span class="tt"><a class="el" href="#a54b2908008b4b846a8c9e4f127d55451">face_data</a></span> includes a zero-area polygon, that polygon will have a non-NaN centroid chosen arbitrarily. For hydroelastics, this is acceptable because its zero area will neutralize its contribution to computation of contact wrench. If all polygons have zero area, the mesh's centroid will be chosen arbitrarily as well. </dd></dl>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="a4f5f9c758771f00b881783f6627bb769" name="a4f5f9c758771f00b881783f6627bb769"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f5f9c758771f00b881783f6627bb769">&#9670;&#160;</a></span>area()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; area </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns area of a polygonal element. </p>
<dl class="section pre"><dt>Precondition</dt><dd>f ∈ {0, 1, 2, ..., <a class="el" href="#a132d1bbcbcc1ac76319da744805bd865" title="Returns the number of polygonal elements in the mesh.">num_faces()</a>-1}. </dd></dl>

</div>
</div>
<a id="a9f61bd2b46e590cb45ae9ff7bb520f85" name="a9f61bd2b46e590cb45ae9ff7bb520f85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f61bd2b46e590cb45ae9ff7bb520f85">&#9670;&#160;</a></span>CalcBarycentric()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;typename C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a9ec52d4217b88f37e7a782129bf52372">Barycentric</a>&lt; <a class="el" href="namespacedrake_1_1geometry.html#a74b8d905842571b365085fdd17378772">promoted_numerical_t</a>&lt; T, C &gt; &gt; CalcBarycentric </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; C &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p_MQ</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See TriangleSurfaceMesh::CalcBaryCentric(). </p>
<p>This implementation is provided to maintain compatibility with <a class="el" href="classdrake_1_1geometry_1_1_mesh_field_linear.html" title="MeshFieldLinear represents a continuous piecewise-linear scalar field f defined on a (triangular or t...">MeshFieldLinear</a>. However, it only throws. PolygonSurfaceMesh does not support barycentric coordinates. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">C</td><td>must be either <span class="tt">double</span> or <span class="tt"><a class="el" href="namespacedrake.html#a3d6302a0051e9403c9df3ed6808f3854" title="A scalar type that performs automatic differentiation.">AutoDiffXd</a></span>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a990e84c8845ff9859cc4897c122c218f" name="a990e84c8845ff9859cc4897c122c218f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a990e84c8845ff9859cc4897c122c218f">&#9670;&#160;</a></span>CalcBoundingBox()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt;, <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &gt; CalcBoundingBox </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the axis-aligned bounding box of this surface mesh M. </p>
<dl class="section return"><dt>Returns</dt><dd>the center and the size vector of the box expressed in M's frame. </dd></dl>

</div>
</div>
<a id="a0b4fef921e399131df9fd6bf3b2dcda3" name="a0b4fef921e399131df9fd6bf3b2dcda3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b4fef921e399131df9fd6bf3b2dcda3">&#9670;&#160;</a></span>CalcGradientVectorOfLinearField()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;typename FieldValue&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; FieldValue &gt; CalcGradientVectorOfLinearField </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; FieldValue, 3 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>field_value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a stub method. </p>
<p>It is provided so that <a class="el" href="classdrake_1_1geometry_1_1_polygon_surface_mesh.html" title="PolygonSurfaceMesh represents a surface comprised of polygonal elements (three or more sides).">PolygonSurfaceMesh</a> provides a sufficient API to compile against <a class="el" href="classdrake_1_1geometry_1_1_mesh_field_linear.html" title="MeshFieldLinear represents a continuous piecewise-linear scalar field f defined on a (triangular or t...">MeshFieldLinear</a>. However, we expect that the gradients of the field will always be provided when defining a <a class="el" href="classdrake_1_1geometry_1_1_mesh_field_linear.html" title="MeshFieldLinear represents a continuous piecewise-linear scalar field f defined on a (triangular or t...">MeshFieldLinear</a> with a <a class="el" href="classdrake_1_1geometry_1_1_polygon_surface_mesh.html" title="PolygonSurfaceMesh represents a surface comprised of polygonal elements (three or more sides).">PolygonSurfaceMesh</a>. Failure to provide those gradients will cause <em>this</em> method to be invoked which will, in turn, throw. </p>

</div>
</div>
<a id="a3c4c114c452d2aecee2b06bc801b5f7c" name="a3c4c114c452d2aecee2b06bc801b5f7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c4c114c452d2aecee2b06bc801b5f7c">&#9670;&#160;</a></span>centroid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp; centroid </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the geometric centroid of this mesh measured and expressed in the mesh's frame M. </p>
<p>(M is the frame in which this mesh's vertices are measured and expressed.) Note that the centroid is not necessarily a point on the surface. If the total mesh area is exactly zero, we define the centroid to be (0,0,0). </p>

</div>
</div>
<a id="a9709fac7886877fc597e4a8117b4e549" name="a9709fac7886877fc597e4a8117b4e549"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9709fac7886877fc597e4a8117b4e549">&#9670;&#160;</a></span>element()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1_surface_polygon.html">SurfacePolygon</a> element </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the polygonal element identified by the given index <span class="tt">e</span>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>e ∈ {0, 1, 2, ..., <a class="el" href="#a132d1bbcbcc1ac76319da744805bd865" title="Returns the number of polygonal elements in the mesh.">num_faces()</a>-1}. </dd></dl>

</div>
</div>
<a id="a337a16f92775c049bf2b7767ddf905dd" name="a337a16f92775c049bf2b7767ddf905dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a337a16f92775c049bf2b7767ddf905dd">&#9670;&#160;</a></span>element_centroid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp; element_centroid </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the geometric centroid of the element indicated be index <span class="tt">e</span>, measured and expressed in the mesh's frame M. </p>
<dl class="section pre"><dt>Precondition</dt><dd>f ∈ {0, 1, 2, ..., <a class="el" href="#a132d1bbcbcc1ac76319da744805bd865" title="Returns the number of polygonal elements in the mesh.">num_faces()</a>-1}. </dd></dl>

</div>
</div>
<a id="a73802b68cb8f52b2161fe1915928341f" name="a73802b68cb8f52b2161fe1915928341f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73802b68cb8f52b2161fe1915928341f">&#9670;&#160;</a></span>Equal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#aed01f43de73ada1fe1b687e113efe612">PolygonSurfaceMesh</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>mesh</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks to see whether the given <a class="el" href="classdrake_1_1geometry_1_1_polygon_surface_mesh.html" title="PolygonSurfaceMesh represents a surface comprised of polygonal elements (three or more sides).">PolygonSurfaceMesh</a> object is equal via deep exact comparison. </p>
<p>NaNs are treated as not equal as per the IEEE standard. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>The mesh for comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><span class="tt">true</span> if the given mesh is equal. </dd></dl>

</div>
</div>
<a id="a54b2908008b4b846a8c9e4f127d55451" name="a54b2908008b4b846a8c9e4f127d55451"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54b2908008b4b846a8c9e4f127d55451">&#9670;&#160;</a></span>face_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; int &gt; &amp; face_data </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a64d4bb522a94137b6d42bb4cff6609b7" name="a64d4bb522a94137b6d42bb4cff6609b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64d4bb522a94137b6d42bb4cff6609b7">&#9670;&#160;</a></span>face_normal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp; face_normal </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the unit face normal vector of a polygon. </p>
<p>It respects the right-handed normal rule. A near-zero-area triangle may get an unreliable normal vector. A zero-area triangle will get a zero vector. </p><dl class="section pre"><dt>Precondition</dt><dd>f ∈ {0, 1, 2, ..., <a class="el" href="#a132d1bbcbcc1ac76319da744805bd865" title="Returns the number of polygonal elements in the mesh.">num_faces()</a>-1}. </dd></dl>

</div>
</div>
<a id="a82f784452844b14acdc970cf85f7772b" name="a82f784452844b14acdc970cf85f7772b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82f784452844b14acdc970cf85f7772b">&#9670;&#160;</a></span>MaybeCalcGradientVectorOfLinearField()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;typename FieldValue&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; FieldValue &gt; &gt; MaybeCalcGradientVectorOfLinearField </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; FieldValue, 3 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like CalcGradientVectorOfLinearField above, this is a stub method, provided for compatibility with <a class="el" href="classdrake_1_1geometry_1_1_mesh_field_linear.html" title="MeshFieldLinear represents a continuous piecewise-linear scalar field f defined on a (triangular or t...">MeshFieldLinear</a>. </p>
<p>The empty return value here will cause the caller to report errors. </p>

</div>
</div>
<a id="a98f8a4ac27c2c8008728ae504e8e68bc" name="a98f8a4ac27c2c8008728ae504e8e68bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98f8a4ac27c2c8008728ae504e8e68bc">&#9670;&#160;</a></span>num_elements()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int num_elements </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of elements in the mesh. </p>
<p>For PolygonSurfaceMesh, an element is a polygon. Returns the same number as <a class="el" href="#a132d1bbcbcc1ac76319da744805bd865" title="Returns the number of polygonal elements in the mesh.">num_faces()</a> and enables mesh consumers to be templated on mesh type. </p>

</div>
</div>
<a id="a132d1bbcbcc1ac76319da744805bd865" name="a132d1bbcbcc1ac76319da744805bd865"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a132d1bbcbcc1ac76319da744805bd865">&#9670;&#160;</a></span>num_faces()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int num_faces </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of polygonal elements in the mesh. </p>

</div>
</div>
<a id="a319e621fc359dd8daad48247f95b12fa" name="a319e621fc359dd8daad48247f95b12fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a319e621fc359dd8daad48247f95b12fa">&#9670;&#160;</a></span>num_vertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int num_vertices </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of vertices in the mesh. </p>

</div>
</div>
<a id="a055063927702c7c55f00261dd6452e0c" name="a055063927702c7c55f00261dd6452e0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a055063927702c7c55f00261dd6452e0c">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#aed01f43de73ada1fe1b687e113efe612">PolygonSurfaceMesh</a> &amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#aed01f43de73ada1fe1b687e113efe612">PolygonSurfaceMesh</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aab6d2d8b2c74e0052e3706b3d834ff6d" name="aab6d2d8b2c74e0052e3706b3d834ff6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab6d2d8b2c74e0052e3706b3d834ff6d">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#aed01f43de73ada1fe1b687e113efe612">PolygonSurfaceMesh</a> &amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#aed01f43de73ada1fe1b687e113efe612">PolygonSurfaceMesh</a>&lt; T &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3c9e33a8f7704980ea0a0f3a4455eaf7" name="a3c9e33a8f7704980ea0a0f3a4455eaf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c9e33a8f7704980ea0a0f3a4455eaf7">&#9670;&#160;</a></span>ReverseFaceWinding()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ReverseFaceWinding </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Internal use only) Reverses the ordering of all the faces' indices. </p>

</div>
</div>
<a id="aa2e4721da8dfb51c381f11eba33a48b3" name="aa2e4721da8dfb51c381f11eba33a48b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2e4721da8dfb51c381f11eba33a48b3">&#9670;&#160;</a></span>SetAllPositions()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SetAllPositions </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p_MVs</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the position of all vertices in the mesh. </p>
<p>Each sequential triple in p_MVs (e.g., 3i, 3i + 1, 3i + 2), i ∈ ℤ, is interpreted as a position vector associated with the iᵗʰ vertex. The position values are interpreted to be measured and expressed in the same frame as the mesh to be deformed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_MVs</td><td>Vertex positions for the mesh's N vertices flattened into a vector (where each position vector is measured and expressed in the mesh's original frame). </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if p_MVs.size() != 3 * <a class="el" href="#a319e621fc359dd8daad48247f95b12fa" title="Returns the number of vertices in the mesh.">num_vertices()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2308d95ee36082f222b032f3abbbf7d6" name="a2308d95ee36082f222b032f3abbbf7d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2308d95ee36082f222b032f3abbbf7d6">&#9670;&#160;</a></span>total_area()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; total_area </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the total area of all the faces of this surface mesh. </p>

</div>
</div>
<a id="a505ea28f0f6274285a379c870c44bb37" name="a505ea28f0f6274285a379c870c44bb37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a505ea28f0f6274285a379c870c44bb37">&#9670;&#160;</a></span>TransformVertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TransformVertices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>X_NM</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Internal use only) Transforms the vertices of this mesh from its initial frame M to the new frame N. </p>

</div>
</div>
<a id="a9b2499cdcce87e9f015529d89fe61dba" name="a9b2499cdcce87e9f015529d89fe61dba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b2499cdcce87e9f015529d89fe61dba">&#9670;&#160;</a></span>vertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp; vertex </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the vertex identified by the given index <span class="tt">v</span>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>v ∈ {0, 1, 2, ..., <a class="el" href="#a319e621fc359dd8daad48247f95b12fa" title="Returns the number of vertices in the mesh.">num_vertices()</a>-1}. </dd></dl>

</div>
</div>
<a name="doc-related-members" id="doc-related-members"></a><h2 id="header-doc-related-members" class="groupheader">Friends And Related Symbol Documentation</h2>
<a id="ade68f034b5e1bf4d14f0821fb144a22a" name="ade68f034b5e1bf4d14f0821fb144a22a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade68f034b5e1bf4d14f0821fb144a22a">&#9670;&#160;</a></span>PolygonSurfaceMeshTest&lt; T &gt;</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classdrake_1_1geometry_1_1_polygon_surface_mesh_test.html">PolygonSurfaceMeshTest</a>&lt; T &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel friend">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a name="doc-variable-members" id="doc-variable-members"></a><h2 id="header-doc-variable-members" class="groupheader">Member Data Documentation</h2>
<a id="a39b0509ce7179535d6b30f11fb305dc6" name="a39b0509ce7179535d6b30f11fb305dc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39b0509ce7179535d6b30f11fb305dc6">&#9670;&#160;</a></span>kVertexPerElement</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int kVertexPerElement = -1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A definition that satisfies the interface that <a class="el" href="classdrake_1_1geometry_1_1_mesh_field_linear.html" title="MeshFieldLinear represents a continuous piecewise-linear scalar field f defined on a (triangular or t...">MeshFieldLinear</a> requires. </p>
<p>The value -1 indicates "unbounded" (as opposed to 3 for <a class="el" href="classdrake_1_1geometry_1_1_triangle_surface_mesh.html" title="TriangleSurfaceMesh represents a union of triangles.">TriangleSurfaceMesh</a> or 4 for <a class="el" href="classdrake_1_1geometry_1_1_volume_mesh.html" title="VolumeMesh represents a tetrahedral volume mesh.">VolumeMesh</a>). It is up to <a class="el" href="classdrake_1_1geometry_1_1_mesh_field_linear.html" title="MeshFieldLinear represents a continuous piecewise-linear scalar field f defined on a (triangular or t...">MeshFieldLinear</a> (and any other MeshType-compatible classes that pair with <a class="el" href="classdrake_1_1geometry_1_1_polygon_surface_mesh.html" title="PolygonSurfaceMesh represents a surface comprised of polygonal elements (three or more sides).">PolygonSurfaceMesh</a>) to decide how they handle this unbounded value. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>drake/geometry/proximity/<a class="el" href="polygon__surface__mesh_8h.html">polygon_surface_mesh.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- footer -->
<div class="navpath">
  <ul>
    <li class="navelem"><a href="namespacedrake.html">drake</a></li><li class="navelem"><a href="namespacedrake_1_1geometry.html">geometry</a></li><li class="navelem"><a href="classdrake_1_1geometry_1_1_polygon_surface_mesh.html">PolygonSurfaceMesh</a></li>
  </ul>
</div>
<footer id="nav-path", class="site-footer padding">
  <div class="contain">
    <a href="/" class="drake-logo">
      <img src="/images/drake-logo.svg"/>
    </a>
    <div class="footer-menu">
      <ul>
        <li>
          <a href="https://accessibility.mit.edu/" class="site-menu-item">Accessibility</a>
        </li>
        <li>
          <a href="/doxygen_cxx/index.html" class="site-menu-item">C++</a>
        </li>
        <li>
          <a href="/pydrake/index.html" class="site-menu-item">Python</a>
        </li>
        <li class="github-link">
          <a href="https://github.com/RobotLocomotion/drake" class="site-menu-item">GitHub <img src="/third_party/images/GitHub-Mark-64px.png"/></a>
        </li>
      </ul>
    </div>
  </div>
</footer>
<script type="text/javascript">
searchBox.searchLabel = 'Go to name…';
searchBox.DOMSearchField().placeholder = searchBox.searchLabel;
searchBox.DOMSearchField().value = '';
</script>
</body>
</html>
