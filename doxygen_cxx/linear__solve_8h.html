<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: drake/math/linear_solve.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('linear__solve_8h.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<div class="title">linear_solve.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="drake__deprecated_8h.html">drake/common/drake_deprecated.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="symbolic_8h.html">drake/common/symbolic.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="math_2autodiff_8h.html">drake/math/autodiff.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="autodiff__gradient_8h.html">drake/math/autodiff_gradient.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for linear_solve.h:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="linear__solve_8h__incl.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacedrake"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake.html">drake</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedrake_1_1math"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html">drake::math</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">solve linear system of equations with a given solver.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="linear_solve_given_solver"></a> Solve linear system of equations A * x = b. Where A is an Eigen matrix of double/AutoDiffScalar/symbolic::Expression, and b is an Eigen matrix of double/AutoDiffScalar/symbolic::Expression. Notice that if either A or b contains symbolic::Expression, then the other has to contain symbolic::Expression. This 3-argument version allows the user to re-use <code>linear_solver</code> when <code>b</code> changes or the gradient of <code>A</code> changes. When either A or b contains AutoDiffScalar, we use implicit function theorem to find the gradient in x as ∂x/∂zᵢ = A⁻¹(∂b/∂zᵢ - ∂A/∂zᵢ * x) where z is the variable we take gradient with.</p>
<dl class="section note"><dt>Note</dt><dd>When both A and b are Eigen matrix of double, this function is almost as fast as calling linear_solver.solve(b) directly. When either A or b contains AutoDiffScalar, this function is a lot faster than first instantiating the linear solver of AutoDiffScalar, and then solving the equation with this autodiffable linear solver. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LinearSolver</td><td>The type of linear solver, for example Eigen::LLT&lt;Eigen::Matrix2d&gt; </td></tr>
    <tr><td class="paramname">DerivedA</td><td>An Eigen Matrix. </td></tr>
    <tr><td class="paramname">DerivedB</td><td>An Eigen Vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">linear_solver</td><td>The linear solver constructed with the double-version of A. </td></tr>
    <tr><td class="paramname">A</td><td>The matrix A. </td></tr>
    <tr><td class="paramname">b</td><td>The vector b.</td></tr>
  </table>
  </dd>
</dl>
<p>Here is an example code. </p><div class="fragment"><div class="line">Eigen::Matrix&lt;AutoDiffd&lt;3&gt;, 2, 2&gt; A_ad;</div><div class="line"><span class="comment">// Set the value and gradient in A_ad with arbitrary values;</span></div><div class="line">Eigen::Matrix2d A_val;</div><div class="line">A_val &lt;&lt; 1, 2, 3, 4;</div><div class="line"><span class="comment">// Gradient of A.col(0).</span></div><div class="line">Eigen::Matrix&lt;double, 2, 3&gt; A0_gradient;</div><div class="line">A0_gradient &lt;&lt; 1, 2, 3, 4, 5, 6;</div><div class="line">A_ad.col(0) = <a class="code" href="namespacedrake_1_1math.html#a36e2a9bc07853150c96614244960dc23">initializeAutoDiffGivenGradientMatrix</a>(</div><div class="line">    A_val.col(0), A0_gradient);</div><div class="line"><span class="comment">// Gradient of A.col(1)</span></div><div class="line">Eigen::Matrix&lt;double, 2, 3&gt; A1_gradient;</div><div class="line">A1_gradient &lt;&lt; 7, 8, 9, 10, 11, 12;</div><div class="line">A_ad.col(1) = <a class="code" href="namespacedrake_1_1math.html#a36e2a9bc07853150c96614244960dc23">initializeAutoDiffGivenGradientMatrix</a>(</div><div class="line">    A_val.col(1), A1_gradient);</div><div class="line"><span class="comment">// Set the value and gradient of b to arbitrary value.</span></div><div class="line"><span class="keyword">const</span> <a class="code" href="namespacedrake_1_1systems_1_1analysis_1_1test.html#a322dbcada3667894a629fe3f1a476f2a">Eigen::Vector2d</a> b_val(2, 3);</div><div class="line">Eigen::Matrix&lt;double, 2, 3&gt; b_gradient;</div><div class="line">b_gradient &lt;&lt; 1, 3, 5, 7, 9, 11;</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> b_ad = <a class="code" href="namespacedrake_1_1math.html#a36e2a9bc07853150c96614244960dc23">initializeAutoDiffGivenGradientMatrix</a>(b_val, b_gradient);</div><div class="line"><span class="comment">// Solve the linear system A_val * x_val = b_val.</span></div><div class="line">Eigen::PartialPivLU&lt;Eigen::Matrix2d&gt; linear_solver(A_val);</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> x_val = <a class="code" href="namespacedrake_1_1math.html#a058825f71b44c44e61dd90c3b89ec87d">SolveLinearSystem</a>(linear_solver, A_val, b_val);</div><div class="line"><span class="comment">// Solve the linear system A*x=b, together with the gradient.</span></div><div class="line"><span class="comment">// x_ad contains both the value of the solution A*x=b, together with its</span></div><div class="line"><span class="comment">// gradient.</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> x_ad = <a class="code" href="namespacedrake_1_1math.html#a058825f71b44c44e61dd90c3b89ec87d">SolveLinearSystem</a>(linear_solver, A_ad, b_ad);</div></div><!-- fragment --> </div></td></tr>
<tr class="memitem:a058825f71b44c44e61dd90c3b89ec87d"><td class="memTemplParams" colspan="2">template&lt;typename LinearSolver , typename DerivedA , typename DerivedB &gt; </td></tr>
<tr class="memitem:a058825f71b44c44e61dd90c3b89ec87d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; internal::is_double_or_symbolic_v&lt; typename DerivedA::Scalar &gt; &amp;&amp;internal::is_double_or_symbolic_v&lt; typename DerivedB::Scalar &gt; &amp;&amp;std::is_same_v&lt; typename DerivedA::Scalar, typename DerivedB::Scalar &gt;, Eigen::Matrix&lt; typename DerivedA::Scalar, DerivedA::RowsAtCompileTime, DerivedB::ColsAtCompileTime &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a058825f71b44c44e61dd90c3b89ec87d">SolveLinearSystem</a> (const LinearSolver &amp;linear_solver, const Eigen::MatrixBase&lt; DerivedA &gt; &amp;A, const Eigen::MatrixBase&lt; DerivedB &gt; &amp;b)</td></tr>
<tr class="memdesc:a058825f71b44c44e61dd90c3b89ec87d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized when A and b are both double or <a class="el" href="classdrake_1_1symbolic_1_1_expression.html" title="Represents a symbolic form of an expression.">symbolic::Expression</a> matrices.  <a href="namespacedrake_1_1math.html#a058825f71b44c44e61dd90c3b89ec87d">More...</a><br /></td></tr>
<tr class="separator:a058825f71b44c44e61dd90c3b89ec87d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12cd1e9dec4704f09c44c240f5b95346"><td class="memTemplParams" colspan="2">template&lt;typename LinearSolver , typename DerivedA , typename DerivedB &gt; </td></tr>
<tr class="memitem:a12cd1e9dec4704f09c44c240f5b95346"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; internal::is_double_or_symbolic_v&lt; typename DerivedA::Scalar &gt; &amp;&amp;internal::is_double_or_symbolic_v&lt; typename DerivedB::Scalar &gt; &amp;&amp;std::is_same_v&lt; typename DerivedA::Scalar, typename DerivedB::Scalar &gt;, Eigen::Matrix&lt; typename DerivedA::Scalar, DerivedA::RowsAtCompileTime, DerivedB::ColsAtCompileTime &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a12cd1e9dec4704f09c44c240f5b95346">LinearSolve</a> (const LinearSolver &amp;linear_solver, const Eigen::MatrixBase&lt; DerivedA &gt; &amp;A, const Eigen::MatrixBase&lt; DerivedB &gt; &amp;b)</td></tr>
<tr class="memdesc:a12cd1e9dec4704f09c44c240f5b95346"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Deprecated.)  <a href="namespacedrake_1_1math.html#a12cd1e9dec4704f09c44c240f5b95346">More...</a><br /></td></tr>
<tr class="separator:a12cd1e9dec4704f09c44c240f5b95346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5b45142d674480f5196638f903867f9"><td class="memTemplParams" colspan="2">template&lt;typename LinearSolver , typename DerivedA , typename DerivedB &gt; </td></tr>
<tr class="memitem:ae5b45142d674480f5196638f903867f9"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same_v&lt; typename DerivedA::Scalar, double &gt; &amp;&amp;!internal::is_double_or_symbolic_v&lt; typename DerivedB::Scalar &gt;, Eigen::Matrix&lt; typename DerivedB::Scalar, DerivedA::RowsAtCompileTime, DerivedB::ColsAtCompileTime &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#ae5b45142d674480f5196638f903867f9">SolveLinearSystem</a> (const LinearSolver &amp;linear_solver, const Eigen::MatrixBase&lt; DerivedA &gt; &amp;A, const Eigen::MatrixBase&lt; DerivedB &gt; &amp;b)</td></tr>
<tr class="memdesc:ae5b45142d674480f5196638f903867f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized when A is a double-valued matrix and b is an AutoDiffScalar-valued matrix .See <a class="el" href="namespacedrake_1_1math.html#linear_solve_given_solver">linear_solve_given_solver</a> for more details.  <a href="namespacedrake_1_1math.html#ae5b45142d674480f5196638f903867f9">More...</a><br /></td></tr>
<tr class="separator:ae5b45142d674480f5196638f903867f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a629a74f63be2d7e37543dc705db83df7"><td class="memTemplParams" colspan="2">template&lt;typename LinearSolver , typename DerivedA , typename DerivedB &gt; </td></tr>
<tr class="memitem:a629a74f63be2d7e37543dc705db83df7"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same_v&lt; typename DerivedA::Scalar, double &gt; &amp;&amp;!internal::is_double_or_symbolic_v&lt; typename DerivedB::Scalar &gt;, Eigen::Matrix&lt; typename DerivedB::Scalar, DerivedA::RowsAtCompileTime, DerivedB::ColsAtCompileTime &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a629a74f63be2d7e37543dc705db83df7">LinearSolve</a> (const LinearSolver &amp;linear_solver, const Eigen::MatrixBase&lt; DerivedA &gt; &amp;A, const Eigen::MatrixBase&lt; DerivedB &gt; &amp;b)</td></tr>
<tr class="memdesc:a629a74f63be2d7e37543dc705db83df7"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Deprecated.)  <a href="namespacedrake_1_1math.html#a629a74f63be2d7e37543dc705db83df7">More...</a><br /></td></tr>
<tr class="separator:a629a74f63be2d7e37543dc705db83df7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a330a49d70f7a590760819c4f228425f6"><td class="memTemplParams" colspan="2">template&lt;typename LinearSolver , typename DerivedA , typename DerivedB &gt; </td></tr>
<tr class="memitem:a330a49d70f7a590760819c4f228425f6"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; !internal::is_double_or_symbolic_v&lt; typename DerivedA::Scalar &gt;, Eigen::Matrix&lt; typename DerivedA::Scalar, DerivedA::RowsAtCompileTime, DerivedB::ColsAtCompileTime &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a330a49d70f7a590760819c4f228425f6">SolveLinearSystem</a> (const LinearSolver &amp;linear_solver, const Eigen::MatrixBase&lt; DerivedA &gt; &amp;A, const Eigen::MatrixBase&lt; DerivedB &gt; &amp;b)</td></tr>
<tr class="memdesc:a330a49d70f7a590760819c4f228425f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized when A is an AutoDiffScalar-valued matrix, and b can contain either AutoDiffScalar or double.  <a href="namespacedrake_1_1math.html#a330a49d70f7a590760819c4f228425f6">More...</a><br /></td></tr>
<tr class="separator:a330a49d70f7a590760819c4f228425f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acff2e71eedf1bd76dc28d9f30b04cace"><td class="memTemplParams" colspan="2">template&lt;typename LinearSolver , typename DerivedA , typename DerivedB &gt; </td></tr>
<tr class="memitem:acff2e71eedf1bd76dc28d9f30b04cace"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; !internal::is_double_or_symbolic_v&lt; typename DerivedA::Scalar &gt;, Eigen::Matrix&lt; typename DerivedA::Scalar, DerivedA::RowsAtCompileTime, DerivedB::ColsAtCompileTime &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#acff2e71eedf1bd76dc28d9f30b04cace">LinearSolve</a> (const LinearSolver &amp;linear_solver, const Eigen::MatrixBase&lt; DerivedA &gt; &amp;A, const Eigen::MatrixBase&lt; DerivedB &gt; &amp;b)</td></tr>
<tr class="memdesc:acff2e71eedf1bd76dc28d9f30b04cace"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Deprecated.)  <a href="namespacedrake_1_1math.html#acff2e71eedf1bd76dc28d9f30b04cace">More...</a><br /></td></tr>
<tr class="separator:acff2e71eedf1bd76dc28d9f30b04cace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">solve linear system of equations</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="linear_solve"></a> Solve linear system of equations A * x = b. Where A is an Eigen matrix of double/AutoDiffScalar/symbolic::Expression, and b is an Eigen matrix of double/AutoDiffScalar/symbolic::Expression. Note that when either A or b contains symbolic::Expression, the other has to contain symbolic::Expression as well. When either A or b contains AutoDiffScalar, we use implicit function theorem to find the gradient in x as ∂x/∂zᵢ = A⁻¹(∂b/∂zᵢ - ∂A/∂zᵢ * x) where z is the variable we take gradient with.</p>
<p>The following table indicate the scalar type of x with A/b containing the specified scalar type. The entries with NA are not supported.</p>
<p>| ＼A | | | | </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">b ＼  </th><th class="markdownTableHeadNone">double  </th><th class="markdownTableHeadNone">ADS  </th><th class="markdownTableHeadNone">Expr   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">double  </td><td class="markdownTableBodyNone">double  </td><td class="markdownTableBodyNone">ADS  </td><td class="markdownTableBodyNone">NA   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">ADS  </td><td class="markdownTableBodyNone">ADS  </td><td class="markdownTableBodyNone">ADS  </td><td class="markdownTableBodyNone">NA   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Expr  </td><td class="markdownTableBodyNone">NA  </td><td class="markdownTableBodyNone">NA  </td><td class="markdownTableBodyNone">Expr   </td></tr>
</table>
<p>where ADS stands for Eigen::AutoDiffScalar, and Expr stands for symbolic::Expression.</p>
<p>TODO(hongkai.dai): support one of A/b being a double matrix and the other being a symbolic::Expression matrix.</p>
<dl class="section note"><dt>Note</dt><dd>When both A and b are Eigen matrix of double, this function is almost as fast as calling linear_solver.solve(b) directly; when either A or b contains AutoDiffScalar, this function is a lot faster than first instantiating the linear solver of AutoDiffScalar, and then solving the equation with this autodiffable linear solver. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LinearSolverType</td><td>The type of linear solver, for example Eigen::LLT. Notice that this is just specifies the solver type (such as Eigen::LLT), not the matrix type (like Eigen::LLT&lt;Eigen::Matrix2d&gt;). All Eigen solvers we care about are templated on the matrix type. Some are further templated on configuration ints. The int... will acount for zero or more of these ints, providing a common interface for both types of solvers. </td></tr>
    <tr><td class="paramname">DerivedA</td><td>An Eigen Matrix. </td></tr>
    <tr><td class="paramname">DerivedB</td><td>An Eigen Vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The matrix A. </td></tr>
    <tr><td class="paramname">b</td><td>The vector b.</td></tr>
  </table>
  </dd>
</dl>
<p>Here is an example code. </p><div class="fragment"><div class="line">Eigen::Matrix&lt;AutoDiffd&lt;3&gt;, 2, 2&gt; A_ad;</div><div class="line"><span class="comment">// Set the value and gradient in A_ad with arbitrary values;</span></div><div class="line">Eigen::Matrix2d A_val;</div><div class="line">A_val &lt;&lt; 1, 2, 3, 4;</div><div class="line"><span class="comment">// Gradient of A.col(0).</span></div><div class="line">Eigen::Matrix&lt;double, 2, 3&gt; A0_gradient;</div><div class="line">A0_gradient &lt;&lt; 1, 2, 3, 4, 5, 6;</div><div class="line">A_ad.col(0) = <a class="code" href="namespacedrake_1_1math.html#a36e2a9bc07853150c96614244960dc23">initializeAutoDiffGivenGradientMatrix</a>(</div><div class="line">    A_val.col(0), A0_gradient);</div><div class="line"><span class="comment">// Gradient of A.col(1)</span></div><div class="line">Eigen::Matrix&lt;double, 2, 3&gt; A1_gradient;</div><div class="line">A1_gradient &lt;&lt; 7, 8, 9, 10, 11, 12;</div><div class="line">A_ad.col(1) = <a class="code" href="namespacedrake_1_1math.html#a36e2a9bc07853150c96614244960dc23">initializeAutoDiffGivenGradientMatrix</a>(</div><div class="line">    A_val.col(1), A1_gradient);</div><div class="line"><span class="comment">// Set the value and gradient of b to arbitrary value.</span></div><div class="line"><span class="keyword">const</span> <a class="code" href="namespacedrake_1_1systems_1_1analysis_1_1test.html#a322dbcada3667894a629fe3f1a476f2a">Eigen::Vector2d</a> b_val(2, 3);</div><div class="line">Eigen::Matrix&lt;double, 2, 3&gt; b_gradient;</div><div class="line">b_gradient &lt;&lt; 1, 3, 5, 7, 9, 11;</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> b_ad = <a class="code" href="namespacedrake_1_1math.html#a36e2a9bc07853150c96614244960dc23">initializeAutoDiffGivenGradientMatrix</a>(b_val, b_gradient);</div><div class="line"><span class="comment">// Solve the linear system A*x=b without the gradient.</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> x_val = SolveLinearSystem&lt;Eigen::PartialPivLU&gt;(A_val, b_val);</div><div class="line"><span class="comment">// Solve the linear system A*x=b, together with the gradient.</span></div><div class="line"><span class="comment">// x_ad contains both the value of the solution A*x=b, together with its</span></div><div class="line"><span class="comment">// gradient.</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> x_ad = SolveLinearSystem&lt;Eigen::PartialPivLU&gt;(A_ad, b_ad);</div></div><!-- fragment --> </div></td></tr>
<tr class="memitem:ac8229b4b5fa06b098639dbf00e82fc78"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename, int... &gt; typename LinearSolverType, typename DerivedA , typename DerivedB &gt; </td></tr>
<tr class="memitem:ac8229b4b5fa06b098639dbf00e82fc78"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; internal::is_double_or_symbolic_v&lt; typename DerivedA::Scalar &gt; &amp;&amp;internal::is_double_or_symbolic_v&lt; typename DerivedB::Scalar &gt; &amp;&amp;std::is_same_v&lt; typename DerivedA::Scalar, typename DerivedB::Scalar &gt;, Eigen::Matrix&lt; typename DerivedA::Scalar, DerivedA::RowsAtCompileTime, DerivedB::ColsAtCompileTime &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#ac8229b4b5fa06b098639dbf00e82fc78">SolveLinearSystem</a> (const Eigen::MatrixBase&lt; DerivedA &gt; &amp;A, const Eigen::MatrixBase&lt; DerivedB &gt; &amp;b)</td></tr>
<tr class="memdesc:ac8229b4b5fa06b098639dbf00e82fc78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specialization for both A and b being double-valued matrices.  <a href="namespacedrake_1_1math.html#ac8229b4b5fa06b098639dbf00e82fc78">More...</a><br /></td></tr>
<tr class="separator:ac8229b4b5fa06b098639dbf00e82fc78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86c6f5510dba4ed848869421642a507b"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename, int... &gt; typename LinearSolverType, typename DerivedA , typename DerivedB &gt; </td></tr>
<tr class="memitem:a86c6f5510dba4ed848869421642a507b"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; internal::is_double_or_symbolic_v&lt; typename DerivedA::Scalar &gt; &amp;&amp;internal::is_double_or_symbolic_v&lt; typename DerivedB::Scalar &gt; &amp;&amp;std::is_same_v&lt; typename DerivedA::Scalar, typename DerivedB::Scalar &gt;, Eigen::Matrix&lt; typename DerivedA::Scalar, DerivedA::RowsAtCompileTime, DerivedB::ColsAtCompileTime &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a86c6f5510dba4ed848869421642a507b">LinearSolve</a> (const Eigen::MatrixBase&lt; DerivedA &gt; &amp;A, const Eigen::MatrixBase&lt; DerivedB &gt; &amp;b)</td></tr>
<tr class="memdesc:a86c6f5510dba4ed848869421642a507b"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Deprecated.)  <a href="namespacedrake_1_1math.html#a86c6f5510dba4ed848869421642a507b">More...</a><br /></td></tr>
<tr class="separator:a86c6f5510dba4ed848869421642a507b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6afc2838c9f0557a1060507a584548ea"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename, int... &gt; typename LinearSolverType, typename DerivedA , typename DerivedB &gt; </td></tr>
<tr class="memitem:a6afc2838c9f0557a1060507a584548ea"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same_v&lt; typename DerivedA::Scalar, double &gt; &amp;&amp;!internal::is_double_or_symbolic_v&lt; typename DerivedB::Scalar &gt;, Eigen::Matrix&lt; typename DerivedB::Scalar, DerivedA::RowsAtCompileTime, DerivedB::ColsAtCompileTime &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a6afc2838c9f0557a1060507a584548ea">SolveLinearSystem</a> (const Eigen::MatrixBase&lt; DerivedA &gt; &amp;A, const Eigen::MatrixBase&lt; DerivedB &gt; &amp;b)</td></tr>
<tr class="memdesc:a6afc2838c9f0557a1060507a584548ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specialization for A being double-valued matrix, and b being AutoDiffScalar-valued matrix.  <a href="namespacedrake_1_1math.html#a6afc2838c9f0557a1060507a584548ea">More...</a><br /></td></tr>
<tr class="separator:a6afc2838c9f0557a1060507a584548ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cbe77d752e146af183c38a4e830042c"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename, int... &gt; typename LinearSolverType, typename DerivedA , typename DerivedB &gt; </td></tr>
<tr class="memitem:a4cbe77d752e146af183c38a4e830042c"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same_v&lt; typename DerivedA::Scalar, double &gt; &amp;&amp;!internal::is_double_or_symbolic_v&lt; typename DerivedB::Scalar &gt;, Eigen::Matrix&lt; typename DerivedB::Scalar, DerivedA::RowsAtCompileTime, DerivedB::ColsAtCompileTime &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a4cbe77d752e146af183c38a4e830042c">LinearSolve</a> (const Eigen::MatrixBase&lt; DerivedA &gt; &amp;A, const Eigen::MatrixBase&lt; DerivedB &gt; &amp;b)</td></tr>
<tr class="memdesc:a4cbe77d752e146af183c38a4e830042c"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Deprecated.)  <a href="namespacedrake_1_1math.html#a4cbe77d752e146af183c38a4e830042c">More...</a><br /></td></tr>
<tr class="separator:a4cbe77d752e146af183c38a4e830042c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab72ac2c5ed9d77fd217afef0db0694b1"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename, int... &gt; typename LinearSolverType, typename DerivedA , typename DerivedB &gt; </td></tr>
<tr class="memitem:ab72ac2c5ed9d77fd217afef0db0694b1"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; !internal::is_double_or_symbolic_v&lt; typename DerivedA::Scalar &gt;, Eigen::Matrix&lt; typename DerivedA::Scalar, DerivedA::RowsAtCompileTime, DerivedB::ColsAtCompileTime &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#ab72ac2c5ed9d77fd217afef0db0694b1">SolveLinearSystem</a> (const Eigen::MatrixBase&lt; DerivedA &gt; &amp;A, const Eigen::MatrixBase&lt; DerivedB &gt; &amp;b)</td></tr>
<tr class="memdesc:ab72ac2c5ed9d77fd217afef0db0694b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specialization when A is a matrix of AutoDiffScalar.  <a href="namespacedrake_1_1math.html#ab72ac2c5ed9d77fd217afef0db0694b1">More...</a><br /></td></tr>
<tr class="separator:ab72ac2c5ed9d77fd217afef0db0694b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52bc61b704331cc7159ee4f3c2c87dfa"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename, int... &gt; typename LinearSolverType, typename DerivedA , typename DerivedB &gt; </td></tr>
<tr class="memitem:a52bc61b704331cc7159ee4f3c2c87dfa"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; !internal::is_double_or_symbolic_v&lt; typename DerivedA::Scalar &gt;, Eigen::Matrix&lt; typename DerivedA::Scalar, DerivedA::RowsAtCompileTime, DerivedB::ColsAtCompileTime &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a52bc61b704331cc7159ee4f3c2c87dfa">LinearSolve</a> (const Eigen::MatrixBase&lt; DerivedA &gt; &amp;A, const Eigen::MatrixBase&lt; DerivedB &gt; &amp;b)</td></tr>
<tr class="memdesc:a52bc61b704331cc7159ee4f3c2c87dfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Deprecated.)  <a href="namespacedrake_1_1math.html#a52bc61b704331cc7159ee4f3c2c87dfa">More...</a><br /></td></tr>
<tr class="separator:a52bc61b704331cc7159ee4f3c2c87dfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Get linear solver</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpaf2e3eb63ecef8e2d47c52ea3815274d"></a><a class="anchor" id="get_linear_solver"></a></p>
<p>Create the linear solver for a given matrix A, which will be used to solve the linear system of equations A * x = b.</p>
<p>The following table indicate the scalar type of the matrix in the returned linear solver, depending on the scalar type in matrix A</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">A  </th><th class="markdownTableHeadNone">double  </th><th class="markdownTableHeadNone">ADS  </th><th class="markdownTableHeadNone">Expr   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">solver  </td><td class="markdownTableBodyNone">double  </td><td class="markdownTableBodyNone">double  </td><td class="markdownTableBodyNone">Expr   </td></tr>
</table>
<p>where ADS stands for Eigen::AutoDiffScalar, and Expr stands for symbolic::Expression. Here is the example code </p><div class="fragment"><div class="line">Eigen::Matrix2d A_val;</div><div class="line">A_val &lt;&lt; 1, 2, 2, 5;</div><div class="line"><a class="code" href="namespacedrake_1_1systems_1_1analysis_1_1test.html#a322dbcada3667894a629fe3f1a476f2a">Eigen::Vector2d</a> b_val(3, 4);</div><div class="line"><span class="keyword">const</span> <a class="code" href="namespacedrake_1_1systems_1_1analysis_1_1test.html#a322dbcada3667894a629fe3f1a476f2a">Eigen::Vector2d</a> x_val =</div><div class="line">  <a class="code" href="namespacedrake_1_1math.html#a058825f71b44c44e61dd90c3b89ec87d">SolveLinearSystem</a>(GetLinearSolver&lt;Eigen::LLT&gt;(A_val), A_val, b_val);</div><div class="line">Eigen::Matrix&lt;AutoDiffXd, 2, 2&gt; A_ad;</div><div class="line">A_ad(0, 0).value() = A_val(0, 0);</div><div class="line">A_ad(0, 0).derivatives() = Eigen::Vector3d(1, 2, 3);</div><div class="line">A_ad(0, 1).value() = A_val(0, 1);</div><div class="line">A_ad(0, 1).derivatives() = Eigen::Vector3d(2, 3, 4);</div><div class="line">A_ad(1, 0).value() = A_val(1, 0);</div><div class="line">A_ad(1, 0).derivatives() = Eigen::Vector3d(3, 4, 5);</div><div class="line">A_ad(1, 1).value() = A_val(1, 1);</div><div class="line">A_ad(1, 1).derivatives() = Eigen::Vector3d(4, 5, 6);</div><div class="line"><span class="comment">// Solve A * x = b with A containing gradient.</span></div><div class="line"><span class="keyword">const</span> Eigen::Matrix&lt;AutoDiffXd, 2, 1&gt; x_ad1 =</div><div class="line">  <a class="code" href="namespacedrake_1_1math.html#a058825f71b44c44e61dd90c3b89ec87d">SolveLinearSystem</a>(GetLinearSolver&lt;Eigen::LLT&gt;(A_ad), A_ad, b_val);</div><div class="line">Eigen::Matrix&lt;AutoDiffXd, 2, 1&gt; b_ad;</div><div class="line">b_ad(0).value() = b_val(0);</div><div class="line">b_ad(0).derivatives() = Eigen::Vector3d(5, 6, 7);</div><div class="line">b_ad(1).value() = b_val(1);</div><div class="line">b_ad(1).derivatives() = Eigen::Vector3d(6, 7, 8);</div><div class="line"><span class="comment">// Solve A * x = b with b containing gradient.</span></div><div class="line"><span class="keyword">const</span> Eigen::Matrix&lt;AutoDiffXd, 2, 1&gt; x_ad2 =</div><div class="line">  <a class="code" href="namespacedrake_1_1math.html#a058825f71b44c44e61dd90c3b89ec87d">SolveLinearSystem</a>(GetLinearSolver&lt;Eigen::LLT&gt;(A_val), A_val, b_ad);</div><div class="line"><span class="comment">// Solve A * x = b with both A and b containing gradient.</span></div><div class="line"><span class="keyword">const</span> Eigen::Matrix&lt;AutoDiffXd, 2, 1&gt; x_ad3 =</div><div class="line">  <a class="code" href="namespacedrake_1_1math.html#a058825f71b44c44e61dd90c3b89ec87d">SolveLinearSystem</a>(GetLinearSolver&lt;Eigen::LLT&gt;(A_ad), A_ad, b_ad);</div></div><!-- fragment --><p>{cc} </p>
</td></tr>
<tr class="memitem:a83f5ce728ad96445072eecaf28b83eb4"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename, int... &gt; typename LinearSolverType, typename DerivedA &gt; </td></tr>
<tr class="memitem:a83f5ce728ad96445072eecaf28b83eb4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a83f5ce728ad96445072eecaf28b83eb4">LinearSolver</a> = LinearSolverType&lt; Eigen::Matrix&lt; std::conditional_t&lt; internal::is_double_or_symbolic_v&lt; typename DerivedA::Scalar &gt;, typename DerivedA::Scalar, double &gt;, DerivedA::RowsAtCompileTime, DerivedA::ColsAtCompileTime, Eigen::ColMajor, DerivedA::MaxRowsAtCompileTime, DerivedA::MaxColsAtCompileTime &gt; &gt;</td></tr>
<tr class="memdesc:a83f5ce728ad96445072eecaf28b83eb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The return type of GetLinearSolver function.  <a href="namespacedrake_1_1math.html#a83f5ce728ad96445072eecaf28b83eb4">More...</a><br /></td></tr>
<tr class="separator:a83f5ce728ad96445072eecaf28b83eb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada1b2ebdc1844a99851185d0921bf8db"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename, int... &gt; typename LinearSolverType, typename DerivedA &gt; </td></tr>
<tr class="memitem:ada1b2ebdc1844a99851185d0921bf8db"><td class="memTemplItemLeft" align="right" valign="top">LinearSolver&lt; LinearSolverType, DerivedA &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#ada1b2ebdc1844a99851185d0921bf8db">GetLinearSolver</a> (const Eigen::MatrixBase&lt; DerivedA &gt; &amp;A)</td></tr>
<tr class="memdesc:ada1b2ebdc1844a99851185d0921bf8db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the linear solver for a matrix A.  <a href="namespacedrake_1_1math.html#ada1b2ebdc1844a99851185d0921bf8db">More...</a><br /></td></tr>
<tr class="separator:ada1b2ebdc1844a99851185d0921bf8db"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.15 -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_f1666844dc41ec91c14125b680b7be1b.html">drake</a></li><li class="navelem"><a class="el" href="dir_fc0178d6978c9fa2cad6ef3e048a60a7.html">math</a></li><li class="navelem"><a class="el" href="linear__solve_8h.html">linear_solve.h</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.nl/">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a></li>
  </ul>
</div>
</body>
</html>
