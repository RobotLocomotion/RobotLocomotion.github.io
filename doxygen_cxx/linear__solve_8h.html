<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: drake/math/linear_solve.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<header class="site-header">
 <div class="site-header-inner contain">
  <a class="drake-logo" href="/"><img src="/images/drake-logo-white.svg"></a>
  <div class="menu-mobile-toggle">
   <span></span>
  </div>
  <nav class="site-menu">
   <ul>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/">Home</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/installation.html">Installation</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/gallery.html">Gallery</a>
    </li>
    <li class="site-menu-item site-menu-item-main">API Documentation
     <div class="sub">
      <a class="site-menu-item" href="https://drake.mit.edu/doxygen_cxx/index.html">C++</a>
      <a class="site-menu-item" href="https://drake.mit.edu/pydrake/index.html">Python</a>
     </div>
    </li>
    <li class="site-menu-item site-menu-item-main">Resources
     <div class="sub">
      <a class="site-menu-item" href="/getting_help.html">Getting Help</a>
      <a class="site-menu-item" href="https://github.com/RobotLocomotion/drake/tree/master/tutorials">Tutorials</a>
      <a class="site-menu-item" href="/python_bindings.html">Python Bindings</a>
      <a class="site-menu-item" href="/developers.html">For Developers</a>
      <a class="site-menu-item" href="/credits.html">Credits</a>
     </div>
    </li>
    <li class="github-link">
     <a class="site-menu-item" href="https://github.com/RobotLocomotion/drake">GitHub <img src="/third_party/images/GitHub-Mark-Light-64px.png"></a>
    </li>
   </ul>
  </nav>
 </div>
</header>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
<div class="title-banner">
 <div class="title-banner__title">
  Drake C++ Documentation
 </div>
 <div id="DDGSearch">
  <form id="ddg-search-form" class="wy_form" action="https://duckduckgo.com/" method="get">
   <input type="text" name="q" placeholder="Search C++ API only…">
   <input type="hidden" name="sites" value="drake.mit.edu/doxygen_cxx">
  </form>
  <form id="ddg-search-form" class="wy_form" action="https://duckduckgo.com/" method="get">
   <input type="text" name="q" placeholder="Search all of Drake…">
   <input type="hidden" name="sites" value="drake.mit.edu">
  </form>
 </div>
 <div id="MSearchBoxContainer">
          <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
 </div>
</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('linear__solve_8h.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<div class="title">linear_solve.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;optional&gt;</code><br />
<code>#include &quot;<a class="el" href="expression_8h.html">drake/common/symbolic/expression.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="math_2autodiff_8h.html">drake/math/autodiff.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="autodiff__gradient_8h.html">drake/math/autodiff_gradient.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for linear_solve.h:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="linear__solve_8h__incl.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="linear__solve_8h__dep__incl.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_linear_solver.html">LinearSolver&lt; LinearSolverType, DerivedA &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves a linear system of equations A*x=b.  <a href="classdrake_1_1math_1_1_linear_solver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacedrake"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake.html">drake</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedrake_1_1math"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html">drake::math</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">solve linear system of equations with a given solver.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="linear_solve_given_solver"></a> Solve linear system of equations A * x = b. Where A is an Eigen matrix of double/AutoDiffScalar/symbolic::Expression, and b is an Eigen matrix of double/AutoDiffScalar/symbolic::Expression. Notice that if either A or b contains symbolic::Expression, then the other has to contain symbolic::Expression. This 3-argument version allows the user to re-use <code>linear_solver</code> when <code>b</code> changes or the gradient of <code>A</code> changes. When either A or b contains AutoDiffScalar, we use implicit function theorem to find the gradient in x as ∂x/∂zᵢ = A⁻¹(∂b/∂zᵢ - ∂A/∂zᵢ * x) where z is the variable we take gradient with.</p>
<dl class="section note"><dt>Note</dt><dd>When both A and b are Eigen matrix of double, this function is almost as fast as calling linear_solver.solve(b) directly. When either A or b contains AutoDiffScalar, this function is a lot faster than first instantiating the linear solver of AutoDiffScalar, and then solving the equation with this autodiffable linear solver. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LinearSolver</td><td>The type of linear solver, for example Eigen::LLT&lt;Eigen::Matrix2d&gt; </td></tr>
    <tr><td class="paramname">DerivedA</td><td>An Eigen Matrix. </td></tr>
    <tr><td class="paramname">DerivedB</td><td>An Eigen Vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">linear_solver</td><td>The linear solver constructed with the double-version of A. </td></tr>
    <tr><td class="paramname">A</td><td>The matrix A. </td></tr>
    <tr><td class="paramname">b</td><td>The vector b.</td></tr>
  </table>
  </dd>
</dl>
<p>Here is an example code. </p><div class="fragment"><div class="line">Eigen::Matrix&lt;AutoDiffd&lt;3&gt;, 2, 2&gt; A_ad;</div><div class="line"><span class="comment">// Set the value and gradient in A_ad with arbitrary values;</span></div><div class="line">Eigen::Matrix2d A_val;</div><div class="line">A_val &lt;&lt; 1, 2, 3, 4;</div><div class="line"><span class="comment">// Gradient of A.col(0).</span></div><div class="line">Eigen::Matrix&lt;double, 2, 3&gt; A0_gradient;</div><div class="line">A0_gradient &lt;&lt; 1, 2, 3, 4, 5, 6;</div><div class="line">A_ad.col(0) = <a class="code" href="namespacedrake_1_1math.html#a32942f788a67278f27426f128e50e0b2">InitializeAutoDiff</a>(A_val.col(0), A0_gradient);</div><div class="line"><span class="comment">// Gradient of A.col(1)</span></div><div class="line">Eigen::Matrix&lt;double, 2, 3&gt; A1_gradient;</div><div class="line">A1_gradient &lt;&lt; 7, 8, 9, 10, 11, 12;</div><div class="line">A_ad.col(1) = <a class="code" href="namespacedrake_1_1math.html#a32942f788a67278f27426f128e50e0b2">InitializeAutoDiff</a>(A_val.col(1), A1_gradient);</div><div class="line"><span class="comment">// Set the value and gradient of b to arbitrary value.</span></div><div class="line"><span class="keyword">const</span> <a class="code" href="namespacedrake_1_1systems_1_1analysis_1_1test.html#a322dbcada3667894a629fe3f1a476f2a">Eigen::Vector2d</a> b_val(2, 3);</div><div class="line">Eigen::Matrix&lt;double, 2, 3&gt; b_gradient;</div><div class="line">b_gradient &lt;&lt; 1, 3, 5, 7, 9, 11;</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> b_ad = <a class="code" href="namespacedrake_1_1math.html#a32942f788a67278f27426f128e50e0b2">InitializeAutoDiff</a>(b_val, b_gradient);</div><div class="line"><span class="comment">// Solve the linear system A_val * x_val = b_val.</span></div><div class="line">Eigen::PartialPivLU&lt;Eigen::Matrix2d&gt; linear_solver(A_val);</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> x_val = <a class="code" href="namespacedrake_1_1math.html#a058825f71b44c44e61dd90c3b89ec87d">SolveLinearSystem</a>(linear_solver, A_val, b_val);</div><div class="line"><span class="comment">// Solve the linear system A*x=b, together with the gradient.</span></div><div class="line"><span class="comment">// x_ad contains both the value of the solution A*x=b, together with its</span></div><div class="line"><span class="comment">// gradient.</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> x_ad = <a class="code" href="namespacedrake_1_1math.html#a058825f71b44c44e61dd90c3b89ec87d">SolveLinearSystem</a>(linear_solver, A_ad, b_ad);</div></div><!-- fragment --> </div></td></tr>
<tr class="memitem:a058825f71b44c44e61dd90c3b89ec87d"><td class="memTemplParams" colspan="2">template&lt;typename LinearSolver , typename DerivedA , typename DerivedB &gt; </td></tr>
<tr class="memitem:a058825f71b44c44e61dd90c3b89ec87d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; internal::is_double_or_symbolic_v&lt; typename DerivedA::Scalar &gt; &amp;&amp;internal::is_double_or_symbolic_v&lt; typename DerivedB::Scalar &gt; &amp;&amp;std::is_same_v&lt; typename DerivedA::Scalar, typename DerivedB::Scalar &gt;, Eigen::Matrix&lt; typename DerivedA::Scalar, DerivedA::RowsAtCompileTime, DerivedB::ColsAtCompileTime &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a058825f71b44c44e61dd90c3b89ec87d">SolveLinearSystem</a> (const LinearSolver &amp;linear_solver, const Eigen::MatrixBase&lt; DerivedA &gt; &amp;A, const Eigen::MatrixBase&lt; DerivedB &gt; &amp;b)</td></tr>
<tr class="memdesc:a058825f71b44c44e61dd90c3b89ec87d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized when A and b are both double or <a class="el" href="classdrake_1_1symbolic_1_1_expression.html" title="Represents a symbolic form of an expression.">symbolic::Expression</a> matrices.  <a href="namespacedrake_1_1math.html#a058825f71b44c44e61dd90c3b89ec87d">More...</a><br /></td></tr>
<tr class="separator:a058825f71b44c44e61dd90c3b89ec87d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34a14f4ecff0af11999f7d416c3316bf"><td class="memTemplParams" colspan="2">template&lt;typename LinearSolver , typename DerivedB &gt; </td></tr>
<tr class="memitem:a34a14f4ecff0af11999f7d416c3316bf"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; internal::is_double_or_symbolic_v&lt; typename LinearSolver::MatrixType::Scalar &gt; &amp;&amp;internal::is_double_or_symbolic_v&lt; typename DerivedB::Scalar &gt; &amp;&amp;std::is_same_v&lt; typename LinearSolver::MatrixType::Scalar, typename DerivedB::Scalar &gt;, Eigen::Matrix&lt; typename LinearSolver::MatrixType::Scalar, DerivedB::RowsAtCompileTime, DerivedB::ColsAtCompileTime &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a34a14f4ecff0af11999f7d416c3316bf">SolveLinearSystem</a> (const LinearSolver &amp;linear_solver, const Eigen::MatrixBase&lt; DerivedB &gt; &amp;b)</td></tr>
<tr class="memdesc:a34a14f4ecff0af11999f7d416c3316bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized when the matrix in linear_solver and b are both double or <a class="el" href="classdrake_1_1symbolic_1_1_expression.html" title="Represents a symbolic form of an expression.">symbolic::Expression</a> matrices.  <a href="namespacedrake_1_1math.html#a34a14f4ecff0af11999f7d416c3316bf">More...</a><br /></td></tr>
<tr class="separator:a34a14f4ecff0af11999f7d416c3316bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1ecf90a76392d69deecb8feb29e19a7"><td class="memTemplParams" colspan="2">template&lt;typename LinearSolver , typename DerivedB &gt; </td></tr>
<tr class="memitem:ac1ecf90a76392d69deecb8feb29e19a7"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same_v&lt; typename LinearSolver::MatrixType::Scalar, double &gt; &amp;&amp;internal::is_autodiff_v&lt; typename DerivedB::Scalar &gt;, Eigen::Matrix&lt; typename DerivedB::Scalar, DerivedB::RowsAtCompileTime, DerivedB::ColsAtCompileTime &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#ac1ecf90a76392d69deecb8feb29e19a7">SolveLinearSystem</a> (const LinearSolver &amp;linear_solver, const Eigen::MatrixBase&lt; DerivedB &gt; &amp;b)</td></tr>
<tr class="memdesc:ac1ecf90a76392d69deecb8feb29e19a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized the matrix in linear_solver is a double-valued matrix and b is an AutoDiffScalar-valued matrix.  <a href="namespacedrake_1_1math.html#ac1ecf90a76392d69deecb8feb29e19a7">More...</a><br /></td></tr>
<tr class="separator:ac1ecf90a76392d69deecb8feb29e19a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fe42b78445dde235cc217342ba8ab87"><td class="memTemplParams" colspan="2">template&lt;typename LinearSolver , typename DerivedA , typename DerivedB &gt; </td></tr>
<tr class="memitem:a2fe42b78445dde235cc217342ba8ab87"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same_v&lt; typename DerivedA::Scalar, double &gt; &amp;&amp;internal::is_autodiff_v&lt; typename DerivedB::Scalar &gt;, Eigen::Matrix&lt; typename DerivedB::Scalar, DerivedA::RowsAtCompileTime, DerivedB::ColsAtCompileTime &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a2fe42b78445dde235cc217342ba8ab87">SolveLinearSystem</a> (const LinearSolver &amp;linear_solver, const Eigen::MatrixBase&lt; DerivedA &gt; &amp;A, const Eigen::MatrixBase&lt; DerivedB &gt; &amp;b)</td></tr>
<tr class="memdesc:a2fe42b78445dde235cc217342ba8ab87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized when A is a double-valued matrix and b is an AutoDiffScalar-valued matrix.  <a href="namespacedrake_1_1math.html#a2fe42b78445dde235cc217342ba8ab87">More...</a><br /></td></tr>
<tr class="separator:a2fe42b78445dde235cc217342ba8ab87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bfcba20c731dc23e4f48c367e36c9de"><td class="memTemplParams" colspan="2">template&lt;typename LinearSolver , typename DerivedA , typename DerivedB &gt; </td></tr>
<tr class="memitem:a9bfcba20c731dc23e4f48c367e36c9de"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; internal::is_autodiff_v&lt; typename DerivedA::Scalar &gt;, Eigen::Matrix&lt; typename DerivedA::Scalar, DerivedA::RowsAtCompileTime, DerivedB::ColsAtCompileTime &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a9bfcba20c731dc23e4f48c367e36c9de">SolveLinearSystem</a> (const LinearSolver &amp;linear_solver, const Eigen::MatrixBase&lt; DerivedA &gt; &amp;A, const Eigen::MatrixBase&lt; DerivedB &gt; &amp;b)</td></tr>
<tr class="memdesc:a9bfcba20c731dc23e4f48c367e36c9de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized when A is an AutoDiffScalar-valued matrix, and b can contain either AutoDiffScalar or double.  <a href="namespacedrake_1_1math.html#a9bfcba20c731dc23e4f48c367e36c9de">More...</a><br /></td></tr>
<tr class="separator:a9bfcba20c731dc23e4f48c367e36c9de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Get linear solver</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="get_linear_solver"></a></p>
<p>Create the linear solver for a given matrix A, which will be used to solve the linear system of equations A * x = b.</p>
<p>The following table indicate the scalar type of the matrix in the returned linear solver, depending on the scalar type in matrix A</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">A  </th><th class="markdownTableHeadNone">double  </th><th class="markdownTableHeadNone">ADS  </th><th class="markdownTableHeadNone">Expr   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">solver  </td><td class="markdownTableBodyNone">double  </td><td class="markdownTableBodyNone">double  </td><td class="markdownTableBodyNone">Expr   </td></tr>
</table>
<p>where ADS stands for Eigen::AutoDiffScalar, and Expr stands for symbolic::Expression. Here is the example code </p><div class="fragment"><div class="line">Eigen::Matrix2d A_val;</div><div class="line">A_val &lt;&lt; 1, 2, 2, 5;</div><div class="line"><a class="code" href="namespacedrake_1_1systems_1_1analysis_1_1test.html#a322dbcada3667894a629fe3f1a476f2a">Eigen::Vector2d</a> b_val(3, 4);</div><div class="line"><span class="keyword">const</span> <a class="code" href="namespacedrake_1_1systems_1_1analysis_1_1test.html#a322dbcada3667894a629fe3f1a476f2a">Eigen::Vector2d</a> x_val =</div><div class="line">  <a class="code" href="namespacedrake_1_1math.html#a058825f71b44c44e61dd90c3b89ec87d">SolveLinearSystem</a>(GetLinearSolver&lt;Eigen::LLT&gt;(A_val), A_val, b_val);</div><div class="line">Eigen::Matrix&lt;AutoDiffXd, 2, 2&gt; A_ad;</div><div class="line">A_ad(0, 0).value() = A_val(0, 0);</div><div class="line">A_ad(0, 0).derivatives() = Eigen::Vector3d(1, 2, 3);</div><div class="line">A_ad(0, 1).value() = A_val(0, 1);</div><div class="line">A_ad(0, 1).derivatives() = Eigen::Vector3d(2, 3, 4);</div><div class="line">A_ad(1, 0).value() = A_val(1, 0);</div><div class="line">A_ad(1, 0).derivatives() = Eigen::Vector3d(3, 4, 5);</div><div class="line">A_ad(1, 1).value() = A_val(1, 1);</div><div class="line">A_ad(1, 1).derivatives() = Eigen::Vector3d(4, 5, 6);</div><div class="line"><span class="comment">// Solve A * x = b with A containing gradient.</span></div><div class="line"><span class="keyword">const</span> Eigen::Matrix&lt;AutoDiffXd, 2, 1&gt; x_ad1 =</div><div class="line">  <a class="code" href="namespacedrake_1_1math.html#a058825f71b44c44e61dd90c3b89ec87d">SolveLinearSystem</a>(GetLinearSolver&lt;Eigen::LLT&gt;(A_ad), A_ad, b_val);</div><div class="line">Eigen::Matrix&lt;AutoDiffXd, 2, 1&gt; b_ad;</div><div class="line">b_ad(0).value() = b_val(0);</div><div class="line">b_ad(0).derivatives() = Eigen::Vector3d(5, 6, 7);</div><div class="line">b_ad(1).value() = b_val(1);</div><div class="line">b_ad(1).derivatives() = Eigen::Vector3d(6, 7, 8);</div><div class="line"><span class="comment">// Solve A * x = b with b containing gradient.</span></div><div class="line"><span class="keyword">const</span> Eigen::Matrix&lt;AutoDiffXd, 2, 1&gt; x_ad2 =</div><div class="line">  <a class="code" href="namespacedrake_1_1math.html#a058825f71b44c44e61dd90c3b89ec87d">SolveLinearSystem</a>(GetLinearSolver&lt;Eigen::LLT&gt;(A_val), A_val, b_ad);</div><div class="line"><span class="comment">// Solve A * x = b with both A and b containing gradient.</span></div><div class="line"><span class="keyword">const</span> Eigen::Matrix&lt;AutoDiffXd, 2, 1&gt; x_ad3 =</div><div class="line">  <a class="code" href="namespacedrake_1_1math.html#a058825f71b44c44e61dd90c3b89ec87d">SolveLinearSystem</a>(GetLinearSolver&lt;Eigen::LLT&gt;(A_ad), A_ad, b_ad);</div></div><!-- fragment --><p>{cc} </p>
</div></td></tr>
<tr class="memitem:a145b102b8109265146ea4a0c63596873"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename, int... &gt; typename LinearSolverType, typename DerivedA &gt; </td></tr>
<tr class="memitem:a145b102b8109265146ea4a0c63596873"><td class="memTemplItemLeft" align="right" valign="top">internal::EigenLinearSolver&lt; LinearSolverType, DerivedA &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a145b102b8109265146ea4a0c63596873">GetLinearSolver</a> (const Eigen::MatrixBase&lt; DerivedA &gt; &amp;A)</td></tr>
<tr class="memdesc:a145b102b8109265146ea4a0c63596873"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the linear solver for a matrix A.  <a href="namespacedrake_1_1math.html#a145b102b8109265146ea4a0c63596873">More...</a><br /></td></tr>
<tr class="separator:a145b102b8109265146ea4a0c63596873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">solve linear system of equations</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="linear_solve"></a> Solve linear system of equations A * x = b. Where A is an Eigen matrix of double/AutoDiffScalar/symbolic::Expression, and b is an Eigen matrix of double/AutoDiffScalar/symbolic::Expression. Note that when either A or b contains symbolic::Expression, the other has to contain symbolic::Expression as well. When either A or b contains AutoDiffScalar, we use implicit function theorem to find the gradient in x as ∂x/∂zᵢ = A⁻¹(∂b/∂zᵢ - ∂A/∂zᵢ * x) where z is the variable we take gradient with.</p>
<p>The following table indicate the scalar type of x with A/b containing the specified scalar type. The entries with NA are not supported.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">b ＼ A  </th><th class="markdownTableHeadNone">double  </th><th class="markdownTableHeadNone">ADS  </th><th class="markdownTableHeadNone">Expr   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">double  </td><td class="markdownTableBodyNone">double  </td><td class="markdownTableBodyNone">ADS  </td><td class="markdownTableBodyNone">NA   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">ADS  </td><td class="markdownTableBodyNone">ADS  </td><td class="markdownTableBodyNone">ADS  </td><td class="markdownTableBodyNone">NA   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Expr  </td><td class="markdownTableBodyNone">NA  </td><td class="markdownTableBodyNone">NA  </td><td class="markdownTableBodyNone">Expr   </td></tr>
</table>
<p>where ADS stands for Eigen::AutoDiffScalar, and Expr stands for symbolic::Expression.</p>
<p>TODO(hongkai.dai): support one of A/b being a double matrix and the other being a symbolic::Expression matrix.</p>
<dl class="section note"><dt>Note</dt><dd>When both A and b are Eigen matrix of double, this function is almost as fast as calling linear_solver.solve(b) directly; when either A or b contains AutoDiffScalar, this function is a lot faster than first instantiating the linear solver of AutoDiffScalar, and then solving the equation with this autodiffable linear solver. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LinearSolverType</td><td>The type of linear solver, for example Eigen::LLT. Notice that this is just specifies the solver type (such as Eigen::LLT), not the matrix type (like Eigen::LLT&lt;Eigen::Matrix2d&gt;). All Eigen solvers we care about are templated on the matrix type. Some are further templated on configuration ints. The int... will acount for zero or more of these ints, providing a common interface for both types of solvers. </td></tr>
    <tr><td class="paramname">DerivedA</td><td>An Eigen Matrix. </td></tr>
    <tr><td class="paramname">DerivedB</td><td>An Eigen Vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The matrix A. </td></tr>
    <tr><td class="paramname">b</td><td>The vector b.</td></tr>
  </table>
  </dd>
</dl>
<p>Here is an example code. </p><div class="fragment"><div class="line">Eigen::Matrix&lt;AutoDiffd&lt;3&gt;, 2, 2&gt; A_ad;</div><div class="line"><span class="comment">// Set the value and gradient in A_ad with arbitrary values;</span></div><div class="line">Eigen::Matrix2d A_val;</div><div class="line">A_val &lt;&lt; 1, 2, 3, 4;</div><div class="line"><span class="comment">// Gradient of A.col(0).</span></div><div class="line">Eigen::Matrix&lt;double, 2, 3&gt; A0_gradient;</div><div class="line">A0_gradient &lt;&lt; 1, 2, 3, 4, 5, 6;</div><div class="line">A_ad.col(0) = <a class="code" href="namespacedrake_1_1math.html#a32942f788a67278f27426f128e50e0b2">InitializeAutoDiff</a>(A_val.col(0), A0_gradient);</div><div class="line"><span class="comment">// Gradient of A.col(1)</span></div><div class="line">Eigen::Matrix&lt;double, 2, 3&gt; A1_gradient;</div><div class="line">A1_gradient &lt;&lt; 7, 8, 9, 10, 11, 12;</div><div class="line">A_ad.col(1) = <a class="code" href="namespacedrake_1_1math.html#a32942f788a67278f27426f128e50e0b2">InitializeAutoDiff</a>(A_val.col(1), A1_gradient);</div><div class="line"><span class="comment">// Set the value and gradient of b to arbitrary value.</span></div><div class="line"><span class="keyword">const</span> <a class="code" href="namespacedrake_1_1systems_1_1analysis_1_1test.html#a322dbcada3667894a629fe3f1a476f2a">Eigen::Vector2d</a> b_val(2, 3);</div><div class="line">Eigen::Matrix&lt;double, 2, 3&gt; b_gradient;</div><div class="line">b_gradient &lt;&lt; 1, 3, 5, 7, 9, 11;</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> b_ad = <a class="code" href="namespacedrake_1_1math.html#a32942f788a67278f27426f128e50e0b2">InitializeAutoDiff</a>(b_val, b_gradient);</div><div class="line"><span class="comment">// Solve the linear system A*x=b without the gradient.</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> x_val = SolveLinearSystem&lt;Eigen::PartialPivLU&gt;(A_val, b_val);</div><div class="line"><span class="comment">// Solve the linear system A*x=b, together with the gradient.</span></div><div class="line"><span class="comment">// x_ad contains both the value of the solution A*x=b, together with its</span></div><div class="line"><span class="comment">// gradient.</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> x_ad = SolveLinearSystem&lt;Eigen::PartialPivLU&gt;(A_ad, b_ad);</div></div><!-- fragment --> </div></td></tr>
<tr class="memitem:a579e00c8ae91d6bcdb32eb4d723eba73"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename, int... &gt; typename LinearSolverType, typename DerivedA , typename DerivedB &gt; </td></tr>
<tr class="memitem:a579e00c8ae91d6bcdb32eb4d723eba73"><td class="memTemplItemLeft" align="right" valign="top">internal::Solution&lt; DerivedA, DerivedB &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a579e00c8ae91d6bcdb32eb4d723eba73">SolveLinearSystem</a> (const Eigen::MatrixBase&lt; DerivedA &gt; &amp;A, const Eigen::MatrixBase&lt; DerivedB &gt; &amp;b)</td></tr>
<tr class="memdesc:a579e00c8ae91d6bcdb32eb4d723eba73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves system A*x=b.  <a href="namespacedrake_1_1math.html#a579e00c8ae91d6bcdb32eb4d723eba73">More...</a><br /></td></tr>
<tr class="separator:a579e00c8ae91d6bcdb32eb4d723eba73"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- footer -->
<div id="nav-path" class="navpath">
  <ul>
    <li class="navelem"><a class="el" href="dir_f1666844dc41ec91c14125b680b7be1b.html">drake</a></li><li class="navelem"><a class="el" href="dir_fc0178d6978c9fa2cad6ef3e048a60a7.html">math</a></li><li class="navelem"><a class="el" href="linear__solve_8h.html">linear_solve.h</a></li>
  </ul>
</div>
<footer class="site-footer padding">
  <div class="contain">
    <a href="/" class="drake-logo">
      <img src="/images/drake-logo.svg"/>
    </a>
    <div class="footer-menu">
      <ul>    
        <li>
          <a href="/doxygen_cxx/index.html" class="site-menu-item">C++</a>
        </li>    
        <li>
          <a href="/pydrake/index.html" class="site-menu-item">Python</a>
        </li>
        <li class="github-link">
          <a href="https://github.com/RobotLocomotion/drake" class="site-menu-item">GitHub <img src="/third_party/images/GitHub-Mark-64px.png"/></a>
        </li>
      </ul>
    </div>
  </div>
</footer>
<script type="text/javascript">
searchBox.searchLabel = 'Go to name…';
searchBox.DOMSearchField().value = searchBox.searchLabel;
</script>
</body>
</html>
