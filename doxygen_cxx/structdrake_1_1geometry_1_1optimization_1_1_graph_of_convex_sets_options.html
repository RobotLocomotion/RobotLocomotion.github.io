<!-- HTML header for doxygen 1.15.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: GraphOfConvexSetsOptions Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(function() { init_search(); });
</script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@4/tex-chtml.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<header class="site-header">
 <div class="site-header-inner contain">
  <a class="drake-logo" href="/"><img src="/images/drake-logo-white.svg"></a>
  <div class="menu-mobile-toggle">
   <span></span>
  </div>
  <nav class="site-menu">
   <ul>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/">Home</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/installation.html">Installation</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/gallery.html">Gallery</a>
    </li>
    <li class="site-menu-item site-menu-item-main">API Documentation
     <div class="sub">
      <a class="site-menu-item" href="/doxygen_cxx/index.html">C++</a>
      <a class="site-menu-item" href="/pydrake/index.html">Python</a>
     </div>
    </li>
    <li class="site-menu-item site-menu-item-main">Resources
     <div class="sub">
      <a class="site-menu-item" href="/getting_help.html">Getting Help</a>
      <a class="site-menu-item" href="https://deepnote.com/workspace/Drake-0b3b2c53-a7ad-441b-80f8-bf8350752305/project/Tutorials-2b4fc509-aef2-417d-a40d-6071dfed9199/notebook/index-753e3c9d261247ba9f0eb1d7868c18c8">Tutorials</a>
      <a class="site-menu-item" href="/python_bindings.html">Python Bindings</a>
      <a class="site-menu-item" href="/developers.html">For Developers</a>
      <a class="site-menu-item" href="/credits.html">Credits</a>
     </div>
    </li>
    <li class="github-link">
     <a class="site-menu-item" href="https://github.com/RobotLocomotion/drake">GitHub <img src="/third_party/images/GitHub-Mark-Light-64px.png"></a>
    </li>
   </ul>
  </nav>
 </div>
</header>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<div class="title-banner">
 <div class="title-banner__title">
  Drake C++ Documentation
 </div>
 <div id="DDGSearch">
  <form id="search_form_cpp" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search C++ API only…">
   <input type="hidden" name="q" value="site:drake.mit.edu/doxygen_cxx">
  </form>
  <form id="search_form" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search all of Drake…">
   <input type="hidden" name="q" value="site:drake.mit.edu OR site:underactuated.csail.mit.edu OR site:manipulation.csail.mit.edu">
  </form>
 </div>
 <div id="MSearchBoxContainer">
  <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect" class="search-icon" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"><span class="search-icon-dropdown"></span></span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><div id="MSearchCloseImg" class="close-icon"></div></a>
          </span>
        </div>
</td>
 </div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('structdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_options.html','','structdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_options-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">GraphOfConvexSetsOptions Struct Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;drake/geometry/optimization/graph_of_convex_sets.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8e8824802dedfbc36776227f7482b6bc" id="r_a8e8824802dedfbc36776227f7482b6bc"><td class="memTemplParams" colspan="2">template&lt;typename Archive&gt; </td></tr>
<tr class="memitem:a8e8824802dedfbc36776227f7482b6bc template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8e8824802dedfbc36776227f7482b6bc">Serialize</a> (Archive *a)</td></tr>
<tr class="memdesc:a8e8824802dedfbc36776227f7482b6bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Passes this object to an Archive.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-attribs" class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a6787cfcca13150e38baf6ec079b36cc6" id="r_a6787cfcca13150e38baf6ec079b36cc6"><td class="memItemLeft" align="right" valign="top">std::optional&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6787cfcca13150e38baf6ec079b36cc6">convex_relaxation</a> {std::nullopt}</td></tr>
<tr class="memdesc:a6787cfcca13150e38baf6ec079b36cc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag to solve the relaxed version of the problem.  <br /></td></tr>
<tr class="memitem:a6a1701a8da6d555793295539e9d4fda4" id="r_a6a1701a8da6d555793295539e9d4fda4"><td class="memItemLeft" align="right" valign="top">std::optional&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6a1701a8da6d555793295539e9d4fda4">max_rounded_paths</a> {std::nullopt}</td></tr>
<tr class="memdesc:a6a1701a8da6d555793295539e9d4fda4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of distinct paths to compare during random rounding; only the lowest cost path is returned.  <br /></td></tr>
<tr class="memitem:a65b45f8fcf0383f8ecccfd94c3b7cd47" id="r_a65b45f8fcf0383f8ecccfd94c3b7cd47"><td class="memItemLeft" align="right" valign="top">std::optional&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a65b45f8fcf0383f8ecccfd94c3b7cd47">preprocessing</a> {std::nullopt}</td></tr>
<tr class="memdesc:a65b45f8fcf0383f8ecccfd94c3b7cd47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a preprocessing step to remove edges that cannot lie on the path from source to target.  <br /></td></tr>
<tr class="memitem:a6430583dae0d07964009a4345136d8ca" id="r_a6430583dae0d07964009a4345136d8ca"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6430583dae0d07964009a4345136d8ca">max_rounding_trials</a> {100}</td></tr>
<tr class="memdesc:a6430583dae0d07964009a4345136d8ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of trials to find a novel path during random rounding.  <br /></td></tr>
<tr class="memitem:aa3fa9cf3c24726cbf70d03c92300b70c" id="r_aa3fa9cf3c24726cbf70d03c92300b70c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa3fa9cf3c24726cbf70d03c92300b70c">flow_tolerance</a> {1e-5}</td></tr>
<tr class="memdesc:aa3fa9cf3c24726cbf70d03c92300b70c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tolerance for ignoring flow along a given edge during random rounding.  <br /></td></tr>
<tr class="memitem:abb7b16d4d092f7b7572de4c058b30d96" id="r_abb7b16d4d092f7b7572de4c058b30d96"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb7b16d4d092f7b7572de4c058b30d96">rounding_seed</a> {0}</td></tr>
<tr class="memdesc:abb7b16d4d092f7b7572de4c058b30d96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Random seed to use for random rounding.  <br /></td></tr>
<tr class="memitem:a1717b842ef7560038a1ee8f5076d7721" id="r_a1717b842ef7560038a1ee8f5076d7721"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1solvers_1_1_solver_interface.html">solvers::SolverInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1717b842ef7560038a1ee8f5076d7721">solver</a> {nullptr}</td></tr>
<tr class="memdesc:a1717b842ef7560038a1ee8f5076d7721"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimizer to be used to solve the MIP, the relaxation of the shortest path optimization problem and the convex restriction if no restriction_solver is provided.  <br /></td></tr>
<tr class="memitem:a2af5f59f2eac4720da5c5d9a901d414f" id="r_a2af5f59f2eac4720da5c5d9a901d414f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1solvers_1_1_solver_interface.html">solvers::SolverInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2af5f59f2eac4720da5c5d9a901d414f">restriction_solver</a> {nullptr}</td></tr>
<tr class="memdesc:a2af5f59f2eac4720da5c5d9a901d414f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimizer to be used in SolveConvexRestriction(), which is also called during the rounding stage of SolveShortestPath() given the relaxation.  <br /></td></tr>
<tr class="memitem:acf69707f5aa6d2853d36600958706ef0" id="r_acf69707f5aa6d2853d36600958706ef0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1solvers_1_1_solver_interface.html">solvers::SolverInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acf69707f5aa6d2853d36600958706ef0">preprocessing_solver</a> {nullptr}</td></tr>
<tr class="memdesc:acf69707f5aa6d2853d36600958706ef0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimizer to be used in the preprocessing stage of GCS, which is performed when SolveShortestPath is called when the <span class="tt"><a class="el" href="#a65b45f8fcf0383f8ecccfd94c3b7cd47" title="Performs a preprocessing step to remove edges that cannot lie on the path from source to target.">preprocessing</a></span> setting has been set to true.  <br /></td></tr>
<tr class="memitem:aa705e1cce16e5f276d9f1ff95851698e" id="r_aa705e1cce16e5f276d9f1ff95851698e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdrake_1_1solvers_1_1_solver_options.html">solvers::SolverOptions</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa705e1cce16e5f276d9f1ff95851698e">solver_options</a> {}</td></tr>
<tr class="memdesc:aa705e1cce16e5f276d9f1ff95851698e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options passed to the solver when solving the generated problem.  <br /></td></tr>
<tr class="memitem:ab41a3270130e638897f5c67f2cae3705" id="r_ab41a3270130e638897f5c67f2cae3705"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="structdrake_1_1solvers_1_1_solver_options.html">solvers::SolverOptions</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab41a3270130e638897f5c67f2cae3705">restriction_solver_options</a></td></tr>
<tr class="memdesc:ab41a3270130e638897f5c67f2cae3705"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optional solver options to be used in SolveConvexRestriction(), which is also used during the rounding stage of SolveShortestPath() given the relaxation.  <br /></td></tr>
<tr class="memitem:a1becd1e36f21ad0e73dd5886f911e551" id="r_a1becd1e36f21ad0e73dd5886f911e551"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="structdrake_1_1solvers_1_1_solver_options.html">solvers::SolverOptions</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1becd1e36f21ad0e73dd5886f911e551">preprocessing_solver_options</a></td></tr>
<tr class="memdesc:a1becd1e36f21ad0e73dd5886f911e551"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optional solver options to be used by preprocessing_solver in the preprocessing stage of GCS, which is used in SolveShortestPath.  <br /></td></tr>
<tr class="memitem:ad56caacfcfc31a58bbbce672c955e976" id="r_ad56caacfcfc31a58bbbce672c955e976"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1_parallelism.html">Parallelism</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad56caacfcfc31a58bbbce672c955e976">parallelism</a> {<a class="el" href="classdrake_1_1_parallelism.html#a5f5d962dfeec6e675996074f913df819">Parallelism::Max</a>()}</td></tr>
<tr class="memdesc:ad56caacfcfc31a58bbbce672c955e976"><td class="mdescLeft">&#160;</td><td class="mdescRight">Some steps in GCS can be parallelized.  <br /></td></tr>
</table>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="a8e8824802dedfbc36776227f7482b6bc" name="a8e8824802dedfbc36776227f7482b6bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e8824802dedfbc36776227f7482b6bc">&#9670;&#160;</a></span>Serialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Archive&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Serialize </td>
          <td>(</td>
          <td class="paramtype">Archive *</td>          <td class="paramname"><span class="paramname"><em>a</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Passes this object to an Archive. </p>
<p>Refer to <a class="el" href="group__yaml__serialization.html">YAML Serialization</a> for background. Note: This only serializes options that are YAML built-in types. </p>

</div>
</div>
<a name="doc-variable-members" id="doc-variable-members"></a><h2 id="header-doc-variable-members" class="groupheader">Member Data Documentation</h2>
<a id="a6787cfcca13150e38baf6ec079b36cc6" name="a6787cfcca13150e38baf6ec079b36cc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6787cfcca13150e38baf6ec079b36cc6">&#9670;&#160;</a></span>convex_relaxation</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;bool&gt; convex_relaxation {std::nullopt}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flag to solve the relaxed version of the problem. </p>
<p>As discussed in the paper, we know that this relaxation cannot solve the original NP-hard problem for all instances, but there are also many instances for which the convex relaxation is tight. If convex_relaxation=nullopt, then each GCS method is free to choose an appropriate default. </p>

</div>
</div>
<a id="aa3fa9cf3c24726cbf70d03c92300b70c" name="aa3fa9cf3c24726cbf70d03c92300b70c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3fa9cf3c24726cbf70d03c92300b70c">&#9670;&#160;</a></span>flow_tolerance</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double flow_tolerance {1e-5}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tolerance for ignoring flow along a given edge during random rounding. </p>
<p>If convex_relaxation is false or max_rounded_paths is less than or equal to zero, this option is ignored. </p>

</div>
</div>
<a id="a6a1701a8da6d555793295539e9d4fda4" name="a6a1701a8da6d555793295539e9d4fda4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a1701a8da6d555793295539e9d4fda4">&#9670;&#160;</a></span>max_rounded_paths</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;int&gt; max_rounded_paths {std::nullopt}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum number of distinct paths to compare during random rounding; only the lowest cost path is returned. </p>
<p>If convex_relaxation is false or this is less than or equal to zero, rounding is not performed. If max_rounded_paths=nullopt, then each GCS method is free to choose an appropriate default. </p>

</div>
</div>
<a id="a6430583dae0d07964009a4345136d8ca" name="a6430583dae0d07964009a4345136d8ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6430583dae0d07964009a4345136d8ca">&#9670;&#160;</a></span>max_rounding_trials</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int max_rounding_trials {100}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum number of trials to find a novel path during random rounding. </p>
<p>If convex_relaxation is false or max_rounded_paths is less than or equal to zero, this option is ignored. </p>

</div>
</div>
<a id="ad56caacfcfc31a58bbbce672c955e976" name="ad56caacfcfc31a58bbbce672c955e976"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad56caacfcfc31a58bbbce672c955e976">&#9670;&#160;</a></span>parallelism</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1_parallelism.html">Parallelism</a> parallelism {<a class="el" href="classdrake_1_1_parallelism.html#a5f5d962dfeec6e675996074f913df819">Parallelism::Max</a>()}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Some steps in GCS can be parallelized. </p>
<p>This is the maximum number of threads used in all places in the algorithm. </p><dl class="section note"><dt>Note</dt><dd>Some solvers will choose their own level of parallelization, independent of this setting. To limit the number of threads, add <a class="el" href="namespacedrake_1_1solvers.html#ae07229124cd16e9d8b62fe359c7d0b40af1d12898262fdbf42df381627646ee00">kMaxThreads</a> to the solver_options. </dd></dl>

</div>
</div>
<a id="a65b45f8fcf0383f8ecccfd94c3b7cd47" name="a65b45f8fcf0383f8ecccfd94c3b7cd47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65b45f8fcf0383f8ecccfd94c3b7cd47">&#9670;&#160;</a></span>preprocessing</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;bool&gt; preprocessing {std::nullopt}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a preprocessing step to remove edges that cannot lie on the path from source to target. </p>
<p>In most cases, preprocessing causes a net reduction in computation by reducing the size of the optimization solved. Note that this preprocessing is not exact. There may be edges that cannot lie on the path from source to target that this does not detect. If preprocessing=nullopt, then each GCS method is free to choose an appropriate default. </p>

</div>
</div>
<a id="acf69707f5aa6d2853d36600958706ef0" name="acf69707f5aa6d2853d36600958706ef0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf69707f5aa6d2853d36600958706ef0">&#9670;&#160;</a></span>preprocessing_solver</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1solvers_1_1_solver_interface.html">solvers::SolverInterface</a>* preprocessing_solver {nullptr}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Optimizer to be used in the preprocessing stage of GCS, which is performed when SolveShortestPath is called when the <span class="tt"><a class="el" href="#a65b45f8fcf0383f8ecccfd94c3b7cd47" title="Performs a preprocessing step to remove edges that cannot lie on the path from source to target.">preprocessing</a></span> setting has been set to true. </p>
<p>If not set, the interface at .solver will be used, if provided, otherwise the best solver for the given problem is selected. Note that if the solver cannot handle the type of optimization problem generated, then calling the <a class="el" href="classdrake_1_1solvers_1_1_solver_interface.html#aec933bef2f8c7a702a6fd5c59feac5ec" title="Solves an optimization program with optional initial guess and solver options.">solvers::SolverInterface::Solve()</a> method will throw. </p>

</div>
</div>
<a id="a1becd1e36f21ad0e73dd5886f911e551" name="a1becd1e36f21ad0e73dd5886f911e551"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1becd1e36f21ad0e73dd5886f911e551">&#9670;&#160;</a></span>preprocessing_solver_options</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;<a class="el" href="structdrake_1_1solvers_1_1_solver_options.html">solvers::SolverOptions</a>&gt; preprocessing_solver_options</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div>
<div class="line">      std::nullopt}</div>
</div><!-- fragment -->
<p>Optional solver options to be used by preprocessing_solver in the preprocessing stage of GCS, which is used in SolveShortestPath. </p>
<p>If preprocessing_solver is set but this parameter is not then solver_options is used. For instance, one might want to print solver logs for the main optimization, but not from the many smaller preprocessing optimizations. </p>

</div>
</div>
<a id="a2af5f59f2eac4720da5c5d9a901d414f" name="a2af5f59f2eac4720da5c5d9a901d414f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2af5f59f2eac4720da5c5d9a901d414f">&#9670;&#160;</a></span>restriction_solver</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1solvers_1_1_solver_interface.html">solvers::SolverInterface</a>* restriction_solver {nullptr}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Optimizer to be used in SolveConvexRestriction(), which is also called during the rounding stage of SolveShortestPath() given the relaxation. </p>
<p>If not set, the interface at .solver will be used, if provided, otherwise the best solver for the given problem is selected. Note that if the solver cannot handle the type of optimization problem generated, then calling the <a class="el" href="classdrake_1_1solvers_1_1_solver_interface.html#aec933bef2f8c7a702a6fd5c59feac5ec" title="Solves an optimization program with optional initial guess and solver options.">solvers::SolverInterface::Solve()</a> method will throw. </p>

</div>
</div>
<a id="ab41a3270130e638897f5c67f2cae3705" name="ab41a3270130e638897f5c67f2cae3705"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab41a3270130e638897f5c67f2cae3705">&#9670;&#160;</a></span>restriction_solver_options</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;<a class="el" href="structdrake_1_1solvers_1_1_solver_options.html">solvers::SolverOptions</a>&gt; restriction_solver_options</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div>
<div class="line">      std::nullopt}</div>
</div><!-- fragment -->
<p>Optional solver options to be used in SolveConvexRestriction(), which is also used during the rounding stage of SolveShortestPath() given the relaxation. </p>
<p>If not set, solver_options is used. For instance, one might want to set tighter (i.e., lower) tolerances for running the relaxed problem and looser (i.e., higher) tolerances for final solves during rounding. </p>

</div>
</div>
<a id="abb7b16d4d092f7b7572de4c058b30d96" name="abb7b16d4d092f7b7572de4c058b30d96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb7b16d4d092f7b7572de4c058b30d96">&#9670;&#160;</a></span>rounding_seed</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rounding_seed {0}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Random seed to use for random rounding. </p>
<p>If convex_relaxation is false or max_rounded_paths is less than or equal to zero, this option is ignored. </p>

</div>
</div>
<a id="a1717b842ef7560038a1ee8f5076d7721" name="a1717b842ef7560038a1ee8f5076d7721"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1717b842ef7560038a1ee8f5076d7721">&#9670;&#160;</a></span>solver</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1solvers_1_1_solver_interface.html">solvers::SolverInterface</a>* solver {nullptr}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Optimizer to be used to solve the MIP, the relaxation of the shortest path optimization problem and the convex restriction if no restriction_solver is provided. </p>
<p>If not set, the best solver for the given problem is selected. Note that if the solver cannot handle the type of optimization problem generated, the calling <a class="el" href="classdrake_1_1solvers_1_1_solver_interface.html#aec933bef2f8c7a702a6fd5c59feac5ec" title="Solves an optimization program with optional initial guess and solver options.">solvers::SolverInterface::Solve()</a> method will throw. </p>

</div>
</div>
<a id="aa705e1cce16e5f276d9f1ff95851698e" name="aa705e1cce16e5f276d9f1ff95851698e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa705e1cce16e5f276d9f1ff95851698e">&#9670;&#160;</a></span>solver_options</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdrake_1_1solvers_1_1_solver_options.html">solvers::SolverOptions</a> solver_options {}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Options passed to the solver when solving the generated problem. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>drake/geometry/optimization/<a class="el" href="graph__of__convex__sets_8h.html">graph_of_convex_sets.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- footer -->
<div class="navpath">
  <ul>
    <li class="navelem"><a href="namespacedrake.html">drake</a></li><li class="navelem"><a href="namespacedrake_1_1geometry.html">geometry</a></li><li class="navelem"><a href="namespacedrake_1_1geometry_1_1optimization.html">optimization</a></li><li class="navelem"><a href="structdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_options.html">GraphOfConvexSetsOptions</a></li>
  </ul>
</div>
<footer id="nav-path", class="site-footer padding">
  <div class="contain">
    <a href="/" class="drake-logo">
      <img src="/images/drake-logo.svg"/>
    </a>
    <div class="footer-menu">
      <ul>
        <li>
          <a href="https://accessibility.mit.edu/" class="site-menu-item">Accessibility</a>
        </li>
        <li>
          <a href="/doxygen_cxx/index.html" class="site-menu-item">C++</a>
        </li>
        <li>
          <a href="/pydrake/index.html" class="site-menu-item">Python</a>
        </li>
        <li class="github-link">
          <a href="https://github.com/RobotLocomotion/drake" class="site-menu-item">GitHub <img src="/third_party/images/GitHub-Mark-64px.png"/></a>
        </li>
      </ul>
    </div>
  </div>
</footer>
<script type="text/javascript">
searchBox.searchLabel = 'Go to name…';
searchBox.DOMSearchField().placeholder = searchBox.searchLabel;
searchBox.DOMSearchField().value = '';
</script>
</body>
</html>
