<!-- HTML header for doxygen 1.15.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: ConvexSet Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(function() { init_search(); });
</script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@4/tex-chtml.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<header class="site-header">
 <div class="site-header-inner contain">
  <a class="drake-logo" href="/"><img src="/images/drake-logo-white.svg"></a>
  <div class="menu-mobile-toggle">
   <span></span>
  </div>
  <nav class="site-menu">
   <ul>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/">Home</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/installation.html">Installation</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/gallery.html">Gallery</a>
    </li>
    <li class="site-menu-item site-menu-item-main">API Documentation
     <div class="sub">
      <a class="site-menu-item" href="/doxygen_cxx/index.html">C++</a>
      <a class="site-menu-item" href="/pydrake/index.html">Python</a>
     </div>
    </li>
    <li class="site-menu-item site-menu-item-main">Resources
     <div class="sub">
      <a class="site-menu-item" href="/getting_help.html">Getting Help</a>
      <a class="site-menu-item" href="https://deepnote.com/workspace/Drake-0b3b2c53-a7ad-441b-80f8-bf8350752305/project/Tutorials-2b4fc509-aef2-417d-a40d-6071dfed9199/notebook/index-753e3c9d261247ba9f0eb1d7868c18c8">Tutorials</a>
      <a class="site-menu-item" href="/python_bindings.html">Python Bindings</a>
      <a class="site-menu-item" href="/developers.html">For Developers</a>
      <a class="site-menu-item" href="/credits.html">Credits</a>
     </div>
    </li>
    <li class="github-link">
     <a class="site-menu-item" href="https://github.com/RobotLocomotion/drake">GitHub <img src="/third_party/images/GitHub-Mark-Light-64px.png"></a>
    </li>
   </ul>
  </nav>
 </div>
</header>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<div class="title-banner">
 <div class="title-banner__title">
  Drake C++ Documentation
 </div>
 <div id="DDGSearch">
  <form id="search_form_cpp" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search C++ API only…">
   <input type="hidden" name="q" value="site:drake.mit.edu/doxygen_cxx">
  </form>
  <form id="search_form" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search all of Drake…">
   <input type="hidden" name="q" value="site:drake.mit.edu OR site:underactuated.csail.mit.edu OR site:manipulation.csail.mit.edu">
  </form>
 </div>
 <div id="MSearchBoxContainer">
  <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect" class="search-icon" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"><span class="search-icon-dropdown"></span></span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><div id="MSearchCloseImg" class="close-icon"></div></a>
          </span>
        </div>
</td>
 </div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('classdrake_1_1geometry_1_1optimization_1_1_convex_set.html','','classdrake_1_1geometry_1_1optimization_1_1_convex_set-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">ConvexSet Class Reference<span class="mlabels"><span class="mlabel abstract">abstract</span></span><div class="ingroups"><a class="el" href="group__geometry.html">Geometric Representations</a> &#124; <a class="el" href="group__solvers.html">Formulating and Solving Optimization Problems</a> &raquo; <a class="el" href="group__geometry__optimization.html">Geometry Optimization</a></div></div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Abstract base class for defining a convex set. </p>
</div>
<p><code>#include &lt;drake/geometry/optimization/convex_set.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa19f9770fdca8fc14ee1dec1cec39710" id="r_aa19f9770fdca8fc14ee1dec1cec39710"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa19f9770fdca8fc14ee1dec1cec39710">~ConvexSet</a> ()</td></tr>
<tr class="memitem:a0c8001a825e23ebda81c7029a2b40c1a" id="r_a0c8001a825e23ebda81c7029a2b40c1a"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="#aee74f49fab7ccaabd8661e516c7a8d9f">ConvexSet</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c8001a825e23ebda81c7029a2b40c1a">Clone</a> () const</td></tr>
<tr class="memdesc:a0c8001a825e23ebda81c7029a2b40c1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a unique deep copy of this set.  <br /></td></tr>
<tr class="memitem:a79ab6fe34900a8391301b23abd29e10e" id="r_a79ab6fe34900a8391301b23abd29e10e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a79ab6fe34900a8391301b23abd29e10e">ambient_dimension</a> () const</td></tr>
<tr class="memdesc:a79ab6fe34900a8391301b23abd29e10e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dimension of the vector space in which the elements of this set are evaluated.  <br /></td></tr>
<tr class="memitem:a9cf0f6eaece284fabedbab39956a0938" id="r_a9cf0f6eaece284fabedbab39956a0938"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9cf0f6eaece284fabedbab39956a0938">IntersectsWith</a> (const <a class="el" href="#aee74f49fab7ccaabd8661e516c7a8d9f">ConvexSet</a> &amp;other) const</td></tr>
<tr class="memdesc:a9cf0f6eaece284fabedbab39956a0938"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true iff the intersection between <span class="tt">this</span> and <span class="tt">other</span> is non-empty.  <br /></td></tr>
<tr class="memitem:a92797706c9c2adb6329f1dce4c672d59" id="r_a92797706c9c2adb6329f1dce4c672d59"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a92797706c9c2adb6329f1dce4c672d59">IsBounded</a> (<a class="el" href="classdrake_1_1_parallelism.html">Parallelism</a> parallelism=<a class="el" href="classdrake_1_1_parallelism.html#a7eba2010dfc9482ef2ae0bb0539a3083">Parallelism::None</a>()) const</td></tr>
<tr class="memdesc:a92797706c9c2adb6329f1dce4c672d59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true iff the set is bounded, e.g., there exists an element-wise finite lower and upper bound for the set.  <br /></td></tr>
<tr class="memitem:a8e12342fc420701fbffd97025421575a" id="r_a8e12342fc420701fbffd97025421575a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8e12342fc420701fbffd97025421575a">IsEmpty</a> () const</td></tr>
<tr class="memdesc:a8e12342fc420701fbffd97025421575a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true iff the set is empty.  <br /></td></tr>
<tr class="memitem:afe62eaea48eff2737aef1398313791d8" id="r_afe62eaea48eff2737aef1398313791d8"><td class="memItemLeft" align="right" valign="top">std::optional&lt; Eigen::VectorXd &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afe62eaea48eff2737aef1398313791d8">MaybeGetPoint</a> () const</td></tr>
<tr class="memdesc:afe62eaea48eff2737aef1398313791d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">If this set trivially contains exactly one point, returns the value of that point.  <br /></td></tr>
<tr class="memitem:ad2b8b78a4d4110e17a7fd071d8964d33" id="r_ad2b8b78a4d4110e17a7fd071d8964d33"><td class="memItemLeft" align="right" valign="top">std::optional&lt; Eigen::VectorXd &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad2b8b78a4d4110e17a7fd071d8964d33">MaybeGetFeasiblePoint</a> () const</td></tr>
<tr class="memdesc:ad2b8b78a4d4110e17a7fd071d8964d33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a feasible point within this convex set if it is nonempty, and nullopt otherwise.  <br /></td></tr>
<tr class="memitem:aa7a4d7c125954dfde3c15238c852eeed" id="r_aa7a4d7c125954dfde3c15238c852eeed"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa7a4d7c125954dfde3c15238c852eeed">PointInSet</a> (const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;<a class="el" href="light__parameter_8h.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a>, <a class="el" href="classdouble.html">double</a> tol=0) const</td></tr>
<tr class="memdesc:aa7a4d7c125954dfde3c15238c852eeed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true iff the point x is contained in the set.  <br /></td></tr>
<tr class="memitem:a3c7e182d43bdc26c55ca29fc53ae1dcc" id="r_a3c7e182d43bdc26c55ca29fc53ae1dcc"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt;, std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">solvers::Constraint</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3c7e182d43bdc26c55ca29fc53ae1dcc">AddPointInSetConstraints</a> (<a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">solvers::MathematicalProgram</a> *prog, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">solvers::VectorXDecisionVariable</a> &gt; &amp;vars) const</td></tr>
<tr class="memdesc:a3c7e182d43bdc26c55ca29fc53ae1dcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a constraint to an existing MathematicalProgram enforcing that the point defined by vars is inside the set.  <br /></td></tr>
<tr class="memitem:a0acc463e9f56ac02e6098de8168b873e" id="r_a0acc463e9f56ac02e6098de8168b873e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">solvers::Constraint</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0acc463e9f56ac02e6098de8168b873e">AddPointInNonnegativeScalingConstraints</a> (<a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">solvers::MathematicalProgram</a> *prog, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">solvers::VectorXDecisionVariable</a> &gt; &amp;<a class="el" href="light__parameter_8h.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a>, const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;t) const</td></tr>
<tr class="memdesc:a0acc463e9f56ac02e6098de8168b873e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Let S be this convex set.  <br /></td></tr>
<tr class="memitem:a84dfeae30f7a0543e87962568748d0f3" id="r_a84dfeae30f7a0543e87962568748d0f3"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">solvers::Constraint</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a84dfeae30f7a0543e87962568748d0f3">AddPointInNonnegativeScalingConstraints</a> (<a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">solvers::MathematicalProgram</a> *prog, const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;A, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;b, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;c, <a class="el" href="classdouble.html">double</a> d, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">solvers::VectorXDecisionVariable</a> &gt; &amp;<a class="el" href="light__parameter_8h.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a>, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">solvers::VectorXDecisionVariable</a> &gt; &amp;t) const</td></tr>
<tr class="memdesc:a84dfeae30f7a0543e87962568748d0f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Let S be this convex set.  <br /></td></tr>
<tr class="memitem:abe00cd8bd17ed5a5d7cd0cf2f3366237" id="r_abe00cd8bd17ed5a5d7cd0cf2f3366237"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::unique_ptr&lt; <a class="el" href="classdrake_1_1geometry_1_1_shape.html">Shape</a> &gt;, math::RigidTransformd &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abe00cd8bd17ed5a5d7cd0cf2f3366237">ToShapeWithPose</a> () const</td></tr>
<tr class="memdesc:abe00cd8bd17ed5a5d7cd0cf2f3366237"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="classdrake_1_1geometry_1_1_shape.html" title="The abstract base class for all shape specifications.">Shape</a> and a pose of the set in the world frame for use in the <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html" title="SceneGraph serves as the nexus for all geometry (and geometry-based operations) in a Diagram.">SceneGraph</a> geometry ecosystem.  <br /></td></tr>
<tr class="memitem:a7a2847efc4f87e996464d9d71159e27b" id="r_a7a2847efc4f87e996464d9d71159e27b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7a2847efc4f87e996464d9d71159e27b">CalcVolume</a> () const</td></tr>
<tr class="memdesc:a7a2847efc4f87e996464d9d71159e27b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the exact volume for the convex set.  <br /></td></tr>
<tr class="memitem:aea6ff00adfe03e87223d06bd4627d5f8" id="r_aea6ff00adfe03e87223d06bd4627d5f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdrake_1_1geometry_1_1optimization_1_1_sampled_volume.html">SampledVolume</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aea6ff00adfe03e87223d06bd4627d5f8">CalcVolumeViaSampling</a> (<a class="el" href="classdrake_1_1_random_generator.html">RandomGenerator</a> *generator, const <a class="el" href="classdouble.html">double</a> desired_rel_accuracy=1e-2, const int max_num_samples=1e4) const</td></tr>
<tr class="memdesc:aea6ff00adfe03e87223d06bd4627d5f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates an estimate of the volume of the convex set using sampling and performing Monte Carlo integration.  <br /></td></tr>
<tr class="memitem:a992509c1275c106b7dcff56139321ea5" id="r_a992509c1275c106b7dcff56139321ea5"><td class="memItemLeft" align="right" valign="top">std::optional&lt; std::pair&lt; std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt;, Eigen::MatrixXd &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a992509c1275c106b7dcff56139321ea5">Projection</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;points) const</td></tr>
<tr class="memdesc:a992509c1275c106b7dcff56139321ea5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes in the L₂ norm the distance and the nearest point in this convex set to every column of <code class="param">points</code>.  <br /></td></tr>
<tr class="memitem:a7d9beaa673ec9f46fcf52eb4c49b62bd" id="r_a7d9beaa673ec9f46fcf52eb4c49b62bd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7d9beaa673ec9f46fcf52eb4c49b62bd">has_exact_volume</a> () const</td></tr>
<tr class="memdesc:a7d9beaa673ec9f46fcf52eb4c49b62bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the exact volume can be computed for this convex set instance.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pro-methods" class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a54c93f7f5c38bfb4996d8ef9fedf0ba8" id="r_a54c93f7f5c38bfb4996d8ef9fedf0ba8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a54c93f7f5c38bfb4996d8ef9fedf0ba8">ConvexSet</a> (int <a class="el" href="#a79ab6fe34900a8391301b23abd29e10e">ambient_dimension</a>, bool <a class="el" href="#a7d9beaa673ec9f46fcf52eb4c49b62bd">has_exact_volume</a>)</td></tr>
<tr class="memdesc:a54c93f7f5c38bfb4996d8ef9fedf0ba8"><td class="mdescLeft">&#160;</td><td class="mdescRight">For use by derived classes to construct a ConvexSet.  <br /></td></tr>
<tr class="memitem:a8e8824802dedfbc36776227f7482b6bc" id="r_a8e8824802dedfbc36776227f7482b6bc"><td class="memTemplParams" colspan="2">template&lt;typename Archive&gt; </td></tr>
<tr class="memitem:a8e8824802dedfbc36776227f7482b6bc template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8e8824802dedfbc36776227f7482b6bc">Serialize</a> (Archive *a)</td></tr>
<tr class="memdesc:a8e8824802dedfbc36776227f7482b6bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements non-virtual base class serialization.  <br /></td></tr>
<tr class="memitem:a7ba72a6dd8948b14dde65c05f8e26b30" id="r_a7ba72a6dd8948b14dde65c05f8e26b30"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="#aee74f49fab7ccaabd8661e516c7a8d9f">ConvexSet</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7ba72a6dd8948b14dde65c05f8e26b30">DoClone</a> () const =0</td></tr>
<tr class="memdesc:a7ba72a6dd8948b14dde65c05f8e26b30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-virtual interface implementation for <a class="el" href="#a0c8001a825e23ebda81c7029a2b40c1a" title="Creates a unique deep copy of this set.">Clone()</a>.  <br /></td></tr>
<tr class="memitem:a7f61a5972585d2ebae8ff570f2c2d6b7" id="r_a7f61a5972585d2ebae8ff570f2c2d6b7"><td class="memItemLeft" align="right" valign="top">virtual std::optional&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7f61a5972585d2ebae8ff570f2c2d6b7">DoIsBoundedShortcut</a> () const</td></tr>
<tr class="memdesc:a7f61a5972585d2ebae8ff570f2c2d6b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-virtual interface implementation for <a class="el" href="#a7f61a5972585d2ebae8ff570f2c2d6b7" title="Non-virtual interface implementation for DoIsBoundedShortcut().">DoIsBoundedShortcut()</a>.  <br /></td></tr>
<tr class="memitem:a13d92126b09558a9a34cff97018dae80" id="r_a13d92126b09558a9a34cff97018dae80"><td class="memItemLeft" align="right" valign="top">virtual std::optional&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a13d92126b09558a9a34cff97018dae80">DoIsBoundedShortcutParallel</a> (<a class="el" href="classdrake_1_1_parallelism.html">Parallelism</a>) const</td></tr>
<tr class="memdesc:a13d92126b09558a9a34cff97018dae80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-virtual interface implementation for <a class="el" href="#a13d92126b09558a9a34cff97018dae80" title="Non-virtual interface implementation for DoIsBoundedShortcutParallel().">DoIsBoundedShortcutParallel()</a>.  <br /></td></tr>
<tr class="memitem:a2eb84f94ab56b462a9031741aea9e8a9" id="r_a2eb84f94ab56b462a9031741aea9e8a9"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::optional&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2eb84f94ab56b462a9031741aea9e8a9">DoProjectionShortcut</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;points, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; Eigen::MatrixXd &gt; projected_points) const</td></tr>
<tr class="memdesc:a2eb84f94ab56b462a9031741aea9e8a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-virtual interface implementation for <a class="el" href="#a2eb84f94ab56b462a9031741aea9e8a9" title="Non-virtual interface implementation for DoProjectionShortcut().">DoProjectionShortcut()</a>.  <br /></td></tr>
<tr class="memitem:a1cc320d6088c2debb29de0d55001596f" id="r_a1cc320d6088c2debb29de0d55001596f"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1cc320d6088c2debb29de0d55001596f">DoIsEmpty</a> () const</td></tr>
<tr class="memdesc:a1cc320d6088c2debb29de0d55001596f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-virtual interface implementation for <a class="el" href="#a8e12342fc420701fbffd97025421575a" title="Returns true iff the set is empty.">IsEmpty()</a>.  <br /></td></tr>
<tr class="memitem:a3486b063d882588baf0b95a4c93552df" id="r_a3486b063d882588baf0b95a4c93552df"><td class="memItemLeft" align="right" valign="top">virtual std::optional&lt; Eigen::VectorXd &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3486b063d882588baf0b95a4c93552df">DoMaybeGetPoint</a> () const</td></tr>
<tr class="memdesc:a3486b063d882588baf0b95a4c93552df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-virtual interface implementation for <a class="el" href="#afe62eaea48eff2737aef1398313791d8" title="If this set trivially contains exactly one point, returns the value of that point.">MaybeGetPoint()</a>.  <br /></td></tr>
<tr class="memitem:ab02b8eeeb2d5196a8085df35560d02b2" id="r_ab02b8eeeb2d5196a8085df35560d02b2"><td class="memItemLeft" align="right" valign="top">virtual std::optional&lt; Eigen::VectorXd &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab02b8eeeb2d5196a8085df35560d02b2">DoMaybeGetFeasiblePoint</a> () const</td></tr>
<tr class="memdesc:ab02b8eeeb2d5196a8085df35560d02b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-virtual interface implementation for <a class="el" href="#ad2b8b78a4d4110e17a7fd071d8964d33" title="Returns a feasible point within this convex set if it is nonempty, and nullopt otherwise.">MaybeGetFeasiblePoint()</a>.  <br /></td></tr>
<tr class="memitem:a14a06ad1d58722819c3bbd609a59ae33" id="r_a14a06ad1d58722819c3bbd609a59ae33"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a14a06ad1d58722819c3bbd609a59ae33">DoPointInSet</a> (const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;<a class="el" href="light__parameter_8h.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a>, <a class="el" href="classdouble.html">double</a> tol) const</td></tr>
<tr class="memdesc:a14a06ad1d58722819c3bbd609a59ae33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-virtual interface implementation for <a class="el" href="#aa7a4d7c125954dfde3c15238c852eeed" title="Returns true iff the point x is contained in the set.">PointInSet()</a>.  <br /></td></tr>
<tr class="memitem:ae697f7efd2857bf107ccf02be0cac137" id="r_ae697f7efd2857bf107ccf02be0cac137"><td class="memItemLeft" align="right" valign="top">virtual std::optional&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae697f7efd2857bf107ccf02be0cac137">DoPointInSetShortcut</a> (const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;<a class="el" href="light__parameter_8h.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a>, <a class="el" href="classdouble.html">double</a> tol) const</td></tr>
<tr class="memdesc:ae697f7efd2857bf107ccf02be0cac137"><td class="mdescLeft">&#160;</td><td class="mdescRight">A non-virtual interface implementation for <a class="el" href="#aa7a4d7c125954dfde3c15238c852eeed" title="Returns true iff the point x is contained in the set.">PointInSet()</a> that should be used when the <a class="el" href="#aa7a4d7c125954dfde3c15238c852eeed" title="Returns true iff the point x is contained in the set.">PointInSet()</a> can be computed more efficiently than solving a convex program.  <br /></td></tr>
<tr class="memitem:ab1753f634768ec5bd04381c9d38b5476" id="r_ab1753f634768ec5bd04381c9d38b5476"><td class="memItemLeft" align="right" valign="top">virtual std::pair&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt;, std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">solvers::Constraint</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab1753f634768ec5bd04381c9d38b5476">DoAddPointInSetConstraints</a> (<a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">solvers::MathematicalProgram</a> *prog, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">solvers::VectorXDecisionVariable</a> &gt; &amp;vars) const =0</td></tr>
<tr class="memdesc:ab1753f634768ec5bd04381c9d38b5476"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-virtual interface implementation for <a class="el" href="#a3c7e182d43bdc26c55ca29fc53ae1dcc" title="Adds a constraint to an existing MathematicalProgram enforcing that the point defined by vars is insi...">AddPointInSetConstraints()</a>.  <br /></td></tr>
<tr class="memitem:a33e03cf0f694bfc44638581de4cb60c5" id="r_a33e03cf0f694bfc44638581de4cb60c5"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">solvers::Constraint</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a33e03cf0f694bfc44638581de4cb60c5">DoAddPointInNonnegativeScalingConstraints</a> (<a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">solvers::MathematicalProgram</a> *prog, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">solvers::VectorXDecisionVariable</a> &gt; &amp;<a class="el" href="light__parameter_8h.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a>, const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;t) const =0</td></tr>
<tr class="memdesc:a33e03cf0f694bfc44638581de4cb60c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-virtual interface implementation for <a class="el" href="#a0acc463e9f56ac02e6098de8168b873e" title="Let S be this convex set.">AddPointInNonnegativeScalingConstraints()</a>.  <br /></td></tr>
<tr class="memitem:a3d96e30820d1fe8e158bb2088b7b0ed7" id="r_a3d96e30820d1fe8e158bb2088b7b0ed7"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">solvers::Constraint</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d96e30820d1fe8e158bb2088b7b0ed7">DoAddPointInNonnegativeScalingConstraints</a> (<a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">solvers::MathematicalProgram</a> *prog, const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;A, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;b, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;c, <a class="el" href="classdouble.html">double</a> d, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">solvers::VectorXDecisionVariable</a> &gt; &amp;<a class="el" href="light__parameter_8h.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a>, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">solvers::VectorXDecisionVariable</a> &gt; &amp;t) const =0</td></tr>
<tr class="memdesc:a3d96e30820d1fe8e158bb2088b7b0ed7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-virtual interface implementation for <a class="el" href="#a0acc463e9f56ac02e6098de8168b873e" title="Let S be this convex set.">AddPointInNonnegativeScalingConstraints()</a>.  <br /></td></tr>
<tr class="memitem:a8094c3cef008dbb0e6f44ea6a7802d0f" id="r_a8094c3cef008dbb0e6f44ea6a7802d0f"><td class="memItemLeft" align="right" valign="top">virtual std::pair&lt; std::unique_ptr&lt; <a class="el" href="classdrake_1_1geometry_1_1_shape.html">Shape</a> &gt;, math::RigidTransformd &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8094c3cef008dbb0e6f44ea6a7802d0f">DoToShapeWithPose</a> () const =0</td></tr>
<tr class="memdesc:a8094c3cef008dbb0e6f44ea6a7802d0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-virtual interface implementation for <a class="el" href="#abe00cd8bd17ed5a5d7cd0cf2f3366237" title="Constructs a Shape and a pose of the set in the world frame for use in the SceneGraph geometry ecosys...">ToShapeWithPose()</a>.  <br /></td></tr>
<tr class="memitem:af2bcbfea8bf330173c41c6cbe4985361" id="r_af2bcbfea8bf330173c41c6cbe4985361"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af2bcbfea8bf330173c41c6cbe4985361">DoCalcVolume</a> () const</td></tr>
<tr class="memdesc:af2bcbfea8bf330173c41c6cbe4985361"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-virtual interface implementation for <a class="el" href="#a7a2847efc4f87e996464d9d71159e27b" title="Computes the exact volume for the convex set.">CalcVolume()</a>.  <br /></td></tr>
<tr class="memitem:a2bc2f3f2d619431c1a0f9e281b274335" id="r_a2bc2f3f2d619431c1a0f9e281b274335"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2bc2f3f2d619431c1a0f9e281b274335">HandleZeroAmbientDimensionConstraints</a> (<a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">solvers::MathematicalProgram</a> *prog, const <a class="el" href="#aee74f49fab7ccaabd8661e516c7a8d9f">ConvexSet</a> &amp;set, std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">solvers::Constraint</a> &gt; &gt; *constraints) const</td></tr>
<tr class="memdesc:a2bc2f3f2d619431c1a0f9e281b274335"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instances of subclasses such as <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_cartesian_product.html" title="The Cartesian product of convex sets is a convex set: S = X₁ × X₂ × ⋯ × Xₙ = {(x₁,...">CartesianProduct</a> and <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_minkowski_sum.html" title="A convex set that represents the Minkowski sum of multiple sets: S = X₁ ⨁ X₂ ⨁ ......">MinkowskiSum</a> can have constituent sets with zero ambient dimension, which much be handled in a special manner when calling methods such as DoAddPointInSetConstraints.  <br /></td></tr>
<tr class="memitem:adcb6ba7e8203634839aecd3a0c4687a1" id="r_adcb6ba7e8203634839aecd3a0c4687a1"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="#aee74f49fab7ccaabd8661e516c7a8d9f">ConvexSet</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adcb6ba7e8203634839aecd3a0c4687a1">DoAffineHullShortcut</a> (std::optional&lt; <a class="el" href="classdouble.html">double</a> &gt; tol) const</td></tr>
<tr class="memdesc:adcb6ba7e8203634839aecd3a0c4687a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">NVI implementation of DoAffineHullShortcut, which trivially returns null.  <br /></td></tr>
<tr id="pro-methods-0" class="groupHeader"><td colspan="2"><div class="groupHeader">Implements CopyConstructible, CopyAssignable, MoveConstructible, MoveAssignable</div></td></tr>
<tr class="memitem:aee74f49fab7ccaabd8661e516c7a8d9f" id="r_aee74f49fab7ccaabd8661e516c7a8d9f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aee74f49fab7ccaabd8661e516c7a8d9f">ConvexSet</a> (const ConvexSet &amp;)=default</td></tr>
<tr class="memitem:a2db1c4b2b4afbab4ae3b3dbcc2a464ad" id="r_a2db1c4b2b4afbab4ae3b3dbcc2a464ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#aee74f49fab7ccaabd8661e516c7a8d9f">ConvexSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2db1c4b2b4afbab4ae3b3dbcc2a464ad">operator=</a> (const <a class="el" href="#aee74f49fab7ccaabd8661e516c7a8d9f">ConvexSet</a> &amp;)=default</td></tr>
<tr class="memitem:a8070665ccaa5579890f30fa70c1d8137" id="r_a8070665ccaa5579890f30fa70c1d8137"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8070665ccaa5579890f30fa70c1d8137">ConvexSet</a> (ConvexSet &amp;&amp;)=default</td></tr>
<tr class="memitem:ad8c4b75a7ea468d9ae9c053f314c0f03" id="r_ad8c4b75a7ea468d9ae9c053f314c0f03"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#aee74f49fab7ccaabd8661e516c7a8d9f">ConvexSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad8c4b75a7ea468d9ae9c053f314c0f03">operator=</a> (<a class="el" href="#aee74f49fab7ccaabd8661e516c7a8d9f">ConvexSet</a> &amp;&amp;)=default</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pro-static-methods" class="groupheader"><a id="pro-static-methods" name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:aefbe21ab5956cf9f0ab32f7dd635ff82" id="r_aefbe21ab5956cf9f0ab32f7dd635ff82"><td class="memItemLeft" align="right" valign="top">static std::unique_ptr&lt; <a class="el" href="#aee74f49fab7ccaabd8661e516c7a8d9f">ConvexSet</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aefbe21ab5956cf9f0ab32f7dd635ff82">AffineHullShortcut</a> (const <a class="el" href="#aee74f49fab7ccaabd8661e516c7a8d9f">ConvexSet</a> &amp;self, std::optional&lt; <a class="el" href="classdouble.html">double</a> &gt; tol)</td></tr>
<tr class="memdesc:aefbe21ab5956cf9f0ab32f7dd635ff82"><td class="mdescLeft">&#160;</td><td class="mdescRight">When there is a more efficient strategy to compute the affine hull of this set, returns affine hull as an <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_affine_subspace.html" title="An affine subspace (also known as a &quot;flat&quot;, a &quot;linear variety&quot;, or a &quot;linearmanifold&quot;) is a vector su...">AffineSubspace</a>.  <br /></td></tr>
</table>
<a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aa19f9770fdca8fc14ee1dec1cec39710" name="aa19f9770fdca8fc14ee1dec1cec39710"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa19f9770fdca8fc14ee1dec1cec39710">&#9670;&#160;</a></span>~ConvexSet()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ~<a class="el" href="#aee74f49fab7ccaabd8661e516c7a8d9f">ConvexSet</a> </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aee74f49fab7ccaabd8661e516c7a8d9f" name="aee74f49fab7ccaabd8661e516c7a8d9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee74f49fab7ccaabd8661e516c7a8d9f">&#9670;&#160;</a></span>ConvexSet() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ConvexSet </td>
          <td>(</td>
          <td class="paramtype">const ConvexSet &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8070665ccaa5579890f30fa70c1d8137" name="a8070665ccaa5579890f30fa70c1d8137"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8070665ccaa5579890f30fa70c1d8137">&#9670;&#160;</a></span>ConvexSet() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ConvexSet </td>
          <td>(</td>
          <td class="paramtype">ConvexSet &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a54c93f7f5c38bfb4996d8ef9fedf0ba8" name="a54c93f7f5c38bfb4996d8ef9fedf0ba8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54c93f7f5c38bfb4996d8ef9fedf0ba8">&#9670;&#160;</a></span>ConvexSet() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ConvexSet </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ambient_dimension</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>has_exact_volume</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel explicit">explicit</span><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For use by derived classes to construct a ConvexSet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">has_exact_volume</td><td>Derived classes should pass <span class="tt">true</span> if they've implemented <a class="el" href="#af2bcbfea8bf330173c41c6cbe4985361" title="Non-virtual interface implementation for CalcVolume().">DoCalcVolume()</a> to return a value (at least sometimes). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="a84dfeae30f7a0543e87962568748d0f3" name="a84dfeae30f7a0543e87962568748d0f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84dfeae30f7a0543e87962568748d0f3">&#9670;&#160;</a></span>AddPointInNonnegativeScalingConstraints() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">solvers::Constraint</a> &gt; &gt; AddPointInNonnegativeScalingConstraints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">solvers::MathematicalProgram</a> *</td>          <td class="paramname"><span class="paramname"><em>prog</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>d</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">solvers::VectorXDecisionVariable</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">solvers::VectorXDecisionVariable</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Let S be this convex set. </p>
<p>When S is bounded, this method adds the convex constraints to imply </p><pre class="fragment">A * x + b ∈ (c' * t + d) S,
c' * t + d ≥ 0,
</pre><p> where A is an n-by-m matrix (with n the ambient_dimension), b is a vector of size n, c is a vector of size p, x is a point in ℜᵐ, and t is a point in ℜᵖ.</p>
<p>When S is unbounded, then the behavior is almost identical, except when c' * t+d=0. In this case, the constraints imply </p><pre class="fragment">A * x + b ∈ (c' * t + d) S ⊕ rec(S),
c' * t + d ≥ 0,
</pre><p> where rec(S) is the recession cone of S (the asymptotic directions in which S is not bounded) and ⊕ is the Minkowski sum. For c' * t + d &gt; 0, this is equivalent to A * x + b ∈ (c' * t + d) S, but for c' * t + d = 0, we have only A * x + b ∈ rec(S). </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <a class="el" href="#a79ab6fe34900a8391301b23abd29e10e" title="Returns the dimension of the vector space in which the elements of this set are evaluated.">ambient_dimension()</a> == 0 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0acc463e9f56ac02e6098de8168b873e" name="a0acc463e9f56ac02e6098de8168b873e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0acc463e9f56ac02e6098de8168b873e">&#9670;&#160;</a></span>AddPointInNonnegativeScalingConstraints() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">solvers::Constraint</a> &gt; &gt; AddPointInNonnegativeScalingConstraints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">solvers::MathematicalProgram</a> *</td>          <td class="paramname"><span class="paramname"><em>prog</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">solvers::VectorXDecisionVariable</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Let S be this convex set. </p>
<p>When S is bounded, this method adds the convex constraints to imply </p><pre class="fragment">x ∈ t S,
t ≥ 0,
</pre><p> where x is a point in ℜⁿ (with n the ambient_dimension) and t is a scalar.</p>
<p>When S is unbounded, then the behavior is almost identical, except when t=0. In this case, the constraints imply t ≥ 0, x ∈ t S ⊕ rec(S), where rec(S) is the recession cone of S (the asymptotic directions in which S is not bounded) and ⊕ is the Minkowski sum. For t &gt; 0, this is equivalent to x ∈ t S, but for t = 0, we have only x ∈ rec(S). </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <a class="el" href="#a79ab6fe34900a8391301b23abd29e10e" title="Returns the dimension of the vector space in which the elements of this set are evaluated.">ambient_dimension()</a> == 0 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3c7e182d43bdc26c55ca29fc53ae1dcc" name="a3c7e182d43bdc26c55ca29fc53ae1dcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c7e182d43bdc26c55ca29fc53ae1dcc">&#9670;&#160;</a></span>AddPointInSetConstraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt;, std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">solvers::Constraint</a> &gt; &gt; &gt; AddPointInSetConstraints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">solvers::MathematicalProgram</a> *</td>          <td class="paramname"><span class="paramname"><em>prog</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">solvers::VectorXDecisionVariable</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a constraint to an existing MathematicalProgram enforcing that the point defined by vars is inside the set. </p>
<dl class="section return"><dt>Returns</dt><dd>(new_vars, new_constraints) Some of the derived class will add new decision variables to enforce this constraint, we return all the newly added decision variables as new_vars. The meaning of these new decision variables differs in each subclass. If no new variables are added, then we return an empty Eigen vector. Also we return all the newly added constraints to <span class="tt">prog</span> through this function. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <a class="el" href="#a79ab6fe34900a8391301b23abd29e10e" title="Returns the dimension of the vector space in which the elements of this set are evaluated.">ambient_dimension()</a> == 0 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aefbe21ab5956cf9f0ab32f7dd635ff82" name="aefbe21ab5956cf9f0ab32f7dd635ff82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefbe21ab5956cf9f0ab32f7dd635ff82">&#9670;&#160;</a></span>AffineHullShortcut()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="#aee74f49fab7ccaabd8661e516c7a8d9f">ConvexSet</a> &gt; AffineHullShortcut </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#aee74f49fab7ccaabd8661e516c7a8d9f">ConvexSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="classdouble.html">double</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>tol</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>When there is a more efficient strategy to compute the affine hull of this set, returns affine hull as an <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_affine_subspace.html" title="An affine subspace (also known as a &quot;flat&quot;, a &quot;linear variety&quot;, or a &quot;linearmanifold&quot;) is a vector su...">AffineSubspace</a>. </p>
<p>When no efficient conversion exists, returns null. The default base class implementation returns null. This method is used by the <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_affine_subspace.html" title="An affine subspace (also known as a &quot;flat&quot;, a &quot;linear variety&quot;, or a &quot;linearmanifold&quot;) is a vector su...">AffineSubspace</a> constructor to short-circuit the generic iterative approach. (This function is static to allow calling it from the <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_affine_subspace.html" title="An affine subspace (also known as a &quot;flat&quot;, a &quot;linear variety&quot;, or a &quot;linearmanifold&quot;) is a vector su...">AffineSubspace</a> constructor, but is conceptially a normal member function.) The return type is <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_convex_set.html" title="Abstract base class for defining a convex set.">ConvexSet</a> to avoid a forward declaration; any non-null result must always have the <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_affine_subspace.html" title="An affine subspace (also known as a &quot;flat&quot;, a &quot;linear variety&quot;, or a &quot;linearmanifold&quot;) is a vector su...">AffineSubspace</a> as its runtime type. </p>

</div>
</div>
<a id="a79ab6fe34900a8391301b23abd29e10e" name="a79ab6fe34900a8391301b23abd29e10e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79ab6fe34900a8391301b23abd29e10e">&#9670;&#160;</a></span>ambient_dimension()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ambient_dimension </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the dimension of the vector space in which the elements of this set are evaluated. </p>
<p>Contrast this with the <span class="tt">affine dimension</span>: the dimension of the smallest affine subset of the ambient space that contains our set. For example, if we define a set using <span class="tt">A*x = b</span>, where <span class="tt">A</span> has linearly independent rows, then the ambient dimension is the dimension of <span class="tt"><a class="el" href="light__parameter_8h.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a></span>, but the affine dimension of the set is <span class="tt"><a class="el" href="#a79ab6fe34900a8391301b23abd29e10e" title="Returns the dimension of the vector space in which the elements of this set are evaluated.">ambient_dimension()</a> - rank(A)</span>. </p>

</div>
</div>
<a id="a7a2847efc4f87e996464d9d71159e27b" name="a7a2847efc4f87e996464d9d71159e27b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a2847efc4f87e996464d9d71159e27b">&#9670;&#160;</a></span>CalcVolume()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> CalcVolume </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the exact volume for the convex set. </p>
<dl class="section note"><dt>Note</dt><dd>Not every convex set can report an exact volume. In that case, use <a class="el" href="#aea6ff00adfe03e87223d06bd4627d5f8" title="Calculates an estimate of the volume of the convex set using sampling and performing Monte Carlo inte...">CalcVolumeViaSampling()</a> instead. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <span class="tt"><a class="el" href="#a7d9beaa673ec9f46fcf52eb4c49b62bd" title="Returns true if the exact volume can be computed for this convex set instance.">has_exact_volume()</a></span> returns <span class="tt">false</span>. </td></tr>
    <tr><td class="paramname">if</td><td><a class="el" href="#a79ab6fe34900a8391301b23abd29e10e" title="Returns the dimension of the vector space in which the elements of this set are evaluated.">ambient_dimension()</a> == 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aea6ff00adfe03e87223d06bd4627d5f8" name="aea6ff00adfe03e87223d06bd4627d5f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea6ff00adfe03e87223d06bd4627d5f8">&#9670;&#160;</a></span>CalcVolumeViaSampling()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdrake_1_1geometry_1_1optimization_1_1_sampled_volume.html">SampledVolume</a> CalcVolumeViaSampling </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_random_generator.html">RandomGenerator</a> *</td>          <td class="paramname"><span class="paramname"><em>generator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>desired_rel_accuracy</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1e-2</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>max_num_samples</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1e4</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates an estimate of the volume of the convex set using sampling and performing Monte Carlo integration. </p>
<dl class="section note"><dt>Note</dt><dd>this method is intended to be used for low to moderate dimensions (d&lt;15). For larger dimensions, a telescopic product approach has yet to be implemented. See, e.g., <a href="https://proceedings.mlr.press/v151/chevallier22a/chevallier22a.pdf">https://proceedings.mlr.press/v151/chevallier22a/chevallier22a.pdf</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">generator</td><td>a random number generator. </td></tr>
    <tr><td class="paramname">desired_rel_accuracy</td><td>the desired relative accuracy of the volume estimate in the sense that the estimated volume is likely to be within the interval defined by (1±2*desired_rel_accuracy)*true_volume with probability of at least* 0.95 according to the Law of Large Numbers. <a href="https://people.math.umass.edu/~lr7q/ps_files/teaching/math456/Chapter6.pdf">https://people.math.umass.edu/~lr7q/ps_files/teaching/math456/Chapter6.pdf</a> The computation will terminate when the relative error is less than rel_accuracy or when the maximum number of samples is reached. </td></tr>
    <tr><td class="paramname">max_num_samples</td><td>the maximum number of samples to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><span class="tt">desired_rel_accuracy</span> is in the range [0,1]. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a pair the estimated volume of the set and an upper bound for the relative accuracy </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">if</td><td><a class="el" href="#a79ab6fe34900a8391301b23abd29e10e" title="Returns the dimension of the vector space in which the elements of this set are evaluated.">ambient_dimension()</a> == 0. </td></tr>
    <tr><td class="paramname">if</td><td>the minimum axis-aligned bounding box of the set cannot be computed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0c8001a825e23ebda81c7029a2b40c1a" name="a0c8001a825e23ebda81c7029a2b40c1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c8001a825e23ebda81c7029a2b40c1a">&#9670;&#160;</a></span>Clone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="#aee74f49fab7ccaabd8661e516c7a8d9f">ConvexSet</a> &gt; Clone </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a unique deep copy of this set. </p>

</div>
</div>
<a id="a3d96e30820d1fe8e158bb2088b7b0ed7" name="a3d96e30820d1fe8e158bb2088b7b0ed7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d96e30820d1fe8e158bb2088b7b0ed7">&#9670;&#160;</a></span>DoAddPointInNonnegativeScalingConstraints() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">solvers::Constraint</a> &gt; &gt; DoAddPointInNonnegativeScalingConstraints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">solvers::MathematicalProgram</a> *</td>          <td class="paramname"><span class="paramname"><em>prog</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>d</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">solvers::VectorXDecisionVariable</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">solvers::VectorXDecisionVariable</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Non-virtual interface implementation for <a class="el" href="#a0acc463e9f56ac02e6098de8168b873e" title="Let S be this convex set.">AddPointInNonnegativeScalingConstraints()</a>. </p>
<p>Subclasses must override to add the constraints needed to keep the point A * x + b in the non-negative scaling of the set. Note that subclasses do not need to add the constraint c * t + d ≥ 0 as it is already added. </p><dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="#a79ab6fe34900a8391301b23abd29e10e" title="Returns the dimension of the vector space in which the elements of this set are evaluated.">ambient_dimension()</a> &gt; 0 </dd>
<dd>
A.rows() == <a class="el" href="#a79ab6fe34900a8391301b23abd29e10e" title="Returns the dimension of the vector space in which the elements of this set are evaluated.">ambient_dimension()</a> </dd>
<dd>
A.rows() == b.rows() </dd>
<dd>
A.cols() == x.size() </dd>
<dd>
c.rows() == t.size() </dd></dl>

</div>
</div>
<a id="a33e03cf0f694bfc44638581de4cb60c5" name="a33e03cf0f694bfc44638581de4cb60c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33e03cf0f694bfc44638581de4cb60c5">&#9670;&#160;</a></span>DoAddPointInNonnegativeScalingConstraints() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">solvers::Constraint</a> &gt; &gt; DoAddPointInNonnegativeScalingConstraints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">solvers::MathematicalProgram</a> *</td>          <td class="paramname"><span class="paramname"><em>prog</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">solvers::VectorXDecisionVariable</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Non-virtual interface implementation for <a class="el" href="#a0acc463e9f56ac02e6098de8168b873e" title="Let S be this convex set.">AddPointInNonnegativeScalingConstraints()</a>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>x.size() == <a class="el" href="#a79ab6fe34900a8391301b23abd29e10e" title="Returns the dimension of the vector space in which the elements of this set are evaluated.">ambient_dimension()</a> </dd>
<dd>
<a class="el" href="#a79ab6fe34900a8391301b23abd29e10e" title="Returns the dimension of the vector space in which the elements of this set are evaluated.">ambient_dimension()</a> &gt; 0 </dd></dl>

</div>
</div>
<a id="ab1753f634768ec5bd04381c9d38b5476" name="ab1753f634768ec5bd04381c9d38b5476"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1753f634768ec5bd04381c9d38b5476">&#9670;&#160;</a></span>DoAddPointInSetConstraints()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::pair&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt;, std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">solvers::Constraint</a> &gt; &gt; &gt; DoAddPointInSetConstraints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">solvers::MathematicalProgram</a> *</td>          <td class="paramname"><span class="paramname"><em>prog</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">solvers::VectorXDecisionVariable</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Non-virtual interface implementation for <a class="el" href="#a3c7e182d43bdc26c55ca29fc53ae1dcc" title="Adds a constraint to an existing MathematicalProgram enforcing that the point defined by vars is insi...">AddPointInSetConstraints()</a>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>vars.size() == <a class="el" href="#a79ab6fe34900a8391301b23abd29e10e" title="Returns the dimension of the vector space in which the elements of this set are evaluated.">ambient_dimension()</a> </dd>
<dd>
<a class="el" href="#a79ab6fe34900a8391301b23abd29e10e" title="Returns the dimension of the vector space in which the elements of this set are evaluated.">ambient_dimension()</a> &gt; 0 </dd></dl>

</div>
</div>
<a id="adcb6ba7e8203634839aecd3a0c4687a1" name="adcb6ba7e8203634839aecd3a0c4687a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcb6ba7e8203634839aecd3a0c4687a1">&#9670;&#160;</a></span>DoAffineHullShortcut()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt; <a class="el" href="#aee74f49fab7ccaabd8661e516c7a8d9f">ConvexSet</a> &gt; DoAffineHullShortcut </td>
          <td>(</td>
          <td class="paramtype">std::optional&lt; <a class="el" href="classdouble.html">double</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>tol</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>NVI implementation of DoAffineHullShortcut, which trivially returns null. </p>
<p>Derived classes that have efficient algorithms should override this method. </p>

</div>
</div>
<a id="af2bcbfea8bf330173c41c6cbe4985361" name="af2bcbfea8bf330173c41c6cbe4985361"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2bcbfea8bf330173c41c6cbe4985361">&#9670;&#160;</a></span>DoCalcVolume()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdouble.html">double</a> DoCalcVolume </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Non-virtual interface implementation for <a class="el" href="#a7a2847efc4f87e996464d9d71159e27b" title="Computes the exact volume for the convex set.">CalcVolume()</a>. </p>
<p>This will <em>only</em> be called if <a class="el" href="#a7d9beaa673ec9f46fcf52eb4c49b62bd" title="Returns true if the exact volume can be computed for this convex set instance.">has_exact_volume()</a> returns true and <a class="el" href="#a79ab6fe34900a8391301b23abd29e10e" title="Returns the dimension of the vector space in which the elements of this set are evaluated.">ambient_dimension()</a> &gt; 0 </p>

</div>
</div>
<a id="a7ba72a6dd8948b14dde65c05f8e26b30" name="a7ba72a6dd8948b14dde65c05f8e26b30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ba72a6dd8948b14dde65c05f8e26b30">&#9670;&#160;</a></span>DoClone()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt; <a class="el" href="#aee74f49fab7ccaabd8661e516c7a8d9f">ConvexSet</a> &gt; DoClone </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Non-virtual interface implementation for <a class="el" href="#a0c8001a825e23ebda81c7029a2b40c1a" title="Creates a unique deep copy of this set.">Clone()</a>. </p>

</div>
</div>
<a id="a7f61a5972585d2ebae8ff570f2c2d6b7" name="a7f61a5972585d2ebae8ff570f2c2d6b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f61a5972585d2ebae8ff570f2c2d6b7">&#9670;&#160;</a></span>DoIsBoundedShortcut()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::optional&lt; bool &gt; DoIsBoundedShortcut </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Non-virtual interface implementation for <a class="el" href="#a7f61a5972585d2ebae8ff570f2c2d6b7" title="Non-virtual interface implementation for DoIsBoundedShortcut().">DoIsBoundedShortcut()</a>. </p>
<p>Trivially returns std::nullopt. This allows a derived class to implement its own boundedness checks, to potentially avoid the more expensive base class checks. </p><dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="#a79ab6fe34900a8391301b23abd29e10e" title="Returns the dimension of the vector space in which the elements of this set are evaluated.">ambient_dimension()</a> &gt;= 0 </dd></dl>

</div>
</div>
<a id="a13d92126b09558a9a34cff97018dae80" name="a13d92126b09558a9a34cff97018dae80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13d92126b09558a9a34cff97018dae80">&#9670;&#160;</a></span>DoIsBoundedShortcutParallel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::optional&lt; bool &gt; DoIsBoundedShortcutParallel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_parallelism.html">Parallelism</a></td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Non-virtual interface implementation for <a class="el" href="#a13d92126b09558a9a34cff97018dae80" title="Non-virtual interface implementation for DoIsBoundedShortcutParallel().">DoIsBoundedShortcutParallel()</a>. </p>
<p>Trivially returns std::nullopt. This allows a derived class to implement its own boundedness checks that leverage parallelization, to potentially avoid the more expensive base class checks. </p><dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="#a79ab6fe34900a8391301b23abd29e10e" title="Returns the dimension of the vector space in which the elements of this set are evaluated.">ambient_dimension()</a> &gt;= 0 </dd></dl>

</div>
</div>
<a id="a1cc320d6088c2debb29de0d55001596f" name="a1cc320d6088c2debb29de0d55001596f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cc320d6088c2debb29de0d55001596f">&#9670;&#160;</a></span>DoIsEmpty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool DoIsEmpty </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Non-virtual interface implementation for <a class="el" href="#a8e12342fc420701fbffd97025421575a" title="Returns true iff the set is empty.">IsEmpty()</a>. </p>
<p>The default implementation solves a feasibility optimization problem, but derived classes can override with a custom (more efficient) implementation. Zero-dimensional sets are considered to be nonempty by default. Sets which can be zero-dimensional and empty must handle this behavior in their derived implementation of DoIsEmpty. </p>

</div>
</div>
<a id="ab02b8eeeb2d5196a8085df35560d02b2" name="ab02b8eeeb2d5196a8085df35560d02b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab02b8eeeb2d5196a8085df35560d02b2">&#9670;&#160;</a></span>DoMaybeGetFeasiblePoint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::optional&lt; Eigen::VectorXd &gt; DoMaybeGetFeasiblePoint </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Non-virtual interface implementation for <a class="el" href="#ad2b8b78a4d4110e17a7fd071d8964d33" title="Returns a feasible point within this convex set if it is nonempty, and nullopt otherwise.">MaybeGetFeasiblePoint()</a>. </p>
<p>The default implementation solves a feasibility optimization problem, but derived classes can override with a custom (more efficient) implementation. </p>

</div>
</div>
<a id="a3486b063d882588baf0b95a4c93552df" name="a3486b063d882588baf0b95a4c93552df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3486b063d882588baf0b95a4c93552df">&#9670;&#160;</a></span>DoMaybeGetPoint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::optional&lt; Eigen::VectorXd &gt; DoMaybeGetPoint </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Non-virtual interface implementation for <a class="el" href="#afe62eaea48eff2737aef1398313791d8" title="If this set trivially contains exactly one point, returns the value of that point.">MaybeGetPoint()</a>. </p>
<p>The default implementation returns nullopt. Sets that can model a single point should override with a custom implementation. </p><dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="#a79ab6fe34900a8391301b23abd29e10e" title="Returns the dimension of the vector space in which the elements of this set are evaluated.">ambient_dimension()</a> &gt;= 0. </dd></dl>

</div>
</div>
<a id="a14a06ad1d58722819c3bbd609a59ae33" name="a14a06ad1d58722819c3bbd609a59ae33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14a06ad1d58722819c3bbd609a59ae33">&#9670;&#160;</a></span>DoPointInSet()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool DoPointInSet </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>tol</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Non-virtual interface implementation for <a class="el" href="#aa7a4d7c125954dfde3c15238c852eeed" title="Returns true iff the point x is contained in the set.">PointInSet()</a>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>x.size() == <a class="el" href="#a79ab6fe34900a8391301b23abd29e10e" title="Returns the dimension of the vector space in which the elements of this set are evaluated.">ambient_dimension()</a> </dd>
<dd>
<a class="el" href="#a79ab6fe34900a8391301b23abd29e10e" title="Returns the dimension of the vector space in which the elements of this set are evaluated.">ambient_dimension()</a> &gt;= 0 </dd></dl>

</div>
</div>
<a id="ae697f7efd2857bf107ccf02be0cac137" name="ae697f7efd2857bf107ccf02be0cac137"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae697f7efd2857bf107ccf02be0cac137">&#9670;&#160;</a></span>DoPointInSetShortcut()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::optional&lt; bool &gt; DoPointInSetShortcut </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>tol</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A non-virtual interface implementation for <a class="el" href="#aa7a4d7c125954dfde3c15238c852eeed" title="Returns true iff the point x is contained in the set.">PointInSet()</a> that should be used when the <a class="el" href="#aa7a4d7c125954dfde3c15238c852eeed" title="Returns true iff the point x is contained in the set.">PointInSet()</a> can be computed more efficiently than solving a convex program. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if and only if x is known to be in the set. Returns false if and only if x is known to not be in the set. Returns std::nullopt if a shortcut implementation is not provided (i.e. the method has not elected to decide whether the point x is in the set).</dd></dl>
<p>For example, membership in a <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_v_polytope.html" title="A polytope described using the vertex representation.">VPolytope</a> cannot be verified without solving a linear program and so no shortcut implementation should be provided. On the other hand, membership in an <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_h_polyhedron.html" title="Implements a polyhedral convex set using the half-space representation: {x| A x ≤ b}...">HPolyhedron</a> can be checked by checking the inequality Ax ≤ b and so a shortcut is possible. </p>

</div>
</div>
<a id="a2eb84f94ab56b462a9031741aea9e8a9" name="a2eb84f94ab56b462a9031741aea9e8a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eb84f94ab56b462a9031741aea9e8a9">&#9670;&#160;</a></span>DoProjectionShortcut()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt; std::optional&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt; DoProjectionShortcut </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>points</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; Eigen::MatrixXd &gt;</td>          <td class="paramname"><span class="paramname"><em>projected_points</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Non-virtual interface implementation for <a class="el" href="#a2eb84f94ab56b462a9031741aea9e8a9" title="Non-virtual interface implementation for DoProjectionShortcut().">DoProjectionShortcut()</a>. </p>
<p>This allows a derived class to implement a method which computes the projection of some, but not necessarily all, of the <code class="param">points</code> more efficiently than the generic implementation.</p>
<p>The default implementation checks whether each column of <code class="param">points</code> is in the set using DoPointInSetShortcut. Points in the set are given a distance of 0 and are projected to themselves.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">points</td><td>are the points which we wish to project to the convex set. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">projected_points</td><td>are the projection of <code class="param">points</code> onto the convex set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector <span class="tt">distances</span> which is the same size as <code class="param">points.cols()</code>.These are the distances from <code class="param">points</code> to the convex set. If distances[i] has a value, then projected_points-&gt;col(i) is the projection of points.col(i) onto the set. If distances[i] is nullopt, then the projection of points.col(i) has not yet been computed, and so the value at projected_points-&gt;col(i) is meaningless.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="#a79ab6fe34900a8391301b23abd29e10e" title="Returns the dimension of the vector space in which the elements of this set are evaluated.">ambient_dimension()</a> &gt;= 0 </dd>
<dd>
distances.size() == points.cols() </dd></dl>

</div>
</div>
<a id="a8094c3cef008dbb0e6f44ea6a7802d0f" name="a8094c3cef008dbb0e6f44ea6a7802d0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8094c3cef008dbb0e6f44ea6a7802d0f">&#9670;&#160;</a></span>DoToShapeWithPose()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::pair&lt; std::unique_ptr&lt; <a class="el" href="classdrake_1_1geometry_1_1_shape.html">Shape</a> &gt;, math::RigidTransformd &gt; DoToShapeWithPose </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Non-virtual interface implementation for <a class="el" href="#abe00cd8bd17ed5a5d7cd0cf2f3366237" title="Constructs a Shape and a pose of the set in the world frame for use in the SceneGraph geometry ecosys...">ToShapeWithPose()</a>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="#a79ab6fe34900a8391301b23abd29e10e" title="Returns the dimension of the vector space in which the elements of this set are evaluated.">ambient_dimension()</a> == 3 </dd></dl>

</div>
</div>
<a id="a2bc2f3f2d619431c1a0f9e281b274335" name="a2bc2f3f2d619431c1a0f9e281b274335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bc2f3f2d619431c1a0f9e281b274335">&#9670;&#160;</a></span>HandleZeroAmbientDimensionConstraints()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt; HandleZeroAmbientDimensionConstraints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">solvers::MathematicalProgram</a> *</td>          <td class="paramname"><span class="paramname"><em>prog</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#aee74f49fab7ccaabd8661e516c7a8d9f">ConvexSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>set</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">solvers::Constraint</a> &gt; &gt; *</td>          <td class="paramname"><span class="paramname"><em>constraints</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Instances of subclasses such as <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_cartesian_product.html" title="The Cartesian product of convex sets is a convex set: S = X₁ × X₂ × ⋯ × Xₙ = {(x₁,...">CartesianProduct</a> and <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_minkowski_sum.html" title="A convex set that represents the Minkowski sum of multiple sets: S = X₁ ⨁ X₂ ⨁ ......">MinkowskiSum</a> can have constituent sets with zero ambient dimension, which much be handled in a special manner when calling methods such as DoAddPointInSetConstraints. </p>
<p>If the set is empty, a trivially infeasible constraint must be added. We also warn the user when this happens, since they probably didn't intend it to occur. If the set is nonempty, then it's the unique zero-dimensional vector space {0}, and no additional variables or constraints are needed. If a new variable is created, return it, to optionally be stored (as in AddPointInSetConstraints), or not be stored (as in DoAddPointInNonnegativeScalingConstraints). </p>

</div>
</div>
<a id="a7d9beaa673ec9f46fcf52eb4c49b62bd" name="a7d9beaa673ec9f46fcf52eb4c49b62bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d9beaa673ec9f46fcf52eb4c49b62bd">&#9670;&#160;</a></span>has_exact_volume()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool has_exact_volume </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the exact volume can be computed for this convex set instance. </p>
<dl class="section note"><dt>Note</dt><dd>This value reasons about to the generic case of the convex set class rather than the specific instance of the convex set. For example, the exact volume of a box is trivival to compute, but if the box is created as a <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_h_polyhedron.html" title="Implements a polyhedral convex set using the half-space representation: {x| A x ≤ b}...">HPolyhedron</a>, then the exact volume cannot be computed. </dd></dl>

</div>
</div>
<a id="a9cf0f6eaece284fabedbab39956a0938" name="a9cf0f6eaece284fabedbab39956a0938"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cf0f6eaece284fabedbab39956a0938">&#9670;&#160;</a></span>IntersectsWith()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IntersectsWith </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#aee74f49fab7ccaabd8661e516c7a8d9f">ConvexSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true iff the intersection between <span class="tt">this</span> and <span class="tt">other</span> is non-empty. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the ambient dimension of <span class="tt">other</span> is not the same as that of <span class="tt">this</span>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a92797706c9c2adb6329f1dce4c672d59" name="a92797706c9c2adb6329f1dce4c672d59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92797706c9c2adb6329f1dce4c672d59">&#9670;&#160;</a></span>IsBounded()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IsBounded </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_parallelism.html">Parallelism</a></td>          <td class="paramname"><span class="paramname"><em>parallelism</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classdrake_1_1_parallelism.html#a7eba2010dfc9482ef2ae0bb0539a3083">Parallelism::None</a>()</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true iff the set is bounded, e.g., there exists an element-wise finite lower and upper bound for the set. </p>
<p>Note: for some derived classes, this check is trivial, but for others it can require solving a number of (typically small) optimization problems. Each derived class documents the cost of its boundedness test and whether it honors the request for parallelism. (Derived classes which do not have a specialized check will, by default, honor parallelism requests.) Note that the overhead of multithreading may lead to slower runtimes for simple, low-dimensional sets, but can enable major speedups for more challenging problems.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parallelism</td><td>requests the number of cores to use when solving mathematical programs to check boundedness, subject to whether a particular derived class honors parallelism. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8e12342fc420701fbffd97025421575a" name="a8e12342fc420701fbffd97025421575a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e12342fc420701fbffd97025421575a">&#9670;&#160;</a></span>IsEmpty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IsEmpty </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true iff the set is empty. </p>
<p>Note: for some derived classes, this check is trivial, but for others, it can require solving a (typically small) optimization problem. Check the derived class documentation for any notes. Zero-dimensional sets must be handled specially. There are two possible sets in a zero-dimensional space &ndash; the empty set, and the whole set (which is simply the "zero vector space", {0}.) For more details, see: <a href="https://en.wikipedia.org/wiki/Examples_of_vector_spaces#Trivial_or_zero_vector_space">https://en.wikipedia.org/wiki/Examples_of_vector_spaces#Trivial_or_zero_vector_space</a> Zero-dimensional sets are considered to be nonempty by default. Sets which can be zero-dimensional and empty must handle this behavior in their derived implementation of DoIsEmpty. An example of such a subclass is <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_v_polytope.html" title="A polytope described using the vertex representation.">VPolytope</a>. </p>

</div>
</div>
<a id="ad2b8b78a4d4110e17a7fd071d8964d33" name="ad2b8b78a4d4110e17a7fd071d8964d33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2b8b78a4d4110e17a7fd071d8964d33">&#9670;&#160;</a></span>MaybeGetFeasiblePoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; Eigen::VectorXd &gt; MaybeGetFeasiblePoint </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a feasible point within this convex set if it is nonempty, and nullopt otherwise. </p>

</div>
</div>
<a id="afe62eaea48eff2737aef1398313791d8" name="afe62eaea48eff2737aef1398313791d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe62eaea48eff2737aef1398313791d8">&#9670;&#160;</a></span>MaybeGetPoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; Eigen::VectorXd &gt; MaybeGetPoint </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If this set trivially contains exactly one point, returns the value of that point. </p>
<p>Otherwise, returns nullopt. By "trivially", we mean that representation of the set structurally maps to a single point; if checking for point-ness would require solving an optimization program, returns nullopt. In other words, this is a relatively cheap function to call. </p>

</div>
</div>
<a id="a2db1c4b2b4afbab4ae3b3dbcc2a464ad" name="a2db1c4b2b4afbab4ae3b3dbcc2a464ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2db1c4b2b4afbab4ae3b3dbcc2a464ad">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#aee74f49fab7ccaabd8661e516c7a8d9f">ConvexSet</a> &amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#aee74f49fab7ccaabd8661e516c7a8d9f">ConvexSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad8c4b75a7ea468d9ae9c053f314c0f03" name="ad8c4b75a7ea468d9ae9c053f314c0f03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8c4b75a7ea468d9ae9c053f314c0f03">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#aee74f49fab7ccaabd8661e516c7a8d9f">ConvexSet</a> &amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#aee74f49fab7ccaabd8661e516c7a8d9f">ConvexSet</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa7a4d7c125954dfde3c15238c852eeed" name="aa7a4d7c125954dfde3c15238c852eeed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7a4d7c125954dfde3c15238c852eeed">&#9670;&#160;</a></span>PointInSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PointInSet </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>tol</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true iff the point x is contained in the set. </p>
<p>If the ambient dimension is zero, then if the set is nonempty, the point is trivially in the set, and if the set is empty, the point is trivially not in the set. </p>

</div>
</div>
<a id="a992509c1275c106b7dcff56139321ea5" name="a992509c1275c106b7dcff56139321ea5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a992509c1275c106b7dcff56139321ea5">&#9670;&#160;</a></span>Projection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; std::pair&lt; std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt;, Eigen::MatrixXd &gt; &gt; Projection </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>points</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes in the L₂ norm the distance and the nearest point in this convex set to every column of <code class="param">points</code>. </p>
<p>If this set is empty, we return nullopt. </p><dl class="section pre"><dt>Precondition</dt><dd>points.rows() == <a class="el" href="#a79ab6fe34900a8391301b23abd29e10e" title="Returns the dimension of the vector space in which the elements of this set are evaluated.">ambient_dimension()</a>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">if</td><td>the internal convex optimization solver fails. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8e8824802dedfbc36776227f7482b6bc" name="a8e8824802dedfbc36776227f7482b6bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e8824802dedfbc36776227f7482b6bc">&#9670;&#160;</a></span>Serialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Archive&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Serialize </td>
          <td>(</td>
          <td class="paramtype">Archive *</td>          <td class="paramname"><span class="paramname"><em>a</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements non-virtual base class serialization. </p>

</div>
</div>
<a id="abe00cd8bd17ed5a5d7cd0cf2f3366237" name="abe00cd8bd17ed5a5d7cd0cf2f3366237"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe00cd8bd17ed5a5d7cd0cf2f3366237">&#9670;&#160;</a></span>ToShapeWithPose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::unique_ptr&lt; <a class="el" href="classdrake_1_1geometry_1_1_shape.html">Shape</a> &gt;, math::RigidTransformd &gt; ToShapeWithPose </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a <a class="el" href="classdrake_1_1geometry_1_1_shape.html" title="The abstract base class for all shape specifications.">Shape</a> and a pose of the set in the world frame for use in the <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html" title="SceneGraph serves as the nexus for all geometry (and geometry-based operations) in a Diagram.">SceneGraph</a> geometry ecosystem. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <a class="el" href="#a79ab6fe34900a8391301b23abd29e10e" title="Returns the dimension of the vector space in which the elements of this set are evaluated.">ambient_dimension()</a> != 3 or if the functionality for a particular set has not been implemented yet. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>drake/geometry/optimization/<a class="el" href="convex__set_8h.html">convex_set.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- footer -->
<div class="navpath">
  <ul>
    <li class="navelem"><a href="namespacedrake.html">drake</a></li><li class="navelem"><a href="namespacedrake_1_1geometry.html">geometry</a></li><li class="navelem"><a href="namespacedrake_1_1geometry_1_1optimization.html">optimization</a></li><li class="navelem"><a href="classdrake_1_1geometry_1_1optimization_1_1_convex_set.html">ConvexSet</a></li>
  </ul>
</div>
<footer id="nav-path", class="site-footer padding">
  <div class="contain">
    <a href="/" class="drake-logo">
      <img src="/images/drake-logo.svg"/>
    </a>
    <div class="footer-menu">
      <ul>    
        <li>
          <a href="/doxygen_cxx/index.html" class="site-menu-item">C++</a>
        </li>    
        <li>
          <a href="/pydrake/index.html" class="site-menu-item">Python</a>
        </li>
        <li class="github-link">
          <a href="https://github.com/RobotLocomotion/drake" class="site-menu-item">GitHub <img src="/third_party/images/GitHub-Mark-64px.png"/></a>
        </li>
      </ul>
    </div>
  </div>
</footer>
<script type="text/javascript">
searchBox.searchLabel = 'Go to name…';
searchBox.DOMSearchField().placeholder = searchBox.searchLabel;
searchBox.DOMSearchField().value = '';
</script>
</body>
</html>
