<!-- HTML header for doxygen 1.15.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: KinematicTrajectoryOptimization Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(function() { init_search(); });
</script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@4/tex-chtml.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<header class="site-header">
 <div class="site-header-inner contain">
  <a class="drake-logo" href="/"><img src="/images/drake-logo-white.svg"></a>
  <div class="menu-mobile-toggle">
   <span></span>
  </div>
  <nav class="site-menu">
   <ul>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/">Home</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/installation.html">Installation</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/gallery.html">Gallery</a>
    </li>
    <li class="site-menu-item site-menu-item-main">API Documentation
     <div class="sub">
      <a class="site-menu-item" href="/doxygen_cxx/index.html">C++</a>
      <a class="site-menu-item" href="/pydrake/index.html">Python</a>
     </div>
    </li>
    <li class="site-menu-item site-menu-item-main">Resources
     <div class="sub">
      <a class="site-menu-item" href="/getting_help.html">Getting Help</a>
      <a class="site-menu-item" href="https://deepnote.com/workspace/Drake-0b3b2c53-a7ad-441b-80f8-bf8350752305/project/Tutorials-2b4fc509-aef2-417d-a40d-6071dfed9199/notebook/index-753e3c9d261247ba9f0eb1d7868c18c8">Tutorials</a>
      <a class="site-menu-item" href="/python_bindings.html">Python Bindings</a>
      <a class="site-menu-item" href="/developers.html">For Developers</a>
      <a class="site-menu-item" href="/credits.html">Credits</a>
     </div>
    </li>
    <li class="github-link">
     <a class="site-menu-item" href="https://github.com/RobotLocomotion/drake">GitHub <img src="/third_party/images/GitHub-Mark-Light-64px.png"></a>
    </li>
   </ul>
  </nav>
 </div>
</header>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<div class="title-banner">
 <div class="title-banner__title">
  Drake C++ Documentation
 </div>
 <div id="DDGSearch">
  <form id="search_form_cpp" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search C++ API only…">
   <input type="hidden" name="q" value="site:drake.mit.edu/doxygen_cxx">
  </form>
  <form id="search_form" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search all of Drake…">
   <input type="hidden" name="q" value="site:drake.mit.edu OR site:underactuated.csail.mit.edu OR site:manipulation.csail.mit.edu">
  </form>
 </div>
 <div id="MSearchBoxContainer">
  <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect" class="search-icon" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"><span class="search-icon-dropdown"></span></span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><div id="MSearchCloseImg" class="close-icon"></div></a>
          </span>
        </div>
</td>
 </div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('classdrake_1_1planning_1_1trajectory__optimization_1_1_kinematic_trajectory_optimization.html','','classdrake_1_1planning_1_1trajectory__optimization_1_1_kinematic_trajectory_optimization-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">KinematicTrajectoryOptimization Class Reference<div class="ingroups"><a class="el" href="group__algorithms.html">Algorithms</a> &raquo; <a class="el" href="group__planning.html">Planning</a> &raquo; <a class="el" href="group__planning__trajectory.html">Trajectories</a></div></div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Optimizes a trajectory, q(t) subject to costs and constraints on the trajectory and its derivatives. </p>
<p>This is accomplished using a <span class="tt">path</span>, r(s), represented as a BsplineTrajectory on the interval s∈[0,1], and a separate duration, T, which maps [0,1] =&gt; [0,T].</p>
<p>The q(t) trajectory is commonly associated with, for instance, the generalized positions of a MultibodyPlant by adding multibody costs and constraints; in this case take note that the velocities in this optimization are q̇(t), not v(t).</p>
<p>Use <a class="el" href="namespacedrake_1_1solvers.html#ae34d0e7febfca6328561574df6ce91d5" title="Solves an optimization program, with optional initial guess and solver options.">solvers::Solve</a> to solve the problem. A typical use case could look like: </p><pre class="fragment">  KinematicTrajectoryOptimization trajopt(2, 10);
  // add costs and constraints
  trajopt.SetInitialGuess(...);
  auto result = solvers::Solve(trajopt.prog());
  auto traj = trajopt.ReconstructTrajectory(result);
</pre><p>When possible this class attempts to formulate convex forms of the costs and constraints. </p>
</div>
<p><code>#include &lt;drake/planning/trajectory_optimization/kinematic_trajectory_optimization.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa04be32847a0a206b2ae988625279139" id="r_aa04be32847a0a206b2ae988625279139"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa04be32847a0a206b2ae988625279139">KinematicTrajectoryOptimization</a> (int <a class="el" href="#aba2887f0ca1fbbdfb49cf6b0ee21e553">num_positions</a>, int <a class="el" href="#a7bf41e0881035d3f5e879b99ff8fc4c5">num_control_points</a>, int spline_order=4, double <a class="el" href="#a547a1ad03a99c89ba67180e4752e1969">duration</a>=1.0)</td></tr>
<tr class="memdesc:aa04be32847a0a206b2ae988625279139"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an optimization problem for a position trajectory represented as a B-spline.  <br /></td></tr>
<tr class="memitem:a65363bc4338584a02f119b225ae1cc98" id="r_a65363bc4338584a02f119b225ae1cc98"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a65363bc4338584a02f119b225ae1cc98">KinematicTrajectoryOptimization</a> (const <a class="el" href="classdrake_1_1trajectories_1_1_bspline_trajectory.html">trajectories::BsplineTrajectory</a>&lt; double &gt; &amp;trajectory)</td></tr>
<tr class="memdesc:a65363bc4338584a02f119b225ae1cc98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an optimization problem for a trajectory represented by a B-spline with the same order and number of control points as <span class="tt">trajectory</span>.  <br /></td></tr>
<tr class="memitem:aba2887f0ca1fbbdfb49cf6b0ee21e553" id="r_aba2887f0ca1fbbdfb49cf6b0ee21e553"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aba2887f0ca1fbbdfb49cf6b0ee21e553">num_positions</a> () const</td></tr>
<tr class="memdesc:aba2887f0ca1fbbdfb49cf6b0ee21e553"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of position variables.  <br /></td></tr>
<tr class="memitem:a7bf41e0881035d3f5e879b99ff8fc4c5" id="r_a7bf41e0881035d3f5e879b99ff8fc4c5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7bf41e0881035d3f5e879b99ff8fc4c5">num_control_points</a> () const</td></tr>
<tr class="memdesc:a7bf41e0881035d3f5e879b99ff8fc4c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of control points used for the path.  <br /></td></tr>
<tr class="memitem:a73b974ae81bfa6e07ecc82d94697305a" id="r_a73b974ae81bfa6e07ecc82d94697305a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1math_1_1_bspline_basis.html">math::BsplineBasis</a>&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a73b974ae81bfa6e07ecc82d94697305a">basis</a> () const</td></tr>
<tr class="memdesc:a73b974ae81bfa6e07ecc82d94697305a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the basis used to represent the path, r(s), over s∈[0,1].  <br /></td></tr>
<tr class="memitem:a410a2ee65236f6dd126caf713fce53ae" id="r_a410a2ee65236f6dd126caf713fce53ae"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacedrake_1_1solvers.html#a85b6a5d80d5e24442bca8472b116c22a">solvers::MatrixXDecisionVariable</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a410a2ee65236f6dd126caf713fce53ae">control_points</a> () const</td></tr>
<tr class="memdesc:a410a2ee65236f6dd126caf713fce53ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the control points defining the path as an M-by-N matrix, where M is the number of positions and N is the number of control points.  <br /></td></tr>
<tr class="memitem:a547a1ad03a99c89ba67180e4752e1969" id="r_a547a1ad03a99c89ba67180e4752e1969"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a547a1ad03a99c89ba67180e4752e1969">duration</a> () const</td></tr>
<tr class="memdesc:a547a1ad03a99c89ba67180e4752e1969"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the decision variable defining the time duration of the trajectory.  <br /></td></tr>
<tr class="memitem:ab54111eab638313c328fc0a0f1b50944" id="r_ab54111eab638313c328fc0a0f1b50944"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">solvers::MathematicalProgram</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab54111eab638313c328fc0a0f1b50944">prog</a> () const</td></tr>
<tr class="memdesc:ab54111eab638313c328fc0a0f1b50944"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for the optimization program.  <br /></td></tr>
<tr class="memitem:afbb6e35083b07855fa7f22826828da2f" id="r_afbb6e35083b07855fa7f22826828da2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">solvers::MathematicalProgram</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afbb6e35083b07855fa7f22826828da2f">get_mutable_prog</a> ()</td></tr>
<tr class="memdesc:afbb6e35083b07855fa7f22826828da2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for a mutable pointer to the optimization program.  <br /></td></tr>
<tr class="memitem:a8375ea48a9fad7145ae1d2e97d851f76" id="r_a8375ea48a9fad7145ae1d2e97d851f76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8375ea48a9fad7145ae1d2e97d851f76">SetInitialGuess</a> (const <a class="el" href="classdrake_1_1trajectories_1_1_bspline_trajectory.html">trajectories::BsplineTrajectory</a>&lt; double &gt; &amp;trajectory)</td></tr>
<tr class="memdesc:a8375ea48a9fad7145ae1d2e97d851f76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the initial guess for the path and duration to match <span class="tt">trajectory</span>.  <br /></td></tr>
<tr class="memitem:a90b718bdee7102d5950bea095fa94e60" id="r_a90b718bdee7102d5950bea095fa94e60"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1trajectories_1_1_bspline_trajectory.html">trajectories::BsplineTrajectory</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a90b718bdee7102d5950bea095fa94e60">ReconstructTrajectory</a> (const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program_result.html">solvers::MathematicalProgramResult</a> &amp;result) const</td></tr>
<tr class="memdesc:a90b718bdee7102d5950bea095fa94e60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the trajectory q(t) from the <span class="tt">result</span> of solving <span class="tt"><a class="el" href="#ab54111eab638313c328fc0a0f1b50944" title="Getter for the optimization program.">prog()</a></span>.  <br /></td></tr>
<tr class="memitem:ab144c56fabc3f5cea958181840f99f4e" id="r_ab144c56fabc3f5cea958181840f99f4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">solvers::LinearConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab144c56fabc3f5cea958181840f99f4e">AddPathPositionConstraint</a> (const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;lb, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;ub, double s)</td></tr>
<tr class="memdesc:ab144c56fabc3f5cea958181840f99f4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a linear constraint on the value of the path, <span class="tt">lb</span> ≤ r(s) ≤ <span class="tt">ub</span>.  <br /></td></tr>
<tr class="memitem:a35d691dd287b93ff5e9f68707563701b" id="r_a35d691dd287b93ff5e9f68707563701b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">solvers::Constraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a35d691dd287b93ff5e9f68707563701b">AddPathPositionConstraint</a> (const std::shared_ptr&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">solvers::Constraint</a> &gt; &amp;constraint, double s)</td></tr>
<tr class="memdesc:a35d691dd287b93ff5e9f68707563701b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a (generic) constraint on path.  <br /></td></tr>
<tr class="memitem:a5b48b2c100068ad213dfaf0e19986faf" id="r_a5b48b2c100068ad213dfaf0e19986faf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">solvers::LinearConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5b48b2c100068ad213dfaf0e19986faf">AddPathVelocityConstraint</a> (const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;lb, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;ub, double s)</td></tr>
<tr class="memdesc:a5b48b2c100068ad213dfaf0e19986faf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a linear constraint on the derivative of the path, <span class="tt">lb</span> ≤ ṙ(s) ≤ <span class="tt">ub</span>.  <br /></td></tr>
<tr class="memitem:a43801547f1677abcf0de7d7d1ee8dc4b" id="r_a43801547f1677abcf0de7d7d1ee8dc4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">solvers::Constraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a43801547f1677abcf0de7d7d1ee8dc4b">AddVelocityConstraintAtNormalizedTime</a> (const std::shared_ptr&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">solvers::Constraint</a> &gt; &amp;constraint, double s)</td></tr>
<tr class="memdesc:a43801547f1677abcf0de7d7d1ee8dc4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a (generic) constraint on trajectory velocity <span class="tt">q̇(t)</span>, evaluated at <span class="tt">s</span>.  <br /></td></tr>
<tr class="memitem:a0d57d91263a430533e9babd7a73211a1" id="r_a0d57d91263a430533e9babd7a73211a1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">solvers::LinearConstraint</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0d57d91263a430533e9babd7a73211a1">AddVelocityConstraintAtNormalizedTime</a> (const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">solvers::LinearConstraint</a> &gt; &amp;binding, double s)</td></tr>
<tr class="memdesc:a0d57d91263a430533e9babd7a73211a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a linear constraint on some (or all) of the placeholder variables qdot, evaluated at a normalized time s.  <br /></td></tr>
<tr class="memitem:a31a3c72f735461c7622476e28754d5f3" id="r_a31a3c72f735461c7622476e28754d5f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">solvers::LinearConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a31a3c72f735461c7622476e28754d5f3">AddPathAccelerationConstraint</a> (const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;lb, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;ub, double s)</td></tr>
<tr class="memdesc:a31a3c72f735461c7622476e28754d5f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a linear constraint on the second derivative of the path, <span class="tt">lb</span> ≤ r̈(s) ≤ <span class="tt">ub</span>.  <br /></td></tr>
<tr class="memitem:a8785696e2d8d0a6f30845ac80fde4b27" id="r_a8785696e2d8d0a6f30845ac80fde4b27"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_bounding_box_constraint.html">solvers::BoundingBoxConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8785696e2d8d0a6f30845ac80fde4b27">AddDurationConstraint</a> (std::optional&lt; double &gt; lb, std::optional&lt; double &gt; ub)</td></tr>
<tr class="memdesc:a8785696e2d8d0a6f30845ac80fde4b27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds bounding box constraints for upper and lower bounds on the duration of the trajectory.  <br /></td></tr>
<tr class="memitem:a36e23f8a438167947988b7c082907c2a" id="r_a36e23f8a438167947988b7c082907c2a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_bounding_box_constraint.html">solvers::BoundingBoxConstraint</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a36e23f8a438167947988b7c082907c2a">AddPositionBounds</a> (const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;lb, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;ub)</td></tr>
<tr class="memdesc:a36e23f8a438167947988b7c082907c2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds bounding box constraints to enforce upper and lower bounds on the positions trajectory, q(t).  <br /></td></tr>
<tr class="memitem:aed08aae38972ec133809090aa133ea10" id="r_aed08aae38972ec133809090aa133ea10"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">solvers::LinearConstraint</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aed08aae38972ec133809090aa133ea10">AddVelocityBounds</a> (const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;lb, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;ub)</td></tr>
<tr class="memdesc:aed08aae38972ec133809090aa133ea10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds linear constraints to enforce upper and lower bounds on the velocity trajectory, q̇(t).  <br /></td></tr>
<tr class="memitem:acd5b41fa974bb1fb073a42178cecc45a" id="r_acd5b41fa974bb1fb073a42178cecc45a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">solvers::Constraint</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acd5b41fa974bb1fb073a42178cecc45a">AddAccelerationBounds</a> (const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;lb, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;ub)</td></tr>
<tr class="memdesc:acd5b41fa974bb1fb073a42178cecc45a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds generic (nonlinear) constraints to enforce the upper and lower bounds to the acceleration trajectory, q̈(t).  <br /></td></tr>
<tr class="memitem:a9721f85fae74ed570dc85096d6d9b779" id="r_a9721f85fae74ed570dc85096d6d9b779"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">solvers::Constraint</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9721f85fae74ed570dc85096d6d9b779">AddJerkBounds</a> (const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;lb, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;ub)</td></tr>
<tr class="memdesc:a9721f85fae74ed570dc85096d6d9b779"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds generic (nonlinear) constraints to enforce the upper and lower bounds to the jerk trajectory, d³qdt³(t).  <br /></td></tr>
<tr class="memitem:aab47bd9333d1cbefaac78563fd7d3ddd" id="r_aab47bd9333d1cbefaac78563fd7d3ddd"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">solvers::Constraint</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aab47bd9333d1cbefaac78563fd7d3ddd">AddEffortBoundsAtNormalizedTimes</a> (const <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html">multibody::MultibodyPlant</a>&lt; double &gt; &amp;plant, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;s, const std::optional&lt; Eigen::Ref&lt; const Eigen::VectorXd &gt; &gt; &amp;lb=std::nullopt, const std::optional&lt; Eigen::Ref&lt; const Eigen::VectorXd &gt; &gt; &amp;ub=std::nullopt, const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; double &gt; *plant_context=nullptr)</td></tr>
<tr class="memdesc:aab47bd9333d1cbefaac78563fd7d3ddd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds generic (nonlinear) constraints to enforce the effort limits defined in the plant at a sequence of normalized times, <span class="tt">s</span>:  <br /></td></tr>
<tr class="memitem:a88aa7e7d75be81f025c98af1b9674765" id="r_a88aa7e7d75be81f025c98af1b9674765"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_cost.html">solvers::LinearCost</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a88aa7e7d75be81f025c98af1b9674765">AddDurationCost</a> (double weight=1.0)</td></tr>
<tr class="memdesc:a88aa7e7d75be81f025c98af1b9674765"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a linear cost on the duration of the trajectory.  <br /></td></tr>
<tr class="memitem:ad62654e6dc2f0373af7c9751f42987d2" id="r_ad62654e6dc2f0373af7c9751f42987d2"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_cost.html">solvers::Cost</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad62654e6dc2f0373af7c9751f42987d2">AddPathLengthCost</a> (double weight=1.0, bool use_conic_constraint=false)</td></tr>
<tr class="memdesc:ad62654e6dc2f0373af7c9751f42987d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a cost on an upper bound of the length of the path, ∫₀ᵀ |q̇(t)|₂ dt, or equivalently ∫₀¹ |ṙ(s)|₂ ds, by summing the distance between the path control points.  <br /></td></tr>
<tr class="memitem:a981e5edc1bfcd187292f9aa01447a8e9" id="r_a981e5edc1bfcd187292f9aa01447a8e9"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_cost.html">solvers::Cost</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a981e5edc1bfcd187292f9aa01447a8e9">AddPathEnergyCost</a> (double weight=1.0)</td></tr>
<tr class="memdesc:a981e5edc1bfcd187292f9aa01447a8e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a convex quadratic cost on an upper bound on the energy of the path, ∫₀¹ |ṙ(s)|₂² ds, by summing the squared distance between the path control points.  <br /></td></tr>
<tr class="memitem:ab7195dc538a2b08a98243e5f24e06bd1" id="r_ab7195dc538a2b08a98243e5f24e06bd1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab7195dc538a2b08a98243e5f24e06bd1">q</a> () const</td></tr>
<tr class="memdesc:ab7195dc538a2b08a98243e5f24e06bd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the placeholder variable for generalized position q.  <br /></td></tr>
<tr class="memitem:adfadf8b11c8358c081d7cf426d4fc8a7" id="r_adfadf8b11c8358c081d7cf426d4fc8a7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adfadf8b11c8358c081d7cf426d4fc8a7">qdot</a> () const</td></tr>
<tr class="memdesc:adfadf8b11c8358c081d7cf426d4fc8a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the placeholder variable for the time derivative of generalized position.  <br /></td></tr>
<tr class="memitem:a6747e458d8ecd6e52e04280744e6568c" id="r_a6747e458d8ecd6e52e04280744e6568c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6747e458d8ecd6e52e04280744e6568c">qddot</a> () const</td></tr>
<tr class="memdesc:a6747e458d8ecd6e52e04280744e6568c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the placeholder variable for the second time derivative of generalized position.  <br /></td></tr>
<tr id="pub-methods-0" class="groupHeader"><td colspan="2"><div class="groupHeader">Does not allow copy, move, or assignment</div></td></tr>
<tr class="memitem:a9a8474ae1e7ce1dab9a404fd6e6f6054" id="r_a9a8474ae1e7ce1dab9a404fd6e6f6054"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9a8474ae1e7ce1dab9a404fd6e6f6054">KinematicTrajectoryOptimization</a> (const KinematicTrajectoryOptimization &amp;)=delete</td></tr>
<tr class="memitem:a6bb3abdee0564a91c3e88aae256ab784" id="r_a6bb3abdee0564a91c3e88aae256ab784"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a9a8474ae1e7ce1dab9a404fd6e6f6054">KinematicTrajectoryOptimization</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6bb3abdee0564a91c3e88aae256ab784">operator=</a> (const <a class="el" href="#a9a8474ae1e7ce1dab9a404fd6e6f6054">KinematicTrajectoryOptimization</a> &amp;)=delete</td></tr>
<tr class="memitem:a2776d8c1a2ba6628d4b0870c76967c28" id="r_a2776d8c1a2ba6628d4b0870c76967c28"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2776d8c1a2ba6628d4b0870c76967c28">KinematicTrajectoryOptimization</a> (KinematicTrajectoryOptimization &amp;&amp;)=delete</td></tr>
<tr class="memitem:a1a212a6703b180dae3bfdc09d4aab07a" id="r_a1a212a6703b180dae3bfdc09d4aab07a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a9a8474ae1e7ce1dab9a404fd6e6f6054">KinematicTrajectoryOptimization</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a212a6703b180dae3bfdc09d4aab07a">operator=</a> (<a class="el" href="#a9a8474ae1e7ce1dab9a404fd6e6f6054">KinematicTrajectoryOptimization</a> &amp;&amp;)=delete</td></tr>
</table>
<a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a9a8474ae1e7ce1dab9a404fd6e6f6054" name="a9a8474ae1e7ce1dab9a404fd6e6f6054"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a8474ae1e7ce1dab9a404fd6e6f6054">&#9670;&#160;</a></span>KinematicTrajectoryOptimization() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">KinematicTrajectoryOptimization </td>
          <td>(</td>
          <td class="paramtype">const KinematicTrajectoryOptimization &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2776d8c1a2ba6628d4b0870c76967c28" name="a2776d8c1a2ba6628d4b0870c76967c28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2776d8c1a2ba6628d4b0870c76967c28">&#9670;&#160;</a></span>KinematicTrajectoryOptimization() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">KinematicTrajectoryOptimization </td>
          <td>(</td>
          <td class="paramtype">KinematicTrajectoryOptimization &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa04be32847a0a206b2ae988625279139" name="aa04be32847a0a206b2ae988625279139"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa04be32847a0a206b2ae988625279139">&#9670;&#160;</a></span>KinematicTrajectoryOptimization() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">KinematicTrajectoryOptimization </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num_positions</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num_control_points</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>spline_order</em></span><span class="paramdefsep"> = </span><span class="paramdefval">4</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>duration</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1.0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs an optimization problem for a position trajectory represented as a B-spline. </p>
<p>The initial guess is the zero trajectory over the time interval [0, T]. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_positions</td><td>The number of rows in the B-spline. </td></tr>
    <tr><td class="paramname">num_control_points</td><td>The number of B-spline control points. </td></tr>
    <tr><td class="paramname">spline_order</td><td>The order of the B-spline. </td></tr>
    <tr><td class="paramname">duration</td><td>The duration (in seconds) of the initial guess. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a65363bc4338584a02f119b225ae1cc98" name="a65363bc4338584a02f119b225ae1cc98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65363bc4338584a02f119b225ae1cc98">&#9670;&#160;</a></span>KinematicTrajectoryOptimization() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">KinematicTrajectoryOptimization </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1trajectories_1_1_bspline_trajectory.html">trajectories::BsplineTrajectory</a>&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>trajectory</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an optimization problem for a trajectory represented by a B-spline with the same order and number of control points as <span class="tt">trajectory</span>. </p>
<p>Additionally sets <span class="tt">trajectory</span> as the initial guess for the optimization. </p>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="acd5b41fa974bb1fb073a42178cecc45a" name="acd5b41fa974bb1fb073a42178cecc45a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd5b41fa974bb1fb073a42178cecc45a">&#9670;&#160;</a></span>AddAccelerationBounds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">solvers::Constraint</a> &gt; &gt; AddAccelerationBounds </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ub</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds generic (nonlinear) constraints to enforce the upper and lower bounds to the acceleration trajectory, q̈(t). </p>
<p>By leveraging the convex hull property of B-splines, these bounds are applied at the (derivative) control points, but will be respected for all times, t ∈ [0,T]. Note that this does NOT directly constrain r̈(s).</p>
<dl class="section return"><dt>Returns</dt><dd>A vector of bindings with interleaved lower and then upper bounds, constraining all of the control points for one element of q̈ (e.g. the acceleration of the ith joint at all times). However, this specific interpretation of these constraints may change without deprecation. </dd></dl>

</div>
</div>
<a id="a8785696e2d8d0a6f30845ac80fde4b27" name="a8785696e2d8d0a6f30845ac80fde4b27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8785696e2d8d0a6f30845ac80fde4b27">&#9670;&#160;</a></span>AddDurationConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_bounding_box_constraint.html">solvers::BoundingBoxConstraint</a> &gt; AddDurationConstraint </td>
          <td>(</td>
          <td class="paramtype">std::optional&lt; double &gt;</td>          <td class="paramname"><span class="paramname"><em>lb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; double &gt;</td>          <td class="paramname"><span class="paramname"><em>ub</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds bounding box constraints for upper and lower bounds on the duration of the trajectory. </p>

</div>
</div>
<a id="a88aa7e7d75be81f025c98af1b9674765" name="a88aa7e7d75be81f025c98af1b9674765"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88aa7e7d75be81f025c98af1b9674765">&#9670;&#160;</a></span>AddDurationCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_cost.html">solvers::LinearCost</a> &gt; AddDurationCost </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>weight</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1.0</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a linear cost on the duration of the trajectory. </p>

</div>
</div>
<a id="aab47bd9333d1cbefaac78563fd7d3ddd" name="aab47bd9333d1cbefaac78563fd7d3ddd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab47bd9333d1cbefaac78563fd7d3ddd">&#9670;&#160;</a></span>AddEffortBoundsAtNormalizedTimes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">solvers::Constraint</a> &gt; &gt; AddEffortBoundsAtNormalizedTimes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html">multibody::MultibodyPlant</a>&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>plant</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::optional&lt; Eigen::Ref&lt; const Eigen::VectorXd &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lb</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::nullopt</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::optional&lt; Eigen::Ref&lt; const Eigen::VectorXd &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ub</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::nullopt</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; double &gt; *</td>          <td class="paramname"><span class="paramname"><em>plant_context</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds generic (nonlinear) constraints to enforce the effort limits defined in the plant at a sequence of normalized times, <span class="tt">s</span>: </p>
<pre class="fragment">B lb ≤ M(q)v̇ + C(q, v)v - τ_g(q) - τ_app ≤ B ub
</pre><p> where q, v, and v̇ are evaluated at s. B is the plant's actuation matrix, and M, C, τ_g, and τ_app are the plant's mass matrix, Coriolis force, gravity, and applied force, respectively. <span class="tt">ub</span> and <span class="tt">lb</span> are the upper and lower effort bounds, respectively; if they are not provided then plant.GetEffortLowerLimits() and plant.GetEffortUpperLimits() are used.</p>
<p>Pass <span class="tt">plant_context</span> if you have non-default parameters in the context. Note that there are no lifetime requirements on <span class="tt">plant</span> nor <span class="tt">plant_context</span>.</p>
<p>Note that the convex hull property of the B-splines is not guaranteed to hold here &ndash; effort limits maybe be violated away from the normalized times <span class="tt">s</span>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>plant.is_finalized() </dd>
<dd>
plant.num_positions() == <a class="el" href="#aba2887f0ca1fbbdfb49cf6b0ee21e553" title="Returns the number of position variables.">num_positions()</a> </dd>
<dd>
plant.IsVelocityEqualToQDot() == true </dd>
<dd>
s[i] ∈ [0, 1] for all i </dd>
<dd>
B lb ≤ B ub</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of bindings with one effort limit constraint for each <span class="tt">s</span>. </dd></dl>

</div>
</div>
<a id="a9721f85fae74ed570dc85096d6d9b779" name="a9721f85fae74ed570dc85096d6d9b779"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9721f85fae74ed570dc85096d6d9b779">&#9670;&#160;</a></span>AddJerkBounds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">solvers::Constraint</a> &gt; &gt; AddJerkBounds </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ub</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds generic (nonlinear) constraints to enforce the upper and lower bounds to the jerk trajectory, d³qdt³(t). </p>
<p>By leveraging the convex hull property of B-splines, these bounds are applied at the (derivative) control points, but will be respected for all times, t ∈ [0,T]. Note that this does NOT directly constrain d³rds³(s).</p>
<dl class="section return"><dt>Returns</dt><dd>A vector of bindings with interleaved lower and then upper bounds, constraining all of the control points for one element of d³qdt³ (e.g. the jerk of the ith joint at all times). However, this specific interpretation of these constraints may change without deprecation. </dd></dl>

</div>
</div>
<a id="a31a3c72f735461c7622476e28754d5f3" name="a31a3c72f735461c7622476e28754d5f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31a3c72f735461c7622476e28754d5f3">&#9670;&#160;</a></span>AddPathAccelerationConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">solvers::LinearConstraint</a> &gt; AddPathAccelerationConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ub</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>s</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a linear constraint on the second derivative of the path, <span class="tt">lb</span> ≤ r̈(s) ≤ <span class="tt">ub</span>. </p>
<p>Note that this does NOT directly constrain q̈(t). </p><dl class="section pre"><dt>Precondition</dt><dd>0 &lt;= <span class="tt">s</span> &lt;= 1. </dd></dl>

</div>
</div>
<a id="a981e5edc1bfcd187292f9aa01447a8e9" name="a981e5edc1bfcd187292f9aa01447a8e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a981e5edc1bfcd187292f9aa01447a8e9">&#9670;&#160;</a></span>AddPathEnergyCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_cost.html">solvers::Cost</a> &gt; &gt; AddPathEnergyCost </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>weight</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1.0</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a convex quadratic cost on an upper bound on the energy of the path, ∫₀¹ |ṙ(s)|₂² ds, by summing the squared distance between the path control points. </p>
<p>In the limit of infinitely many control points, minimizers for AddPathLengthCost and AddPathEnergyCost will follow the same path, but potentially with different timing. They may have different values if additional costs and constraints are imposed. This cost yields simpler gradients than AddPathLengthCost, and biases the control points towards being evenly spaced.</p>
<dl class="section return"><dt>Returns</dt><dd>A vector of bindings with the ith element adding a cost to the ith control point of the velocity trajectory. However, this specific interpretation of these constraints may change without deprecation. </dd></dl>

</div>
</div>
<a id="ad62654e6dc2f0373af7c9751f42987d2" name="ad62654e6dc2f0373af7c9751f42987d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad62654e6dc2f0373af7c9751f42987d2">&#9670;&#160;</a></span>AddPathLengthCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_cost.html">solvers::Cost</a> &gt; &gt; AddPathLengthCost </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>weight</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1.0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>use_conic_constraint</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a cost on an upper bound of the length of the path, ∫₀ᵀ |q̇(t)|₂ dt, or equivalently ∫₀¹ |ṙ(s)|₂ ds, by summing the distance between the path control points. </p>
<p>If <span class="tt">use_conic_constraint = false</span>, then costs are added via MathematicalProgram::AddL2NormCost; otherwise they are added via MathematicalProgram::AddL2NormCostUsingConicConstraint.</p>
<dl class="section return"><dt>Returns</dt><dd>A vector of bindings with the ith element adding a cost to the ith control point of the velocity trajectory. However, this specific interpretation of these constraints may change without deprecation. </dd></dl>

</div>
</div>
<a id="ab144c56fabc3f5cea958181840f99f4e" name="ab144c56fabc3f5cea958181840f99f4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab144c56fabc3f5cea958181840f99f4e">&#9670;&#160;</a></span>AddPathPositionConstraint() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">solvers::LinearConstraint</a> &gt; AddPathPositionConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ub</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>s</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a linear constraint on the value of the path, <span class="tt">lb</span> ≤ r(s) ≤ <span class="tt">ub</span>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>0 &lt;= <span class="tt">s</span> &lt;= 1. </dd></dl>

</div>
</div>
<a id="a35d691dd287b93ff5e9f68707563701b" name="a35d691dd287b93ff5e9f68707563701b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35d691dd287b93ff5e9f68707563701b">&#9670;&#160;</a></span>AddPathPositionConstraint() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">solvers::Constraint</a> &gt; AddPathPositionConstraint </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">solvers::Constraint</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>constraint</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>s</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a (generic) constraint on path. </p>
<p>The constraint will be evaluated as if it is bound with variables corresponding to <span class="tt">r(s)</span>. </p><dl class="section pre"><dt>Precondition</dt><dd>constraint.num_vars() == <a class="el" href="#aba2887f0ca1fbbdfb49cf6b0ee21e553" title="Returns the number of position variables.">num_positions()</a> </dd>
<dd>
0 &lt;= <span class="tt">s</span> &lt;= 1. </dd></dl>

</div>
</div>
<a id="a5b48b2c100068ad213dfaf0e19986faf" name="a5b48b2c100068ad213dfaf0e19986faf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b48b2c100068ad213dfaf0e19986faf">&#9670;&#160;</a></span>AddPathVelocityConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">solvers::LinearConstraint</a> &gt; AddPathVelocityConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ub</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>s</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a linear constraint on the derivative of the path, <span class="tt">lb</span> ≤ ṙ(s) ≤ <span class="tt">ub</span>. </p>
<p>Note that this does NOT directly constrain q̇(t). </p><dl class="section pre"><dt>Precondition</dt><dd>0 &lt;= <span class="tt">s</span> &lt;= 1. </dd></dl>

</div>
</div>
<a id="a36e23f8a438167947988b7c082907c2a" name="a36e23f8a438167947988b7c082907c2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36e23f8a438167947988b7c082907c2a">&#9670;&#160;</a></span>AddPositionBounds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_bounding_box_constraint.html">solvers::BoundingBoxConstraint</a> &gt; &gt; AddPositionBounds </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ub</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds bounding box constraints to enforce upper and lower bounds on the positions trajectory, q(t). </p>
<p>These bounds will be respected at all times, t∈[0,T]. This also implies the constraints are satisfied for r(s), for all s∈[0,1].</p>
<dl class="section return"><dt>Returns</dt><dd>A vector of bindings with the ith element adding a constraint to the ith control point. However, this specific interpretation of these constraints may change without deprecation. </dd></dl>

</div>
</div>
<a id="aed08aae38972ec133809090aa133ea10" name="aed08aae38972ec133809090aa133ea10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed08aae38972ec133809090aa133ea10">&#9670;&#160;</a></span>AddVelocityBounds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">solvers::LinearConstraint</a> &gt; &gt; AddVelocityBounds </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ub</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds linear constraints to enforce upper and lower bounds on the velocity trajectory, q̇(t). </p>
<p>By leveraging the convex hull property of B-splines, these bounds are applied at the (derivative) control points, but will be respected for all times, t ∈ [0,T]. Note this does NOT directly constrain ṙ(s).</p>
<dl class="section return"><dt>Returns</dt><dd>A vector of bindings with interleaved lower and then upper bounds, constraining all of the control points for one element of q̇ (e.g. the velocity of the ith joint at all times). However, this specific interpretation of these constraints may change without deprecation.. </dd></dl>

</div>
</div>
<a id="a0d57d91263a430533e9babd7a73211a1" name="a0d57d91263a430533e9babd7a73211a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d57d91263a430533e9babd7a73211a1">&#9670;&#160;</a></span>AddVelocityConstraintAtNormalizedTime() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">solvers::LinearConstraint</a> &gt; &gt; AddVelocityConstraintAtNormalizedTime </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">solvers::LinearConstraint</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>binding</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>s</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a linear constraint on some (or all) of the placeholder variables qdot, evaluated at a normalized time s. </p>
<dl class="section pre"><dt>Precondition</dt><dd>binding Can only associate with <a class="el" href="#adfadf8b11c8358c081d7cf426d4fc8a7" title="Returns the placeholder variable for the time derivative of generalized position.">qdot()</a>. </dd>
<dd>
0 &lt;= <span class="tt">s</span> &lt;= 1.</dd></dl>
<div class="fragment"><div class="line">Binding&lt;LinearConstraint&gt; b(LinearConstraint(A, b), trajopt.qdot());</div>
<div class="line">trajopt.AddVelocityConstraintAtNormalizedTime(b, 0);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a43801547f1677abcf0de7d7d1ee8dc4b" name="a43801547f1677abcf0de7d7d1ee8dc4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43801547f1677abcf0de7d7d1ee8dc4b">&#9670;&#160;</a></span>AddVelocityConstraintAtNormalizedTime() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">solvers::Constraint</a> &gt; AddVelocityConstraintAtNormalizedTime </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">solvers::Constraint</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>constraint</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>s</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a (generic) constraint on trajectory velocity <span class="tt">q̇(t)</span>, evaluated at <span class="tt">s</span>. </p>
<p>The constraint will be evaluated as if it is bound with variables corresponding to <span class="tt">[q(T*s), q̇(T*s)]</span>.</p>
<p>This is a potentially confusing mix of <span class="tt">s</span> and <span class="tt">t</span>, but it is important in practice. For instance if you want to constrain the true (trajectory) velocity at the final time, one would naturally want to write AddVelocityConstraint(constraint, s=1).</p>
<p>This method should be compared with AddPathVelocityConstraint, which only constrains ṙ(s) because it does not reason about the time scaling, T. However, AddPathVelocityConstraint adds convex constraints, whereas this method adds nonconvex generic constraints.</p>
<dl class="section pre"><dt>Precondition</dt><dd>constraint.num_vars() == <a class="el" href="#aba2887f0ca1fbbdfb49cf6b0ee21e553" title="Returns the number of position variables.">num_positions()</a> </dd>
<dd>
0 &lt;= <span class="tt">s</span> &lt;= 1. </dd></dl>

</div>
</div>
<a id="a73b974ae81bfa6e07ecc82d94697305a" name="a73b974ae81bfa6e07ecc82d94697305a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73b974ae81bfa6e07ecc82d94697305a">&#9670;&#160;</a></span>basis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1math_1_1_bspline_basis.html">math::BsplineBasis</a>&lt; double &gt; &amp; basis </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the basis used to represent the path, r(s), over s∈[0,1]. </p>

</div>
</div>
<a id="a410a2ee65236f6dd126caf713fce53ae" name="a410a2ee65236f6dd126caf713fce53ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a410a2ee65236f6dd126caf713fce53ae">&#9670;&#160;</a></span>control_points()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacedrake_1_1solvers.html#a85b6a5d80d5e24442bca8472b116c22a">solvers::MatrixXDecisionVariable</a> &amp; control_points </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the control points defining the path as an M-by-N matrix, where M is the number of positions and N is the number of control points. </p>

</div>
</div>
<a id="a547a1ad03a99c89ba67180e4752e1969" name="a547a1ad03a99c89ba67180e4752e1969"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a547a1ad03a99c89ba67180e4752e1969">&#9670;&#160;</a></span>duration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp; duration </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the decision variable defining the time duration of the trajectory. </p>

</div>
</div>
<a id="afbb6e35083b07855fa7f22826828da2f" name="afbb6e35083b07855fa7f22826828da2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbb6e35083b07855fa7f22826828da2f">&#9670;&#160;</a></span>get_mutable_prog()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">solvers::MathematicalProgram</a> &amp; get_mutable_prog </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter for a mutable pointer to the optimization program. </p>

</div>
</div>
<a id="a7bf41e0881035d3f5e879b99ff8fc4c5" name="a7bf41e0881035d3f5e879b99ff8fc4c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bf41e0881035d3f5e879b99ff8fc4c5">&#9670;&#160;</a></span>num_control_points()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int num_control_points </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of control points used for the path. </p>

</div>
</div>
<a id="aba2887f0ca1fbbdfb49cf6b0ee21e553" name="aba2887f0ca1fbbdfb49cf6b0ee21e553"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba2887f0ca1fbbdfb49cf6b0ee21e553">&#9670;&#160;</a></span>num_positions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int num_positions </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of position variables. </p>

</div>
</div>
<a id="a6bb3abdee0564a91c3e88aae256ab784" name="a6bb3abdee0564a91c3e88aae256ab784"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bb3abdee0564a91c3e88aae256ab784">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a9a8474ae1e7ce1dab9a404fd6e6f6054">KinematicTrajectoryOptimization</a> &amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a9a8474ae1e7ce1dab9a404fd6e6f6054">KinematicTrajectoryOptimization</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1a212a6703b180dae3bfdc09d4aab07a" name="a1a212a6703b180dae3bfdc09d4aab07a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a212a6703b180dae3bfdc09d4aab07a">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a9a8474ae1e7ce1dab9a404fd6e6f6054">KinematicTrajectoryOptimization</a> &amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a9a8474ae1e7ce1dab9a404fd6e6f6054">KinematicTrajectoryOptimization</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab54111eab638313c328fc0a0f1b50944" name="ab54111eab638313c328fc0a0f1b50944"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab54111eab638313c328fc0a0f1b50944">&#9670;&#160;</a></span>prog()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">solvers::MathematicalProgram</a> &amp; prog </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter for the optimization program. </p>

</div>
</div>
<a id="ab7195dc538a2b08a98243e5f24e06bd1" name="ab7195dc538a2b08a98243e5f24e06bd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7195dc538a2b08a98243e5f24e06bd1">&#9670;&#160;</a></span>q()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt; &amp; q </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the placeholder variable for generalized position q. </p>
<p>Note these are NOT decision variables in the MathematicalProgram. These variables will be substituted for the real decision variables at particular times. Passing these variables directily into objective/constraints for the MathematicalProgram will result in an error. </p>

</div>
</div>
<a id="a6747e458d8ecd6e52e04280744e6568c" name="a6747e458d8ecd6e52e04280744e6568c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6747e458d8ecd6e52e04280744e6568c">&#9670;&#160;</a></span>qddot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt; &amp; qddot </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the placeholder variable for the second time derivative of generalized position. </p>
<p>Note these are NOT decision variables in the MathematicalProgram. These variables will be substituted for the real decision variables at particular times. Passing these variables directily into objective/constraints for the MathematicalProgram will result in an error. </p>

</div>
</div>
<a id="adfadf8b11c8358c081d7cf426d4fc8a7" name="adfadf8b11c8358c081d7cf426d4fc8a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfadf8b11c8358c081d7cf426d4fc8a7">&#9670;&#160;</a></span>qdot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt; &amp; qdot </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the placeholder variable for the time derivative of generalized position. </p>
<p>Note these are NOT decision variables in the MathematicalProgram. These variables will be substituted for the real decision variables at particular times. Passing these variables directily into objective/constraints for the MathematicalProgram will result in an error. </p>

</div>
</div>
<a id="a90b718bdee7102d5950bea095fa94e60" name="a90b718bdee7102d5950bea095fa94e60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90b718bdee7102d5950bea095fa94e60">&#9670;&#160;</a></span>ReconstructTrajectory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1trajectories_1_1_bspline_trajectory.html">trajectories::BsplineTrajectory</a>&lt; double &gt; ReconstructTrajectory </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program_result.html">solvers::MathematicalProgramResult</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>result</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the trajectory q(t) from the <span class="tt">result</span> of solving <span class="tt"><a class="el" href="#ab54111eab638313c328fc0a0f1b50944" title="Getter for the optimization program.">prog()</a></span>. </p>

</div>
</div>
<a id="a8375ea48a9fad7145ae1d2e97d851f76" name="a8375ea48a9fad7145ae1d2e97d851f76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8375ea48a9fad7145ae1d2e97d851f76">&#9670;&#160;</a></span>SetInitialGuess()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetInitialGuess </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1trajectories_1_1_bspline_trajectory.html">trajectories::BsplineTrajectory</a>&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>trajectory</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the initial guess for the path and duration to match <span class="tt">trajectory</span>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>trajectory.rows() == <a class="el" href="#aba2887f0ca1fbbdfb49cf6b0ee21e553" title="Returns the number of position variables.">num_positions()</a> </dd>
<dd>
trajectory.columns() == 1 </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>drake/planning/trajectory_optimization/<a class="el" href="kinematic__trajectory__optimization_8h.html">kinematic_trajectory_optimization.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- footer -->
<div class="navpath">
  <ul>
    <li class="navelem"><a href="namespacedrake.html">drake</a></li><li class="navelem"><a href="namespacedrake_1_1planning.html">planning</a></li><li class="navelem"><a href="namespacedrake_1_1planning_1_1trajectory__optimization.html">trajectory_optimization</a></li><li class="navelem"><a href="classdrake_1_1planning_1_1trajectory__optimization_1_1_kinematic_trajectory_optimization.html">KinematicTrajectoryOptimization</a></li>
  </ul>
</div>
<footer id="nav-path", class="site-footer padding">
  <div class="contain">
    <a href="/" class="drake-logo">
      <img src="/images/drake-logo.svg"/>
    </a>
    <div class="footer-menu">
      <ul>
        <li>
          <a href="https://accessibility.mit.edu/" class="site-menu-item">Accessibility</a>
        </li>
        <li>
          <a href="/doxygen_cxx/index.html" class="site-menu-item">C++</a>
        </li>
        <li>
          <a href="/pydrake/index.html" class="site-menu-item">Python</a>
        </li>
        <li class="github-link">
          <a href="https://github.com/RobotLocomotion/drake" class="site-menu-item">GitHub <img src="/third_party/images/GitHub-Mark-64px.png"/></a>
        </li>
      </ul>
    </div>
  </div>
</footer>
<script type="text/javascript">
searchBox.searchLabel = 'Go to name…';
searchBox.DOMSearchField().placeholder = searchBox.searchLabel;
searchBox.DOMSearchField().value = '';
</script>
</body>
</html>
