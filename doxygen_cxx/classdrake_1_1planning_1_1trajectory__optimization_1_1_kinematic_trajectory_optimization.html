<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: KinematicTrajectoryOptimization Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<header class="site-header">
 <div class="site-header-inner contain">
  <a class="drake-logo" href="/"><img src="/images/drake-logo-white.svg"></a>
  <div class="menu-mobile-toggle">
   <span></span>
  </div>
  <nav class="site-menu">
   <ul>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/">Home</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/installation.html">Installation</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/gallery.html">Gallery</a>
    </li>
    <li class="site-menu-item site-menu-item-main">API Documentation
     <div class="sub">
      <a class="site-menu-item" href="/doxygen_cxx/index.html">C++</a>
      <a class="site-menu-item" href="/pydrake/index.html">Python</a>
     </div>
    </li>
    <li class="site-menu-item site-menu-item-main">Resources
     <div class="sub">
      <a class="site-menu-item" href="/getting_help.html">Getting Help</a>
      <a class="site-menu-item" href="https://deepnote.com/workspace/Drake-0b3b2c53-a7ad-441b-80f8-bf8350752305/project/Tutorials-2b4fc509-aef2-417d-a40d-6071dfed9199/%2Findex.ipynb">Tutorials</a>
      <a class="site-menu-item" href="/python_bindings.html">Python Bindings</a>
      <a class="site-menu-item" href="/developers.html">For Developers</a>
      <a class="site-menu-item" href="/credits.html">Credits</a>
     </div>
    </li>
    <li class="github-link">
     <a class="site-menu-item" href="https://github.com/RobotLocomotion/drake">GitHub <img src="/third_party/images/GitHub-Mark-Light-64px.png"></a>
    </li>
   </ul>
  </nav>
 </div>
</header>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
<div class="title-banner">
 <div class="title-banner__title">
  Drake C++ Documentation
 </div>
 <div id="DDGSearch">
  <form id="search_form_cpp" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search C++ API only…">
   <input type="hidden" name="q" value="site:drake.mit.edu/doxygen_cxx">
  </form>
  <form id="search_form" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search all of Drake…">
   <input type="hidden" name="q" value="site:drake.mit.edu OR site:underactuated.csail.mit.edu OR site:manipulation.csail.mit.edu">
  </form>
 </div>
 <div id="MSearchBoxContainer">
          <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
 </div>
</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classdrake_1_1planning_1_1trajectory__optimization_1_1_kinematic_trajectory_optimization.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classdrake_1_1planning_1_1trajectory__optimization_1_1_kinematic_trajectory_optimization-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">KinematicTrajectoryOptimization Class Reference<div class="ingroups"><a class="el" href="group__algorithms.html">Algorithms</a> &raquo; <a class="el" href="group__planning.html">Planning</a> &raquo; <a class="el" href="group__planning__trajectory.html">Trajectories</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Optimizes a trajectory, q(t) subject to costs and constraints on the trajectory and its derivatives. </p>
<p>This is accomplished using a <code>path</code>, r(s), represented as a BsplineTrajectory on the interval s∈[0,1], and a separate duration, T, which maps [0,1] =&gt; [0,T].</p>
<p>The q(t) trajectory is commonly associated with, for instance, the generalized positions of a MultibodyPlant by adding multibody costs and constraints; in this case take note that the velocities in this optimization are q̇(t), not v(t).</p>
<p>Use <a class="el" href="namespacedrake_1_1solvers.html#a07bf1722e3e347d7878ae44be98b4b92" title="Solves an optimization program, with optional initial guess and solver options.">solvers::Solve</a> to solve the problem. A typical use case could look like: </p><pre class="fragment">  KinematicTrajectoryOptimization trajopt(2, 10);
  // add costs and constraints
  trajopt.SetInitialGuess(...);
  auto result = solvers::Solve(trajopt.prog());
  auto traj = trajopt.ReconstructTrajectory(result);
</pre><p>When possible this class attempts to formulate convex forms of the costs and constraints. </p>
</div>
<p><code>#include &lt;drake/planning/trajectory_optimization/kinematic_trajectory_optimization.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa04be32847a0a206b2ae988625279139"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1planning_1_1trajectory__optimization_1_1_kinematic_trajectory_optimization.html#aa04be32847a0a206b2ae988625279139">KinematicTrajectoryOptimization</a> (<a class="el" href="classint.html">int</a> <a class="el" href="classdrake_1_1planning_1_1trajectory__optimization_1_1_kinematic_trajectory_optimization.html#aba2887f0ca1fbbdfb49cf6b0ee21e553">num_positions</a>, <a class="el" href="classint.html">int</a> <a class="el" href="classdrake_1_1planning_1_1trajectory__optimization_1_1_kinematic_trajectory_optimization.html#a7bf41e0881035d3f5e879b99ff8fc4c5">num_control_points</a>, <a class="el" href="classint.html">int</a> spline_order=4, <a class="el" href="classdouble.html">double</a> <a class="el" href="classdrake_1_1planning_1_1trajectory__optimization_1_1_kinematic_trajectory_optimization.html#ada7b35ee8b161bd6ccc2709ccf3c1022">duration</a>=1.0)</td></tr>
<tr class="memdesc:aa04be32847a0a206b2ae988625279139"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an optimization problem for a position trajectory represented as a B-spline.  <a href="#aa04be32847a0a206b2ae988625279139">More...</a><br /></td></tr>
<tr class="separator:aa04be32847a0a206b2ae988625279139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65363bc4338584a02f119b225ae1cc98"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1planning_1_1trajectory__optimization_1_1_kinematic_trajectory_optimization.html#a65363bc4338584a02f119b225ae1cc98">KinematicTrajectoryOptimization</a> (const <a class="el" href="classdrake_1_1trajectories_1_1_bspline_trajectory.html">trajectories::BsplineTrajectory</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;trajectory)</td></tr>
<tr class="memdesc:a65363bc4338584a02f119b225ae1cc98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an optimization problem for a trajectory represented by a B-spline with the same order and number of control points as <code>trajectory</code>.  <a href="#a65363bc4338584a02f119b225ae1cc98">More...</a><br /></td></tr>
<tr class="separator:a65363bc4338584a02f119b225ae1cc98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba2887f0ca1fbbdfb49cf6b0ee21e553"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1planning_1_1trajectory__optimization_1_1_kinematic_trajectory_optimization.html#aba2887f0ca1fbbdfb49cf6b0ee21e553">num_positions</a> () const</td></tr>
<tr class="memdesc:aba2887f0ca1fbbdfb49cf6b0ee21e553"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of position variables.  <a href="#aba2887f0ca1fbbdfb49cf6b0ee21e553">More...</a><br /></td></tr>
<tr class="separator:aba2887f0ca1fbbdfb49cf6b0ee21e553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bf41e0881035d3f5e879b99ff8fc4c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1planning_1_1trajectory__optimization_1_1_kinematic_trajectory_optimization.html#a7bf41e0881035d3f5e879b99ff8fc4c5">num_control_points</a> () const</td></tr>
<tr class="memdesc:a7bf41e0881035d3f5e879b99ff8fc4c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of control points used for the path.  <a href="#a7bf41e0881035d3f5e879b99ff8fc4c5">More...</a><br /></td></tr>
<tr class="separator:a7bf41e0881035d3f5e879b99ff8fc4c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a762563a2efd7d83a85bae4df50c66fa8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1math_1_1_bspline_basis.html">math::BsplineBasis</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1planning_1_1trajectory__optimization_1_1_kinematic_trajectory_optimization.html#a762563a2efd7d83a85bae4df50c66fa8">basis</a> () const</td></tr>
<tr class="memdesc:a762563a2efd7d83a85bae4df50c66fa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the basis used to represent the path, r(s), over s∈[0,1].  <a href="#a762563a2efd7d83a85bae4df50c66fa8">More...</a><br /></td></tr>
<tr class="separator:a762563a2efd7d83a85bae4df50c66fa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ca6213bff8c9ae3df9fd4e864a58fb1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacedrake_1_1solvers.html#ac04cfbe6b8d63ecb463fc087385ce061">solvers::MatrixXDecisionVariable</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1planning_1_1trajectory__optimization_1_1_kinematic_trajectory_optimization.html#a3ca6213bff8c9ae3df9fd4e864a58fb1">control_points</a> () const</td></tr>
<tr class="memdesc:a3ca6213bff8c9ae3df9fd4e864a58fb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the control points defining the path as an M-by-N matrix, where M is the number of positions and N is the number of control points.  <a href="#a3ca6213bff8c9ae3df9fd4e864a58fb1">More...</a><br /></td></tr>
<tr class="separator:a3ca6213bff8c9ae3df9fd4e864a58fb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada7b35ee8b161bd6ccc2709ccf3c1022"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1planning_1_1trajectory__optimization_1_1_kinematic_trajectory_optimization.html#ada7b35ee8b161bd6ccc2709ccf3c1022">duration</a> () const</td></tr>
<tr class="memdesc:ada7b35ee8b161bd6ccc2709ccf3c1022"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the decision variable defining the time duration of the trajectory.  <a href="#ada7b35ee8b161bd6ccc2709ccf3c1022">More...</a><br /></td></tr>
<tr class="separator:ada7b35ee8b161bd6ccc2709ccf3c1022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcc8c6b2091ff4447ee2951bb7907de8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">solvers::MathematicalProgram</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1planning_1_1trajectory__optimization_1_1_kinematic_trajectory_optimization.html#afcc8c6b2091ff4447ee2951bb7907de8">prog</a> () const</td></tr>
<tr class="memdesc:afcc8c6b2091ff4447ee2951bb7907de8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for the optimization program.  <a href="#afcc8c6b2091ff4447ee2951bb7907de8">More...</a><br /></td></tr>
<tr class="separator:afcc8c6b2091ff4447ee2951bb7907de8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3392559929281e1d5db4f104ed4b8f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">solvers::MathematicalProgram</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1planning_1_1trajectory__optimization_1_1_kinematic_trajectory_optimization.html#af3392559929281e1d5db4f104ed4b8f1">get_mutable_prog</a> ()</td></tr>
<tr class="memdesc:af3392559929281e1d5db4f104ed4b8f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for a mutable pointer to the optimization program.  <a href="#af3392559929281e1d5db4f104ed4b8f1">More...</a><br /></td></tr>
<tr class="separator:af3392559929281e1d5db4f104ed4b8f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8375ea48a9fad7145ae1d2e97d851f76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1planning_1_1trajectory__optimization_1_1_kinematic_trajectory_optimization.html#a8375ea48a9fad7145ae1d2e97d851f76">SetInitialGuess</a> (const <a class="el" href="classdrake_1_1trajectories_1_1_bspline_trajectory.html">trajectories::BsplineTrajectory</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;trajectory)</td></tr>
<tr class="memdesc:a8375ea48a9fad7145ae1d2e97d851f76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the initial guess for the path and duration to match <code>trajectory</code>.  <a href="#a8375ea48a9fad7145ae1d2e97d851f76">More...</a><br /></td></tr>
<tr class="separator:a8375ea48a9fad7145ae1d2e97d851f76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb432a55ef7765459155c69a539d8658"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1trajectories_1_1_bspline_trajectory.html">trajectories::BsplineTrajectory</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1planning_1_1trajectory__optimization_1_1_kinematic_trajectory_optimization.html#aeb432a55ef7765459155c69a539d8658">ReconstructTrajectory</a> (const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program_result.html">solvers::MathematicalProgramResult</a> &amp;result) const</td></tr>
<tr class="memdesc:aeb432a55ef7765459155c69a539d8658"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the trajectory q(t) from the <code>result</code> of solving <code><a class="el" href="classdrake_1_1planning_1_1trajectory__optimization_1_1_kinematic_trajectory_optimization.html#afcc8c6b2091ff4447ee2951bb7907de8" title="Getter for the optimization program.">prog()</a></code>.  <a href="#aeb432a55ef7765459155c69a539d8658">More...</a><br /></td></tr>
<tr class="separator:aeb432a55ef7765459155c69a539d8658"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a030ffdb9bb87db95f7ab4b4271f3f7db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">solvers::LinearConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1planning_1_1trajectory__optimization_1_1_kinematic_trajectory_optimization.html#a030ffdb9bb87db95f7ab4b4271f3f7db">AddPathPositionConstraint</a> (const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;lb, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;ub, <a class="el" href="classdouble.html">double</a> s)</td></tr>
<tr class="memdesc:a030ffdb9bb87db95f7ab4b4271f3f7db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a linear constraint on the value of the path, <code>lb</code> ≤ r(s) ≤ <code>ub</code>.  <a href="#a030ffdb9bb87db95f7ab4b4271f3f7db">More...</a><br /></td></tr>
<tr class="separator:a030ffdb9bb87db95f7ab4b4271f3f7db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21f8c3c709d1033af97e84221e2cf33b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">solvers::Constraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1planning_1_1trajectory__optimization_1_1_kinematic_trajectory_optimization.html#a21f8c3c709d1033af97e84221e2cf33b">AddPathPositionConstraint</a> (const std::shared_ptr&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">solvers::Constraint</a> &gt; &amp;constraint, <a class="el" href="classdouble.html">double</a> s)</td></tr>
<tr class="memdesc:a21f8c3c709d1033af97e84221e2cf33b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a (generic) constraint on path.  <a href="#a21f8c3c709d1033af97e84221e2cf33b">More...</a><br /></td></tr>
<tr class="separator:a21f8c3c709d1033af97e84221e2cf33b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cdddfa87a81c1bb16e7c543fbc2c1e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">solvers::LinearConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1planning_1_1trajectory__optimization_1_1_kinematic_trajectory_optimization.html#a5cdddfa87a81c1bb16e7c543fbc2c1e6">AddPathVelocityConstraint</a> (const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;lb, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;ub, <a class="el" href="classdouble.html">double</a> s)</td></tr>
<tr class="memdesc:a5cdddfa87a81c1bb16e7c543fbc2c1e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a linear constraint on the derivative of the path, <code>lb</code> ≤ ṙ(s) ≤ <code>ub</code>.  <a href="#a5cdddfa87a81c1bb16e7c543fbc2c1e6">More...</a><br /></td></tr>
<tr class="separator:a5cdddfa87a81c1bb16e7c543fbc2c1e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9130da22735a186f32196b00f7fc80ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">solvers::Constraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1planning_1_1trajectory__optimization_1_1_kinematic_trajectory_optimization.html#a9130da22735a186f32196b00f7fc80ae">AddVelocityConstraintAtNormalizedTime</a> (const std::shared_ptr&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">solvers::Constraint</a> &gt; &amp;constraint, <a class="el" href="classdouble.html">double</a> s)</td></tr>
<tr class="memdesc:a9130da22735a186f32196b00f7fc80ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a (generic) constraint on trajectory velocity <code>q̇(t)</code>, evaluated at <code>s</code>.  <a href="#a9130da22735a186f32196b00f7fc80ae">More...</a><br /></td></tr>
<tr class="separator:a9130da22735a186f32196b00f7fc80ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67ebb878e71a66ac8d6ea1e739766d3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">solvers::LinearConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1planning_1_1trajectory__optimization_1_1_kinematic_trajectory_optimization.html#a67ebb878e71a66ac8d6ea1e739766d3b">AddPathAccelerationConstraint</a> (const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;lb, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;ub, <a class="el" href="classdouble.html">double</a> s)</td></tr>
<tr class="memdesc:a67ebb878e71a66ac8d6ea1e739766d3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a linear constraint on the second derivative of the path, <code>lb</code> ≤ r̈(s) ≤ <code>ub</code>.  <a href="#a67ebb878e71a66ac8d6ea1e739766d3b">More...</a><br /></td></tr>
<tr class="separator:a67ebb878e71a66ac8d6ea1e739766d3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe1106b68562afbcfec8556500df5f90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_bounding_box_constraint.html">solvers::BoundingBoxConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1planning_1_1trajectory__optimization_1_1_kinematic_trajectory_optimization.html#afe1106b68562afbcfec8556500df5f90">AddDurationConstraint</a> (std::optional&lt; <a class="el" href="classdouble.html">double</a> &gt; lb, std::optional&lt; <a class="el" href="classdouble.html">double</a> &gt; ub)</td></tr>
<tr class="memdesc:afe1106b68562afbcfec8556500df5f90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds bounding box constraints for upper and lower bounds on the duration of the trajectory.  <a href="#afe1106b68562afbcfec8556500df5f90">More...</a><br /></td></tr>
<tr class="separator:afe1106b68562afbcfec8556500df5f90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81d27229471360feee82aac9ea2be7e7"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_bounding_box_constraint.html">solvers::BoundingBoxConstraint</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1planning_1_1trajectory__optimization_1_1_kinematic_trajectory_optimization.html#a81d27229471360feee82aac9ea2be7e7">AddPositionBounds</a> (const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;lb, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;ub)</td></tr>
<tr class="memdesc:a81d27229471360feee82aac9ea2be7e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds bounding box constraints to enforce upper and lower bounds on the positions trajectory, q(t).  <a href="#a81d27229471360feee82aac9ea2be7e7">More...</a><br /></td></tr>
<tr class="separator:a81d27229471360feee82aac9ea2be7e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8529eb42d4e8ce382c0a53ee9b26e236"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">solvers::LinearConstraint</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1planning_1_1trajectory__optimization_1_1_kinematic_trajectory_optimization.html#a8529eb42d4e8ce382c0a53ee9b26e236">AddVelocityBounds</a> (const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;lb, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;ub)</td></tr>
<tr class="memdesc:a8529eb42d4e8ce382c0a53ee9b26e236"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds linear constraints to enforce upper and lower bounds on the velocity trajectory, q̇(t).  <a href="#a8529eb42d4e8ce382c0a53ee9b26e236">More...</a><br /></td></tr>
<tr class="separator:a8529eb42d4e8ce382c0a53ee9b26e236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a850317f5fe8fa8343e0690a51556bbbe"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">solvers::Constraint</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1planning_1_1trajectory__optimization_1_1_kinematic_trajectory_optimization.html#a850317f5fe8fa8343e0690a51556bbbe">AddAccelerationBounds</a> (const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;lb, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;ub)</td></tr>
<tr class="memdesc:a850317f5fe8fa8343e0690a51556bbbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds generic (nonlinear) constraints to enforce the upper and lower bounds to the acceleration trajectory, q̈(t).  <a href="#a850317f5fe8fa8343e0690a51556bbbe">More...</a><br /></td></tr>
<tr class="separator:a850317f5fe8fa8343e0690a51556bbbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c266cf092028fbabcc0bca77054d3a3"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">solvers::Constraint</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1planning_1_1trajectory__optimization_1_1_kinematic_trajectory_optimization.html#a8c266cf092028fbabcc0bca77054d3a3">AddJerkBounds</a> (const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;lb, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;ub)</td></tr>
<tr class="memdesc:a8c266cf092028fbabcc0bca77054d3a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds generic (nonlinear) constraints to enforce the upper and lower bounds to the jerk trajectory, d³qdt³(t).  <a href="#a8c266cf092028fbabcc0bca77054d3a3">More...</a><br /></td></tr>
<tr class="separator:a8c266cf092028fbabcc0bca77054d3a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad869a71300a38a96b8f1c7e40090f383"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">solvers::Constraint</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1planning_1_1trajectory__optimization_1_1_kinematic_trajectory_optimization.html#ad869a71300a38a96b8f1c7e40090f383">AddEffortBoundsAtNormalizedTimes</a> (const <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html">multibody::MultibodyPlant</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;plant, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;s, const std::optional&lt; Eigen::Ref&lt; const Eigen::VectorXd &gt;&gt; &amp;lb=std::nullopt, const std::optional&lt; Eigen::Ref&lt; const Eigen::VectorXd &gt;&gt; &amp;ub=std::nullopt, const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; *plant_context=nullptr)</td></tr>
<tr class="memdesc:ad869a71300a38a96b8f1c7e40090f383"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds generic (nonlinear) constraints to enforce the effort limits defined in the plant at a sequence of normalized times, <code>s</code>:  <a href="#ad869a71300a38a96b8f1c7e40090f383">More...</a><br /></td></tr>
<tr class="separator:ad869a71300a38a96b8f1c7e40090f383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3f60fe9552c90c9a3986f023ba18a56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_cost.html">solvers::LinearCost</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1planning_1_1trajectory__optimization_1_1_kinematic_trajectory_optimization.html#ae3f60fe9552c90c9a3986f023ba18a56">AddDurationCost</a> (<a class="el" href="classdouble.html">double</a> weight=1.0)</td></tr>
<tr class="memdesc:ae3f60fe9552c90c9a3986f023ba18a56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a linear cost on the duration of the trajectory.  <a href="#ae3f60fe9552c90c9a3986f023ba18a56">More...</a><br /></td></tr>
<tr class="separator:ae3f60fe9552c90c9a3986f023ba18a56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6da88e725b9e65eb10ffe19f25742ad4"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_cost.html">solvers::Cost</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1planning_1_1trajectory__optimization_1_1_kinematic_trajectory_optimization.html#a6da88e725b9e65eb10ffe19f25742ad4">AddPathLengthCost</a> (<a class="el" href="classdouble.html">double</a> weight=1.0, bool use_conic_constraint=false)</td></tr>
<tr class="memdesc:a6da88e725b9e65eb10ffe19f25742ad4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a cost on an upper bound of the length of the path, ∫₀ᵀ |q̇(t)|₂ dt, or equivalently ∫₀¹ |ṙ(s)|₂ ds, by summing the distance between the path control points.  <a href="#a6da88e725b9e65eb10ffe19f25742ad4">More...</a><br /></td></tr>
<tr class="separator:a6da88e725b9e65eb10ffe19f25742ad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a411b4823b494999f0d51e7d0afac17c0"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_cost.html">solvers::Cost</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1planning_1_1trajectory__optimization_1_1_kinematic_trajectory_optimization.html#a411b4823b494999f0d51e7d0afac17c0">AddPathEnergyCost</a> (<a class="el" href="classdouble.html">double</a> weight=1.0)</td></tr>
<tr class="memdesc:a411b4823b494999f0d51e7d0afac17c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a convex quadratic cost on an upper bound on the energy of the path, ∫₀¹ |ṙ(s)|₂² ds, by summing the squared distance between the path control points.  <a href="#a411b4823b494999f0d51e7d0afac17c0">More...</a><br /></td></tr>
<tr class="separator:a411b4823b494999f0d51e7d0afac17c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Does not allow copy, move, or assignment</div></td></tr>
<tr class="memitem:a9a8474ae1e7ce1dab9a404fd6e6f6054"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1planning_1_1trajectory__optimization_1_1_kinematic_trajectory_optimization.html#a9a8474ae1e7ce1dab9a404fd6e6f6054">KinematicTrajectoryOptimization</a> (const <a class="el" href="classdrake_1_1planning_1_1trajectory__optimization_1_1_kinematic_trajectory_optimization.html">KinematicTrajectoryOptimization</a> &amp;)=delete</td></tr>
<tr class="separator:a9a8474ae1e7ce1dab9a404fd6e6f6054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab1f0d3cbfc0204c739cdd549d980d2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1planning_1_1trajectory__optimization_1_1_kinematic_trajectory_optimization.html">KinematicTrajectoryOptimization</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1planning_1_1trajectory__optimization_1_1_kinematic_trajectory_optimization.html#aab1f0d3cbfc0204c739cdd549d980d2b">operator=</a> (const <a class="el" href="classdrake_1_1planning_1_1trajectory__optimization_1_1_kinematic_trajectory_optimization.html">KinematicTrajectoryOptimization</a> &amp;)=delete</td></tr>
<tr class="separator:aab1f0d3cbfc0204c739cdd549d980d2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2776d8c1a2ba6628d4b0870c76967c28"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1planning_1_1trajectory__optimization_1_1_kinematic_trajectory_optimization.html#a2776d8c1a2ba6628d4b0870c76967c28">KinematicTrajectoryOptimization</a> (<a class="el" href="classdrake_1_1planning_1_1trajectory__optimization_1_1_kinematic_trajectory_optimization.html">KinematicTrajectoryOptimization</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a2776d8c1a2ba6628d4b0870c76967c28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a547060be7141e61d9ce65e75ae93f00d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1planning_1_1trajectory__optimization_1_1_kinematic_trajectory_optimization.html">KinematicTrajectoryOptimization</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1planning_1_1trajectory__optimization_1_1_kinematic_trajectory_optimization.html#a547060be7141e61d9ce65e75ae93f00d">operator=</a> (<a class="el" href="classdrake_1_1planning_1_1trajectory__optimization_1_1_kinematic_trajectory_optimization.html">KinematicTrajectoryOptimization</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a547060be7141e61d9ce65e75ae93f00d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a9a8474ae1e7ce1dab9a404fd6e6f6054"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a8474ae1e7ce1dab9a404fd6e6f6054">&#9670;&nbsp;</a></span>KinematicTrajectoryOptimization() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1planning_1_1trajectory__optimization_1_1_kinematic_trajectory_optimization.html">KinematicTrajectoryOptimization</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1planning_1_1trajectory__optimization_1_1_kinematic_trajectory_optimization.html">KinematicTrajectoryOptimization</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2776d8c1a2ba6628d4b0870c76967c28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2776d8c1a2ba6628d4b0870c76967c28">&#9670;&nbsp;</a></span>KinematicTrajectoryOptimization() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1planning_1_1trajectory__optimization_1_1_kinematic_trajectory_optimization.html">KinematicTrajectoryOptimization</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1planning_1_1trajectory__optimization_1_1_kinematic_trajectory_optimization.html">KinematicTrajectoryOptimization</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa04be32847a0a206b2ae988625279139"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa04be32847a0a206b2ae988625279139">&#9670;&nbsp;</a></span>KinematicTrajectoryOptimization() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1planning_1_1trajectory__optimization_1_1_kinematic_trajectory_optimization.html">KinematicTrajectoryOptimization</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>num_positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>num_control_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>spline_order</em> = <code>4</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>duration</em> = <code>1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs an optimization problem for a position trajectory represented as a B-spline. </p>
<p>The initial guess is the zero trajectory over the time interval [0, T]. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_positions</td><td>The number of rows in the B-spline. </td></tr>
    <tr><td class="paramname">num_control_points</td><td>The number of B-spline control points. </td></tr>
    <tr><td class="paramname">spline_order</td><td>The order of the B-spline. </td></tr>
    <tr><td class="paramname">duration</td><td>The duration (in seconds) of the initial guess. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a65363bc4338584a02f119b225ae1cc98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65363bc4338584a02f119b225ae1cc98">&#9670;&nbsp;</a></span>KinematicTrajectoryOptimization() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1planning_1_1trajectory__optimization_1_1_kinematic_trajectory_optimization.html">KinematicTrajectoryOptimization</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1trajectories_1_1_bspline_trajectory.html">trajectories::BsplineTrajectory</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>trajectory</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an optimization problem for a trajectory represented by a B-spline with the same order and number of control points as <code>trajectory</code>. </p>
<p>Additionally sets <code>trajectory</code> as the initial guess for the optimization. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a850317f5fe8fa8343e0690a51556bbbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a850317f5fe8fa8343e0690a51556bbbe">&#9670;&nbsp;</a></span>AddAccelerationBounds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_constraint.html">solvers::Constraint</a>&gt; &gt; AddAccelerationBounds </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>ub</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds generic (nonlinear) constraints to enforce the upper and lower bounds to the acceleration trajectory, q̈(t). </p>
<p>By leveraging the convex hull property of B-splines, these bounds are applied at the (derivative) control points, but will be respected for all times, t ∈ [0,T]. Note that this does NOT directly constrain r̈(s).</p>
<dl class="section return"><dt>Returns</dt><dd>A vector of bindings with interleaved lower and then upper bounds, constraining all of the control points for one element of q̈ (e.g. the acceleration of the ith joint at all times). However, this specific interpretation of these constraints may change without deprecation. </dd></dl>

</div>
</div>
<a id="afe1106b68562afbcfec8556500df5f90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe1106b68562afbcfec8556500df5f90">&#9670;&nbsp;</a></span>AddDurationConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_bounding_box_constraint.html">solvers::BoundingBoxConstraint</a>&gt; AddDurationConstraint </td>
          <td>(</td>
          <td class="paramtype">std::optional&lt; <a class="el" href="classdouble.html">double</a> &gt;&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="classdouble.html">double</a> &gt;&#160;</td>
          <td class="paramname"><em>ub</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds bounding box constraints for upper and lower bounds on the duration of the trajectory. </p>

</div>
</div>
<a id="ae3f60fe9552c90c9a3986f023ba18a56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3f60fe9552c90c9a3986f023ba18a56">&#9670;&nbsp;</a></span>AddDurationCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_linear_cost.html">solvers::LinearCost</a>&gt; AddDurationCost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>weight</em> = <code>1.0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a linear cost on the duration of the trajectory. </p>

</div>
</div>
<a id="ad869a71300a38a96b8f1c7e40090f383"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad869a71300a38a96b8f1c7e40090f383">&#9670;&nbsp;</a></span>AddEffortBoundsAtNormalizedTimes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_constraint.html">solvers::Constraint</a>&gt; &gt; AddEffortBoundsAtNormalizedTimes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html">multibody::MultibodyPlant</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>plant</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::optional&lt; Eigen::Ref&lt; const Eigen::VectorXd &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>lb</em> = <code>std::nullopt</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::optional&lt; Eigen::Ref&lt; const Eigen::VectorXd &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>ub</em> = <code>std::nullopt</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; *&#160;</td>
          <td class="paramname"><em>plant_context</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds generic (nonlinear) constraints to enforce the effort limits defined in the plant at a sequence of normalized times, <code>s</code>: </p>
<pre class="fragment">B lb ≤ M(q)v̇ + C(q, v)v - τ_g(q) - τ_app ≤ B ub
</pre><p> where q, v, and v̇ are evaluated at s. B is the plant's actuation matrix, and M, C, τ_g, and τ_app are the plant's mass matrix, Coriolis force, gravity, and applied force, respectively. <code>ub</code> and <code>lb</code> are the upper and lower effort bounds, respectively; if they are not provided then plant.GetEffortLowerLimits() and plant.GetEffortUpperLimits() are used.</p>
<p>Pass <code>plant_context</code> if you have non-default parameters in the context. Note that there are no lifetime requirements on <code>plant</code> nor <code>plant_context</code>.</p>
<p>Note that the convex hull property of the B-splines is not guaranteed to hold here &ndash; effort limits maybe be violated away from the normalized times <code>s</code>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>plant.is_finalized() </dd>
<dd>
plant.num_positions() == <a class="el" href="classdrake_1_1planning_1_1trajectory__optimization_1_1_kinematic_trajectory_optimization.html#aba2887f0ca1fbbdfb49cf6b0ee21e553" title="Returns the number of position variables.">num_positions()</a> </dd>
<dd>
plant.IsVelocityEqualToQDot() == true </dd>
<dd>
s[i] ∈ [0, 1] for all i </dd>
<dd>
B lb ≤ B ub</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of bindings with one effort limit constraint for each <code>s</code>. </dd></dl>

</div>
</div>
<a id="a8c266cf092028fbabcc0bca77054d3a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c266cf092028fbabcc0bca77054d3a3">&#9670;&nbsp;</a></span>AddJerkBounds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_constraint.html">solvers::Constraint</a>&gt; &gt; AddJerkBounds </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>ub</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds generic (nonlinear) constraints to enforce the upper and lower bounds to the jerk trajectory, d³qdt³(t). </p>
<p>By leveraging the convex hull property of B-splines, these bounds are applied at the (derivative) control points, but will be respected for all times, t ∈ [0,T]. Note that this does NOT directly constrain d³rds³(s).</p>
<dl class="section return"><dt>Returns</dt><dd>A vector of bindings with interleaved lower and then upper bounds, constraining all of the control points for one element of d³qdt³ (e.g. the jerk of the ith joint at all times). However, this specific interpretation of these constraints may change without deprecation. </dd></dl>

</div>
</div>
<a id="a67ebb878e71a66ac8d6ea1e739766d3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67ebb878e71a66ac8d6ea1e739766d3b">&#9670;&nbsp;</a></span>AddPathAccelerationConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">solvers::LinearConstraint</a>&gt; AddPathAccelerationConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a linear constraint on the second derivative of the path, <code>lb</code> ≤ r̈(s) ≤ <code>ub</code>. </p>
<p>Note that this does NOT directly constrain q̈(t). </p><dl class="section pre"><dt>Precondition</dt><dd>0 &lt;= <code>s</code> &lt;= 1. </dd></dl>

</div>
</div>
<a id="a411b4823b494999f0d51e7d0afac17c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a411b4823b494999f0d51e7d0afac17c0">&#9670;&nbsp;</a></span>AddPathEnergyCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_cost.html">solvers::Cost</a>&gt; &gt; AddPathEnergyCost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>weight</em> = <code>1.0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a convex quadratic cost on an upper bound on the energy of the path, ∫₀¹ |ṙ(s)|₂² ds, by summing the squared distance between the path control points. </p>
<p>In the limit of infinitely many control points, minimizers for AddPathLengthCost and AddPathEnergyCost will follow the same path, but potentially with different timing. They may have different values if additional costs and constraints are imposed. This cost yields simpler gradients than AddPathLengthCost, and biases the control points towards being evenly spaced.</p>
<dl class="section return"><dt>Returns</dt><dd>A vector of bindings with the ith element adding a cost to the ith control point of the velocity trajectory. However, this specific interpretation of these constraints may change without deprecation. </dd></dl>

</div>
</div>
<a id="a6da88e725b9e65eb10ffe19f25742ad4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6da88e725b9e65eb10ffe19f25742ad4">&#9670;&nbsp;</a></span>AddPathLengthCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_cost.html">solvers::Cost</a>&gt; &gt; AddPathLengthCost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>weight</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_conic_constraint</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a cost on an upper bound of the length of the path, ∫₀ᵀ |q̇(t)|₂ dt, or equivalently ∫₀¹ |ṙ(s)|₂ ds, by summing the distance between the path control points. </p>
<p>If <code>use_conic_constraint = false</code>, then costs are added via MathematicalProgram::AddL2NormCost; otherwise they are added via MathematicalProgram::AddL2NormCostUsingConicConstraint.</p>
<dl class="section return"><dt>Returns</dt><dd>A vector of bindings with the ith element adding a cost to the ith control point of the velocity trajectory. However, this specific interpretation of these constraints may change without deprecation. </dd></dl>

</div>
</div>
<a id="a030ffdb9bb87db95f7ab4b4271f3f7db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a030ffdb9bb87db95f7ab4b4271f3f7db">&#9670;&nbsp;</a></span>AddPathPositionConstraint() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">solvers::LinearConstraint</a>&gt; AddPathPositionConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a linear constraint on the value of the path, <code>lb</code> ≤ r(s) ≤ <code>ub</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>0 &lt;= <code>s</code> &lt;= 1. </dd></dl>

</div>
</div>
<a id="a21f8c3c709d1033af97e84221e2cf33b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21f8c3c709d1033af97e84221e2cf33b">&#9670;&nbsp;</a></span>AddPathPositionConstraint() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_constraint.html">solvers::Constraint</a>&gt; AddPathPositionConstraint </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">solvers::Constraint</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a (generic) constraint on path. </p>
<p>The constraint will be evaluated as if it is bound with variables corresponding to <code>r(s)</code>. </p><dl class="section pre"><dt>Precondition</dt><dd>constraint.num_vars() == <a class="el" href="classdrake_1_1planning_1_1trajectory__optimization_1_1_kinematic_trajectory_optimization.html#aba2887f0ca1fbbdfb49cf6b0ee21e553" title="Returns the number of position variables.">num_positions()</a> </dd>
<dd>
0 &lt;= <code>s</code> &lt;= 1. </dd></dl>

</div>
</div>
<a id="a5cdddfa87a81c1bb16e7c543fbc2c1e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cdddfa87a81c1bb16e7c543fbc2c1e6">&#9670;&nbsp;</a></span>AddPathVelocityConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">solvers::LinearConstraint</a>&gt; AddPathVelocityConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a linear constraint on the derivative of the path, <code>lb</code> ≤ ṙ(s) ≤ <code>ub</code>. </p>
<p>Note that this does NOT directly constrain q̇(t). </p><dl class="section pre"><dt>Precondition</dt><dd>0 &lt;= <code>s</code> &lt;= 1. </dd></dl>

</div>
</div>
<a id="a81d27229471360feee82aac9ea2be7e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81d27229471360feee82aac9ea2be7e7">&#9670;&nbsp;</a></span>AddPositionBounds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_bounding_box_constraint.html">solvers::BoundingBoxConstraint</a>&gt; &gt; AddPositionBounds </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>ub</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds bounding box constraints to enforce upper and lower bounds on the positions trajectory, q(t). </p>
<p>These bounds will be respected at all times, t∈[0,T]. This also implies the constraints are satisfied for r(s), for all s∈[0,1].</p>
<dl class="section return"><dt>Returns</dt><dd>A vector of bindings with the ith element adding a constraint to the ith control point. However, this specific interpretation of these constraints may change without deprecation. </dd></dl>

</div>
</div>
<a id="a8529eb42d4e8ce382c0a53ee9b26e236"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8529eb42d4e8ce382c0a53ee9b26e236">&#9670;&nbsp;</a></span>AddVelocityBounds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">solvers::LinearConstraint</a>&gt; &gt; AddVelocityBounds </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>ub</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds linear constraints to enforce upper and lower bounds on the velocity trajectory, q̇(t). </p>
<p>By leveraging the convex hull property of B-splines, these bounds are applied at the (derivative) control points, but will be respected for all times, t ∈ [0,T]. Note this does NOT directly constrain ṙ(s).</p>
<dl class="section return"><dt>Returns</dt><dd>A vector of bindings with interleaved lower and then upper bounds, constraining all of the control points for one element of q̇ (e.g. the velocity of the ith joint at all times). However, this specific interpretation of these constraints may change without deprecation.. </dd></dl>

</div>
</div>
<a id="a9130da22735a186f32196b00f7fc80ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9130da22735a186f32196b00f7fc80ae">&#9670;&nbsp;</a></span>AddVelocityConstraintAtNormalizedTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_constraint.html">solvers::Constraint</a>&gt; AddVelocityConstraintAtNormalizedTime </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">solvers::Constraint</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a (generic) constraint on trajectory velocity <code>q̇(t)</code>, evaluated at <code>s</code>. </p>
<p>The constraint will be evaluated as if it is bound with variables corresponding to <code>[q(T*s), q̇(T*s)]</code>.</p>
<p>This is a potentially confusing mix of <code>s</code> and <code>t</code>, but it is important in practice. For instance if you want to constrain the true (trajectory) velocity at the final time, one would naturally want to write AddVelocityConstraint(constraint, s=1).</p>
<p>This method should be compared with AddPathVelocityConstraint, which only constrains ṙ(s) because it does not reason about the time scaling, T. However, AddPathVelocityConstraint adds convex constraints, whereas this method adds nonconvex generic constraints.</p>
<dl class="section pre"><dt>Precondition</dt><dd>constraint.num_vars() == <a class="el" href="classdrake_1_1planning_1_1trajectory__optimization_1_1_kinematic_trajectory_optimization.html#aba2887f0ca1fbbdfb49cf6b0ee21e553" title="Returns the number of position variables.">num_positions()</a> </dd>
<dd>
0 &lt;= <code>s</code> &lt;= 1. </dd></dl>

</div>
</div>
<a id="a762563a2efd7d83a85bae4df50c66fa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a762563a2efd7d83a85bae4df50c66fa8">&#9670;&nbsp;</a></span>basis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1math_1_1_bspline_basis.html">math::BsplineBasis</a>&lt;<a class="el" href="classdouble.html">double</a>&gt;&amp; basis </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the basis used to represent the path, r(s), over s∈[0,1]. </p>

</div>
</div>
<a id="a3ca6213bff8c9ae3df9fd4e864a58fb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ca6213bff8c9ae3df9fd4e864a58fb1">&#9670;&nbsp;</a></span>control_points()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacedrake_1_1solvers.html#ac04cfbe6b8d63ecb463fc087385ce061">solvers::MatrixXDecisionVariable</a>&amp; control_points </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the control points defining the path as an M-by-N matrix, where M is the number of positions and N is the number of control points. </p>

</div>
</div>
<a id="ada7b35ee8b161bd6ccc2709ccf3c1022"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada7b35ee8b161bd6ccc2709ccf3c1022">&#9670;&nbsp;</a></span>duration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a>&amp; duration </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the decision variable defining the time duration of the trajectory. </p>

</div>
</div>
<a id="af3392559929281e1d5db4f104ed4b8f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3392559929281e1d5db4f104ed4b8f1">&#9670;&nbsp;</a></span>get_mutable_prog()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">solvers::MathematicalProgram</a>&amp; get_mutable_prog </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter for a mutable pointer to the optimization program. </p>

</div>
</div>
<a id="a7bf41e0881035d3f5e879b99ff8fc4c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bf41e0881035d3f5e879b99ff8fc4c5">&#9670;&nbsp;</a></span>num_control_points()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> num_control_points </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of control points used for the path. </p>

</div>
</div>
<a id="aba2887f0ca1fbbdfb49cf6b0ee21e553"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba2887f0ca1fbbdfb49cf6b0ee21e553">&#9670;&nbsp;</a></span>num_positions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> num_positions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of position variables. </p>

</div>
</div>
<a id="a547060be7141e61d9ce65e75ae93f00d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a547060be7141e61d9ce65e75ae93f00d">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1planning_1_1trajectory__optimization_1_1_kinematic_trajectory_optimization.html">KinematicTrajectoryOptimization</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1planning_1_1trajectory__optimization_1_1_kinematic_trajectory_optimization.html">KinematicTrajectoryOptimization</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aab1f0d3cbfc0204c739cdd549d980d2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab1f0d3cbfc0204c739cdd549d980d2b">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1planning_1_1trajectory__optimization_1_1_kinematic_trajectory_optimization.html">KinematicTrajectoryOptimization</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1planning_1_1trajectory__optimization_1_1_kinematic_trajectory_optimization.html">KinematicTrajectoryOptimization</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afcc8c6b2091ff4447ee2951bb7907de8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcc8c6b2091ff4447ee2951bb7907de8">&#9670;&nbsp;</a></span>prog()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">solvers::MathematicalProgram</a>&amp; prog </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter for the optimization program. </p>

</div>
</div>
<a id="aeb432a55ef7765459155c69a539d8658"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb432a55ef7765459155c69a539d8658">&#9670;&nbsp;</a></span>ReconstructTrajectory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1trajectories_1_1_bspline_trajectory.html">trajectories::BsplineTrajectory</a>&lt;<a class="el" href="classdouble.html">double</a>&gt; ReconstructTrajectory </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program_result.html">solvers::MathematicalProgramResult</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the trajectory q(t) from the <code>result</code> of solving <code><a class="el" href="classdrake_1_1planning_1_1trajectory__optimization_1_1_kinematic_trajectory_optimization.html#afcc8c6b2091ff4447ee2951bb7907de8" title="Getter for the optimization program.">prog()</a></code>. </p>

</div>
</div>
<a id="a8375ea48a9fad7145ae1d2e97d851f76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8375ea48a9fad7145ae1d2e97d851f76">&#9670;&nbsp;</a></span>SetInitialGuess()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetInitialGuess </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1trajectories_1_1_bspline_trajectory.html">trajectories::BsplineTrajectory</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>trajectory</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the initial guess for the path and duration to match <code>trajectory</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>trajectory.rows() == <a class="el" href="classdrake_1_1planning_1_1trajectory__optimization_1_1_kinematic_trajectory_optimization.html#aba2887f0ca1fbbdfb49cf6b0ee21e553" title="Returns the number of position variables.">num_positions()</a> </dd>
<dd>
trajectory.columns() == 1 </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>drake/planning/trajectory_optimization/<a class="el" href="kinematic__trajectory__optimization_8h.html">kinematic_trajectory_optimization.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- footer -->
<div class="navpath">
  <ul>
    <li class="navelem"><a class="el" href="namespacedrake.html">drake</a></li><li class="navelem"><a class="el" href="namespacedrake_1_1planning.html">planning</a></li><li class="navelem"><a class="el" href="namespacedrake_1_1planning_1_1trajectory__optimization.html">trajectory_optimization</a></li><li class="navelem"><a class="el" href="classdrake_1_1planning_1_1trajectory__optimization_1_1_kinematic_trajectory_optimization.html">KinematicTrajectoryOptimization</a></li>
  </ul>
</div>
<footer id="nav-path", class="site-footer padding">
  <div class="contain">
    <a href="/" class="drake-logo">
      <img src="/images/drake-logo.svg"/>
    </a>
    <div class="footer-menu">
      <ul>    
        <li>
          <a href="/doxygen_cxx/index.html" class="site-menu-item">C++</a>
        </li>    
        <li>
          <a href="/pydrake/index.html" class="site-menu-item">Python</a>
        </li>
        <li class="github-link">
          <a href="https://github.com/RobotLocomotion/drake" class="site-menu-item">GitHub <img src="/third_party/images/GitHub-Mark-64px.png"/></a>
        </li>
      </ul>
    </div>
  </div>
</footer>
<script type="text/javascript">
searchBox.searchLabel = 'Go to name…';
searchBox.DOMSearchField().value = searchBox.searchLabel;
</script>
</body>
</html>
