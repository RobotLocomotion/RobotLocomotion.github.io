<!-- HTML header for doxygen 1.15.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: CollisionChecker Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(function() { init_search(); });
</script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@4/tex-chtml.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<header class="site-header">
 <div class="site-header-inner contain">
  <a class="drake-logo" href="/"><img src="/images/drake-logo-white.svg"></a>
  <div class="menu-mobile-toggle">
   <span></span>
  </div>
  <nav class="site-menu">
   <ul>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/">Home</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/installation.html">Installation</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/gallery.html">Gallery</a>
    </li>
    <li class="site-menu-item site-menu-item-main">API Documentation
     <div class="sub">
      <a class="site-menu-item" href="/doxygen_cxx/index.html">C++</a>
      <a class="site-menu-item" href="/pydrake/index.html">Python</a>
     </div>
    </li>
    <li class="site-menu-item site-menu-item-main">Resources
     <div class="sub">
      <a class="site-menu-item" href="/getting_help.html">Getting Help</a>
      <a class="site-menu-item" href="https://deepnote.com/workspace/Drake-0b3b2c53-a7ad-441b-80f8-bf8350752305/project/Tutorials-2b4fc509-aef2-417d-a40d-6071dfed9199/notebook/index-753e3c9d261247ba9f0eb1d7868c18c8">Tutorials</a>
      <a class="site-menu-item" href="/python_bindings.html">Python Bindings</a>
      <a class="site-menu-item" href="/developers.html">For Developers</a>
      <a class="site-menu-item" href="/credits.html">Credits</a>
     </div>
    </li>
    <li class="github-link">
     <a class="site-menu-item" href="https://github.com/RobotLocomotion/drake">GitHub <img src="/third_party/images/GitHub-Mark-Light-64px.png"></a>
    </li>
   </ul>
  </nav>
 </div>
</header>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<div class="title-banner">
 <div class="title-banner__title">
  Drake C++ Documentation
 </div>
 <div id="DDGSearch">
  <form id="search_form_cpp" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search C++ API only…">
   <input type="hidden" name="q" value="site:drake.mit.edu/doxygen_cxx">
  </form>
  <form id="search_form" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search all of Drake…">
   <input type="hidden" name="q" value="site:drake.mit.edu OR site:underactuated.csail.mit.edu OR site:manipulation.csail.mit.edu">
  </form>
 </div>
 <div id="MSearchBoxContainer">
  <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect" class="search-icon" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"><span class="search-icon-dropdown"></span></span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><div id="MSearchCloseImg" class="close-icon"></div></a>
          </span>
        </div>
</td>
 </div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('classdrake_1_1planning_1_1_collision_checker.html','','classdrake_1_1planning_1_1_collision_checker-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">CollisionChecker Class Reference<span class="mlabels"><span class="mlabel abstract">abstract</span></span><div class="ingroups"><a class="el" href="group__algorithms.html">Algorithms</a> &raquo; <a class="el" href="group__planning.html">Planning</a> &raquo; <a class="el" href="group__planning__collision__checker.html">Collision checking</a></div></div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Interface for collision checkers to use. </p>
<p>This interface builds on the basic multi-threading idiom of Drake: one context per thread. It offers two models to achieve multi-threaded parallel collision checking:</p>
<ul>
<li>using thread pools (e.g. OpenMP or similar) and "implicit contexts" managed by this object</li>
<li>using arbitrary threads and "explicit contexts" created by this object</li>
</ul>
<p><a class="anchor" id="ccb_implicit_contexts"></a></p><h5>Implicit Context <a class="el" href="classdrake_1_1_parallelism.html" title="Specifies a desired degree of parallelism for a parallelized operation.">Parallelism</a></h5>
<p>Many methods of this class aren't designed for entry from arbitrary threads (e.g. from std::async threads), but rather are designed for use with a main thread and various thread-pool-parallel operations achieved by using directives like <span class="tt">omp parallel</span>. To support this usage, the base class <span class="tt"><a class="el" href="#a381697ea7e2a890f5cd018d7c6dc8bc2" title="Allocate the per-thread context pool, and discontinue mutable access to the robot model.">AllocateContexts()</a></span> protected method establishes a pool of contexts to support the implicit context parallelism specified in the constructor. (Note: if the collision checker declares that parallel checking is not supported, only one implict context will be allocated). <span class="tt"><a class="el" href="#a381697ea7e2a890f5cd018d7c6dc8bc2" title="Allocate the per-thread context pool, and discontinue mutable access to the robot model.">AllocateContexts()</a></span> must be called and only be called as part of the constructor of a derived class defined as final.</p>
<p>Once the context pool is created, clients can access a thread-associated context by using <span class="tt"><a class="el" href="#a5a8b62cb6805a9d647e8ea0c783bb47d" title="Accesses a collision checking context from within the implicit context pool owned by this collision c...">model_context</a>(optional&lt;int&gt; context_number)</span> and related methods. These methods may be called in two ways:</p>
<ul>
<li>without a context number, the association between thread and context uses the OpenMP notion of thread number</li>
<li>with a context number, the method uses the context corresponding to the provided number</li>
</ul>
<p>Without a context number, these context access methods are only safe under the following conditions:</p>
<ul>
<li>the caller is the "main thread"</li>
<li>the caller is an OpenMP team thread <em>during execution of a parallel region</em></li>
</ul>
<p>With a context number, these context access methods are only safe under the following conditions:</p>
<ul>
<li>no two or more threads simultaneously use the same context number</li>
</ul>
<p>Methods supporting implicit context parallelism are noted below by having a reference to this section; as a rule of thumb, any public method that takes a <span class="tt">context_number</span> argument uses implicit context parallelism.</p>
<p>Users of this class (derived classes and others) can write their own parallel operations using implicit contexts, provided they limit parallel blocks to only use <span class="tt">const</span> methods or methods marked to support implicit contexts parallelism, and the parallel operations are:</p>
<ul>
<li>without a context number, only with parallelism using OpenMP directives</li>
<li>with a context number, via a parallelization method that provides a notion of thread numbers similar in behavior to OpenMP's (i.e. a thread number in [0, number of threads), not arbitrary values like <span class="tt">std::this_thread::get_id()</span>)</li>
</ul>
<p>To determine the greatest implicit context parallelism that can be achieved in a parallelized operation, <span class="tt">GetNumberOfThreads(Parallelism parallelize)</span> returns the lesser of the provided <span class="tt">parallelism</span> and the supported implicit context parallelism.</p>
<p><a class="anchor" id="ccb_explicit_contexts"></a></p><h5>Explicit Context <a class="el" href="classdrake_1_1_parallelism.html" title="Specifies a desired degree of parallelism for a parallelized operation.">Parallelism</a></h5>
<p>It is also possible to use arbitrary thread models to perform collision checking in parallel using explicitly created contexts from this class. Contexts returned from <a class="el" href="#afe874e7850ecb2ec51f0c950903d572c" title="Make and track a CollisionCheckerContext.">MakeStandaloneModelContext()</a> may be used in any thread, using only <span class="tt">const</span> methods of this class, or "explicit context" methods.</p>
<p>Explicit contexts are tracked by this class using <span class="tt">std::weak_ptr</span> to track their lifetimes. This mechanism is used by PerformOperationAgainstAllModelContexts to map an operation over all collision contexts, whether explicit or implicit.</p>
<p>Methods supporting explicit context parallelism are noted below by having a reference to this section; as a rule of thumb, any public method that takes a <span class="tt"><a class="el" href="#a5a8b62cb6805a9d647e8ea0c783bb47d" title="Accesses a collision checking context from within the implicit context pool owned by this collision c...">model_context</a></span> first argument uses explicit context parallelism.</p>
<p>In practice, multi-threaded collision checking with explicit contexts may look something like the example below.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> Eigen::VectorXd start_q ...</div>
<div class="line">const Eigen::VectorXd sample_q1 ...</div>
<div class="line">const Eigen::VectorXd sample_q2 ...</div>
<div class="line"> </div>
<div class="line">const <span class="keyword">auto</span> check_edge_to = [&amp;collision_checker, &amp;start_q] (</div>
<div class="line">    <span class="keyword">const</span> Eigen::VectorXd&amp; sample_q,</div>
<div class="line">    <a class="code hl_class" href="classdrake_1_1planning_1_1_collision_checker_context.html">CollisionCheckerContext</a>* explicit_context) {</div>
<div class="line">  <span class="keywordflow">return</span> collision_checker.CheckContextEdgeCollisionFree(</div>
<div class="line">      explicit_context, start_q, sample_q);</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> context_1 = collision_checker.MakeStandaloneModelContext();</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> context_2 = collision_checker.MakeStandaloneModelContext();</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> future_q1 = std::async(std::launch::async, check_edge_to, sample_q1,</div>
<div class="line">                            context_1.get());</div>
<div class="line"><span class="keyword">auto</span> future_q2 = std::async(std::launch::async, check_edge_to, sample_q2,</div>
<div class="line">                            context_2.get());</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> edge_1_valid = future_q1.get();</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> edge_2_valid = future_q2.get();</div>
<div class="ttc" id="aclassdrake_1_1planning_1_1_collision_checker_context_html"><div class="ttname"><a href="classdrake_1_1planning_1_1_collision_checker_context.html">drake::planning::CollisionCheckerContext</a></div><div class="ttdoc">This class represents the data necessary for CollisionChecker to operate safely across multiple threa...</div><div class="ttdef"><b>Definition</b> collision_checker_context.h:25</div></div>
</div><!-- fragment --><h5>Mixing Threading Models</h5>
<p>It is possible to support mixed threading models, i.e., using both OpenMP thread pools and arbitrary threads. In this case, each arbitrary thread (say, from std::async) should have its own instance of a collision checker made using <a class="el" href="#ac41b3899f6c88a6c13ea82b776a8f9e3">Clone()</a>. Then each arbitrary thread will have its own implicit context pool.</p>
<h5>Implementing Derived Classes</h5>
<p>Collision checkers deriving from <a class="el" href="classdrake_1_1planning_1_1_collision_checker.html" title="Interface for collision checkers to use.">CollisionChecker</a> <em>must</em> support parallel operations from both of the above parallelism models. This is generally accomplished by placing all mutable state within the per-thread context. If this cannot be accomplished, the shared mutable state must be accessed in a thread-safe manner. There are APIs that depend on <a class="el" href="#a6831872639ff530b78810ef26115bb26" title="Does the collision checker support true parallel collision checks?">SupportsParallelChecking()</a> (e.g., <a class="el" href="#a48cc1b334d7f2f565b6e66ac82e27b63" title="Checks a vector of configurations for collision, evaluating in parallel when supported and enabled by...">CheckConfigsCollisionFree()</a>, <a class="el" href="#a6bb8c478f30ea78ac72ce0e557c6067d" title="Checks a single configuration-to-configuration edge for collision.">CheckEdgeCollisionFreeParallel()</a>, <a class="el" href="#a5e46f4dff608e99d432d3c700e870c4a" title="Checks multiple configuration-to-configuration edges for collision.">CheckEdgesCollisionFree()</a>, etc); a derived implementation should return <span class="tt">false</span> from <a class="el" href="#a6831872639ff530b78810ef26115bb26" title="Does the collision checker support true parallel collision checks?">SupportsParallelChecking()</a> if there is no meaningful benefit to attempting to do work in parallel (e.g., they must fully serialize on shared state). </p>
</div>
<p><code>#include &lt;drake/planning/collision_checker.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:AddedShape" id="r_AddedShape"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1planning_1_1_collision_checker_1_1_added_shape.html">AddedShape</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of an "added" shape.  <a href="structdrake_1_1planning_1_1_collision_checker_1_1_added_shape.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr id="pub-methods-0" class="groupHeader"><td colspan="2"><div class="groupHeader">Does not allow copy, move, or assignment.</div></td></tr>
<tr class="memitem:a236e58ced4f42c22e7395000ecaaeb7b" id="r_a236e58ced4f42c22e7395000ecaaeb7b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a236e58ced4f42c22e7395000ecaaeb7b">CollisionChecker</a> (CollisionChecker &amp;&amp;)=delete</td></tr>
<tr class="memitem:ac5ded431d5c52f21ea406c521ac75a94" id="r_ac5ded431d5c52f21ea406c521ac75a94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a236e58ced4f42c22e7395000ecaaeb7b">CollisionChecker</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac5ded431d5c52f21ea406c521ac75a94">operator=</a> (const <a class="el" href="#a236e58ced4f42c22e7395000ecaaeb7b">CollisionChecker</a> &amp;)=delete</td></tr>
<tr class="memitem:a484fcf526a45f95ace6f9fd099cc8887" id="r_a484fcf526a45f95ace6f9fd099cc8887"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a236e58ced4f42c22e7395000ecaaeb7b">CollisionChecker</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a484fcf526a45f95ace6f9fd099cc8887">operator=</a> (<a class="el" href="#a236e58ced4f42c22e7395000ecaaeb7b">CollisionChecker</a> &amp;&amp;)=delete</td></tr>
<tr class="memitem:a9f469a8ba4f8fbd62921ff2f18590ce5" id="r_a9f469a8ba4f8fbd62921ff2f18590ce5"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9f469a8ba4f8fbd62921ff2f18590ce5">~CollisionChecker</a> ()</td></tr>
<tr class="memitem:ac41b3899f6c88a6c13ea82b776a8f9e3" id="r_ac41b3899f6c88a6c13ea82b776a8f9e3"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="#a236e58ced4f42c22e7395000ecaaeb7b">CollisionChecker</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac41b3899f6c88a6c13ea82b776a8f9e3">Clone</a> () const</td></tr>
<tr id="pub-methods-1" class="groupHeader"><td colspan="2"><div class="groupHeader">Robot Model</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p>These methods all provide access to the underlying robot model's contents. </p>
</div></td></tr>
<tr class="memitem:a5b27629aa14a86079b45f9bc76234863" id="r_a5b27629aa14a86079b45f9bc76234863"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1planning_1_1_robot_diagram.html">RobotDiagram</a>&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5b27629aa14a86079b45f9bc76234863">model</a> () const</td></tr>
<tr class="memitem:a3f699d3e3d57e0d543304760d014e774" id="r_a3f699d3e3d57e0d543304760d014e774"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html">multibody::MultibodyPlant</a>&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f699d3e3d57e0d543304760d014e774">plant</a> () const</td></tr>
<tr class="memitem:a1eeb910f4ee1c706d9ccd689ec01828d" id="r_a1eeb910f4ee1c706d9ccd689ec01828d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">multibody::RigidBody</a>&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1eeb910f4ee1c706d9ccd689ec01828d">get_body</a> (<a class="el" href="namespacedrake_1_1multibody.html#a02d233e6f0ef016f5cf02e2222a22f5c">multibody::BodyIndex</a> body_index) const</td></tr>
<tr class="memitem:aa072ab3f5946cea5d01402018c74e643" id="r_aa072ab3f5946cea5d01402018c74e643"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">multibody::ModelInstanceIndex</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa072ab3f5946cea5d01402018c74e643">robot_model_instances</a> () const</td></tr>
<tr class="memdesc:aa072ab3f5946cea5d01402018c74e643"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the set of model instances belonging to the robot.  <br /></td></tr>
<tr class="memitem:a7cf0f9ebe090ff87c21ebbe3c7bd0539" id="r_a7cf0f9ebe090ff87c21ebbe3c7bd0539"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7cf0f9ebe090ff87c21ebbe3c7bd0539">IsPartOfRobot</a> (const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">multibody::RigidBody</a>&lt; double &gt; &amp;body) const</td></tr>
<tr class="memitem:a0dcd7c9ea7d36219c6790fe017d41578" id="r_a0dcd7c9ea7d36219c6790fe017d41578"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0dcd7c9ea7d36219c6790fe017d41578">IsPartOfRobot</a> (<a class="el" href="namespacedrake_1_1multibody.html#a02d233e6f0ef016f5cf02e2222a22f5c">multibody::BodyIndex</a> body_index) const</td></tr>
<tr class="memitem:a6ed0e139750504ce407049fef515da6c" id="r_a6ed0e139750504ce407049fef515da6c"><td class="memItemLeft" align="right" valign="top">const Eigen::VectorXd &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ed0e139750504ce407049fef515da6c">GetZeroConfiguration</a> () const</td></tr>
<tr id="pub-methods-2" class="groupHeader"><td colspan="2"><div class="groupHeader">Context management</div></td></tr>
<tr class="memitem:a1db04299a725f279a9c49df91dc0deb2" id="r_a1db04299a725f279a9c49df91dc0deb2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1db04299a725f279a9c49df91dc0deb2">num_allocated_contexts</a> () const</td></tr>
<tr class="memitem:a5a8b62cb6805a9d647e8ea0c783bb47d" id="r_a5a8b62cb6805a9d647e8ea0c783bb47d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1planning_1_1_collision_checker_context.html">CollisionCheckerContext</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5a8b62cb6805a9d647e8ea0c783bb47d">model_context</a> (std::optional&lt; int &gt; context_number=std::nullopt) const</td></tr>
<tr class="memdesc:a5a8b62cb6805a9d647e8ea0c783bb47d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses a collision checking context from within the implicit context pool owned by this collision checker.  <br /></td></tr>
<tr class="memitem:aee97203e446d54e036ea9093c8c5efec" id="r_aee97203e446d54e036ea9093c8c5efec"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aee97203e446d54e036ea9093c8c5efec">plant_context</a> (std::optional&lt; int &gt; context_number=std::nullopt) const</td></tr>
<tr class="memdesc:aee97203e446d54e036ea9093c8c5efec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses a multibody plant sub-context context from within the implicit context pool owned by this collision checker.  <br /></td></tr>
<tr class="memitem:a3e74e151c02c6abad08eed5a7f77df0a" id="r_a3e74e151c02c6abad08eed5a7f77df0a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3e74e151c02c6abad08eed5a7f77df0a">UpdatePositions</a> (const Eigen::VectorXd &amp;q, std::optional&lt; int &gt; context_number=std::nullopt) const</td></tr>
<tr class="memdesc:a3e74e151c02c6abad08eed5a7f77df0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the generalized positions <span class="tt">q</span> in the implicit context specified and returns a reference to the MultibodyPlant's now-updated context.  <br /></td></tr>
<tr class="memitem:ac3e931b23a64ee072c7290b6aa3462be" id="r_ac3e931b23a64ee072c7290b6aa3462be"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac3e931b23a64ee072c7290b6aa3462be">UpdateContextPositions</a> (<a class="el" href="classdrake_1_1planning_1_1_collision_checker_context.html">CollisionCheckerContext</a> *<a class="el" href="#a5a8b62cb6805a9d647e8ea0c783bb47d">model_context</a>, const Eigen::VectorXd &amp;q) const</td></tr>
<tr class="memdesc:ac3e931b23a64ee072c7290b6aa3462be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit Context-based version of <a class="el" href="#a3e74e151c02c6abad08eed5a7f77df0a" title="Updates the generalized positions q in the implicit context specified and returns a reference to the ...">UpdatePositions()</a>.  <br /></td></tr>
<tr class="memitem:afe874e7850ecb2ec51f0c950903d572c" id="r_afe874e7850ecb2ec51f0c950903d572c"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classdrake_1_1planning_1_1_collision_checker_context.html">CollisionCheckerContext</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afe874e7850ecb2ec51f0c950903d572c">MakeStandaloneModelContext</a> () const</td></tr>
<tr class="memdesc:afe874e7850ecb2ec51f0c950903d572c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make and track a <a class="el" href="classdrake_1_1planning_1_1_collision_checker_context.html" title="This class represents the data necessary for CollisionChecker to operate safely across multiple threa...">CollisionCheckerContext</a>.  <br /></td></tr>
<tr class="memitem:a07edeec959f087dcc1812af16b19b02c" id="r_a07edeec959f087dcc1812af16b19b02c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a07edeec959f087dcc1812af16b19b02c">PerformOperationAgainstAllModelContexts</a> (const std::function&lt; void(const <a class="el" href="classdrake_1_1planning_1_1_robot_diagram.html">RobotDiagram</a>&lt; double &gt; &amp;, <a class="el" href="classdrake_1_1planning_1_1_collision_checker_context.html">CollisionCheckerContext</a> *)&gt; &amp;operation)</td></tr>
<tr class="memdesc:a07edeec959f087dcc1812af16b19b02c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows externally-provided operations that must be performed against all contexts in the per-thread context pool, and any standalone contexts made with <a class="el" href="#afe874e7850ecb2ec51f0c950903d572c" title="Make and track a CollisionCheckerContext.">MakeStandaloneModelContext()</a>.  <br /></td></tr>
<tr id="pub-methods-3" class="groupHeader"><td colspan="2"><div class="groupHeader">Adding geometries to a body</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p>While the underlying model will have some set of geometries to represent each body, it can be useful to extend the representative set of geometries.</p>
<p>These APIs admit adding and removing such geometries to the underlying model. We'll distinguish the geometries added by the checker from those in the underlying model by referring to them as "checker" geometries and "model" geometries, respectively.</p>
<p>For example, when an end effector has successfully grasped a manipuland, we can add additional geometry to the end effector body, representing the extent of the manipuland, causing the motion planning to likewise consider collisions with the manipuland. Note, this implicitly treats the manipuland as being rigidly affixed to the end effector.</p>
<p>Checker geometries are managed in groups, identified by "group names". Each group can contain one or more checker geometries. This is particularly useful when multiple geometries should be added and removed as a whole. Simply by storing the shared group name, all checker geometries in the group can be removed with a single invocation, relying on the collision checker to do the book keeping for you.</p>
<p>Note that different collision checker implementations may limit the set of supported Shape types; e.g. sphere-robot-model collision checkers only add sphere shapes to robot bodies, and voxel-based collision checkers cannot add individual collision geometries to the environment at all. Therefore, all methods for adding collision geometries report if the geometries were added. The derived classes should clearly document which shapes they support. </p>
</div></td></tr>
<tr class="memitem:a36952e978a6e386dc832b1dfe957c990" id="r_a36952e978a6e386dc832b1dfe957c990"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a36952e978a6e386dc832b1dfe957c990">AddCollisionShape</a> (const std::string &amp;group_name, const <a class="el" href="classdrake_1_1planning_1_1_body_shape_description.html">BodyShapeDescription</a> &amp;description)</td></tr>
<tr class="memdesc:a36952e978a6e386dc832b1dfe957c990"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests the addition of a shape to a body, both given in <span class="tt">description</span>.  <br /></td></tr>
<tr class="memitem:a67bf182abc9d41aeb581fad57585a7fc" id="r_a67bf182abc9d41aeb581fad57585a7fc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a67bf182abc9d41aeb581fad57585a7fc">AddCollisionShapes</a> (const std::string &amp;group_name, const std::vector&lt; <a class="el" href="classdrake_1_1planning_1_1_body_shape_description.html">BodyShapeDescription</a> &gt; &amp;descriptions)</td></tr>
<tr class="memdesc:a67bf182abc9d41aeb581fad57585a7fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests the addition of N shapes to N bodies, each given in the set of <span class="tt">descriptions</span>.  <br /></td></tr>
<tr class="memitem:a0336ea13062d3d7eae43f0e86ee8a38a" id="r_a0336ea13062d3d7eae43f0e86ee8a38a"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0336ea13062d3d7eae43f0e86ee8a38a">AddCollisionShapes</a> (const std::map&lt; std::string, std::vector&lt; <a class="el" href="classdrake_1_1planning_1_1_body_shape_description.html">BodyShapeDescription</a> &gt; &gt; &amp;geometry_groups)</td></tr>
<tr class="memdesc:a0336ea13062d3d7eae43f0e86ee8a38a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests the addition of a collection of shapes to bodies across multiple geometry groups.  <br /></td></tr>
<tr class="memitem:a5d11d679e9525d2a51454c2c1fffad72" id="r_a5d11d679e9525d2a51454c2c1fffad72"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5d11d679e9525d2a51454c2c1fffad72">AddCollisionShapeToFrame</a> (const std::string &amp;group_name, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">multibody::Frame</a>&lt; double &gt; &amp;frameA, const <a class="el" href="classdrake_1_1geometry_1_1_shape.html">geometry::Shape</a> &amp;shape, const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; double &gt; &amp;X_AG)</td></tr>
<tr class="memdesc:a5d11d679e9525d2a51454c2c1fffad72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests the addition of <span class="tt">shape</span> to the frame A in the checker's model.  <br /></td></tr>
<tr class="memitem:a6b8ea6e05b3b70f876e44eab1f340806" id="r_a6b8ea6e05b3b70f876e44eab1f340806"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b8ea6e05b3b70f876e44eab1f340806">AddCollisionShapeToBody</a> (const std::string &amp;group_name, const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">multibody::RigidBody</a>&lt; double &gt; &amp;bodyA, const <a class="el" href="classdrake_1_1geometry_1_1_shape.html">geometry::Shape</a> &amp;shape, const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; double &gt; &amp;X_AG)</td></tr>
<tr class="memdesc:a6b8ea6e05b3b70f876e44eab1f340806"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests the addition of <span class="tt">shape</span> to the body A in the checker's model The added <span class="tt">shape</span> will belong to the named geometry group.  <br /></td></tr>
<tr class="memitem:af51fe263feb12a3a3734c3aa83569ae8" id="r_af51fe263feb12a3a3734c3aa83569ae8"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, std::vector&lt; <a class="el" href="classdrake_1_1planning_1_1_body_shape_description.html">BodyShapeDescription</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af51fe263feb12a3a3734c3aa83569ae8">GetAllAddedCollisionShapes</a> () const</td></tr>
<tr class="memdesc:af51fe263feb12a3a3734c3aa83569ae8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets all checker geometries currently added across the whole checker.  <br /></td></tr>
<tr class="memitem:a5c936a3e9f8ae2750cb5ce8c18985d0a" id="r_a5c936a3e9f8ae2750cb5ce8c18985d0a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5c936a3e9f8ae2750cb5ce8c18985d0a">RemoveAllAddedCollisionShapes</a> (const std::string &amp;group_name)</td></tr>
<tr class="memdesc:a5c936a3e9f8ae2750cb5ce8c18985d0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all added checker geometries which belong to the named group.  <br /></td></tr>
<tr class="memitem:af1190d81eb661b4151d32b844e86fc5a" id="r_af1190d81eb661b4151d32b844e86fc5a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af1190d81eb661b4151d32b844e86fc5a">RemoveAllAddedCollisionShapes</a> ()</td></tr>
<tr class="memdesc:af1190d81eb661b4151d32b844e86fc5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all added checker geometries from all geometry groups.  <br /></td></tr>
<tr id="pub-methods-4" class="groupHeader"><td colspan="2"><div class="groupHeader">Padding the distance between bodies</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p>Ultimately, the model's bodies are represented with geometries.</p>
<p>The distance between bodies is the distance between their representative geometries. However, the exact distance between those geometries is not necessarily helpful in planning. For example,</p>
<ul>
<li>You may want to add padding when real-world objects differ from the planning geometry.</li>
<li>In some cases, limited penetration is expected, and possibly desirable, such as when grasping in clutter.</li>
</ul>
<p>Padding is a mechanism where these distances can be "fudged" without modifying the underlying model. The <em>reported</em> distance between two bodies can be decreased by adding <em>positive</em> padding or increased by adding negative* padding. One could think of it as padding the geometries &ndash; making the objects larger (positive) or smaller (negative). This isn't quite true. Padding is defined for <em>pairs</em> of geometries.</p>
<p>Ultimately, the padding data is stored in an NxN matrix (where the underlying model has N total bodies). The matrix is symmetric and the entry at (i, j) &ndash; and (j, i) &ndash; is the padding value to be applied to distance measurements between bodies i and j. It is meaningless to apply padding between a body and itself. Furthermore, as CollisionChecker is concerned with the state of the <em>robot</em>, it is equally meaningless to apply padding between environment* bodies. To avoid the illusion of padding, those entries on the diagonal and corresponding to environment body pairs are kept at zero.</p>
<p><u>Configuring padding</u></p>
<p>Padding can be applied at different levels of scope:</p>
<ul>
<li>For all pairs, via <a class="el" href="#ae5073981822b962bcc7ca569b399b3db" title="Sets the collision padding matrix.">SetPaddingMatrix()</a>.</li>
<li>For all (robot, environment) or (robot, robot) pairs via <a class="el" href="#af9df46cf7a999edaee7b5461a38a8e0d" title="Sets the padding for all (robot, environment) pairs.">SetPaddingAllRobotEnvironmentPairs()</a> and <a class="el" href="#af8423473a4d7b2c2b37c7f9c8108c7a3" title="Sets the padding for all (robot, robot) pairs.">SetPaddingAllRobotRobotPairs()</a>.</li>
<li>For all (robot i, environment) pairs via <a class="el" href="#a963ab30a4085cd7704496f7c5289c7df" title="Sets the environment collision padding for the provided robot body with respect to all environment bo...">SetPaddingOneRobotBodyAllEnvironmentPairs()</a>.</li>
<li>For pair (body i, body j) via <a class="el" href="#a2abd1ef467638caa52681db77bd8ea18" title="Sets the padding value for the pair of bodies specified.">SetPaddingBetween()</a>.</li>
</ul>
<p>Invocations of these methods make immediate changes to the underlying padding data. Changing the order of invocations will change the final padding state. In other words, setting padding for a particular pair (A, B) followed by calling, for example, SetPaddingOneRobotBodyAllEnvironmentPairs(A) could erase the effect of the first invocation.</p>
<p><a class="anchor" id="collision_checker_padding_prereqs"></a><u>Configuration prerequisites</u></p>
<p>In all these configuration methods, there are some specific requirements:</p>
<ul>
<li>The padding value must always be finite.</li>
<li>Body indices must be in range (i.e., in [0, N) for a model with N total bodies).</li>
<li>If the parameters include one or more more body indices, at least one of them must reference a robot body.</li>
</ul>
<p><u>Introspection</u></p>
<p>The current state of collision padding can be introspected via a number of methods:</p>
<ul>
<li>View the underlying NxN padding matrix via <a class="el" href="#aa0204ecd934b96efb2d151156b1be9b0" title="Gets the collision padding matrix.">GetPaddingMatrix()</a>.</li>
<li>Find out if padding values are heterogeneous via <a class="el" href="#a8a44e5a7067bb2c6f603aa66f9343d40" title="If the padding between all robot bodies and environment bodies is the same, returns the common paddin...">MaybeGetUniformRobotEnvironmentPadding()</a> and <a class="el" href="#a6e1b0cf9c177dfb7c41fcf1839668e2f" title="If the padding between all pairs of robot bodies is the same, returns the common padding value.">MaybeGetUniformRobotRobotPadding()</a>.</li>
<li>Query the specific padding value between a pair of bodies via <a class="el" href="#a642639c3ef89987db37c8ba232f0f494" title="Gets the padding value for the pair of bodies specified.">GetPaddingBetween()</a>.</li>
<li>Find out the maximum padding value via <a class="el" href="#abbe38491db7dbc7136d180ed55698538" title="Gets the current largest collision padding across all (robot, *) body pairs.">GetLargestPadding()</a>. </li>
</ul>
</div></td></tr>
<tr class="memitem:a8a44e5a7067bb2c6f603aa66f9343d40" id="r_a8a44e5a7067bb2c6f603aa66f9343d40"><td class="memItemLeft" align="right" valign="top">std::optional&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8a44e5a7067bb2c6f603aa66f9343d40">MaybeGetUniformRobotEnvironmentPadding</a> () const</td></tr>
<tr class="memdesc:a8a44e5a7067bb2c6f603aa66f9343d40"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the padding between all robot bodies and environment bodies is the same, returns the common padding value.  <br /></td></tr>
<tr class="memitem:a6e1b0cf9c177dfb7c41fcf1839668e2f" id="r_a6e1b0cf9c177dfb7c41fcf1839668e2f"><td class="memItemLeft" align="right" valign="top">std::optional&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6e1b0cf9c177dfb7c41fcf1839668e2f">MaybeGetUniformRobotRobotPadding</a> () const</td></tr>
<tr class="memdesc:a6e1b0cf9c177dfb7c41fcf1839668e2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the padding between all pairs of robot bodies is the same, returns the common padding value.  <br /></td></tr>
<tr class="memitem:a642639c3ef89987db37c8ba232f0f494" id="r_a642639c3ef89987db37c8ba232f0f494"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a642639c3ef89987db37c8ba232f0f494">GetPaddingBetween</a> (<a class="el" href="namespacedrake_1_1multibody.html#a02d233e6f0ef016f5cf02e2222a22f5c">multibody::BodyIndex</a> bodyA_index, <a class="el" href="namespacedrake_1_1multibody.html#a02d233e6f0ef016f5cf02e2222a22f5c">multibody::BodyIndex</a> bodyB_index) const</td></tr>
<tr class="memdesc:a642639c3ef89987db37c8ba232f0f494"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the padding value for the pair of bodies specified.  <br /></td></tr>
<tr class="memitem:a3fd56eac31d01ff184f7f796f3f18760" id="r_a3fd56eac31d01ff184f7f796f3f18760"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3fd56eac31d01ff184f7f796f3f18760">GetPaddingBetween</a> (const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">multibody::RigidBody</a>&lt; double &gt; &amp;bodyA, const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">multibody::RigidBody</a>&lt; double &gt; &amp;bodyB) const</td></tr>
<tr class="memdesc:a3fd56eac31d01ff184f7f796f3f18760"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload that uses body references.  <br /></td></tr>
<tr class="memitem:a2abd1ef467638caa52681db77bd8ea18" id="r_a2abd1ef467638caa52681db77bd8ea18"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2abd1ef467638caa52681db77bd8ea18">SetPaddingBetween</a> (<a class="el" href="namespacedrake_1_1multibody.html#a02d233e6f0ef016f5cf02e2222a22f5c">multibody::BodyIndex</a> bodyA_index, <a class="el" href="namespacedrake_1_1multibody.html#a02d233e6f0ef016f5cf02e2222a22f5c">multibody::BodyIndex</a> bodyB_index, double padding)</td></tr>
<tr class="memdesc:a2abd1ef467638caa52681db77bd8ea18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the padding value for the pair of bodies specified.  <br /></td></tr>
<tr class="memitem:a216553d6f53318bace05961e5010ab97" id="r_a216553d6f53318bace05961e5010ab97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a216553d6f53318bace05961e5010ab97">SetPaddingBetween</a> (const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">multibody::RigidBody</a>&lt; double &gt; &amp;bodyA, const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">multibody::RigidBody</a>&lt; double &gt; &amp;bodyB, double padding)</td></tr>
<tr class="memdesc:a216553d6f53318bace05961e5010ab97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload that uses body references.  <br /></td></tr>
<tr class="memitem:aa0204ecd934b96efb2d151156b1be9b0" id="r_aa0204ecd934b96efb2d151156b1be9b0"><td class="memItemLeft" align="right" valign="top">const Eigen::MatrixXd &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa0204ecd934b96efb2d151156b1be9b0">GetPaddingMatrix</a> () const</td></tr>
<tr class="memdesc:aa0204ecd934b96efb2d151156b1be9b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the collision padding matrix.  <br /></td></tr>
<tr class="memitem:ae5073981822b962bcc7ca569b399b3db" id="r_ae5073981822b962bcc7ca569b399b3db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae5073981822b962bcc7ca569b399b3db">SetPaddingMatrix</a> (const Eigen::MatrixXd &amp;collision_padding)</td></tr>
<tr class="memdesc:ae5073981822b962bcc7ca569b399b3db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the collision padding matrix.  <br /></td></tr>
<tr class="memitem:abbe38491db7dbc7136d180ed55698538" id="r_abbe38491db7dbc7136d180ed55698538"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abbe38491db7dbc7136d180ed55698538">GetLargestPadding</a> () const</td></tr>
<tr class="memdesc:abbe38491db7dbc7136d180ed55698538"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current largest collision padding across all (robot, *) body pairs.  <br /></td></tr>
<tr class="memitem:a963ab30a4085cd7704496f7c5289c7df" id="r_a963ab30a4085cd7704496f7c5289c7df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a963ab30a4085cd7704496f7c5289c7df">SetPaddingOneRobotBodyAllEnvironmentPairs</a> (<a class="el" href="namespacedrake_1_1multibody.html#a02d233e6f0ef016f5cf02e2222a22f5c">multibody::BodyIndex</a> body_index, double padding)</td></tr>
<tr class="memdesc:a963ab30a4085cd7704496f7c5289c7df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the environment collision padding for the provided robot body with respect to all environment bodies.  <br /></td></tr>
<tr class="memitem:af9df46cf7a999edaee7b5461a38a8e0d" id="r_af9df46cf7a999edaee7b5461a38a8e0d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af9df46cf7a999edaee7b5461a38a8e0d">SetPaddingAllRobotEnvironmentPairs</a> (double padding)</td></tr>
<tr class="memdesc:af9df46cf7a999edaee7b5461a38a8e0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the padding for all (robot, environment) pairs.  <br /></td></tr>
<tr class="memitem:af8423473a4d7b2c2b37c7f9c8108c7a3" id="r_af8423473a4d7b2c2b37c7f9c8108c7a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af8423473a4d7b2c2b37c7f9c8108c7a3">SetPaddingAllRobotRobotPairs</a> (double padding)</td></tr>
<tr class="memdesc:af8423473a4d7b2c2b37c7f9c8108c7a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the padding for all (robot, robot) pairs.  <br /></td></tr>
<tr id="pub-methods-5" class="groupHeader"><td colspan="2"><div class="groupHeader">Collision filtering</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p>The CollisionChecker adapts the idea of "collision filtering" to <em>bodies</em> (see <a class="el" href="classdrake_1_1geometry_1_1_collision_filter_manager.html" title="Class for configuring &quot;collision filters&quot;; collision filters limit the scope of various proximity que...">geometry::CollisionFilterManager</a>).</p>
<p>In addition to whatever collision filters have been declared within the underlying model, CollisionChecker provides mechanisms to layer <em>additional</em> filters by specifying a pair of bodies as being "filtered". No collisions or distance measurements are reported on filtered body pairs.</p>
<p>The "filter" state of all possible body pairs are stored in a symmetric NxN integer-valued matrix, where N is the number of bodies reported by the plant owned by this collision checker.</p>
<p>The matrix can only contain one of three values: 0, 1, and -1. For the (i, j) entry in the matrix, each value would be interpreted as follows:</p>
<p>0: The collision is <em>not</em> filtered. Collision checker will report collisions and clearance between bodies I and J. 1: The collision <em>is</em> filtered. Collision checker will <em>not</em> report collisions and clearance between bodies I and J. -1: The collision <em>is</em> filtered <em>by definition</em>. Collision checker will not* report collisions and clearance between bodies I and J and the user cannot change this state.</p>
<p><a class="el" href="classdrake_1_1planning_1_1_collision_checker.html" title="Interface for collision checkers to use.">CollisionChecker</a> limits itself to characterizing the state of the <em>robot</em>. As such, it <em>always</em> filters collisions between pairs of environment bodies. It also filters collisions between a body and itself as nonsensical. Therefore, the matrix will always have immutable -1s along the diagonal and for every cell representing an environment-environment pair.</p>
<p>The collision filter matrix must remain <em>consistent</em>. Only valid values for body pairs are accepted. I.e., assigning an (environment, environment) pair a value of 0 or 1 is "inconsistent". Likewise doing the same on the diagonal. Alternatively, assigning a -1 to any pair with a robot body would be inconsistent. The functions for configuring collision filters will throw if explicitly asked to make an inconsistent change.</p>
<p>The CollisionChecker's definition of filtered body pairs is initially drawn from the underlying model's configuration (see <a class="el" href="#a81f25e0bab7179f3a00503a4a2a321b4" title="Returns the &quot;nominal&quot; collision filter matrix.">GetNominalFilteredCollisionMatrix()</a>). However, the <a class="el" href="classdrake_1_1planning_1_1_collision_checker.html" title="Interface for collision checkers to use.">CollisionChecker</a>'s definition of the set of collision filters is independent of the model after construction and can be freely modified to allow for greater freedom in determining which bodies can affect each other. </p>
</div></td></tr>
<tr class="memitem:a81f25e0bab7179f3a00503a4a2a321b4" id="r_a81f25e0bab7179f3a00503a4a2a321b4"><td class="memItemLeft" align="right" valign="top">const Eigen::MatrixXi &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a81f25e0bab7179f3a00503a4a2a321b4">GetNominalFilteredCollisionMatrix</a> () const</td></tr>
<tr class="memdesc:a81f25e0bab7179f3a00503a4a2a321b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the "nominal" collision filter matrix.  <br /></td></tr>
<tr class="memitem:ae73ffb323e76df5b732fa9c6c6e74592" id="r_ae73ffb323e76df5b732fa9c6c6e74592"><td class="memItemLeft" align="right" valign="top">const Eigen::MatrixXi &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae73ffb323e76df5b732fa9c6c6e74592">GetFilteredCollisionMatrix</a> () const</td></tr>
<tr class="memdesc:ae73ffb323e76df5b732fa9c6c6e74592"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the "active" collision filter matrix.  <br /></td></tr>
<tr class="memitem:a5741d217236e45f7aed61d7a28c23d39" id="r_a5741d217236e45f7aed61d7a28c23d39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5741d217236e45f7aed61d7a28c23d39">SetCollisionFilterMatrix</a> (const Eigen::MatrixXi &amp;filter_matrix)</td></tr>
<tr class="memdesc:a5741d217236e45f7aed61d7a28c23d39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the "active" collision filter matrix.  <br /></td></tr>
<tr class="memitem:a4c482d9dc344b97944de8b61dc41911f" id="r_a4c482d9dc344b97944de8b61dc41911f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4c482d9dc344b97944de8b61dc41911f">IsCollisionFilteredBetween</a> (<a class="el" href="namespacedrake_1_1multibody.html#a02d233e6f0ef016f5cf02e2222a22f5c">multibody::BodyIndex</a> bodyA_index, <a class="el" href="namespacedrake_1_1multibody.html#a02d233e6f0ef016f5cf02e2222a22f5c">multibody::BodyIndex</a> bodyB_index) const</td></tr>
<tr class="memdesc:a4c482d9dc344b97944de8b61dc41911f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if collision is filtered between the two bodies specified.  <br /></td></tr>
<tr class="memitem:a89638e2733d1b29dc1c66307d49edfc6" id="r_a89638e2733d1b29dc1c66307d49edfc6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a89638e2733d1b29dc1c66307d49edfc6">IsCollisionFilteredBetween</a> (const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">multibody::RigidBody</a>&lt; double &gt; &amp;bodyA, const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">multibody::RigidBody</a>&lt; double &gt; &amp;bodyB) const</td></tr>
<tr class="memdesc:a89638e2733d1b29dc1c66307d49edfc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload that uses body references.  <br /></td></tr>
<tr class="memitem:a87a9e6f72e628e92db913a5f9aa64d3c" id="r_a87a9e6f72e628e92db913a5f9aa64d3c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a87a9e6f72e628e92db913a5f9aa64d3c">SetCollisionFilteredBetween</a> (<a class="el" href="namespacedrake_1_1multibody.html#a02d233e6f0ef016f5cf02e2222a22f5c">multibody::BodyIndex</a> bodyA_index, <a class="el" href="namespacedrake_1_1multibody.html#a02d233e6f0ef016f5cf02e2222a22f5c">multibody::BodyIndex</a> bodyB_index, bool filter_collision)</td></tr>
<tr class="memdesc:a87a9e6f72e628e92db913a5f9aa64d3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the body pair (bodyA, bodyB) to be filtered (or not) based on <span class="tt">filter_collision</span>.  <br /></td></tr>
<tr class="memitem:acd19e60df81a218dc6b60bd661e3a917" id="r_acd19e60df81a218dc6b60bd661e3a917"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acd19e60df81a218dc6b60bd661e3a917">SetCollisionFilteredBetween</a> (const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">multibody::RigidBody</a>&lt; double &gt; &amp;bodyA, const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">multibody::RigidBody</a>&lt; double &gt; &amp;bodyB, bool filter_collision)</td></tr>
<tr class="memdesc:acd19e60df81a218dc6b60bd661e3a917"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload that uses body references.  <br /></td></tr>
<tr class="memitem:adbc935f824f1b4601d04346c0cebac63" id="r_adbc935f824f1b4601d04346c0cebac63"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adbc935f824f1b4601d04346c0cebac63">SetCollisionFilteredWithAllBodies</a> (<a class="el" href="namespacedrake_1_1multibody.html#a02d233e6f0ef016f5cf02e2222a22f5c">multibody::BodyIndex</a> body_index)</td></tr>
<tr class="memdesc:adbc935f824f1b4601d04346c0cebac63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares that body pair (B, O) is filtered (for all bodies O in this checker's plant).  <br /></td></tr>
<tr class="memitem:a9fa7881e827b615483f2ec16d66fac82" id="r_a9fa7881e827b615483f2ec16d66fac82"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9fa7881e827b615483f2ec16d66fac82">SetCollisionFilteredWithAllBodies</a> (const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">multibody::RigidBody</a>&lt; double &gt; &amp;body)</td></tr>
<tr class="memdesc:a9fa7881e827b615483f2ec16d66fac82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload that uses body references.  <br /></td></tr>
<tr id="pub-methods-6" class="groupHeader"><td colspan="2"><div class="groupHeader">Configuration collision checking</div></td></tr>
<tr class="memitem:adb33fbe45f267be402e5e2a750428044" id="r_adb33fbe45f267be402e5e2a750428044"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adb33fbe45f267be402e5e2a750428044">CheckConfigCollisionFree</a> (const Eigen::VectorXd &amp;q, std::optional&lt; int &gt; context_number=std::nullopt) const</td></tr>
<tr class="memdesc:adb33fbe45f267be402e5e2a750428044"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks a single configuration for collision using the current thread's associated context.  <br /></td></tr>
<tr class="memitem:acc6b89337adab829567d9be3fe350517" id="r_acc6b89337adab829567d9be3fe350517"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acc6b89337adab829567d9be3fe350517">CheckContextConfigCollisionFree</a> (<a class="el" href="classdrake_1_1planning_1_1_collision_checker_context.html">CollisionCheckerContext</a> *<a class="el" href="#a5a8b62cb6805a9d647e8ea0c783bb47d">model_context</a>, const Eigen::VectorXd &amp;q) const</td></tr>
<tr class="memdesc:acc6b89337adab829567d9be3fe350517"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit Context-based version of <a class="el" href="#adb33fbe45f267be402e5e2a750428044" title="Checks a single configuration for collision using the current thread&#39;s associated context.">CheckConfigCollisionFree()</a>.  <br /></td></tr>
<tr class="memitem:a48cc1b334d7f2f565b6e66ac82e27b63" id="r_a48cc1b334d7f2f565b6e66ac82e27b63"><td class="memItemLeft" align="right" valign="top">std::vector&lt; uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a48cc1b334d7f2f565b6e66ac82e27b63">CheckConfigsCollisionFree</a> (const std::vector&lt; Eigen::VectorXd &gt; &amp;configs, <a class="el" href="classdrake_1_1_parallelism.html">Parallelism</a> parallelize=<a class="el" href="classdrake_1_1_parallelism.html#a5f5d962dfeec6e675996074f913df819">Parallelism::Max</a>()) const</td></tr>
<tr class="memdesc:a48cc1b334d7f2f565b6e66ac82e27b63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks a vector of configurations for collision, evaluating in parallel when supported and enabled by <span class="tt">parallelize</span>.  <br /></td></tr>
<tr id="pub-methods-7" class="groupHeader"><td colspan="2"><div class="groupHeader">Edge collision checking</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p>These functions serve motion planning methods, such as sampling-based planners and shortcut smoothers, which are concerned about checking that an "edge" between two configurations, q1 and q2, is free of collision.</p>
<p>These functions <em>approximately</em> answer the question: is the edge collision free. The answer is determined by sampling configurations along the edge and reporting the edge to be collision free if all samples are collision free. Otherwise, we report the fraction of samples (starting with the start configuration) that reported to be collision free. The tested samples include the start and end configurations, q1 and q2, respectively.</p>
<p>CollisionChecker doesn't know how an edge is defined. An edge can be anything from a simple line segment (e.g. a linear path in C-space) to an arbitrarily complex path (e.g. a Reeds-Shepp path). The shape of the edge is defined implicitly by the <a class="el" href="namespacedrake_1_1planning.html#a51c19bebe45e89327241c79776dad396" title="Configuration interpolation function takes two configurations of the robot, q1, and q2,...">ConfigurationInterpolationFunction</a> as an interpolation between two configurations <span class="tt">q1</span> and <span class="tt">q2</span> (see <a class="el" href="#ad399081b57b1becb847d9a6f77928903" title="Sets the configuration distance function to distance_function.">SetConfigurationDistanceFunction()</a> and <a class="el" href="#aebf58f4817df47ff85f1e4f3de824382" title="Sets the configuration interpolation function to interpolation_function.">SetConfigurationInterpolationFunction()</a>).</p>
<p>CollisionChecker picks configuration samples along an edge by uniformly sampling the interpolation <em>parameter</em> from zero to one. (By definition, the interpolation at zero is equal to <span class="tt">q1</span> and at one is equal to <span class="tt">q2</span>.) The number of samples is determined by the distance between <span class="tt">q1</span> and <span class="tt">q2</span>, as provided by a <a class="el" href="namespacedrake_1_1planning.html#abdbb6a212eb30d6a68643bf0aebe0426" title="Configuration distance takes two configurations of the robot, q1 and q2, both as Eigen::VectorXd,...">ConfigurationDistanceFunction</a>, divided by "edge step size" (see <a class="el" href="#a285e992424a4197669a43d70f1208474" title="Sets the edge step size to edge_step_size.">set_edge_step_size()</a>).</p>
<p>As a result, the selection of interpolation function, distance function, and edge step size must be coordinated to ensure that edge collision checking is sufficiently accurate for your application.</p>
<p><u>Default functions</u></p>
<p>The configuration distance function is defined at construction (from <a class="el" href="structdrake_1_1planning_1_1_collision_checker_params.html" title="A set of common constructor parameters for a CollisionChecker.">CollisionCheckerParams</a>). It can be as simple as <span class="tt">|q1 - q2|</span> or could be a weighted norm <span class="tt">|wᵀ⋅(q1 − q2)|</span> based on joint importance or unit reconciliation (e.g., some qs are translational and some are rotational). Because of this, the "distance" reported may have arbitrary units.</p>
<p>Whatever the units are, the edge step size must match. The step size value and distance function will determine the number of samples on the edge. The smaller the step size, the more samples (and the more expensive the collision check becomes).</p>
<p>If all joints are revolute joints, one reasonable distance function is the weighted function <span class="tt">|wᵀ⋅(q1 − q2)|</span> where the weights are based on joint speed. For joint dofs <span class="tt">J = [J₀, J₁, ...]</span> with corresponding positive maximum speeds <span class="tt">[s₀, s₁, ...]</span>, we identify the speed of the fastest joint <span class="tt">sₘₐₓ = maxᵢ(sᵢ)</span> and define the per-dof weights as <span class="tt">wᵢ = sₘₐₓ / sᵢ</span>. Intuitively, the more time a particular joint requires to cover an angular distance, the more significance we attribute to that distance &ndash; it's a <em>time</em>-biased weighting function. The weights are unitless so the reported distance is in radians. For some common arms (IIWA, Panda, UR, Jaco, etc.), we have found that an edge step size of 0.05 radians produces reasonable results.</p>
<p>CollisionChecker has a default interpolation function, as defined by MakeDefaultConfigurationInterpolationFunction(). It performs Slerp for quaternion-valued dofs and linear interpolation for all other dofs. Note that this is not appropriate for all robots, (e.g. those using a BallRpyJoint, or any non-holonomic robot). You will need to provide your own interpolation function in such cases.</p>
<p><a class="anchor" id="collision_checker_parallel_edge"></a><u>Function-level parallelism</u></p>
<p>Parallelization in some edge collision checks is provided using OpenMP and is enabled when both: (1) the collision checker declares that parallelization is supported (i.e. when <a class="el" href="#a6831872639ff530b78810ef26115bb26" title="Does the collision checker support true parallel collision checks?">SupportsParallelChecking()</a> is true) and (2) when multiple OpenMP threads are available for execution.</p>
<p>Due to this internal parallelism, special care must be paid when calling these methods from any thread that is not the main thread; ensure that, for a given collision checker instance, implicit context methods are only called from one non-OpenMP thread at a given time.</p>
<p><u>Thoughts on configuring CollisionChecker for edge collision detection</u></p>
<p>Because the edge collision check samples the edge, there is a perpetual trade off between the cost of evaluating the edge and the likelihood that a real collision is missed. In practice, the CollisionChecker should be configured to maximize performance for a reasonable level of collision detection reliability. There is no definitive method for tuning the parameters. Rather than advocating a tuning strategy, we'll simply elaborate on the available parameters and leave the actual tuning as an exercise for the reader.</p>
<p>There are two properties that will most directly contribute to the accuracy of the edge tests: edge step size and padding. Ultimately, any obstacle in <em>C-space</em> whose measure is smaller than the edge step size is likely to be missed. The goal is to tune the parameters such that such features &ndash; located in an area of interest (i.e., where you want your robot to operate) &ndash; will have a low probability of being missed.</p>
<p>Edge step size is very much a global parameter. It will increase the cost of <em>every</em> collision check. If you are unable to anticipate where the small features are, a small edge step size will be robust to that uncertainty. As such, it serves as a good backstop. It comes at a cost of increasing the cost of <em>every</em> test, even for large geometries with nothing but coarse features.</p>
<p>Increasing the padding can likewise reduce the likelihood of missing features. Adding padding has the effect of increasing the size of the workspace obstacles in C-space. The primary benefit is that it can be applied locally. If there is a particular obstacle with fine features that your robot will be near, padding between robot and that obstacle can be added so that interactions between robot and obstacle are more likely to be caught. Doing so leaves the global cost low for coarse features. However, padding comes at the cost that physically free edges may no longer be considered free.</p>
<p>The best tuning will likely include configuring both edge step size and applying appropriate padding. </p>
</div></td></tr>
<tr class="memitem:afef8ab83612978d5deeb7cd6fc413b80" id="r_afef8ab83612978d5deeb7cd6fc413b80"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afef8ab83612978d5deeb7cd6fc413b80">SetDistanceAndInterpolationProvider</a> (std::shared_ptr&lt; const <a class="el" href="classdrake_1_1planning_1_1_distance_and_interpolation_provider.html">DistanceAndInterpolationProvider</a> &gt; provider)</td></tr>
<tr class="memdesc:afef8ab83612978d5deeb7cd6fc413b80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the distance and interpolation provider to use.  <br /></td></tr>
<tr class="memitem:ae18a5310160c2b1c594c623f320c42f5" id="r_ae18a5310160c2b1c594c623f320c42f5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1planning_1_1_distance_and_interpolation_provider.html">DistanceAndInterpolationProvider</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae18a5310160c2b1c594c623f320c42f5">distance_and_interpolation_provider</a> () const</td></tr>
<tr class="memdesc:ae18a5310160c2b1c594c623f320c42f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the <a class="el" href="classdrake_1_1planning_1_1_distance_and_interpolation_provider.html" title="This class represents the base interface for performing configuration distance and interpolation oper...">DistanceAndInterpolationProvider</a> in use.  <br /></td></tr>
<tr class="memitem:ad399081b57b1becb847d9a6f77928903" id="r_ad399081b57b1becb847d9a6f77928903"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad399081b57b1becb847d9a6f77928903">SetConfigurationDistanceFunction</a> (const <a class="el" href="namespacedrake_1_1planning.html#abdbb6a212eb30d6a68643bf0aebe0426">ConfigurationDistanceFunction</a> &amp;distance_function)</td></tr>
<tr class="memdesc:ad399081b57b1becb847d9a6f77928903"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the configuration distance function to <span class="tt">distance_function</span>.  <br /></td></tr>
<tr class="memitem:ae76ac66c1677433ebe8cff135f77af58" id="r_ae76ac66c1677433ebe8cff135f77af58"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae76ac66c1677433ebe8cff135f77af58">ComputeConfigurationDistance</a> (const Eigen::VectorXd &amp;q1, const Eigen::VectorXd &amp;q2) const</td></tr>
<tr class="memdesc:ae76ac66c1677433ebe8cff135f77af58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes configuration-space distance between the provided configurations <span class="tt">q1</span> and <span class="tt">q2</span>, using the distance function configured at construction- time or via <a class="el" href="#ad399081b57b1becb847d9a6f77928903" title="Sets the configuration distance function to distance_function.">SetConfigurationDistanceFunction()</a>.  <br /></td></tr>
<tr class="memitem:a57903558264bcd6cb91e68f8e49d20a1" id="r_a57903558264bcd6cb91e68f8e49d20a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1planning.html#abdbb6a212eb30d6a68643bf0aebe0426">ConfigurationDistanceFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a57903558264bcd6cb91e68f8e49d20a1">MakeStandaloneConfigurationDistanceFunction</a> () const</td></tr>
<tr class="memitem:aebf58f4817df47ff85f1e4f3de824382" id="r_aebf58f4817df47ff85f1e4f3de824382"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aebf58f4817df47ff85f1e4f3de824382">SetConfigurationInterpolationFunction</a> (const <a class="el" href="namespacedrake_1_1planning.html#a51c19bebe45e89327241c79776dad396">ConfigurationInterpolationFunction</a> &amp;interpolation_function)</td></tr>
<tr class="memdesc:aebf58f4817df47ff85f1e4f3de824382"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the configuration interpolation function to <span class="tt">interpolation_function</span>.  <br /></td></tr>
<tr class="memitem:a15d96471a621cda128cdbc959b4f96c9" id="r_a15d96471a621cda128cdbc959b4f96c9"><td class="memItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a15d96471a621cda128cdbc959b4f96c9">InterpolateBetweenConfigurations</a> (const Eigen::VectorXd &amp;q1, const Eigen::VectorXd &amp;q2, double ratio) const</td></tr>
<tr class="memdesc:a15d96471a621cda128cdbc959b4f96c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolates between provided configurations <span class="tt">q1</span> and <span class="tt">q2</span>.  <br /></td></tr>
<tr class="memitem:a07431eb14eaf038162e550c13e1373dc" id="r_a07431eb14eaf038162e550c13e1373dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1planning.html#a51c19bebe45e89327241c79776dad396">ConfigurationInterpolationFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a07431eb14eaf038162e550c13e1373dc">MakeStandaloneConfigurationInterpolationFunction</a> () const</td></tr>
<tr class="memitem:adaa8d8cac0c3193bc48a6fb8229b85e8" id="r_adaa8d8cac0c3193bc48a6fb8229b85e8"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adaa8d8cac0c3193bc48a6fb8229b85e8">edge_step_size</a> () const</td></tr>
<tr class="memdesc:adaa8d8cac0c3193bc48a6fb8229b85e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current edge step size.  <br /></td></tr>
<tr class="memitem:a285e992424a4197669a43d70f1208474" id="r_a285e992424a4197669a43d70f1208474"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a285e992424a4197669a43d70f1208474">set_edge_step_size</a> (double <a class="el" href="#adaa8d8cac0c3193bc48a6fb8229b85e8">edge_step_size</a>)</td></tr>
<tr class="memdesc:a285e992424a4197669a43d70f1208474"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the edge step size to <span class="tt"><a class="el" href="#adaa8d8cac0c3193bc48a6fb8229b85e8" title="Gets the current edge step size.">edge_step_size</a></span>.  <br /></td></tr>
<tr class="memitem:acd7c5dd9a903bedc2d984fe12aa5c409" id="r_acd7c5dd9a903bedc2d984fe12aa5c409"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acd7c5dd9a903bedc2d984fe12aa5c409">CheckEdgeCollisionFree</a> (const Eigen::VectorXd &amp;q1, const Eigen::VectorXd &amp;q2, std::optional&lt; int &gt; context_number=std::nullopt) const</td></tr>
<tr class="memdesc:acd7c5dd9a903bedc2d984fe12aa5c409"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks a single configuration-to-configuration edge for collision, using the current thread's associated context.  <br /></td></tr>
<tr class="memitem:a2ab530c2f1db69b7fcb503447c63ef8f" id="r_a2ab530c2f1db69b7fcb503447c63ef8f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2ab530c2f1db69b7fcb503447c63ef8f">CheckContextEdgeCollisionFree</a> (<a class="el" href="classdrake_1_1planning_1_1_collision_checker_context.html">CollisionCheckerContext</a> *<a class="el" href="#a5a8b62cb6805a9d647e8ea0c783bb47d">model_context</a>, const Eigen::VectorXd &amp;q1, const Eigen::VectorXd &amp;q2) const</td></tr>
<tr class="memdesc:a2ab530c2f1db69b7fcb503447c63ef8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit Context-based version of <a class="el" href="#acd7c5dd9a903bedc2d984fe12aa5c409" title="Checks a single configuration-to-configuration edge for collision, using the current thread&#39;s associa...">CheckEdgeCollisionFree()</a>.  <br /></td></tr>
<tr class="memitem:a6bb8c478f30ea78ac72ce0e557c6067d" id="r_a6bb8c478f30ea78ac72ce0e557c6067d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6bb8c478f30ea78ac72ce0e557c6067d">CheckEdgeCollisionFreeParallel</a> (const Eigen::VectorXd &amp;q1, const Eigen::VectorXd &amp;q2, <a class="el" href="classdrake_1_1_parallelism.html">Parallelism</a> parallelize=<a class="el" href="classdrake_1_1_parallelism.html#a5f5d962dfeec6e675996074f913df819">Parallelism::Max</a>()) const</td></tr>
<tr class="memdesc:a6bb8c478f30ea78ac72ce0e557c6067d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks a single configuration-to-configuration edge for collision.  <br /></td></tr>
<tr class="memitem:a5e46f4dff608e99d432d3c700e870c4a" id="r_a5e46f4dff608e99d432d3c700e870c4a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5e46f4dff608e99d432d3c700e870c4a">CheckEdgesCollisionFree</a> (const std::vector&lt; std::pair&lt; Eigen::VectorXd, Eigen::VectorXd &gt; &gt; &amp;edges, <a class="el" href="classdrake_1_1_parallelism.html">Parallelism</a> parallelize=<a class="el" href="classdrake_1_1_parallelism.html#a5f5d962dfeec6e675996074f913df819">Parallelism::Max</a>()) const</td></tr>
<tr class="memdesc:a5e46f4dff608e99d432d3c700e870c4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks multiple configuration-to-configuration edges for collision.  <br /></td></tr>
<tr class="memitem:ac60fa98836f3dac1975ebc8f7a68b223" id="r_ac60fa98836f3dac1975ebc8f7a68b223"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1planning_1_1_edge_measure.html">EdgeMeasure</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac60fa98836f3dac1975ebc8f7a68b223">MeasureEdgeCollisionFree</a> (const Eigen::VectorXd &amp;q1, const Eigen::VectorXd &amp;q2, std::optional&lt; int &gt; context_number=std::nullopt) const</td></tr>
<tr class="memdesc:ac60fa98836f3dac1975ebc8f7a68b223"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks a single configuration-to-configuration edge for collision, using the current thread's associated context.  <br /></td></tr>
<tr class="memitem:a769397ad377b0ff40c67cc3e373ee8a1" id="r_a769397ad377b0ff40c67cc3e373ee8a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1planning_1_1_edge_measure.html">EdgeMeasure</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a769397ad377b0ff40c67cc3e373ee8a1">MeasureContextEdgeCollisionFree</a> (<a class="el" href="classdrake_1_1planning_1_1_collision_checker_context.html">CollisionCheckerContext</a> *<a class="el" href="#a5a8b62cb6805a9d647e8ea0c783bb47d">model_context</a>, const Eigen::VectorXd &amp;q1, const Eigen::VectorXd &amp;q2) const</td></tr>
<tr class="memdesc:a769397ad377b0ff40c67cc3e373ee8a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit Context-based version of <a class="el" href="#ac60fa98836f3dac1975ebc8f7a68b223" title="Checks a single configuration-to-configuration edge for collision, using the current thread&#39;s associa...">MeasureEdgeCollisionFree()</a>.  <br /></td></tr>
<tr class="memitem:ae06d7f2e61a9d56deb761d03a216f01b" id="r_ae06d7f2e61a9d56deb761d03a216f01b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1planning_1_1_edge_measure.html">EdgeMeasure</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae06d7f2e61a9d56deb761d03a216f01b">MeasureEdgeCollisionFreeParallel</a> (const Eigen::VectorXd &amp;q1, const Eigen::VectorXd &amp;q2, <a class="el" href="classdrake_1_1_parallelism.html">Parallelism</a> parallelize=<a class="el" href="classdrake_1_1_parallelism.html#a5f5d962dfeec6e675996074f913df819">Parallelism::Max</a>()) const</td></tr>
<tr class="memdesc:ae06d7f2e61a9d56deb761d03a216f01b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks a single configuration-to-configuration edge for collision.  <br /></td></tr>
<tr class="memitem:a75d2f68e2c725852eb833732c48f047e" id="r_a75d2f68e2c725852eb833732c48f047e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classdrake_1_1planning_1_1_edge_measure.html">EdgeMeasure</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a75d2f68e2c725852eb833732c48f047e">MeasureEdgesCollisionFree</a> (const std::vector&lt; std::pair&lt; Eigen::VectorXd, Eigen::VectorXd &gt; &gt; &amp;edges, <a class="el" href="classdrake_1_1_parallelism.html">Parallelism</a> parallelize=<a class="el" href="classdrake_1_1_parallelism.html#a5f5d962dfeec6e675996074f913df819">Parallelism::Max</a>()) const</td></tr>
<tr class="memdesc:a75d2f68e2c725852eb833732c48f047e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks multiple configuration-to-configuration edge for collision.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-member-group" class="groupheader"><a id="member-group" name="member-group"></a>
Internal overridable implementations of public methods.</h2></td></tr>
<tr class="memitem:a20c31df6bcbc8410dc3c9fca03b22320" id="r_a20c31df6bcbc8410dc3c9fca03b22320"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="#a236e58ced4f42c22e7395000ecaaeb7b">CollisionChecker</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a20c31df6bcbc8410dc3c9fca03b22320">DoClone</a> () const =0</td></tr>
<tr class="memdesc:a20c31df6bcbc8410dc3c9fca03b22320"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived collision checkers implement can make use of the protected copy constructor to implement <a class="el" href="#a20c31df6bcbc8410dc3c9fca03b22320" title="Derived collision checkers implement can make use of the protected copy constructor to implement DoCl...">DoClone()</a>.  <br /></td></tr>
<tr class="memitem:af4a3f7ae74cf3f31e5f3a3b840d111a5" id="r_af4a3f7ae74cf3f31e5f3a3b840d111a5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af4a3f7ae74cf3f31e5f3a3b840d111a5">DoUpdateContextPositions</a> (<a class="el" href="classdrake_1_1planning_1_1_collision_checker_context.html">CollisionCheckerContext</a> *<a class="el" href="#a5a8b62cb6805a9d647e8ea0c783bb47d">model_context</a>) const =0</td></tr>
<tr class="memdesc:af4a3f7ae74cf3f31e5f3a3b840d111a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived collision checkers can do further work in this function in response to updates to the MultibodyPlant positions.  <br /></td></tr>
<tr class="memitem:a751ed5a04cd06853f43ab40f1ac5dde6" id="r_a751ed5a04cd06853f43ab40f1ac5dde6"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a751ed5a04cd06853f43ab40f1ac5dde6">DoCheckContextConfigCollisionFree</a> (const <a class="el" href="classdrake_1_1planning_1_1_collision_checker_context.html">CollisionCheckerContext</a> &amp;<a class="el" href="#a5a8b62cb6805a9d647e8ea0c783bb47d">model_context</a>) const =0</td></tr>
<tr class="memdesc:a751ed5a04cd06853f43ab40f1ac5dde6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived collision checkers are responsible for reporting the collision status of the configuration.  <br /></td></tr>
<tr class="memitem:a5c07f13becacf1aacae6bff5cfff24cd" id="r_a5c07f13becacf1aacae6bff5cfff24cd"><td class="memItemLeft" align="right" valign="top">virtual std::optional&lt; <a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">geometry::GeometryId</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5c07f13becacf1aacae6bff5cfff24cd">DoAddCollisionShapeToBody</a> (const std::string &amp;group_name, const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">multibody::RigidBody</a>&lt; double &gt; &amp;bodyA, const <a class="el" href="classdrake_1_1geometry_1_1_shape.html">geometry::Shape</a> &amp;shape, const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; double &gt; &amp;X_AG)=0</td></tr>
<tr class="memdesc:a5c07f13becacf1aacae6bff5cfff24cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does the work of adding a shape to be rigidly affixed to the body.  <br /></td></tr>
<tr class="memitem:ad9de25681f79223e3157ee5835ff85da" id="r_ad9de25681f79223e3157ee5835ff85da"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad9de25681f79223e3157ee5835ff85da">RemoveAddedGeometries</a> (const std::vector&lt; <a class="el" href="structdrake_1_1planning_1_1_collision_checker_1_1_added_shape.html">AddedShape</a> &gt; &amp;shapes)=0</td></tr>
<tr class="memdesc:ad9de25681f79223e3157ee5835ff85da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all of the given added shapes (if they exist) from the checker.  <br /></td></tr>
<tr class="memitem:a798297e12a4bdd3f95081215966ed07d" id="r_a798297e12a4bdd3f95081215966ed07d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a798297e12a4bdd3f95081215966ed07d">UpdateCollisionFilters</a> ()=0</td></tr>
<tr class="memdesc:a798297e12a4bdd3f95081215966ed07d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived collision checkers can do further work in this function in response to changes in collision filters.  <br /></td></tr>
<tr class="memitem:a8393e34359ae424d80b7975551234652" id="r_a8393e34359ae424d80b7975551234652"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdrake_1_1planning_1_1_robot_clearance.html">RobotClearance</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8393e34359ae424d80b7975551234652">DoCalcContextRobotClearance</a> (const <a class="el" href="classdrake_1_1planning_1_1_collision_checker_context.html">CollisionCheckerContext</a> &amp;<a class="el" href="#a5a8b62cb6805a9d647e8ea0c783bb47d">model_context</a>, double influence_distance) const =0</td></tr>
<tr class="memdesc:a8393e34359ae424d80b7975551234652"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived collision checkers are responsible for defining the reported measurements.  <br /></td></tr>
<tr class="memitem:ab426080b04fbbf03aeba88ac67517e8d" id="r_ab426080b04fbbf03aeba88ac67517e8d"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="group__planning__collision__checker.html#ga6e884b3a7afc04b1a0c132ce264c14b7">RobotCollisionType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab426080b04fbbf03aeba88ac67517e8d">DoClassifyContextBodyCollisions</a> (const <a class="el" href="classdrake_1_1planning_1_1_collision_checker_context.html">CollisionCheckerContext</a> &amp;<a class="el" href="#a5a8b62cb6805a9d647e8ea0c783bb47d">model_context</a>) const =0</td></tr>
<tr class="memdesc:ab426080b04fbbf03aeba88ac67517e8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived collision checkers are responsible for choosing a collision type for each of the robot bodies.  <br /></td></tr>
<tr class="memitem:a145c8a89488c119f22a13557dd2376b9" id="r_a145c8a89488c119f22a13557dd2376b9"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a145c8a89488c119f22a13557dd2376b9">DoMaxContextNumDistances</a> (const <a class="el" href="classdrake_1_1planning_1_1_collision_checker_context.html">CollisionCheckerContext</a> &amp;<a class="el" href="#a5a8b62cb6805a9d647e8ea0c783bb47d">model_context</a>) const =0</td></tr>
<tr class="memdesc:a145c8a89488c119f22a13557dd2376b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived collision checkers must implement the semantics documented for MaxNumDistances.  <br /></td></tr>
<tr class="memitem:a1a55cd16a37b3e35a8a870dd867257f1" id="r_a1a55cd16a37b3e35a8a870dd867257f1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a55cd16a37b3e35a8a870dd867257f1">CanEvaluateInParallel</a> () const</td></tr>
<tr class="memitem:ad9406112c93e430d27b84744b6f5fa77" id="r_ad9406112c93e430d27b84744b6f5fa77"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad9406112c93e430d27b84744b6f5fa77">CriticizePaddingMatrix</a> () const</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-member-group" class="groupheader"><a id="member-group" name="member-group"></a>
Robot collision state</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>These methods help characterize the robot's collision state with respect to a particular robot configuration.</p>
<p>In this section, the "collision state" is characterized with two different APIs:</p>
<ul>
<li>"clearance", a measure of how near to collision the robot as computed by <a class="el" href="#a2b9fc782d20ef71bf845c913e3f9b7c8" title="Calculates the distance, ϕ, and distance Jacobian, Jqᵣ_ϕ, for each potential collision whose distance...">CalcRobotClearance()</a>, and</li>
<li>a boolean colliding state for each robot body as computed by <a class="el" href="#ae6086bc18a71a830249985033f740d94" title="Classifies which robot bodies are in collision (and which type of collision) for the provided configu...">ClassifyBodyCollisions()</a>. </li>
</ul>
</td></tr>
<tr class="memitem:a2b9fc782d20ef71bf845c913e3f9b7c8" id="r_a2b9fc782d20ef71bf845c913e3f9b7c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1planning_1_1_robot_clearance.html">RobotClearance</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2b9fc782d20ef71bf845c913e3f9b7c8">CalcRobotClearance</a> (const Eigen::VectorXd &amp;q, double influence_distance, std::optional&lt; int &gt; context_number=std::nullopt) const</td></tr>
<tr class="memdesc:a2b9fc782d20ef71bf845c913e3f9b7c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the distance, ϕ, and distance Jacobian, Jqᵣ_ϕ, for each potential collision whose distance is less than <span class="tt">influence_distance</span>, using the current thread's associated context.  <br /></td></tr>
<tr class="memitem:a087708be5fd97325b70c6da77de44eae" id="r_a087708be5fd97325b70c6da77de44eae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1planning_1_1_robot_clearance.html">RobotClearance</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a087708be5fd97325b70c6da77de44eae">CalcContextRobotClearance</a> (<a class="el" href="classdrake_1_1planning_1_1_collision_checker_context.html">CollisionCheckerContext</a> *<a class="el" href="#a5a8b62cb6805a9d647e8ea0c783bb47d">model_context</a>, const Eigen::VectorXd &amp;q, double influence_distance) const</td></tr>
<tr class="memdesc:a087708be5fd97325b70c6da77de44eae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit Context-based version of <a class="el" href="#a2b9fc782d20ef71bf845c913e3f9b7c8" title="Calculates the distance, ϕ, and distance Jacobian, Jqᵣ_ϕ, for each potential collision whose distance...">CalcRobotClearance()</a>.  <br /></td></tr>
<tr class="memitem:acb92e0e060e99a17ea72a57daba72251" id="r_acb92e0e060e99a17ea72a57daba72251"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acb92e0e060e99a17ea72a57daba72251">MaxNumDistances</a> (std::optional&lt; int &gt; context_number=std::nullopt) const</td></tr>
<tr class="memdesc:acb92e0e060e99a17ea72a57daba72251"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an upper bound on the number of distances returned by <a class="el" href="#a2b9fc782d20ef71bf845c913e3f9b7c8" title="Calculates the distance, ϕ, and distance Jacobian, Jqᵣ_ϕ, for each potential collision whose distance...">CalcRobotClearance()</a>, using the current thread's associated context.  <br /></td></tr>
<tr class="memitem:a23bcd057122f2a90fd8e673a51e9bcd3" id="r_a23bcd057122f2a90fd8e673a51e9bcd3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a23bcd057122f2a90fd8e673a51e9bcd3">MaxContextNumDistances</a> (const <a class="el" href="classdrake_1_1planning_1_1_collision_checker_context.html">CollisionCheckerContext</a> &amp;<a class="el" href="#a5a8b62cb6805a9d647e8ea0c783bb47d">model_context</a>) const</td></tr>
<tr class="memdesc:a23bcd057122f2a90fd8e673a51e9bcd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit Context-based version of <a class="el" href="#acb92e0e060e99a17ea72a57daba72251" title="Returns an upper bound on the number of distances returned by CalcRobotClearance(),...">MaxNumDistances()</a>.  <br /></td></tr>
<tr class="memitem:ae6086bc18a71a830249985033f740d94" id="r_ae6086bc18a71a830249985033f740d94"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="group__planning__collision__checker.html#ga6e884b3a7afc04b1a0c132ce264c14b7">RobotCollisionType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae6086bc18a71a830249985033f740d94">ClassifyBodyCollisions</a> (const Eigen::VectorXd &amp;q, std::optional&lt; int &gt; context_number=std::nullopt) const</td></tr>
<tr class="memdesc:ae6086bc18a71a830249985033f740d94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Classifies which robot bodies are in collision (and which type of collision) for the provided configuration <span class="tt">q</span>, using the current thread's associated context.  <br /></td></tr>
<tr class="memitem:a7bed4349eab4c529e90c87bbcb96dafa" id="r_a7bed4349eab4c529e90c87bbcb96dafa"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="group__planning__collision__checker.html#ga6e884b3a7afc04b1a0c132ce264c14b7">RobotCollisionType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7bed4349eab4c529e90c87bbcb96dafa">ClassifyContextBodyCollisions</a> (<a class="el" href="classdrake_1_1planning_1_1_collision_checker_context.html">CollisionCheckerContext</a> *<a class="el" href="#a5a8b62cb6805a9d647e8ea0c783bb47d">model_context</a>, const Eigen::VectorXd &amp;q) const</td></tr>
<tr class="memdesc:a7bed4349eab4c529e90c87bbcb96dafa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit Context-based version of <a class="el" href="#ae6086bc18a71a830249985033f740d94" title="Classifies which robot bodies are in collision (and which type of collision) for the provided configu...">ClassifyBodyCollisions()</a>.  <br /></td></tr>
<tr class="memitem:a6831872639ff530b78810ef26115bb26" id="r_a6831872639ff530b78810ef26115bb26"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6831872639ff530b78810ef26115bb26">SupportsParallelChecking</a> () const</td></tr>
<tr class="memdesc:a6831872639ff530b78810ef26115bb26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does the collision checker support true parallel collision checks?  <br /></td></tr>
<tr class="memitem:abf9f38d4551063f5871e7d88d1b4f449" id="r_abf9f38d4551063f5871e7d88d1b4f449"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abf9f38d4551063f5871e7d88d1b4f449">CollisionChecker</a> (<a class="el" href="structdrake_1_1planning_1_1_collision_checker_params.html">CollisionCheckerParams</a> params, bool supports_parallel_checking)</td></tr>
<tr class="memdesc:abf9f38d4551063f5871e7d88d1b4f449"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived classes declare upon construction whether they support parallel checking (see <a class="el" href="#a6831872639ff530b78810ef26115bb26" title="Does the collision checker support true parallel collision checks?">SupportsParallelChecking()</a>).  <br /></td></tr>
<tr class="memitem:a39e0515b70f3d7475edac30d4f60aee3" id="r_a39e0515b70f3d7475edac30d4f60aee3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a39e0515b70f3d7475edac30d4f60aee3">CollisionChecker</a> (const CollisionChecker &amp;)</td></tr>
<tr class="memdesc:a39e0515b70f3d7475edac30d4f60aee3"><td class="mdescLeft">&#160;</td><td class="mdescRight">To support <a class="el" href="#ac41b3899f6c88a6c13ea82b776a8f9e3">Clone()</a>, allow copying (but not move nor assign).  <br /></td></tr>
<tr class="memitem:a381697ea7e2a890f5cd018d7c6dc8bc2" id="r_a381697ea7e2a890f5cd018d7c6dc8bc2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a381697ea7e2a890f5cd018d7c6dc8bc2">AllocateContexts</a> ()</td></tr>
<tr class="memdesc:a381697ea7e2a890f5cd018d7c6dc8bc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate the per-thread context pool, and discontinue mutable access to the robot model.  <br /></td></tr>
<tr class="memitem:a0f8ed11e66563529eaa64e83f7b534d9" id="r_a0f8ed11e66563529eaa64e83f7b534d9"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classdrake_1_1planning_1_1_collision_checker_context.html">CollisionCheckerContext</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0f8ed11e66563529eaa64e83f7b534d9">CreatePrototypeContext</a> () const</td></tr>
<tr class="memdesc:a0f8ed11e66563529eaa64e83f7b534d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collision checkers that use derived context types can override this implementation to allocate their context type instead.  <br /></td></tr>
<tr class="memitem:aa28eccaff2de74330a76a1e48c0368c5" id="r_aa28eccaff2de74330a76a1e48c0368c5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa28eccaff2de74330a76a1e48c0368c5">IsInitialSetup</a> () const</td></tr>
<tr class="memitem:a6e5de66acea304deca00ac047b77b480" id="r_a6e5de66acea304deca00ac047b77b480"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1planning_1_1_robot_diagram.html">RobotDiagram</a>&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6e5de66acea304deca00ac047b77b480">GetMutableSetupModel</a> ()</td></tr>
</table>
<a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a236e58ced4f42c22e7395000ecaaeb7b" name="a236e58ced4f42c22e7395000ecaaeb7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a236e58ced4f42c22e7395000ecaaeb7b">&#9670;&#160;</a></span>CollisionChecker() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CollisionChecker </td>
          <td>(</td>
          <td class="paramtype">CollisionChecker &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9f469a8ba4f8fbd62921ff2f18590ce5" name="a9f469a8ba4f8fbd62921ff2f18590ce5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f469a8ba4f8fbd62921ff2f18590ce5">&#9670;&#160;</a></span>~CollisionChecker()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ~<a class="el" href="#a236e58ced4f42c22e7395000ecaaeb7b">CollisionChecker</a> </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abf9f38d4551063f5871e7d88d1b4f449" name="abf9f38d4551063f5871e7d88d1b4f449"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf9f38d4551063f5871e7d88d1b4f449">&#9670;&#160;</a></span>CollisionChecker() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CollisionChecker </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdrake_1_1planning_1_1_collision_checker_params.html">CollisionCheckerParams</a></td>          <td class="paramname"><span class="paramname"><em>params</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>supports_parallel_checking</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Derived classes declare upon construction whether they support parallel checking (see <a class="el" href="#a6831872639ff530b78810ef26115bb26" title="Does the collision checker support true parallel collision checks?">SupportsParallelChecking()</a>). </p>
<p>If a derived class does not support parallel checking, it must set params.implicit_context_parallelism to <a class="el" href="classdrake_1_1_parallelism.html#a7eba2010dfc9482ef2ae0bb0539a3083" title="Constructs a Parallelism with no parallelism (i.e., num_threads=1).">Parallelism::None()</a>; otherwise this constructor will throw. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if params is invalid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structdrake_1_1planning_1_1_collision_checker_params.html" title="A set of common constructor parameters for a CollisionChecker.">CollisionCheckerParams</a>. </dd></dl>

</div>
</div>
<a id="a39e0515b70f3d7475edac30d4f60aee3" name="a39e0515b70f3d7475edac30d4f60aee3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39e0515b70f3d7475edac30d4f60aee3">&#9670;&#160;</a></span>CollisionChecker() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CollisionChecker </td>
          <td>(</td>
          <td class="paramtype">const CollisionChecker &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>To support <a class="el" href="#ac41b3899f6c88a6c13ea82b776a8f9e3">Clone()</a>, allow copying (but not move nor assign). </p>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="a36952e978a6e386dc832b1dfe957c990" name="a36952e978a6e386dc832b1dfe957c990"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36952e978a6e386dc832b1dfe957c990">&#9670;&#160;</a></span>AddCollisionShape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AddCollisionShape </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>group_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1planning_1_1_body_shape_description.html">BodyShapeDescription</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>description</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Requests the addition of a shape to a body, both given in <span class="tt">description</span>. </p>
<p>If added, the shape will belong to the named geometry group.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_name</td><td>The name of the group to add the geometry to. </td></tr>
    <tr><td class="paramname">description</td><td>The data describing the shape and target body. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><span class="tt">true</span> if the shape was added. </dd></dl>

</div>
</div>
<a id="a0336ea13062d3d7eae43f0e86ee8a38a" name="a0336ea13062d3d7eae43f0e86ee8a38a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0336ea13062d3d7eae43f0e86ee8a38a">&#9670;&#160;</a></span>AddCollisionShapes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; std::string, int &gt; AddCollisionShapes </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; std::string, std::vector&lt; <a class="el" href="classdrake_1_1planning_1_1_body_shape_description.html">BodyShapeDescription</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>geometry_groups</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Requests the addition of a collection of shapes to bodies across multiple geometry groups. </p>
<p><span class="tt">geometry_groups</span> specifies a collection of (shape, body) descriptors across multiple geometry groups.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">geometry_groups</td><td>A map from a named geometry group to the (shape, body) pairs to add to that group. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A map from input named geometry group to the <em>number</em> of geometries added to that group. </dd></dl>

</div>
</div>
<a id="a67bf182abc9d41aeb581fad57585a7fc" name="a67bf182abc9d41aeb581fad57585a7fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67bf182abc9d41aeb581fad57585a7fc">&#9670;&#160;</a></span>AddCollisionShapes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AddCollisionShapes </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>group_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classdrake_1_1planning_1_1_body_shape_description.html">BodyShapeDescription</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>descriptions</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Requests the addition of N shapes to N bodies, each given in the set of <span class="tt">descriptions</span>. </p>
<p>Each added shape will belong to the named geometry group.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_name</td><td>The name of the group to add the geometry to. </td></tr>
    <tr><td class="paramname">descriptions</td><td>The descriptions of N (shape, body) pairs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The total number of shapes in <span class="tt">descriptions</span> that got added. </dd></dl>

</div>
</div>
<a id="a6b8ea6e05b3b70f876e44eab1f340806" name="a6b8ea6e05b3b70f876e44eab1f340806"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b8ea6e05b3b70f876e44eab1f340806">&#9670;&#160;</a></span>AddCollisionShapeToBody()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AddCollisionShapeToBody </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>group_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">multibody::RigidBody</a>&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>bodyA</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1_shape.html">geometry::Shape</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>shape</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>X_AG</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Requests the addition of <span class="tt">shape</span> to the body A in the checker's model The added <span class="tt">shape</span> will belong to the named geometry group. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_name</td><td>The name of the group to add the geometry to. </td></tr>
    <tr><td class="paramname">bodyA</td><td>The body the shape should be rigidly affixed to. </td></tr>
    <tr><td class="paramname">shape</td><td>The requested shape, defined in its canonical frame G. </td></tr>
    <tr><td class="paramname">X_AG</td><td>The pose of the shape in body A's frame. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><span class="tt">true</span> if the shape was added. </dd></dl>

</div>
</div>
<a id="a5d11d679e9525d2a51454c2c1fffad72" name="a5d11d679e9525d2a51454c2c1fffad72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d11d679e9525d2a51454c2c1fffad72">&#9670;&#160;</a></span>AddCollisionShapeToFrame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AddCollisionShapeToFrame </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>group_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">multibody::Frame</a>&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>frameA</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1_shape.html">geometry::Shape</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>shape</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>X_AG</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Requests the addition of <span class="tt">shape</span> to the frame A in the checker's model. </p>
<p>The added <span class="tt">shape</span> will belong to the named geometry group.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_name</td><td>The name of the group to add the geometry to. </td></tr>
    <tr><td class="paramname">frameA</td><td>The frame the shape should be rigidly affixed to. </td></tr>
    <tr><td class="paramname">shape</td><td>The requested shape, defined in its canonical frame G. </td></tr>
    <tr><td class="paramname">X_AG</td><td>The pose of the shape in the frame A. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><span class="tt">true</span> if the shape was added. </dd></dl>

</div>
</div>
<a id="a381697ea7e2a890f5cd018d7c6dc8bc2" name="a381697ea7e2a890f5cd018d7c6dc8bc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a381697ea7e2a890f5cd018d7c6dc8bc2">&#9670;&#160;</a></span>AllocateContexts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AllocateContexts </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate the per-thread context pool, and discontinue mutable access to the robot model. </p>
<p>This must be called and only be called as part of the constructor in a derived class defined as final.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This cannot have already been called for this instance. </dd></dl>

</div>
</div>
<a id="a087708be5fd97325b70c6da77de44eae" name="a087708be5fd97325b70c6da77de44eae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a087708be5fd97325b70c6da77de44eae">&#9670;&#160;</a></span>CalcContextRobotClearance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1planning_1_1_robot_clearance.html">RobotClearance</a> CalcContextRobotClearance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1planning_1_1_collision_checker_context.html">CollisionCheckerContext</a> *</td>          <td class="paramname"><span class="paramname"><em>model_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>q</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>influence_distance</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Explicit Context-based version of <a class="el" href="#a2b9fc782d20ef71bf845c913e3f9b7c8" title="Calculates the distance, ϕ, and distance Jacobian, Jqᵣ_ϕ, for each potential collision whose distance...">CalcRobotClearance()</a>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <span class="tt"><a class="el" href="#a5a8b62cb6805a9d647e8ea0c783bb47d" title="Accesses a collision checking context from within the implicit context pool owned by this collision c...">model_context</a></span> is nullptr. </td></tr>
    <tr><td class="paramname">if</td><td><span class="tt">q</span> contains non-finite values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ccb_explicit_contexts">Explicit Context Parallelism</a>. </dd></dl>

</div>
</div>
<a id="a2b9fc782d20ef71bf845c913e3f9b7c8" name="a2b9fc782d20ef71bf845c913e3f9b7c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b9fc782d20ef71bf845c913e3f9b7c8">&#9670;&#160;</a></span>CalcRobotClearance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1planning_1_1_robot_clearance.html">RobotClearance</a> CalcRobotClearance </td>
          <td>(</td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>q</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>influence_distance</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; int &gt;</td>          <td class="paramname"><span class="paramname"><em>context_number</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::nullopt</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the distance, ϕ, and distance Jacobian, Jqᵣ_ϕ, for each potential collision whose distance is less than <span class="tt">influence_distance</span>, using the current thread's associated context. </p>
<p>Distances for filtered collisions will not be returned.</p>
<p>Distances between a pair of robot bodies (i.e., where <span class="tt">collision_types()</span> reports <span class="tt">SelfCollision</span>) report one body's index in <span class="tt">robot_indices()</span> and the the other body's in <span class="tt">other_indices()</span>; which body appears in which column is arbitrary.</p>
<p>The total number of rows can depend on how the model is defined and how a particular <a class="el" href="classdrake_1_1planning_1_1_collision_checker.html" title="Interface for collision checkers to use.">CollisionChecker</a> instance is implemented (see <a class="el" href="#acb92e0e060e99a17ea72a57daba72251" title="Returns an upper bound on the number of distances returned by CalcRobotClearance(),...">MaxNumDistances()</a>). </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1planning_1_1_robot_clearance.html" title="A summary of the clearance – a collection of distance measurements – between the robot and everything...">RobotClearance</a> for details on the quantities ϕ and Jqᵣ_ϕ (and other details). </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context_number</td><td>Optional implicit context number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">if</td><td><span class="tt">q</span> contains non-finite values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ccb_implicit_contexts">Implicit Context Parallelism</a>. </dd></dl>

</div>
</div>
<a id="a1a55cd16a37b3e35a8a870dd867257f1" name="a1a55cd16a37b3e35a8a870dd867257f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a55cd16a37b3e35a8a870dd867257f1">&#9670;&#160;</a></span>CanEvaluateInParallel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CanEvaluateInParallel </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if this object <a class="el" href="#a6831872639ff530b78810ef26115bb26" title="Does the collision checker support true parallel collision checks?">SupportsParallelChecking()</a> and more than one thread is available. </dd></dl>

</div>
</div>
<a id="adb33fbe45f267be402e5e2a750428044" name="adb33fbe45f267be402e5e2a750428044"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb33fbe45f267be402e5e2a750428044">&#9670;&#160;</a></span>CheckConfigCollisionFree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CheckConfigCollisionFree </td>
          <td>(</td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>q</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; int &gt;</td>          <td class="paramname"><span class="paramname"><em>context_number</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::nullopt</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks a single configuration for collision using the current thread's associated context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>Configuration to check </td></tr>
    <tr><td class="paramname">context_number</td><td>Optional implicit context number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if collision free, false if in collision. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">if</td><td><span class="tt">q</span> contains non-finite values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ccb_implicit_contexts">Implicit Context Parallelism</a>. </dd></dl>

</div>
</div>
<a id="a48cc1b334d7f2f565b6e66ac82e27b63" name="a48cc1b334d7f2f565b6e66ac82e27b63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48cc1b334d7f2f565b6e66ac82e27b63">&#9670;&#160;</a></span>CheckConfigsCollisionFree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; uint8_t &gt; CheckConfigsCollisionFree </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Eigen::VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>configs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_parallelism.html">Parallelism</a></td>          <td class="paramname"><span class="paramname"><em>parallelize</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classdrake_1_1_parallelism.html#a5f5d962dfeec6e675996074f913df819">Parallelism::Max</a>()</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks a vector of configurations for collision, evaluating in parallel when supported and enabled by <span class="tt">parallelize</span>. </p>
<p>Parallelization in configuration collision checks is provided using OpenMP and is supported when both: (1) the collision checker declares that parallelization is supported (i.e. when <a class="el" href="#a6831872639ff530b78810ef26115bb26" title="Does the collision checker support true parallel collision checks?">SupportsParallelChecking()</a> is true) and (2) when multiple OpenMP threads are available for execution. See <a class="el" href="#collision_checker_parallel_edge">function-level parallelism</a> for guidance on proper usage. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">configs</td><td>Configurations to check </td></tr>
    <tr><td class="paramname">parallelize</td><td>How much should collision checks be parallelized? </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;uint8_t&gt;, one for each configuration in configs. For each configuration, 1 if collision free, 0 if in collision. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">if</td><td><span class="tt">configs</span> contains non-finite values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acc6b89337adab829567d9be3fe350517" name="acc6b89337adab829567d9be3fe350517"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc6b89337adab829567d9be3fe350517">&#9670;&#160;</a></span>CheckContextConfigCollisionFree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CheckContextConfigCollisionFree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1planning_1_1_collision_checker_context.html">CollisionCheckerContext</a> *</td>          <td class="paramname"><span class="paramname"><em>model_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>q</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Explicit Context-based version of <a class="el" href="#adb33fbe45f267be402e5e2a750428044" title="Checks a single configuration for collision using the current thread&#39;s associated context.">CheckConfigCollisionFree()</a>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if model_context is nullptr. </td></tr>
    <tr><td class="paramname">if</td><td><span class="tt">q</span> contains non-finite values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ccb_explicit_contexts">Explicit Context Parallelism</a>. </dd></dl>

</div>
</div>
<a id="a2ab530c2f1db69b7fcb503447c63ef8f" name="a2ab530c2f1db69b7fcb503447c63ef8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ab530c2f1db69b7fcb503447c63ef8f">&#9670;&#160;</a></span>CheckContextEdgeCollisionFree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CheckContextEdgeCollisionFree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1planning_1_1_collision_checker_context.html">CollisionCheckerContext</a> *</td>          <td class="paramname"><span class="paramname"><em>model_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>q1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>q2</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Explicit Context-based version of <a class="el" href="#acd7c5dd9a903bedc2d984fe12aa5c409" title="Checks a single configuration-to-configuration edge for collision, using the current thread&#39;s associa...">CheckEdgeCollisionFree()</a>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">if</td><td><span class="tt">q1</span> or <span class="tt">q2</span> contain non-finite values. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if <span class="tt"><a class="el" href="#a5a8b62cb6805a9d647e8ea0c783bb47d" title="Accesses a collision checking context from within the implicit context pool owned by this collision c...">model_context</a></span> is nullptr. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ccb_explicit_contexts">Explicit Context Parallelism</a>. </dd></dl>

</div>
</div>
<a id="acd7c5dd9a903bedc2d984fe12aa5c409" name="acd7c5dd9a903bedc2d984fe12aa5c409"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd7c5dd9a903bedc2d984fe12aa5c409">&#9670;&#160;</a></span>CheckEdgeCollisionFree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CheckEdgeCollisionFree </td>
          <td>(</td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>q1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>q2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; int &gt;</td>          <td class="paramname"><span class="paramname"><em>context_number</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::nullopt</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks a single configuration-to-configuration edge for collision, using the current thread's associated context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q1</td><td>Start configuration for edge. </td></tr>
    <tr><td class="paramname">q2</td><td>End configuration for edge. </td></tr>
    <tr><td class="paramname">context_number</td><td>Optional implicit context number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if collision free, false if in collision. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">if</td><td><span class="tt">q1</span> or <span class="tt">q2</span> contain non-finite values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ccb_implicit_contexts">Implicit Context Parallelism</a>. </dd></dl>

</div>
</div>
<a id="a6bb8c478f30ea78ac72ce0e557c6067d" name="a6bb8c478f30ea78ac72ce0e557c6067d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bb8c478f30ea78ac72ce0e557c6067d">&#9670;&#160;</a></span>CheckEdgeCollisionFreeParallel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CheckEdgeCollisionFreeParallel </td>
          <td>(</td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>q1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>q2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_parallelism.html">Parallelism</a></td>          <td class="paramname"><span class="paramname"><em>parallelize</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classdrake_1_1_parallelism.html#a5f5d962dfeec6e675996074f913df819">Parallelism::Max</a>()</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks a single configuration-to-configuration edge for collision. </p>
<p>Collision check is parallelized via OpenMP when supported. See <a class="el" href="#collision_checker_parallel_edge">function-level parallelism</a> for guidance on proper usage. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q1</td><td>Start configuration for edge. </td></tr>
    <tr><td class="paramname">q2</td><td>End configuration for edge. </td></tr>
    <tr><td class="paramname">parallelize</td><td>How much should edge collision check be parallelized? </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if collision free, false if in collision. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">if</td><td><span class="tt">q1</span> or <span class="tt">q2</span> contain non-finite values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5e46f4dff608e99d432d3c700e870c4a" name="a5e46f4dff608e99d432d3c700e870c4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e46f4dff608e99d432d3c700e870c4a">&#9670;&#160;</a></span>CheckEdgesCollisionFree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; uint8_t &gt; CheckEdgesCollisionFree </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; Eigen::VectorXd, Eigen::VectorXd &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>edges</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_parallelism.html">Parallelism</a></td>          <td class="paramname"><span class="paramname"><em>parallelize</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classdrake_1_1_parallelism.html#a5f5d962dfeec6e675996074f913df819">Parallelism::Max</a>()</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks multiple configuration-to-configuration edges for collision. </p>
<p>Collision checks are parallelized via OpenMP when supported and enabled by <span class="tt">parallelize</span>. See <a class="el" href="#collision_checker_parallel_edge">function-level parallelism</a> for guidance on proper usage. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edges</td><td>Edges to check, each in the form of pair&lt;q1, q2&gt;. </td></tr>
    <tr><td class="paramname">parallelize</td><td>How much should edge collision checks be parallelized? </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;uint8_t&gt;, one for each edge in edges. For each edge, 1 if collision free, 0 if in collision. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">if</td><td>any vector in <span class="tt">edges</span> contains non-finite values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae6086bc18a71a830249985033f740d94" name="ae6086bc18a71a830249985033f740d94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6086bc18a71a830249985033f740d94">&#9670;&#160;</a></span>ClassifyBodyCollisions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="group__planning__collision__checker.html#ga6e884b3a7afc04b1a0c132ce264c14b7">RobotCollisionType</a> &gt; ClassifyBodyCollisions </td>
          <td>(</td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>q</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; int &gt;</td>          <td class="paramname"><span class="paramname"><em>context_number</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::nullopt</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Classifies which robot bodies are in collision (and which type of collision) for the provided configuration <span class="tt">q</span>, using the current thread's associated context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context_number</td><td>Optional implicit context number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of collision types arranged in body index order. Only entries for robot bodies are guaranteed to be valid; entries for environment bodies are populated with kNoCollision, regardless of their actual status. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">if</td><td><span class="tt">q</span> contains non-finite values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ccb_implicit_contexts">Implicit Context Parallelism</a>. </dd></dl>

</div>
</div>
<a id="a7bed4349eab4c529e90c87bbcb96dafa" name="a7bed4349eab4c529e90c87bbcb96dafa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bed4349eab4c529e90c87bbcb96dafa">&#9670;&#160;</a></span>ClassifyContextBodyCollisions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="group__planning__collision__checker.html#ga6e884b3a7afc04b1a0c132ce264c14b7">RobotCollisionType</a> &gt; ClassifyContextBodyCollisions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1planning_1_1_collision_checker_context.html">CollisionCheckerContext</a> *</td>          <td class="paramname"><span class="paramname"><em>model_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>q</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Explicit Context-based version of <a class="el" href="#ae6086bc18a71a830249985033f740d94" title="Classifies which robot bodies are in collision (and which type of collision) for the provided configu...">ClassifyBodyCollisions()</a>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <span class="tt"><a class="el" href="#a5a8b62cb6805a9d647e8ea0c783bb47d" title="Accesses a collision checking context from within the implicit context pool owned by this collision c...">model_context</a></span> is nullptr. </td></tr>
    <tr><td class="paramname">if</td><td><span class="tt">q</span> contains non-finite values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ccb_explicit_contexts">Explicit Context Parallelism</a>. </dd></dl>

</div>
</div>
<a id="ac41b3899f6c88a6c13ea82b776a8f9e3" name="ac41b3899f6c88a6c13ea82b776a8f9e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac41b3899f6c88a6c13ea82b776a8f9e3">&#9670;&#160;</a></span>Clone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="#a236e58ced4f42c22e7395000ecaaeb7b">CollisionChecker</a> &gt; Clone </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae76ac66c1677433ebe8cff135f77af58" name="ae76ac66c1677433ebe8cff135f77af58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae76ac66c1677433ebe8cff135f77af58">&#9670;&#160;</a></span>ComputeConfigurationDistance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ComputeConfigurationDistance </td>
          <td>(</td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>q1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>q2</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes configuration-space distance between the provided configurations <span class="tt">q1</span> and <span class="tt">q2</span>, using the distance function configured at construction- time or via <a class="el" href="#ad399081b57b1becb847d9a6f77928903" title="Sets the configuration distance function to distance_function.">SetConfigurationDistanceFunction()</a>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">if</td><td><span class="tt">q1</span> or <span class="tt">q2</span> contain non-finite values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0f8ed11e66563529eaa64e83f7b534d9" name="a0f8ed11e66563529eaa64e83f7b534d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f8ed11e66563529eaa64e83f7b534d9">&#9670;&#160;</a></span>CreatePrototypeContext()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt; <a class="el" href="classdrake_1_1planning_1_1_collision_checker_context.html">CollisionCheckerContext</a> &gt; CreatePrototypeContext </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Collision checkers that use derived context types can override this implementation to allocate their context type instead. </p>

</div>
</div>
<a id="ad9406112c93e430d27b84744b6f5fa77" name="ad9406112c93e430d27b84744b6f5fa77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9406112c93e430d27b84744b6f5fa77">&#9670;&#160;</a></span>CriticizePaddingMatrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string CriticizePaddingMatrix </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae18a5310160c2b1c594c623f320c42f5" name="ae18a5310160c2b1c594c623f320c42f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae18a5310160c2b1c594c623f320c42f5">&#9670;&#160;</a></span>distance_and_interpolation_provider()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1planning_1_1_distance_and_interpolation_provider.html">DistanceAndInterpolationProvider</a> &amp; distance_and_interpolation_provider </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the <a class="el" href="classdrake_1_1planning_1_1_distance_and_interpolation_provider.html" title="This class represents the base interface for performing configuration distance and interpolation oper...">DistanceAndInterpolationProvider</a> in use. </p>

</div>
</div>
<a id="a5c07f13becacf1aacae6bff5cfff24cd" name="a5c07f13becacf1aacae6bff5cfff24cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c07f13becacf1aacae6bff5cfff24cd">&#9670;&#160;</a></span>DoAddCollisionShapeToBody()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::optional&lt; <a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">geometry::GeometryId</a> &gt; DoAddCollisionShapeToBody </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>group_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">multibody::RigidBody</a>&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>bodyA</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1_shape.html">geometry::Shape</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>shape</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>X_AG</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does the work of adding a shape to be rigidly affixed to the body. </p>
<p>Derived checkers can choose to ignore the request, but must return <span class="tt">nullopt</span> if they do so. </p>

<p>Implemented in <a class="el" href="classdrake_1_1planning_1_1_unimplemented_collision_checker.html#a4e6495f9eb6c59552797cf343315d1de">UnimplementedCollisionChecker</a>.</p>

</div>
</div>
<a id="a8393e34359ae424d80b7975551234652" name="a8393e34359ae424d80b7975551234652"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8393e34359ae424d80b7975551234652">&#9670;&#160;</a></span>DoCalcContextRobotClearance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdrake_1_1planning_1_1_robot_clearance.html">RobotClearance</a> DoCalcContextRobotClearance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1planning_1_1_collision_checker_context.html">CollisionCheckerContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>model_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>influence_distance</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Derived collision checkers are responsible for defining the reported measurements. </p>
<p>But they must adhere to the characteristics documented on <a class="el" href="classdrake_1_1planning_1_1_robot_clearance.html" title="A summary of the clearance – a collection of distance measurements – between the robot and everything...">RobotClearance</a>, e.g., one measurement per row. <a class="el" href="classdrake_1_1planning_1_1_collision_checker.html" title="Interface for collision checkers to use.">CollisionChecker</a> guarantees that <span class="tt">influence_distance</span> is finite and non-negative. </p>

<p>Implemented in <a class="el" href="classdrake_1_1planning_1_1_unimplemented_collision_checker.html#a749f14f28d5f317e2bbcf99590ae78d4">UnimplementedCollisionChecker</a>.</p>

</div>
</div>
<a id="a751ed5a04cd06853f43ab40f1ac5dde6" name="a751ed5a04cd06853f43ab40f1ac5dde6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a751ed5a04cd06853f43ab40f1ac5dde6">&#9670;&#160;</a></span>DoCheckContextConfigCollisionFree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool DoCheckContextConfigCollisionFree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1planning_1_1_collision_checker_context.html">CollisionCheckerContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>model_context</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Derived collision checkers are responsible for reporting the collision status of the configuration. </p>
<p><a class="el" href="classdrake_1_1planning_1_1_collision_checker.html" title="Interface for collision checkers to use.">CollisionChecker</a> guarantees that the passed <span class="tt"><a class="el" href="#a5a8b62cb6805a9d647e8ea0c783bb47d" title="Accesses a collision checking context from within the implicit context pool owned by this collision c...">model_context</a></span> has been updated with the configuration <span class="tt">q</span> supplied to the public method. </p>

<p>Implemented in <a class="el" href="classdrake_1_1planning_1_1_unimplemented_collision_checker.html#ad2bc3e678132547a0fb97d486067c0e5">UnimplementedCollisionChecker</a>.</p>

</div>
</div>
<a id="ab426080b04fbbf03aeba88ac67517e8d" name="ab426080b04fbbf03aeba88ac67517e8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab426080b04fbbf03aeba88ac67517e8d">&#9670;&#160;</a></span>DoClassifyContextBodyCollisions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt; <a class="el" href="group__planning__collision__checker.html#ga6e884b3a7afc04b1a0c132ce264c14b7">RobotCollisionType</a> &gt; DoClassifyContextBodyCollisions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1planning_1_1_collision_checker_context.html">CollisionCheckerContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>model_context</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Derived collision checkers are responsible for choosing a collision type for each of the robot bodies. </p>
<p>They should adhere to the semantics documented for ClassifyBodyCollisions. <a class="el" href="classdrake_1_1planning_1_1_collision_checker.html" title="Interface for collision checkers to use.">CollisionChecker</a> guarantees that the passed <span class="tt"><a class="el" href="#a5a8b62cb6805a9d647e8ea0c783bb47d" title="Accesses a collision checking context from within the implicit context pool owned by this collision c...">model_context</a></span> has been updated with the configuration <span class="tt">q</span> supplied to the public method. </p>

<p>Implemented in <a class="el" href="classdrake_1_1planning_1_1_unimplemented_collision_checker.html#aa28597db95a3582f61940f52fbd9a5b0">UnimplementedCollisionChecker</a>.</p>

</div>
</div>
<a id="a20c31df6bcbc8410dc3c9fca03b22320" name="a20c31df6bcbc8410dc3c9fca03b22320"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20c31df6bcbc8410dc3c9fca03b22320">&#9670;&#160;</a></span>DoClone()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt; <a class="el" href="#a236e58ced4f42c22e7395000ecaaeb7b">CollisionChecker</a> &gt; DoClone </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Derived collision checkers implement can make use of the protected copy constructor to implement <a class="el" href="#a20c31df6bcbc8410dc3c9fca03b22320" title="Derived collision checkers implement can make use of the protected copy constructor to implement DoCl...">DoClone()</a>. </p>

<p>Implemented in <a class="el" href="classdrake_1_1planning_1_1_unimplemented_collision_checker.html#a6298f2602d4badde26d4082a21e39b26">UnimplementedCollisionChecker</a>.</p>

</div>
</div>
<a id="a145c8a89488c119f22a13557dd2376b9" name="a145c8a89488c119f22a13557dd2376b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a145c8a89488c119f22a13557dd2376b9">&#9670;&#160;</a></span>DoMaxContextNumDistances()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int DoMaxContextNumDistances </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1planning_1_1_collision_checker_context.html">CollisionCheckerContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>model_context</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Derived collision checkers must implement the semantics documented for MaxNumDistances. </p>
<p><a class="el" href="classdrake_1_1planning_1_1_collision_checker.html" title="Interface for collision checkers to use.">CollisionChecker</a> does nothing; it just calls this method. </p>

<p>Implemented in <a class="el" href="classdrake_1_1planning_1_1_unimplemented_collision_checker.html#a0d31a213a240c881150cd1a6980cfef9">UnimplementedCollisionChecker</a>.</p>

</div>
</div>
<a id="af4a3f7ae74cf3f31e5f3a3b840d111a5" name="af4a3f7ae74cf3f31e5f3a3b840d111a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4a3f7ae74cf3f31e5f3a3b840d111a5">&#9670;&#160;</a></span>DoUpdateContextPositions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void DoUpdateContextPositions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1planning_1_1_collision_checker_context.html">CollisionCheckerContext</a> *</td>          <td class="paramname"><span class="paramname"><em>model_context</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Derived collision checkers can do further work in this function in response to updates to the MultibodyPlant positions. </p>
<p><a class="el" href="classdrake_1_1planning_1_1_collision_checker.html" title="Interface for collision checkers to use.">CollisionChecker</a> guarantees that <span class="tt"><a class="el" href="#a5a8b62cb6805a9d647e8ea0c783bb47d" title="Accesses a collision checking context from within the implicit context pool owned by this collision c...">model_context</a></span> will not be nullptr and that the new positions are present in model_context-&gt;<a class="el" href="#aee97203e446d54e036ea9093c8c5efec" title="Accesses a multibody plant sub-context context from within the implicit context pool owned by this co...">plant_context()</a>. </p>

<p>Implemented in <a class="el" href="classdrake_1_1planning_1_1_unimplemented_collision_checker.html#a5785657320b67a48e969d427e1ff9995">UnimplementedCollisionChecker</a>.</p>

</div>
</div>
<a id="adaa8d8cac0c3193bc48a6fb8229b85e8" name="adaa8d8cac0c3193bc48a6fb8229b85e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaa8d8cac0c3193bc48a6fb8229b85e8">&#9670;&#160;</a></span>edge_step_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double edge_step_size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the current edge step size. </p>

</div>
</div>
<a id="a1eeb910f4ee1c706d9ccd689ec01828d" name="a1eeb910f4ee1c706d9ccd689ec01828d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eeb910f4ee1c706d9ccd689ec01828d">&#9670;&#160;</a></span>get_body()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">multibody::RigidBody</a>&lt; double &gt; &amp; get_body </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#a02d233e6f0ef016f5cf02e2222a22f5c">multibody::BodyIndex</a></td>          <td class="paramname"><span class="paramname"><em>body_index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a const body reference to a body in the full model's plant for the given <span class="tt">body_index</span>. </dd></dl>

</div>
</div>
<a id="af51fe263feb12a3a3734c3aa83569ae8" name="af51fe263feb12a3a3734c3aa83569ae8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af51fe263feb12a3a3734c3aa83569ae8">&#9670;&#160;</a></span>GetAllAddedCollisionShapes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; std::string, std::vector&lt; <a class="el" href="classdrake_1_1planning_1_1_body_shape_description.html">BodyShapeDescription</a> &gt; &gt; GetAllAddedCollisionShapes </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets all checker geometries currently added across the whole checker. </p>
<dl class="section return"><dt>Returns</dt><dd>A mapping from each geometry group name to the collection of (shape, body) descriptions in that group. </dd></dl>

</div>
</div>
<a id="ae73ffb323e76df5b732fa9c6c6e74592" name="ae73ffb323e76df5b732fa9c6c6e74592"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae73ffb323e76df5b732fa9c6c6e74592">&#9670;&#160;</a></span>GetFilteredCollisionMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Eigen::MatrixXi &amp; GetFilteredCollisionMatrix </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the "active" collision filter matrix. </p>

</div>
</div>
<a id="abbe38491db7dbc7136d180ed55698538" name="abbe38491db7dbc7136d180ed55698538"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbe38491db7dbc7136d180ed55698538">&#9670;&#160;</a></span>GetLargestPadding()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double GetLargestPadding </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the current largest collision padding across all (robot, *) body pairs. </p>
<p>This excludes the meaningless zeros on the diagonal and environment-environment pairs; the return value <em>can</em> be negative. </p>

</div>
</div>
<a id="a6e5de66acea304deca00ac047b77b480" name="a6e5de66acea304deca00ac047b77b480"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e5de66acea304deca00ac047b77b480">&#9670;&#160;</a></span>GetMutableSetupModel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1planning_1_1_robot_diagram.html">RobotDiagram</a>&lt; double &gt; &amp; GetMutableSetupModel </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a mutable reference to the robot model. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <a class="el" href="#aa28eccaff2de74330a76a1e48c0368c5">IsInitialSetup()</a> == false. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a81f25e0bab7179f3a00503a4a2a321b4" name="a81f25e0bab7179f3a00503a4a2a321b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81f25e0bab7179f3a00503a4a2a321b4">&#9670;&#160;</a></span>GetNominalFilteredCollisionMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Eigen::MatrixXi &amp; GetNominalFilteredCollisionMatrix </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the "nominal" collision filter matrix. </p>
<p>The nominal matrix is initialized at construction time and represents the configuration of the model's plant and scene graph. It serves as a reference point to assess any changes to collision filters beyond this checker's intrinsic model.</p>
<p>Collisions between bodies A and B are filtered in the following cases:</p>
<ul>
<li>There exists a welded path between A and B.</li>
<li>SceneGraph has filtered the collisions between <em>all</em> pairs of geometries of A and B.</li>
</ul>
<p>Note: SceneGraph allows arbitrary collision filter configuration at the geometry* level. The filters on one geometry of body need not be the same as another geometry on the same body. CollisionChecker is body centric. It requires all geometries on a body to be filtered homogeneously. A SceneGraph that violates this stricter requirement cannot be used in a CollisionChecker. It is highly unlikely that a SceneGraph instance will ever be in this configuration by accident. </p>

</div>
</div>
<a id="a3fd56eac31d01ff184f7f796f3f18760" name="a3fd56eac31d01ff184f7f796f3f18760"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fd56eac31d01ff184f7f796f3f18760">&#9670;&#160;</a></span>GetPaddingBetween() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double GetPaddingBetween </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">multibody::RigidBody</a>&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>bodyA</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">multibody::RigidBody</a>&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>bodyB</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload that uses body references. </p>

</div>
</div>
<a id="a642639c3ef89987db37c8ba232f0f494" name="a642639c3ef89987db37c8ba232f0f494"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a642639c3ef89987db37c8ba232f0f494">&#9670;&#160;</a></span>GetPaddingBetween() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double GetPaddingBetween </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#a02d233e6f0ef016f5cf02e2222a22f5c">multibody::BodyIndex</a></td>          <td class="paramname"><span class="paramname"><em>bodyA_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#a02d233e6f0ef016f5cf02e2222a22f5c">multibody::BodyIndex</a></td>          <td class="paramname"><span class="paramname"><em>bodyB_index</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the padding value for the pair of bodies specified. </p>
<p>If the body indices are the same, zero will always be returned. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if either body index is out of range. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa0204ecd934b96efb2d151156b1be9b0" name="aa0204ecd934b96efb2d151156b1be9b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0204ecd934b96efb2d151156b1be9b0">&#9670;&#160;</a></span>GetPaddingMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Eigen::MatrixXd &amp; GetPaddingMatrix </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the collision padding matrix. </p>

</div>
</div>
<a id="a6ed0e139750504ce407049fef515da6c" name="a6ed0e139750504ce407049fef515da6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ed0e139750504ce407049fef515da6c">&#9670;&#160;</a></span>GetZeroConfiguration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Eigen::VectorXd &amp; GetZeroConfiguration </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a generalized position vector, sized according to the full model, whose values are all zero. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>A zero vector is not necessarily a valid configuration, e.g., in case the configuration has quaternions, or position constraints, or etc. </dd></dl>

</div>
</div>
<a id="a15d96471a621cda128cdbc959b4f96c9" name="a15d96471a621cda128cdbc959b4f96c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15d96471a621cda128cdbc959b4f96c9">&#9670;&#160;</a></span>InterpolateBetweenConfigurations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXd InterpolateBetweenConfigurations </td>
          <td>(</td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>q1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>q2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>ratio</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolates between provided configurations <span class="tt">q1</span> and <span class="tt">q2</span>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ratio</td><td>Interpolation ratio. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Interpolated configuration. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if ratio is not in range [0, 1]. </td></tr>
    <tr><td class="paramname">if</td><td><span class="tt">q1</span> or <span class="tt">q2</span> contain non-finite values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacedrake_1_1planning.html#a51c19bebe45e89327241c79776dad396" title="Configuration interpolation function takes two configurations of the robot, q1, and q2,...">ConfigurationInterpolationFunction</a> for more. </dd></dl>

</div>
</div>
<a id="a89638e2733d1b29dc1c66307d49edfc6" name="a89638e2733d1b29dc1c66307d49edfc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89638e2733d1b29dc1c66307d49edfc6">&#9670;&#160;</a></span>IsCollisionFilteredBetween() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IsCollisionFilteredBetween </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">multibody::RigidBody</a>&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>bodyA</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">multibody::RigidBody</a>&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>bodyB</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload that uses body references. </p>

</div>
</div>
<a id="a4c482d9dc344b97944de8b61dc41911f" name="a4c482d9dc344b97944de8b61dc41911f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c482d9dc344b97944de8b61dc41911f">&#9670;&#160;</a></span>IsCollisionFilteredBetween() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IsCollisionFilteredBetween </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#a02d233e6f0ef016f5cf02e2222a22f5c">multibody::BodyIndex</a></td>          <td class="paramname"><span class="paramname"><em>bodyA_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#a02d233e6f0ef016f5cf02e2222a22f5c">multibody::BodyIndex</a></td>          <td class="paramname"><span class="paramname"><em>bodyB_index</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if collision is filtered between the two bodies specified. </p>
<p>Note: collision between two environment bodies is <em>always</em> filtered. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if either body index is out of range. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa28eccaff2de74330a76a1e48c0368c5" name="aa28eccaff2de74330a76a1e48c0368c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa28eccaff2de74330a76a1e48c0368c5">&#9670;&#160;</a></span>IsInitialSetup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IsInitialSetup </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if called during initial setup (before <a class="el" href="#a381697ea7e2a890f5cd018d7c6dc8bc2" title="Allocate the per-thread context pool, and discontinue mutable access to the robot model.">AllocateContexts()</a> is called). </dd></dl>

</div>
</div>
<a id="a7cf0f9ebe090ff87c21ebbe3c7bd0539" name="a7cf0f9ebe090ff87c21ebbe3c7bd0539"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cf0f9ebe090ff87c21ebbe3c7bd0539">&#9670;&#160;</a></span>IsPartOfRobot() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IsPartOfRobot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">multibody::RigidBody</a>&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>body</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if the indicated body is part of the robot. </dd></dl>

</div>
</div>
<a id="a0dcd7c9ea7d36219c6790fe017d41578" name="a0dcd7c9ea7d36219c6790fe017d41578"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dcd7c9ea7d36219c6790fe017d41578">&#9670;&#160;</a></span>IsPartOfRobot() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IsPartOfRobot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#a02d233e6f0ef016f5cf02e2222a22f5c">multibody::BodyIndex</a></td>          <td class="paramname"><span class="paramname"><em>body_index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if the indicated body is part of the robot. </dd></dl>

</div>
</div>
<a id="a57903558264bcd6cb91e68f8e49d20a1" name="a57903558264bcd6cb91e68f8e49d20a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57903558264bcd6cb91e68f8e49d20a1">&#9670;&#160;</a></span>MakeStandaloneConfigurationDistanceFunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1planning.html#abdbb6a212eb30d6a68643bf0aebe0426">ConfigurationDistanceFunction</a> MakeStandaloneConfigurationDistanceFunction </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a functor that captures this object, so it can be used like a free function. The returned functor is only valid during the lifetime of this object. The math of the function is equivalent to <a class="el" href="#ae76ac66c1677433ebe8cff135f77af58" title="Computes configuration-space distance between the provided configurations q1 and q2,...">ComputeConfigurationDistance()</a>. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>do not pass this standalone function back into <a class="el" href="#ad399081b57b1becb847d9a6f77928903" title="Sets the configuration distance function to distance_function.">SetConfigurationDistanceFunction()</a> function; doing so would create an infinite loop. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">if</td><td><span class="tt">q1</span> or <span class="tt">q2</span> contain non-finite values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a07431eb14eaf038162e550c13e1373dc" name="a07431eb14eaf038162e550c13e1373dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07431eb14eaf038162e550c13e1373dc">&#9670;&#160;</a></span>MakeStandaloneConfigurationInterpolationFunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1planning.html#a51c19bebe45e89327241c79776dad396">ConfigurationInterpolationFunction</a> MakeStandaloneConfigurationInterpolationFunction </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a functor that captures this object, so it can be used like a free function. The returned functor is only valid during the lifetime of this object. The math of the function is equivalent to <a class="el" href="#a15d96471a621cda128cdbc959b4f96c9" title="Interpolates between provided configurations q1 and q2.">InterpolateBetweenConfigurations()</a>. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>do not pass this standalone function back into our <a class="el" href="#aebf58f4817df47ff85f1e4f3de824382" title="Sets the configuration interpolation function to interpolation_function.">SetConfigurationInterpolationFunction()</a> function; doing so would create an infinite loop. </dd></dl>

</div>
</div>
<a id="afe874e7850ecb2ec51f0c950903d572c" name="afe874e7850ecb2ec51f0c950903d572c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe874e7850ecb2ec51f0c950903d572c">&#9670;&#160;</a></span>MakeStandaloneModelContext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classdrake_1_1planning_1_1_collision_checker_context.html">CollisionCheckerContext</a> &gt; MakeStandaloneModelContext </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make and track a <a class="el" href="classdrake_1_1planning_1_1_collision_checker_context.html" title="This class represents the data necessary for CollisionChecker to operate safely across multiple threa...">CollisionCheckerContext</a>. </p>
<p>The returned context will participate in <a class="el" href="#a07edeec959f087dcc1812af16b19b02c" title="Allows externally-provided operations that must be performed against all contexts in the per-thread c...">PerformOperationAgainstAllModelContexts()</a> until it is destroyed. </p>

</div>
</div>
<a id="a23bcd057122f2a90fd8e673a51e9bcd3" name="a23bcd057122f2a90fd8e673a51e9bcd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23bcd057122f2a90fd8e673a51e9bcd3">&#9670;&#160;</a></span>MaxContextNumDistances()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MaxContextNumDistances </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1planning_1_1_collision_checker_context.html">CollisionCheckerContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>model_context</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Explicit Context-based version of <a class="el" href="#acb92e0e060e99a17ea72a57daba72251" title="Returns an upper bound on the number of distances returned by CalcRobotClearance(),...">MaxNumDistances()</a>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ccb_explicit_contexts">Explicit Context Parallelism</a>. </dd></dl>

</div>
</div>
<a id="acb92e0e060e99a17ea72a57daba72251" name="acb92e0e060e99a17ea72a57daba72251"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb92e0e060e99a17ea72a57daba72251">&#9670;&#160;</a></span>MaxNumDistances()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MaxNumDistances </td>
          <td>(</td>
          <td class="paramtype">std::optional&lt; int &gt;</td>          <td class="paramname"><span class="paramname"><em>context_number</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::nullopt</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an upper bound on the number of distances returned by <a class="el" href="#a2b9fc782d20ef71bf845c913e3f9b7c8" title="Calculates the distance, ϕ, and distance Jacobian, Jqᵣ_ϕ, for each potential collision whose distance...">CalcRobotClearance()</a>, using the current thread's associated context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context_number</td><td>Optional implicit context number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ccb_implicit_contexts">Implicit Context Parallelism</a>. </dd></dl>

</div>
</div>
<a id="a8a44e5a7067bb2c6f603aa66f9343d40" name="a8a44e5a7067bb2c6f603aa66f9343d40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a44e5a7067bb2c6f603aa66f9343d40">&#9670;&#160;</a></span>MaybeGetUniformRobotEnvironmentPadding()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; double &gt; MaybeGetUniformRobotEnvironmentPadding </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If the padding between all robot bodies and environment bodies is the same, returns the common padding value. </p>
<p>Returns nullopt otherwise. </p>

</div>
</div>
<a id="a6e1b0cf9c177dfb7c41fcf1839668e2f" name="a6e1b0cf9c177dfb7c41fcf1839668e2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e1b0cf9c177dfb7c41fcf1839668e2f">&#9670;&#160;</a></span>MaybeGetUniformRobotRobotPadding()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; double &gt; MaybeGetUniformRobotRobotPadding </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If the padding between all pairs of robot bodies is the same, returns the common padding value. </p>
<p>Returns nullopt otherwise. </p>

</div>
</div>
<a id="a769397ad377b0ff40c67cc3e373ee8a1" name="a769397ad377b0ff40c67cc3e373ee8a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a769397ad377b0ff40c67cc3e373ee8a1">&#9670;&#160;</a></span>MeasureContextEdgeCollisionFree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1planning_1_1_edge_measure.html">EdgeMeasure</a> MeasureContextEdgeCollisionFree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1planning_1_1_collision_checker_context.html">CollisionCheckerContext</a> *</td>          <td class="paramname"><span class="paramname"><em>model_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>q1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>q2</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Explicit Context-based version of <a class="el" href="#ac60fa98836f3dac1975ebc8f7a68b223" title="Checks a single configuration-to-configuration edge for collision, using the current thread&#39;s associa...">MeasureEdgeCollisionFree()</a>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <span class="tt"><a class="el" href="#a5a8b62cb6805a9d647e8ea0c783bb47d" title="Accesses a collision checking context from within the implicit context pool owned by this collision c...">model_context</a></span> is nullptr. </td></tr>
    <tr><td class="paramname">if</td><td><span class="tt">q1</span> or <span class="tt">q2</span> contain non-finite values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ccb_explicit_contexts">Explicit Context Parallelism</a>. </dd></dl>

</div>
</div>
<a id="ac60fa98836f3dac1975ebc8f7a68b223" name="ac60fa98836f3dac1975ebc8f7a68b223"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac60fa98836f3dac1975ebc8f7a68b223">&#9670;&#160;</a></span>MeasureEdgeCollisionFree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1planning_1_1_edge_measure.html">EdgeMeasure</a> MeasureEdgeCollisionFree </td>
          <td>(</td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>q1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>q2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; int &gt;</td>          <td class="paramname"><span class="paramname"><em>context_number</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::nullopt</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks a single configuration-to-configuration edge for collision, using the current thread's associated context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q1</td><td>Start configuration for edge. </td></tr>
    <tr><td class="paramname">q2</td><td>End configuration for edge. </td></tr>
    <tr><td class="paramname">context_number</td><td>Optional implicit context number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A measure of how much of the edge is collision free. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">if</td><td><span class="tt">q1</span> or <span class="tt">q2</span> contain non-finite values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ccb_implicit_contexts">Implicit Context Parallelism</a>. </dd></dl>

</div>
</div>
<a id="ae06d7f2e61a9d56deb761d03a216f01b" name="ae06d7f2e61a9d56deb761d03a216f01b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae06d7f2e61a9d56deb761d03a216f01b">&#9670;&#160;</a></span>MeasureEdgeCollisionFreeParallel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1planning_1_1_edge_measure.html">EdgeMeasure</a> MeasureEdgeCollisionFreeParallel </td>
          <td>(</td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>q1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>q2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_parallelism.html">Parallelism</a></td>          <td class="paramname"><span class="paramname"><em>parallelize</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classdrake_1_1_parallelism.html#a5f5d962dfeec6e675996074f913df819">Parallelism::Max</a>()</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks a single configuration-to-configuration edge for collision. </p>
<p>Collision check is parallelized via OpenMP when supported. See <a class="el" href="#collision_checker_parallel_edge">function-level parallelism</a> for guidance on proper usage. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q1</td><td>Start configuration for edge. </td></tr>
    <tr><td class="paramname">q2</td><td>End configuration for edge. </td></tr>
    <tr><td class="paramname">parallelize</td><td>How much should edge collision check be parallelized? </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A measure of how much of the edge is collision free. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">if</td><td><span class="tt">q1</span> or <span class="tt">q2</span> contain non-finite values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a75d2f68e2c725852eb833732c48f047e" name="a75d2f68e2c725852eb833732c48f047e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75d2f68e2c725852eb833732c48f047e">&#9670;&#160;</a></span>MeasureEdgesCollisionFree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classdrake_1_1planning_1_1_edge_measure.html">EdgeMeasure</a> &gt; MeasureEdgesCollisionFree </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; Eigen::VectorXd, Eigen::VectorXd &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>edges</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_parallelism.html">Parallelism</a></td>          <td class="paramname"><span class="paramname"><em>parallelize</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classdrake_1_1_parallelism.html#a5f5d962dfeec6e675996074f913df819">Parallelism::Max</a>()</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks multiple configuration-to-configuration edge for collision. </p>
<p>Collision checks are parallelized via OpenMP when supported and enabled by <span class="tt">parallelize</span>. See <a class="el" href="#collision_checker_parallel_edge">function-level parallelism</a> for guidance on proper usage. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edges</td><td>Edges to check, each in the form of pair&lt;q1, q2&gt;. </td></tr>
    <tr><td class="paramname">parallelize</td><td>How much should edge collision checks be parallelized? </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A measure of how much of each edge is collision free. The iᵗʰ entry is the result for the iᵗʰ edge. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">if</td><td>any vector in <span class="tt">edges</span> contains non-finite values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5b27629aa14a86079b45f9bc76234863" name="a5b27629aa14a86079b45f9bc76234863"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b27629aa14a86079b45f9bc76234863">&#9670;&#160;</a></span>model()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1planning_1_1_robot_diagram.html">RobotDiagram</a>&lt; double &gt; &amp; model </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a const reference to the full model. </dd></dl>

</div>
</div>
<a id="a5a8b62cb6805a9d647e8ea0c783bb47d" name="a5a8b62cb6805a9d647e8ea0c783bb47d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a8b62cb6805a9d647e8ea0c783bb47d">&#9670;&#160;</a></span>model_context()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1planning_1_1_collision_checker_context.html">CollisionCheckerContext</a> &amp; model_context </td>
          <td>(</td>
          <td class="paramtype">std::optional&lt; int &gt;</td>          <td class="paramname"><span class="paramname"><em>context_number</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::nullopt</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accesses a collision checking context from within the implicit context pool owned by this collision checker. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context_number</td><td>Optional implicit context number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a const reference to either the collision checking context given by the <span class="tt">context_number</span>, or when nullopt the context to be used with the current OpenMP thread. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ccb_implicit_contexts">Implicit Context Parallelism</a>. </dd></dl>

</div>
</div>
<a id="a1db04299a725f279a9c49df91dc0deb2" name="a1db04299a725f279a9c49df91dc0deb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1db04299a725f279a9c49df91dc0deb2">&#9670;&#160;</a></span>num_allocated_contexts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int num_allocated_contexts </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the number of internal (not standalone) per-thread contexts. </dd></dl>

</div>
</div>
<a id="a484fcf526a45f95ace6f9fd099cc8887" name="a484fcf526a45f95ace6f9fd099cc8887"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a484fcf526a45f95ace6f9fd099cc8887">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a236e58ced4f42c22e7395000ecaaeb7b">CollisionChecker</a> &amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a236e58ced4f42c22e7395000ecaaeb7b">CollisionChecker</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac5ded431d5c52f21ea406c521ac75a94" name="ac5ded431d5c52f21ea406c521ac75a94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5ded431d5c52f21ea406c521ac75a94">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a236e58ced4f42c22e7395000ecaaeb7b">CollisionChecker</a> &amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a236e58ced4f42c22e7395000ecaaeb7b">CollisionChecker</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a07edeec959f087dcc1812af16b19b02c" name="a07edeec959f087dcc1812af16b19b02c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07edeec959f087dcc1812af16b19b02c">&#9670;&#160;</a></span>PerformOperationAgainstAllModelContexts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PerformOperationAgainstAllModelContexts </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void(const <a class="el" href="classdrake_1_1planning_1_1_robot_diagram.html">RobotDiagram</a>&lt; double &gt; &amp;, <a class="el" href="classdrake_1_1planning_1_1_collision_checker_context.html">CollisionCheckerContext</a> *)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>operation</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows externally-provided operations that must be performed against all contexts in the per-thread context pool, and any standalone contexts made with <a class="el" href="#afe874e7850ecb2ec51f0c950903d572c" title="Make and track a CollisionCheckerContext.">MakeStandaloneModelContext()</a>. </p>
<p>For any standalone contexts, note that it is illegal to mutate a context from two different threads. No other threads should be mutating any of our standalone contexts when this function is called. </p>

</div>
</div>
<a id="a3f699d3e3d57e0d543304760d014e774" name="a3f699d3e3d57e0d543304760d014e774"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f699d3e3d57e0d543304760d014e774">&#9670;&#160;</a></span>plant()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html">multibody::MultibodyPlant</a>&lt; double &gt; &amp; plant </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a const reference to the full model's plant. </dd></dl>

</div>
</div>
<a id="aee97203e446d54e036ea9093c8c5efec" name="aee97203e446d54e036ea9093c8c5efec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee97203e446d54e036ea9093c8c5efec">&#9670;&#160;</a></span>plant_context()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; double &gt; &amp; plant_context </td>
          <td>(</td>
          <td class="paramtype">std::optional&lt; int &gt;</td>          <td class="paramname"><span class="paramname"><em>context_number</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::nullopt</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accesses a multibody plant sub-context context from within the implicit context pool owned by this collision checker. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context_number</td><td>Optional implicit context number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a const reference to the multibody plant sub-context within the context given by the <span class="tt">context_number</span>, or when nullopt the context to be used with the current OpenMP thread. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ccb_implicit_contexts">Implicit Context Parallelism</a>. </dd></dl>

</div>
</div>
<a id="ad9de25681f79223e3157ee5835ff85da" name="ad9de25681f79223e3157ee5835ff85da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9de25681f79223e3157ee5835ff85da">&#9670;&#160;</a></span>RemoveAddedGeometries()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void RemoveAddedGeometries </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structdrake_1_1planning_1_1_collision_checker_1_1_added_shape.html">AddedShape</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>shapes</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all of the given added shapes (if they exist) from the checker. </p>

<p>Implemented in <a class="el" href="classdrake_1_1planning_1_1_unimplemented_collision_checker.html#ad0c2822fb46c799d890a5d57de2a3115">UnimplementedCollisionChecker</a>.</p>

</div>
</div>
<a id="af1190d81eb661b4151d32b844e86fc5a" name="af1190d81eb661b4151d32b844e86fc5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1190d81eb661b4151d32b844e86fc5a">&#9670;&#160;</a></span>RemoveAllAddedCollisionShapes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RemoveAllAddedCollisionShapes </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes all added checker geometries from all geometry groups. </p>

</div>
</div>
<a id="a5c936a3e9f8ae2750cb5ce8c18985d0a" name="a5c936a3e9f8ae2750cb5ce8c18985d0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c936a3e9f8ae2750cb5ce8c18985d0a">&#9670;&#160;</a></span>RemoveAllAddedCollisionShapes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RemoveAllAddedCollisionShapes </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>group_name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes all added checker geometries which belong to the named group. </p>

</div>
</div>
<a id="aa072ab3f5946cea5d01402018c74e643" name="aa072ab3f5946cea5d01402018c74e643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa072ab3f5946cea5d01402018c74e643">&#9670;&#160;</a></span>robot_model_instances()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">multibody::ModelInstanceIndex</a> &gt; &amp; robot_model_instances </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the set of model instances belonging to the robot. </p>
<p>The returned vector has no duplicates and is in sorted order. </p>

</div>
</div>
<a id="a285e992424a4197669a43d70f1208474" name="a285e992424a4197669a43d70f1208474"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a285e992424a4197669a43d70f1208474">&#9670;&#160;</a></span>set_edge_step_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_edge_step_size </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>edge_step_size</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the edge step size to <span class="tt"><a class="el" href="#adaa8d8cac0c3193bc48a6fb8229b85e8" title="Gets the current edge step size.">edge_step_size</a></span>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <span class="tt"><a class="el" href="#adaa8d8cac0c3193bc48a6fb8229b85e8" title="Gets the current edge step size.">edge_step_size</a></span> is not positive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acd19e60df81a218dc6b60bd661e3a917" name="acd19e60df81a218dc6b60bd661e3a917"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd19e60df81a218dc6b60bd661e3a917">&#9670;&#160;</a></span>SetCollisionFilteredBetween() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetCollisionFilteredBetween </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">multibody::RigidBody</a>&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>bodyA</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">multibody::RigidBody</a>&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>bodyB</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>filter_collision</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload that uses body references. </p>

</div>
</div>
<a id="a87a9e6f72e628e92db913a5f9aa64d3c" name="a87a9e6f72e628e92db913a5f9aa64d3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87a9e6f72e628e92db913a5f9aa64d3c">&#9670;&#160;</a></span>SetCollisionFilteredBetween() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetCollisionFilteredBetween </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#a02d233e6f0ef016f5cf02e2222a22f5c">multibody::BodyIndex</a></td>          <td class="paramname"><span class="paramname"><em>bodyA_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#a02d233e6f0ef016f5cf02e2222a22f5c">multibody::BodyIndex</a></td>          <td class="paramname"><span class="paramname"><em>bodyB_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>filter_collision</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declares the body pair (bodyA, bodyB) to be filtered (or not) based on <span class="tt">filter_collision</span>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filter_collision</td><td>Sets the to body pair to be filtered if <span class="tt">true</span>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if either body index is out of range. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if both indices refer to the same body. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if both indices refer to environment bodies. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9fa7881e827b615483f2ec16d66fac82" name="a9fa7881e827b615483f2ec16d66fac82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fa7881e827b615483f2ec16d66fac82">&#9670;&#160;</a></span>SetCollisionFilteredWithAllBodies() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetCollisionFilteredWithAllBodies </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">multibody::RigidBody</a>&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>body</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload that uses body references. </p>

</div>
</div>
<a id="adbc935f824f1b4601d04346c0cebac63" name="adbc935f824f1b4601d04346c0cebac63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbc935f824f1b4601d04346c0cebac63">&#9670;&#160;</a></span>SetCollisionFilteredWithAllBodies() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetCollisionFilteredWithAllBodies </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#a02d233e6f0ef016f5cf02e2222a22f5c">multibody::BodyIndex</a></td>          <td class="paramname"><span class="paramname"><em>body_index</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declares that body pair (B, O) is filtered (for all bodies O in this checker's plant). </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">body_index</span> is out of range. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">body_index</span> refers to an environment body. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5741d217236e45f7aed61d7a28c23d39" name="a5741d217236e45f7aed61d7a28c23d39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5741d217236e45f7aed61d7a28c23d39">&#9670;&#160;</a></span>SetCollisionFilterMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetCollisionFilterMatrix </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXi &amp;</td>          <td class="paramname"><span class="paramname"><em>filter_matrix</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the "active" collision filter matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filter_matrix</td><td>must meet the above conditions to be a "consistent" collision filter matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the given matrix is incompatible with this collision checker, or if it is inconsistent. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad399081b57b1becb847d9a6f77928903" name="ad399081b57b1becb847d9a6f77928903"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad399081b57b1becb847d9a6f77928903">&#9670;&#160;</a></span>SetConfigurationDistanceFunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetConfigurationDistanceFunction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1planning.html#abdbb6a212eb30d6a68643bf0aebe0426">ConfigurationDistanceFunction</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>distance_function</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the configuration distance function to <span class="tt">distance_function</span>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>distance_function satisfies the requirements documented on <a class="el" href="namespacedrake_1_1planning.html#abdbb6a212eb30d6a68643bf0aebe0426" title="Configuration distance takes two configurations of the robot, q1 and q2, both as Eigen::VectorXd,...">ConfigurationDistanceFunction</a> and a <a class="el" href="classdrake_1_1planning_1_1_distance_and_interpolation_provider.html" title="This class represents the base interface for performing configuration distance and interpolation oper...">DistanceAndInterpolationProvider</a> is not already in use. </dd>
<dd>
the collision checker was created with separate distance and interpolation functions, not a combined <a class="el" href="classdrake_1_1planning_1_1_distance_and_interpolation_provider.html" title="This class represents the base interface for performing configuration distance and interpolation oper...">DistanceAndInterpolationProvider</a>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>the <span class="tt">distance_function</span> object will be copied and retained by this collision checker, so if the function has any lambda-captured data then that data must outlive this collision checker. </dd></dl>

</div>
</div>
<a id="aebf58f4817df47ff85f1e4f3de824382" name="aebf58f4817df47ff85f1e4f3de824382"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebf58f4817df47ff85f1e4f3de824382">&#9670;&#160;</a></span>SetConfigurationInterpolationFunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetConfigurationInterpolationFunction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1planning.html#a51c19bebe45e89327241c79776dad396">ConfigurationInterpolationFunction</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>interpolation_function</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the configuration interpolation function to <span class="tt">interpolation_function</span>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interpolation_function</td><td>a functor, or nullptr. If nullptr, the default function will be configured and used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>interpolation_function satisfies the requirements documented on <a class="el" href="namespacedrake_1_1planning.html#a51c19bebe45e89327241c79776dad396" title="Configuration interpolation function takes two configurations of the robot, q1, and q2,...">ConfigurationInterpolationFunction</a>, or is nullptr and a <a class="el" href="classdrake_1_1planning_1_1_distance_and_interpolation_provider.html" title="This class represents the base interface for performing configuration distance and interpolation oper...">DistanceAndInterpolationProvider</a> is not already in use. </dd>
<dd>
the collision checker was created with separate distance and interpolation functions, not a combined <a class="el" href="classdrake_1_1planning_1_1_distance_and_interpolation_provider.html" title="This class represents the base interface for performing configuration distance and interpolation oper...">DistanceAndInterpolationProvider</a>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>the <span class="tt">interpolation_function</span> object will be copied and retained by this collision checker, so if the function has any lambda-captured data then that data must outlive this collision checker. </dd>
<dd>
the default function uses linear interpolation for most variables, and uses slerp for quaternion valued variables. </dd></dl>

</div>
</div>
<a id="afef8ab83612978d5deeb7cd6fc413b80" name="afef8ab83612978d5deeb7cd6fc413b80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afef8ab83612978d5deeb7cd6fc413b80">&#9670;&#160;</a></span>SetDistanceAndInterpolationProvider()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetDistanceAndInterpolationProvider </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1planning_1_1_distance_and_interpolation_provider.html">DistanceAndInterpolationProvider</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>provider</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the distance and interpolation provider to use. </p>
<p>Note that in case any of the (to-be-deprecated) separate distance and interpolation functions were in use, this supplants <em>both</em> of them. </p><dl class="section pre"><dt>Precondition</dt><dd>provider satisfies the requirements documents on <a class="el" href="classdrake_1_1planning_1_1_distance_and_interpolation_provider.html" title="This class represents the base interface for performing configuration distance and interpolation oper...">DistanceAndInterpolationProvider</a>. </dd></dl>

</div>
</div>
<a id="af9df46cf7a999edaee7b5461a38a8e0d" name="af9df46cf7a999edaee7b5461a38a8e0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9df46cf7a999edaee7b5461a38a8e0d">&#9670;&#160;</a></span>SetPaddingAllRobotEnvironmentPairs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetPaddingAllRobotEnvironmentPairs </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>padding</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the padding for all (robot, environment) pairs. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the <a class="el" href="#collision_checker_padding_prereqs">configuration prerequisites</a> are not met. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af8423473a4d7b2c2b37c7f9c8108c7a3" name="af8423473a4d7b2c2b37c7f9c8108c7a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8423473a4d7b2c2b37c7f9c8108c7a3">&#9670;&#160;</a></span>SetPaddingAllRobotRobotPairs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetPaddingAllRobotRobotPairs </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>padding</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the padding for all (robot, robot) pairs. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the <a class="el" href="#collision_checker_padding_prereqs">configuration prerequisites</a> are not met. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a216553d6f53318bace05961e5010ab97" name="a216553d6f53318bace05961e5010ab97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a216553d6f53318bace05961e5010ab97">&#9670;&#160;</a></span>SetPaddingBetween() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetPaddingBetween </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">multibody::RigidBody</a>&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>bodyA</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">multibody::RigidBody</a>&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>bodyB</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>padding</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload that uses body references. </p>

</div>
</div>
<a id="a2abd1ef467638caa52681db77bd8ea18" name="a2abd1ef467638caa52681db77bd8ea18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2abd1ef467638caa52681db77bd8ea18">&#9670;&#160;</a></span>SetPaddingBetween() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetPaddingBetween </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#a02d233e6f0ef016f5cf02e2222a22f5c">multibody::BodyIndex</a></td>          <td class="paramname"><span class="paramname"><em>bodyA_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#a02d233e6f0ef016f5cf02e2222a22f5c">multibody::BodyIndex</a></td>          <td class="paramname"><span class="paramname"><em>bodyB_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>padding</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the padding value for the pair of bodies specified. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the <a class="el" href="#collision_checker_padding_prereqs">configuration prerequisites</a> are not met or <span class="tt">bodyA_index ==
        bodyB_index</span>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae5073981822b962bcc7ca569b399b3db" name="ae5073981822b962bcc7ca569b399b3db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5073981822b962bcc7ca569b399b3db">&#9670;&#160;</a></span>SetPaddingMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetPaddingMatrix </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;</td>          <td class="paramname"><span class="paramname"><em>collision_padding</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the collision padding matrix. </p>
<p>Note that this matrix contains all padding data, both robot-robot "self" padding, and robot-environment padding. <span class="tt">collision_padding</span> must have the following properties to be considered valid.</p>
<ul>
<li>It is a square NxN matrix (where N is the total number of bodies).</li>
<li>Diagonal values are all zero.</li>
<li>Entries involving only environment bodies are all zero.</li>
<li>It is symmetric.</li>
<li>All values are finite.</li>
</ul>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">collision_padding</span> doesn't have the enumerated properties. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a963ab30a4085cd7704496f7c5289c7df" name="a963ab30a4085cd7704496f7c5289c7df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a963ab30a4085cd7704496f7c5289c7df">&#9670;&#160;</a></span>SetPaddingOneRobotBodyAllEnvironmentPairs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetPaddingOneRobotBodyAllEnvironmentPairs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#a02d233e6f0ef016f5cf02e2222a22f5c">multibody::BodyIndex</a></td>          <td class="paramname"><span class="paramname"><em>body_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>padding</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the environment collision padding for the provided robot body with respect to all environment bodies. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the <a class="el" href="#collision_checker_padding_prereqs">configuration prerequisites</a> are not met. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6831872639ff530b78810ef26115bb26" name="a6831872639ff530b78810ef26115bb26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6831872639ff530b78810ef26115bb26">&#9670;&#160;</a></span>SupportsParallelChecking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SupportsParallelChecking </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Does the collision checker support true parallel collision checks? </p>
<dl class="section return"><dt>Returns</dt><dd>true if parallel checking is supported. </dd></dl>

</div>
</div>
<a id="a798297e12a4bdd3f95081215966ed07d" name="a798297e12a4bdd3f95081215966ed07d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a798297e12a4bdd3f95081215966ed07d">&#9670;&#160;</a></span>UpdateCollisionFilters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void UpdateCollisionFilters </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Derived collision checkers can do further work in this function in response to changes in collision filters. </p>
<p>This is called after any changes are made to the collision filter matrix. </p>

<p>Implemented in <a class="el" href="classdrake_1_1planning_1_1_unimplemented_collision_checker.html#a202d29fe281f901ce6a8f278dc61764c">UnimplementedCollisionChecker</a>.</p>

</div>
</div>
<a id="ac3e931b23a64ee072c7290b6aa3462be" name="ac3e931b23a64ee072c7290b6aa3462be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3e931b23a64ee072c7290b6aa3462be">&#9670;&#160;</a></span>UpdateContextPositions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; double &gt; &amp; UpdateContextPositions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1planning_1_1_collision_checker_context.html">CollisionCheckerContext</a> *</td>          <td class="paramname"><span class="paramname"><em>model_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>q</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Explicit Context-based version of <a class="el" href="#a3e74e151c02c6abad08eed5a7f77df0a" title="Updates the generalized positions q in the implicit context specified and returns a reference to the ...">UpdatePositions()</a>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <span class="tt"><a class="el" href="#a5a8b62cb6805a9d647e8ea0c783bb47d" title="Accesses a collision checking context from within the implicit context pool owned by this collision c...">model_context</a></span> is <span class="tt">nullptr</span>. </td></tr>
    <tr><td class="paramname">if</td><td><span class="tt">q</span> contains non-finite values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ccb_explicit_contexts">Explicit Context Parallelism</a>. </dd></dl>

</div>
</div>
<a id="a3e74e151c02c6abad08eed5a7f77df0a" name="a3e74e151c02c6abad08eed5a7f77df0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e74e151c02c6abad08eed5a7f77df0a">&#9670;&#160;</a></span>UpdatePositions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; double &gt; &amp; UpdatePositions </td>
          <td>(</td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>q</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; int &gt;</td>          <td class="paramname"><span class="paramname"><em>context_number</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::nullopt</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the generalized positions <span class="tt">q</span> in the implicit context specified and returns a reference to the MultibodyPlant's now-updated context. </p>
<p>The implicit context is either that specified by <span class="tt">context_number</span>, or when nullopt the context to be used with the current OpenMP thread. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context_number</td><td>Optional implicit context number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ccb_implicit_contexts">Implicit Context Parallelism</a>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">if</td><td><span class="tt">q</span> contains non-finite values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>drake/planning/<a class="el" href="collision__checker_8h.html">collision_checker.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- footer -->
<div class="navpath">
  <ul>
    <li class="navelem"><a href="namespacedrake.html">drake</a></li><li class="navelem"><a href="namespacedrake_1_1planning.html">planning</a></li><li class="navelem"><a href="classdrake_1_1planning_1_1_collision_checker.html">CollisionChecker</a></li>
  </ul>
</div>
<footer id="nav-path", class="site-footer padding">
  <div class="contain">
    <a href="/" class="drake-logo">
      <img src="/images/drake-logo.svg"/>
    </a>
    <div class="footer-menu">
      <ul>
        <li>
          <a href="https://accessibility.mit.edu/" class="site-menu-item">Accessibility</a>
        </li>
        <li>
          <a href="/doxygen_cxx/index.html" class="site-menu-item">C++</a>
        </li>
        <li>
          <a href="/pydrake/index.html" class="site-menu-item">Python</a>
        </li>
        <li class="github-link">
          <a href="https://github.com/RobotLocomotion/drake" class="site-menu-item">GitHub <img src="/third_party/images/GitHub-Mark-64px.png"/></a>
        </li>
      </ul>
    </div>
  </div>
</footer>
<script type="text/javascript">
searchBox.searchLabel = 'Go to name…';
searchBox.DOMSearchField().placeholder = searchBox.searchLabel;
searchBox.DOMSearchField().value = '';
</script>
</body>
</html>
