<!-- HTML header for doxygen 1.15.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: copyable_unique_ptr&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(function() { init_search(); });
</script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@4/tex-chtml.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<header class="site-header">
 <div class="site-header-inner contain">
  <a class="drake-logo" href="/"><img src="/images/drake-logo-white.svg"></a>
  <div class="menu-mobile-toggle">
   <span></span>
  </div>
  <nav class="site-menu">
   <ul>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/">Home</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/installation.html">Installation</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/gallery.html">Gallery</a>
    </li>
    <li class="site-menu-item site-menu-item-main">API Documentation
     <div class="sub">
      <a class="site-menu-item" href="/doxygen_cxx/index.html">C++</a>
      <a class="site-menu-item" href="/pydrake/index.html">Python</a>
     </div>
    </li>
    <li class="site-menu-item site-menu-item-main">Resources
     <div class="sub">
      <a class="site-menu-item" href="/getting_help.html">Getting Help</a>
      <a class="site-menu-item" href="https://deepnote.com/workspace/Drake-0b3b2c53-a7ad-441b-80f8-bf8350752305/project/Tutorials-2b4fc509-aef2-417d-a40d-6071dfed9199/notebook/index-753e3c9d261247ba9f0eb1d7868c18c8">Tutorials</a>
      <a class="site-menu-item" href="/python_bindings.html">Python Bindings</a>
      <a class="site-menu-item" href="/developers.html">For Developers</a>
      <a class="site-menu-item" href="/credits.html">Credits</a>
     </div>
    </li>
    <li class="github-link">
     <a class="site-menu-item" href="https://github.com/RobotLocomotion/drake">GitHub <img src="/third_party/images/GitHub-Mark-Light-64px.png"></a>
    </li>
   </ul>
  </nav>
 </div>
</header>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<div class="title-banner">
 <div class="title-banner__title">
  Drake C++ Documentation
 </div>
 <div id="DDGSearch">
  <form id="search_form_cpp" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search C++ API only…">
   <input type="hidden" name="q" value="site:drake.mit.edu/doxygen_cxx">
  </form>
  <form id="search_form" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search all of Drake…">
   <input type="hidden" name="q" value="site:drake.mit.edu OR site:underactuated.csail.mit.edu OR site:manipulation.csail.mit.edu">
  </form>
 </div>
 <div id="MSearchBoxContainer">
  <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect" class="search-icon" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"><span class="search-icon-dropdown"></span></span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><div id="MSearchCloseImg" class="close-icon"></div></a>
          </span>
        </div>
</td>
 </div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('classdrake_1_1copyable__unique__ptr.html','','classdrake_1_1copyable__unique__ptr-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">copyable_unique_ptr&lt; T &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename T&gt;<br />
class drake::copyable_unique_ptr&lt; T &gt;</div><p>A smart pointer with deep copy semantics. </p>
<p>This is <em>similar</em> to <span class="tt">std::unique_ptr</span> in that it does not permit shared ownership of the contained object. However, unlike <span class="tt">std::unique_ptr</span>, copyable_unique_ptr supports copy and assignment operations, by insisting that the contained object be "copyable". To be copyable, the class must have either an accessible copy constructor, or it must have an accessible clone method with signature </p><div class="fragment"><div class="line">std::unique_ptr&lt;Foo&gt; Clone() <span class="keyword">const</span>;</div>
</div><!-- fragment --><p> where Foo is the type of the managed object. By "accessible" we mean either that the copy constructor or clone method is public, or <span class="tt">friend <a class="el" href="classdrake_1_1copyable__unique__ptr.html" title="A smart pointer with deep copy semantics.">copyable_unique_ptr</a>&lt;Foo&gt;;</span> appears in Foo's class declaration.</p>
<p>Generally, the API is modeled as closely as possible on the C++ standard <span class="tt">std::unique_ptr</span> API and copyable_unique_ptr is interoperable with <span class="tt">unique_ptr&lt;T&gt;</span> wherever that makes sense. However, there are some differences:</p>
<ol type="1">
<li>It always uses a default deleter.</li>
<li>There is no array version.</li>
<li>To allow for future copy-on-write optimizations, there is a distinction between writable and const access, the <a class="el" href="#a6bd1472e6d131375f0e2670b789cbd0f" title="Return a const pointer to the contained object if any, or nullptr.">get()</a> method is modified to return only a const pointer, with <a class="el" href="#a05eb6db51f59f531a9ffcadd3361436e" title="Return a writable pointer to the contained object if any, or nullptr.">get_mutable()</a> added to return a writable pointer. Furthermore, dereferencing (<a class="el" href="#a3f534efce0b043d603eb8f5653268e7d" title="Return a writable reference to the contained object (if T is itself not const).">operator*()</a>) a mutable pointer will give a mutable reference (in so far as T is not declared const), and dereferencing a const pointer will give a const reference.</li>
</ol>
<p>This class is entirely inline and has no computational or space overhead except when copying is required; it contains just a single pointer and does no reference counting.</p>
<p><b>Usage</b></p>
<p>In the simplest use case, the instantiation type will match the type of object it references, e.g.: </p><div class="fragment"><div class="line"><a class="code hl_function" href="#a38cdcb23181ad1c554ef0209a29cd768">copyable_unique_ptr&lt;Foo&gt;</a> ptr = make_unique&lt;Foo&gt;(...);</div>
<div class="ttc" id="aclassdrake_1_1copyable__unique__ptr_html_a38cdcb23181ad1c554ef0209a29cd768"><div class="ttname"><a href="#a38cdcb23181ad1c554ef0209a29cd768">drake::copyable_unique_ptr::copyable_unique_ptr</a></div><div class="ttdeci">copyable_unique_ptr() noexcept</div><div class="ttdoc">Default constructor stores a nullptr.</div><div class="ttdef"><b>Definition</b> copyable_unique_ptr.h:113</div></div>
</div><!-- fragment --><p> In this case, as long <span class="tt">Foo</span> is deemed compatible, the behavior will be as expected, i.e., when <span class="tt">ptr</span> copies, it will contain a reference to a new instance of <span class="tt">Foo</span>.</p>
<p>copyable_unique_ptr can also be used with polymorphic classes &ndash; a copyable_unique_ptr, instantiated on a <em>base</em> class, references an instance of a <em>derived</em> class. When copying the object, we would want the copy to likewise contain an instance of the derived class. For example:</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="#a38cdcb23181ad1c554ef0209a29cd768">copyable_unique_ptr&lt;Base&gt;</a> cu_ptr = make_unique&lt;Derived&gt;();</div>
<div class="line"><a class="code hl_function" href="#a38cdcb23181ad1c554ef0209a29cd768">copyable_unique_ptr&lt;Base&gt;</a> other_cu_ptr = cu_ptr;           <span class="comment">// Triggers a copy.</span></div>
<div class="line">is_dynamic_castable&lt;Derived&gt;(other_cu_ptr.<a class="code hl_function" href="#a6bd1472e6d131375f0e2670b789cbd0f">get</a>());          <span class="comment">// Should be true.</span></div>
<div class="ttc" id="aclassdrake_1_1copyable__unique__ptr_html_a6bd1472e6d131375f0e2670b789cbd0f"><div class="ttname"><a href="#a6bd1472e6d131375f0e2670b789cbd0f">drake::copyable_unique_ptr::get</a></div><div class="ttdeci">const T * get() const noexcept</div><div class="ttdoc">Return a const pointer to the contained object if any, or nullptr.</div><div class="ttdef"><b>Definition</b> copyable_unique_ptr.h:285</div></div>
</div><!-- fragment --><p>This works for well-designed polymorphic classes.</p>
<dl class="section warning"><dt>Warning</dt><dd>Ill-formed polymorphic classes can lead to fatal type slicing of the referenced object, such that the new copy contains an instance of <span class="tt">Base</span> instead of <span class="tt">Derived</span>. Some mistakes that would lead to this degenerate behavior:</dd></dl>
<ul>
<li>The <span class="tt">Base</span> class's Clone() implementation does not invoke the <span class="tt">Derived</span> class's implementation of a suitable virtual method.</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the contained object, which <em>must</em> be copyable as defined above. May be an abstract or concrete type. </td></tr>
  </table>
  </dd>
</dl>
</div>
<p><code>#include &lt;drake/common/copyable_unique_ptr.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr id="pub-methods-0" class="groupHeader"><td colspan="2"><div class="groupHeader">Constructors</div></td></tr>
<tr class="memitem:a38cdcb23181ad1c554ef0209a29cd768" id="r_a38cdcb23181ad1c554ef0209a29cd768"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a38cdcb23181ad1c554ef0209a29cd768">copyable_unique_ptr</a> () noexcept</td></tr>
<tr class="memdesc:a38cdcb23181ad1c554ef0209a29cd768"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor stores a <span class="tt">nullptr</span>.  <br /></td></tr>
<tr class="memitem:acfdff602d3fd4c83656a696b984ea7f5" id="r_acfdff602d3fd4c83656a696b984ea7f5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acfdff602d3fd4c83656a696b984ea7f5">copyable_unique_ptr</a> (T *raw) noexcept</td></tr>
<tr class="memdesc:acfdff602d3fd4c83656a696b984ea7f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a raw pointer to a writable heap-allocated object, take over ownership of that object.  <br /></td></tr>
<tr class="memitem:ad454f66aaeaf4bff4953937c55634298" id="r_ad454f66aaeaf4bff4953937c55634298"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad454f66aaeaf4bff4953937c55634298">copyable_unique_ptr</a> (const T &amp;value)</td></tr>
<tr class="memdesc:ad454f66aaeaf4bff4953937c55634298"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a unique instance of T as a copy of the provided model value.  <br /></td></tr>
<tr class="memitem:a9efa09fdc8aad69db06b649c447d9806" id="r_a9efa09fdc8aad69db06b649c447d9806"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9efa09fdc8aad69db06b649c447d9806">copyable_unique_ptr</a> (const copyable_unique_ptr &amp;cu_ptr)</td></tr>
<tr class="memdesc:a9efa09fdc8aad69db06b649c447d9806"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor is deep; the new copyable_unique_ptr object contains a new copy of the object in the source, created via the source object's copy constructor or <span class="tt">Clone()</span> method.  <br /></td></tr>
<tr class="memitem:a1774b97188ce9c5a5cd47c5c4ff63fc0" id="r_a1774b97188ce9c5a5cd47c5c4ff63fc0"><td class="memTemplParams" colspan="2">template&lt;typename U&gt; </td></tr>
<tr class="memitem:a1774b97188ce9c5a5cd47c5c4ff63fc0 template"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1774b97188ce9c5a5cd47c5c4ff63fc0">copyable_unique_ptr</a> (const std::unique_ptr&lt; U &gt; &amp;u_ptr)</td></tr>
<tr class="memdesc:a1774b97188ce9c5a5cd47c5c4ff63fc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor from a standard <span class="tt">unique_ptr</span> of <em>compatible</em> type.  <br /></td></tr>
<tr class="memitem:ac60d2d174b5ce39e94bf59719c997250" id="r_ac60d2d174b5ce39e94bf59719c997250"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac60d2d174b5ce39e94bf59719c997250">copyable_unique_ptr</a> (copyable_unique_ptr &amp;&amp;cu_ptr) noexcept</td></tr>
<tr class="memdesc:ac60d2d174b5ce39e94bf59719c997250"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor is very fast and leaves the source empty.  <br /></td></tr>
<tr class="memitem:a5a34341a71b340b3af3ee3d18e9d09bc" id="r_a5a34341a71b340b3af3ee3d18e9d09bc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5a34341a71b340b3af3ee3d18e9d09bc">copyable_unique_ptr</a> (std::unique_ptr&lt; T &gt; &amp;&amp;u_ptr) noexcept</td></tr>
<tr class="memdesc:a5a34341a71b340b3af3ee3d18e9d09bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor from a standard <span class="tt">unique_ptr</span>.  <br /></td></tr>
<tr class="memitem:ad0b538a9c4ca822d4212226ba51dc0aa" id="r_ad0b538a9c4ca822d4212226ba51dc0aa"><td class="memTemplParams" colspan="2">template&lt;typename U&gt; </td></tr>
<tr class="memitem:ad0b538a9c4ca822d4212226ba51dc0aa template"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad0b538a9c4ca822d4212226ba51dc0aa">copyable_unique_ptr</a> (std::unique_ptr&lt; U &gt; &amp;&amp;u_ptr) noexcept</td></tr>
<tr class="memdesc:ad0b538a9c4ca822d4212226ba51dc0aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move construction from a compatible standard <span class="tt">unique_ptr</span>.  <br /></td></tr>
<tr id="pub-methods-1" class="groupHeader"><td colspan="2"><div class="groupHeader">Assignment</div></td></tr>
<tr class="memitem:a6be6239f2e48a9cec1bac49a1c6dbee7" id="r_a6be6239f2e48a9cec1bac49a1c6dbee7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a38cdcb23181ad1c554ef0209a29cd768">copyable_unique_ptr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6be6239f2e48a9cec1bac49a1c6dbee7">operator=</a> (T *raw) noexcept</td></tr>
<tr class="memdesc:a6be6239f2e48a9cec1bac49a1c6dbee7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This form of assignment replaces the currently-held object by the given source object and takes over ownership of the source object.  <br /></td></tr>
<tr class="memitem:ac91938174de556777a72c9a13afe8908" id="r_ac91938174de556777a72c9a13afe8908"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a38cdcb23181ad1c554ef0209a29cd768">copyable_unique_ptr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac91938174de556777a72c9a13afe8908">operator=</a> (const T &amp;ref)</td></tr>
<tr class="memdesc:ac91938174de556777a72c9a13afe8908"><td class="mdescLeft">&#160;</td><td class="mdescRight">This form of assignment replaces the currently-held object by a heap-allocated copy of the source object, created using its copy constructor or <span class="tt">Clone()</span> method.  <br /></td></tr>
<tr class="memitem:ab9f69305b8c9a8ec5387111dcea17819" id="r_ab9f69305b8c9a8ec5387111dcea17819"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a38cdcb23181ad1c554ef0209a29cd768">copyable_unique_ptr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab9f69305b8c9a8ec5387111dcea17819">operator=</a> (const <a class="el" href="#a38cdcb23181ad1c554ef0209a29cd768">copyable_unique_ptr</a> &amp;cu_ptr)</td></tr>
<tr class="memdesc:ab9f69305b8c9a8ec5387111dcea17819"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment from copyable_unique_ptr replaces the currently-held object by a copy of the object held in the source container, created using the source object's copy constructor or <span class="tt">Clone()</span> method.  <br /></td></tr>
<tr class="memitem:a9bcf365fa57478306724aef12f4f9e43" id="r_a9bcf365fa57478306724aef12f4f9e43"><td class="memTemplParams" colspan="2">template&lt;typename U&gt; </td></tr>
<tr class="memitem:a9bcf365fa57478306724aef12f4f9e43 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a38cdcb23181ad1c554ef0209a29cd768">copyable_unique_ptr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9bcf365fa57478306724aef12f4f9e43">operator=</a> (const <a class="el" href="#a38cdcb23181ad1c554ef0209a29cd768">copyable_unique_ptr</a>&lt; U &gt; &amp;cu_ptr)</td></tr>
<tr class="memdesc:a9bcf365fa57478306724aef12f4f9e43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment from a compatible copyable_unique_ptr replaces the currently-held object by a copy of the object held in the source container, created using the source object's copy constructor or <span class="tt">Clone()</span> method.  <br /></td></tr>
<tr class="memitem:a08814f8868af365bb6e6740945caca3b" id="r_a08814f8868af365bb6e6740945caca3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a38cdcb23181ad1c554ef0209a29cd768">copyable_unique_ptr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a08814f8868af365bb6e6740945caca3b">operator=</a> (const std::unique_ptr&lt; T &gt; &amp;src)</td></tr>
<tr class="memdesc:a08814f8868af365bb6e6740945caca3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment from a standard <span class="tt">unique_ptr</span> replaces the currently-held object by a copy of the object held in the source container, created using the source object's copy constructor or <span class="tt">Clone()</span> method.  <br /></td></tr>
<tr class="memitem:a240f5a55cea2f6c449e3236616928e2c" id="r_a240f5a55cea2f6c449e3236616928e2c"><td class="memTemplParams" colspan="2">template&lt;typename U&gt; </td></tr>
<tr class="memitem:a240f5a55cea2f6c449e3236616928e2c template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a38cdcb23181ad1c554ef0209a29cd768">copyable_unique_ptr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a240f5a55cea2f6c449e3236616928e2c">operator=</a> (const std::unique_ptr&lt; U &gt; &amp;u_ptr)</td></tr>
<tr class="memdesc:a240f5a55cea2f6c449e3236616928e2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment from a compatible standard <span class="tt">unique_ptr</span> replaces the currently-held object by a copy of the object held in the source container, created using the source object's copy constructor or <span class="tt">Clone()</span> method.  <br /></td></tr>
<tr class="memitem:a3a0a9193c0637e2a9b2813aaf375a014" id="r_a3a0a9193c0637e2a9b2813aaf375a014"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a38cdcb23181ad1c554ef0209a29cd768">copyable_unique_ptr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3a0a9193c0637e2a9b2813aaf375a014">operator=</a> (<a class="el" href="#a38cdcb23181ad1c554ef0209a29cd768">copyable_unique_ptr</a> &amp;&amp;cu_ptr) noexcept</td></tr>
<tr class="memdesc:a3a0a9193c0637e2a9b2813aaf375a014"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment replaces the currently-held object by the source object, leaving the source empty.  <br /></td></tr>
<tr class="memitem:a7c34234c3ca4d100b54614332120b64e" id="r_a7c34234c3ca4d100b54614332120b64e"><td class="memTemplParams" colspan="2">template&lt;typename U&gt; </td></tr>
<tr class="memitem:a7c34234c3ca4d100b54614332120b64e template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a38cdcb23181ad1c554ef0209a29cd768">copyable_unique_ptr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7c34234c3ca4d100b54614332120b64e">operator=</a> (<a class="el" href="#a38cdcb23181ad1c554ef0209a29cd768">copyable_unique_ptr</a>&lt; U &gt; &amp;&amp;cu_ptr) noexcept</td></tr>
<tr class="memdesc:a7c34234c3ca4d100b54614332120b64e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment replaces the currently-held object by the compatible source object, leaving the source empty.  <br /></td></tr>
<tr class="memitem:a789ee5e0480e220978ab29bbfbf711a7" id="r_a789ee5e0480e220978ab29bbfbf711a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a38cdcb23181ad1c554ef0209a29cd768">copyable_unique_ptr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a789ee5e0480e220978ab29bbfbf711a7">operator=</a> (std::unique_ptr&lt; T &gt; &amp;&amp;u_ptr) noexcept</td></tr>
<tr class="memdesc:a789ee5e0480e220978ab29bbfbf711a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment replaces the currently-held object by the source object, leaving the source empty.  <br /></td></tr>
<tr class="memitem:a3e46b0304bfb4542ded3f290ec0c05c6" id="r_a3e46b0304bfb4542ded3f290ec0c05c6"><td class="memTemplParams" colspan="2">template&lt;typename U&gt; </td></tr>
<tr class="memitem:a3e46b0304bfb4542ded3f290ec0c05c6 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a38cdcb23181ad1c554ef0209a29cd768">copyable_unique_ptr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3e46b0304bfb4542ded3f290ec0c05c6">operator=</a> (std::unique_ptr&lt; U &gt; &amp;&amp;u_ptr) noexcept</td></tr>
<tr class="memdesc:a3e46b0304bfb4542ded3f290ec0c05c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment replaces the currently-held object by the compatible source object, leaving the source empty.  <br /></td></tr>
<tr id="pub-methods-2" class="groupHeader"><td colspan="2"><div class="groupHeader">Observers</div></td></tr>
<tr class="memitem:a3f6fc5de06a318920d84f3c3742db07f" id="r_a3f6fc5de06a318920d84f3c3742db07f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f6fc5de06a318920d84f3c3742db07f">empty</a> () const noexcept</td></tr>
<tr class="memdesc:a3f6fc5de06a318920d84f3c3742db07f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this container is empty, which is the state the container is in immediately after default construction and various other operations.  <br /></td></tr>
<tr class="memitem:a6bd1472e6d131375f0e2670b789cbd0f" id="r_a6bd1472e6d131375f0e2670b789cbd0f"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6bd1472e6d131375f0e2670b789cbd0f">get</a> () const noexcept</td></tr>
<tr class="memdesc:a6bd1472e6d131375f0e2670b789cbd0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const pointer to the contained object if any, or <span class="tt">nullptr</span>.  <br /></td></tr>
<tr class="memitem:a05eb6db51f59f531a9ffcadd3361436e" id="r_a05eb6db51f59f531a9ffcadd3361436e"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a05eb6db51f59f531a9ffcadd3361436e">get_mutable</a> () noexcept</td></tr>
<tr class="memdesc:a05eb6db51f59f531a9ffcadd3361436e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a writable pointer to the contained object if any, or <span class="tt">nullptr</span>.  <br /></td></tr>
<tr class="memitem:a241c04e3ce86e1fd5a946eb2aa8b1f22" id="r_a241c04e3ce86e1fd5a946eb2aa8b1f22"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a241c04e3ce86e1fd5a946eb2aa8b1f22">operator*</a> () const</td></tr>
<tr class="memdesc:a241c04e3ce86e1fd5a946eb2aa8b1f22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const reference to the contained object.  <br /></td></tr>
<tr class="memitem:a3f534efce0b043d603eb8f5653268e7d" id="r_a3f534efce0b043d603eb8f5653268e7d"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f534efce0b043d603eb8f5653268e7d">operator*</a> ()</td></tr>
<tr class="memdesc:a3f534efce0b043d603eb8f5653268e7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a writable reference to the contained object (if T is itself not const).  <br /></td></tr>
</table>
<a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a38cdcb23181ad1c554ef0209a29cd768" name="a38cdcb23181ad1c554ef0209a29cd768"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38cdcb23181ad1c554ef0209a29cd768">&#9670;&#160;</a></span>copyable_unique_ptr() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">copyable_unique_ptr </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor stores a <span class="tt">nullptr</span>. </p>
<p>No heap allocation is performed. The <a class="el" href="#a3f6fc5de06a318920d84f3c3742db07f" title="Return true if this container is empty, which is the state the container is in immediately after defa...">empty()</a> method will return true when called on a default-constructed copyable_unique_ptr. </p>

</div>
</div>
<a id="acfdff602d3fd4c83656a696b984ea7f5" name="acfdff602d3fd4c83656a696b984ea7f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfdff602d3fd4c83656a696b984ea7f5">&#9670;&#160;</a></span>copyable_unique_ptr() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">copyable_unique_ptr </td>
          <td>(</td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>raw</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel explicit">explicit</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a raw pointer to a writable heap-allocated object, take over ownership of that object. </p>
<p>No copying occurs. </p>

</div>
</div>
<a id="ad454f66aaeaf4bff4953937c55634298" name="ad454f66aaeaf4bff4953937c55634298"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad454f66aaeaf4bff4953937c55634298">&#9670;&#160;</a></span>copyable_unique_ptr() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">copyable_unique_ptr </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a unique instance of T as a copy of the provided model value. </p>

</div>
</div>
<a id="a9efa09fdc8aad69db06b649c447d9806" name="a9efa09fdc8aad69db06b649c447d9806"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9efa09fdc8aad69db06b649c447d9806">&#9670;&#160;</a></span>copyable_unique_ptr() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">copyable_unique_ptr </td>
          <td>(</td>
          <td class="paramtype">const copyable_unique_ptr&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>cu_ptr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor is deep; the new copyable_unique_ptr object contains a new copy of the object in the source, created via the source object's copy constructor or <span class="tt">Clone()</span> method. </p>
<p>If the source container is empty this one will be empty also. </p>

</div>
</div>
<a id="a1774b97188ce9c5a5cd47c5c4ff63fc0" name="a1774b97188ce9c5a5cd47c5c4ff63fc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1774b97188ce9c5a5cd47c5c4ff63fc0">&#9670;&#160;</a></span>copyable_unique_ptr() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">copyable_unique_ptr </td>
          <td>(</td>
          <td class="paramtype">const std::unique_ptr&lt; U &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>u_ptr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor from a standard <span class="tt">unique_ptr</span> of <em>compatible</em> type. </p>
<p>The copy is deep; the new copyable_unique_ptr object contains a new copy of the object in the source, created via the source object's copy constructor or <span class="tt">Clone()</span> method. If the source container is empty this one will be empty also. </p>

</div>
</div>
<a id="ac60d2d174b5ce39e94bf59719c997250" name="ac60d2d174b5ce39e94bf59719c997250"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac60d2d174b5ce39e94bf59719c997250">&#9670;&#160;</a></span>copyable_unique_ptr() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">copyable_unique_ptr </td>
          <td>(</td>
          <td class="paramtype">copyable_unique_ptr&lt; T &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>cu_ptr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor is very fast and leaves the source empty. </p>
<p>Ownership is transferred from the source to the new copyable_unique_ptr. If the source was empty this one will be empty also. No heap activity occurs. </p>

</div>
</div>
<a id="a5a34341a71b340b3af3ee3d18e9d09bc" name="a5a34341a71b340b3af3ee3d18e9d09bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a34341a71b340b3af3ee3d18e9d09bc">&#9670;&#160;</a></span>copyable_unique_ptr() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">copyable_unique_ptr </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; T &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>u_ptr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel explicit">explicit</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor from a standard <span class="tt">unique_ptr</span>. </p>
<p>The move is very fast and leaves the source empty. Ownership is transferred from the source to the new copyable_unique_ptr. If the source was empty this one will be empty also. No heap activity occurs. </p>

</div>
</div>
<a id="ad0b538a9c4ca822d4212226ba51dc0aa" name="ad0b538a9c4ca822d4212226ba51dc0aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0b538a9c4ca822d4212226ba51dc0aa">&#9670;&#160;</a></span>copyable_unique_ptr() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">copyable_unique_ptr </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; U &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>u_ptr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel explicit">explicit</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move construction from a compatible standard <span class="tt">unique_ptr</span>. </p>
<p>Type <span class="tt">U*</span> must be implicitly convertible to type <span class="tt">T*</span>. Ownership is transferred from the source to the new copyable_unique_ptr. If the source was empty this one will be empty also. No heap activity occurs. </p>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="a3f6fc5de06a318920d84f3c3742db07f" name="a3f6fc5de06a318920d84f3c3742db07f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f6fc5de06a318920d84f3c3742db07f">&#9670;&#160;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool empty </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if this container is empty, which is the state the container is in immediately after default construction and various other operations. </p>

</div>
</div>
<a id="a6bd1472e6d131375f0e2670b789cbd0f" name="a6bd1472e6d131375f0e2670b789cbd0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bd1472e6d131375f0e2670b789cbd0f">&#9670;&#160;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T * get </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const pointer to the contained object if any, or <span class="tt">nullptr</span>. </p>
<p>Note that this is different than <span class="tt">get()</span> for the standard smart pointers like <span class="tt">std::unique_ptr</span> which return a writable pointer. Use <a class="el" href="#a05eb6db51f59f531a9ffcadd3361436e" title="Return a writable pointer to the contained object if any, or nullptr.">get_mutable()</a> here for that purpose. </p>

</div>
</div>
<a id="a05eb6db51f59f531a9ffcadd3361436e" name="a05eb6db51f59f531a9ffcadd3361436e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05eb6db51f59f531a9ffcadd3361436e">&#9670;&#160;</a></span>get_mutable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * get_mutable </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a writable pointer to the contained object if any, or <span class="tt">nullptr</span>. </p>
<p>Note that you need write access to this container in order to get write access to the object it contains.</p>
<dl class="section warning"><dt>Warning</dt><dd>If copyable_unique_ptr is instantiated on a const template parameter (e.g., <span class="tt"><a class="el" href="classdrake_1_1copyable__unique__ptr.html" title="A smart pointer with deep copy semantics.">copyable_unique_ptr</a>&lt;const Foo&gt;</span>), then <a class="el" href="#a05eb6db51f59f531a9ffcadd3361436e" title="Return a writable pointer to the contained object if any, or nullptr.">get_mutable()</a> returns a const pointer. </dd></dl>

</div>
</div>
<a id="a3f534efce0b043d603eb8f5653268e7d" name="a3f534efce0b043d603eb8f5653268e7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f534efce0b043d603eb8f5653268e7d">&#9670;&#160;</a></span>operator*() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T &amp; operator* </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a writable reference to the contained object (if T is itself not const). </p>
<p>Note that you need write access to this container in order to get write access to the object it contains.</p>
<p>We <em>strongly</em> recommend, that, if dereferencing a copyable_unique_ptr without the intention of mutating the underlying value, prefer to dereference a <em>const</em> copyable_unique_ptr (or use *my_ptr.<a class="el" href="#a6bd1472e6d131375f0e2670b789cbd0f" title="Return a const pointer to the contained object if any, or nullptr.">get()</a>) and not a mutable copyable_unique_ptr. As "copy-on-write" behavior is introduced in the future, this recommended practice will prevent unwanted copies of the underlying value.</p>
<p>If copyable_unique_ptr is instantiated on a const template parameter (e.g., <span class="tt"><a class="el" href="classdrake_1_1copyable__unique__ptr.html" title="A smart pointer with deep copy semantics.">copyable_unique_ptr</a>&lt;const Foo&gt;</span>), then <a class="el" href="#a3f534efce0b043d603eb8f5653268e7d" title="Return a writable reference to the contained object (if T is itself not const).">operator*()</a> must return a const reference.</p>
<dl class="section pre"><dt>Precondition</dt><dd><span class="tt">this != nullptr</span> reports <span class="tt">true</span>. </dd></dl>

</div>
</div>
<a id="a241c04e3ce86e1fd5a946eb2aa8b1f22" name="a241c04e3ce86e1fd5a946eb2aa8b1f22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a241c04e3ce86e1fd5a946eb2aa8b1f22">&#9670;&#160;</a></span>operator*() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; operator* </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a const reference to the contained object. </p>
<p>Note that this is different from <span class="tt">std::unique_ptr::operator*()</span> which would return a non-const reference (if <span class="tt">T</span> is non-const), even if the container itself is const. For a const copyable_unique_ptr will always return a const reference to its contained value.</p>
<dl class="section warning"><dt>Warning</dt><dd>Currently copyable_unique_ptr is a std::unique_ptr. As such, a const copyable_unique_ptr&lt;Foo&gt; can be upcast to a const unique_ptr&lt;Foo&gt; and the parent's behavior will provide a mutable reference. This is strongly discouraged and will break as the implementation of this class changes to shore up this gap in the const correctness protection.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><span class="tt">this != nullptr</span> reports <span class="tt">true</span>. </dd></dl>

</div>
</div>
<a id="ab9f69305b8c9a8ec5387111dcea17819" name="ab9f69305b8c9a8ec5387111dcea17819"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9f69305b8c9a8ec5387111dcea17819">&#9670;&#160;</a></span>operator=() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a38cdcb23181ad1c554ef0209a29cd768">copyable_unique_ptr</a> &amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a38cdcb23181ad1c554ef0209a29cd768">copyable_unique_ptr</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>cu_ptr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy assignment from copyable_unique_ptr replaces the currently-held object by a copy of the object held in the source container, created using the source object's copy constructor or <span class="tt">Clone()</span> method. </p>
<p>The currently-held object (if any) is deleted. If the source container is empty this one will be empty also after the assignment. Nothing happens if the source and destination are the same container. </p>

</div>
</div>
<a id="a9bcf365fa57478306724aef12f4f9e43" name="a9bcf365fa57478306724aef12f4f9e43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bcf365fa57478306724aef12f4f9e43">&#9670;&#160;</a></span>operator=() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename U&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a38cdcb23181ad1c554ef0209a29cd768">copyable_unique_ptr</a> &amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a38cdcb23181ad1c554ef0209a29cd768">copyable_unique_ptr</a>&lt; U &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>cu_ptr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy assignment from a compatible copyable_unique_ptr replaces the currently-held object by a copy of the object held in the source container, created using the source object's copy constructor or <span class="tt">Clone()</span> method. </p>
<p>The currently-held object (if any) is deleted. If the source container is empty this one will be empty also after the assignment. Nothing happens if the source and destination are the same container. </p>

</div>
</div>
<a id="a08814f8868af365bb6e6740945caca3b" name="a08814f8868af365bb6e6740945caca3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08814f8868af365bb6e6740945caca3b">&#9670;&#160;</a></span>operator=() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a38cdcb23181ad1c554ef0209a29cd768">copyable_unique_ptr</a> &amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const std::unique_ptr&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy assignment from a standard <span class="tt">unique_ptr</span> replaces the currently-held object by a copy of the object held in the source container, created using the source object's copy constructor or <span class="tt">Clone()</span> method. </p>
<p>The currently-held object (if any) is deleted. If the source container is empty this one will be empty also after the assignment. Nothing happens if the source and destination are the same container. </p>

</div>
</div>
<a id="a240f5a55cea2f6c449e3236616928e2c" name="a240f5a55cea2f6c449e3236616928e2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a240f5a55cea2f6c449e3236616928e2c">&#9670;&#160;</a></span>operator=() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename U&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a38cdcb23181ad1c554ef0209a29cd768">copyable_unique_ptr</a> &amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const std::unique_ptr&lt; U &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>u_ptr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy assignment from a compatible standard <span class="tt">unique_ptr</span> replaces the currently-held object by a copy of the object held in the source container, created using the source object's copy constructor or <span class="tt">Clone()</span> method. </p>
<p>The currently-held object (if any) is deleted. If the source container is empty this one will be empty also after the assignment. Nothing happens if the source and destination are the same container. </p>

</div>
</div>
<a id="ac91938174de556777a72c9a13afe8908" name="ac91938174de556777a72c9a13afe8908"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac91938174de556777a72c9a13afe8908">&#9670;&#160;</a></span>operator=() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a38cdcb23181ad1c554ef0209a29cd768">copyable_unique_ptr</a> &amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>ref</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This form of assignment replaces the currently-held object by a heap-allocated copy of the source object, created using its copy constructor or <span class="tt">Clone()</span> method. </p>
<p>The currently-held object (if any) is deleted. </p>

</div>
</div>
<a id="a3a0a9193c0637e2a9b2813aaf375a014" name="a3a0a9193c0637e2a9b2813aaf375a014"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a0a9193c0637e2a9b2813aaf375a014">&#9670;&#160;</a></span>operator=() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a38cdcb23181ad1c554ef0209a29cd768">copyable_unique_ptr</a> &amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a38cdcb23181ad1c554ef0209a29cd768">copyable_unique_ptr</a>&lt; T &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>cu_ptr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment replaces the currently-held object by the source object, leaving the source empty. </p>
<p>The currently-held object (if any) is deleted. The instance is <em>not</em> copied. Nothing happens if the source and destination are the same containers. </p>

</div>
</div>
<a id="a7c34234c3ca4d100b54614332120b64e" name="a7c34234c3ca4d100b54614332120b64e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c34234c3ca4d100b54614332120b64e">&#9670;&#160;</a></span>operator=() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a38cdcb23181ad1c554ef0209a29cd768">copyable_unique_ptr</a> &amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a38cdcb23181ad1c554ef0209a29cd768">copyable_unique_ptr</a>&lt; U &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>cu_ptr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment replaces the currently-held object by the compatible source object, leaving the source empty. </p>
<p>The currently-held object (if any) is deleted. The instance is <em>not</em> copied. Nothing happens if the source and destination are the same containers. </p>

</div>
</div>
<a id="a789ee5e0480e220978ab29bbfbf711a7" name="a789ee5e0480e220978ab29bbfbf711a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a789ee5e0480e220978ab29bbfbf711a7">&#9670;&#160;</a></span>operator=() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a38cdcb23181ad1c554ef0209a29cd768">copyable_unique_ptr</a> &amp; operator= </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; T &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>u_ptr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment replaces the currently-held object by the source object, leaving the source empty. </p>
<p>The currently-held object (if any) is deleted. The instance is <em>not</em> copied. Nothing happens if the source and destination are the same containers. </p>

</div>
</div>
<a id="a3e46b0304bfb4542ded3f290ec0c05c6" name="a3e46b0304bfb4542ded3f290ec0c05c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e46b0304bfb4542ded3f290ec0c05c6">&#9670;&#160;</a></span>operator=() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a38cdcb23181ad1c554ef0209a29cd768">copyable_unique_ptr</a> &amp; operator= </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; U &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>u_ptr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment replaces the currently-held object by the compatible source object, leaving the source empty. </p>
<p>The currently-held object (if any) is deleted. The instance is <em>not</em> copied. Nothing happens if the source and destination are the same containers. </p>

</div>
</div>
<a id="a6be6239f2e48a9cec1bac49a1c6dbee7" name="a6be6239f2e48a9cec1bac49a1c6dbee7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6be6239f2e48a9cec1bac49a1c6dbee7">&#9670;&#160;</a></span>operator=() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a38cdcb23181ad1c554ef0209a29cd768">copyable_unique_ptr</a> &amp; operator= </td>
          <td>(</td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>raw</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This form of assignment replaces the currently-held object by the given source object and takes over ownership of the source object. </p>
<p>The currently-held object (if any) is deleted. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>drake/common/<a class="el" href="copyable__unique__ptr_8h.html">copyable_unique_ptr.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- footer -->
<div class="navpath">
  <ul>
    <li class="navelem"><a href="namespacedrake.html">drake</a></li><li class="navelem"><a href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a></li>
  </ul>
</div>
<footer id="nav-path", class="site-footer padding">
  <div class="contain">
    <a href="/" class="drake-logo">
      <img src="/images/drake-logo.svg"/>
    </a>
    <div class="footer-menu">
      <ul>    
        <li>
          <a href="/doxygen_cxx/index.html" class="site-menu-item">C++</a>
        </li>    
        <li>
          <a href="/pydrake/index.html" class="site-menu-item">Python</a>
        </li>
        <li class="github-link">
          <a href="https://github.com/RobotLocomotion/drake" class="site-menu-item">GitHub <img src="/third_party/images/GitHub-Mark-64px.png"/></a>
        </li>
      </ul>
    </div>
  </div>
</footer>
<script type="text/javascript">
searchBox.searchLabel = 'Go to name…';
searchBox.DOMSearchField().placeholder = searchBox.searchLabel;
searchBox.DOMSearchField().value = '';
</script>
</body>
</html>
