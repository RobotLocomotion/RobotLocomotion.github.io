<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: copyable_unique_ptr&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<header class="site-header">
 <div class="site-header-inner contain">
  <a class="drake-logo" href="/"><img src="/images/drake-logo-white.svg"></a>
  <div class="menu-mobile-toggle">
   <span></span>
  </div>
  <nav class="site-menu">
   <ul>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/">Home</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/installation.html">Installation</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/gallery.html">Gallery</a>
    </li>
    <li class="site-menu-item site-menu-item-main">API Documentation
     <div class="sub">
      <a class="site-menu-item" href="https://drake.mit.edu/doxygen_cxx/index.html">C++</a>
      <a class="site-menu-item" href="https://drake.mit.edu/pydrake/index.html">Python</a>
     </div>
    </li>
    <li class="site-menu-item site-menu-item-main">Resources
     <div class="sub">
      <a class="site-menu-item" href="/getting_help.html">Getting Help</a>
      <a class="site-menu-item" href="https://deepnote.com/workspace/Drake-0b3b2c53-a7ad-441b-80f8-bf8350752305/project/Tutorials-2b4fc509-aef2-417d-a40d-6071dfed9199/%2Findex.ipynb">Tutorials</a>
      <a class="site-menu-item" href="/python_bindings.html">Python Bindings</a>
      <a class="site-menu-item" href="/developers.html">For Developers</a>
      <a class="site-menu-item" href="/credits.html">Credits</a>
     </div>
    </li>
    <li class="github-link">
     <a class="site-menu-item" href="https://github.com/RobotLocomotion/drake">GitHub <img src="/third_party/images/GitHub-Mark-Light-64px.png"></a>
    </li>
   </ul>
  </nav>
 </div>
</header>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
<div class="title-banner">
 <div class="title-banner__title">
  Drake C++ Documentation
 </div>
 <div id="DDGSearch">
  <form id="ddg-search-form" class="wy_form" action="https://duckduckgo.com/" method="get">
   <input type="text" name="q" placeholder="Search C++ API only…">
   <input type="hidden" name="sites" value="drake.mit.edu/doxygen_cxx">
  </form>
  <form id="ddg-search-form" class="wy_form" action="https://duckduckgo.com/" method="get">
   <input type="text" name="q" placeholder="Search all of Drake…">
   <input type="hidden" name="sites" value="drake.mit.edu">
  </form>
 </div>
 <div id="MSearchBoxContainer">
          <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
 </div>
</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classdrake_1_1copyable__unique__ptr.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#related">Related Functions</a> &#124;
<a href="classdrake_1_1copyable__unique__ptr-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">copyable_unique_ptr&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class drake::copyable_unique_ptr&lt; T &gt;</h3>

<p>A smart pointer with deep copy semantics. </p>
<p>This is <em>similar</em> to <code>std::unique_ptr</code> in that it does not permit shared ownership of the contained object. However, unlike <code>std::unique_ptr</code>, copyable_unique_ptr supports copy and assignment operations, by insisting that the contained object be "copyable". To be copyable, the class must have either an accessible copy constructor, or it must have an accessible clone method with signature</p><div class="fragment"><div class="line">std::unique_ptr&lt;Foo&gt; Clone() <span class="keyword">const</span>;</div></div><!-- fragment --><p> where Foo is the type of the managed object. By "accessible" we mean either that the copy constructor or clone method is public, or <code>friend <a class="el" href="classdrake_1_1copyable__unique__ptr.html" title="A smart pointer with deep copy semantics.">copyable_unique_ptr</a>&lt;Foo&gt;;</code> appears in Foo's class declaration.</p>
<p>Generally, the API is modeled as closely as possible on the C++ standard <code>std::unique_ptr</code> API and copyable_unique_ptr&lt;T&gt; is interoperable with <code>unique_ptr&lt;T&gt;</code> wherever that makes sense. However, there are some differences:</p>
<ol type="1">
<li>It always uses a default deleter.</li>
<li>There is no array version.</li>
<li>To allow for future copy-on-write optimizations, there is a distinction between writable and const access, the <a class="el" href="classdrake_1_1copyable__unique__ptr.html#a76c791981969a90b67778f87036b032e" title="Return a const pointer to the contained object if any, or nullptr.">get()</a> method is modified to return only a const pointer, with <a class="el" href="classdrake_1_1copyable__unique__ptr.html#ac684d04fadf2a6b636c98e38aabf7ccb" title="Return a writable pointer to the contained object if any, or nullptr.">get_mutable()</a> added to return a writable pointer. Furthermore, dereferencing (<a class="el" href="classdrake_1_1copyable__unique__ptr.html#acd9f2ee3a1bcd0468bba24f98905b00f" title="Return a writable reference to the contained object (if T is itself not const).">operator*()</a>) a mutable pointer will give a mutable reference (in so far as T is not declared const), and dereferencing a const pointer will give a const reference.</li>
</ol>
<p>This class is entirely inline and has no computational or space overhead except when copying is required; it contains just a single pointer and does no reference counting.</p>
<p><b>Usage</b></p>
<p>In the simplest use case, the instantiation type will match the type of object it references, e.g.: </p><div class="fragment"><div class="line">copyable_unique_ptr&lt;Foo&gt; ptr = make_unique&lt;Foo&gt;(...);</div></div><!-- fragment --><p> In this case, as long <code>Foo</code> is deemed compatible, the behavior will be as expected, i.e., when <code>ptr</code> copies, it will contain a reference to a new instance of <code>Foo</code>.</p>
<p>copyable_unique_ptr can also be used with polymorphic classes &ndash; a copyable_unique_ptr, instantiated on a <em>base</em> class, references an instance of a <em>derived</em> class. When copying the object, we would want the copy to likewise contain an instance of the derived class. For example:</p>
<div class="fragment"><div class="line">copyable_unique_ptr&lt;Base&gt; cu_ptr = make_unique&lt;Derived&gt;();</div><div class="line">copyable_unique_ptr&lt;Base&gt; other_cu_ptr = cu_ptr;           <span class="comment">// Triggers a copy.</span></div><div class="line">is_dynamic_castable&lt;Derived&gt;(other_cu_ptr.get());          <span class="comment">// Should be true.</span></div></div><!-- fragment --><p>This works for well-designed polymorphic classes.</p>
<dl class="section warning"><dt>Warning</dt><dd>Ill-formed polymorphic classes can lead to fatal type slicing of the referenced object, such that the new copy contains an instance of <code>Base</code> instead of <code>Derived</code>. Some mistakes that would lead to this degenerate behavior:</dd></dl>
<ul>
<li>The <code>Base</code> class's Clone() implementation does not invoke the <code>Derived</code> class's implementation of a suitable virtual method.</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the contained object, which <em>must</em> be copyable as defined above. May be an abstract or concrete type. </td></tr>
  </table>
  </dd>
</dl>
</div>
<p><code>#include &lt;drake/common/copyable_unique_ptr.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors</div></td></tr>
<tr class="memitem:a38cdcb23181ad1c554ef0209a29cd768"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1copyable__unique__ptr.html#a38cdcb23181ad1c554ef0209a29cd768">copyable_unique_ptr</a> () noexcept</td></tr>
<tr class="memdesc:a38cdcb23181ad1c554ef0209a29cd768"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor stores a <code>nullptr</code>.  <a href="#a38cdcb23181ad1c554ef0209a29cd768">More...</a><br /></td></tr>
<tr class="separator:a38cdcb23181ad1c554ef0209a29cd768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfdff602d3fd4c83656a696b984ea7f5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1copyable__unique__ptr.html#acfdff602d3fd4c83656a696b984ea7f5">copyable_unique_ptr</a> (T *raw) noexcept</td></tr>
<tr class="memdesc:acfdff602d3fd4c83656a696b984ea7f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a raw pointer to a writable heap-allocated object, take over ownership of that object.  <a href="#acfdff602d3fd4c83656a696b984ea7f5">More...</a><br /></td></tr>
<tr class="separator:acfdff602d3fd4c83656a696b984ea7f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad454f66aaeaf4bff4953937c55634298"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1copyable__unique__ptr.html#ad454f66aaeaf4bff4953937c55634298">copyable_unique_ptr</a> (const T &amp;value)</td></tr>
<tr class="memdesc:ad454f66aaeaf4bff4953937c55634298"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a unique instance of T as a copy of the provided model value.  <a href="#ad454f66aaeaf4bff4953937c55634298">More...</a><br /></td></tr>
<tr class="separator:ad454f66aaeaf4bff4953937c55634298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9efa09fdc8aad69db06b649c447d9806"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1copyable__unique__ptr.html#a9efa09fdc8aad69db06b649c447d9806">copyable_unique_ptr</a> (const <a class="el" href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a> &amp;cu_ptr)</td></tr>
<tr class="memdesc:a9efa09fdc8aad69db06b649c447d9806"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor is deep; the new copyable_unique_ptr object contains a new copy of the object in the source, created via the source object's copy constructor or <code>Clone()</code> method.  <a href="#a9efa09fdc8aad69db06b649c447d9806">More...</a><br /></td></tr>
<tr class="separator:a9efa09fdc8aad69db06b649c447d9806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1774b97188ce9c5a5cd47c5c4ff63fc0"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a1774b97188ce9c5a5cd47c5c4ff63fc0"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1copyable__unique__ptr.html#a1774b97188ce9c5a5cd47c5c4ff63fc0">copyable_unique_ptr</a> (const std::unique_ptr&lt; U &gt; &amp;u_ptr)</td></tr>
<tr class="memdesc:a1774b97188ce9c5a5cd47c5c4ff63fc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor from a standard <code>unique_ptr</code> of <em>compatible</em> type.  <a href="#a1774b97188ce9c5a5cd47c5c4ff63fc0">More...</a><br /></td></tr>
<tr class="separator:a1774b97188ce9c5a5cd47c5c4ff63fc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac60d2d174b5ce39e94bf59719c997250"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1copyable__unique__ptr.html#ac60d2d174b5ce39e94bf59719c997250">copyable_unique_ptr</a> (<a class="el" href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a> &amp;&amp;cu_ptr) noexcept</td></tr>
<tr class="memdesc:ac60d2d174b5ce39e94bf59719c997250"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor is very fast and leaves the source empty.  <a href="#ac60d2d174b5ce39e94bf59719c997250">More...</a><br /></td></tr>
<tr class="separator:ac60d2d174b5ce39e94bf59719c997250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a34341a71b340b3af3ee3d18e9d09bc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1copyable__unique__ptr.html#a5a34341a71b340b3af3ee3d18e9d09bc">copyable_unique_ptr</a> (std::unique_ptr&lt; T &gt; &amp;&amp;u_ptr) noexcept</td></tr>
<tr class="memdesc:a5a34341a71b340b3af3ee3d18e9d09bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor from a standard <code>unique_ptr</code>.  <a href="#a5a34341a71b340b3af3ee3d18e9d09bc">More...</a><br /></td></tr>
<tr class="separator:a5a34341a71b340b3af3ee3d18e9d09bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0b538a9c4ca822d4212226ba51dc0aa"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:ad0b538a9c4ca822d4212226ba51dc0aa"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1copyable__unique__ptr.html#ad0b538a9c4ca822d4212226ba51dc0aa">copyable_unique_ptr</a> (std::unique_ptr&lt; U &gt; &amp;&amp;u_ptr) noexcept</td></tr>
<tr class="memdesc:ad0b538a9c4ca822d4212226ba51dc0aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move construction from a compatible standard <code>unique_ptr</code>.  <a href="#ad0b538a9c4ca822d4212226ba51dc0aa">More...</a><br /></td></tr>
<tr class="separator:ad0b538a9c4ca822d4212226ba51dc0aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Assignment</div></td></tr>
<tr class="memitem:ae817c604dc8ec423c4c58620ee6f8fe2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1copyable__unique__ptr.html#ae817c604dc8ec423c4c58620ee6f8fe2">operator=</a> (T *raw) noexcept</td></tr>
<tr class="memdesc:ae817c604dc8ec423c4c58620ee6f8fe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This form of assignment replaces the currently-held object by the given source object and takes over ownership of the source object.  <a href="#ae817c604dc8ec423c4c58620ee6f8fe2">More...</a><br /></td></tr>
<tr class="separator:ae817c604dc8ec423c4c58620ee6f8fe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d4078720893b915d022bd734f6eb5e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1copyable__unique__ptr.html#a4d4078720893b915d022bd734f6eb5e9">operator=</a> (const T &amp;ref)</td></tr>
<tr class="memdesc:a4d4078720893b915d022bd734f6eb5e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This form of assignment replaces the currently-held object by a heap-allocated copy of the source object, created using its copy constructor or <code>Clone()</code> method.  <a href="#a4d4078720893b915d022bd734f6eb5e9">More...</a><br /></td></tr>
<tr class="separator:a4d4078720893b915d022bd734f6eb5e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35881f6551d81d4ba11f23bdc695dbf5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1copyable__unique__ptr.html#a35881f6551d81d4ba11f23bdc695dbf5">operator=</a> (const <a class="el" href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a> &amp;cu_ptr)</td></tr>
<tr class="memdesc:a35881f6551d81d4ba11f23bdc695dbf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment from copyable_unique_ptr replaces the currently-held object by a copy of the object held in the source container, created using the source object's copy constructor or <code>Clone()</code> method.  <a href="#a35881f6551d81d4ba11f23bdc695dbf5">More...</a><br /></td></tr>
<tr class="separator:a35881f6551d81d4ba11f23bdc695dbf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d014005bde7838a248d7129023b999c"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a5d014005bde7838a248d7129023b999c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1copyable__unique__ptr.html#a5d014005bde7838a248d7129023b999c">operator=</a> (const <a class="el" href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a>&lt; U &gt; &amp;cu_ptr)</td></tr>
<tr class="memdesc:a5d014005bde7838a248d7129023b999c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment from a compatible copyable_unique_ptr replaces the currently-held object by a copy of the object held in the source container, created using the source object's copy constructor or <code>Clone()</code> method.  <a href="#a5d014005bde7838a248d7129023b999c">More...</a><br /></td></tr>
<tr class="separator:a5d014005bde7838a248d7129023b999c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a241aa7fdb2e242c6965006831d9e62dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1copyable__unique__ptr.html#a241aa7fdb2e242c6965006831d9e62dd">operator=</a> (const std::unique_ptr&lt; T &gt; &amp;src)</td></tr>
<tr class="memdesc:a241aa7fdb2e242c6965006831d9e62dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment from a standard <code>unique_ptr</code> replaces the currently-held object by a copy of the object held in the source container, created using the source object's copy constructor or <code>Clone()</code> method.  <a href="#a241aa7fdb2e242c6965006831d9e62dd">More...</a><br /></td></tr>
<tr class="separator:a241aa7fdb2e242c6965006831d9e62dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67bca368e89b4408972a3f54c09eaab3"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a67bca368e89b4408972a3f54c09eaab3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1copyable__unique__ptr.html#a67bca368e89b4408972a3f54c09eaab3">operator=</a> (const std::unique_ptr&lt; U &gt; &amp;u_ptr)</td></tr>
<tr class="memdesc:a67bca368e89b4408972a3f54c09eaab3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment from a compatible standard <code>unique_ptr</code> replaces the currently-held object by a copy of the object held in the source container, created using the source object's copy constructor or <code>Clone()</code> method.  <a href="#a67bca368e89b4408972a3f54c09eaab3">More...</a><br /></td></tr>
<tr class="separator:a67bca368e89b4408972a3f54c09eaab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2693139bff4ad445212aa4bb73284ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1copyable__unique__ptr.html#af2693139bff4ad445212aa4bb73284ad">operator=</a> (<a class="el" href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a> &amp;&amp;cu_ptr) noexcept</td></tr>
<tr class="memdesc:af2693139bff4ad445212aa4bb73284ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment replaces the currently-held object by the source object, leaving the source empty.  <a href="#af2693139bff4ad445212aa4bb73284ad">More...</a><br /></td></tr>
<tr class="separator:af2693139bff4ad445212aa4bb73284ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60fa4971dcefe82f931084653b196a55"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a60fa4971dcefe82f931084653b196a55"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1copyable__unique__ptr.html#a60fa4971dcefe82f931084653b196a55">operator=</a> (<a class="el" href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a>&lt; U &gt; &amp;&amp;cu_ptr) noexcept</td></tr>
<tr class="memdesc:a60fa4971dcefe82f931084653b196a55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment replaces the currently-held object by the compatible source object, leaving the source empty.  <a href="#a60fa4971dcefe82f931084653b196a55">More...</a><br /></td></tr>
<tr class="separator:a60fa4971dcefe82f931084653b196a55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53f1739bcedb13183285a9995d3b9daf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1copyable__unique__ptr.html#a53f1739bcedb13183285a9995d3b9daf">operator=</a> (std::unique_ptr&lt; T &gt; &amp;&amp;u_ptr) noexcept</td></tr>
<tr class="memdesc:a53f1739bcedb13183285a9995d3b9daf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment replaces the currently-held object by the source object, leaving the source empty.  <a href="#a53f1739bcedb13183285a9995d3b9daf">More...</a><br /></td></tr>
<tr class="separator:a53f1739bcedb13183285a9995d3b9daf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf98f86aa60c05f0a546ca78c2a2e857"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:abf98f86aa60c05f0a546ca78c2a2e857"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1copyable__unique__ptr.html#abf98f86aa60c05f0a546ca78c2a2e857">operator=</a> (std::unique_ptr&lt; U &gt; &amp;&amp;u_ptr) noexcept</td></tr>
<tr class="memdesc:abf98f86aa60c05f0a546ca78c2a2e857"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment replaces the currently-held object by the compatible source object, leaving the source empty.  <a href="#abf98f86aa60c05f0a546ca78c2a2e857">More...</a><br /></td></tr>
<tr class="separator:abf98f86aa60c05f0a546ca78c2a2e857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Observers</div></td></tr>
<tr class="memitem:a3f6fc5de06a318920d84f3c3742db07f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1copyable__unique__ptr.html#a3f6fc5de06a318920d84f3c3742db07f">empty</a> () const noexcept</td></tr>
<tr class="memdesc:a3f6fc5de06a318920d84f3c3742db07f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this container is empty, which is the state the container is in immediately after default construction and various other operations.  <a href="#a3f6fc5de06a318920d84f3c3742db07f">More...</a><br /></td></tr>
<tr class="separator:a3f6fc5de06a318920d84f3c3742db07f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76c791981969a90b67778f87036b032e"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1copyable__unique__ptr.html#a76c791981969a90b67778f87036b032e">get</a> () const noexcept</td></tr>
<tr class="memdesc:a76c791981969a90b67778f87036b032e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const pointer to the contained object if any, or <code>nullptr</code>.  <a href="#a76c791981969a90b67778f87036b032e">More...</a><br /></td></tr>
<tr class="separator:a76c791981969a90b67778f87036b032e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac684d04fadf2a6b636c98e38aabf7ccb"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1copyable__unique__ptr.html#ac684d04fadf2a6b636c98e38aabf7ccb">get_mutable</a> () noexcept</td></tr>
<tr class="memdesc:ac684d04fadf2a6b636c98e38aabf7ccb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a writable pointer to the contained object if any, or <code>nullptr</code>.  <a href="#ac684d04fadf2a6b636c98e38aabf7ccb">More...</a><br /></td></tr>
<tr class="separator:ac684d04fadf2a6b636c98e38aabf7ccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdbce0832fe3d1de72e719f60db3a9aa"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1copyable__unique__ptr.html#acdbce0832fe3d1de72e719f60db3a9aa">operator *</a> () const</td></tr>
<tr class="memdesc:acdbce0832fe3d1de72e719f60db3a9aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const reference to the contained object.  <a href="#acdbce0832fe3d1de72e719f60db3a9aa">More...</a><br /></td></tr>
<tr class="separator:acdbce0832fe3d1de72e719f60db3a9aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd9f2ee3a1bcd0468bba24f98905b00f"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1copyable__unique__ptr.html#acd9f2ee3a1bcd0468bba24f98905b00f">operator *</a> ()</td></tr>
<tr class="memdesc:acd9f2ee3a1bcd0468bba24f98905b00f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a writable reference to the contained object (if T is itself not const).  <a href="#acd9f2ee3a1bcd0468bba24f98905b00f">More...</a><br /></td></tr>
<tr class="separator:acd9f2ee3a1bcd0468bba24f98905b00f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:ab5373c9f8caa95d0cdf8d4b7d1066cb3"><td class="memTemplParams" colspan="2">template&lt;class charT , class traits , class T &gt; </td></tr>
<tr class="memitem:ab5373c9f8caa95d0cdf8d4b7d1066cb3"><td class="memTemplItemLeft" align="right" valign="top">std::basic_ostream&lt; charT, traits &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1copyable__unique__ptr.html#ab5373c9f8caa95d0cdf8d4b7d1066cb3">operator&lt;&lt;</a> (std::basic_ostream&lt; charT, traits &gt; &amp;os, const <a class="el" href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a>&lt; T &gt; &amp;cu_ptr)</td></tr>
<tr class="memdesc:ab5373c9f8caa95d0cdf8d4b7d1066cb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output the system-dependent representation of the pointer contained in a <a class="el" href="classdrake_1_1copyable__unique__ptr.html" title="A smart pointer with deep copy semantics.">copyable_unique_ptr</a> object.  <a href="#ab5373c9f8caa95d0cdf8d4b7d1066cb3">More...</a><br /></td></tr>
<tr class="separator:ab5373c9f8caa95d0cdf8d4b7d1066cb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a38cdcb23181ad1c554ef0209a29cd768"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38cdcb23181ad1c554ef0209a29cd768">&#9670;&nbsp;</a></span>copyable_unique_ptr() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor stores a <code>nullptr</code>. </p>
<p>No heap allocation is performed. The <a class="el" href="classdrake_1_1copyable__unique__ptr.html#a3f6fc5de06a318920d84f3c3742db07f" title="Return true if this container is empty, which is the state the container is in immediately after defa...">empty()</a> method will return true when called on a default-constructed copyable_unique_ptr. </p>

</div>
</div>
<a id="acfdff602d3fd4c83656a696b984ea7f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfdff602d3fd4c83656a696b984ea7f5">&#9670;&nbsp;</a></span>copyable_unique_ptr() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a> </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>raw</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a raw pointer to a writable heap-allocated object, take over ownership of that object. </p>
<p>No copying occurs. </p>

</div>
</div>
<a id="ad454f66aaeaf4bff4953937c55634298"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad454f66aaeaf4bff4953937c55634298">&#9670;&nbsp;</a></span>copyable_unique_ptr() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a> </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a unique instance of T as a copy of the provided model value. </p>

</div>
</div>
<a id="a9efa09fdc8aad69db06b649c447d9806"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9efa09fdc8aad69db06b649c447d9806">&#9670;&nbsp;</a></span>copyable_unique_ptr() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>cu_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor is deep; the new copyable_unique_ptr object contains a new copy of the object in the source, created via the source object's copy constructor or <code>Clone()</code> method. </p>
<p>If the source container is empty this one will be empty also. </p>

</div>
</div>
<a id="a1774b97188ce9c5a5cd47c5c4ff63fc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1774b97188ce9c5a5cd47c5c4ff63fc0">&#9670;&nbsp;</a></span>copyable_unique_ptr() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a> </td>
          <td>(</td>
          <td class="paramtype">const std::unique_ptr&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>u_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor from a standard <code>unique_ptr</code> of <em>compatible</em> type. </p>
<p>The copy is deep; the new copyable_unique_ptr object contains a new copy of the object in the source, created via the source object's copy constructor or <code>Clone()</code> method. If the source container is empty this one will be empty also. </p>

</div>
</div>
<a id="ac60d2d174b5ce39e94bf59719c997250"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac60d2d174b5ce39e94bf59719c997250">&#9670;&nbsp;</a></span>copyable_unique_ptr() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>cu_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor is very fast and leaves the source empty. </p>
<p>Ownership is transferred from the source to the new copyable_unique_ptr. If the source was empty this one will be empty also. No heap activity occurs. </p>

</div>
</div>
<a id="a5a34341a71b340b3af3ee3d18e9d09bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a34341a71b340b3af3ee3d18e9d09bc">&#9670;&nbsp;</a></span>copyable_unique_ptr() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a> </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>u_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor from a standard <code>unique_ptr</code>. </p>
<p>The move is very fast and leaves the source empty. Ownership is transferred from the source to the new copyable_unique_ptr. If the source was empty this one will be empty also. No heap activity occurs. </p>

</div>
</div>
<a id="ad0b538a9c4ca822d4212226ba51dc0aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0b538a9c4ca822d4212226ba51dc0aa">&#9670;&nbsp;</a></span>copyable_unique_ptr() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a> </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; U &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>u_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move construction from a compatible standard <code>unique_ptr</code>. </p>
<p>Type <code>U*</code> must be implicitly convertible to type <code>T*</code>. Ownership is transferred from the source to the new copyable_unique_ptr. If the source was empty this one will be empty also. No heap activity occurs. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3f6fc5de06a318920d84f3c3742db07f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f6fc5de06a318920d84f3c3742db07f">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if this container is empty, which is the state the container is in immediately after default construction and various other operations. </p>

</div>
</div>
<a id="a76c791981969a90b67778f87036b032e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76c791981969a90b67778f87036b032e">&#9670;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const pointer to the contained object if any, or <code>nullptr</code>. </p>
<p>Note that this is different than <code>get()</code> for the standard smart pointers like <code>std::unique_ptr</code> which return a writable pointer. Use <a class="el" href="classdrake_1_1copyable__unique__ptr.html#ac684d04fadf2a6b636c98e38aabf7ccb" title="Return a writable pointer to the contained object if any, or nullptr.">get_mutable()</a> here for that purpose. </p>

</div>
</div>
<a id="ac684d04fadf2a6b636c98e38aabf7ccb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac684d04fadf2a6b636c98e38aabf7ccb">&#9670;&nbsp;</a></span>get_mutable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* get_mutable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a writable pointer to the contained object if any, or <code>nullptr</code>. </p>
<p>Note that you need write access to this container in order to get write access to the object it contains.</p>
<dl class="section warning"><dt>Warning</dt><dd>If copyable_unique_ptr is instantiated on a const template parameter (e.g., <code><a class="el" href="classdrake_1_1copyable__unique__ptr.html" title="A smart pointer with deep copy semantics.">copyable_unique_ptr</a>&lt;const Foo&gt;</code>), then <a class="el" href="classdrake_1_1copyable__unique__ptr.html#ac684d04fadf2a6b636c98e38aabf7ccb" title="Return a writable pointer to the contained object if any, or nullptr.">get_mutable()</a> returns a const pointer. </dd></dl>

</div>
</div>
<a id="acdbce0832fe3d1de72e719f60db3a9aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdbce0832fe3d1de72e719f60db3a9aa">&#9670;&nbsp;</a></span>operator *() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; operator * </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a const reference to the contained object. </p>
<p>Note that this is different from <code><a class="el" href="namespacedrake_1_1ad.html#ae521245b6aec25f233036d952061fb5b" title="Standard multiplication operator.">std::unique_ptr::operator*()</a></code> which would return a non-const reference (if <code>T</code> is non-const), even if the container itself is const. For a const copyable_unique_ptr will always return a const reference to its contained value.</p>
<dl class="section warning"><dt>Warning</dt><dd>Currently copyable_unique_ptr is a std::unique_ptr. As such, a const copyable_unique_ptr&lt;Foo&gt; can be upcast to a const unique_ptr&lt;Foo&gt; and the parent's behavior will provide a mutable reference. This is strongly discouraged and will break as the implementation of this class changes to shore up this gap in the const correctness protection.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>this != nullptr</code> reports <code>true</code>. </dd></dl>

</div>
</div>
<a id="acd9f2ee3a1bcd0468bba24f98905b00f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd9f2ee3a1bcd0468bba24f98905b00f">&#9670;&nbsp;</a></span>operator *() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; operator * </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a writable reference to the contained object (if T is itself not const). </p>
<p>Note that you need write access to this container in order to get write access to the object it contains.</p>
<p>We <em>strongly</em> recommend, that, if dereferencing a copyable_unique_ptr without the intention of mutating the underlying value, prefer to dereference a <em>const</em> copyable_unique_ptr (or use *my_ptr.<a class="el" href="classdrake_1_1copyable__unique__ptr.html#a76c791981969a90b67778f87036b032e" title="Return a const pointer to the contained object if any, or nullptr.">get()</a>) and not a mutable copyable_unique_ptr. As "copy-on-write" behavior is introduced in the future, this recommended practice will prevent unwanted copies of the underlying value.</p>
<p>If copyable_unique_ptr is instantiated on a const template parameter (e.g., <code><a class="el" href="classdrake_1_1copyable__unique__ptr.html" title="A smart pointer with deep copy semantics.">copyable_unique_ptr</a>&lt;const Foo&gt;</code>), then <a class="el" href="classdrake_1_1copyable__unique__ptr.html#acd9f2ee3a1bcd0468bba24f98905b00f" title="Return a writable reference to the contained object (if T is itself not const).">operator*()</a> must return a const reference.</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>this != nullptr</code> reports <code>true</code>. </dd></dl>

</div>
</div>
<a id="ae817c604dc8ec423c4c58620ee6f8fe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae817c604dc8ec423c4c58620ee6f8fe2">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>raw</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This form of assignment replaces the currently-held object by the given source object and takes over ownership of the source object. </p>
<p>The currently-held object (if any) is deleted. </p>

</div>
</div>
<a id="a4d4078720893b915d022bd734f6eb5e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d4078720893b915d022bd734f6eb5e9">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>ref</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This form of assignment replaces the currently-held object by a heap-allocated copy of the source object, created using its copy constructor or <code>Clone()</code> method. </p>
<p>The currently-held object (if any) is deleted. </p>

</div>
</div>
<a id="a35881f6551d81d4ba11f23bdc695dbf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35881f6551d81d4ba11f23bdc695dbf5">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>cu_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy assignment from copyable_unique_ptr replaces the currently-held object by a copy of the object held in the source container, created using the source object's copy constructor or <code>Clone()</code> method. </p>
<p>The currently-held object (if any) is deleted. If the source container is empty this one will be empty also after the assignment. Nothing happens if the source and destination are the same container. </p>

</div>
</div>
<a id="a5d014005bde7838a248d7129023b999c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d014005bde7838a248d7129023b999c">&#9670;&nbsp;</a></span>operator=() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>cu_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy assignment from a compatible copyable_unique_ptr replaces the currently-held object by a copy of the object held in the source container, created using the source object's copy constructor or <code>Clone()</code> method. </p>
<p>The currently-held object (if any) is deleted. If the source container is empty this one will be empty also after the assignment. Nothing happens if the source and destination are the same container. </p>

</div>
</div>
<a id="a241aa7fdb2e242c6965006831d9e62dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a241aa7fdb2e242c6965006831d9e62dd">&#9670;&nbsp;</a></span>operator=() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const std::unique_ptr&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy assignment from a standard <code>unique_ptr</code> replaces the currently-held object by a copy of the object held in the source container, created using the source object's copy constructor or <code>Clone()</code> method. </p>
<p>The currently-held object (if any) is deleted. If the source container is empty this one will be empty also after the assignment. Nothing happens if the source and destination are the same container. </p>

</div>
</div>
<a id="a67bca368e89b4408972a3f54c09eaab3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67bca368e89b4408972a3f54c09eaab3">&#9670;&nbsp;</a></span>operator=() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const std::unique_ptr&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>u_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy assignment from a compatible standard <code>unique_ptr</code> replaces the currently-held object by a copy of the object held in the source container, created using the source object's copy constructor or <code>Clone()</code> method. </p>
<p>The currently-held object (if any) is deleted. If the source container is empty this one will be empty also after the assignment. Nothing happens if the source and destination are the same container. </p>

</div>
</div>
<a id="af2693139bff4ad445212aa4bb73284ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2693139bff4ad445212aa4bb73284ad">&#9670;&nbsp;</a></span>operator=() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>cu_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment replaces the currently-held object by the source object, leaving the source empty. </p>
<p>The currently-held object (if any) is deleted. The instance is <em>not</em> copied. Nothing happens if the source and destination are the same containers. </p>

</div>
</div>
<a id="a60fa4971dcefe82f931084653b196a55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60fa4971dcefe82f931084653b196a55">&#9670;&nbsp;</a></span>operator=() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a>&lt; U &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>cu_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment replaces the currently-held object by the compatible source object, leaving the source empty. </p>
<p>The currently-held object (if any) is deleted. The instance is <em>not</em> copied. Nothing happens if the source and destination are the same containers. </p>

</div>
</div>
<a id="a53f1739bcedb13183285a9995d3b9daf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53f1739bcedb13183285a9995d3b9daf">&#9670;&nbsp;</a></span>operator=() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>u_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment replaces the currently-held object by the source object, leaving the source empty. </p>
<p>The currently-held object (if any) is deleted. The instance is <em>not</em> copied. Nothing happens if the source and destination are the same containers. </p>

</div>
</div>
<a id="abf98f86aa60c05f0a546ca78c2a2e857"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf98f86aa60c05f0a546ca78c2a2e857">&#9670;&nbsp;</a></span>operator=() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; U &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>u_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment replaces the currently-held object by the compatible source object, leaving the source empty. </p>
<p>The currently-held object (if any) is deleted. The instance is <em>not</em> copied. Nothing happens if the source and destination are the same containers. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="ab5373c9f8caa95d0cdf8d4b7d1066cb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5373c9f8caa95d0cdf8d4b7d1066cb3">&#9670;&nbsp;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::basic_ostream&lt; charT, traits &gt; &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::basic_ostream&lt; charT, traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>cu_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Output the system-dependent representation of the pointer contained in a <a class="el" href="classdrake_1_1copyable__unique__ptr.html" title="A smart pointer with deep copy semantics.">copyable_unique_ptr</a> object. </p>
<p>This is equivalent to <code>os &lt;&lt; p.get();</code>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>drake/common/<a class="el" href="copyable__unique__ptr_8h.html">copyable_unique_ptr.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- footer -->
<div id="nav-path" class="navpath">
  <ul>
    <li class="navelem"><a class="el" href="namespacedrake.html">drake</a></li><li class="navelem"><a class="el" href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a></li>
  </ul>
</div>
<footer class="site-footer padding">
  <div class="contain">
    <a href="/" class="drake-logo">
      <img src="/images/drake-logo.svg"/>
    </a>
    <div class="footer-menu">
      <ul>    
        <li>
          <a href="/doxygen_cxx/index.html" class="site-menu-item">C++</a>
        </li>    
        <li>
          <a href="/pydrake/index.html" class="site-menu-item">Python</a>
        </li>
        <li class="github-link">
          <a href="https://github.com/RobotLocomotion/drake" class="site-menu-item">GitHub <img src="/third_party/images/GitHub-Mark-64px.png"/></a>
        </li>
      </ul>
    </div>
  </div>
</footer>
<script type="text/javascript">
searchBox.searchLabel = 'Go to name…';
searchBox.DOMSearchField().value = searchBox.searchLabel;
</script>
</body>
</html>
