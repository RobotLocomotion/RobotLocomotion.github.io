<!-- HTML header for doxygen 1.15.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: PiecewisePolynomial&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(function() { init_search(); });
</script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@4/tex-chtml.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<header class="site-header">
 <div class="site-header-inner contain">
  <a class="drake-logo" href="/"><img src="/images/drake-logo-white.svg"></a>
  <div class="menu-mobile-toggle">
   <span></span>
  </div>
  <nav class="site-menu">
   <ul>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/">Home</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/installation.html">Installation</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/gallery.html">Gallery</a>
    </li>
    <li class="site-menu-item site-menu-item-main">API Documentation
     <div class="sub">
      <a class="site-menu-item" href="/doxygen_cxx/index.html">C++</a>
      <a class="site-menu-item" href="/pydrake/index.html">Python</a>
     </div>
    </li>
    <li class="site-menu-item site-menu-item-main">Resources
     <div class="sub">
      <a class="site-menu-item" href="/getting_help.html">Getting Help</a>
      <a class="site-menu-item" href="https://deepnote.com/workspace/Drake-0b3b2c53-a7ad-441b-80f8-bf8350752305/project/Tutorials-2b4fc509-aef2-417d-a40d-6071dfed9199/notebook/index-753e3c9d261247ba9f0eb1d7868c18c8">Tutorials</a>
      <a class="site-menu-item" href="/python_bindings.html">Python Bindings</a>
      <a class="site-menu-item" href="/developers.html">For Developers</a>
      <a class="site-menu-item" href="/credits.html">Credits</a>
     </div>
    </li>
    <li class="github-link">
     <a class="site-menu-item" href="https://github.com/RobotLocomotion/drake">GitHub <img src="/third_party/images/GitHub-Mark-Light-64px.png"></a>
    </li>
   </ul>
  </nav>
 </div>
</header>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<div class="title-banner">
 <div class="title-banner__title">
  Drake C++ Documentation
 </div>
 <div id="DDGSearch">
  <form id="search_form_cpp" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search C++ API only…">
   <input type="hidden" name="q" value="site:drake.mit.edu/doxygen_cxx">
  </form>
  <form id="search_form" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search all of Drake…">
   <input type="hidden" name="q" value="site:drake.mit.edu OR site:underactuated.csail.mit.edu OR site:manipulation.csail.mit.edu">
  </form>
 </div>
 <div id="MSearchBoxContainer">
  <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect" class="search-icon" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"><span class="search-icon-dropdown"></span></span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><div id="MSearchCloseImg" class="close-icon"></div></a>
          </span>
        </div>
</td>
 </div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('classdrake_1_1multibody_1_1_piecewise_polynomial.html','','classdrake_1_1multibody_1_1_piecewise_polynomial-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">PiecewisePolynomial&lt; T &gt; Class Template Reference<span class="mlabels"><span class="mlabel final">final</span></span></div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename T&gt;<br />
class drake::multibody::PiecewisePolynomial&lt; T &gt;</div><p>A scalar multi-variate piecewise polynomial. </p>
<p>PiecewisePolynomial represents a list of contiguous segments in a scalar independent variable (typically corresponding to time) with Polynomials defined at each segment. We call the output from evaluating the PiecewisePolynomial at the scalar independent variable "the output", and that output can be either a Eigen <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95" title="A matrix of dynamic size, templated on scalar type.">MatrixX&lt;T&gt;</a> (if evaluated using <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a13176bef855d6085bd2395da6855886f" title="Evaluates the PiecewisePolynomial at the given time t.">value()</a>) or a scalar (if evaluated using scalar_value()).</p>
<p>An example of a piecewise polynomial is a function of m segments in time, where a different polynomial is defined for each segment. For a specific example, consider the absolute value function over the interval [-1, 1]. We can define a PiecewisePolynomial over this interval using breaks at t = { -1.0, 0.0, 1.0 }, and "samples" of abs(t).</p>
<div class="fragment"><div class="line"><span class="comment">// Construct the PiecewisePolynomial.</span></div>
<div class="line"><span class="keyword">const</span> std::vector&lt;double&gt; <a class="code hl_function" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a4e258af58745532546142965cd4444c7">breaks</a> = { -1.0, 0.0, 1.0 };</div>
<div class="line">std::vector&lt;Eigen::MatrixXd&gt; samples(3);</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; static_cast&lt;int&gt;(<a class="code hl_function" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a4e258af58745532546142965cd4444c7">breaks</a>.size()); ++i) {</div>
<div class="line">  samples[i].resize(1, 1);</div>
<div class="line">  samples[i](0, 0) = std::abs(<a class="code hl_function" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a4e258af58745532546142965cd4444c7">breaks</a>[i]);</div>
<div class="line">}</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> pp =</div>
<div class="line">     <a class="code hl_function" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#acd2146d6af5a8c5211df9c3f66d1984b">PiecewisePolynomial&lt;double&gt;::FirstOrderHold</a>(<a class="code hl_function" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a4e258af58745532546142965cd4444c7">breaks</a>, samples);</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> row = 0, col = 0;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Evaluate the PiecewisePolynomial at some values.</span></div>
<div class="line">std::cout &lt;&lt; pp.value(-.5)(row, col) &lt;&lt; std::endl;    <span class="comment">// Outputs 0.5.</span></div>
<div class="line">std::cout &lt;&lt; pp.value(0.0)(row, col) &lt;&lt; std::endl;    <span class="comment">// Outputs 0.0;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Show how we can evaluate the first derivative (outputs -1.0).</span></div>
<div class="line">std::cout &lt;&lt; pp.derivative(1).value(-.5)(row, col) &lt;&lt; std::endl;</div>
<div class="ttc" id="aclassdrake_1_1trajectories_1_1_piecewise_polynomial_html_acd2146d6af5a8c5211df9c3f66d1984b"><div class="ttname"><a href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#acd2146d6af5a8c5211df9c3f66d1984b">drake::trajectories::PiecewisePolynomial::FirstOrderHold</a></div><div class="ttdeci">static PiecewisePolynomial&lt; T &gt; FirstOrderHold(const std::vector&lt; T &gt; &amp;breaks, const std::vector&lt; MatrixX&lt; T &gt; &gt; &amp;samples)</div><div class="ttdoc">Constructs a piecewise linear PiecewisePolynomial using matrix samples.</div></div>
<div class="ttc" id="aclassdrake_1_1trajectories_1_1_piecewise_trajectory_html_a4e258af58745532546142965cd4444c7"><div class="ttname"><a href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a4e258af58745532546142965cd4444c7">drake::trajectories::PiecewiseTrajectory::breaks</a></div><div class="ttdeci">const std::vector&lt; T &gt; &amp; breaks() const</div><div class="ttdef"><b>Definition</b> piecewise_trajectory.h:69</div></div>
</div><!-- fragment --><p>A note on terminology. For piecewise-polynomial interpolation, we use <span class="tt"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a4e258af58745532546142965cd4444c7">breaks</a></span> to indicate the scalar (e.g. times) which form the boundary of each segment. We use <span class="tt">samples</span> to indicate the function value at the <span class="tt"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a4e258af58745532546142965cd4444c7">breaks</a></span>, e.g. <span class="tt">p(breaks[i]) = samples[i]</span>. The term <span class="tt">knot</span> should be reserved for the "(x,y)" coordinate, here <span class="tt">knot[i] = (<a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a4e258af58745532546142965cd4444c7">breaks</a>[i], samples[i])</span>, though it is used inconsistently in the interpolation literature (sometimes for <span class="tt"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a4e258af58745532546142965cd4444c7">breaks</a></span>, sometimes for <span class="tt">samples</span>), so we try to mostly avoid it here.</p>
<p><a class="el" href="classdrake_1_1multibody_1_1_piecewise_polynomial.html" title="A scalar multi-variate piecewise polynomial.">PiecewisePolynomial</a> objects can be added, subtracted, and multiplied. They cannot be divided because Polynomials are not closed under division.</p>
<dl class="section warning"><dt>Warning</dt><dd>PiecewisePolynomial silently clips input evaluations outside of the range defined by the breaks. So <span class="tt">pp.value(-2.0, row, col)</span> in the example above would evaluate to -1.0. See <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a13176bef855d6085bd2395da6855886f" title="Evaluates the PiecewisePolynomial at the given time t.">value()</a>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The scalar type, which must be one of the <a class="el" href="group__default__scalars.html">default scalars</a>. </td></tr>
  </table>
  </dd>
</dl>
</div>
<p><code>#include &lt;drake/common/trajectories/piecewise_polynomial.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-types" class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a9c5cbf1ba95055937fdb8283769df797" id="r_a9c5cbf1ba95055937fdb8283769df797"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9c5cbf1ba95055937fdb8283769df797">PolynomialMatrix</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6a44781cbe3dd6c55234638a1b63d4ef" id="r_a6a44781cbe3dd6c55234638a1b63d4ef"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6a44781cbe3dd6c55234638a1b63d4ef">PiecewisePolynomial</a> ()=default</td></tr>
<tr class="memdesc:a6a44781cbe3dd6c55234638a1b63d4ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an empty piecewise polynomial.  <br /></td></tr>
<tr class="memitem:a838cb1725eb9ba7896158fa9032ecdcc" id="r_a838cb1725eb9ba7896158fa9032ecdcc"><td class="memTemplParams" colspan="2">template&lt;typename Derived&gt; </td></tr>
<tr class="memitem:a838cb1725eb9ba7896158fa9032ecdcc template"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a838cb1725eb9ba7896158fa9032ecdcc">PiecewisePolynomial</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;constant_value)</td></tr>
<tr class="memdesc:a838cb1725eb9ba7896158fa9032ecdcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single segment, constant value constructor over the interval [-∞, ∞].  <br /></td></tr>
<tr id="pub-methods-0" class="groupHeader"><td colspan="2"><div class="groupHeader">Implements CopyConstructible, CopyAssignable, MoveConstructible, MoveAssignable</div></td></tr>
<tr class="memitem:acd5823d88e611200dc63daaf05eeb9d9" id="r_acd5823d88e611200dc63daaf05eeb9d9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acd5823d88e611200dc63daaf05eeb9d9">PiecewisePolynomial</a> (const PiecewisePolynomial &amp;)=default</td></tr>
<tr class="memitem:a8c9575eec7fd062e42ed17407a337abc" id="r_a8c9575eec7fd062e42ed17407a337abc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8c9575eec7fd062e42ed17407a337abc">PiecewisePolynomial</a> (PiecewisePolynomial &amp;&amp;)=default</td></tr>
<tr class="memitem:a74f448d9a26234f9c8304a182b61da63" id="r_a74f448d9a26234f9c8304a182b61da63"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a6a44781cbe3dd6c55234638a1b63d4ef">PiecewisePolynomial</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a74f448d9a26234f9c8304a182b61da63">operator=</a> (const <a class="el" href="#a6a44781cbe3dd6c55234638a1b63d4ef">PiecewisePolynomial</a> &amp;)=default</td></tr>
<tr class="memitem:a52448559a01daac33f78c61cc4a148a8" id="r_a52448559a01daac33f78c61cc4a148a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a6a44781cbe3dd6c55234638a1b63d4ef">PiecewisePolynomial</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a52448559a01daac33f78c61cc4a148a8">operator=</a> (<a class="el" href="#a6a44781cbe3dd6c55234638a1b63d4ef">PiecewisePolynomial</a> &amp;&amp;)=default</td></tr>
<tr id="pub-methods-1" class="groupHeader"><td colspan="2"><div class="groupHeader">Polynomial-based construction methods.</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p><a class="anchor" id="polynomial_construction_methods"></a> Various methods for constructing a PiecewisePolynomial using vectors of matrices of polynomials, one for each output dimension.</p>
<p>Unlike the coefficient-based methods, the number of polynomials must equal the number of segments, which will be one fewer than the number of breaks.</p>
<p>The following shows how such a PiecewisePolynomial might be constructed and used: </p><div class="fragment"><div class="line"><span class="comment">// Construct the PiecewisePolynomial.</span></div>
<div class="line"><span class="keyword">const</span> std::vector&lt;double&gt; <a class="code hl_function" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a4e258af58745532546142965cd4444c7">breaks</a> = { -1.0, 0.0, 1.0 };</div>
<div class="line"><a class="code hl_typedef" href="namespacedrake.html#ab0a2621977171e1d2d5b64c55141b9b2">Polynomiald</a> t(<span class="stringliteral">&quot;t&quot;</span>);</div>
<div class="line">std::vector&lt;Polynomiald&gt; polynomials = { -(t*t), (t*t) };</div>
<div class="line"><span class="keyword">const</span> PiecewisePolynomial&lt;double&gt; pp(polynomials, <a class="code hl_function" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a4e258af58745532546142965cd4444c7">breaks</a>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Evaluate the PiecewisePolynomial at some values.</span></div>
<div class="line">std::cout &lt;&lt; pp.scalar_value(-1.0) &lt;&lt; std::endl;    <span class="comment">// Outputs -1.0</span></div>
<div class="line">std::cout &lt;&lt; pp.scalar_value(1.0) &lt;&lt; std::endl;     <span class="comment">// Outputs 1.0</span></div>
<div class="ttc" id="anamespacedrake_html_ab0a2621977171e1d2d5b64c55141b9b2"><div class="ttname"><a href="namespacedrake.html#ab0a2621977171e1d2d5b64c55141b9b2">drake::Polynomiald</a></div><div class="ttdeci">Polynomial&lt; double &gt; Polynomiald</div><div class="ttdef"><b>Definition</b> polynomial.h:507</div></div>
</div><!-- fragment --><p><a class="anchor" id="polynomial_warning"></a><b>WARNING:</b> For robust floating point arithmetic, the polynomial for a segment will be evaluated (using <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a13176bef855d6085bd2395da6855886f" title="Evaluates the PiecewisePolynomial at the given time t.">value()</a>) by first subtracting the break time from the evaluation time. In other words, when t lies in the half-open interval <span class="tt">[<a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a4e258af58745532546142965cd4444c7">breaks</a>[i], <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a4e258af58745532546142965cd4444c7">breaks</a>[i+1])</span> then: </p><div class="fragment"><div class="line"><a class="code hl_function" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a13176bef855d6085bd2395da6855886f">value</a>(t) == polynomials[i].eval(t - <a class="code hl_function" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a4e258af58745532546142965cd4444c7">breaks</a>[i])</div>
<div class="ttc" id="aclassdrake_1_1trajectories_1_1_piecewise_polynomial_html_a13176bef855d6085bd2395da6855886f"><div class="ttname"><a href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a13176bef855d6085bd2395da6855886f">drake::trajectories::PiecewisePolynomial::value</a></div><div class="ttdeci">MatrixX&lt; T &gt; value(const T &amp;t) const</div><div class="ttdoc">Evaluates the PiecewisePolynomial at the given time t.</div><div class="ttdef"><b>Definition</b> piecewise_polynomial.h:513</div></div>
</div><!-- fragment --><p> meaning that constructing the polynomial like: </p><div class="fragment"><div class="line"><span class="keyword">const</span> std::vector&lt;double&gt; <a class="code hl_function" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a4e258af58745532546142965cd4444c7">breaks</a> = { 0.0, 1.0, 2.0 };</div>
<div class="line"><a class="code hl_typedef" href="namespacedrake.html#ab0a2621977171e1d2d5b64c55141b9b2">Polynomiald</a> t(<span class="stringliteral">&quot;t&quot;</span>);</div>
<div class="line">std::vector&lt;Polynomiald&gt; polynomials = { (t*t), (t*t) };</div>
<div class="line"><span class="keyword">const</span> PiecewisePolynomial&lt;double&gt; pp(polynomials, <a class="code hl_function" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a4e258af58745532546142965cd4444c7">breaks</a>);</div>
</div><!-- fragment --><p> would give the following result: </p><div class="fragment"><div class="line"><span class="comment">// Evaluate the PiecewisePolynomial on both sides of a break.</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> row = 0, col = 0;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> eps = 0.5 * std::numeric_limits&lt;double&gt;::epsilon();</div>
<div class="line">std::cout &lt;&lt; pp.value(1.0-eps)(row, col) &lt;&lt; std::endl;    <span class="comment">// Outputs 1.0</span></div>
<div class="line">std::cout &lt;&lt; pp.value(1.0+eps)(row, col) &lt;&lt; std::endl;    <span class="comment">// Outputs 1e-32</span></div>
</div><!-- fragment --><p> because the second polynomial will be evaluated at 1.0+eps minus the break time for that polynomial (1.0), i.e., t=eps. The intended result for the above example can be obtained by shifting the piecewise polynomial like so: </p><div class="fragment"><div class="line"><span class="keyword">const</span> std::vector&lt;double&gt; <a class="code hl_function" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a4e258af58745532546142965cd4444c7">breaks</a> = { 0.0, 1.0, 2.0 };</div>
<div class="line"><a class="code hl_typedef" href="namespacedrake.html#ab0a2621977171e1d2d5b64c55141b9b2">Polynomiald</a> t(<span class="stringliteral">&quot;t&quot;</span>);</div>
<div class="line">std::vector&lt;Polynomiald&gt; polynomials = { (t*t),</div>
<div class="line">    ((t+<a class="code hl_function" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a4e258af58745532546142965cd4444c7">breaks</a>[1])*(t+<a class="code hl_function" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a4e258af58745532546142965cd4444c7">breaks</a>[1])) };</div>
<div class="line"><span class="keyword">const</span> PiecewisePolynomial&lt;double&gt; pp(polynomials, <a class="code hl_function" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a4e258af58745532546142965cd4444c7">breaks</a>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Evaluate the PiecewisePolynomial on both sides of a break.</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> eps = 0.5 * std::numeric_limits&lt;double&gt;::epsilon();</div>
<div class="line">std::cout &lt;&lt; pp.value(1.0-eps)(row, col) &lt;&lt; std::endl;    <span class="comment">// Outputs 1.0</span></div>
<div class="line">std::cout &lt;&lt; pp.value(1.0+eps)(row, col) &lt;&lt; std::endl;    <span class="comment">// Outputs 1.0</span></div>
</div><!-- fragment --> </div></td></tr>
<tr class="memitem:a9145f61319cb888cb71fc58cebc8fe38" id="r_a9145f61319cb888cb71fc58cebc8fe38"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9145f61319cb888cb71fc58cebc8fe38">PiecewisePolynomial</a> (const std::vector&lt; <a class="el" href="#a9c5cbf1ba95055937fdb8283769df797">PolynomialMatrix</a> &gt; &amp;polynomials_matrix, const std::vector&lt; T &gt; &amp;<a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a4e258af58745532546142965cd4444c7">breaks</a>)</td></tr>
<tr class="memdesc:a9145f61319cb888cb71fc58cebc8fe38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a PiecewisePolynomial using matrix-output Polynomials defined over each segment.  <br /></td></tr>
<tr class="memitem:a855e5579cf5a007bc3406051a2d5e296" id="r_a855e5579cf5a007bc3406051a2d5e296"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a855e5579cf5a007bc3406051a2d5e296">PiecewisePolynomial</a> (const std::vector&lt; <a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a>&lt; T &gt; &gt; &amp;polynomials, const std::vector&lt; T &gt; &amp;<a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a4e258af58745532546142965cd4444c7">breaks</a>)</td></tr>
<tr class="memdesc:a855e5579cf5a007bc3406051a2d5e296"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a PiecewisePolynomial using scalar-output Polynomials defined over each segment.  <br /></td></tr>
<tr class="memitem:a04aa32f958635709b5a538f99c092ba0" id="r_a04aa32f958635709b5a538f99c092ba0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a04aa32f958635709b5a538f99c092ba0">~PiecewisePolynomial</a> () final</td></tr>
<tr class="inherit_header pub_methods_classdrake_1_1trajectories_1_1_piecewise_trajectory"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_classdrake_1_1trajectories_1_1_piecewise_trajectory')"><span class="dynarrow"><span class="arrowhead closed"></span></span>Public Member Functions inherited from <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html">PiecewiseTrajectory&lt; T &gt;</a></td></tr>
<tr class="memitem:afcec38847e04c1bb331a306768da20c7 inherit pub_methods_classdrake_1_1trajectories_1_1_piecewise_trajectory" id="r_afcec38847e04c1bb331a306768da20c7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#afcec38847e04c1bb331a306768da20c7">~PiecewiseTrajectory</a> () override</td></tr>
<tr class="memitem:a4ff5241db765b5a4de7c88bb996d39a8 inherit pub_methods_classdrake_1_1trajectories_1_1_piecewise_trajectory" id="r_a4ff5241db765b5a4de7c88bb996d39a8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a4ff5241db765b5a4de7c88bb996d39a8">get_number_of_segments</a> () const</td></tr>
<tr class="memitem:a1019f41dcfe440c98c91029f4b0b0bc0 inherit pub_methods_classdrake_1_1trajectories_1_1_piecewise_trajectory" id="r_a1019f41dcfe440c98c91029f4b0b0bc0"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a1019f41dcfe440c98c91029f4b0b0bc0">start_time</a> (int segment_number) const</td></tr>
<tr class="memitem:a4c1604e170d921c073e4fba715622507 inherit pub_methods_classdrake_1_1trajectories_1_1_piecewise_trajectory" id="r_a4c1604e170d921c073e4fba715622507"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a4c1604e170d921c073e4fba715622507">end_time</a> (int segment_number) const</td></tr>
<tr class="memitem:af88c3d4b35f53401069500f721083309 inherit pub_methods_classdrake_1_1trajectories_1_1_piecewise_trajectory" id="r_af88c3d4b35f53401069500f721083309"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#af88c3d4b35f53401069500f721083309">duration</a> (int segment_number) const</td></tr>
<tr class="memitem:acae435d14c7da7e732884c43b125040a inherit pub_methods_classdrake_1_1trajectories_1_1_piecewise_trajectory" id="r_acae435d14c7da7e732884c43b125040a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#acae435d14c7da7e732884c43b125040a">is_time_in_range</a> (const T &amp;t) const</td></tr>
<tr class="memdesc:acae435d14c7da7e732884c43b125040a inherit pub_methods_classdrake_1_1trajectories_1_1_piecewise_trajectory"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true iff <span class="tt">t &gt;= getStartTime() &amp;&amp; t &lt;= getEndTime()</span>.  <br /></td></tr>
<tr class="memitem:a326ae949f44158da731ef777bba601ec inherit pub_methods_classdrake_1_1trajectories_1_1_piecewise_trajectory" id="r_a326ae949f44158da731ef777bba601ec"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a326ae949f44158da731ef777bba601ec">get_segment_index</a> (const T &amp;t) const</td></tr>
<tr class="memitem:ab5b1a0b2d9113c656018bcace89985b4 inherit pub_methods_classdrake_1_1trajectories_1_1_piecewise_trajectory" id="r_ab5b1a0b2d9113c656018bcace89985b4"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#ab5b1a0b2d9113c656018bcace89985b4">get_segment_times</a> () const</td></tr>
<tr class="memitem:a0a4ac30a258a47b6ea610f16f4accece inherit pub_methods_classdrake_1_1trajectories_1_1_piecewise_trajectory" id="r_a0a4ac30a258a47b6ea610f16f4accece"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a0a4ac30a258a47b6ea610f16f4accece">segment_number_range_check</a> (int segment_number) const</td></tr>
<tr class="inherit_header pub_methods_classdrake_1_1trajectories_1_1_trajectory"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_classdrake_1_1trajectories_1_1_trajectory')"><span class="dynarrow"><span class="arrowhead closed"></span></span>Public Member Functions inherited from <a class="el" href="classdrake_1_1trajectories_1_1_trajectory.html">Trajectory&lt; T &gt;</a></td></tr>
<tr class="memitem:ab987e6d84bde821d7e3c212c48b99ce7 inherit pub_methods_classdrake_1_1trajectories_1_1_trajectory" id="r_ab987e6d84bde821d7e3c212c48b99ce7"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_trajectory.html#ab987e6d84bde821d7e3c212c48b99ce7">~Trajectory</a> ()</td></tr>
<tr class="memitem:aa234e95231130c750201bd0104658f90 inherit pub_methods_classdrake_1_1trajectories_1_1_trajectory" id="r_aa234e95231130c750201bd0104658f90"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classdrake_1_1trajectories_1_1_trajectory.html#a6b15b4592b800d6cf4d9273f46a2774b">Trajectory</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_trajectory.html#aa234e95231130c750201bd0104658f90">Clone</a> () const</td></tr>
<tr class="memitem:a13176bef855d6085bd2395da6855886f inherit pub_methods_classdrake_1_1trajectories_1_1_trajectory" id="r_a13176bef855d6085bd2395da6855886f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_trajectory.html#a13176bef855d6085bd2395da6855886f">value</a> (const T &amp;t) const</td></tr>
<tr class="memdesc:a13176bef855d6085bd2395da6855886f inherit pub_methods_classdrake_1_1trajectories_1_1_trajectory"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the trajectory at the given time <code class="param">t</code>.  <br /></td></tr>
<tr class="memitem:ad3a9474931d162dd67c7b3261479e39c inherit pub_methods_classdrake_1_1trajectories_1_1_trajectory" id="r_ad3a9474931d162dd67c7b3261479e39c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_trajectory.html#ad3a9474931d162dd67c7b3261479e39c">vector_values</a> (const std::vector&lt; T &gt; &amp;t) const</td></tr>
<tr class="memdesc:ad3a9474931d162dd67c7b3261479e39c inherit pub_methods_classdrake_1_1trajectories_1_1_trajectory"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <a class="el" href="classdrake_1_1trajectories_1_1_trajectory.html#ad6c1acca5de9ae9bed71bbafb0051de3">cols()</a>==1, then evaluates the trajectory at each time <code class="param">t</code>, and returns the results as a Matrix with the ith column corresponding to the ith time.  <br /></td></tr>
<tr class="memitem:ac0b535e23261216ed8ea3ee9748daef8 inherit pub_methods_classdrake_1_1trajectories_1_1_trajectory" id="r_ac0b535e23261216ed8ea3ee9748daef8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_trajectory.html#ac0b535e23261216ed8ea3ee9748daef8">vector_values</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; &amp;t) const</td></tr>
<tr class="memdesc:ac0b535e23261216ed8ea3ee9748daef8 inherit pub_methods_classdrake_1_1trajectories_1_1_trajectory"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <a class="el" href="classdrake_1_1trajectories_1_1_trajectory.html#ad6c1acca5de9ae9bed71bbafb0051de3">cols()</a>==1, then evaluates the trajectory at each time <code class="param">t</code>, and returns the results as a Matrix with the ith column corresponding to the ith time.  <br /></td></tr>
<tr class="memitem:a9507f1cc6b538dc632d20e3d681bbaba inherit pub_methods_classdrake_1_1trajectories_1_1_trajectory" id="r_a9507f1cc6b538dc632d20e3d681bbaba"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_trajectory.html#a9507f1cc6b538dc632d20e3d681bbaba">has_derivative</a> () const</td></tr>
<tr class="memdesc:a9507f1cc6b538dc632d20e3d681bbaba inherit pub_methods_classdrake_1_1trajectories_1_1_trajectory"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true iff the <a class="el" href="classdrake_1_1trajectories_1_1_trajectory.html" title="A Trajectory represents a time-varying matrix, indexed by a single scalar time.">Trajectory</a> provides and implementation for <a class="el" href="classdrake_1_1trajectories_1_1_trajectory.html#abf2912689d33fd58c54d119cab8f4140" title="Evaluates the derivative of this at the given time t.">EvalDerivative()</a> and <a class="el" href="classdrake_1_1trajectories_1_1_trajectory.html#ad0a2e28df96d5c3f7a7d94c47208d65a" title="Takes the derivative of this Trajectory.">MakeDerivative()</a>.  <br /></td></tr>
<tr class="memitem:abf2912689d33fd58c54d119cab8f4140 inherit pub_methods_classdrake_1_1trajectories_1_1_trajectory" id="r_abf2912689d33fd58c54d119cab8f4140"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_trajectory.html#abf2912689d33fd58c54d119cab8f4140">EvalDerivative</a> (const T &amp;t, int derivative_order=1) const</td></tr>
<tr class="memdesc:abf2912689d33fd58c54d119cab8f4140 inherit pub_methods_classdrake_1_1trajectories_1_1_trajectory"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the derivative of <span class="tt">this</span> at the given time <code class="param">t</code>.  <br /></td></tr>
<tr class="memitem:ad0a2e28df96d5c3f7a7d94c47208d65a inherit pub_methods_classdrake_1_1trajectories_1_1_trajectory" id="r_ad0a2e28df96d5c3f7a7d94c47208d65a"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classdrake_1_1trajectories_1_1_trajectory.html#a6b15b4592b800d6cf4d9273f46a2774b">Trajectory</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_trajectory.html#ad0a2e28df96d5c3f7a7d94c47208d65a">MakeDerivative</a> (int derivative_order=1) const</td></tr>
<tr class="memdesc:ad0a2e28df96d5c3f7a7d94c47208d65a inherit pub_methods_classdrake_1_1trajectories_1_1_trajectory"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes the derivative of this <a class="el" href="classdrake_1_1trajectories_1_1_trajectory.html" title="A Trajectory represents a time-varying matrix, indexed by a single scalar time.">Trajectory</a>.  <br /></td></tr>
<tr class="memitem:adcc8b67a7b625544afb0ae19bcf76564 inherit pub_methods_classdrake_1_1trajectories_1_1_trajectory" id="r_adcc8b67a7b625544afb0ae19bcf76564"><td class="memItemLeft" align="right" valign="top">Eigen::Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_trajectory.html#adcc8b67a7b625544afb0ae19bcf76564">rows</a> () const</td></tr>
<tr class="memitem:ad6c1acca5de9ae9bed71bbafb0051de3 inherit pub_methods_classdrake_1_1trajectories_1_1_trajectory" id="r_ad6c1acca5de9ae9bed71bbafb0051de3"><td class="memItemLeft" align="right" valign="top">Eigen::Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_trajectory.html#ad6c1acca5de9ae9bed71bbafb0051de3">cols</a> () const</td></tr>
<tr class="memitem:abe137b1185034503e70febe2ebe779ce inherit pub_methods_classdrake_1_1trajectories_1_1_trajectory" id="r_abe137b1185034503e70febe2ebe779ce"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_trajectory.html#abe137b1185034503e70febe2ebe779ce">start_time</a> () const</td></tr>
<tr class="memitem:ac438ad10b752ebb42788ff09d0fa653f inherit pub_methods_classdrake_1_1trajectories_1_1_trajectory" id="r_ac438ad10b752ebb42788ff09d0fa653f"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_trajectory.html#ac438ad10b752ebb42788ff09d0fa653f">end_time</a> () const</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-member-group" class="groupheader"><a id="member-group" name="member-group"></a>
Coefficient-based construction methods.</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="coefficient_construction_methods"></a> Various methods for constructing a PiecewisePolynomial using samples of coefficient matrices.</p>
<p>Under the hood, PiecewisePolynomial constructs interpolating <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> objects that pass through the sample points. These methods differ by the continuity constraints that they enforce at break points and whether each sample represents a full matrix (versions taking <span class="tt">const std::vector&lt;<a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95" title="A matrix of dynamic size, templated on scalar type.">MatrixX</a>&lt;T&gt;&gt;&amp;</span>) or a column vector (versions taking <span class="tt">const Eigen::Ref&lt;const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95" title="A matrix of dynamic size, templated on scalar type.">MatrixX</a>&lt;T&gt;&gt;&amp;</span>).</p>
<p>These methods will throw <span class="tt">std::exception</span> if:</p><ul>
<li>the breaks and samples have different length,</li>
<li>the breaks are not strictly increasing,</li>
<li>the samples have inconsistent dimensions (i.e., the matrices do not all have identical dimensions),</li>
<li>the breaks vector has length smaller than 2. </li>
</ul>
</td></tr>
<tr class="memitem:a405f92e0e677a316b9a8ed8ec841befd" id="r_a405f92e0e677a316b9a8ed8ec841befd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a6a44781cbe3dd6c55234638a1b63d4ef">PiecewisePolynomial</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a405f92e0e677a316b9a8ed8ec841befd">derivative</a> (int derivative_order=1) const</td></tr>
<tr class="memdesc:a405f92e0e677a316b9a8ed8ec841befd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a PiecewisePolynomial where each segment is the specified derivative of the corresponding segment in <span class="tt">this</span>.  <br /></td></tr>
<tr class="memitem:aeaceab81f8d6fd7e3af6d32b076fea0a" id="r_aeaceab81f8d6fd7e3af6d32b076fea0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a6a44781cbe3dd6c55234638a1b63d4ef">PiecewisePolynomial</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeaceab81f8d6fd7e3af6d32b076fea0a">integral</a> (const T &amp;value_at_start_time=0.0) const</td></tr>
<tr class="memdesc:aeaceab81f8d6fd7e3af6d32b076fea0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a PiecewisePolynomial that is the indefinite integral of this one.  <br /></td></tr>
<tr class="memitem:af53fa90507df925e5fe8006558edbdf3" id="r_af53fa90507df925e5fe8006558edbdf3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a6a44781cbe3dd6c55234638a1b63d4ef">PiecewisePolynomial</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af53fa90507df925e5fe8006558edbdf3">integral</a> (const Eigen::Ref&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &gt; &amp;value_at_start_time) const</td></tr>
<tr class="memdesc:af53fa90507df925e5fe8006558edbdf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a PiecewisePolynomial that is the indefinite integral of this one.  <br /></td></tr>
<tr class="memitem:a644718bb2fb240de962dc3c9a1fdf0dc" id="r_a644718bb2fb240de962dc3c9a1fdf0dc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a644718bb2fb240de962dc3c9a1fdf0dc">empty</a> () const</td></tr>
<tr class="memdesc:a644718bb2fb240de962dc3c9a1fdf0dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <span class="tt">true</span> if this trajectory has no breaks/samples/polynomials.  <br /></td></tr>
<tr class="memitem:a16274d0c316c76ded4b85111b38ece15" id="r_a16274d0c316c76ded4b85111b38ece15"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a16274d0c316c76ded4b85111b38ece15">scalarValue</a> (const T &amp;t, Eigen::Index row=0, Eigen::Index col=0) const</td></tr>
<tr class="memdesc:a16274d0c316c76ded4b85111b38ece15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the trajectory at the given time without returning the entire matrix.  <br /></td></tr>
<tr class="memitem:a13176bef855d6085bd2395da6855886f" id="r_a13176bef855d6085bd2395da6855886f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a13176bef855d6085bd2395da6855886f">value</a> (const T &amp;t) const</td></tr>
<tr class="memdesc:a13176bef855d6085bd2395da6855886f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the PiecewisePolynomial at the given time t.  <br /></td></tr>
<tr class="memitem:a33b5e4a75a36128eb0f8d16e29789b09" id="r_a33b5e4a75a36128eb0f8d16e29789b09"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="#a9c5cbf1ba95055937fdb8283769df797">PolynomialMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a33b5e4a75a36128eb0f8d16e29789b09">getPolynomialMatrix</a> (int segment_index) const</td></tr>
<tr class="memdesc:a33b5e4a75a36128eb0f8d16e29789b09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the matrix of Polynomials corresponding to the given segment index.  <br /></td></tr>
<tr class="memitem:acc499221b2ff0630d2b79d1fc9ec61d4" id="r_acc499221b2ff0630d2b79d1fc9ec61d4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acc499221b2ff0630d2b79d1fc9ec61d4">getPolynomial</a> (int segment_index, Eigen::Index row=0, Eigen::Index col=0) const</td></tr>
<tr class="memdesc:acc499221b2ff0630d2b79d1fc9ec61d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> with the given matrix row and column index that corresponds to the given segment index.  <br /></td></tr>
<tr class="memitem:aa5a111a1944f16bb21873433d4b7b31d" id="r_aa5a111a1944f16bb21873433d4b7b31d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa5a111a1944f16bb21873433d4b7b31d">getSegmentPolynomialDegree</a> (int segment_index, Eigen::Index row=0, Eigen::Index col=0) const</td></tr>
<tr class="memdesc:aa5a111a1944f16bb21873433d4b7b31d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the degree of the <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> with the given matrix row and column index that corresponds to the given segment index.  <br /></td></tr>
<tr class="memitem:adcc8b67a7b625544afb0ae19bcf76564" id="r_adcc8b67a7b625544afb0ae19bcf76564"><td class="memItemLeft" align="right" valign="top">Eigen::Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adcc8b67a7b625544afb0ae19bcf76564">rows</a> () const</td></tr>
<tr class="memdesc:adcc8b67a7b625544afb0ae19bcf76564"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the row count of the output matrices.  <br /></td></tr>
<tr class="memitem:ad6c1acca5de9ae9bed71bbafb0051de3" id="r_ad6c1acca5de9ae9bed71bbafb0051de3"><td class="memItemLeft" align="right" valign="top">Eigen::Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad6c1acca5de9ae9bed71bbafb0051de3">cols</a> () const</td></tr>
<tr class="memdesc:ad6c1acca5de9ae9bed71bbafb0051de3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the column count of the output matrices.  <br /></td></tr>
<tr class="memitem:a39001029f6f2e13a8890f233254c4709" id="r_a39001029f6f2e13a8890f233254c4709"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a39001029f6f2e13a8890f233254c4709">Reshape</a> (int <a class="el" href="#adcc8b67a7b625544afb0ae19bcf76564">rows</a>, int <a class="el" href="#ad6c1acca5de9ae9bed71bbafb0051de3">cols</a>)</td></tr>
<tr class="memdesc:a39001029f6f2e13a8890f233254c4709"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reshapes the dimensions of the Eigen::MatrixX&lt;T&gt; returned by <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a13176bef855d6085bd2395da6855886f" title="Evaluates the PiecewisePolynomial at the given time t.">value()</a>, <a class="el" href="classdrake_1_1trajectories_1_1_trajectory.html#abf2912689d33fd58c54d119cab8f4140" title="Evaluates the derivative of this at the given time t.">EvalDerivative()</a>, etc.  <br /></td></tr>
<tr class="memitem:a59f4f35bd9afa91ca14283e7c865918f" id="r_a59f4f35bd9afa91ca14283e7c865918f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a6a44781cbe3dd6c55234638a1b63d4ef">PiecewisePolynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a59f4f35bd9afa91ca14283e7c865918f">Transpose</a> () const</td></tr>
<tr class="memdesc:a59f4f35bd9afa91ca14283e7c865918f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new <a class="el" href="classdrake_1_1multibody_1_1_piecewise_polynomial.html" title="A scalar multi-variate piecewise polynomial.">PiecewisePolynomial</a> for which value(t) == this.value(t).transpose().  <br /></td></tr>
<tr class="memitem:a45001b70f1a92e1d01778b69bb61adf3" id="r_a45001b70f1a92e1d01778b69bb61adf3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a6a44781cbe3dd6c55234638a1b63d4ef">PiecewisePolynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a45001b70f1a92e1d01778b69bb61adf3">Block</a> (int start_row, int start_col, int block_rows, int block_cols) const</td></tr>
<tr class="memdesc:a45001b70f1a92e1d01778b69bb61adf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a trajectory representing a block of size (block_rows, block_cols) starting at (start_row, start_col) from the <a class="el" href="classdrake_1_1multibody_1_1_piecewise_polynomial.html" title="A scalar multi-variate piecewise polynomial.">PiecewisePolynomial</a>.  <br /></td></tr>
<tr class="memitem:a2a12a957f3f33854c28f533f571c9592" id="r_a2a12a957f3f33854c28f533f571c9592"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a6a44781cbe3dd6c55234638a1b63d4ef">PiecewisePolynomial</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2a12a957f3f33854c28f533f571c9592">operator+=</a> (const <a class="el" href="#a6a44781cbe3dd6c55234638a1b63d4ef">PiecewisePolynomial</a> &amp;other)</td></tr>
<tr class="memdesc:a2a12a957f3f33854c28f533f571c9592"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds each <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> in the <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a9c5cbf1ba95055937fdb8283769df797">PolynomialMatrix</a> of <span class="tt">other</span> to the corresponding <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> in the <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a9c5cbf1ba95055937fdb8283769df797">PolynomialMatrix</a> of <span class="tt">this</span>, storing the result in <span class="tt">this</span>.  <br /></td></tr>
<tr class="memitem:a31232077298203598bab7b730a73b8b2" id="r_a31232077298203598bab7b730a73b8b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a6a44781cbe3dd6c55234638a1b63d4ef">PiecewisePolynomial</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a31232077298203598bab7b730a73b8b2">operator+=</a> (const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &amp;coeff)</td></tr>
<tr class="memitem:a2534241e0adb371ee9cb3d0fd6c02092" id="r_a2534241e0adb371ee9cb3d0fd6c02092"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a6a44781cbe3dd6c55234638a1b63d4ef">PiecewisePolynomial</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2534241e0adb371ee9cb3d0fd6c02092">operator-=</a> (const <a class="el" href="#a6a44781cbe3dd6c55234638a1b63d4ef">PiecewisePolynomial</a> &amp;other)</td></tr>
<tr class="memdesc:a2534241e0adb371ee9cb3d0fd6c02092"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts each <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> in the <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a9c5cbf1ba95055937fdb8283769df797">PolynomialMatrix</a> of <span class="tt">other</span> from the corresponding <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> in the <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a9c5cbf1ba95055937fdb8283769df797">PolynomialMatrix</a> of <span class="tt">this</span>, storing the result in <span class="tt">this</span>.  <br /></td></tr>
<tr class="memitem:a722590f3afed971fa441f2d5de89d944" id="r_a722590f3afed971fa441f2d5de89d944"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a6a44781cbe3dd6c55234638a1b63d4ef">PiecewisePolynomial</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a722590f3afed971fa441f2d5de89d944">operator-=</a> (const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &amp;coeff)</td></tr>
<tr class="memitem:a132ba8fdc66d6182646b9b4f80c97507" id="r_a132ba8fdc66d6182646b9b4f80c97507"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a6a44781cbe3dd6c55234638a1b63d4ef">PiecewisePolynomial</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a132ba8fdc66d6182646b9b4f80c97507">operator*=</a> (const <a class="el" href="#a6a44781cbe3dd6c55234638a1b63d4ef">PiecewisePolynomial</a> &amp;other)</td></tr>
<tr class="memdesc:a132ba8fdc66d6182646b9b4f80c97507"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies each <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> in the <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a9c5cbf1ba95055937fdb8283769df797">PolynomialMatrix</a> of <span class="tt">other</span> by the corresponding <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> in the <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a9c5cbf1ba95055937fdb8283769df797">PolynomialMatrix</a> of <span class="tt">this</span> (i.e., a coefficient-wise multiplication), storing the result in <span class="tt">this</span>.  <br /></td></tr>
<tr class="memitem:ad838f10606e844eac52b6553ba5acfd0" id="r_ad838f10606e844eac52b6553ba5acfd0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="#a6a44781cbe3dd6c55234638a1b63d4ef">PiecewisePolynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad838f10606e844eac52b6553ba5acfd0">operator+</a> (const <a class="el" href="#a6a44781cbe3dd6c55234638a1b63d4ef">PiecewisePolynomial</a> &amp;other) const</td></tr>
<tr class="memdesc:ad838f10606e844eac52b6553ba5acfd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds each <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> in the <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a9c5cbf1ba95055937fdb8283769df797">PolynomialMatrix</a> of <span class="tt">other</span> to the corresponding <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> in the <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a9c5cbf1ba95055937fdb8283769df797">PolynomialMatrix</a> of <span class="tt">this</span>.  <br /></td></tr>
<tr class="memitem:a87952ec710e902557114a6d53d39734e" id="r_a87952ec710e902557114a6d53d39734e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="#a6a44781cbe3dd6c55234638a1b63d4ef">PiecewisePolynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a87952ec710e902557114a6d53d39734e">operator+</a> (const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &amp;coeff) const</td></tr>
<tr class="memitem:a359271510bcf12db604f2e7572c45839" id="r_a359271510bcf12db604f2e7572c45839"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="#a6a44781cbe3dd6c55234638a1b63d4ef">PiecewisePolynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a359271510bcf12db604f2e7572c45839">operator-</a> (const <a class="el" href="#a6a44781cbe3dd6c55234638a1b63d4ef">PiecewisePolynomial</a> &amp;other) const</td></tr>
<tr class="memdesc:a359271510bcf12db604f2e7572c45839"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts each <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> in the <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a9c5cbf1ba95055937fdb8283769df797">PolynomialMatrix</a> of <span class="tt">other</span> from the corresponding <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> in the <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a9c5cbf1ba95055937fdb8283769df797">PolynomialMatrix</a> of <span class="tt">this</span>.  <br /></td></tr>
<tr class="memitem:ac3fb3016c2ae2b3bc37459710539e1fa" id="r_ac3fb3016c2ae2b3bc37459710539e1fa"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="#a6a44781cbe3dd6c55234638a1b63d4ef">PiecewisePolynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac3fb3016c2ae2b3bc37459710539e1fa">operator-</a> () const</td></tr>
<tr class="memdesc:ac3fb3016c2ae2b3bc37459710539e1fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements unary minus operator.  <br /></td></tr>
<tr class="memitem:a9bd57b84091cef3694aee370fa189735" id="r_a9bd57b84091cef3694aee370fa189735"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="#a6a44781cbe3dd6c55234638a1b63d4ef">PiecewisePolynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9bd57b84091cef3694aee370fa189735">operator-</a> (const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &amp;coeff) const</td></tr>
<tr class="memitem:a7495e58bd96d928d186092e155c413ad" id="r_a7495e58bd96d928d186092e155c413ad"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="#a6a44781cbe3dd6c55234638a1b63d4ef">PiecewisePolynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7495e58bd96d928d186092e155c413ad">operator*</a> (const <a class="el" href="#a6a44781cbe3dd6c55234638a1b63d4ef">PiecewisePolynomial</a> &amp;other) const</td></tr>
<tr class="memdesc:a7495e58bd96d928d186092e155c413ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies each <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> in the <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a9c5cbf1ba95055937fdb8283769df797">PolynomialMatrix</a> of <span class="tt">other</span> by the corresponding <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> in the <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a9c5cbf1ba95055937fdb8283769df797">PolynomialMatrix</a> of <span class="tt">this</span> (i.e., a coefficient-wise multiplication).  <br /></td></tr>
<tr class="memitem:a5d7edaa991443e887ca36e0fd20b96c7" id="r_a5d7edaa991443e887ca36e0fd20b96c7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5d7edaa991443e887ca36e0fd20b96c7">isApprox</a> (const <a class="el" href="#a6a44781cbe3dd6c55234638a1b63d4ef">PiecewisePolynomial</a> &amp;other, double tol, const <a class="el" href="namespacedrake.html#af8777bc10296f9d39d52753861110e26">ToleranceType</a> &amp;tol_type=<a class="el" href="namespacedrake.html#af8777bc10296f9d39d52753861110e26af460a96ab20647996c15854794763384">ToleranceType::kRelative</a>) const</td></tr>
<tr class="memdesc:a5d7edaa991443e887ca36e0fd20b96c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a PiecewisePolynomial is approximately equal to this one by calling <a class="el" href="classdrake_1_1_polynomial.html#ad96f76c37313cb0d62582faccf358345" title="Checks if a Polynomial is approximately equal to this one.">Polynomial&lt;T&gt;::CoefficientsAlmostEqual()</a> on every element of every segment.  <br /></td></tr>
<tr class="memitem:a75d7ffe2f4e1a808aaeb76a871f772e2" id="r_a75d7ffe2f4e1a808aaeb76a871f772e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a75d7ffe2f4e1a808aaeb76a871f772e2">ConcatenateInTime</a> (const <a class="el" href="#a6a44781cbe3dd6c55234638a1b63d4ef">PiecewisePolynomial</a> &amp;other)</td></tr>
<tr class="memdesc:a75d7ffe2f4e1a808aaeb76a871f772e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates <span class="tt">other</span> to the end of <span class="tt">this</span>.  <br /></td></tr>
<tr class="memitem:a90e19253a0e27427859a34ab7b2f81ba" id="r_a90e19253a0e27427859a34ab7b2f81ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a90e19253a0e27427859a34ab7b2f81ba">AppendCubicHermiteSegment</a> (const T &amp;time, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &gt; &amp;sample, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &gt; &amp;sample_dot)</td></tr>
<tr class="memdesc:a90e19253a0e27427859a34ab7b2f81ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">The CubicHermite spline construction has a nice property of being incremental (each segment can be solved independently).  <br /></td></tr>
<tr class="memitem:ae08f90c486157496f359c38655f74985" id="r_ae08f90c486157496f359c38655f74985"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae08f90c486157496f359c38655f74985">AppendFirstOrderSegment</a> (const T &amp;time, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &gt; &amp;sample)</td></tr>
<tr class="memdesc:ae08f90c486157496f359c38655f74985"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a new sample, this method adds one segment to the end of <span class="tt">this</span> using a first-order hold, where the start sample is taken as the value at the final break of <span class="tt">this</span>.  <br /></td></tr>
<tr class="memitem:a88e900c12b23dd1cb0bccb6d0357db5f" id="r_a88e900c12b23dd1cb0bccb6d0357db5f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a88e900c12b23dd1cb0bccb6d0357db5f">RemoveFinalSegment</a> ()</td></tr>
<tr class="memdesc:a88e900c12b23dd1cb0bccb6d0357db5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the final segment from the trajectory, reducing the number of segments by 1.  <br /></td></tr>
<tr class="memitem:afca7568bb098808d681cb14d7fa09f99" id="r_afca7568bb098808d681cb14d7fa09f99"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afca7568bb098808d681cb14d7fa09f99">ReverseTime</a> ()</td></tr>
<tr class="memdesc:afca7568bb098808d681cb14d7fa09f99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifies the trajectory so that pp_after(t) = pp_before(-t).  <br /></td></tr>
<tr class="memitem:a923a4ac5ef6f85f444519188d9dbd3e1" id="r_a923a4ac5ef6f85f444519188d9dbd3e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a923a4ac5ef6f85f444519188d9dbd3e1">ScaleTime</a> (const T &amp;scale)</td></tr>
<tr class="memdesc:a923a4ac5ef6f85f444519188d9dbd3e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales the time of the trajectory by non-negative <span class="tt">scale</span> (use <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#afca7568bb098808d681cb14d7fa09f99" title="Modifies the trajectory so that pp_after(t) = pp_before(-t).">ReverseTime()</a> if you want to also negate time).  <br /></td></tr>
<tr class="memitem:a728995759fa06a8d1a2b967d313b6d6b" id="r_a728995759fa06a8d1a2b967d313b6d6b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a728995759fa06a8d1a2b967d313b6d6b">shiftRight</a> (const T &amp;offset)</td></tr>
<tr class="memdesc:a728995759fa06a8d1a2b967d313b6d6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds <span class="tt">offset</span> to all of the breaks.  <br /></td></tr>
<tr class="memitem:a6697b9094ce308f8a5445604076181e8" id="r_a6697b9094ce308f8a5445604076181e8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6697b9094ce308f8a5445604076181e8">AddBreak</a> (const T &amp;new_break)</td></tr>
<tr class="memdesc:a6697b9094ce308f8a5445604076181e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a break at the specified time.  <br /></td></tr>
<tr class="memitem:ab0edf720069e60d0da73fba82dec2fa2" id="r_ab0edf720069e60d0da73fba82dec2fa2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a6a44781cbe3dd6c55234638a1b63d4ef">PiecewisePolynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab0edf720069e60d0da73fba82dec2fa2">SliceByTime</a> (const T &amp;<a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a1019f41dcfe440c98c91029f4b0b0bc0">start_time</a>, const T &amp;<a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a4c1604e170d921c073e4fba715622507">end_time</a>) const</td></tr>
<tr class="memdesc:ab0edf720069e60d0da73fba82dec2fa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Slices the trajectory within a specified time range.  <br /></td></tr>
<tr class="memitem:a9a7863e6bf8a3ccb5335563370305add" id="r_a9a7863e6bf8a3ccb5335563370305add"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9a7863e6bf8a3ccb5335563370305add">setPolynomialMatrixBlock</a> (const <a class="el" href="#a9c5cbf1ba95055937fdb8283769df797">PolynomialMatrix</a> &amp;replacement, int segment_index, Eigen::Index row_start=0, Eigen::Index col_start=0)</td></tr>
<tr class="memdesc:a9a7863e6bf8a3ccb5335563370305add"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the specified block of the <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a9c5cbf1ba95055937fdb8283769df797">PolynomialMatrix</a> at the given segment index.  <br /></td></tr>
<tr class="memitem:a28dc60d1015ae4d2e946898a2eec5692" id="r_a28dc60d1015ae4d2e946898a2eec5692"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a6a44781cbe3dd6c55234638a1b63d4ef">PiecewisePolynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a28dc60d1015ae4d2e946898a2eec5692">slice</a> (int start_segment_index, int num_segments) const</td></tr>
<tr class="memdesc:a28dc60d1015ae4d2e946898a2eec5692"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the PiecewisePolynomial comprising the <span class="tt">num_segments</span> segments starting at the specified <span class="tt">start_segment_index</span>.  <br /></td></tr>
<tr class="memitem:a8e8824802dedfbc36776227f7482b6bc" id="r_a8e8824802dedfbc36776227f7482b6bc"><td class="memTemplParams" colspan="2">template&lt;typename Archive&gt; </td></tr>
<tr class="memitem:a8e8824802dedfbc36776227f7482b6bc template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8e8824802dedfbc36776227f7482b6bc">Serialize</a> (Archive *a)</td></tr>
<tr class="memdesc:a8e8824802dedfbc36776227f7482b6bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Passes this object to an Archive.  <br /></td></tr>
<tr class="memitem:ad4f93c291cf6baf5b808fdd2770bd35a" id="r_ad4f93c291cf6baf5b808fdd2770bd35a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#a6a44781cbe3dd6c55234638a1b63d4ef">PiecewisePolynomial</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad4f93c291cf6baf5b808fdd2770bd35a">ZeroOrderHold</a> (const std::vector&lt; T &gt; &amp;<a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a4e258af58745532546142965cd4444c7">breaks</a>, const std::vector&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &gt; &amp;samples)</td></tr>
<tr class="memdesc:ad4f93c291cf6baf5b808fdd2770bd35a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a piecewise constant PiecewisePolynomial using matrix samples.  <br /></td></tr>
<tr class="memitem:a676915a092a5400783b06c6e0441db96" id="r_a676915a092a5400783b06c6e0441db96"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#a6a44781cbe3dd6c55234638a1b63d4ef">PiecewisePolynomial</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a676915a092a5400783b06c6e0441db96">ZeroOrderHold</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; &amp;<a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a4e258af58745532546142965cd4444c7">breaks</a>, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &gt; &amp;samples)</td></tr>
<tr class="memdesc:a676915a092a5400783b06c6e0441db96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version of ZeroOrderHold(breaks, samples) that uses vector samples and <span class="tt">Eigen::VectorX&lt;T&gt;/MatrixX&lt;T&gt;</span> arguments.  <br /></td></tr>
<tr class="memitem:acd2146d6af5a8c5211df9c3f66d1984b" id="r_acd2146d6af5a8c5211df9c3f66d1984b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#a6a44781cbe3dd6c55234638a1b63d4ef">PiecewisePolynomial</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acd2146d6af5a8c5211df9c3f66d1984b">FirstOrderHold</a> (const std::vector&lt; T &gt; &amp;<a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a4e258af58745532546142965cd4444c7">breaks</a>, const std::vector&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &gt; &amp;samples)</td></tr>
<tr class="memdesc:acd2146d6af5a8c5211df9c3f66d1984b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a piecewise linear PiecewisePolynomial using matrix samples.  <br /></td></tr>
<tr class="memitem:a96b1b2ab23a48a0f1c4aa9afc54a33ef" id="r_a96b1b2ab23a48a0f1c4aa9afc54a33ef"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#a6a44781cbe3dd6c55234638a1b63d4ef">PiecewisePolynomial</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a96b1b2ab23a48a0f1c4aa9afc54a33ef">FirstOrderHold</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; &amp;<a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a4e258af58745532546142965cd4444c7">breaks</a>, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &gt; &amp;samples)</td></tr>
<tr class="memdesc:a96b1b2ab23a48a0f1c4aa9afc54a33ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version of FirstOrderHold(breaks, samples) that uses vector samples and Eigen VectorXd / <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95" title="A matrix of dynamic size, templated on scalar type.">MatrixX&lt;T&gt;</a> arguments.  <br /></td></tr>
<tr class="memitem:a85547d076bfdd0b984be17db18402bee" id="r_a85547d076bfdd0b984be17db18402bee"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#a6a44781cbe3dd6c55234638a1b63d4ef">PiecewisePolynomial</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a85547d076bfdd0b984be17db18402bee">CubicShapePreserving</a> (const std::vector&lt; T &gt; &amp;<a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a4e258af58745532546142965cd4444c7">breaks</a>, const std::vector&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &gt; &amp;samples, bool zero_end_point_derivatives=false)</td></tr>
<tr class="memdesc:a85547d076bfdd0b984be17db18402bee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a third order PiecewisePolynomial using vector samples, where each column of <span class="tt">samples</span> represents a sample point.  <br /></td></tr>
<tr class="memitem:ae800ad298124a2fcca1dc0ed1d6c062a" id="r_ae800ad298124a2fcca1dc0ed1d6c062a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#a6a44781cbe3dd6c55234638a1b63d4ef">PiecewisePolynomial</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae800ad298124a2fcca1dc0ed1d6c062a">CubicShapePreserving</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; &amp;<a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a4e258af58745532546142965cd4444c7">breaks</a>, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &gt; &amp;samples, bool zero_end_point_derivatives=false)</td></tr>
<tr class="memdesc:ae800ad298124a2fcca1dc0ed1d6c062a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version of CubicShapePreserving(breaks, samples,
zero_end_point_derivatives) that uses vector samples and Eigen VectorXd and <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95" title="A matrix of dynamic size, templated on scalar type.">MatrixX&lt;T&gt;</a> arguments.  <br /></td></tr>
<tr class="memitem:aba4275b536c162df6d8e2c06b4036f3a" id="r_aba4275b536c162df6d8e2c06b4036f3a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#a6a44781cbe3dd6c55234638a1b63d4ef">PiecewisePolynomial</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aba4275b536c162df6d8e2c06b4036f3a">CubicWithContinuousSecondDerivatives</a> (const std::vector&lt; T &gt; &amp;<a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a4e258af58745532546142965cd4444c7">breaks</a>, const std::vector&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &gt; &amp;samples, const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &amp;sample_dot_at_start, const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &amp;sample_dot_at_end)</td></tr>
<tr class="memdesc:aba4275b536c162df6d8e2c06b4036f3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a third order PiecewisePolynomial using matrix samples.  <br /></td></tr>
<tr class="memitem:ad0617b00fdc31ffb3fd08adb99f4c820" id="r_ad0617b00fdc31ffb3fd08adb99f4c820"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#a6a44781cbe3dd6c55234638a1b63d4ef">PiecewisePolynomial</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad0617b00fdc31ffb3fd08adb99f4c820">CubicWithContinuousSecondDerivatives</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; &amp;<a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a4e258af58745532546142965cd4444c7">breaks</a>, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &gt; &amp;samples, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; &amp;sample_dot_at_start, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; &amp;sample_dot_at_end)</td></tr>
<tr class="memdesc:ad0617b00fdc31ffb3fd08adb99f4c820"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version of <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#aba4275b536c162df6d8e2c06b4036f3a" title="Constructs a third order PiecewisePolynomial using matrix samples.">CubicWithContinuousSecondDerivatives()</a> that uses vector samples and Eigen VectorXd / <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95" title="A matrix of dynamic size, templated on scalar type.">MatrixX&lt;T&gt;</a> arguments.  <br /></td></tr>
<tr class="memitem:a929b7eb2cf12883a1698c1cf019f39ea" id="r_a929b7eb2cf12883a1698c1cf019f39ea"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#a6a44781cbe3dd6c55234638a1b63d4ef">PiecewisePolynomial</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a929b7eb2cf12883a1698c1cf019f39ea">CubicWithContinuousSecondDerivatives</a> (const std::vector&lt; T &gt; &amp;<a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a4e258af58745532546142965cd4444c7">breaks</a>, const std::vector&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &gt; &amp;samples, bool periodic_end_condition=false)</td></tr>
<tr class="memdesc:a929b7eb2cf12883a1698c1cf019f39ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a third order PiecewisePolynomial using matrix samples.  <br /></td></tr>
<tr class="memitem:a596c911a6efa7880a8482c432213f796" id="r_a596c911a6efa7880a8482c432213f796"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#a6a44781cbe3dd6c55234638a1b63d4ef">PiecewisePolynomial</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a596c911a6efa7880a8482c432213f796">CubicWithContinuousSecondDerivatives</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; &amp;<a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a4e258af58745532546142965cd4444c7">breaks</a>, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &gt; &amp;samples, bool periodic_end_condition=false)</td></tr>
<tr class="memdesc:a596c911a6efa7880a8482c432213f796"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version of CubicWithContinuousSecondDerivatives(breaks, samples) that uses vector samples and Eigen VectorXd / <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95" title="A matrix of dynamic size, templated on scalar type.">MatrixX&lt;T&gt;</a> arguments.  <br /></td></tr>
<tr class="memitem:a1f9ac065de97f612798acd5414c086b0" id="r_a1f9ac065de97f612798acd5414c086b0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#a6a44781cbe3dd6c55234638a1b63d4ef">PiecewisePolynomial</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f9ac065de97f612798acd5414c086b0">CubicHermite</a> (const std::vector&lt; T &gt; &amp;<a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a4e258af58745532546142965cd4444c7">breaks</a>, const std::vector&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &gt; &amp;samples, const std::vector&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &gt; &amp;samples_dot)</td></tr>
<tr class="memdesc:a1f9ac065de97f612798acd5414c086b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a third order PiecewisePolynomial using matrix samples and derivatives of samples (<span class="tt">samples_dot</span>); each matrix element of <span class="tt">samples_dot</span> represents the derivative with respect to the independent variable (e.g., the time derivative) of the corresponding entry in <span class="tt">samples</span>.  <br /></td></tr>
<tr class="memitem:a9fc6639f654b5602b63423314aff5650" id="r_a9fc6639f654b5602b63423314aff5650"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#a6a44781cbe3dd6c55234638a1b63d4ef">PiecewisePolynomial</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9fc6639f654b5602b63423314aff5650">CubicHermite</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; &amp;<a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a4e258af58745532546142965cd4444c7">breaks</a>, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &gt; &amp;samples, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &gt; &amp;samples_dot)</td></tr>
<tr class="memdesc:a9fc6639f654b5602b63423314aff5650"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version of CubicHermite(breaks, samples, samples_dot) that uses vector samples and Eigen VectorXd / <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95" title="A matrix of dynamic size, templated on scalar type.">MatrixX&lt;T&gt;</a> arguments.  <br /></td></tr>
<tr class="memitem:a3d80c4b93bcf4cf4a58e0a53e732f7d0" id="r_a3d80c4b93bcf4cf4a58e0a53e732f7d0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#a6a44781cbe3dd6c55234638a1b63d4ef">PiecewisePolynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d80c4b93bcf4cf4a58e0a53e732f7d0">LagrangeInterpolatingPolynomial</a> (const std::vector&lt; T &gt; &amp;times, const std::vector&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &gt; &amp;samples)</td></tr>
<tr class="memdesc:a3d80c4b93bcf4cf4a58e0a53e732f7d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a polynomial with a <em>single segment</em> of the lowest possible degree that passes through all of the sample points.  <br /></td></tr>
<tr class="memitem:a878e19dce9467fc1035ad21b7096b80a" id="r_a878e19dce9467fc1035ad21b7096b80a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#a6a44781cbe3dd6c55234638a1b63d4ef">PiecewisePolynomial</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a878e19dce9467fc1035ad21b7096b80a">LagrangeInterpolatingPolynomial</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; &amp;times, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &gt; &amp;samples)</td></tr>
<tr class="memdesc:a878e19dce9467fc1035ad21b7096b80a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version of LagrangeInterpolatingPolynomial(times, samples) that uses vector samples and Eigen VectorXd / <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95" title="A matrix of dynamic size, templated on scalar type.">MatrixX&lt;T&gt;</a> arguments.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-inherited" class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_classdrake_1_1trajectories_1_1_piecewise_trajectory"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_static_methods_classdrake_1_1trajectories_1_1_piecewise_trajectory')"><span class="dynarrow"><span class="arrowhead closed"></span></span>Static Public Member Functions inherited from <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html">PiecewiseTrajectory&lt; T &gt;</a></td></tr>
<tr class="memitem:a72da8a211fe992871a7c693731bb47f6 inherit pub_static_methods_classdrake_1_1trajectories_1_1_piecewise_trajectory" id="r_a72da8a211fe992871a7c693731bb47f6"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a72da8a211fe992871a7c693731bb47f6">RandomSegmentTimes</a> (int num_segments, std::default_random_engine &amp;generator)</td></tr>
<tr class="inherit_header pub_static_attribs_classdrake_1_1trajectories_1_1_piecewise_trajectory"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_static_attribs_classdrake_1_1trajectories_1_1_piecewise_trajectory')"><span class="dynarrow"><span class="arrowhead closed"></span></span>Static Public Attributes inherited from <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html">PiecewiseTrajectory&lt; T &gt;</a></td></tr>
<tr class="memitem:a0539f01602cd1ab9b25989206d302401 inherit pub_static_attribs_classdrake_1_1trajectories_1_1_piecewise_trajectory" id="r_a0539f01602cd1ab9b25989206d302401"><td class="memItemLeft" align="right" valign="top">static constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a0539f01602cd1ab9b25989206d302401">kEpsilonTime</a> = std::numeric_limits&lt;double&gt;::epsilon()</td></tr>
<tr class="memdesc:a0539f01602cd1ab9b25989206d302401 inherit pub_static_attribs_classdrake_1_1trajectories_1_1_piecewise_trajectory"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum delta quantity used for comparing time.  <br /></td></tr>
<tr class="inherit_header pro_methods_classdrake_1_1trajectories_1_1_piecewise_trajectory"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pro_methods_classdrake_1_1trajectories_1_1_piecewise_trajectory')"><span class="dynarrow"><span class="arrowhead closed"></span></span>Protected Member Functions inherited from <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html">PiecewiseTrajectory&lt; T &gt;</a></td></tr>
<tr class="memitem:a293c775020a0b5f25770dd398ea14f1d inherit pro_methods_classdrake_1_1trajectories_1_1_piecewise_trajectory" id="r_a293c775020a0b5f25770dd398ea14f1d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a293c775020a0b5f25770dd398ea14f1d">PiecewiseTrajectory</a> ()=default</td></tr>
<tr class="memitem:a205b86a6552919d515ba544c185c04c3 inherit pro_methods_classdrake_1_1trajectories_1_1_piecewise_trajectory" id="r_a205b86a6552919d515ba544c185c04c3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a205b86a6552919d515ba544c185c04c3">PiecewiseTrajectory</a> (const std::vector&lt; T &gt; &amp;<a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a4e258af58745532546142965cd4444c7">breaks</a>)</td></tr>
<tr class="memdesc:a205b86a6552919d515ba544c185c04c3 inherit pro_methods_classdrake_1_1trajectories_1_1_piecewise_trajectory"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code class="param">breaks</code> increments must be greater or equal to kEpsilonTime.  <br /></td></tr>
<tr class="memitem:a8973617cd17ac27655d3fd7d9d970d56 inherit pro_methods_classdrake_1_1trajectories_1_1_piecewise_trajectory" id="r_a8973617cd17ac27655d3fd7d9d970d56"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a8973617cd17ac27655d3fd7d9d970d56">do_start_time</a> () const override</td></tr>
<tr class="memitem:afc66a15124c3d9cfce830865935d3013 inherit pro_methods_classdrake_1_1trajectories_1_1_piecewise_trajectory" id="r_afc66a15124c3d9cfce830865935d3013"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#afc66a15124c3d9cfce830865935d3013">do_end_time</a> () const override</td></tr>
<tr class="memitem:a0f1bc48c32072f8a84aa295528a66440 inherit pro_methods_classdrake_1_1trajectories_1_1_piecewise_trajectory" id="r_a0f1bc48c32072f8a84aa295528a66440"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a0f1bc48c32072f8a84aa295528a66440">SegmentTimesEqual</a> (const <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#af360987538c584ed2a7c5ad8e2f3d6e4">PiecewiseTrajectory</a> &amp;b, double tol=<a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a0539f01602cd1ab9b25989206d302401">kEpsilonTime</a>) const</td></tr>
<tr class="memitem:a4e258af58745532546142965cd4444c7 inherit pro_methods_classdrake_1_1trajectories_1_1_piecewise_trajectory" id="r_a4e258af58745532546142965cd4444c7"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a4e258af58745532546142965cd4444c7">breaks</a> () const</td></tr>
<tr class="memitem:a20553098d60b2b9c52af43225676c9ec inherit pro_methods_classdrake_1_1trajectories_1_1_piecewise_trajectory" id="r_a20553098d60b2b9c52af43225676c9ec"><td class="memItemLeft" align="right" valign="top">std::vector&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a20553098d60b2b9c52af43225676c9ec">get_mutable_breaks</a> ()</td></tr>
<tr class="memitem:af360987538c584ed2a7c5ad8e2f3d6e4 inherit pro_methods_classdrake_1_1trajectories_1_1_piecewise_trajectory" id="r_af360987538c584ed2a7c5ad8e2f3d6e4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#af360987538c584ed2a7c5ad8e2f3d6e4">PiecewiseTrajectory</a> (const PiecewiseTrajectory &amp;)=default</td></tr>
<tr class="memitem:a7b6e4f3e6a9ec9cf152fa791b02e7c20 inherit pro_methods_classdrake_1_1trajectories_1_1_piecewise_trajectory" id="r_a7b6e4f3e6a9ec9cf152fa791b02e7c20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#af360987538c584ed2a7c5ad8e2f3d6e4">PiecewiseTrajectory</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a7b6e4f3e6a9ec9cf152fa791b02e7c20">operator=</a> (const <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#af360987538c584ed2a7c5ad8e2f3d6e4">PiecewiseTrajectory</a> &amp;)=default</td></tr>
<tr class="memitem:a65dc25e24cd2903a0861b9589065c897 inherit pro_methods_classdrake_1_1trajectories_1_1_piecewise_trajectory" id="r_a65dc25e24cd2903a0861b9589065c897"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a65dc25e24cd2903a0861b9589065c897">PiecewiseTrajectory</a> (PiecewiseTrajectory &amp;&amp;)=default</td></tr>
<tr class="memitem:a62b9da76ee468cc7549b129f39cedfdc inherit pro_methods_classdrake_1_1trajectories_1_1_piecewise_trajectory" id="r_a62b9da76ee468cc7549b129f39cedfdc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#af360987538c584ed2a7c5ad8e2f3d6e4">PiecewiseTrajectory</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a62b9da76ee468cc7549b129f39cedfdc">operator=</a> (<a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#af360987538c584ed2a7c5ad8e2f3d6e4">PiecewiseTrajectory</a> &amp;&amp;)=default</td></tr>
<tr class="inherit_header pro_methods_classdrake_1_1trajectories_1_1_trajectory"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pro_methods_classdrake_1_1trajectories_1_1_trajectory')"><span class="dynarrow"><span class="arrowhead closed"></span></span>Protected Member Functions inherited from <a class="el" href="classdrake_1_1trajectories_1_1_trajectory.html">Trajectory&lt; T &gt;</a></td></tr>
<tr class="memitem:a0d2a23aec55910c9e1102de7ab8c3249 inherit pro_methods_classdrake_1_1trajectories_1_1_trajectory" id="r_a0d2a23aec55910c9e1102de7ab8c3249"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_trajectory.html#a0d2a23aec55910c9e1102de7ab8c3249">Trajectory</a> ()=default</td></tr>
<tr class="memitem:a6b15b4592b800d6cf4d9273f46a2774b inherit pro_methods_classdrake_1_1trajectories_1_1_trajectory" id="r_a6b15b4592b800d6cf4d9273f46a2774b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_trajectory.html#a6b15b4592b800d6cf4d9273f46a2774b">Trajectory</a> (const Trajectory &amp;)=default</td></tr>
<tr class="memitem:a949b2361eb018dbb5e1039808bf73eb3 inherit pro_methods_classdrake_1_1trajectories_1_1_trajectory" id="r_a949b2361eb018dbb5e1039808bf73eb3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1trajectories_1_1_trajectory.html#a6b15b4592b800d6cf4d9273f46a2774b">Trajectory</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_trajectory.html#a949b2361eb018dbb5e1039808bf73eb3">operator=</a> (const <a class="el" href="classdrake_1_1trajectories_1_1_trajectory.html#a6b15b4592b800d6cf4d9273f46a2774b">Trajectory</a> &amp;)=default</td></tr>
<tr class="memitem:af752fbd39919690fbbe2110639682be7 inherit pro_methods_classdrake_1_1trajectories_1_1_trajectory" id="r_af752fbd39919690fbbe2110639682be7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_trajectory.html#af752fbd39919690fbbe2110639682be7">Trajectory</a> (Trajectory &amp;&amp;)=default</td></tr>
<tr class="memitem:ae83de2c19f5f6cf70844631f4014c8cc inherit pro_methods_classdrake_1_1trajectories_1_1_trajectory" id="r_ae83de2c19f5f6cf70844631f4014c8cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1trajectories_1_1_trajectory.html#a6b15b4592b800d6cf4d9273f46a2774b">Trajectory</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_trajectory.html#ae83de2c19f5f6cf70844631f4014c8cc">operator=</a> (<a class="el" href="classdrake_1_1trajectories_1_1_trajectory.html#a6b15b4592b800d6cf4d9273f46a2774b">Trajectory</a> &amp;&amp;)=default</td></tr>
</table>
<a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Member Typedef Documentation</h2>
<a id="a9c5cbf1ba95055937fdb8283769df797" name="a9c5cbf1ba95055937fdb8283769df797"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c5cbf1ba95055937fdb8283769df797">&#9670;&#160;</a></span>PolynomialMatrix</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt;<a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a>&lt;T&gt; &gt; <a class="el" href="#a9c5cbf1ba95055937fdb8283769df797">PolynomialMatrix</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a6a44781cbe3dd6c55234638a1b63d4ef" name="a6a44781cbe3dd6c55234638a1b63d4ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a44781cbe3dd6c55234638a1b63d4ef">&#9670;&#160;</a></span>PiecewisePolynomial() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PiecewisePolynomial </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an empty piecewise polynomial. </p>

</div>
</div>
<a id="acd5823d88e611200dc63daaf05eeb9d9" name="acd5823d88e611200dc63daaf05eeb9d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd5823d88e611200dc63daaf05eeb9d9">&#9670;&#160;</a></span>PiecewisePolynomial() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PiecewisePolynomial </td>
          <td>(</td>
          <td class="paramtype">const PiecewisePolynomial&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8c9575eec7fd062e42ed17407a337abc" name="a8c9575eec7fd062e42ed17407a337abc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c9575eec7fd062e42ed17407a337abc">&#9670;&#160;</a></span>PiecewisePolynomial() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PiecewisePolynomial </td>
          <td>(</td>
          <td class="paramtype">PiecewisePolynomial&lt; T &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a838cb1725eb9ba7896158fa9032ecdcc" name="a838cb1725eb9ba7896158fa9032ecdcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a838cb1725eb9ba7896158fa9032ecdcc">&#9670;&#160;</a></span>PiecewisePolynomial() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PiecewisePolynomial </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>constant_value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Single segment, constant value constructor over the interval [-∞, ∞]. </p>
<p>The constructed PiecewisePolynomial will return <span class="tt">constant_value</span> at every evaluated point (i.e., <span class="tt">value(t) = constant_value</span> ∀t ∈ [-∞, ∞]). </p>

</div>
</div>
<a id="a9145f61319cb888cb71fc58cebc8fe38" name="a9145f61319cb888cb71fc58cebc8fe38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9145f61319cb888cb71fc58cebc8fe38">&#9670;&#160;</a></span>PiecewisePolynomial() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">PiecewisePolynomial </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="#a9c5cbf1ba95055937fdb8283769df797">PolynomialMatrix</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>polynomials_matrix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>breaks</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a PiecewisePolynomial using matrix-output Polynomials defined over each segment. </p>
<dl class="section pre"><dt>Precondition</dt><dd><span class="tt">polynomials.size() == breaks.size() - 1</span> </dd></dl>

</div>
</div>
<a id="a855e5579cf5a007bc3406051a2d5e296" name="a855e5579cf5a007bc3406051a2d5e296"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a855e5579cf5a007bc3406051a2d5e296">&#9670;&#160;</a></span>PiecewisePolynomial() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">PiecewisePolynomial </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a>&lt; T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>polynomials</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>breaks</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a PiecewisePolynomial using scalar-output Polynomials defined over each segment. </p>
<dl class="section pre"><dt>Precondition</dt><dd><span class="tt">polynomials.size() == breaks.size() - 1</span> </dd></dl>

</div>
</div>
<a id="a04aa32f958635709b5a538f99c092ba0" name="a04aa32f958635709b5a538f99c092ba0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04aa32f958635709b5a538f99c092ba0">&#9670;&#160;</a></span>~PiecewisePolynomial()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="#a6a44781cbe3dd6c55234638a1b63d4ef">PiecewisePolynomial</a> </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel final">final</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="a6697b9094ce308f8a5445604076181e8" name="a6697b9094ce308f8a5445604076181e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6697b9094ce308f8a5445604076181e8">&#9670;&#160;</a></span>AddBreak()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int AddBreak </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>new_break</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a break at the specified time. </p>
<p>It does not change the value of the trajectory at any point but the number of segments increases by 1. </p><dl class="section return"><dt>Returns</dt><dd>the index of the new break. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">new_break</span> is not within the trajectory's time range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>If <span class="tt">new_break</span> is within <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a0539f01602cd1ab9b25989206d302401" title="Minimum delta quantity used for comparing time.">PiecewiseTrajectory::kEpsilonTime</a> from an existing break, the new break will be silently ignored. Returns the index of the existing break. </dd></dl>

</div>
</div>
<a id="a90e19253a0e27427859a34ab7b2f81ba" name="a90e19253a0e27427859a34ab7b2f81ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90e19253a0e27427859a34ab7b2f81ba">&#9670;&#160;</a></span>AppendCubicHermiteSegment()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void AppendCubicHermiteSegment </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>time</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>sample</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>sample_dot</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The CubicHermite spline construction has a nice property of being incremental (each segment can be solved independently). </p>
<p>Given a new sample and it's derivative, this method adds one segment to the end of <span class="tt">this</span> where the start sample and derivative are taken as the value and derivative at the final break of <span class="tt">this</span>.</p>
<dl class="section pre"><dt>Precondition</dt><dd><span class="tt">this</span> is not <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a644718bb2fb240de962dc3c9a1fdf0dc" title="Returns true if this trajectory has no breaks/samples/polynomials.">empty()</a> </dd>
<dd>
<span class="tt">time</span> &gt; <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a4c1604e170d921c073e4fba715622507">end_time()</a> </dd>
<dd>
<span class="tt">sample</span> and <span class="tt">sample_dot</span> must have size <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#adcc8b67a7b625544afb0ae19bcf76564" title="Returns the row count of the output matrices.">rows()</a> x <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#ad6c1acca5de9ae9bed71bbafb0051de3" title="Returns the column count of the output matrices.">cols()</a>. </dd></dl>

</div>
</div>
<a id="ae08f90c486157496f359c38655f74985" name="ae08f90c486157496f359c38655f74985"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae08f90c486157496f359c38655f74985">&#9670;&#160;</a></span>AppendFirstOrderSegment()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void AppendFirstOrderSegment </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>time</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>sample</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a new sample, this method adds one segment to the end of <span class="tt">this</span> using a first-order hold, where the start sample is taken as the value at the final break of <span class="tt">this</span>. </p>

</div>
</div>
<a id="a45001b70f1a92e1d01778b69bb61adf3" name="a45001b70f1a92e1d01778b69bb61adf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45001b70f1a92e1d01778b69bb61adf3">&#9670;&#160;</a></span>Block()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a6a44781cbe3dd6c55234638a1b63d4ef">PiecewisePolynomial</a> Block </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>start_row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>start_col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>block_rows</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>block_cols</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts a trajectory representing a block of size (block_rows, block_cols) starting at (start_row, start_col) from the <a class="el" href="classdrake_1_1multibody_1_1_piecewise_polynomial.html" title="A scalar multi-variate piecewise polynomial.">PiecewisePolynomial</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classdrake_1_1multibody_1_1_piecewise_polynomial.html" title="A scalar multi-variate piecewise polynomial.">PiecewisePolynomial</a> such that ret.value(t) = this.value(t).block(i,j,p,q); </dd></dl>

</div>
</div>
<a id="ad6c1acca5de9ae9bed71bbafb0051de3" name="ad6c1acca5de9ae9bed71bbafb0051de3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6c1acca5de9ae9bed71bbafb0051de3">&#9670;&#160;</a></span>cols()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Index cols </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the column count of the output matrices. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a644718bb2fb240de962dc3c9a1fdf0dc" title="Returns true if this trajectory has no breaks/samples/polynomials.">empty()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a75d7ffe2f4e1a808aaeb76a871f772e2" name="a75d7ffe2f4e1a808aaeb76a871f772e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75d7ffe2f4e1a808aaeb76a871f772e2">&#9670;&#160;</a></span>ConcatenateInTime()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ConcatenateInTime </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a6a44781cbe3dd6c55234638a1b63d4ef">PiecewisePolynomial</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenates <span class="tt">other</span> to the end of <span class="tt">this</span>. </p>
<dl class="section warning"><dt>Warning</dt><dd>The resulting PiecewisePolynomial will only be continuous to the degree that the first <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> of <span class="tt">other</span> is continuous with the last <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> of <span class="tt">this</span>. See warning about evaluating discontinuous derivatives at breaks in <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a405f92e0e677a316b9a8ed8ec841befd" title="Returns a PiecewisePolynomial where each segment is the specified derivative of the corresponding seg...">derivative()</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>PiecewisePolynomial instance to concatenate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if trajectories' dimensions do not match each other (either <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#adcc8b67a7b625544afb0ae19bcf76564" title="Returns the row count of the output matrices.">rows()</a> or <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#ad6c1acca5de9ae9bed71bbafb0051de3" title="Returns the column count of the output matrices.">cols()</a> does not match between this and <span class="tt">other</span>). </td></tr>
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">this-&gt;<a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a4c1604e170d921c073e4fba715622507">end_time()</a></span> and <span class="tt">other-&gt;<a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a1019f41dcfe440c98c91029f4b0b0bc0">start_time()</a></span> are not within <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a0539f01602cd1ab9b25989206d302401" title="Minimum delta quantity used for comparing time.">PiecewiseTrajectory&lt;T&gt;::kEpsilonTime</a> from each other. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9fc6639f654b5602b63423314aff5650" name="a9fc6639f654b5602b63423314aff5650"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fc6639f654b5602b63423314aff5650">&#9670;&#160;</a></span>CubicHermite() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a6a44781cbe3dd6c55234638a1b63d4ef">PiecewisePolynomial</a>&lt; T &gt; CubicHermite </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>breaks</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>samples</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>samples_dot</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Version of CubicHermite(breaks, samples, samples_dot) that uses vector samples and Eigen VectorXd / <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95" title="A matrix of dynamic size, templated on scalar type.">MatrixX&lt;T&gt;</a> arguments. </p>
<p>Corresponding columns of <span class="tt">samples</span> and <span class="tt">samples_dot</span> are used as the sample point and independent variable derivative, respectively.</p>
<dl class="section pre"><dt>Precondition</dt><dd><span class="tt">samples.cols() == samples_dot.cols() == breaks.size()</span>. </dd></dl>

</div>
</div>
<a id="a1f9ac065de97f612798acd5414c086b0" name="a1f9ac065de97f612798acd5414c086b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f9ac065de97f612798acd5414c086b0">&#9670;&#160;</a></span>CubicHermite() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a6a44781cbe3dd6c55234638a1b63d4ef">PiecewisePolynomial</a>&lt; T &gt; CubicHermite </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>breaks</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>samples</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>samples_dot</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a third order PiecewisePolynomial using matrix samples and derivatives of samples (<span class="tt">samples_dot</span>); each matrix element of <span class="tt">samples_dot</span> represents the derivative with respect to the independent variable (e.g., the time derivative) of the corresponding entry in <span class="tt">samples</span>. </p>
<p>Each segment is fully specified by <span class="tt">samples</span> and <span class="tt">sample_dot</span> at both ends. Second derivatives are not continuous. </p>

</div>
</div>
<a id="ae800ad298124a2fcca1dc0ed1d6c062a" name="ae800ad298124a2fcca1dc0ed1d6c062a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae800ad298124a2fcca1dc0ed1d6c062a">&#9670;&#160;</a></span>CubicShapePreserving() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a6a44781cbe3dd6c55234638a1b63d4ef">PiecewisePolynomial</a>&lt; T &gt; CubicShapePreserving </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>breaks</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>samples</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>zero_end_point_derivatives</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Version of CubicShapePreserving(breaks, samples,
zero_end_point_derivatives) that uses vector samples and Eigen VectorXd and <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95" title="A matrix of dynamic size, templated on scalar type.">MatrixX&lt;T&gt;</a> arguments. </p>
<p>Each column of <span class="tt">samples</span> represents a sample point.</p>
<dl class="section pre"><dt>Precondition</dt><dd><span class="tt">samples.cols() == breaks.size()</span>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>under the conditions specified under <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#coefficient_construction_methods">coefficient_construction_methods</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a85547d076bfdd0b984be17db18402bee" name="a85547d076bfdd0b984be17db18402bee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85547d076bfdd0b984be17db18402bee">&#9670;&#160;</a></span>CubicShapePreserving() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a6a44781cbe3dd6c55234638a1b63d4ef">PiecewisePolynomial</a>&lt; T &gt; CubicShapePreserving </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>breaks</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>samples</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>zero_end_point_derivatives</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a third order PiecewisePolynomial using vector samples, where each column of <span class="tt">samples</span> represents a sample point. </p>
<p>First derivatives are chosen to be "shape preserving", i.e. if <span class="tt">samples</span> is monotonic within some interval, the interpolated data will also be monotonic. The second derivative is not guaranteed to be smooth across the entire spline.</p>
<p>MATLAB calls this method "pchip" (short for "Piecewise Cubic Hermite
Interpolating Polynomial"), and provides a nice description in their documentation. <a href="http://home.uchicago.edu/~sctchoi/courses/cs138/interp.pdf">http://home.uchicago.edu/~sctchoi/courses/cs138/interp.pdf</a> is also a good reference.</p>
<p>If <span class="tt">zero_end_point_derivatives</span> is <span class="tt">false</span>, the first and last first derivative is chosen using a non-centered, shape-preserving three-point formulae. See equation (2.10) in the following reference for more details. <a href="http://www.mi.sanu.ac.rs/~gvm/radovi/mon.pdf">http://www.mi.sanu.ac.rs/~gvm/radovi/mon.pdf</a> If <span class="tt">zero_end_point_derivatives</span> is <span class="tt">true</span>, they are set to zeros.</p>
<p>If <span class="tt">zero_end_point_derivatives</span> is <span class="tt">false</span>, <span class="tt"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a4e258af58745532546142965cd4444c7">breaks</a></span> and <span class="tt">samples</span> must have at least 3 elements for the algorithm to determine the first derivatives.</p>
<p>If <span class="tt">zero_end_point_derivatives</span> is <span class="tt">true</span>, <span class="tt"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a4e258af58745532546142965cd4444c7">breaks</a></span> and <span class="tt">samples</span> may have 2 or more elements. For the 2 elements case, the result is equivalent to computing a cubic polynomial whose values are given by <span class="tt">samples</span>, and derivatives set to zero.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if:<ul>
<li><span class="tt"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a4e258af58745532546142965cd4444c7">breaks</a></span> has length smaller than 3 and <span class="tt">zero_end_point_derivatives</span> is <span class="tt">false</span>,</li>
<li><span class="tt"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a4e258af58745532546142965cd4444c7">breaks</a></span> has length smaller than 2 and <span class="tt">zero_end_point_derivatives</span> is true.</li>
</ul>
</td></tr>
    <tr><td class="paramname">std::exception</td><td>under the conditions specified under <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#coefficient_construction_methods">coefficient_construction_methods</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a596c911a6efa7880a8482c432213f796" name="a596c911a6efa7880a8482c432213f796"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a596c911a6efa7880a8482c432213f796">&#9670;&#160;</a></span>CubicWithContinuousSecondDerivatives() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a6a44781cbe3dd6c55234638a1b63d4ef">PiecewisePolynomial</a>&lt; T &gt; CubicWithContinuousSecondDerivatives </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>breaks</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>samples</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>periodic_end_condition</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Version of CubicWithContinuousSecondDerivatives(breaks, samples) that uses vector samples and Eigen VectorXd / <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95" title="A matrix of dynamic size, templated on scalar type.">MatrixX&lt;T&gt;</a> arguments. </p>
<p>Each column of <span class="tt">samples</span> represents a sample point.</p>
<dl class="section pre"><dt>Precondition</dt><dd><span class="tt">samples.cols() == breaks.size()</span>. </dd></dl>

</div>
</div>
<a id="ad0617b00fdc31ffb3fd08adb99f4c820" name="ad0617b00fdc31ffb3fd08adb99f4c820"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0617b00fdc31ffb3fd08adb99f4c820">&#9670;&#160;</a></span>CubicWithContinuousSecondDerivatives() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a6a44781cbe3dd6c55234638a1b63d4ef">PiecewisePolynomial</a>&lt; T &gt; CubicWithContinuousSecondDerivatives </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>breaks</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>samples</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>sample_dot_at_start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>sample_dot_at_end</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Version of <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#aba4275b536c162df6d8e2c06b4036f3a" title="Constructs a third order PiecewisePolynomial using matrix samples.">CubicWithContinuousSecondDerivatives()</a> that uses vector samples and Eigen VectorXd / <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95" title="A matrix of dynamic size, templated on scalar type.">MatrixX&lt;T&gt;</a> arguments. </p>
<p>Each column of <span class="tt">samples</span> represents a sample point.</p>
<dl class="section pre"><dt>Precondition</dt><dd><span class="tt">samples.cols() == breaks.size()</span>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>under the conditions specified under <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#coefficient_construction_methods">coefficient_construction_methods</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a929b7eb2cf12883a1698c1cf019f39ea" name="a929b7eb2cf12883a1698c1cf019f39ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a929b7eb2cf12883a1698c1cf019f39ea">&#9670;&#160;</a></span>CubicWithContinuousSecondDerivatives() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a6a44781cbe3dd6c55234638a1b63d4ef">PiecewisePolynomial</a>&lt; T &gt; CubicWithContinuousSecondDerivatives </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>breaks</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>samples</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>periodic_end_condition</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a third order PiecewisePolynomial using matrix samples. </p>
<p>The PiecewisePolynomial is constructed such that the interior segments have the same value, first and second derivatives at <span class="tt"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a4e258af58745532546142965cd4444c7">breaks</a></span>. If <span class="tt">periodic_end_condition</span> is <span class="tt">false</span> (default), then the "Not-a-sample" end condition is used here, which means the third derivatives are continuous for the first two and last two segments. If <span class="tt">periodic_end_condition</span> is <span class="tt">true</span>, then the first and second derivatives between the end of the last segment and the beginning of the first segment will be continuous. Note that the periodic end condition does not require the first and last sample to be collocated, nor does it add an additional sample to connect the first and last segments. Only first and second derivative continuity is enforced. See <a href="https://en.wikipedia.org/wiki/Spline_interpolation">https://en.wikipedia.org/wiki/Spline_interpolation</a> and <a href="https://web.archive.org/web/20140125011904/https://www.math.uh.edu/~jingqiu/math4364/spline.pdf">https://web.archive.org/web/20140125011904/https://www.math.uh.edu/~jingqiu/math4364/spline.pdf</a> for more about cubic splines and their end conditions. The MATLAB docs for methods "spline" and "csape" are also good references.</p>
<dl class="section pre"><dt>Precondition</dt><dd><span class="tt"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a4e258af58745532546142965cd4444c7">breaks</a></span> and <span class="tt">samples</span> must have at least 3 elements. If <span class="tt">periodic_end_condition</span> is <span class="tt">true</span>, then for two samples, it would produce a straight line (use <span class="tt"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#acd2146d6af5a8c5211df9c3f66d1984b" title="Constructs a piecewise linear PiecewisePolynomial using matrix samples.">FirstOrderHold</a></span> for this instead), and if <span class="tt">periodic_end_condition</span> is <span class="tt">false</span> the problem is ill-defined. </dd></dl>

</div>
</div>
<a id="aba4275b536c162df6d8e2c06b4036f3a" name="aba4275b536c162df6d8e2c06b4036f3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba4275b536c162df6d8e2c06b4036f3a">&#9670;&#160;</a></span>CubicWithContinuousSecondDerivatives() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a6a44781cbe3dd6c55234638a1b63d4ef">PiecewisePolynomial</a>&lt; T &gt; CubicWithContinuousSecondDerivatives </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>breaks</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>samples</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>sample_dot_at_start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>sample_dot_at_end</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a third order PiecewisePolynomial using matrix samples. </p>
<p>The PiecewisePolynomial is constructed such that the interior segments have the same value, first and second derivatives at <span class="tt"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a4e258af58745532546142965cd4444c7">breaks</a></span>. <span class="tt">sample_dot_at_start</span> and <span class="tt">sample_dot_at_end</span> are used for the first and last first derivatives.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">sample_dot_at_start</span> or <span class="tt">sample_dot_at_end</span> and <span class="tt">samples</span> have inconsistent dimensions. </td></tr>
    <tr><td class="paramname">std::exception</td><td>under the conditions specified under <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#coefficient_construction_methods">coefficient_construction_methods</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a405f92e0e677a316b9a8ed8ec841befd" name="a405f92e0e677a316b9a8ed8ec841befd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a405f92e0e677a316b9a8ed8ec841befd">&#9670;&#160;</a></span>derivative()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a6a44781cbe3dd6c55234638a1b63d4ef">PiecewisePolynomial</a>&lt; T &gt; derivative </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>derivative_order</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a PiecewisePolynomial where each segment is the specified derivative of the corresponding segment in <span class="tt">this</span>. </p>
<p>Any rules or limitations of Polynomial::derivative() also apply to this function.</p>
<p>Derivatives evaluated at non-differentiable points return the value at the left hand side of the interval. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">derivative_order</td><td>The order of the derivative, namely, if <span class="tt">derivative_order</span> = n, the n'th derivative of the polynomial will be returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>In the event of discontinuous derivatives evaluated at breaks, it is not defined which polynomial (i.e., to the left or right of the break) will be the one that is evaluated at the break. </dd></dl>

</div>
</div>
<a id="a644718bb2fb240de962dc3c9a1fdf0dc" name="a644718bb2fb240de962dc3c9a1fdf0dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a644718bb2fb240de962dc3c9a1fdf0dc">&#9670;&#160;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool empty </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <span class="tt">true</span> if this trajectory has no breaks/samples/polynomials. </p>

</div>
</div>
<a id="a96b1b2ab23a48a0f1c4aa9afc54a33ef" name="a96b1b2ab23a48a0f1c4aa9afc54a33ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96b1b2ab23a48a0f1c4aa9afc54a33ef">&#9670;&#160;</a></span>FirstOrderHold() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a6a44781cbe3dd6c55234638a1b63d4ef">PiecewisePolynomial</a>&lt; T &gt; FirstOrderHold </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>breaks</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>samples</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Version of FirstOrderHold(breaks, samples) that uses vector samples and Eigen VectorXd / <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95" title="A matrix of dynamic size, templated on scalar type.">MatrixX&lt;T&gt;</a> arguments. </p>
<p>Each column of <span class="tt">samples</span> represents a sample point.</p>
<dl class="section pre"><dt>Precondition</dt><dd><span class="tt">samples.cols() == breaks.size()</span> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>under the conditions specified under <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#coefficient_construction_methods">coefficient_construction_methods</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acd2146d6af5a8c5211df9c3f66d1984b" name="acd2146d6af5a8c5211df9c3f66d1984b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd2146d6af5a8c5211df9c3f66d1984b">&#9670;&#160;</a></span>FirstOrderHold() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a6a44781cbe3dd6c55234638a1b63d4ef">PiecewisePolynomial</a>&lt; T &gt; FirstOrderHold </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>breaks</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>samples</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a piecewise linear PiecewisePolynomial using matrix samples. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>under the conditions specified under <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#coefficient_construction_methods">coefficient_construction_methods</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acc499221b2ff0630d2b79d1fc9ec61d4" name="acc499221b2ff0630d2b79d1fc9ec61d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc499221b2ff0630d2b79d1fc9ec61d4">&#9670;&#160;</a></span>getPolynomial()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a>&lt; T &gt; &amp; getPolynomial </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>segment_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Index</td>          <td class="paramname"><span class="paramname"><em>row</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Index</td>          <td class="paramname"><span class="paramname"><em>col</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> with the given matrix row and column index that corresponds to the given segment index. </p>
<p>Equivalent to <span class="tt">getPolynomialMatrix(segment_index)(row, col)</span>. </p><dl class="section note"><dt>Note</dt><dd>Calls <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a0a4ac30a258a47b6ea610f16f4accece">PiecewiseTrajectory&lt;T&gt;::segment_number_range_check()</a> to validate <span class="tt">segment_index</span>. </dd></dl>

</div>
</div>
<a id="a33b5e4a75a36128eb0f8d16e29789b09" name="a33b5e4a75a36128eb0f8d16e29789b09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33b5e4a75a36128eb0f8d16e29789b09">&#9670;&#160;</a></span>getPolynomialMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="#a9c5cbf1ba95055937fdb8283769df797">PolynomialMatrix</a> &amp; getPolynomialMatrix </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>segment_index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the matrix of Polynomials corresponding to the given segment index. </p>
<dl class="section warning"><dt>Warning</dt><dd><span class="tt">segment_index</span> is not checked for validity. </dd></dl>

</div>
</div>
<a id="aa5a111a1944f16bb21873433d4b7b31d" name="aa5a111a1944f16bb21873433d4b7b31d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5a111a1944f16bb21873433d4b7b31d">&#9670;&#160;</a></span>getSegmentPolynomialDegree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int getSegmentPolynomialDegree </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>segment_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Index</td>          <td class="paramname"><span class="paramname"><em>row</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Index</td>          <td class="paramname"><span class="paramname"><em>col</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the degree of the <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> with the given matrix row and column index that corresponds to the given segment index. </p>
<p>Equivalent to <span class="tt">getPolynomial(segment_index, row, col).GetDegree()</span>. </p>

</div>
</div>
<a id="af53fa90507df925e5fe8006558edbdf3" name="af53fa90507df925e5fe8006558edbdf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af53fa90507df925e5fe8006558edbdf3">&#9670;&#160;</a></span>integral() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a6a44781cbe3dd6c55234638a1b63d4ef">PiecewisePolynomial</a>&lt; T &gt; integral </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>value_at_start_time</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a PiecewisePolynomial that is the indefinite integral of this one. </p>
<p>Any rules or limitations of Polynomial::integral() also apply to this function.</p>
<p>If <span class="tt">value_at_start_time</span> is given, it does the following only for the first segment: adds <span class="tt">value_at_start_time(row,col)</span> as the constant term (zeroth-order coefficient) of the resulting <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a>. </p>

</div>
</div>
<a id="aeaceab81f8d6fd7e3af6d32b076fea0a" name="aeaceab81f8d6fd7e3af6d32b076fea0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaceab81f8d6fd7e3af6d32b076fea0a">&#9670;&#160;</a></span>integral() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a6a44781cbe3dd6c55234638a1b63d4ef">PiecewisePolynomial</a>&lt; T &gt; integral </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>value_at_start_time</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.0</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a PiecewisePolynomial that is the indefinite integral of this one. </p>
<p>Any rules or limitations of Polynomial::integral() also apply to this function.</p>
<p>If <span class="tt">value_at_start_time</span> is given, it does the following only for the first segment: adds that constant as the constant term (zeroth-order coefficient) of the resulting <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a>. </p>

</div>
</div>
<a id="a5d7edaa991443e887ca36e0fd20b96c7" name="a5d7edaa991443e887ca36e0fd20b96c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d7edaa991443e887ca36e0fd20b96c7">&#9670;&#160;</a></span>isApprox()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool isApprox </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a6a44781cbe3dd6c55234638a1b63d4ef">PiecewisePolynomial</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>tol</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#af8777bc10296f9d39d52753861110e26">ToleranceType</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>tol_type</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespacedrake.html#af8777bc10296f9d39d52753861110e26af460a96ab20647996c15854794763384">ToleranceType::kRelative</a></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether a PiecewisePolynomial is approximately equal to this one by calling <a class="el" href="classdrake_1_1_polynomial.html#ad96f76c37313cb0d62582faccf358345" title="Checks if a Polynomial is approximately equal to this one.">Polynomial&lt;T&gt;::CoefficientsAlmostEqual()</a> on every element of every segment. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1_polynomial.html#ad96f76c37313cb0d62582faccf358345" title="Checks if a Polynomial is approximately equal to this one.">Polynomial&lt;T&gt;::CoefficientsAlmostEqual()</a>. </dd></dl>

</div>
</div>
<a id="a878e19dce9467fc1035ad21b7096b80a" name="a878e19dce9467fc1035ad21b7096b80a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a878e19dce9467fc1035ad21b7096b80a">&#9670;&#160;</a></span>LagrangeInterpolatingPolynomial() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a6a44781cbe3dd6c55234638a1b63d4ef">PiecewisePolynomial</a>&lt; T &gt; LagrangeInterpolatingPolynomial </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>times</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>samples</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Version of LagrangeInterpolatingPolynomial(times, samples) that uses vector samples and Eigen VectorXd / <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95" title="A matrix of dynamic size, templated on scalar type.">MatrixX&lt;T&gt;</a> arguments. </p>
<p>Each column of <span class="tt">samples</span> represents a sample point.</p>
<dl class="section pre"><dt>Precondition</dt><dd><span class="tt">samples.cols() == times.size()</span>. </dd></dl>

</div>
</div>
<a id="a3d80c4b93bcf4cf4a58e0a53e732f7d0" name="a3d80c4b93bcf4cf4a58e0a53e732f7d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d80c4b93bcf4cf4a58e0a53e732f7d0">&#9670;&#160;</a></span>LagrangeInterpolatingPolynomial() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a6a44781cbe3dd6c55234638a1b63d4ef">PiecewisePolynomial</a> LagrangeInterpolatingPolynomial </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>times</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>samples</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a polynomial with a <em>single segment</em> of the lowest possible degree that passes through all of the sample points. </p>
<p>See "polynomial
interpolation" and/or "Lagrange polynomial" on Wikipedia for more information. </p><dl class="section pre"><dt>Precondition</dt><dd><span class="tt">times</span> must be monotonically increasing. </dd>
<dd>
<span class="tt">samples.size() == times.size()</span>. </dd></dl>

</div>
</div>
<a id="a7495e58bd96d928d186092e155c413ad" name="a7495e58bd96d928d186092e155c413ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7495e58bd96d928d186092e155c413ad">&#9670;&#160;</a></span>operator*()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="#a6a44781cbe3dd6c55234638a1b63d4ef">PiecewisePolynomial</a> operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a6a44781cbe3dd6c55234638a1b63d4ef">PiecewisePolynomial</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies each <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> in the <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a9c5cbf1ba95055937fdb8283769df797">PolynomialMatrix</a> of <span class="tt">other</span> by the corresponding <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> in the <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a9c5cbf1ba95055937fdb8283769df797">PolynomialMatrix</a> of <span class="tt">this</span> (i.e., a coefficient-wise multiplication). </p>
<p>If <span class="tt">this</span> corresponds to t² and <span class="tt">other</span> corresponds to t³, <span class="tt">this *= other</span> will correspond to t⁵. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if every element of <span class="tt">other.get_segment_times()</span> is not within <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a0539f01602cd1ab9b25989206d302401" title="Minimum delta quantity used for comparing time.">PiecewiseTrajectory::kEpsilonTime</a> from <span class="tt">this-&gt;<a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#ab5b1a0b2d9113c656018bcace89985b4">get_segment_times()</a></span>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a132ba8fdc66d6182646b9b4f80c97507" name="a132ba8fdc66d6182646b9b4f80c97507"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a132ba8fdc66d6182646b9b4f80c97507">&#9670;&#160;</a></span>operator*=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a6a44781cbe3dd6c55234638a1b63d4ef">PiecewisePolynomial</a> &amp; operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a6a44781cbe3dd6c55234638a1b63d4ef">PiecewisePolynomial</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies each <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> in the <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a9c5cbf1ba95055937fdb8283769df797">PolynomialMatrix</a> of <span class="tt">other</span> by the corresponding <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> in the <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a9c5cbf1ba95055937fdb8283769df797">PolynomialMatrix</a> of <span class="tt">this</span> (i.e., a coefficient-wise multiplication), storing the result in <span class="tt">this</span>. </p>
<p>If <span class="tt">this</span> corresponds to t² and <span class="tt">other</span> corresponds to t³, <span class="tt">this *= other</span> will correspond to t⁵. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if every element of <span class="tt">other.get_segment_times()</span> is not within <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a0539f01602cd1ab9b25989206d302401" title="Minimum delta quantity used for comparing time.">PiecewiseTrajectory::kEpsilonTime</a> from <span class="tt">this-&gt;<a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#ab5b1a0b2d9113c656018bcace89985b4">get_segment_times()</a></span>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a87952ec710e902557114a6d53d39734e" name="a87952ec710e902557114a6d53d39734e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87952ec710e902557114a6d53d39734e">&#9670;&#160;</a></span>operator+() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="#a6a44781cbe3dd6c55234638a1b63d4ef">PiecewisePolynomial</a> operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>coeff</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad838f10606e844eac52b6553ba5acfd0" name="ad838f10606e844eac52b6553ba5acfd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad838f10606e844eac52b6553ba5acfd0">&#9670;&#160;</a></span>operator+() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="#a6a44781cbe3dd6c55234638a1b63d4ef">PiecewisePolynomial</a> operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a6a44781cbe3dd6c55234638a1b63d4ef">PiecewisePolynomial</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds each <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> in the <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a9c5cbf1ba95055937fdb8283769df797">PolynomialMatrix</a> of <span class="tt">other</span> to the corresponding <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> in the <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a9c5cbf1ba95055937fdb8283769df797">PolynomialMatrix</a> of <span class="tt">this</span>. </p>
<p>If <span class="tt">this</span> corresponds to t² and <span class="tt">other</span> corresponds to t³, <span class="tt">this + other</span> will correspond to t³ + t². </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if every element of <span class="tt">other.get_segment_times()</span> is not within <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a0539f01602cd1ab9b25989206d302401" title="Minimum delta quantity used for comparing time.">PiecewiseTrajectory::kEpsilonTime</a> from <span class="tt">this-&gt;<a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#ab5b1a0b2d9113c656018bcace89985b4">get_segment_times()</a></span>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a31232077298203598bab7b730a73b8b2" name="a31232077298203598bab7b730a73b8b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31232077298203598bab7b730a73b8b2">&#9670;&#160;</a></span>operator+=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a6a44781cbe3dd6c55234638a1b63d4ef">PiecewisePolynomial</a> &amp; operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>coeff</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2a12a957f3f33854c28f533f571c9592" name="a2a12a957f3f33854c28f533f571c9592"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a12a957f3f33854c28f533f571c9592">&#9670;&#160;</a></span>operator+=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a6a44781cbe3dd6c55234638a1b63d4ef">PiecewisePolynomial</a> &amp; operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a6a44781cbe3dd6c55234638a1b63d4ef">PiecewisePolynomial</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds each <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> in the <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a9c5cbf1ba95055937fdb8283769df797">PolynomialMatrix</a> of <span class="tt">other</span> to the corresponding <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> in the <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a9c5cbf1ba95055937fdb8283769df797">PolynomialMatrix</a> of <span class="tt">this</span>, storing the result in <span class="tt">this</span>. </p>
<p>If <span class="tt">this</span> corresponds to t² and <span class="tt">other</span> corresponds to t³, <span class="tt">this += other</span> will correspond to t³ + t². </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if every element of <span class="tt">other.get_segment_times()</span> is not within <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a0539f01602cd1ab9b25989206d302401" title="Minimum delta quantity used for comparing time.">PiecewiseTrajectory::kEpsilonTime</a> from <span class="tt">this-&gt;<a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#ab5b1a0b2d9113c656018bcace89985b4">get_segment_times()</a></span>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac3fb3016c2ae2b3bc37459710539e1fa" name="ac3fb3016c2ae2b3bc37459710539e1fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3fb3016c2ae2b3bc37459710539e1fa">&#9670;&#160;</a></span>operator-() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="#a6a44781cbe3dd6c55234638a1b63d4ef">PiecewisePolynomial</a> operator- </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements unary minus operator. </p>
<p>Multiplies each <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> in <span class="tt">this</span> by -1. </p>

</div>
</div>
<a id="a9bd57b84091cef3694aee370fa189735" name="a9bd57b84091cef3694aee370fa189735"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bd57b84091cef3694aee370fa189735">&#9670;&#160;</a></span>operator-() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="#a6a44781cbe3dd6c55234638a1b63d4ef">PiecewisePolynomial</a> operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>coeff</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a359271510bcf12db604f2e7572c45839" name="a359271510bcf12db604f2e7572c45839"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a359271510bcf12db604f2e7572c45839">&#9670;&#160;</a></span>operator-() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="#a6a44781cbe3dd6c55234638a1b63d4ef">PiecewisePolynomial</a> operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a6a44781cbe3dd6c55234638a1b63d4ef">PiecewisePolynomial</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtracts each <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> in the <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a9c5cbf1ba95055937fdb8283769df797">PolynomialMatrix</a> of <span class="tt">other</span> from the corresponding <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> in the <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a9c5cbf1ba95055937fdb8283769df797">PolynomialMatrix</a> of <span class="tt">this</span>. </p>
<p>If <span class="tt">this</span> corresponds to t² and <span class="tt">other</span> corresponds to t³, <span class="tt">this - other</span> will correspond to t² - t³. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if every element of <span class="tt">other.get_segment_times()</span> is not within <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a0539f01602cd1ab9b25989206d302401" title="Minimum delta quantity used for comparing time.">PiecewiseTrajectory::kEpsilonTime</a> from <span class="tt">this-&gt;<a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#ab5b1a0b2d9113c656018bcace89985b4">get_segment_times()</a></span>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a722590f3afed971fa441f2d5de89d944" name="a722590f3afed971fa441f2d5de89d944"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a722590f3afed971fa441f2d5de89d944">&#9670;&#160;</a></span>operator-=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a6a44781cbe3dd6c55234638a1b63d4ef">PiecewisePolynomial</a> &amp; operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>coeff</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2534241e0adb371ee9cb3d0fd6c02092" name="a2534241e0adb371ee9cb3d0fd6c02092"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2534241e0adb371ee9cb3d0fd6c02092">&#9670;&#160;</a></span>operator-=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a6a44781cbe3dd6c55234638a1b63d4ef">PiecewisePolynomial</a> &amp; operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a6a44781cbe3dd6c55234638a1b63d4ef">PiecewisePolynomial</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtracts each <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> in the <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a9c5cbf1ba95055937fdb8283769df797">PolynomialMatrix</a> of <span class="tt">other</span> from the corresponding <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> in the <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a9c5cbf1ba95055937fdb8283769df797">PolynomialMatrix</a> of <span class="tt">this</span>, storing the result in <span class="tt">this</span>. </p>
<p>If <span class="tt">this</span> corresponds to t² and <span class="tt">other</span> corresponds to t³, <span class="tt">this -= other</span> will correspond to t² - t³. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if every element of <span class="tt">other.get_segment_times()</span> is not within <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a0539f01602cd1ab9b25989206d302401" title="Minimum delta quantity used for comparing time.">PiecewiseTrajectory::kEpsilonTime</a> from <span class="tt">this-&gt;<a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#ab5b1a0b2d9113c656018bcace89985b4">get_segment_times()</a></span>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a74f448d9a26234f9c8304a182b61da63" name="a74f448d9a26234f9c8304a182b61da63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74f448d9a26234f9c8304a182b61da63">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a6a44781cbe3dd6c55234638a1b63d4ef">PiecewisePolynomial</a> &amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a6a44781cbe3dd6c55234638a1b63d4ef">PiecewisePolynomial</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a52448559a01daac33f78c61cc4a148a8" name="a52448559a01daac33f78c61cc4a148a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52448559a01daac33f78c61cc4a148a8">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a6a44781cbe3dd6c55234638a1b63d4ef">PiecewisePolynomial</a> &amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a6a44781cbe3dd6c55234638a1b63d4ef">PiecewisePolynomial</a>&lt; T &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a88e900c12b23dd1cb0bccb6d0357db5f" name="a88e900c12b23dd1cb0bccb6d0357db5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88e900c12b23dd1cb0bccb6d0357db5f">&#9670;&#160;</a></span>RemoveFinalSegment()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void RemoveFinalSegment </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the final segment from the trajectory, reducing the number of segments by 1. </p>
<dl class="section pre"><dt>Precondition</dt><dd><span class="tt">this</span> is not <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a644718bb2fb240de962dc3c9a1fdf0dc" title="Returns true if this trajectory has no breaks/samples/polynomials.">empty()</a> </dd></dl>

</div>
</div>
<a id="a39001029f6f2e13a8890f233254c4709" name="a39001029f6f2e13a8890f233254c4709"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39001029f6f2e13a8890f233254c4709">&#9670;&#160;</a></span>Reshape()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Reshape </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>rows</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>cols</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reshapes the dimensions of the Eigen::MatrixX&lt;T&gt; returned by <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a13176bef855d6085bd2395da6855886f" title="Evaluates the PiecewisePolynomial at the given time t.">value()</a>, <a class="el" href="classdrake_1_1trajectories_1_1_trajectory.html#abf2912689d33fd58c54d119cab8f4140" title="Evaluates the derivative of this at the given time t.">EvalDerivative()</a>, etc. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code class="param">rows</code> x <code class="param">cols</code> must equal this.rows() * this.cols(). </dd></dl>
<dl class="section see"><dt>See also</dt><dd>Eigen::PlainObjectBase::resize(). </dd></dl>

</div>
</div>
<a id="afca7568bb098808d681cb14d7fa09f99" name="afca7568bb098808d681cb14d7fa09f99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afca7568bb098808d681cb14d7fa09f99">&#9670;&#160;</a></span>ReverseTime()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ReverseTime </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modifies the trajectory so that pp_after(t) = pp_before(-t). </p>
<dl class="section note"><dt>Note</dt><dd>The new trajectory will evaluate differently at precisely the break points if the original trajectory was discontinuous at the break points. This is because the segments are defined on the half-open intervals [breaks(i), breaks(i+1)), and the order of the breaks have been reversed. </dd></dl>

</div>
</div>
<a id="adcc8b67a7b625544afb0ae19bcf76564" name="adcc8b67a7b625544afb0ae19bcf76564"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcc8b67a7b625544afb0ae19bcf76564">&#9670;&#160;</a></span>rows()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Index rows </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the row count of the output matrices. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a644718bb2fb240de962dc3c9a1fdf0dc" title="Returns true if this trajectory has no breaks/samples/polynomials.">empty()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a16274d0c316c76ded4b85111b38ece15" name="a16274d0c316c76ded4b85111b38ece15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16274d0c316c76ded4b85111b38ece15">&#9670;&#160;</a></span>scalarValue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T scalarValue </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Index</td>          <td class="paramname"><span class="paramname"><em>row</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Index</td>          <td class="paramname"><span class="paramname"><em>col</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates the trajectory at the given time without returning the entire matrix. </p>
<p>Equivalent to value(t)(row, col). </p><dl class="section warning"><dt>Warning</dt><dd>See warnings in <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a13176bef855d6085bd2395da6855886f" title="Evaluates the PiecewisePolynomial at the given time t.">value()</a>. </dd></dl>

</div>
</div>
<a id="a923a4ac5ef6f85f444519188d9dbd3e1" name="a923a4ac5ef6f85f444519188d9dbd3e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a923a4ac5ef6f85f444519188d9dbd3e1">&#9670;&#160;</a></span>ScaleTime()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ScaleTime </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>scale</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scales the time of the trajectory by non-negative <span class="tt">scale</span> (use <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#afca7568bb098808d681cb14d7fa09f99" title="Modifies the trajectory so that pp_after(t) = pp_before(-t).">ReverseTime()</a> if you want to also negate time). </p>
<p>The resulting polynomial evaluates to pp_after(t) = pp_before(t/scale).</p>
<p>As an example, <span class="tt">scale</span>=2 will result in a trajectory that is twice as long (<a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a1019f41dcfe440c98c91029f4b0b0bc0">start_time()</a> and <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a4c1604e170d921c073e4fba715622507">end_time()</a> have both doubled). </p>

</div>
</div>
<a id="a8e8824802dedfbc36776227f7482b6bc" name="a8e8824802dedfbc36776227f7482b6bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e8824802dedfbc36776227f7482b6bc">&#9670;&#160;</a></span>Serialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename Archive&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Serialize </td>
          <td>(</td>
          <td class="paramtype">Archive *</td>          <td class="paramname"><span class="paramname"><em>a</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Passes this object to an Archive. </p>
<p>Refer to <a class="el" href="group__yaml__serialization.html">YAML Serialization</a> for background. This method is only available when T = double. </p>

</div>
</div>
<a id="a9a7863e6bf8a3ccb5335563370305add" name="a9a7863e6bf8a3ccb5335563370305add"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a7863e6bf8a3ccb5335563370305add">&#9670;&#160;</a></span>setPolynomialMatrixBlock()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void setPolynomialMatrixBlock </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a9c5cbf1ba95055937fdb8283769df797">PolynomialMatrix</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>replacement</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>segment_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Index</td>          <td class="paramname"><span class="paramname"><em>row_start</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Index</td>          <td class="paramname"><span class="paramname"><em>col_start</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces the specified block of the <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a9c5cbf1ba95055937fdb8283769df797">PolynomialMatrix</a> at the given segment index. </p>
<dl class="section note"><dt>Note</dt><dd>Calls <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a0a4ac30a258a47b6ea610f16f4accece">PiecewiseTrajectory&lt;T&gt;::segment_number_range_check()</a> to validate <span class="tt">segment_index</span>. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This code relies upon Eigen to verify that the replacement block is not too large. </dd></dl>

</div>
</div>
<a id="a728995759fa06a8d1a2b967d313b6d6b" name="a728995759fa06a8d1a2b967d313b6d6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a728995759fa06a8d1a2b967d313b6d6b">&#9670;&#160;</a></span>shiftRight()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void shiftRight </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>offset</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds <span class="tt">offset</span> to all of the breaks. </p>
<p><span class="tt">offset</span> need not be a non-negative number. The resulting polynomial will evaluate to pp_after(t) = pp_before(t-offset).</p>
<p>As an example, <span class="tt">offset</span>=2 will result in the <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a1019f41dcfe440c98c91029f4b0b0bc0">start_time()</a> and <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a4c1604e170d921c073e4fba715622507">end_time()</a> being 2 seconds later. </p>

</div>
</div>
<a id="a28dc60d1015ae4d2e946898a2eec5692" name="a28dc60d1015ae4d2e946898a2eec5692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28dc60d1015ae4d2e946898a2eec5692">&#9670;&#160;</a></span>slice()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a6a44781cbe3dd6c55234638a1b63d4ef">PiecewisePolynomial</a> slice </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>start_segment_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num_segments</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the PiecewisePolynomial comprising the <span class="tt">num_segments</span> segments starting at the specified <span class="tt">start_segment_index</span>. </p>
<dl class="section note"><dt>Note</dt><dd>Calls <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a0a4ac30a258a47b6ea610f16f4accece">PiecewiseTrajectory&lt;T&gt;::segment_number_range_check()</a> to validate <span class="tt">segment_index</span>. </dd></dl>

</div>
</div>
<a id="ab0edf720069e60d0da73fba82dec2fa2" name="ab0edf720069e60d0da73fba82dec2fa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0edf720069e60d0da73fba82dec2fa2">&#9670;&#160;</a></span>SliceByTime()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a6a44781cbe3dd6c55234638a1b63d4ef">PiecewisePolynomial</a> SliceByTime </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>start_time</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>end_time</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Slices the trajectory within a specified time range. </p>
<p>q = p.SliceByTime(t1, t2) returns a <a class="el" href="classdrake_1_1multibody_1_1_piecewise_polynomial.html" title="A scalar multi-variate piecewise polynomial.">PiecewisePolynomial</a> q such that q.start_time() = t1, q.end_time() = t2, and q(t) = p(t) for t1 &lt;= t &lt;= t2. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <span class="tt"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a1019f41dcfe440c98c91029f4b0b0bc0">start_time</a></span> or <span class="tt"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a4c1604e170d921c073e4fba715622507">end_time</a></span> is not within the trajectory's time range. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a59f4f35bd9afa91ca14283e7c865918f" name="a59f4f35bd9afa91ca14283e7c865918f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59f4f35bd9afa91ca14283e7c865918f">&#9670;&#160;</a></span>Transpose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a6a44781cbe3dd6c55234638a1b63d4ef">PiecewisePolynomial</a> Transpose </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a new <a class="el" href="classdrake_1_1multibody_1_1_piecewise_polynomial.html" title="A scalar multi-variate piecewise polynomial.">PiecewisePolynomial</a> for which value(t) == this.value(t).transpose(). </p>

</div>
</div>
<a id="a13176bef855d6085bd2395da6855886f" name="a13176bef855d6085bd2395da6855886f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13176bef855d6085bd2395da6855886f">&#9670;&#160;</a></span>value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; value </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates the PiecewisePolynomial at the given time t. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The time at which to evaluate the PiecewisePolynomial. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The matrix of evaluated values. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>If T == <a class="el" href="classdrake_1_1symbolic_1_1_expression.html" title="Represents a symbolic form of an expression.">symbolic::Expression</a>, <span class="tt">t.is_constant()</span> must be true.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If t does not lie in the range that the polynomial is defined over, the polynomial will silently be evaluated at the closest point to t. For example, <span class="tt"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a13176bef855d6085bd2395da6855886f" title="Evaluates the PiecewisePolynomial at the given time t.">value</a>(-1)</span> will return <span class="tt">value(0)</span> for a polynomial defined over [0, 1]. </dd>
<dd>
See warning in the <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#polynomial_warning">constructor overview</a> above. </dd></dl>

</div>
</div>
<a id="a676915a092a5400783b06c6e0441db96" name="a676915a092a5400783b06c6e0441db96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a676915a092a5400783b06c6e0441db96">&#9670;&#160;</a></span>ZeroOrderHold() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a6a44781cbe3dd6c55234638a1b63d4ef">PiecewisePolynomial</a>&lt; T &gt; ZeroOrderHold </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>breaks</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>samples</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Version of ZeroOrderHold(breaks, samples) that uses vector samples and <span class="tt">Eigen::VectorX&lt;T&gt;/MatrixX&lt;T&gt;</span> arguments. </p>
<p>Each column of <span class="tt">samples</span> represents a sample point.</p>
<dl class="section pre"><dt>Precondition</dt><dd><span class="tt">samples.cols() == breaks.size()</span> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>under the conditions specified under <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#coefficient_construction_methods">coefficient_construction_methods</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad4f93c291cf6baf5b808fdd2770bd35a" name="ad4f93c291cf6baf5b808fdd2770bd35a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4f93c291cf6baf5b808fdd2770bd35a">&#9670;&#160;</a></span>ZeroOrderHold() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a6a44781cbe3dd6c55234638a1b63d4ef">PiecewisePolynomial</a>&lt; T &gt; ZeroOrderHold </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>breaks</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>samples</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a piecewise constant PiecewisePolynomial using matrix samples. </p>
<p>Note that constructing a PiecewisePolynomial requires at least two sample points, although in this case, the second sample point's value is ignored, and only its break time is used.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>under the conditions specified under <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#coefficient_construction_methods">coefficient_construction_methods</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>drake/common/trajectories/<a class="el" href="piecewise__polynomial_8h.html">piecewise_polynomial.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- footer -->
<div class="navpath">
  <ul>
    <li class="navelem"><a href="namespacedrake.html">drake</a></li><li class="navelem"><a href="namespacedrake_1_1multibody.html">multibody</a></li><li class="navelem"><a href="classdrake_1_1multibody_1_1_piecewise_polynomial.html">PiecewisePolynomial</a></li>
  </ul>
</div>
<footer id="nav-path", class="site-footer padding">
  <div class="contain">
    <a href="/" class="drake-logo">
      <img src="/images/drake-logo.svg"/>
    </a>
    <div class="footer-menu">
      <ul>
        <li>
          <a href="https://accessibility.mit.edu/" class="site-menu-item">Accessibility</a>
        </li>
        <li>
          <a href="/doxygen_cxx/index.html" class="site-menu-item">C++</a>
        </li>
        <li>
          <a href="/pydrake/index.html" class="site-menu-item">Python</a>
        </li>
        <li class="github-link">
          <a href="https://github.com/RobotLocomotion/drake" class="site-menu-item">GitHub <img src="/third_party/images/GitHub-Mark-64px.png"/></a>
        </li>
      </ul>
    </div>
  </div>
</footer>
<script type="text/javascript">
searchBox.searchLabel = 'Go to name…';
searchBox.DOMSearchField().placeholder = searchBox.searchLabel;
searchBox.DOMSearchField().value = '';
</script>
</body>
</html>
