<!-- HTML header for doxygen 1.15.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: Frame&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(function() { init_search(); });
</script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@4/tex-chtml.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<header class="site-header">
 <div class="site-header-inner contain">
  <a class="drake-logo" href="/"><img src="/images/drake-logo-white.svg"></a>
  <div class="menu-mobile-toggle">
   <span></span>
  </div>
  <nav class="site-menu">
   <ul>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/">Home</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/installation.html">Installation</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/gallery.html">Gallery</a>
    </li>
    <li class="site-menu-item site-menu-item-main">API Documentation
     <div class="sub">
      <a class="site-menu-item" href="/doxygen_cxx/index.html">C++</a>
      <a class="site-menu-item" href="/pydrake/index.html">Python</a>
     </div>
    </li>
    <li class="site-menu-item site-menu-item-main">Resources
     <div class="sub">
      <a class="site-menu-item" href="/getting_help.html">Getting Help</a>
      <a class="site-menu-item" href="https://deepnote.com/workspace/Drake-0b3b2c53-a7ad-441b-80f8-bf8350752305/project/Tutorials-2b4fc509-aef2-417d-a40d-6071dfed9199/notebook/index-753e3c9d261247ba9f0eb1d7868c18c8">Tutorials</a>
      <a class="site-menu-item" href="/python_bindings.html">Python Bindings</a>
      <a class="site-menu-item" href="/developers.html">For Developers</a>
      <a class="site-menu-item" href="/credits.html">Credits</a>
     </div>
    </li>
    <li class="github-link">
     <a class="site-menu-item" href="https://github.com/RobotLocomotion/drake">GitHub <img src="/third_party/images/GitHub-Mark-Light-64px.png"></a>
    </li>
   </ul>
  </nav>
 </div>
</header>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<div class="title-banner">
 <div class="title-banner__title">
  Drake C++ Documentation
 </div>
 <div id="DDGSearch">
  <form id="search_form_cpp" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search C++ API only…">
   <input type="hidden" name="q" value="site:drake.mit.edu/doxygen_cxx">
  </form>
  <form id="search_form" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search all of Drake…">
   <input type="hidden" name="q" value="site:drake.mit.edu OR site:underactuated.csail.mit.edu OR site:manipulation.csail.mit.edu">
  </form>
 </div>
 <div id="MSearchBoxContainer">
  <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect" class="search-icon" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"><span class="search-icon-dropdown"></span></span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><div id="MSearchCloseImg" class="close-icon"></div></a>
          </span>
        </div>
</td>
 </div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('classdrake_1_1multibody_1_1_frame.html','','classdrake_1_1multibody_1_1_frame-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">Frame&lt; T &gt; Class Template Reference<span class="mlabels"><span class="mlabel abstract">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename T&gt;<br />
class drake::multibody::Frame&lt; T &gt;</div><p>Frame is an abstract class representing a <em>material frame</em> (also called a <em>physical frame</em>) of its underlying <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html" title="The term rigid body implies that the deformations of the body under consideration are so small that t...">RigidBody</a>. </p>
<p>The Frame's origin is a material point of its <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html" title="The term rigid body implies that the deformations of the body under consideration are so small that t...">RigidBody</a>, and its axes have fixed directions in that body. A Frame's pose (position and orientation) with respect to its <a class="el" href="classdrake_1_1multibody_1_1_rigid_body_frame.html" title="A RigidBodyFrame is a material Frame that serves as the unique reference frame for a RigidBody.">RigidBodyFrame</a> may be parameterized, but is fixed (not time or state dependent) once parameters have been set.</p>
<p>An important characteristic of a Frame is that forces or torques applied to a Frame are applied to the Frame's underlying <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html" title="The term rigid body implies that the deformations of the body under consideration are so small that t...">RigidBody</a>. Force-producing elements like joints, actuators, and constraints usually employ two Frames, with one Frame connected to one body and the other connected to a different body. Every Frame F can report the <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html" title="The term rigid body implies that the deformations of the body under consideration are so small that t...">RigidBody</a> B to which it is attached and its pose X_BF with respect to B's <a class="el" href="classdrake_1_1multibody_1_1_rigid_body_frame.html" title="A RigidBodyFrame is a material Frame that serves as the unique reference frame for a RigidBody.">RigidBodyFrame</a>.</p>
<p>A Frame's pose in World (or relative to other frames) is always calculated starting with its pose relative to its underlying <a class="el" href="classdrake_1_1multibody_1_1_rigid_body_frame.html" title="A RigidBodyFrame is a material Frame that serves as the unique reference frame for a RigidBody.">RigidBodyFrame</a>. Subclasses derived from Frame differ in how kinematic calculations are performed. For example, the angular velocity of a <a class="el" href="classdrake_1_1multibody_1_1_fixed_offset_frame.html" title="FixedOffsetFrame represents a material frame F whose pose is fixed with respect to a parent material ...">FixedOffsetFrame</a> or <a class="el" href="classdrake_1_1multibody_1_1_rigid_body_frame.html" title="A RigidBodyFrame is a material Frame that serves as the unique reference frame for a RigidBody.">RigidBodyFrame</a> is identical to the angular velocity of its underlying body, whereas the translational velocity of a <a class="el" href="classdrake_1_1multibody_1_1_fixed_offset_frame.html" title="FixedOffsetFrame represents a material frame F whose pose is fixed with respect to a parent material ...">FixedOffsetFrame</a> differs from that of a <a class="el" href="classdrake_1_1multibody_1_1_rigid_body_frame.html" title="A RigidBodyFrame is a material Frame that serves as the unique reference frame for a RigidBody.">RigidBodyFrame</a>.</p>
<p>Frame provides methods for obtaining its current orientation, position, motion, etc. from a Context passed to those methods.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The scalar type, which must be one of the <a class="el" href="group__default__scalars.html">default scalars</a>. </td></tr>
  </table>
  </dd>
</dl>
</div>
<p><code>#include &lt;drake/multibody/tree/frame.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa0f3f98e61d00d6d126bba55efbff728" id="r_aa0f3f98e61d00d6d126bba55efbff728"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa0f3f98e61d00d6d126bba55efbff728">~Frame</a> () override</td></tr>
<tr class="memitem:aacda9c48ea6f77ab847cf27804705b04" id="r_aacda9c48ea6f77ab847cf27804705b04"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1multibody.html#a51c69848adb64ae45eebc1e5af5dbaa6">FrameIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aacda9c48ea6f77ab847cf27804705b04">index</a> () const</td></tr>
<tr class="memdesc:aacda9c48ea6f77ab847cf27804705b04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns this element's unique index.  <br /></td></tr>
<tr class="memitem:af7a5e902b948cca72b9209752aba0d3c" id="r_af7a5e902b948cca72b9209752aba0d3c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af7a5e902b948cca72b9209752aba0d3c">body</a> () const</td></tr>
<tr class="memdesc:af7a5e902b948cca72b9209752aba0d3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reference to the body associated to this Frame.  <br /></td></tr>
<tr class="memitem:a64d83126860c9766c12c88786177cf22" id="r_a64d83126860c9766c12c88786177cf22"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a64d83126860c9766c12c88786177cf22">is_world_frame</a> () const</td></tr>
<tr class="memdesc:a64d83126860c9766c12c88786177cf22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <span class="tt">this</span> is the world frame.  <br /></td></tr>
<tr class="memitem:a6681a8def9431af1311063721c46fe14" id="r_a6681a8def9431af1311063721c46fe14"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6681a8def9431af1311063721c46fe14">is_body_frame</a> () const</td></tr>
<tr class="memdesc:a6681a8def9431af1311063721c46fe14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <span class="tt">this</span> is the body frame.  <br /></td></tr>
<tr class="memitem:a24dcbf29c0d6cd766009a182a6484e3b" id="r_a24dcbf29c0d6cd766009a182a6484e3b"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a24dcbf29c0d6cd766009a182a6484e3b">name</a> () const</td></tr>
<tr class="memdesc:a24dcbf29c0d6cd766009a182a6484e3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of this frame. The name will never be empty.  <br /></td></tr>
<tr class="memitem:a06542e4ec7c6a884bfcd61c9b00221b4" id="r_a06542e4ec7c6a884bfcd61c9b00221b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_scoped_name.html">ScopedName</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a06542e4ec7c6a884bfcd61c9b00221b4">scoped_name</a> () const</td></tr>
<tr class="memdesc:a06542e4ec7c6a884bfcd61c9b00221b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns scoped name of this frame.  <br /></td></tr>
<tr class="memitem:affd9719c2170a4d085c06206f45f721c" id="r_affd9719c2170a4d085c06206f45f721c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#affd9719c2170a4d085c06206f45f721c">EvalPoseInBodyFrame</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:affd9719c2170a4d085c06206f45f721c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the body-relative pose X_BF giving the pose of this <a class="el" href="classdrake_1_1multibody_1_1_frame.html" title="Frame is an abstract class representing a material frame (also called a physical frame) of its underl...">Frame</a> with respect to its body's <a class="el" href="classdrake_1_1multibody_1_1_rigid_body_frame.html" title="A RigidBodyFrame is a material Frame that serves as the unique reference frame for a RigidBody.">RigidBodyFrame</a>.  <br /></td></tr>
<tr class="memitem:a5335d24722724ebc56d37a2880aeebd4" id="r_a5335d24722724ebc56d37a2880aeebd4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5335d24722724ebc56d37a2880aeebd4">CalcPoseInBodyFrame</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:a5335d24722724ebc56d37a2880aeebd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the pose <span class="tt">X_BF</span> of <span class="tt">this</span> frame F in the body frame B associated with this frame.  <br /></td></tr>
<tr class="memitem:a795668d7ea25354fa43ee73df1499f51" id="r_a795668d7ea25354fa43ee73df1499f51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">math::RotationMatrix</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a795668d7ea25354fa43ee73df1499f51">CalcRotationMatrixInBodyFrame</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:a795668d7ea25354fa43ee73df1499f51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the rotation matrix <span class="tt">R_BF</span> that relates body frame B to <span class="tt">this</span> frame F (B is the body frame to which <span class="tt">this</span> frame F is attached).  <br /></td></tr>
<tr class="memitem:a4f15964d808fb5542563a4375698c7d6" id="r_a4f15964d808fb5542563a4375698c7d6"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4f15964d808fb5542563a4375698c7d6">GetFixedPoseInBodyFrame</a> () const</td></tr>
<tr class="memdesc:a4f15964d808fb5542563a4375698c7d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variant of <a class="el" href="#a5335d24722724ebc56d37a2880aeebd4" title="Returns the pose X_BF of this frame F in the body frame B associated with this frame.">CalcPoseInBodyFrame()</a> that returns the fixed pose <span class="tt">X_BF</span> of <span class="tt">this</span> frame F in the body frame B associated with this frame.  <br /></td></tr>
<tr class="memitem:acf51fc331733cac246d03c3fa1f6dc7f" id="r_acf51fc331733cac246d03c3fa1f6dc7f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">math::RotationMatrix</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acf51fc331733cac246d03c3fa1f6dc7f">GetFixedRotationMatrixInBodyFrame</a> () const</td></tr>
<tr class="memdesc:acf51fc331733cac246d03c3fa1f6dc7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the rotation matrix <span class="tt">R_BF</span> that relates body frame B to <span class="tt">this</span> frame F (B is the body frame to which <span class="tt">this</span> frame F is attached).  <br /></td></tr>
<tr class="memitem:a1f1f6d8f6718b83c4d7f4864e4b5ef4d" id="r_a1f1f6d8f6718b83c4d7f4864e4b5ef4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f1f6d8f6718b83c4d7f4864e4b5ef4d">CalcOffsetPoseInBody</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; T &gt; &amp;X_FQ) const</td></tr>
<tr class="memdesc:a1f1f6d8f6718b83c4d7f4864e4b5ef4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the offset pose <span class="tt">X_FQ</span> of a frame Q in <span class="tt">this</span> frame F, this method computes the pose <span class="tt">X_BQ</span> of frame Q in the body frame B to which this frame is attached.  <br /></td></tr>
<tr class="memitem:af974101d46b2ddc2a89484f726da729e" id="r_af974101d46b2ddc2a89484f726da729e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">math::RotationMatrix</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af974101d46b2ddc2a89484f726da729e">CalcOffsetRotationMatrixInBody</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, const <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">math::RotationMatrix</a>&lt; T &gt; &amp;R_FQ) const</td></tr>
<tr class="memdesc:af974101d46b2ddc2a89484f726da729e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates and returns the rotation matrix <span class="tt">R_BQ</span> that relates body frame B to frame Q via <span class="tt">this</span> intermediate frame F, i.e., <span class="tt">R_BQ = R_BF * R_FQ</span> (B is the body frame to which <span class="tt">this</span> frame F is attached).  <br /></td></tr>
<tr class="memitem:ada1b5bd9d108546400623ce9b031b8cf" id="r_ada1b5bd9d108546400623ce9b031b8cf"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada1b5bd9d108546400623ce9b031b8cf">GetFixedOffsetPoseInBody</a> (const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; T &gt; &amp;X_FQ) const</td></tr>
<tr class="memdesc:ada1b5bd9d108546400623ce9b031b8cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variant of <a class="el" href="#a1f1f6d8f6718b83c4d7f4864e4b5ef4d" title="Given the offset pose X_FQ of a frame Q in this frame F, this method computes the pose X_BQ of frame ...">CalcOffsetPoseInBody()</a> that given the offset pose <span class="tt">X_FQ</span> of a frame Q in <span class="tt">this</span> frame F, returns the pose <span class="tt">X_BQ</span> of frame Q in the body frame B to which this frame is attached.  <br /></td></tr>
<tr class="memitem:ab516edb7052775503f5e7b9a94a5c566" id="r_ab516edb7052775503f5e7b9a94a5c566"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">math::RotationMatrix</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab516edb7052775503f5e7b9a94a5c566">GetFixedRotationMatrixInBody</a> (const <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">math::RotationMatrix</a>&lt; T &gt; &amp;R_FQ) const</td></tr>
<tr class="memdesc:ab516edb7052775503f5e7b9a94a5c566"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates and returns the rotation matrix <span class="tt">R_BQ</span> that relates body frame B to frame Q via <span class="tt">this</span> intermediate frame F, i.e., <span class="tt">R_BQ = R_BF * R_FQ</span> (B is the body frame to which <span class="tt">this</span> frame F is attached).  <br /></td></tr>
<tr class="memitem:a2f1ab566c4c4e25645fa9712c275a434" id="r_a2f1ab566c4c4e25645fa9712c275a434"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2f1ab566c4c4e25645fa9712c275a434">CalcPoseInWorld</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:a2f1ab566c4c4e25645fa9712c275a434"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes and returns the pose <span class="tt">X_WF</span> of <span class="tt">this</span> frame F in the world frame W as a function of the state of the model stored in <span class="tt">context</span>.  <br /></td></tr>
<tr class="memitem:a6e6be2a2ffa00f74b2988eb6b160f4ce" id="r_a6e6be2a2ffa00f74b2988eb6b160f4ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6e6be2a2ffa00f74b2988eb6b160f4ce">CalcPose</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, const <a class="el" href="#a921f7998dbc51e8b4298b1fbb2369686">Frame</a>&lt; T &gt; &amp;frame_M) const</td></tr>
<tr class="memdesc:a6e6be2a2ffa00f74b2988eb6b160f4ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes and returns the pose <span class="tt">X_MF</span> of <span class="tt">this</span> frame F in measured in <span class="tt">frame_M</span> as a function of the state of the model stored in <span class="tt">context</span>.  <br /></td></tr>
<tr class="memitem:ad0392fe93d111538f073a608ee051113" id="r_ad0392fe93d111538f073a608ee051113"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">math::RotationMatrix</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad0392fe93d111538f073a608ee051113">CalcRotationMatrix</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, const <a class="el" href="#a921f7998dbc51e8b4298b1fbb2369686">Frame</a>&lt; T &gt; &amp;frame_M) const</td></tr>
<tr class="memdesc:ad0392fe93d111538f073a608ee051113"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates and returns the rotation matrix <span class="tt">R_MF</span> that relates <span class="tt">frame_M</span> and <span class="tt">this</span> frame F as a function of the state stored in <span class="tt">context</span>.  <br /></td></tr>
<tr class="memitem:a3f0e841bc0c32a845c57a564f0157895" id="r_a3f0e841bc0c32a845c57a564f0157895"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">math::RotationMatrix</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f0e841bc0c32a845c57a564f0157895">CalcRotationMatrixInWorld</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:a3f0e841bc0c32a845c57a564f0157895"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates and returns the rotation matrix <span class="tt">R_WF</span> that relates the world frame W and <span class="tt">this</span> frame F as a function of the state stored in <span class="tt">context</span>.  <br /></td></tr>
<tr class="memitem:ab869854391d326b0d230ed5c4a46b7d8" id="r_ab869854391d326b0d230ed5c4a46b7d8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab869854391d326b0d230ed5c4a46b7d8">EvalAngularVelocityInWorld</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:ab869854391d326b0d230ed5c4a46b7d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates <span class="tt">this</span> frame F's angular velocity measured and expressed in the world frame W.  <br /></td></tr>
<tr class="memitem:a606d1fae37bb5759acb4744a653e2b15" id="r_a606d1fae37bb5759acb4744a653e2b15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a606d1fae37bb5759acb4744a653e2b15">CalcAngularVelocity</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, const <a class="el" href="#a921f7998dbc51e8b4298b1fbb2369686">Frame</a>&lt; T &gt; &amp;measured_in_frame, const <a class="el" href="#a921f7998dbc51e8b4298b1fbb2369686">Frame</a>&lt; T &gt; &amp;expressed_in_frame) const</td></tr>
<tr class="memdesc:a606d1fae37bb5759acb4744a653e2b15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates <span class="tt">this</span> frame F's angular velocity measured in a frame M, expressed in a frame E.  <br /></td></tr>
<tr class="memitem:afb3f4ddf29eee9d776573336cb75a5fe" id="r_afb3f4ddf29eee9d776573336cb75a5fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_spatial_velocity.html">SpatialVelocity</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afb3f4ddf29eee9d776573336cb75a5fe">CalcSpatialVelocityInWorld</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:afb3f4ddf29eee9d776573336cb75a5fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates <span class="tt">this</span> frame F's spatial velocity measured and expressed in the world frame W.  <br /></td></tr>
<tr class="memitem:a9acd38f4c77a86622deda5e26ff763c4" id="r_a9acd38f4c77a86622deda5e26ff763c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_spatial_velocity.html">SpatialVelocity</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9acd38f4c77a86622deda5e26ff763c4">CalcSpatialVelocity</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, const <a class="el" href="#a921f7998dbc51e8b4298b1fbb2369686">Frame</a>&lt; T &gt; &amp;frame_M, const <a class="el" href="#a921f7998dbc51e8b4298b1fbb2369686">Frame</a>&lt; T &gt; &amp;frame_E) const</td></tr>
<tr class="memdesc:a9acd38f4c77a86622deda5e26ff763c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates <span class="tt">this</span> frame F's spatial velocity measured in a frame M, expressed in a frame E.  <br /></td></tr>
<tr class="memitem:aea3234e285067e2c032750d2c3be3f0f" id="r_aea3234e285067e2c032750d2c3be3f0f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_spatial_velocity.html">SpatialVelocity</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aea3234e285067e2c032750d2c3be3f0f">CalcRelativeSpatialVelocityInWorld</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, const <a class="el" href="#a921f7998dbc51e8b4298b1fbb2369686">Frame</a>&lt; T &gt; &amp;other_frame) const</td></tr>
<tr class="memdesc:aea3234e285067e2c032750d2c3be3f0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates <span class="tt">this</span> frame C's spatial velocity relative to another frame B, measured and expressed in the world frame W.  <br /></td></tr>
<tr class="memitem:ae5ed37e2dc9581c253d592922105249f" id="r_ae5ed37e2dc9581c253d592922105249f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_spatial_velocity.html">SpatialVelocity</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae5ed37e2dc9581c253d592922105249f">CalcRelativeSpatialVelocity</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, const <a class="el" href="#a921f7998dbc51e8b4298b1fbb2369686">Frame</a>&lt; T &gt; &amp;other_frame, const <a class="el" href="#a921f7998dbc51e8b4298b1fbb2369686">Frame</a>&lt; T &gt; &amp;measured_in_frame, const <a class="el" href="#a921f7998dbc51e8b4298b1fbb2369686">Frame</a>&lt; T &gt; &amp;expressed_in_frame) const</td></tr>
<tr class="memdesc:ae5ed37e2dc9581c253d592922105249f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates <span class="tt">this</span> frame C's spatial velocity relative to another frame B, measured in a frame M, expressed in a frame E.  <br /></td></tr>
<tr class="memitem:a2fe2b1457ab123c9a3cdf6db20826400" id="r_a2fe2b1457ab123c9a3cdf6db20826400"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_spatial_acceleration.html">SpatialAcceleration</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2fe2b1457ab123c9a3cdf6db20826400">CalcSpatialAccelerationInWorld</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:a2fe2b1457ab123c9a3cdf6db20826400"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates <span class="tt">this</span> frame F's spatial acceleration measured and expressed in the world frame W.  <br /></td></tr>
<tr class="memitem:ad26da01fad6bb3778253eb34924fb840" id="r_ad26da01fad6bb3778253eb34924fb840"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_spatial_acceleration.html">SpatialAcceleration</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad26da01fad6bb3778253eb34924fb840">CalcSpatialAcceleration</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, const <a class="el" href="#a921f7998dbc51e8b4298b1fbb2369686">Frame</a>&lt; T &gt; &amp;measured_in_frame, const <a class="el" href="#a921f7998dbc51e8b4298b1fbb2369686">Frame</a>&lt; T &gt; &amp;expressed_in_frame) const</td></tr>
<tr class="memdesc:ad26da01fad6bb3778253eb34924fb840"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates <span class="tt">this</span> frame F's spatial acceleration measured in a frame M, expressed in a frame E.  <br /></td></tr>
<tr class="memitem:a88af386f4cce8fe95b75ccfd01bfed66" id="r_a88af386f4cce8fe95b75ccfd01bfed66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_spatial_acceleration.html">SpatialAcceleration</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a88af386f4cce8fe95b75ccfd01bfed66">CalcRelativeSpatialAccelerationInWorld</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, const <a class="el" href="#a921f7998dbc51e8b4298b1fbb2369686">Frame</a>&lt; T &gt; &amp;other_frame) const</td></tr>
<tr class="memdesc:a88af386f4cce8fe95b75ccfd01bfed66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates <span class="tt">this</span> frame C's spatial acceleration relative to another frame B, measured and expressed in the world frame W.  <br /></td></tr>
<tr class="memitem:ab8f2d64f408f1404ef93f2abdfb9738f" id="r_ab8f2d64f408f1404ef93f2abdfb9738f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_spatial_acceleration.html">SpatialAcceleration</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab8f2d64f408f1404ef93f2abdfb9738f">CalcRelativeSpatialAcceleration</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, const <a class="el" href="#a921f7998dbc51e8b4298b1fbb2369686">Frame</a>&lt; T &gt; &amp;other_frame, const <a class="el" href="#a921f7998dbc51e8b4298b1fbb2369686">Frame</a>&lt; T &gt; &amp;measured_in_frame, const <a class="el" href="#a921f7998dbc51e8b4298b1fbb2369686">Frame</a>&lt; T &gt; &amp;expressed_in_frame) const</td></tr>
<tr class="memdesc:ab8f2d64f408f1404ef93f2abdfb9738f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates <span class="tt">this</span> frame C's spatial acceleration relative to another frame B, measured in a frame M, expressed in a frame E.  <br /></td></tr>
<tr class="memitem:a24dd310e5292eb141218c1f101f45b5d" id="r_a24dd310e5292eb141218c1f101f45b5d"><td class="memTemplParams" colspan="2">template&lt;typename ToScalar&gt; </td></tr>
<tr class="memitem:a24dd310e5292eb141218c1f101f45b5d template"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="#a921f7998dbc51e8b4298b1fbb2369686">Frame</a>&lt; ToScalar &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a24dd310e5292eb141218c1f101f45b5d">CloneToScalar</a> (const internal::MultibodyTree&lt; ToScalar &gt; &amp;tree_clone) const</td></tr>
<tr class="memdesc:a24dd310e5292eb141218c1f101f45b5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) NVI to <a class="el" href="#a28167855937b28ef48da220bc063a16c" title="Clones this Frame (templated on T) to a frame templated on double.">DoCloneToScalar()</a> templated on the scalar type of the new clone to be created.  <br /></td></tr>
<tr class="memitem:ab4a78b9f732e3c35f83ced2c8e1ad7c8" id="r_ab4a78b9f732e3c35f83ced2c8e1ad7c8"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="#a921f7998dbc51e8b4298b1fbb2369686">Frame</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab4a78b9f732e3c35f83ced2c8e1ad7c8">ShallowClone</a> () const</td></tr>
<tr class="memdesc:ab4a78b9f732e3c35f83ced2c8e1ad7c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) Returns a shallow clone (i.e., dependent elements such as bodies are aliased, not copied) that is not associated with any MbT (so the assigned index, if any, is discarded).  <br /></td></tr>
<tr id="pub-methods-0" class="groupHeader"><td colspan="2"><div class="groupHeader">Does not allow copy, move, or assignment</div></td></tr>
<tr class="memitem:a921f7998dbc51e8b4298b1fbb2369686" id="r_a921f7998dbc51e8b4298b1fbb2369686"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a921f7998dbc51e8b4298b1fbb2369686">Frame</a> (const Frame &amp;)=delete</td></tr>
<tr class="memitem:a0132e78948ea65a861789fb77aebd4e0" id="r_a0132e78948ea65a861789fb77aebd4e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a921f7998dbc51e8b4298b1fbb2369686">Frame</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0132e78948ea65a861789fb77aebd4e0">operator=</a> (const <a class="el" href="#a921f7998dbc51e8b4298b1fbb2369686">Frame</a> &amp;)=delete</td></tr>
<tr class="memitem:aced939d5919bf90594d6821ab9bf0fb8" id="r_aced939d5919bf90594d6821ab9bf0fb8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aced939d5919bf90594d6821ab9bf0fb8">Frame</a> (Frame &amp;&amp;)=delete</td></tr>
<tr class="memitem:a239b1b644a4300af0ab0ff81780a03f4" id="r_a239b1b644a4300af0ab0ff81780a03f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a921f7998dbc51e8b4298b1fbb2369686">Frame</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a239b1b644a4300af0ab0ff81780a03f4">operator=</a> (<a class="el" href="#a921f7998dbc51e8b4298b1fbb2369686">Frame</a> &amp;&amp;)=delete</td></tr>
<tr class="inherit_header pub_methods_classdrake_1_1multibody_1_1_multibody_element"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_classdrake_1_1multibody_1_1_multibody_element')"><span class="dynarrow"><span class="arrowhead closed"></span></span>Public Member Functions inherited from <a class="el" href="classdrake_1_1multibody_1_1_multibody_element.html">MultibodyElement&lt; T &gt;</a></td></tr>
<tr class="memitem:a1703fe23765583a9ceb91bfba1adc896 inherit pub_methods_classdrake_1_1multibody_1_1_multibody_element" id="r_a1703fe23765583a9ceb91bfba1adc896"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_element.html#a1703fe23765583a9ceb91bfba1adc896">~MultibodyElement</a> ()</td></tr>
<tr class="memitem:acd2192bbd60e8c8d2c14763041d66d50 inherit pub_methods_classdrake_1_1multibody_1_1_multibody_element" id="r_acd2192bbd60e8c8d2c14763041d66d50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_element.html#acd2192bbd60e8c8d2c14763041d66d50">model_instance</a> () const</td></tr>
<tr class="memdesc:acd2192bbd60e8c8d2c14763041d66d50 inherit pub_methods_classdrake_1_1multibody_1_1_multibody_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0" title="Type used to identify model instances by index within a multibody plant.">ModelInstanceIndex</a> of the model instance to which this element belongs.  <br /></td></tr>
<tr class="memitem:aefc839e3d729d61ce618a5849da279e1 inherit pub_methods_classdrake_1_1multibody_1_1_multibody_element" id="r_aefc839e3d729d61ce618a5849da279e1"><td class="memTemplParams" colspan="2">template&lt;typename = void&gt; </td></tr>
<tr class="memitem:aefc839e3d729d61ce618a5849da279e1 inherit pub_methods_classdrake_1_1multibody_1_1_multibody_element template"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html">MultibodyPlant</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_element.html#aefc839e3d729d61ce618a5849da279e1">GetParentPlant</a> () const</td></tr>
<tr class="memdesc:aefc839e3d729d61ce618a5849da279e1 inherit pub_methods_classdrake_1_1multibody_1_1_multibody_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> that owns this MultibodyElement.  <br /></td></tr>
<tr class="memitem:a78bee989062e1b311dbd90831ac9959f inherit pub_methods_classdrake_1_1multibody_1_1_multibody_element" id="r_a78bee989062e1b311dbd90831ac9959f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_element.html#a78bee989062e1b311dbd90831ac9959f">DeclareParameters</a> (internal::MultibodyTreeSystem&lt; T &gt; *tree_system)</td></tr>
<tr class="memdesc:a78bee989062e1b311dbd90831ac9959f inherit pub_methods_classdrake_1_1multibody_1_1_multibody_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares MultibodyTreeSystem Parameters at MultibodyTreeSystem::Finalize() time.  <br /></td></tr>
<tr class="memitem:af084609147b7e91add9fb620a12735e3 inherit pub_methods_classdrake_1_1multibody_1_1_multibody_element" id="r_af084609147b7e91add9fb620a12735e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_element.html#af084609147b7e91add9fb620a12735e3">SetDefaultParameters</a> (<a class="el" href="classdrake_1_1systems_1_1_parameters.html">systems::Parameters</a>&lt; T &gt; *parameters) const</td></tr>
<tr class="memdesc:af084609147b7e91add9fb620a12735e3 inherit pub_methods_classdrake_1_1multibody_1_1_multibody_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets default values of parameters belonging to each MultibodyElement in <span class="tt">parameters</span> at a call to MultibodyTreeSystem::SetDefaultParameters().  <br /></td></tr>
<tr class="memitem:a3866d0245d1722869287b159c0b6adb3 inherit pub_methods_classdrake_1_1multibody_1_1_multibody_element" id="r_a3866d0245d1722869287b159c0b6adb3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_element.html#a3866d0245d1722869287b159c0b6adb3">DeclareDiscreteState</a> (internal::MultibodyTreeSystem&lt; T &gt; *tree_system)</td></tr>
<tr class="memdesc:a3866d0245d1722869287b159c0b6adb3 inherit pub_methods_classdrake_1_1multibody_1_1_multibody_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares MultibodyTreeSystem discrete states.  <br /></td></tr>
<tr class="memitem:a91a60255e4ba08ef36d6a913c47e1e91 inherit pub_methods_classdrake_1_1multibody_1_1_multibody_element" id="r_a91a60255e4ba08ef36d6a913c47e1e91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_element.html#a91a60255e4ba08ef36d6a913c47e1e91">DeclareCacheEntries</a> (internal::MultibodyTreeSystem&lt; T &gt; *tree_system)</td></tr>
<tr class="memdesc:a91a60255e4ba08ef36d6a913c47e1e91 inherit pub_methods_classdrake_1_1multibody_1_1_multibody_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) Declares all cache entries needed by this element.  <br /></td></tr>
<tr class="memitem:ae050e0d4d07cfeb79d77626a7175f596 inherit pub_methods_classdrake_1_1multibody_1_1_multibody_element" id="r_ae050e0d4d07cfeb79d77626a7175f596"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_element.html#ae050e0d4d07cfeb79d77626a7175f596">is_ephemeral</a> () const</td></tr>
<tr class="memdesc:ae050e0d4d07cfeb79d77626a7175f596 inherit pub_methods_classdrake_1_1multibody_1_1_multibody_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <span class="tt">true</span> if this MultibodyElement was added during Finalize() rather than something a user added.  <br /></td></tr>
<tr class="memitem:aec74a0672620a8670aaf06ba7c00e1c9 inherit pub_methods_classdrake_1_1multibody_1_1_multibody_element" id="r_aec74a0672620a8670aaf06ba7c00e1c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_element.html#aec74a0672620a8670aaf06ba7c00e1c9">set_is_ephemeral</a> (bool <a class="el" href="classdrake_1_1multibody_1_1_multibody_element.html#ae050e0d4d07cfeb79d77626a7175f596">is_ephemeral</a>)</td></tr>
<tr class="memdesc:aec74a0672620a8670aaf06ba7c00e1c9 inherit pub_methods_classdrake_1_1multibody_1_1_multibody_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) Sets the <span class="tt"><a class="el" href="classdrake_1_1multibody_1_1_multibody_element.html#ae050e0d4d07cfeb79d77626a7175f596" title="Returns true if this MultibodyElement was added during Finalize() rather than something a user added.">is_ephemeral</a></span> flag to the indicated value.  <br /></td></tr>
<tr class="memitem:a2d506f577f85b2c7c49a678007ef2f8b inherit pub_methods_classdrake_1_1multibody_1_1_multibody_element" id="r_a2d506f577f85b2c7c49a678007ef2f8b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_element.html#a2d506f577f85b2c7c49a678007ef2f8b">MultibodyElement</a> (const MultibodyElement &amp;)=delete</td></tr>
<tr class="memitem:acbe8d50a258932cf45f52b3bfb3e96b9 inherit pub_methods_classdrake_1_1multibody_1_1_multibody_element" id="r_acbe8d50a258932cf45f52b3bfb3e96b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_multibody_element.html#a2d506f577f85b2c7c49a678007ef2f8b">MultibodyElement</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_element.html#acbe8d50a258932cf45f52b3bfb3e96b9">operator=</a> (const <a class="el" href="classdrake_1_1multibody_1_1_multibody_element.html#a2d506f577f85b2c7c49a678007ef2f8b">MultibodyElement</a> &amp;)=delete</td></tr>
<tr class="memitem:a8659b2212916d36167001616643398f1 inherit pub_methods_classdrake_1_1multibody_1_1_multibody_element" id="r_a8659b2212916d36167001616643398f1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_element.html#a8659b2212916d36167001616643398f1">MultibodyElement</a> (MultibodyElement &amp;&amp;)=delete</td></tr>
<tr class="memitem:a4fa21d9742cf691bfd607a73d5005680 inherit pub_methods_classdrake_1_1multibody_1_1_multibody_element" id="r_a4fa21d9742cf691bfd607a73d5005680"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_multibody_element.html#a2d506f577f85b2c7c49a678007ef2f8b">MultibodyElement</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_element.html#a4fa21d9742cf691bfd607a73d5005680">operator=</a> (<a class="el" href="classdrake_1_1multibody_1_1_multibody_element.html#a2d506f577f85b2c7c49a678007ef2f8b">MultibodyElement</a> &amp;&amp;)=delete</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pro-methods" class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a5e25fc7d512e8a22236622f3326ccd0d" id="r_a5e25fc7d512e8a22236622f3326ccd0d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5e25fc7d512e8a22236622f3326ccd0d">DoCalcPoseInBodyFrame</a> (const <a class="el" href="classdrake_1_1systems_1_1_parameters.html">systems::Parameters</a>&lt; T &gt; &amp;parameters) const =0</td></tr>
<tr class="memitem:ac8928684361bcc2fca812ddfae884bb5" id="r_ac8928684361bcc2fca812ddfae884bb5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">math::RotationMatrix</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac8928684361bcc2fca812ddfae884bb5">DoCalcRotationMatrixInBodyFrame</a> (const <a class="el" href="classdrake_1_1systems_1_1_parameters.html">systems::Parameters</a>&lt; T &gt; &amp;parameters) const =0</td></tr>
<tr class="memitem:ab169d4a563a02214049b7626f62bbcbd" id="r_ab169d4a563a02214049b7626f62bbcbd"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab169d4a563a02214049b7626f62bbcbd">DoCalcOffsetPoseInBody</a> (const <a class="el" href="classdrake_1_1systems_1_1_parameters.html">systems::Parameters</a>&lt; T &gt; &amp;parameters, const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; T &gt; &amp;X_FQ) const</td></tr>
<tr class="memitem:a8bafd16c1c2d7dfad8c413b1012fc4e9" id="r_a8bafd16c1c2d7dfad8c413b1012fc4e9"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">math::RotationMatrix</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8bafd16c1c2d7dfad8c413b1012fc4e9">DoCalcOffsetRotationMatrixInBody</a> (const <a class="el" href="classdrake_1_1systems_1_1_parameters.html">systems::Parameters</a>&lt; T &gt; &amp;parameters, const <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">math::RotationMatrix</a>&lt; T &gt; &amp;R_FQ) const</td></tr>
<tr id="pro-methods-0" class="groupHeader"><td colspan="2"><div class="groupHeader">Methods to make a clone, optionally templated on different scalar</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p>types.</p>
<p>The first three are meant to be called by MultibodyTree::CloneToScalar() when making a clone of the entire tree or a new instance templated on a different scalar type. The only const argument to these methods is the new MultibodyTree clone under construction. Specific Frame subclasses might specify a number of prerequisites on the cloned tree and therefore require it to be at a given state of cloning. See MultibodyTree::CloneToScalar() for a list of prerequisites that are guaranteed to be satisfied during the cloning process. </p>
</div></td></tr>
<tr class="memitem:a28167855937b28ef48da220bc063a16c" id="r_a28167855937b28ef48da220bc063a16c"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="#a921f7998dbc51e8b4298b1fbb2369686">Frame</a>&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a28167855937b28ef48da220bc063a16c">DoCloneToScalar</a> (const internal::MultibodyTree&lt; double &gt; &amp;tree_clone) const =0</td></tr>
<tr class="memdesc:a28167855937b28ef48da220bc063a16c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clones this Frame (templated on T) to a frame templated on <span class="tt">double</span>.  <br /></td></tr>
<tr class="memitem:a4240009b149bca1222ffaa1a615ba345" id="r_a4240009b149bca1222ffaa1a615ba345"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="#a921f7998dbc51e8b4298b1fbb2369686">Frame</a>&lt; <a class="el" href="namespacedrake.html#a3d6302a0051e9403c9df3ed6808f3854">AutoDiffXd</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4240009b149bca1222ffaa1a615ba345">DoCloneToScalar</a> (const internal::MultibodyTree&lt; <a class="el" href="namespacedrake.html#a3d6302a0051e9403c9df3ed6808f3854">AutoDiffXd</a> &gt; &amp;tree_clone) const =0</td></tr>
<tr class="memdesc:a4240009b149bca1222ffaa1a615ba345"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clones this Frame (templated on T) to a frame templated on <a class="el" href="namespacedrake.html#a3d6302a0051e9403c9df3ed6808f3854" title="A scalar type that performs automatic differentiation.">AutoDiffXd</a>.  <br /></td></tr>
<tr class="memitem:aa58648a850c80fd1cb22eec01326283f" id="r_aa58648a850c80fd1cb22eec01326283f"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="#a921f7998dbc51e8b4298b1fbb2369686">Frame</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa58648a850c80fd1cb22eec01326283f">DoCloneToScalar</a> (const internal::MultibodyTree&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt; &amp;) const =0</td></tr>
<tr class="memitem:a85a7cc085e039dc8ebe04a4aaaf6eb4c" id="r_a85a7cc085e039dc8ebe04a4aaaf6eb4c"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="#a921f7998dbc51e8b4298b1fbb2369686">Frame</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a85a7cc085e039dc8ebe04a4aaaf6eb4c">DoShallowClone</a> () const</td></tr>
<tr class="memdesc:a85a7cc085e039dc8ebe04a4aaaf6eb4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">NVI for <a class="el" href="#ab4a78b9f732e3c35f83ced2c8e1ad7c8" title="(Internal use only) Returns a shallow clone (i.e., dependent elements such as bodies are aliased,...">ShallowClone()</a>.  <br /></td></tr>
<tr class="inherit_header pro_methods_classdrake_1_1multibody_1_1_multibody_element"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pro_methods_classdrake_1_1multibody_1_1_multibody_element')"><span class="dynarrow"><span class="arrowhead closed"></span></span>Protected Member Functions inherited from <a class="el" href="classdrake_1_1multibody_1_1_multibody_element.html">MultibodyElement&lt; T &gt;</a></td></tr>
<tr class="memitem:a7b561934ea4adacae196c9f85cfa6f13 inherit pro_methods_classdrake_1_1multibody_1_1_multibody_element" id="r_a7b561934ea4adacae196c9f85cfa6f13"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_element.html#a7b561934ea4adacae196c9f85cfa6f13">MultibodyElement</a> ()</td></tr>
<tr class="memdesc:a7b561934ea4adacae196c9f85cfa6f13 inherit pro_methods_classdrake_1_1multibody_1_1_multibody_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor made protected so that sub-classes can still declare their default constructors if they need to.  <br /></td></tr>
<tr class="memitem:a5a912f1fd024549f45d6197eadc30e48 inherit pro_methods_classdrake_1_1multibody_1_1_multibody_element" id="r_a5a912f1fd024549f45d6197eadc30e48"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_element.html#a5a912f1fd024549f45d6197eadc30e48">MultibodyElement</a> (<a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> <a class="el" href="classdrake_1_1multibody_1_1_multibody_element.html#acd2192bbd60e8c8d2c14763041d66d50">model_instance</a>)</td></tr>
<tr class="memdesc:a5a912f1fd024549f45d6197eadc30e48 inherit pro_methods_classdrake_1_1multibody_1_1_multibody_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor which allows specifying a model instance.  <br /></td></tr>
<tr class="memitem:a35978a256b0f4488ebc9026116b3c364 inherit pro_methods_classdrake_1_1multibody_1_1_multibody_element" id="r_a35978a256b0f4488ebc9026116b3c364"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_element.html#a35978a256b0f4488ebc9026116b3c364">MultibodyElement</a> (<a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> <a class="el" href="classdrake_1_1multibody_1_1_multibody_element.html#acd2192bbd60e8c8d2c14763041d66d50">model_instance</a>, int64_t index)</td></tr>
<tr class="memdesc:a35978a256b0f4488ebc9026116b3c364 inherit pro_methods_classdrake_1_1multibody_1_1_multibody_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Both the model instance and element index are specified.  <br /></td></tr>
<tr class="memitem:aded9a9cca94a35fc5ab0eb794ecfb6f9 inherit pro_methods_classdrake_1_1multibody_1_1_multibody_element" id="r_aded9a9cca94a35fc5ab0eb794ecfb6f9"><td class="memTemplParams" colspan="2">template&lt;typename ElementIndexType&gt; </td></tr>
<tr class="memitem:aded9a9cca94a35fc5ab0eb794ecfb6f9 inherit pro_methods_classdrake_1_1multibody_1_1_multibody_element template"><td class="memItemLeft" align="right" valign="top">ElementIndexType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_element.html#aded9a9cca94a35fc5ab0eb794ecfb6f9">index_impl</a> () const</td></tr>
<tr class="memdesc:aded9a9cca94a35fc5ab0eb794ecfb6f9 inherit pro_methods_classdrake_1_1multibody_1_1_multibody_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns this element's unique index.  <br /></td></tr>
<tr class="memitem:a4e00fa4f13ff51e93bdb20990852e813 inherit pro_methods_classdrake_1_1multibody_1_1_multibody_element" id="r_a4e00fa4f13ff51e93bdb20990852e813"><td class="memTemplParams" colspan="2">template&lt;typename ElementOrdinalType = int64_t&gt; </td></tr>
<tr class="memitem:a4e00fa4f13ff51e93bdb20990852e813 inherit pro_methods_classdrake_1_1multibody_1_1_multibody_element template"><td class="memItemLeft" align="right" valign="top">ElementOrdinalType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_element.html#a4e00fa4f13ff51e93bdb20990852e813">ordinal_impl</a> () const</td></tr>
<tr class="memdesc:a4e00fa4f13ff51e93bdb20990852e813 inherit pro_methods_classdrake_1_1multibody_1_1_multibody_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns this element's unique ordinal.  <br /></td></tr>
<tr class="memitem:a647f12860ab08828aedabdc06fc55b00 inherit pro_methods_classdrake_1_1multibody_1_1_multibody_element" id="r_a647f12860ab08828aedabdc06fc55b00"><td class="memItemLeft" align="right" valign="top">const internal::MultibodyTree&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_element.html#a647f12860ab08828aedabdc06fc55b00">get_parent_tree</a> () const</td></tr>
<tr class="memdesc:a647f12860ab08828aedabdc06fc55b00 inherit pro_methods_classdrake_1_1multibody_1_1_multibody_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the parent MultibodyTree that owns this element.  <br /></td></tr>
<tr class="memitem:ac94cbee880b500f4a96865e431181b40 inherit pro_methods_classdrake_1_1multibody_1_1_multibody_element" id="r_ac94cbee880b500f4a96865e431181b40"><td class="memItemLeft" align="right" valign="top">const internal::MultibodyTreeSystem&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_element.html#ac94cbee880b500f4a96865e431181b40">GetParentTreeSystem</a> () const</td></tr>
<tr class="memdesc:ac94cbee880b500f4a96865e431181b40 inherit pro_methods_classdrake_1_1multibody_1_1_multibody_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the parent MultibodyTreeSystem that owns the parent MultibodyTree that owns this element.  <br /></td></tr>
<tr class="memitem:a9f03f5a6d341cb0d918b3d450f6fdb58 inherit pro_methods_classdrake_1_1multibody_1_1_multibody_element" id="r_a9f03f5a6d341cb0d918b3d450f6fdb58"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_element.html#a9f03f5a6d341cb0d918b3d450f6fdb58">SetTopology</a> ()</td></tr>
<tr class="memdesc:a9f03f5a6d341cb0d918b3d450f6fdb58 inherit pro_methods_classdrake_1_1multibody_1_1_multibody_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) Gives MultibodyElement-derived objects the opportunity to set data members that depend on topology and coordinate assignments having been finalized.  <br /></td></tr>
<tr class="memitem:a3394b67729adad18156be78ac98281fe inherit pro_methods_classdrake_1_1multibody_1_1_multibody_element" id="r_a3394b67729adad18156be78ac98281fe"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_element.html#a3394b67729adad18156be78ac98281fe">DoDeclareDiscreteState</a> (internal::MultibodyTreeSystem&lt; T &gt; *)</td></tr>
<tr class="memdesc:a3394b67729adad18156be78ac98281fe inherit pro_methods_classdrake_1_1multibody_1_1_multibody_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the NVI <a class="el" href="classdrake_1_1multibody_1_1_multibody_element.html#a3866d0245d1722869287b159c0b6adb3" title="Declares MultibodyTreeSystem discrete states.">DeclareDiscreteState()</a>.  <br /></td></tr>
<tr class="memitem:a23bbf0a8dab0eeaf8e967745e6048e5d inherit pro_methods_classdrake_1_1multibody_1_1_multibody_element" id="r_a23bbf0a8dab0eeaf8e967745e6048e5d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_element.html#a23bbf0a8dab0eeaf8e967745e6048e5d">DoDeclareCacheEntries</a> (internal::MultibodyTreeSystem&lt; T &gt; *)</td></tr>
<tr class="memdesc:a23bbf0a8dab0eeaf8e967745e6048e5d inherit pro_methods_classdrake_1_1multibody_1_1_multibody_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived classes must override this method to declare cache entries needed by <span class="tt">this</span> element.  <br /></td></tr>
<tr class="memitem:a7a976e6fccd8686189b1fdbf1d2cc722 inherit pro_methods_classdrake_1_1multibody_1_1_multibody_element" id="r_a7a976e6fccd8686189b1fdbf1d2cc722"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1systems.html#af11369a06c5bfd3fa18acb79f85777df">systems::NumericParameterIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_element.html#a7a976e6fccd8686189b1fdbf1d2cc722">DeclareNumericParameter</a> (internal::MultibodyTreeSystem&lt; T &gt; *tree_system, const <a class="el" href="classdrake_1_1systems_1_1_basic_vector.html">systems::BasicVector</a>&lt; T &gt; &amp;model_vector)</td></tr>
<tr class="memdesc:a7a976e6fccd8686189b1fdbf1d2cc722 inherit pro_methods_classdrake_1_1multibody_1_1_multibody_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">To be used by MultibodyElement-derived objects when declaring parameters in their implementation of <a class="el" href="classdrake_1_1multibody_1_1_multibody_element.html#a81c425ccd8cf5adb6b0d496ad7f4b314" title="Implementation of the NVI DeclareParameters().">DoDeclareParameters()</a>.  <br /></td></tr>
<tr class="memitem:a57aa9aaaab0516dbcbaf970347c76611 inherit pro_methods_classdrake_1_1multibody_1_1_multibody_element" id="r_a57aa9aaaab0516dbcbaf970347c76611"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1systems.html#a86b350169906f6d5e07e9db46e36d57a">systems::AbstractParameterIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_element.html#a57aa9aaaab0516dbcbaf970347c76611">DeclareAbstractParameter</a> (internal::MultibodyTreeSystem&lt; T &gt; *tree_system, const <a class="el" href="classdrake_1_1_abstract_value.html">AbstractValue</a> &amp;model_value)</td></tr>
<tr class="memdesc:a57aa9aaaab0516dbcbaf970347c76611 inherit pro_methods_classdrake_1_1multibody_1_1_multibody_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">To be used by MultibodyElement-derived objects when declaring parameters in their implementation of <a class="el" href="classdrake_1_1multibody_1_1_multibody_element.html#a81c425ccd8cf5adb6b0d496ad7f4b314" title="Implementation of the NVI DeclareParameters().">DoDeclareParameters()</a>.  <br /></td></tr>
<tr class="memitem:a80ae3195088941d76212740a197117c5 inherit pro_methods_classdrake_1_1multibody_1_1_multibody_element" id="r_a80ae3195088941d76212740a197117c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1systems.html#acf2a50397e9fa764d32553cf98460ba7">systems::DiscreteStateIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_element.html#a80ae3195088941d76212740a197117c5">DeclareDiscreteState</a> (internal::MultibodyTreeSystem&lt; T &gt; *tree_system, const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;model_value)</td></tr>
<tr class="memdesc:a80ae3195088941d76212740a197117c5 inherit pro_methods_classdrake_1_1multibody_1_1_multibody_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">To be used by MultibodyElement-derived objects when declaring discrete states in their implementation of DoDeclareDiscreteStates().  <br /></td></tr>
<tr class="memitem:a89e7a15170271f05c5a81e133ea83fcc inherit pro_methods_classdrake_1_1multibody_1_1_multibody_element" id="r_a89e7a15170271f05c5a81e133ea83fcc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1systems_1_1_cache_entry.html">systems::CacheEntry</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_element.html#a89e7a15170271f05c5a81e133ea83fcc">DeclareCacheEntry</a> (internal::MultibodyTreeSystem&lt; T &gt; *tree_system, std::string description, <a class="el" href="classdrake_1_1systems_1_1_value_producer.html">systems::ValueProducer</a> value_producer, std::set&lt; <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">systems::DependencyTicket</a> &gt; prerequisites_of_calc)</td></tr>
<tr class="memdesc:a89e7a15170271f05c5a81e133ea83fcc inherit pro_methods_classdrake_1_1multibody_1_1_multibody_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">To be used by MultibodyElement-derived objects when declaring cache entries in their implementation of <a class="el" href="classdrake_1_1multibody_1_1_multibody_element.html#a23bbf0a8dab0eeaf8e967745e6048e5d" title="Derived classes must override this method to declare cache entries needed by this element.">DoDeclareCacheEntries()</a>.  <br /></td></tr>
<tr class="memitem:af679af47835138fca8011749414d3bd4 inherit pro_methods_classdrake_1_1multibody_1_1_multibody_element" id="r_af679af47835138fca8011749414d3bd4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_element.html#af679af47835138fca8011749414d3bd4">has_parent_tree</a> () const</td></tr>
<tr class="memdesc:af679af47835138fca8011749414d3bd4 inherit pro_methods_classdrake_1_1multibody_1_1_multibody_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this multibody element has a parent tree, otherwise false.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-member-group" class="groupheader"><a id="member-group" name="member-group"></a>
Internal use only</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>These functions work directly with the frame body pose cache entry. </p>
</td></tr>
<tr class="memitem:ad6f622812a34d39933a4866423064123" id="r_ad6f622812a34d39933a4866423064123"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad6f622812a34d39933a4866423064123">set_body_pose_index_in_cache</a> (int body_pose_index)</td></tr>
<tr class="memdesc:ad6f622812a34d39933a4866423064123"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) A Frame's pose-in-parent X_PF can be parameterized, the parent's pose may also be parameterized, and so on.  <br /></td></tr>
<tr class="memitem:a13ba8ca46e472757c51b8b0808e3e220" id="r_a13ba8ca46e472757c51b8b0808e3e220"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a13ba8ca46e472757c51b8b0808e3e220">get_body_pose_index_in_cache</a> () const</td></tr>
<tr class="memdesc:a13ba8ca46e472757c51b8b0808e3e220"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) Retrieve this Frame's body pose index in the cache.  <br /></td></tr>
<tr class="memitem:a5d46708bf7b6b4c5488319bdbe700d87" id="r_a5d46708bf7b6b4c5488319bdbe700d87"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5d46708bf7b6b4c5488319bdbe700d87">get_X_BF</a> (const internal::FrameBodyPoseCache&lt; T &gt; &amp;frame_body_poses) const</td></tr>
<tr class="memdesc:a5d46708bf7b6b4c5488319bdbe700d87"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) Given an already up-to-date frame body pose cache, extract X_BF for this Frame from it.  <br /></td></tr>
<tr class="memitem:ab40f3ccecb682ff128a8f10e302be621" id="r_ab40f3ccecb682ff128a8f10e302be621"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab40f3ccecb682ff128a8f10e302be621">get_X_FB</a> (const internal::FrameBodyPoseCache&lt; T &gt; &amp;frame_body_poses) const</td></tr>
<tr class="memdesc:ab40f3ccecb682ff128a8f10e302be621"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) Given an already up-to-date frame body pose cache, extract X_FB (=X_BF⁻¹) for this Frame from it.  <br /></td></tr>
<tr class="memitem:a8122f6b68972e5ee63d6806da34e2f95" id="r_a8122f6b68972e5ee63d6806da34e2f95"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8122f6b68972e5ee63d6806da34e2f95">is_X_BF_identity</a> (const internal::FrameBodyPoseCache&lt; T &gt; &amp;frame_body_poses) const</td></tr>
<tr class="memdesc:a8122f6b68972e5ee63d6806da34e2f95"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) Given an already up-to-date frame body pose cache, returns whether X_BF (and thus X_FB) is exactly identity.  <br /></td></tr>
<tr class="memitem:a463192cd66dda4c63fe256e0ad1004d6" id="r_a463192cd66dda4c63fe256e0ad1004d6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a463192cd66dda4c63fe256e0ad1004d6">Frame</a> (const std::string &amp;<a class="el" href="#a24dcbf29c0d6cd766009a182a6484e3b">name</a>, const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;<a class="el" href="#af7a5e902b948cca72b9209752aba0d3c">body</a>, std::optional&lt; <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> &gt; <a class="el" href="classdrake_1_1multibody_1_1_multibody_element.html#acd2192bbd60e8c8d2c14763041d66d50">model_instance</a>={})</td></tr>
<tr class="memdesc:a463192cd66dda4c63fe256e0ad1004d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Only derived classes can use this constructor.  <br /></td></tr>
<tr class="memitem:a1f059110215fa08c1fe519e29737f452" id="r_a1f059110215fa08c1fe519e29737f452"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f059110215fa08c1fe519e29737f452">DoDeclareFrameParameters</a> (internal::MultibodyTreeSystem&lt; T &gt; *)</td></tr>
<tr class="memdesc:a1f059110215fa08c1fe519e29737f452"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by DoDeclareParameters().  <br /></td></tr>
<tr class="memitem:a358afbe8ee25409df05f9979a335e1ba" id="r_a358afbe8ee25409df05f9979a335e1ba"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a358afbe8ee25409df05f9979a335e1ba">DoSetDefaultFrameParameters</a> (<a class="el" href="classdrake_1_1systems_1_1_parameters.html">systems::Parameters</a>&lt; T &gt; *) const</td></tr>
<tr class="memdesc:a358afbe8ee25409df05f9979a335e1ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by DoSetDefaultParameters().  <br /></td></tr>
</table>
<a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a921f7998dbc51e8b4298b1fbb2369686" name="a921f7998dbc51e8b4298b1fbb2369686"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a921f7998dbc51e8b4298b1fbb2369686">&#9670;&#160;</a></span>Frame() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Frame </td>
          <td>(</td>
          <td class="paramtype">const Frame&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aced939d5919bf90594d6821ab9bf0fb8" name="aced939d5919bf90594d6821ab9bf0fb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aced939d5919bf90594d6821ab9bf0fb8">&#9670;&#160;</a></span>Frame() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Frame </td>
          <td>(</td>
          <td class="paramtype">Frame&lt; T &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa0f3f98e61d00d6d126bba55efbff728" name="aa0f3f98e61d00d6d126bba55efbff728"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0f3f98e61d00d6d126bba55efbff728">&#9670;&#160;</a></span>~Frame()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="#a921f7998dbc51e8b4298b1fbb2369686">Frame</a> </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel override">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a463192cd66dda4c63fe256e0ad1004d6" name="a463192cd66dda4c63fe256e0ad1004d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a463192cd66dda4c63fe256e0ad1004d6">&#9670;&#160;</a></span>Frame() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Frame </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>body</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>model_instance</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel explicit">explicit</span><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Only derived classes can use this constructor. </p>
<p>It creates a Frame object attached to <span class="tt"><a class="el" href="#af7a5e902b948cca72b9209752aba0d3c" title="Returns a const reference to the body associated to this Frame.">body</a></span> and puts the frame in the body's model instance. </p>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="af7a5e902b948cca72b9209752aba0d3c" name="af7a5e902b948cca72b9209752aba0d3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7a5e902b948cca72b9209752aba0d3c">&#9670;&#160;</a></span>body()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp; body </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a const reference to the body associated to this Frame. </p>

</div>
</div>
<a id="a606d1fae37bb5759acb4744a653e2b15" name="a606d1fae37bb5759acb4744a653e2b15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a606d1fae37bb5759acb4744a653e2b15">&#9670;&#160;</a></span>CalcAngularVelocity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; CalcAngularVelocity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a921f7998dbc51e8b4298b1fbb2369686">Frame</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>measured_in_frame</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a921f7998dbc51e8b4298b1fbb2369686">Frame</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>expressed_in_frame</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates <span class="tt">this</span> frame F's angular velocity measured in a frame M, expressed in a frame E. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>contains the state of the multibody system. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">measured_in_frame</td><td>which is frame M (the frame in which <span class="tt">this</span> angular velocity is to be measured). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">expressed_in_frame</td><td>which is frame E (the frame in which the returned angular velocity is to be expressed). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ω_MF_E, <span class="tt">this</span> frame F's angular velocity ω measured in frame M, expressed in frame E. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ab869854391d326b0d230ed5c4a46b7d8" title="Evaluates this frame F&#39;s angular velocity measured and expressed in the world frame W.">EvalAngularVelocityInWorld()</a> to evaluate ω_WF_W (<span class="tt">this</span> frame F's angular velocity ω measured and expressed in the world frame W). </dd></dl>

</div>
</div>
<a id="a1f1f6d8f6718b83c4d7f4864e4b5ef4d" name="a1f1f6d8f6718b83c4d7f4864e4b5ef4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f1f6d8f6718b83c4d7f4864e4b5ef4d">&#9670;&#160;</a></span>CalcOffsetPoseInBody()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; T &gt; CalcOffsetPoseInBody </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>X_FQ</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given the offset pose <span class="tt">X_FQ</span> of a frame Q in <span class="tt">this</span> frame F, this method computes the pose <span class="tt">X_BQ</span> of frame Q in the body frame B to which this frame is attached. </p>
<p>In other words, if the pose of <span class="tt">this</span> frame F in the body frame B is <span class="tt">X_BF</span>, this method computes the pose <span class="tt">X_BQ</span> of frame Q in the body frame B as <span class="tt">X_BQ = X_BF * X_FQ</span>. In particular, if <span class="tt">this</span> <b>is</b> the body frame B, i.e. <span class="tt">X_BF</span> is the identity transformation, this method directly returns <span class="tt">X_FQ</span>. Specific frame subclasses can override this method to provide faster implementations if needed. </p>

</div>
</div>
<a id="af974101d46b2ddc2a89484f726da729e" name="af974101d46b2ddc2a89484f726da729e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af974101d46b2ddc2a89484f726da729e">&#9670;&#160;</a></span>CalcOffsetRotationMatrixInBody()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">math::RotationMatrix</a>&lt; T &gt; CalcOffsetRotationMatrixInBody </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">math::RotationMatrix</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>R_FQ</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates and returns the rotation matrix <span class="tt">R_BQ</span> that relates body frame B to frame Q via <span class="tt">this</span> intermediate frame F, i.e., <span class="tt">R_BQ = R_BF * R_FQ</span> (B is the body frame to which <span class="tt">this</span> frame F is attached). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">R_FQ</td><td>rotation matrix that relates frame F to frame Q. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6e6be2a2ffa00f74b2988eb6b160f4ce" name="a6e6be2a2ffa00f74b2988eb6b160f4ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e6be2a2ffa00f74b2988eb6b160f4ce">&#9670;&#160;</a></span>CalcPose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; T &gt; CalcPose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a921f7998dbc51e8b4298b1fbb2369686">Frame</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>frame_M</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes and returns the pose <span class="tt">X_MF</span> of <span class="tt">this</span> frame F in measured in <span class="tt">frame_M</span> as a function of the state of the model stored in <span class="tt">context</span>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a2f1ab566c4c4e25645fa9712c275a434" title="Computes and returns the pose X_WF of this frame F in the world frame W as a function of the state of...">CalcPoseInWorld()</a>. </dd></dl>

</div>
</div>
<a id="a5335d24722724ebc56d37a2880aeebd4" name="a5335d24722724ebc56d37a2880aeebd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5335d24722724ebc56d37a2880aeebd4">&#9670;&#160;</a></span>CalcPoseInBodyFrame()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; T &gt; CalcPoseInBodyFrame </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the pose <span class="tt">X_BF</span> of <span class="tt">this</span> frame F in the body frame B associated with this frame. </p>
<p>In particular, if <span class="tt">this</span> <b>is</b> the body frame B, this method directly returns the identity transformation. Note that this ONLY depends on the Parameters in the context; it does not depend on time, input, state, etc. </p>

</div>
</div>
<a id="a2f1ab566c4c4e25645fa9712c275a434" name="a2f1ab566c4c4e25645fa9712c275a434"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f1ab566c4c4e25645fa9712c275a434">&#9670;&#160;</a></span>CalcPoseInWorld()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; T &gt; CalcPoseInWorld </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes and returns the pose <span class="tt">X_WF</span> of <span class="tt">this</span> frame F in the world frame W as a function of the state of the model stored in <span class="tt">context</span>. </p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html#af5348fed610d8b4c89c7445e30c09df6" title="Returns the pose X_WB of this RigidBody B in the world frame W as a function of the state of the mode...">RigidBody::EvalPoseInWorld()</a> provides a more efficient way to obtain the pose for a body frame. </dd></dl>

</div>
</div>
<a id="ab8f2d64f408f1404ef93f2abdfb9738f" name="ab8f2d64f408f1404ef93f2abdfb9738f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8f2d64f408f1404ef93f2abdfb9738f">&#9670;&#160;</a></span>CalcRelativeSpatialAcceleration()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_spatial_acceleration.html">SpatialAcceleration</a>&lt; T &gt; CalcRelativeSpatialAcceleration </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a921f7998dbc51e8b4298b1fbb2369686">Frame</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other_frame</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a921f7998dbc51e8b4298b1fbb2369686">Frame</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>measured_in_frame</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a921f7998dbc51e8b4298b1fbb2369686">Frame</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>expressed_in_frame</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates <span class="tt">this</span> frame C's spatial acceleration relative to another frame B, measured in a frame M, expressed in a frame E. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>contains the state of the multibody system. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">other_frame</td><td>which is frame B. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">measured_in_frame</td><td>which is frame M. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">expressed_in_frame</td><td>which is frame E. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A_M_BC_E = A_MC_E - A_MB_E, frame C's spatial acceleration relative to frame B, measured in frame M, expressed in frame E.</dd></dl>
<p>In general, A_M_BC = DtW(V_M_BC), the time-derivative in frame M of frame C's spatial velocity relative to frame B. The rotational part of the returned quantity is α_MC_E - α_MB_E = DtM(ω_BC)_E. Note: For 3D analysis, DtM(ω_BC) ≠ α_BC. The translational part of the returned quantity is a_M_BoCo_E (Co's translational acceleration relative to Bo, measured in frame M, expressed in frame E). </p><pre>
 α_MC_E - α_MB_E = DtM(ω_MC)_E - DtM(ω_MB)_E = DtM(ω_BC)_E
 a_M_BoCo_E = a_MCo_E - a_MBo_E = DtM(v_MCo) - DtM(v_MBo) = Dt²M(p_BoCo)_E
</pre><p> where Dt²M(p_BoCo)_E is the 2ⁿᵈ time-derivative in frame M of p_BoCo (the position vector from Bo to Co), and this result is expressed in frame E. </p><dl class="section note"><dt>Note</dt><dd>The calculation of the 2ⁿᵈ time-derivative of the distance between Bo and Co can be done with relative translational acceleration, but this calculation does not depend on the measured-in-frame, hence in this case, consider <a class="el" href="#a88af386f4cce8fe95b75ccfd01bfed66" title="Calculates this frame C&#39;s spatial acceleration relative to another frame B, measured and expressed in...">CalcRelativeSpatialAccelerationInWorld()</a> since it is faster. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a2fe2b1457ab123c9a3cdf6db20826400" title="Calculates this frame F&#39;s spatial acceleration measured and expressed in the world frame W.">CalcSpatialAccelerationInWorld()</a>, <a class="el" href="#ad26da01fad6bb3778253eb34924fb840" title="Calculates this frame F&#39;s spatial acceleration measured in a frame M, expressed in a frame E.">CalcSpatialAcceleration()</a>, and <a class="el" href="#a88af386f4cce8fe95b75ccfd01bfed66" title="Calculates this frame C&#39;s spatial acceleration relative to another frame B, measured and expressed in...">CalcRelativeSpatialAccelerationInWorld()</a>. </dd></dl>

</div>
</div>
<a id="a88af386f4cce8fe95b75ccfd01bfed66" name="a88af386f4cce8fe95b75ccfd01bfed66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88af386f4cce8fe95b75ccfd01bfed66">&#9670;&#160;</a></span>CalcRelativeSpatialAccelerationInWorld()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_spatial_acceleration.html">SpatialAcceleration</a>&lt; T &gt; CalcRelativeSpatialAccelerationInWorld </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a921f7998dbc51e8b4298b1fbb2369686">Frame</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other_frame</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates <span class="tt">this</span> frame C's spatial acceleration relative to another frame B, measured and expressed in the world frame W. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>contains the state of the multibody system. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">other_frame</td><td>which is frame B. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A_W_BC_W = A_WC_W - A_WB_W, frame C's spatial acceleration relative to frame B, measured and expressed in the world frame W.</dd></dl>
<p>In general, A_W_BC = DtW(V_W_BC), the time-derivative in the world frame W of frame C's spatial velocity relative to frame B. The rotational part of the returned quantity is α_WC_W - α_WB_W = DtW(ω_BC)_W. For 3D analysis, DtW(ω_BC) ≠ α_BC. The translational part of the returned quantity is a_W_BoCo_W (Co's translational acceleration relative to Bo, measured and expressed in world frame W). </p><pre>
 α_WC_W - α_WB_W = DtW(ω_WC)_W - DtW(ω_WB)_W = DtW(ω_BC)_W
 a_W_BoCo_W = a_WCo_W - a_WBo_W = DtW(v_WCo) - DtW(v_WBo) = Dt²W(p_BoCo)_W
</pre><p> where Dt²W(p_BoCo)_W is the 2ⁿᵈ time-derivative in frame W of p_BoCo (the position vector from Bo to Co), and this result is expressed in frame W. </p><dl class="section note"><dt>Note</dt><dd>The method <a class="el" href="#a2fe2b1457ab123c9a3cdf6db20826400" title="Calculates this frame F&#39;s spatial acceleration measured and expressed in the world frame W.">CalcSpatialAccelerationInWorld()</a> is more efficient and coherent if any of <span class="tt">this</span>, other_frame, or the world frame W are the same. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a2fe2b1457ab123c9a3cdf6db20826400" title="Calculates this frame F&#39;s spatial acceleration measured and expressed in the world frame W.">CalcSpatialAccelerationInWorld()</a>, <a class="el" href="#ab8f2d64f408f1404ef93f2abdfb9738f" title="Calculates this frame C&#39;s spatial acceleration relative to another frame B, measured in a frame M,...">CalcRelativeSpatialAcceleration()</a>. </dd></dl>

</div>
</div>
<a id="ae5ed37e2dc9581c253d592922105249f" name="ae5ed37e2dc9581c253d592922105249f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5ed37e2dc9581c253d592922105249f">&#9670;&#160;</a></span>CalcRelativeSpatialVelocity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_spatial_velocity.html">SpatialVelocity</a>&lt; T &gt; CalcRelativeSpatialVelocity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a921f7998dbc51e8b4298b1fbb2369686">Frame</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other_frame</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a921f7998dbc51e8b4298b1fbb2369686">Frame</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>measured_in_frame</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a921f7998dbc51e8b4298b1fbb2369686">Frame</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>expressed_in_frame</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates <span class="tt">this</span> frame C's spatial velocity relative to another frame B, measured in a frame M, expressed in a frame E. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>contains the state of the multibody system. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">other_frame</td><td>which is frame B. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">measured_in_frame</td><td>which is frame M. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">expressed_in_frame</td><td>which is frame E. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>V_M_BC_E = V_MC_E - V_MB_E, frame C's spatial velocity relative to frame B, measured in frame M, expressed in frame E. The rotational part of the returned quantity is ω_BC_E (C's angular velocity measured in B and expressed in E). The translational part is v_M_BoCo_E (Co's translational velocity relative to Bo, measured in M, and expressed in E). <pre>
 ω_BC_E = ω_MC_E - ω_MB_E
 v_M_BoCo_E = v_MCo_E - v_MBo_E = DtM(p_BoCo)
</pre> where DtM(p_BoCo) is the time-derivative in frame M of p_BoCo (position vector from Bo to Co), and this vector is expressed in frame E. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The method <a class="el" href="#a9acd38f4c77a86622deda5e26ff763c4" title="Calculates this frame F&#39;s spatial velocity measured in a frame M, expressed in a frame E.">CalcSpatialVelocity()</a> is more efficient and coherent if any of <span class="tt">this</span>, other_frame, or measured_in_frame are the same. Also, the value of V_M_BoCo does not depend on the measured_in_frame if Bo and Co are coincident (i.e., p_BoCo = 0), in which case consider the more efficient method <a class="el" href="#aea3234e285067e2c032750d2c3be3f0f" title="Calculates this frame C&#39;s spatial velocity relative to another frame B, measured and expressed in the...">CalcRelativeSpatialVelocityInWorld()</a>. Lastly, the calculation of elongation between Bo and Co can be done with relative translational velocity, but elongation does not depend on the measured-in-frame (hence consider <a class="el" href="#aea3234e285067e2c032750d2c3be3f0f" title="Calculates this frame C&#39;s spatial velocity relative to another frame B, measured and expressed in the...">CalcRelativeSpatialVelocityInWorld()</a>). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#afb3f4ddf29eee9d776573336cb75a5fe" title="Calculates this frame F&#39;s spatial velocity measured and expressed in the world frame W.">CalcSpatialVelocityInWorld()</a>, <a class="el" href="#a9acd38f4c77a86622deda5e26ff763c4" title="Calculates this frame F&#39;s spatial velocity measured in a frame M, expressed in a frame E.">CalcSpatialVelocity()</a>, and <a class="el" href="#aea3234e285067e2c032750d2c3be3f0f" title="Calculates this frame C&#39;s spatial velocity relative to another frame B, measured and expressed in the...">CalcRelativeSpatialVelocityInWorld()</a>. </dd></dl>

</div>
</div>
<a id="aea3234e285067e2c032750d2c3be3f0f" name="aea3234e285067e2c032750d2c3be3f0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea3234e285067e2c032750d2c3be3f0f">&#9670;&#160;</a></span>CalcRelativeSpatialVelocityInWorld()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_spatial_velocity.html">SpatialVelocity</a>&lt; T &gt; CalcRelativeSpatialVelocityInWorld </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a921f7998dbc51e8b4298b1fbb2369686">Frame</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other_frame</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates <span class="tt">this</span> frame C's spatial velocity relative to another frame B, measured and expressed in the world frame W. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>contains the state of the multibody system. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">other_frame</td><td>which is frame B. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>V_W_BC_W = V_WC_W - V_WB_W, frame C's spatial velocity relative to frame B, measured and expressed in the world frame W. The rotational part of the returned quantity is ω_BC_W (C's angular velocity measured in B and expressed in W). The translational part is v_W_BoCo_W (Co's translational velocity relative to Bo, measured and expressed in world frame W). <pre>
    ω_BC_W  = ω_WC_W - ω_WB_W
 v_W_BoCo_W = v_WCo_W - v_WBo_W = DtW(p_BoCo)
</pre> where DtW(p_BoCo) is the time-derivative in frame W of p_BoCo (position vector from Bo to Co), and this vector is expressed in frame W. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The method <a class="el" href="#afb3f4ddf29eee9d776573336cb75a5fe" title="Calculates this frame F&#39;s spatial velocity measured and expressed in the world frame W.">CalcSpatialVelocityInWorld()</a> is more efficient and coherent if any of <span class="tt">this</span>, other_frame, or the world frame W are the same. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#afb3f4ddf29eee9d776573336cb75a5fe" title="Calculates this frame F&#39;s spatial velocity measured and expressed in the world frame W.">CalcSpatialVelocityInWorld()</a> and <a class="el" href="#ae5ed37e2dc9581c253d592922105249f" title="Calculates this frame C&#39;s spatial velocity relative to another frame B, measured in a frame M,...">CalcRelativeSpatialVelocity()</a>. </dd></dl>

</div>
</div>
<a id="ad0392fe93d111538f073a608ee051113" name="ad0392fe93d111538f073a608ee051113"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0392fe93d111538f073a608ee051113">&#9670;&#160;</a></span>CalcRotationMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">math::RotationMatrix</a>&lt; T &gt; CalcRotationMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a921f7998dbc51e8b4298b1fbb2369686">Frame</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>frame_M</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates and returns the rotation matrix <span class="tt">R_MF</span> that relates <span class="tt">frame_M</span> and <span class="tt">this</span> frame F as a function of the state stored in <span class="tt">context</span>. </p>

</div>
</div>
<a id="a795668d7ea25354fa43ee73df1499f51" name="a795668d7ea25354fa43ee73df1499f51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a795668d7ea25354fa43ee73df1499f51">&#9670;&#160;</a></span>CalcRotationMatrixInBodyFrame()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">math::RotationMatrix</a>&lt; T &gt; CalcRotationMatrixInBodyFrame </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the rotation matrix <span class="tt">R_BF</span> that relates body frame B to <span class="tt">this</span> frame F (B is the body frame to which <span class="tt">this</span> frame F is attached). </p>
<dl class="section note"><dt>Note</dt><dd>If <span class="tt">this</span> is B, this method returns the identity RotationMatrix. Note that this ONLY depends on the Parameters in the context; it does not depend on time, input, state, etc. </dd></dl>

</div>
</div>
<a id="a3f0e841bc0c32a845c57a564f0157895" name="a3f0e841bc0c32a845c57a564f0157895"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f0e841bc0c32a845c57a564f0157895">&#9670;&#160;</a></span>CalcRotationMatrixInWorld()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">math::RotationMatrix</a>&lt; T &gt; CalcRotationMatrixInWorld </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates and returns the rotation matrix <span class="tt">R_WF</span> that relates the world frame W and <span class="tt">this</span> frame F as a function of the state stored in <span class="tt">context</span>. </p>

</div>
</div>
<a id="ad26da01fad6bb3778253eb34924fb840" name="ad26da01fad6bb3778253eb34924fb840"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad26da01fad6bb3778253eb34924fb840">&#9670;&#160;</a></span>CalcSpatialAcceleration()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_spatial_acceleration.html">SpatialAcceleration</a>&lt; T &gt; CalcSpatialAcceleration </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a921f7998dbc51e8b4298b1fbb2369686">Frame</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>measured_in_frame</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a921f7998dbc51e8b4298b1fbb2369686">Frame</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>expressed_in_frame</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates <span class="tt">this</span> frame F's spatial acceleration measured in a frame M, expressed in a frame E. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>contains the state of the multibody system. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">measured_in_frame</td><td>which is frame M. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">expressed_in_frame</td><td>which is frame E. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A_MF_E, <span class="tt">this</span> frame F's spatial acceleration measured in frame M, expressed in frame E. The rotational part of the returned quantity is α_MF_E (frame F's angular acceleration α measured in frame M, expressed in frame E). The translational part is a_MFo_E (translational acceleration of frame F's origin point Fo, measured in frame M, expressed in frame E). Although α_MF is defined below in terms of DtM(ω_MF), the time-derivative in frame M of ω_MF, the actual calculation of α_MF avoids differentiation. Similarly for the definition vs. calculation for a_MFo. <pre>
 α_MF = DtM(ω_MF)           ω_MF is frame F's angular velocity in frame M.
 a_MFo = DtM(v_MFo)    v_MF is Fo's translational acceleration in frame M.
</pre> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a2fe2b1457ab123c9a3cdf6db20826400" title="Calculates this frame F&#39;s spatial acceleration measured and expressed in the world frame W.">CalcSpatialAccelerationInWorld()</a> and <a class="el" href="#a9acd38f4c77a86622deda5e26ff763c4" title="Calculates this frame F&#39;s spatial velocity measured in a frame M, expressed in a frame E.">CalcSpatialVelocity()</a>. </dd></dl>

</div>
</div>
<a id="a2fe2b1457ab123c9a3cdf6db20826400" name="a2fe2b1457ab123c9a3cdf6db20826400"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fe2b1457ab123c9a3cdf6db20826400">&#9670;&#160;</a></span>CalcSpatialAccelerationInWorld()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_spatial_acceleration.html">SpatialAcceleration</a>&lt; T &gt; CalcSpatialAccelerationInWorld </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates <span class="tt">this</span> frame F's spatial acceleration measured and expressed in the world frame W. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>contains the state of the multibody system. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A_WF_W, <span class="tt">this</span> frame F's spatial acceleration measured and expressed in the world frame W. The rotational part of the returned quantity is α_WF_E (frame F's angular acceleration α measured and expressed in the world frame W). The translational part is a_WFo_W (translational acceleration of frame F's origin point Fo, measured and expressed in the world frame W). </dd></dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html#a7416f40dcb9c2d78afa9fd26d3cec89e" title="Evaluates A_WB, this body B&#39;s SpatialAcceleration in the world frame W.">RigidBody::EvalSpatialAccelerationInWorld()</a> provides a more efficient way to obtain a body frame's spatial acceleration measured in the world frame. </dd>
<dd>
When cached values are out of sync with the state stored in context, this method performs an expensive forward dynamics computation, whereas once evaluated, successive calls to this method are inexpensive. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ad26da01fad6bb3778253eb34924fb840" title="Calculates this frame F&#39;s spatial acceleration measured in a frame M, expressed in a frame E.">CalcSpatialAcceleration()</a> and <a class="el" href="#afb3f4ddf29eee9d776573336cb75a5fe" title="Calculates this frame F&#39;s spatial velocity measured and expressed in the world frame W.">CalcSpatialVelocityInWorld()</a>. </dd></dl>

</div>
</div>
<a id="a9acd38f4c77a86622deda5e26ff763c4" name="a9acd38f4c77a86622deda5e26ff763c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9acd38f4c77a86622deda5e26ff763c4">&#9670;&#160;</a></span>CalcSpatialVelocity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_spatial_velocity.html">SpatialVelocity</a>&lt; T &gt; CalcSpatialVelocity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a921f7998dbc51e8b4298b1fbb2369686">Frame</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>frame_M</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a921f7998dbc51e8b4298b1fbb2369686">Frame</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>frame_E</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates <span class="tt">this</span> frame F's spatial velocity measured in a frame M, expressed in a frame E. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>contains the state of the multibody system. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_M</td><td>which is the measured_in_frame. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_E</td><td>which is the expressed_in_frame. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>V_MF_E, <span class="tt">this</span> frame F's spatial velocity measured in frame M, expressed in frame E. The rotational part of the returned quantity is ω_MF_E (frame F's angular velocity ω measured in frame M, expressed in frame E). The translational part is v_MFo_E (translational velocity v of frame F's origin point Fo, measured in frame M, expressed in frame E). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#afb3f4ddf29eee9d776573336cb75a5fe" title="Calculates this frame F&#39;s spatial velocity measured and expressed in the world frame W.">CalcSpatialVelocityInWorld()</a>, <a class="el" href="#ae5ed37e2dc9581c253d592922105249f" title="Calculates this frame C&#39;s spatial velocity relative to another frame B, measured in a frame M,...">CalcRelativeSpatialVelocity()</a>, and <a class="el" href="#ad26da01fad6bb3778253eb34924fb840" title="Calculates this frame F&#39;s spatial acceleration measured in a frame M, expressed in a frame E.">CalcSpatialAcceleration()</a>. </dd></dl>

</div>
</div>
<a id="afb3f4ddf29eee9d776573336cb75a5fe" name="afb3f4ddf29eee9d776573336cb75a5fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb3f4ddf29eee9d776573336cb75a5fe">&#9670;&#160;</a></span>CalcSpatialVelocityInWorld()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_spatial_velocity.html">SpatialVelocity</a>&lt; T &gt; CalcSpatialVelocityInWorld </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates <span class="tt">this</span> frame F's spatial velocity measured and expressed in the world frame W. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>contains the state of the multibody system. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>V_WF_W, <span class="tt">this</span> frame F's spatial velocity measured and expressed in the world frame W. The rotational part of the returned quantity is ω_WF_W (frame F's angular velocity ω measured and expressed in the world frame W). The translational part is v_WFo_W (translational velocity v of frame F's origin point Fo, measured and expressed in the world frame W). </dd></dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html#ad8ae5e3c7c3df73c212d8bc3f73d84ae" title="Evaluates V_WB, this body B&#39;s SpatialVelocity in the world frame W.">RigidBody::EvalSpatialVelocityInWorld()</a> provides a more efficient way to obtain a body frame's spatial velocity measured in the world frame. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a9acd38f4c77a86622deda5e26ff763c4" title="Calculates this frame F&#39;s spatial velocity measured in a frame M, expressed in a frame E.">CalcSpatialVelocity()</a>, <a class="el" href="#aea3234e285067e2c032750d2c3be3f0f" title="Calculates this frame C&#39;s spatial velocity relative to another frame B, measured and expressed in the...">CalcRelativeSpatialVelocityInWorld()</a>, and <a class="el" href="#a2fe2b1457ab123c9a3cdf6db20826400" title="Calculates this frame F&#39;s spatial acceleration measured and expressed in the world frame W.">CalcSpatialAccelerationInWorld()</a>. </dd></dl>

</div>
</div>
<a id="a24dd310e5292eb141218c1f101f45b5d" name="a24dd310e5292eb141218c1f101f45b5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24dd310e5292eb141218c1f101f45b5d">&#9670;&#160;</a></span>CloneToScalar()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename ToScalar&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="#a921f7998dbc51e8b4298b1fbb2369686">Frame</a>&lt; ToScalar &gt; &gt; CloneToScalar </td>
          <td>(</td>
          <td class="paramtype">const internal::MultibodyTree&lt; ToScalar &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>tree_clone</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Advanced) NVI to <a class="el" href="#a28167855937b28ef48da220bc063a16c" title="Clones this Frame (templated on T) to a frame templated on double.">DoCloneToScalar()</a> templated on the scalar type of the new clone to be created. </p>
<p>This method is mostly intended to be called by MultibodyTree::CloneToScalar(). Most users should not call this clone method directly but rather clone the entire parent MultibodyTree if needed. </p><dl class="section see"><dt>See also</dt><dd>MultibodyTree::CloneToScalar() </dd></dl>

</div>
</div>
<a id="ab169d4a563a02214049b7626f62bbcbd" name="ab169d4a563a02214049b7626f62bbcbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab169d4a563a02214049b7626f62bbcbd">&#9670;&#160;</a></span>DoCalcOffsetPoseInBody()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; T &gt; DoCalcOffsetPoseInBody </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_parameters.html">systems::Parameters</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>parameters</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>X_FQ</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classdrake_1_1multibody_1_1_rigid_body_frame.html#a964f50174510f76493db60ade6855565">RigidBodyFrame&lt; T &gt;</a>, and <a class="el" href="classdrake_1_1multibody_1_1_rigid_body_frame.html#a964f50174510f76493db60ade6855565">RigidBodyFrame&lt; double &gt;</a>.</p>

</div>
</div>
<a id="a8bafd16c1c2d7dfad8c413b1012fc4e9" name="a8bafd16c1c2d7dfad8c413b1012fc4e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bafd16c1c2d7dfad8c413b1012fc4e9">&#9670;&#160;</a></span>DoCalcOffsetRotationMatrixInBody()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">math::RotationMatrix</a>&lt; T &gt; DoCalcOffsetRotationMatrixInBody </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_parameters.html">systems::Parameters</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>parameters</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">math::RotationMatrix</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>R_FQ</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classdrake_1_1multibody_1_1_rigid_body_frame.html#a65b74ea6f2fa229a710e7e712a99132e">RigidBodyFrame&lt; T &gt;</a>, and <a class="el" href="classdrake_1_1multibody_1_1_rigid_body_frame.html#a65b74ea6f2fa229a710e7e712a99132e">RigidBodyFrame&lt; double &gt;</a>.</p>

</div>
</div>
<a id="a5e25fc7d512e8a22236622f3326ccd0d" name="a5e25fc7d512e8a22236622f3326ccd0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e25fc7d512e8a22236622f3326ccd0d">&#9670;&#160;</a></span>DoCalcPoseInBodyFrame()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; T &gt; DoCalcPoseInBodyFrame </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_parameters.html">systems::Parameters</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>parameters</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classdrake_1_1multibody_1_1_fixed_offset_frame.html#aaae143700f382ad02ae66ffb03338d30">FixedOffsetFrame&lt; T &gt;</a>, <a class="el" href="classdrake_1_1multibody_1_1_rigid_body_frame.html#a7840540e7b6c8d4b5ab345621fc89ce8">RigidBodyFrame&lt; T &gt;</a>, and <a class="el" href="classdrake_1_1multibody_1_1_rigid_body_frame.html#a7840540e7b6c8d4b5ab345621fc89ce8">RigidBodyFrame&lt; double &gt;</a>.</p>

</div>
</div>
<a id="ac8928684361bcc2fca812ddfae884bb5" name="ac8928684361bcc2fca812ddfae884bb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8928684361bcc2fca812ddfae884bb5">&#9670;&#160;</a></span>DoCalcRotationMatrixInBodyFrame()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">math::RotationMatrix</a>&lt; T &gt; DoCalcRotationMatrixInBodyFrame </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_parameters.html">systems::Parameters</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>parameters</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classdrake_1_1multibody_1_1_fixed_offset_frame.html#a63b7f1a7b2d057a27105518a5088213f">FixedOffsetFrame&lt; T &gt;</a>, <a class="el" href="classdrake_1_1multibody_1_1_rigid_body_frame.html#a22f04fbcef1160cf13b9afd8b73777ef">RigidBodyFrame&lt; T &gt;</a>, and <a class="el" href="classdrake_1_1multibody_1_1_rigid_body_frame.html#a22f04fbcef1160cf13b9afd8b73777ef">RigidBodyFrame&lt; double &gt;</a>.</p>

</div>
</div>
<a id="a4240009b149bca1222ffaa1a615ba345" name="a4240009b149bca1222ffaa1a615ba345"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4240009b149bca1222ffaa1a615ba345">&#9670;&#160;</a></span>DoCloneToScalar() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt; <a class="el" href="#a921f7998dbc51e8b4298b1fbb2369686">Frame</a>&lt; <a class="el" href="namespacedrake.html#a3d6302a0051e9403c9df3ed6808f3854">AutoDiffXd</a> &gt; &gt; DoCloneToScalar </td>
          <td>(</td>
          <td class="paramtype">const internal::MultibodyTree&lt; <a class="el" href="namespacedrake.html#a3d6302a0051e9403c9df3ed6808f3854">AutoDiffXd</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>tree_clone</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clones this Frame (templated on T) to a frame templated on <a class="el" href="namespacedrake.html#a3d6302a0051e9403c9df3ed6808f3854" title="A scalar type that performs automatic differentiation.">AutoDiffXd</a>. </p>

<p>Implemented in <a class="el" href="classdrake_1_1multibody_1_1_fixed_offset_frame.html#aa63b57f5254a61e87544cbad7ff1bc8e">FixedOffsetFrame&lt; T &gt;</a>, and <a class="el" href="classdrake_1_1multibody_1_1_rigid_body_frame.html#aa63b57f5254a61e87544cbad7ff1bc8e">RigidBodyFrame&lt; T &gt;</a>.</p>

</div>
</div>
<a id="a28167855937b28ef48da220bc063a16c" name="a28167855937b28ef48da220bc063a16c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28167855937b28ef48da220bc063a16c">&#9670;&#160;</a></span>DoCloneToScalar() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt; <a class="el" href="#a921f7998dbc51e8b4298b1fbb2369686">Frame</a>&lt; double &gt; &gt; DoCloneToScalar </td>
          <td>(</td>
          <td class="paramtype">const internal::MultibodyTree&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>tree_clone</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clones this Frame (templated on T) to a frame templated on <span class="tt">double</span>. </p>

<p>Implemented in <a class="el" href="classdrake_1_1multibody_1_1_fixed_offset_frame.html#a0532d9aee770883cdfb972a8575ee4d6">FixedOffsetFrame&lt; T &gt;</a>, <a class="el" href="classdrake_1_1multibody_1_1_rigid_body_frame.html#a0532d9aee770883cdfb972a8575ee4d6">RigidBodyFrame&lt; T &gt;</a>, and <a class="el" href="classdrake_1_1multibody_1_1_rigid_body_frame.html#a0532d9aee770883cdfb972a8575ee4d6">RigidBodyFrame&lt; double &gt;</a>.</p>

</div>
</div>
<a id="aa58648a850c80fd1cb22eec01326283f" name="aa58648a850c80fd1cb22eec01326283f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa58648a850c80fd1cb22eec01326283f">&#9670;&#160;</a></span>DoCloneToScalar() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt; <a class="el" href="#a921f7998dbc51e8b4298b1fbb2369686">Frame</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt; &gt; DoCloneToScalar </td>
          <td>(</td>
          <td class="paramtype">const internal::MultibodyTree&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classdrake_1_1multibody_1_1_fixed_offset_frame.html#a921baf6e8d090e5c3d8a466b392c0c77">FixedOffsetFrame&lt; T &gt;</a>, and <a class="el" href="classdrake_1_1multibody_1_1_rigid_body_frame.html#a921baf6e8d090e5c3d8a466b392c0c77">RigidBodyFrame&lt; T &gt;</a>.</p>

</div>
</div>
<a id="a1f059110215fa08c1fe519e29737f452" name="a1f059110215fa08c1fe519e29737f452"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f059110215fa08c1fe519e29737f452">&#9670;&#160;</a></span>DoDeclareFrameParameters()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void DoDeclareFrameParameters </td>
          <td>(</td>
          <td class="paramtype">internal::MultibodyTreeSystem&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called by DoDeclareParameters(). </p>
<p>Derived classes may choose to override to declare their sub-class specific parameters. </p>

</div>
</div>
<a id="a358afbe8ee25409df05f9979a335e1ba" name="a358afbe8ee25409df05f9979a335e1ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a358afbe8ee25409df05f9979a335e1ba">&#9670;&#160;</a></span>DoSetDefaultFrameParameters()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void DoSetDefaultFrameParameters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_parameters.html">systems::Parameters</a>&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called by DoSetDefaultParameters(). </p>
<p>Derived classes may choose to override to set their sub-class specific parameters. </p>

</div>
</div>
<a id="a85a7cc085e039dc8ebe04a4aaaf6eb4c" name="a85a7cc085e039dc8ebe04a4aaaf6eb4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85a7cc085e039dc8ebe04a4aaaf6eb4c">&#9670;&#160;</a></span>DoShallowClone()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt; <a class="el" href="#a921f7998dbc51e8b4298b1fbb2369686">Frame</a>&lt; T &gt; &gt; DoShallowClone </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>NVI for <a class="el" href="#ab4a78b9f732e3c35f83ced2c8e1ad7c8" title="(Internal use only) Returns a shallow clone (i.e., dependent elements such as bodies are aliased,...">ShallowClone()</a>. </p>

<p>Reimplemented in <a class="el" href="classdrake_1_1multibody_1_1_fixed_offset_frame.html#a1de914248fe41b91fea76569311bcc0d">FixedOffsetFrame&lt; T &gt;</a>, <a class="el" href="classdrake_1_1multibody_1_1_rigid_body_frame.html#a1de914248fe41b91fea76569311bcc0d">RigidBodyFrame&lt; T &gt;</a>, and <a class="el" href="classdrake_1_1multibody_1_1_rigid_body_frame.html#a1de914248fe41b91fea76569311bcc0d">RigidBodyFrame&lt; double &gt;</a>.</p>

</div>
</div>
<a id="ab869854391d326b0d230ed5c4a46b7d8" name="ab869854391d326b0d230ed5c4a46b7d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab869854391d326b0d230ed5c4a46b7d8">&#9670;&#160;</a></span>EvalAngularVelocityInWorld()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp; EvalAngularVelocityInWorld </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates <span class="tt">this</span> frame F's angular velocity measured and expressed in the world frame W. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>contains the state of the multibody system. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ω_WF_W (frame F's angular velocity ω measured and expressed in the world frame W). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a606d1fae37bb5759acb4744a653e2b15" title="Calculates this frame F&#39;s angular velocity measured in a frame M, expressed in a frame E.">CalcAngularVelocity()</a> to calculate ω_MF_E (<span class="tt">this</span> frame F's angular velocity ω measured in a frame M and expressed in a frame E). </dd></dl>

</div>
</div>
<a id="affd9719c2170a4d085c06206f45f721c" name="affd9719c2170a4d085c06206f45f721c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affd9719c2170a4d085c06206f45f721c">&#9670;&#160;</a></span>EvalPoseInBodyFrame()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; T &gt; &amp; EvalPoseInBodyFrame </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reference to the body-relative pose X_BF giving the pose of this <a class="el" href="classdrake_1_1multibody_1_1_frame.html" title="Frame is an abstract class representing a material frame (also called a physical frame) of its underl...">Frame</a> with respect to its body's <a class="el" href="classdrake_1_1multibody_1_1_rigid_body_frame.html" title="A RigidBodyFrame is a material Frame that serves as the unique reference frame for a RigidBody.">RigidBodyFrame</a>. </p>
<p>This may depend on parameters in the Context but not on time or state. The first time this is called after a parameter change will precalculate offset poses for all Frames into the Context's cache; subsequent calls on any Frame are very fast. </p>

</div>
</div>
<a id="a13ba8ca46e472757c51b8b0808e3e220" name="a13ba8ca46e472757c51b8b0808e3e220"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13ba8ca46e472757c51b8b0808e3e220">&#9670;&#160;</a></span>get_body_pose_index_in_cache()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int get_body_pose_index_in_cache </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Internal use only) Retrieve this Frame's body pose index in the cache. </p>

</div>
</div>
<a id="a5d46708bf7b6b4c5488319bdbe700d87" name="a5d46708bf7b6b4c5488319bdbe700d87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d46708bf7b6b4c5488319bdbe700d87">&#9670;&#160;</a></span>get_X_BF()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; T &gt; &amp; get_X_BF </td>
          <td>(</td>
          <td class="paramtype">const internal::FrameBodyPoseCache&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>frame_body_poses</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Internal use only) Given an already up-to-date frame body pose cache, extract X_BF for this Frame from it. </p>
<dl class="section note"><dt>Note</dt><dd>Be sure you have called MultibodyTreeSystem::EvalFrameBodyPoses() since the last parameter change; we can't check here. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">X_BF</td><td>pose of this frame in its body's frame </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab40f3ccecb682ff128a8f10e302be621" name="ab40f3ccecb682ff128a8f10e302be621"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab40f3ccecb682ff128a8f10e302be621">&#9670;&#160;</a></span>get_X_FB()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; T &gt; &amp; get_X_FB </td>
          <td>(</td>
          <td class="paramtype">const internal::FrameBodyPoseCache&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>frame_body_poses</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Internal use only) Given an already up-to-date frame body pose cache, extract X_FB (=X_BF⁻¹) for this Frame from it. </p>
<dl class="section note"><dt>Note</dt><dd>Be sure you have called MultibodyTreeSystem::EvalFrameBodyPoses() since the last parameter change; we can't check here. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">X_FB</td><td>inverse of this frame's pose in its body's frame </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ada1b5bd9d108546400623ce9b031b8cf" name="ada1b5bd9d108546400623ce9b031b8cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada1b5bd9d108546400623ce9b031b8cf">&#9670;&#160;</a></span>GetFixedOffsetPoseInBody()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; T &gt; GetFixedOffsetPoseInBody </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>X_FQ</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Variant of <a class="el" href="#a1f1f6d8f6718b83c4d7f4864e4b5ef4d" title="Given the offset pose X_FQ of a frame Q in this frame F, this method computes the pose X_BQ of frame ...">CalcOffsetPoseInBody()</a> that given the offset pose <span class="tt">X_FQ</span> of a frame Q in <span class="tt">this</span> frame F, returns the pose <span class="tt">X_BQ</span> of frame Q in the body frame B to which this frame is attached. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if called on a Frame that does not have a fixed offset in the body frame. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classdrake_1_1multibody_1_1_rigid_body_frame.html#aba3d455b72ade516762f31d1181a24fd">RigidBodyFrame&lt; T &gt;</a>, and <a class="el" href="classdrake_1_1multibody_1_1_rigid_body_frame.html#aba3d455b72ade516762f31d1181a24fd">RigidBodyFrame&lt; double &gt;</a>.</p>

</div>
</div>
<a id="a4f15964d808fb5542563a4375698c7d6" name="a4f15964d808fb5542563a4375698c7d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f15964d808fb5542563a4375698c7d6">&#9670;&#160;</a></span>GetFixedPoseInBodyFrame()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; T &gt; GetFixedPoseInBodyFrame </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Variant of <a class="el" href="#a5335d24722724ebc56d37a2880aeebd4" title="Returns the pose X_BF of this frame F in the body frame B associated with this frame.">CalcPoseInBodyFrame()</a> that returns the fixed pose <span class="tt">X_BF</span> of <span class="tt">this</span> frame F in the body frame B associated with this frame. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if called on a Frame that does not have a fixed offset in the body frame. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classdrake_1_1multibody_1_1_fixed_offset_frame.html#a528ba536d676b0d6b561d2bf6e3b8876">FixedOffsetFrame&lt; T &gt;</a>, <a class="el" href="classdrake_1_1multibody_1_1_rigid_body_frame.html#a528ba536d676b0d6b561d2bf6e3b8876">RigidBodyFrame&lt; T &gt;</a>, and <a class="el" href="classdrake_1_1multibody_1_1_rigid_body_frame.html#a528ba536d676b0d6b561d2bf6e3b8876">RigidBodyFrame&lt; double &gt;</a>.</p>

</div>
</div>
<a id="ab516edb7052775503f5e7b9a94a5c566" name="ab516edb7052775503f5e7b9a94a5c566"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab516edb7052775503f5e7b9a94a5c566">&#9670;&#160;</a></span>GetFixedRotationMatrixInBody()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">math::RotationMatrix</a>&lt; T &gt; GetFixedRotationMatrixInBody </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">math::RotationMatrix</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>R_FQ</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates and returns the rotation matrix <span class="tt">R_BQ</span> that relates body frame B to frame Q via <span class="tt">this</span> intermediate frame F, i.e., <span class="tt">R_BQ = R_BF * R_FQ</span> (B is the body frame to which <span class="tt">this</span> frame F is attached). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">R_FQ</td><td>rotation matrix that relates frame F to frame Q. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">this</span> frame F is a Frame that does not have a fixed offset in the body frame B (i.e., <span class="tt">R_BF</span> is not constant). </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classdrake_1_1multibody_1_1_rigid_body_frame.html#a41641b1e0c6f670f7caa2aa1c62dbd61">RigidBodyFrame&lt; T &gt;</a>, and <a class="el" href="classdrake_1_1multibody_1_1_rigid_body_frame.html#a41641b1e0c6f670f7caa2aa1c62dbd61">RigidBodyFrame&lt; double &gt;</a>.</p>

</div>
</div>
<a id="acf51fc331733cac246d03c3fa1f6dc7f" name="acf51fc331733cac246d03c3fa1f6dc7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf51fc331733cac246d03c3fa1f6dc7f">&#9670;&#160;</a></span>GetFixedRotationMatrixInBodyFrame()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">math::RotationMatrix</a>&lt; T &gt; GetFixedRotationMatrixInBodyFrame </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the rotation matrix <span class="tt">R_BF</span> that relates body frame B to <span class="tt">this</span> frame F (B is the body frame to which <span class="tt">this</span> frame F is attached). </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">this</span> frame F is a Frame that does not have a fixed offset in the body frame B (i.e., <span class="tt">R_BF</span> is not constant). Frame sub-classes that have a constant <span class="tt">R_BF</span> must override this method. An example of a frame sub-class not implementing this method would be that of a frame on a soft body, for which its pose in the body frame depends on the state of deformation of the body. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classdrake_1_1multibody_1_1_fixed_offset_frame.html#a09191dc7ba0b4b7e4786fd6b6e6ab2f9">FixedOffsetFrame&lt; T &gt;</a>, <a class="el" href="classdrake_1_1multibody_1_1_rigid_body_frame.html#a09191dc7ba0b4b7e4786fd6b6e6ab2f9">RigidBodyFrame&lt; T &gt;</a>, and <a class="el" href="classdrake_1_1multibody_1_1_rigid_body_frame.html#a09191dc7ba0b4b7e4786fd6b6e6ab2f9">RigidBodyFrame&lt; double &gt;</a>.</p>

</div>
</div>
<a id="aacda9c48ea6f77ab847cf27804705b04" name="aacda9c48ea6f77ab847cf27804705b04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacda9c48ea6f77ab847cf27804705b04">&#9670;&#160;</a></span>index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1multibody.html#a51c69848adb64ae45eebc1e5af5dbaa6">FrameIndex</a> index </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns this element's unique index. </p>

</div>
</div>
<a id="a6681a8def9431af1311063721c46fe14" name="a6681a8def9431af1311063721c46fe14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6681a8def9431af1311063721c46fe14">&#9670;&#160;</a></span>is_body_frame()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool is_body_frame </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if <span class="tt">this</span> is the body frame. </p>

</div>
</div>
<a id="a64d83126860c9766c12c88786177cf22" name="a64d83126860c9766c12c88786177cf22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64d83126860c9766c12c88786177cf22">&#9670;&#160;</a></span>is_world_frame()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool is_world_frame </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if <span class="tt">this</span> is the world frame. </p>

</div>
</div>
<a id="a8122f6b68972e5ee63d6806da34e2f95" name="a8122f6b68972e5ee63d6806da34e2f95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8122f6b68972e5ee63d6806da34e2f95">&#9670;&#160;</a></span>is_X_BF_identity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool is_X_BF_identity </td>
          <td>(</td>
          <td class="paramtype">const internal::FrameBodyPoseCache&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>frame_body_poses</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Internal use only) Given an already up-to-date frame body pose cache, returns whether X_BF (and thus X_FB) is exactly identity. </p>
<p>This is precomputed in the cache so is very fast to check. </p><dl class="section note"><dt>Note</dt><dd>Be sure you have called MultibodyTreeSystem::EvalFrameBodyPoses() since the last parameter change; we can't check here. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a5d46708bf7b6b4c5488319bdbe700d87" title="(Internal use only) Given an already up-to-date frame body pose cache, extract X_BF for this Frame fr...">get_X_BF()</a> </dd></dl>

</div>
</div>
<a id="a24dcbf29c0d6cd766009a182a6484e3b" name="a24dcbf29c0d6cd766009a182a6484e3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24dcbf29c0d6cd766009a182a6484e3b">&#9670;&#160;</a></span>name()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; name </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the name of this frame. The name will never be empty. </p>

</div>
</div>
<a id="a0132e78948ea65a861789fb77aebd4e0" name="a0132e78948ea65a861789fb77aebd4e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0132e78948ea65a861789fb77aebd4e0">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a921f7998dbc51e8b4298b1fbb2369686">Frame</a> &amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a921f7998dbc51e8b4298b1fbb2369686">Frame</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a239b1b644a4300af0ab0ff81780a03f4" name="a239b1b644a4300af0ab0ff81780a03f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a239b1b644a4300af0ab0ff81780a03f4">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a921f7998dbc51e8b4298b1fbb2369686">Frame</a> &amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a921f7998dbc51e8b4298b1fbb2369686">Frame</a>&lt; T &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a06542e4ec7c6a884bfcd61c9b00221b4" name="a06542e4ec7c6a884bfcd61c9b00221b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06542e4ec7c6a884bfcd61c9b00221b4">&#9670;&#160;</a></span>scoped_name()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_scoped_name.html">ScopedName</a> scoped_name </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns scoped name of this frame. </p>
<p>Neither of the two pieces of the name will be empty (the scope name and the element name). </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if this element is not associated with a <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad6f622812a34d39933a4866423064123" name="ad6f622812a34d39933a4866423064123"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6f622812a34d39933a4866423064123">&#9670;&#160;</a></span>set_body_pose_index_in_cache()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void set_body_pose_index_in_cache </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>body_pose_index</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Internal use only) A Frame's pose-in-parent X_PF can be parameterized, the parent's pose may also be parameterized, and so on. </p>
<p>Thus the calculation of this frame's pose in its body (X_BF) can be expensive. There is a cache entry that holds the calculated X_BF, evaluated whenever parameters change. This allows us to grab X_BF as a const reference rather than having to extract and reformat parameters, and compose with parent and ancestor poses at runtime.</p>
<p>At the time parameters are allocated we assign a slot in the body pose cache entry to each Frame and record its index using this function. (The index for a <a class="el" href="classdrake_1_1multibody_1_1_rigid_body_frame.html" title="A RigidBodyFrame is a material Frame that serves as the unique reference frame for a RigidBody.">RigidBodyFrame</a> will refer to an identity transform.) Note that the body pose index is not necessarily the same as the Frame index because all RigidBodyFrames can share an entry. (Of course if you know you are working with a <a class="el" href="classdrake_1_1multibody_1_1_rigid_body_frame.html" title="A RigidBodyFrame is a material Frame that serves as the unique reference frame for a RigidBody.">RigidBodyFrame</a> you don't need to ask about its body pose!) </p>

</div>
</div>
<a id="ab4a78b9f732e3c35f83ced2c8e1ad7c8" name="ab4a78b9f732e3c35f83ced2c8e1ad7c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4a78b9f732e3c35f83ced2c8e1ad7c8">&#9670;&#160;</a></span>ShallowClone()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="#a921f7998dbc51e8b4298b1fbb2369686">Frame</a>&lt; T &gt; &gt; ShallowClone </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Internal use only) Returns a shallow clone (i.e., dependent elements such as bodies are aliased, not copied) that is not associated with any MbT (so the assigned index, if any, is discarded). </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>drake/multibody/tree/<a class="el" href="frame_8h.html">frame.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- footer -->
<div class="navpath">
  <ul>
    <li class="navelem"><a href="namespacedrake.html">drake</a></li><li class="navelem"><a href="namespacedrake_1_1multibody.html">multibody</a></li><li class="navelem"><a href="classdrake_1_1multibody_1_1_frame.html">Frame</a></li>
  </ul>
</div>
<footer id="nav-path", class="site-footer padding">
  <div class="contain">
    <a href="/" class="drake-logo">
      <img src="/images/drake-logo.svg"/>
    </a>
    <div class="footer-menu">
      <ul>
        <li>
          <a href="https://accessibility.mit.edu/" class="site-menu-item">Accessibility</a>
        </li>
        <li>
          <a href="/doxygen_cxx/index.html" class="site-menu-item">C++</a>
        </li>
        <li>
          <a href="/pydrake/index.html" class="site-menu-item">Python</a>
        </li>
        <li class="github-link">
          <a href="https://github.com/RobotLocomotion/drake" class="site-menu-item">GitHub <img src="/third_party/images/GitHub-Mark-64px.png"/></a>
        </li>
      </ul>
    </div>
  </div>
</footer>
<script type="text/javascript">
searchBox.searchLabel = 'Go to name…';
searchBox.DOMSearchField().placeholder = searchBox.searchLabel;
searchBox.DOMSearchField().value = '';
</script>
</body>
</html>
