<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: Modeling Compliant Contact</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<header class="site-header">
 <div class="site-header-inner contain">
  <a class="drake-logo" href="/"><img src="/images/drake-logo-white.svg"></a>
  <div class="menu-mobile-toggle">
   <span></span>
  </div>
  <nav class="site-menu">
   <ul>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/">Home</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/installation.html">Installation</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/gallery.html">Gallery</a>
    </li>
    <li class="site-menu-item site-menu-item-main">API Documentation
     <div class="sub">
      <a class="site-menu-item" href="/doxygen_cxx/index.html">C++</a>
      <a class="site-menu-item" href="/pydrake/index.html">Python</a>
     </div>
    </li>
    <li class="site-menu-item site-menu-item-main">Resources
     <div class="sub">
      <a class="site-menu-item" href="/getting_help.html">Getting Help</a>
      <a class="site-menu-item" href="https://deepnote.com/workspace/Drake-0b3b2c53-a7ad-441b-80f8-bf8350752305/project/Tutorials-2b4fc509-aef2-417d-a40d-6071dfed9199/%2Findex.ipynb">Tutorials</a>
      <a class="site-menu-item" href="/python_bindings.html">Python Bindings</a>
      <a class="site-menu-item" href="/developers.html">For Developers</a>
      <a class="site-menu-item" href="/credits.html">Credits</a>
     </div>
    </li>
    <li class="github-link">
     <a class="site-menu-item" href="https://github.com/RobotLocomotion/drake">GitHub <img src="/third_party/images/GitHub-Mark-Light-64px.png"></a>
    </li>
   </ul>
  </nav>
 </div>
</header>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
<div class="title-banner">
 <div class="title-banner__title">
  Drake C++ Documentation
 </div>
 <div id="DDGSearch">
  <form id="search_form_cpp" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search C++ API only…">
   <input type="hidden" name="q" value="site:drake.mit.edu/doxygen_cxx">
  </form>
  <form id="search_form" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search all of Drake…">
   <input type="hidden" name="q" value="site:drake.mit.edu OR site:underactuated.csail.mit.edu OR site:manipulation.csail.mit.edu">
  </form>
 </div>
 <div id="MSearchBoxContainer">
          <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
 </div>
</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__compliant__contact.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Modeling Compliant Contact<div class="ingroups"><a class="el" href="group__multibody.html">Multibody Kinematics and Dynamics</a> &raquo; <a class="el" href="group__drake__contacts.html">Contact Modeling in Drake</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<h1><a class="anchor" id="compliant_point_contact"></a>
Compliant Point Contact</h1>
<p>The point contact model defines the contact force by determining the minimum translational displacement (MTD). The minimum translational displacement is the smallest relative displacement between two volumes that will take them from intersecting to just touching. This quantity need not be unique (if two spheres have coincident centers, any direction will serve). Once we have this displacement, we get three quantities that we use to define the contact force:</p><ul>
<li>The direction of the displacement vector is the contact normal.</li>
<li>The magnitude is a measure of the amount of penetration (and is correlated with the magnitude of the normal component of the contact force).</li>
<li>Two witness points for the MTD. The witness points comprise one point on the surface of each volume such that when we apply the minimum translational displacement, they are coincident. We use the witness points (and other physical parameters) to define the point at which the contact force is applied.</li>
</ul>
<p>This model is simple to implement and cheap to compute, but has some drawbacks.</p>
<ul>
<li>A single measure of “maximum penetration” cannot distinguish between a large intersecting volume and a small intersecting volume (see Figure 1). The two intersections would produce the same amount of contact force despite the fact that one is clearly compressing more material.</li>
<li>Contact along a large interface is treated as contact at a single point (see Figure 2). Effects that depend on a contact interface over a domain with non-zero area disappear (e.g., torsional friction).</li>
<li>The witness points are not necessarily unique. This means, generally, there is no guarantee that the witness points will be consistent from frame to frame, which means that the point at which the force is applied will not be consistent. This can produce non-physical artifacts like sudden changes in force direction.</li>
</ul>
<div class="image">
<img src="contact-fig-01.png" alt="contact-fig-01.png"/>
</div>
<p>Figure 1: Two intersections with significantly different intersecting volumes characterized with the same measure: d.</p>
<div class="image">
<img src="contact-fig-02.png" alt="contact-fig-02.png"/>
</div>
<p>Figure 2: Modeling contact forces with point contact (considering the blue half space as rigid). (a) the actual intersection of the simulated bodies. (b) the conceptual deformation of the orange body creating a large area of contact. (c) how point contact sees the deformation: contact at a single point.</p>
<h2><a class="anchor" id="point_forces_modeling"></a>
Modeling of Forces</h2>
<p>Given the "maximum penetration" x, we compute the normal component of the contact force according to a simple compliant law of the form: </p><pre>
   fₙ = k(x)₊(1 + dẋ)₊
</pre><p> with <code>(a)₊ = max(0, a)</code>. The normal contact force <code>fₙ</code> is made a continuous function of the penetration distance x between the bodies (defined to be positive when the bodies are in contact) and the penetration distance rate ẋ (with ẋ &gt; 0 meaning the penetration distance is increasing and therefore the interpenetration between the bodies is also increasing). Stiffness <code>k</code> and dissipation <code>d</code> are the combined "effective" stiffness and dissipation for the pair of contacting geometries. Dissipation is modeled using a Hunt &amp; Crossley model of dissipation, see <a class="el" href="group__compliant__contact.html#mbp_dissipation_model">Modeling Dissipation</a> for details. For flexibility of parameterization, stiffness and dissipation are set on a per-geometry basis (<a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#accessing_contact_properties">Accessing point contact parameters</a>). Given two geometries with individual stiffness and dissipation parameters (k₁, d₁) and (k₂, d₂), we define the rule for combined stiffness (k) and dissipation (d) as: </p><pre>
  k = (k₁⋅k₂)/(k₁+k₂)
  d = (k₂/(k₁+k₂))⋅d₁ + (k₁/(k₁+k₂))⋅d₂
</pre><p> These parameters are optional for each geometry. For any geometry not assigned these parameters by a user Pre-Finalize, MultibodyPlant will assign default values such that the combined parameters of two geometries with default values match those estimated using the user-supplied "penetration allowance", see <a class="el" href="group__compliant__contact.html#point_contact_defaults">Default Parameters</a>.</p>
<dl class="section note"><dt>Note</dt><dd>When modeling stiff materials such as steel or ceramics, these model parameters often need to be tuned as a trade-off between numerical stiffness and physical accuracy. Stiffer materials lead to a harder to solve system of equations, affecting the overall performance of the simulation. The convex approximations provided in Drake are very robust even at high stiffness values, please refer to <a class="el" href="group__drake__contacts.html#Castro2023">[Castro et al., 2023]</a> for a study on the effect of stiffness on solver performance.</dd></dl>
<h3><a class="anchor" id="point_contact_defaults"></a>
Default Parameters</h3>
<dl class="section note"><dt>Note</dt><dd>The treatment of default parameters is undergoing a major revision. Please refer to the documentation for <a class="el" href="structdrake_1_1geometry_1_1_default_proximity_properties.html">DefaultProximityProperties</a> and for <a class="el" href="namespacedrake_1_1multibody.html#a7e468aa35ef6a84196ac20a13065ca0c" title="Adds a new MultibodyPlant and SceneGraph to the given builder.">AddMultibodyPlant()</a>. For now, we still support the "penetration
allowance" workflow outlined below, but that might change.</dd></dl>
<p>While we strongly recommend setting these parameters appropriately for your model, <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html">MultibodyPlant</a> aids the estimation of these coefficients using a heuristic function based on a user-supplied "penetration allowance", see <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a1e5e058b968b927f6342a8127aea663a">set_penetration_allowance()</a>. This heuristics offers a good starting point when creating a simulation for the first time. Users can then set material properties for specific geometries once they observe the results of a first simulation with these defaults. The penetration allowance is a number in meters that specifies the order of magnitude of the average penetration between bodies in the system that the user is willing to accept as reasonable for the problem being solved. For instance, in the robotic manipulation of ordinary daily objects the user might set this number to 1 millimeter. However, the user might want to increase it for the simulation of heavy walking robots for which an allowance of 1 millimeter would result in a very stiff system.</p>
<p>As for the dissipation coefficient in the simple law above, <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html">MultibodyPlant</a> chooses the dissipation coefficient d to model inelastic collisions and therefore sets it so that the penetration distance x behaves as a critically damped oscillator. That is, at the limit of ideal rigid contact (very high stiffness k or equivalently the penetration allowance goes to zero), this method behaves as a unilateral constraint on the penetration distance, which models a perfect inelastic collision. For most applications, such as manipulation and walking, this is the desired behavior.</p>
<p>When <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a1e5e058b968b927f6342a8127aea663a">set_penetration_allowance()</a> is called, <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html">MultibodyPlant</a> will estimate reasonable stiffness and dissipation coefficients as a function of the input penetration allowance. Users will want to run their simulation a number of times to determine if they are satisfied with the level of inter-penetration actually observed in the simulation; if the observed penetration is too large, the user will want to set a smaller penetration allowance. If the system is too stiff and the time integration requires very small time steps while at the same time the user can afford larger inter-penetrations, the user will want to increase the penetration allowance. Typically, the observed penetration will be proportional to the penetration allowance. Thus scaling the penetration allowance by say a factor of 0.5, would typically results in inter-penetrations being reduced by the same factor of 0.5. In summary, users should choose the largest penetration allowance that results in inter-penetration levels that are acceptable for the particular application (even when in theory this penetration should be zero for perfectly rigid bodies.)</p>
<p>For a given penetration allowance, the contact interaction that takes two bodies with a non-zero approaching velocity to zero approaching velocity, takes place in a finite amount of time (for ideal rigid contact this time is zero.) A good estimate of this time period is given by a call to <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a3338392f611d5d9f93d0ea90e172c68c">get_contact_penalty_method_time_scale()</a>. Users might want to query this value to either set the maximum time step in error-controlled time integration or to set the time step for fixed time step integration. As a guidance, typical fixed time step integrators will become unstable for time steps larger than about a tenth of this time scale.</p>
<h2><a class="anchor" id="crafting_collision_geometry"></a>
Choosing the Right Collision Geometry</h2>
<p>The compliant point contact model only reports a single contact between bodies. More particularly, the contact is characterized by a single point. In some cases (e.g., a steel ball on a table surface), that is perfectly fine. For objects that contact across a large surface area (such as a box on the table), this characterization has two negative implications:</p><ul>
<li>the contact point will not be guaranteed to be at the center of pressure, possibly inducing unrealistic torque, and</li>
<li>not be temporally coherent. This will lead to instability artifacts which can only be addressed through smaller time steps.</li>
</ul>
<p>Both of these issues can be addressed by changing the geometry that represent the body's contact surface. For some shapes (e.g., boxes), we can introduce two sets of collision elements: discrete "points" at the corners, and a box capturing the volume (see <a href="https://github.com/RobotLocomotion/drake/blob/master/examples/kuka_iiwa_arm/models/objects/block_for_pick_and_place.urdf">block_for_pick_and_place.urdf</a> and <a href="https://github.com/RobotLocomotion/drake/blob/master/examples/multibody/inclined_plane_with_body/inclined_plane_with_body.cc">inclined_plane_with_body.cc</a> in Drake's examples). With this strategy, the contact "points" are actually small-radius spheres. The volume-capturing box should actually be inset from those spheres such that when the box is lying on a plane (such that the logical contact manifold would be a face), only the contact points make contact, providing reliable points of contact. However, for arbitrary configurations contact with the box will provide more general contact.</p>
<p>The Hydroelastic contact model described below in <a class="el" href="group__compliant__contact.html#hydro_contact">Hydroelastic Contact</a>, was designed to resolve these issues in a principled manner. We recommend switching to this model unless other requirements such as simulation speed are a constraint.</p>
<h1><a class="anchor" id="hydro_contact"></a>
Hydroelastic Contact</h1>
<p>The purpose of this documentation is to provide a quick overview of the Hydroelastic contact model and its modeling parameters. More details are provided in Drake's <a class="el" href="group__hydroelastic__user__guide.html">Hydroelastic Contact User Guide</a> and references therein.</p>
<p>Hydroelastic contact was created to address some of the short-comings in point contact. In fact, one might argue that many of the strategies used to mitigate the shortcomings of point contact (such as using lots of points) push it closer and closer to hydroelastic contact.</p>
<p>Hydroelastic Contact was originally introduced by <a class="el" href="group__hydroelastic__user__guide.html#Elandt2019">[Elandt et al., 2019]</a>. Modifications and further development of the model can be found in <a class="el" href="group__hydroelastic__user__guide.html#Masterjohn2022">[Masterjohn et al., 2022]</a>. In Drake, we refer to this model as the “hydroelastic” model. It differs from point contact in how it characterizes the contact. Rather than a single point, it imagines an entire contact surface. This surface is an approximation of the contact surface as visualized in Figure 2(b).</p>
<p>When two objects come into contact, forces are produced due to deformation ("strain") of the objects at the contact interface. At first touch, there are no forces but as the objects are pressed further they deform to produce a region over which contact pressure is non-zero, causing equal-and-opposite forces to act on the objects. Calculating the actual deformations is expensive. Hydroelastic contact is based on the idea that for relatively small deformations we can approximate the resulting contact interface and pressure distribution without having to compute the actual deformations. We do that by precalculating a "pressure field" on the interior of compliant objects (see Figure 3). The pressure field approximates the pressure that would result from deforming the surface to some point within the field. A point on the surface (that is, no deformation) experiences zero pressure, but as it is pressed inward, it experiences an increase in pressure (up to a maximum pressure on the interior of the body). When two bodies are colliding, we look for a surface in the intersecting volume where the pressure on the surface is the same in each object; it’s an equilibrium surface (see Figure 4). There is pressure defined across the entire contact surface. It is integrated to define the resultant contact force and moment.</p>
<div class="image">
<img src="contact-fig-03.png" alt="contact-fig-03.png"/>
</div>
<p>Figure 3: Three shapes and possible pressure fields in the interior of the object. Pressure is zero at the outer boundary, and maximum on the interior.</p>
<div class="image">
<img src="contact-fig-04.png" alt="contact-fig-04.png"/>
</div>
<p>Figure 4: The equilibrium contact surface (pale green) between two bodies where the left-hand, yellow body has (a) less compliance, (b) equal compliance, and (c) greater compliance.</p>
<p>This equilibrium surface has important properties:</p><ul>
<li>The contact surface will always be contained within the intersecting volume.</li>
<li>The surface’s edge will always lie on the surface of both objects and have zero pressure.</li>
<li>The location of the surface depends on the relative compliance of the two objects. As one object becomes more rigid than the other, the contact surface begins to converge to its surface (see Figure 4). As one surface becomes perfectly rigid, the other object deforms completely to conform to its shape.</li>
<li>The contacting bodies need not be convex, nor will the contact surface between two objects necessarily be a single contiguous patch. For non-convex geometries, the contact can be meaningfully represented by multiple disjoint patches. The resultant contact force will still be meaningful.</li>
<li>The resultant contact force is continuous with respect to the relative pose between bodies. In fact, the contact surface’s mesh, its area, and the pressures measured on the surface are likewise continuous.</li>
</ul>
<h2><a class="anchor" id="hydro_model_parameters"></a>
Model Parameters</h2>
<p>The hydroelastic modulus has units of pressure, i.e. <code>Pa (N/m²)</code>. The hydroelastic modulus is often estimated based on the Young's modulus of the material though in the hydroelastic model it represents an effective elastic property. For instance, <a class="el" href="group__hydroelastic__user__guide.html#Elandt2019">[Elandt et al., 2019]</a> chooses to use <code>E = G</code>, with <code>G</code> the P-wave elastic modulus <code>G = (1-ν)/(1+ν)/(1-2ν)E</code>, with ν the Poisson ratio, consistent with the theory of layered solids in which plane sections remain planar after compression. Another possibility is to specify <code>E = E*</code>, with <code>E*</code> the effective elastic modulus given by the Hertz theory of contact, <code>E* = E/(1-ν²)</code>. In all of these cases a sound estimation of <code>hydroelastic_modulus</code> starts with the Young's modulus of the material. However, due to numerical conditioning, much smaller values are used in practice for hard materials such as steel. While Young's modulus of steel is about 200 GPa (2×10¹¹ Pa), hydroelastic modulus values of about 10⁵−10⁷ Pa lead to good approximations of rigid contact, with no practical reason to use higher values.</p>
<dl class="section note"><dt>Note</dt><dd>Although the hydroelastic modulus carries the same units as the more familiar elastic moduli mentioned above, it is qualitatively different. Do not expect to use values for those moduli for the hydroelastic modulus to good effect.</dd></dl>
<p>As with point contact, the hydroelastic contact model uses a Hunt &amp; Crossley dissipation model (see <a class="el" href="group__compliant__contact.html#mbp_dissipation_model">Modeling Dissipation</a>). It differs in defining the combined effective dissipation parameter; for hydroelastic contact, the combined dissipation depends on the hydroelastic moduli of the contacting geometries. For two hydroelastic bodies A and B, with hydroelastic moduli <code>Eᵃ</code> and <code>Eᵇ</code>, respectively, and dissipation <code>dᵃ</code> and <code>dᵇ</code>, respectively, the effective dissipation is defined according to the combination law: </p><pre>
  E = Eᵃ⋅Eᵇ/(Eᵃ + Eᵇ),
  d = E/Eᵃ⋅dᵃ + E/Eᵇ⋅dᵇ = Eᵇ/(Eᵃ+Eᵇ)⋅dᵃ + Eᵃ/(Eᵃ+Eᵇ)⋅dᵇ
</pre><p> thus dissipation is weighted in accordance with the fact that the softer material will deform more and faster and thus the softer material dissipation is given more importance.</p>
<p>The <a class="el" href="group__hydroelastic__user__guide.html#hug_geometry_properties">hydroelastic user guide</a> shows how values for these properties can be assigned to geometries.</p>
<h2><a class="anchor" id="hydro_practice"></a>
Hydroelastic Contact in practice</h2>
<p>The theory operates on arbitrary geometries and pressure fields. In practice, we operate on discrete representations of both the geometry and the field.</p>
<p>Compliant objects are represented by tetrahedral meshes. The Drake data type is <a class="el" href="classdrake_1_1geometry_1_1_volume_mesh.html">VolumeMesh</a>. The pressure fields on those meshes are piecewise linear.</p>
<p>The resulting contact surface is likewise a discrete mesh. This mesh may be built of nothing but triangles or polygons. The choice of representation has various implications on the computation of contact forces (see below). The pressure on the contact surface is likewise a piecewise linear function.</p>
<p>Objects with very large hydroelastic modulus can introduce stiffness into the numerics of the contact resolution computation and lead to ill conditioning, affecting simulation performance and robustness. For these cases, Drake permits declaring an object as "rigid hydroelastic" (see <a class="el" href="group__hydroelastic__user__guide.html#creating_hydro_reps">Creating hydroelastic representations of collision geometries</a>.) When a <em>rigid</em> hydroelastic object interacts with other <em>compliant</em> hydroelastic objects, the contact surface always follows the surface of the rigid object. Think of it as the compliant object doing 100% of the deformation, so it conforms to the shape of the rigid object. However, rigid hydroelastic objects have limitations. There is no hydroelastic contact surface between two rigid hydroelastic representations &ndash; when contact is observed between two such objects, the contact will be characterized with point contact (or maybe even throw), depending on how the <a class="el" href="group__hydroelastic__user__guide.html#hug_enabling">contact model</a> has been configured. For this reason, the use of the rigid hydroelastic declaration should be used judiciously &ndash; making everything compliant can be simpler in reasoning about the scene.</p>
<p>Important points to note:</p><ul>
<li>The time cost of resolving contact scales with the complexity of the contact surface (number of faces).</li>
<li>The complexity of the contact surface is a function of the complexity of the contacting geometries.</li>
<li>The best performance comes from the lowest resolution meshes that produce “acceptable” behaviors.</li>
<li>It is not universally true that every geometry is represented discretely. The implementation may represent some shapes differently when it allows performance improvements. The canonical example would be a half space geometry. As a shape with infinite volume, it would be infeasible to create a finite, discrete representation. It is also unnecessary. Intersecting meshes directly with a half space is far more efficient.</li>
</ul>
<h1><a class="anchor" id="mbp_dissipation_model"></a>
Modeling Dissipation</h1>
<p>We use a dissipation model inspired by the model in <a class="el" href="group__drake__contacts.html#HuntCrossley1975">[Hunt and Crossley 1975]</a>, parameterized by a dissipation constant with units of inverse of velocity, i.e. <code>s/m</code>.</p>
<p>To be more precise, compliant point contact forces are modeled as a function of state x: </p><pre>
  f(x) = fₑ(x)⋅(1 - d⋅vₙ(x))₊
</pre><p> where here <code>fₑ(x)</code> denotes the elastic forces, vₙ(x) is the contact velocity in the normal direction (negative when objects approach) and <code>(a)₊</code> denotes "the
positive part of a". The model parameter <code>d</code> is the Hunt &amp; Crossley dissipation constant, in s/m. The Hunt &amp; Crossley term <code>(1 - d⋅vₙ(x))₊</code> models the effect of dissipation due to deformation.</p>
<p>Similarly, Drake's hydroelastic contact model incorporates dissipation at the stress level, rather than forces. That is, pressure <code>p(x)</code> at a specific point on the contact surface replaces the force <code>f(x)</code> in the point contact model: </p><pre>
  p(x) = pₑ(x)⋅(1 - d⋅vₙ(x))₊
</pre><p> where <code>pₑ(x)</code> is the (elastic) hydroelastic pressure and once more the term <code>(1</p><ul>
<li>d⋅vₙ(x))₊ models Hunt &amp; Crossley dissipation.</li>
</ul>
<p></code></p>
<p><code>This is our preferred model of dissipation for several reasons:</p><ol type="1">
<li>It is based on physics and has been developed based on experimental observations.</li>
<li>It is a continuous function of state, as in the real physical world. Moreover, this continuity leads to better conditioned systems of equations.</li>
<li>The bounce velocity after an impact is bounded by 1/d, giving a quick physical intuition when setting this parameter.</li>
<li>Typical values are in the range [0; 100] s/m, with a value of 20 s/m being typical.</li>
<li>Values larger than 500 s/m are unphysical and usually lead to numerical problems when using discrete approximations given how time is discretized.</li>
</ol>
<p></code></p>
<p><code>The Hunt &amp; Crossley model is supported by the <a class="el" href="namespacedrake_1_1multibody.html#a902306c5e0120a67c07f80e9219a3e8dad454de89727cb520148830aa54cb3a90" title="TAMSI solver, see [Castro et al., 2019].">drake::multibody::DiscreteContactApproximation::kTamsi</a>, <a class="el" href="namespacedrake_1_1multibody.html#aa1d02176591187cb83e77e9ff779d679ac9a6ebef7049abc9802a9d0705a2e976" title="Similarity approximation found in [Castro et al., 2023].">drake::multibody::DiscreteContactApproximation::kSimilar</a>, and <a class="el" href="namespacedrake_1_1multibody.html#aa1d02176591187cb83e77e9ff779d679a22387111372cb701adbd49eaa6a28261" title="Approximation in which the normal force is lagged in Coulomb&#39;s law, such that ‖γₜ‖ ≤ μ γₙ₀,...">drake::multibody::DiscreteContactApproximation::kLagged</a> model approximations. In particular, <a class="el" href="namespacedrake_1_1multibody.html#aa1d02176591187cb83e77e9ff779d679ac9a6ebef7049abc9802a9d0705a2e976" title="Similarity approximation found in [Castro et al., 2023].">drake::multibody::DiscreteContactApproximation::kSimilar</a> and <a class="el" href="namespacedrake_1_1multibody.html#aa1d02176591187cb83e77e9ff779d679a22387111372cb701adbd49eaa6a28261" title="Approximation in which the normal force is lagged in Coulomb&#39;s law, such that ‖γₜ‖ ≤ μ γₙ₀,...">drake::multibody::DiscreteContactApproximation::kLagged</a> are convex approximations of contact, using a solver with theoretical and practical convergence guarantees. </code></p>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- footer -->
<div class="navpath">
  <ul>
  </ul>
</div>
<footer id="nav-path", class="site-footer padding">
  <div class="contain">
    <a href="/" class="drake-logo">
      <img src="/images/drake-logo.svg"/>
    </a>
    <div class="footer-menu">
      <ul>    
        <li>
          <a href="/doxygen_cxx/index.html" class="site-menu-item">C++</a>
        </li>    
        <li>
          <a href="/pydrake/index.html" class="site-menu-item">Python</a>
        </li>
        <li class="github-link">
          <a href="https://github.com/RobotLocomotion/drake" class="site-menu-item">GitHub <img src="/third_party/images/GitHub-Mark-64px.png"/></a>
        </li>
      </ul>
    </div>
  </div>
</footer>
<script type="text/javascript">
searchBox.searchLabel = 'Go to name…';
searchBox.DOMSearchField().value = searchBox.searchLabel;
</script>
</body>
</html>
