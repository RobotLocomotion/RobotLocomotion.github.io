<!-- HTML header for doxygen 1.14.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: drake::math Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(function() { init_search(); });
</script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<header class="site-header">
 <div class="site-header-inner contain">
  <a class="drake-logo" href="/"><img src="/images/drake-logo-white.svg"></a>
  <div class="menu-mobile-toggle">
   <span></span>
  </div>
  <nav class="site-menu">
   <ul>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/">Home</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/installation.html">Installation</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/gallery.html">Gallery</a>
    </li>
    <li class="site-menu-item site-menu-item-main">API Documentation
     <div class="sub">
      <a class="site-menu-item" href="/doxygen_cxx/index.html">C++</a>
      <a class="site-menu-item" href="/pydrake/index.html">Python</a>
     </div>
    </li>
    <li class="site-menu-item site-menu-item-main">Resources
     <div class="sub">
      <a class="site-menu-item" href="/getting_help.html">Getting Help</a>
      <a class="site-menu-item" href="https://deepnote.com/workspace/Drake-0b3b2c53-a7ad-441b-80f8-bf8350752305/project/Tutorials-2b4fc509-aef2-417d-a40d-6071dfed9199/notebook/index-753e3c9d261247ba9f0eb1d7868c18c8">Tutorials</a>
      <a class="site-menu-item" href="/python_bindings.html">Python Bindings</a>
      <a class="site-menu-item" href="/developers.html">For Developers</a>
      <a class="site-menu-item" href="/credits.html">Credits</a>
     </div>
    </li>
    <li class="github-link">
     <a class="site-menu-item" href="https://github.com/RobotLocomotion/drake">GitHub <img src="/third_party/images/GitHub-Mark-Light-64px.png"></a>
    </li>
   </ul>
  </nav>
 </div>
</header>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<div class="title-banner">
 <div class="title-banner__title">
  Drake C++ Documentation
 </div>
 <div id="DDGSearch">
  <form id="search_form_cpp" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search C++ API only…">
   <input type="hidden" name="q" value="site:drake.mit.edu/doxygen_cxx">
  </form>
  <form id="search_form" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search all of Drake…">
   <input type="hidden" name="q" value="site:drake.mit.edu OR site:underactuated.csail.mit.edu OR site:manipulation.csail.mit.edu">
  </form>
 </div>
 <div id="MSearchBoxContainer">
  <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect" class="search-icon" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"><span class="search-icon-dropdown"></span></span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><div id="MSearchCloseImg" class="close-icon"></div></a>
          </span>
        </div>
</td>
 </div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('namespacedrake_1_1math.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">drake::math Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:BarycentricMesh" id="r_BarycentricMesh"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_barycentric_mesh.html">BarycentricMesh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a multi-linear function (from vector inputs to vector outputs) by interpolating between points on a mesh using (triangular) barycentric interpolation.  <a href="classdrake_1_1math_1_1_barycentric_mesh.html#details">More...</a><br /></td></tr>
<tr class="memitem:BsplineBasis" id="r_BsplineBasis"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_bspline_basis.html">BsplineBasis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a set of non-descending breakpoints t₀ ≤ t₁ ≤ ⋅⋅⋅ ≤ tₘ, a B-spline basis of order k is a set of n + 1 (where n = m - k) piecewise polynomials of degree k - 1 defined over those breakpoints.  <a href="classdrake_1_1math_1_1_bspline_basis.html#details">More...</a><br /></td></tr>
<tr class="memitem:GetSubMatrixGradientArray" id="r_GetSubMatrixGradientArray"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1math_1_1_get_sub_matrix_gradient_array.html">GetSubMatrixGradientArray</a></td></tr>
<tr class="memitem:GetSubMatrixGradientSingleElement" id="r_GetSubMatrixGradientSingleElement"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1math_1_1_get_sub_matrix_gradient_single_element.html">GetSubMatrixGradientSingleElement</a></td></tr>
<tr class="memitem:Gradient" id="r_Gradient"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1math_1_1_gradient.html">Gradient</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively defined template specifying a matrix type of the correct size for a gradient of a matrix function with respect to <span class="tt">nq</span> variables, of any order.  <a href="structdrake_1_1math_1_1_gradient.html#details">More...</a><br /></td></tr>
<tr class="memitem:Gradient_3C_20Derived_2C_20nq_2C_201_20_3E" id="r_Gradient_3C_20Derived_2C_20nq_2C_201_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1math_1_1_gradient_3_01_derived_00_01nq_00_011_01_4.html">Gradient&lt; Derived, nq, 1 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base case for recursively defined gradient template.  <a href="structdrake_1_1math_1_1_gradient_3_01_derived_00_01nq_00_011_01_4.html#details">More...</a><br /></td></tr>
<tr class="memitem:GrayCodesMatrix" id="r_GrayCodesMatrix"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1math_1_1_gray_codes_matrix.html">GrayCodesMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structdrake_1_1math_1_1_gray_codes_matrix.html#a83c3b24ce255b931f182e59775510cb1">GrayCodesMatrix::type</a> returns an Eigen matrix of integers.  <a href="structdrake_1_1math_1_1_gray_codes_matrix.html#details">More...</a><br /></td></tr>
<tr class="memitem:GrayCodesMatrix_3C_20Eigen_3A_3ADynamic_20_3E" id="r_GrayCodesMatrix_3C_20Eigen_3A_3ADynamic_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>GrayCodesMatrix&lt; Eigen::Dynamic &gt;</b></td></tr>
<tr class="memitem:LinearSolver" id="r_LinearSolver"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_linear_solver.html">LinearSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves a linear system of equations A*x=b.  <a href="classdrake_1_1math_1_1_linear_solver.html#details">More...</a><br /></td></tr>
<tr class="memitem:MatGradMult" id="r_MatGradMult"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1math_1_1_mat_grad_mult.html">MatGradMult</a></td></tr>
<tr class="memitem:MatGradMultMat" id="r_MatGradMultMat"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1math_1_1_mat_grad_mult_mat.html">MatGradMultMat</a></td></tr>
<tr class="memitem:NumericalGradientOption" id="r_NumericalGradientOption"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_numerical_gradient_option.html">NumericalGradientOption</a></td></tr>
<tr class="memitem:RigidTransform" id="r_RigidTransform"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a proper rigid transform between two frames which can be regarded in two ways.  <a href="classdrake_1_1math_1_1_rigid_transform.html#details">More...</a><br /></td></tr>
<tr class="memitem:RollPitchYaw" id="r_RollPitchYaw"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_roll_pitch_yaw.html">RollPitchYaw</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents the orientation between two arbitrary frames A and D associated with a Space-fixed (extrinsic) X-Y-Z rotation by "roll-pitch-yaw" angles <span class="tt">[r, p, y]</span>, which is equivalent to a Body-fixed (intrinsic) Z-Y-X rotation by "yaw-pitch-roll" angles <span class="tt">[y, p, r]</span>.  <a href="classdrake_1_1math_1_1_roll_pitch_yaw.html#details">More...</a><br /></td></tr>
<tr class="memitem:RotationMatrix" id="r_RotationMatrix"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a 3x3 rotation matrix between two arbitrary frames A and B and helps ensure users create valid rotation matrices.  <a href="classdrake_1_1math_1_1_rotation_matrix.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-typedef-members" class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a25ae6f07da9dbbdc55d02c5749c6a5b3" id="r_a25ae6f07da9dbbdc55d02c5749c6a5b3"><td class="memTemplParams" colspan="2">template&lt;typename Derived, int nq&gt; </td></tr>
<tr class="memitem:a25ae6f07da9dbbdc55d02c5749c6a5b3 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a25ae6f07da9dbbdc55d02c5749c6a5b3">AutoDiffMatrixType</a></td></tr>
<tr class="memdesc:a25ae6f07da9dbbdc55d02c5749c6a5b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The appropriate AutoDiffScalar matrix type given the value type and the number of derivatives at compile time.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-enum-members" class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a33f67c50b300b399043477a51861400a" id="r_a33f67c50b300b399043477a51861400a"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a33f67c50b300b399043477a51861400a">NumericalGradientMethod</a> { <a class="el" href="#a33f67c50b300b399043477a51861400aae7c3602dce09c755e09250077a601a51">kForward</a>
, <a class="el" href="#a33f67c50b300b399043477a51861400aa5cc7cc1518100eae9e3f2d83673a74ed">kBackward</a>
, <a class="el" href="#a33f67c50b300b399043477a51861400aa39209ccaab9620e08ec04483c22a7eda">kCentral</a>
 }</td></tr>
<tr class="memitem:a2dc222f66e0f5092e8cfe879f24874b2" id="r_a2dc222f66e0f5092e8cfe879f24874b2"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2dc222f66e0f5092e8cfe879f24874b2">KnotVectorType</a> { <a class="el" href="#a2dc222f66e0f5092e8cfe879f24874b2a3ea9f7aca87fd7b64469a0d1119f0b50">kUniform</a>
, <a class="el" href="#a2dc222f66e0f5092e8cfe879f24874b2af1b493f6e43ce0d1371533ee4f1199d0">kClampedUniform</a>
 }</td></tr>
<tr class="memdesc:a2dc222f66e0f5092e8cfe879f24874b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum representing types of knot vectors.  <a href="#a2dc222f66e0f5092e8cfe879f24874b2">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a511506438ea2d8b648ef31f7957f118b" id="r_a511506438ea2d8b648ef31f7957f118b"><td class="memTemplParams" colspan="2">template&lt;typename Derived&gt; </td></tr>
<tr class="memitem:a511506438ea2d8b648ef31f7957f118b template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a511506438ea2d8b648ef31f7957f118b">ExtractValue</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;auto_diff_matrix, <a class="el" href="namespacedrake.html#aae413ce2f94f0ecb301727a6781b69ff">MatrixLikewise</a>&lt; typename Derived::Scalar::Scalar, Derived &gt; *value)</td></tr>
<tr class="memdesc:a511506438ea2d8b648ef31f7957f118b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the <span class="tt">value()</span> portion from an AutoDiffScalar matrix into a pre-existing matrix (resizing if necessary).  <br /></td></tr>
<tr class="memitem:a483ac3b69e4ce09af0b0d977128ed769" id="r_a483ac3b69e4ce09af0b0d977128ed769"><td class="memTemplParams" colspan="2">template&lt;typename Derived&gt; </td></tr>
<tr class="memitem:a483ac3b69e4ce09af0b0d977128ed769 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#aae413ce2f94f0ecb301727a6781b69ff">MatrixLikewise</a>&lt; typename Derived::Scalar::Scalar, Derived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a483ac3b69e4ce09af0b0d977128ed769">ExtractValue</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;auto_diff_matrix)</td></tr>
<tr class="memdesc:a483ac3b69e4ce09af0b0d977128ed769"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <span class="tt">value()</span> portion from a matrix of AutoDiffScalar entries.  <br /></td></tr>
<tr class="memitem:aa6b853dffb7141874967340f9a18f4eb" id="r_aa6b853dffb7141874967340f9a18f4eb"><td class="memTemplParams" colspan="2">template&lt;typename Derived&gt; </td></tr>
<tr class="memitem:aa6b853dffb7141874967340f9a18f4eb template"><td class="memItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa6b853dffb7141874967340f9a18f4eb">DiscardGradient</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;matrix)</td></tr>
<tr class="memdesc:aa6b853dffb7141874967340f9a18f4eb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><span class="tt">B = DiscardGradient(A)</span> enables casting from a matrix of AutoDiffScalars to AutoDiffScalar::Scalar type, explicitly throwing away any gradient information.  <br /></td></tr>
<tr class="memitem:a41b52d9aa2a46f7d783f20b12085d9ab" id="r_a41b52d9aa2a46f7d783f20b12085d9ab"><td class="memTemplParams" colspan="2">template&lt;typename Derived, typename DerivedAutoDiff&gt; </td></tr>
<tr class="memitem:a41b52d9aa2a46f7d783f20b12085d9ab template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a41b52d9aa2a46f7d783f20b12085d9ab">InitializeAutoDiff</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;value, std::optional&lt; int &gt; num_derivatives, std::optional&lt; int &gt; deriv_num_start, Eigen::MatrixBase&lt; DerivedAutoDiff &gt; *auto_diff_matrix)</td></tr>
<tr class="memdesc:a41b52d9aa2a46f7d783f20b12085d9ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a single AutoDiff matrix given the corresponding value matrix.  <br /></td></tr>
<tr class="memitem:a1fa7a3cb7b521d7f9c9973c5052f27c6" id="r_a1fa7a3cb7b521d7f9c9973c5052f27c6"><td class="memTemplParams" colspan="2">template&lt;typename Derived, typename DerivedAutoDiff&gt; </td></tr>
<tr class="memitem:a1fa7a3cb7b521d7f9c9973c5052f27c6 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1fa7a3cb7b521d7f9c9973c5052f27c6">InitializeAutoDiff</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;value, Eigen::MatrixBase&lt; DerivedAutoDiff &gt; *auto_diff_matrix)</td></tr>
<tr class="memdesc:a1fa7a3cb7b521d7f9c9973c5052f27c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate signature provides default values for the number of derivatives (dynamic, determined at run time) and the starting index (0).  <br /></td></tr>
<tr class="memitem:a72b0b18a66ef46995b64fa1d3945317b" id="r_a72b0b18a66ef46995b64fa1d3945317b"><td class="memTemplParams" colspan="2">template&lt;int nq = Eigen::Dynamic, typename Derived&gt; </td></tr>
<tr class="memitem:a72b0b18a66ef46995b64fa1d3945317b template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a25ae6f07da9dbbdc55d02c5749c6a5b3">AutoDiffMatrixType</a>&lt; Derived, nq &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a72b0b18a66ef46995b64fa1d3945317b">InitializeAutoDiff</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;value, std::optional&lt; int &gt; num_derivatives={}, std::optional&lt; int &gt; deriv_num_start={})</td></tr>
<tr class="memdesc:a72b0b18a66ef46995b64fa1d3945317b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a single AutoDiff matrix given the corresponding value matrix.  <br /></td></tr>
<tr class="memitem:a75e80609d562cf17809fba18f9f68e30" id="r_a75e80609d562cf17809fba18f9f68e30"><td class="memTemplParams" colspan="2">template&lt;typename... Deriveds&gt; </td></tr>
<tr class="memitem:a75e80609d562cf17809fba18f9f68e30 template"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a75e80609d562cf17809fba18f9f68e30">InitializeAutoDiffTuple</a> (const Eigen::MatrixBase&lt; Deriveds &gt; &amp;... args)</td></tr>
<tr class="memdesc:a75e80609d562cf17809fba18f9f68e30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a series of Eigen matrices, creates a tuple of corresponding AutoDiff matrices with values equal to the input matrices and properly initialized derivative vectors.  <br /></td></tr>
<tr class="memitem:acdad302100e5da633d37a1a996d25acd" id="r_acdad302100e5da633d37a1a996d25acd"><td class="memTemplParams" colspan="2">template&lt;typename Derived&gt; </td></tr>
<tr class="memitem:acdad302100e5da633d37a1a996d25acd template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acdad302100e5da633d37a1a996d25acd">ExtractGradient</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;auto_diff_matrix, std::optional&lt; int &gt; num_derivatives, Eigen::Matrix&lt; typename Derived::Scalar::Scalar, Derived::SizeAtCompileTime, Eigen::Dynamic &gt; *gradient)</td></tr>
<tr class="memdesc:acdad302100e5da633d37a1a996d25acd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the <span class="tt">derivatives()</span> portion from an AutoDiffScalar matrix into a pre-existing matrix (resizing if necessary).  <br /></td></tr>
<tr class="memitem:afbd01251fe24c716eca07635c4861b7b" id="r_afbd01251fe24c716eca07635c4861b7b"><td class="memTemplParams" colspan="2">template&lt;typename Derived&gt; </td></tr>
<tr class="memitem:afbd01251fe24c716eca07635c4861b7b template"><td class="memItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename Derived::Scalar::Scalar, Derived::SizeAtCompileTime, Eigen::Dynamic &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afbd01251fe24c716eca07635c4861b7b">ExtractGradient</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;auto_diff_matrix, std::optional&lt; int &gt; num_derivatives={})</td></tr>
<tr class="memdesc:afbd01251fe24c716eca07635c4861b7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <span class="tt">derivatives()</span> portion from a matrix of AutoDiffScalar entries.  <br /></td></tr>
<tr class="memitem:ab9edc6655caed8198f72f998d6612223" id="r_ab9edc6655caed8198f72f998d6612223"><td class="memTemplParams" colspan="2">template&lt;typename DerivedValue, typename DerivedGradient, typename DerivedAutoDiff&gt; </td></tr>
<tr class="memitem:ab9edc6655caed8198f72f998d6612223 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab9edc6655caed8198f72f998d6612223">InitializeAutoDiff</a> (const Eigen::MatrixBase&lt; DerivedValue &gt; &amp;value, const Eigen::MatrixBase&lt; DerivedGradient &gt; &amp;gradient, Eigen::MatrixBase&lt; DerivedAutoDiff &gt; *auto_diff_matrix)</td></tr>
<tr class="memdesc:ab9edc6655caed8198f72f998d6612223"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes an AutoDiff matrix given a matrix of values and a gradient matrix.  <br /></td></tr>
<tr class="memitem:a00bfe0f878b9f318900d47dd81e6e308" id="r_a00bfe0f878b9f318900d47dd81e6e308"><td class="memTemplParams" colspan="2">template&lt;typename DerivedValue, typename DerivedGradient&gt; </td></tr>
<tr class="memitem:a00bfe0f878b9f318900d47dd81e6e308 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a25ae6f07da9dbbdc55d02c5749c6a5b3">AutoDiffMatrixType</a>&lt; DerivedValue, DerivedGradient::ColsAtCompileTime &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a00bfe0f878b9f318900d47dd81e6e308">InitializeAutoDiff</a> (const Eigen::MatrixBase&lt; DerivedValue &gt; &amp;value, const Eigen::MatrixBase&lt; DerivedGradient &gt; &amp;gradient)</td></tr>
<tr class="memdesc:a00bfe0f878b9f318900d47dd81e6e308"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an AutoDiff matrix given a matrix of values and a gradient matrix.  <br /></td></tr>
<tr class="memitem:aa702a82946411f68e87bb6fb27cfdfa4" id="r_aa702a82946411f68e87bb6fb27cfdfa4"><td class="memTemplParams" colspan="2">template&lt;typename Derived&gt; </td></tr>
<tr class="memitem:aa702a82946411f68e87bb6fb27cfdfa4 template"><td class="memItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa702a82946411f68e87bb6fb27cfdfa4">DiscardZeroGradient</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;auto_diff_matrix, <a class="el" href="classdouble.html">double</a> precision=Eigen::NumTraits&lt; <a class="el" href="classdouble.html">double</a> &gt;::dummy_precision())</td></tr>
<tr class="memdesc:aa702a82946411f68e87bb6fb27cfdfa4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><span class="tt">B = DiscardZeroGradient(A, precision)</span> enables casting from a matrix of AutoDiffScalars to AutoDiffScalar::Scalar type, but first checking that the gradient matrix is empty or zero.  <br /></td></tr>
<tr class="memitem:abff94f9cb54675e2c8979f98feb35324" id="r_abff94f9cb54675e2c8979f98feb35324"><td class="memTemplParams" colspan="2">template&lt;typename Derived&gt; </td></tr>
<tr class="memitem:abff94f9cb54675e2c8979f98feb35324 template"><td class="memItemLeft" align="right" valign="top">std::enable_if&lt;!std::is_same_v&lt; typenameDerived::Scalar, <a class="el" href="classdouble.html">double</a> &gt;, int &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abff94f9cb54675e2c8979f98feb35324">GetDerivativeSize</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:abff94f9cb54675e2c8979f98feb35324"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a matrix of AutoDiffScalars, returns the size of the derivatives.  <br /></td></tr>
<tr class="memitem:ab8de94fedb09b1b5dec16c615d68eb23" id="r_ab8de94fedb09b1b5dec16c615d68eb23"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab8de94fedb09b1b5dec16c615d68eb23">AreAutoDiffVecXdEqual</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="namespacedrake.html#a35725b277b02aeb79f24fd7f724e6dbc">AutoDiffXd</a> &gt; &gt; &amp;a, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="namespacedrake.html#a35725b277b02aeb79f24fd7f724e6dbc">AutoDiffXd</a> &gt; &gt; &amp;b)</td></tr>
<tr class="memdesc:ab8de94fedb09b1b5dec16c615d68eb23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a and b are equal.  <br /></td></tr>
<tr class="memitem:a961adeb2899673c1cee7062ad80aab81" id="r_a961adeb2899673c1cee7062ad80aab81"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a961adeb2899673c1cee7062ad80aab81">BinomialCoefficient</a> (int n, int k)</td></tr>
<tr class="memdesc:a961adeb2899673c1cee7062ad80aab81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the binomial coefficient <span class="tt">n</span>-choose-<span class="tt">k</span> efficiently using a dynamic programming recursion.  <br /></td></tr>
<tr class="memitem:a25fb88b582a1cedece10b67353f2d18d" id="r_a25fb88b582a1cedece10b67353f2d18d"><td class="memTemplParams" colspan="2">template&lt;typename DerivedX, typename DerivedY, typename DerivedCalcX&gt; </td></tr>
<tr class="memitem:a25fb88b582a1cedece10b67353f2d18d template"><td class="memItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename DerivedX::Scalar, DerivedY::RowsAtCompileTime, DerivedX::RowsAtCompileTime &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a25fb88b582a1cedece10b67353f2d18d">ComputeNumericalGradient</a> (std::function&lt; void(const DerivedCalcX &amp;, DerivedY *y)&gt; calc_func, const DerivedX &amp;<a class="el" href="pixel__types_8h.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a>, const <a class="el" href="classdrake_1_1math_1_1_numerical_gradient_option.html">NumericalGradientOption</a> &amp;option=<a class="el" href="classdrake_1_1math_1_1_numerical_gradient_option.html">NumericalGradientOption</a>{ <a class="el" href="#a33f67c50b300b399043477a51861400aae7c3602dce09c755e09250077a601a51">NumericalGradientMethod::kForward</a>})</td></tr>
<tr class="memdesc:a25fb88b582a1cedece10b67353f2d18d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the gradient of a function f(x) through numerical difference.  <br /></td></tr>
<tr class="memitem:aed596a7b73bd51a9acfa28df7be4214f" id="r_aed596a7b73bd51a9acfa28df7be4214f"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aed596a7b73bd51a9acfa28df7be4214f">ContinuousAlgebraicRiccatiEquation</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;A, const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;B, const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;Q, const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;R)</td></tr>
<tr class="memdesc:aed596a7b73bd51a9acfa28df7be4214f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the unique stabilizing solution S to the continuous-time algebraic Riccati equation:  <br /></td></tr>
<tr class="memitem:a47d4e4f52f3321536bf570b3a1a23718" id="r_a47d4e4f52f3321536bf570b3a1a23718"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a47d4e4f52f3321536bf570b3a1a23718">ContinuousAlgebraicRiccatiEquation</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;A, const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;B, const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;Q, const Eigen::LLT&lt; Eigen::MatrixXd &gt; &amp;R_cholesky)</td></tr>
<tr class="memdesc:a47d4e4f52f3321536bf570b3a1a23718"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is functionally the same as ContinuousAlgebraicRiccatiEquation(A, B, Q, R).  <br /></td></tr>
<tr class="memitem:a87898df1c0be39d4073b61d033390502" id="r_a87898df1c0be39d4073b61d033390502"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a87898df1c0be39d4073b61d033390502">RealContinuousLyapunovEquation</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;A, const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;Q)</td></tr>
<tr class="memitem:a178c2116d7750bdd9ab8647b69e51a9d" id="r_a178c2116d7750bdd9ab8647b69e51a9d"><td class="memTemplParams" colspan="2">template&lt;typename v_Type, typename DtB_v_Type, typename w_AB_Type&gt; </td></tr>
<tr class="memitem:a178c2116d7750bdd9ab8647b69e51a9d template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; typename v_Type::Scalar &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a178c2116d7750bdd9ab8647b69e51a9d">ConvertTimeDerivativeToOtherFrame</a> (const Eigen::MatrixBase&lt; v_Type &gt; &amp;v_E, const Eigen::MatrixBase&lt; DtB_v_Type &gt; &amp;DtB_v_E, const Eigen::MatrixBase&lt; w_AB_Type &gt; &amp;w_AB_E)</td></tr>
<tr class="memdesc:a178c2116d7750bdd9ab8647b69e51a9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given ᴮd/dt(v) (the time derivative in frame B of an arbitrary 3D vector v) and given ᴬωᴮ (frame B's angular velocity in another frame A), this method computes ᴬd/dt(v) (the time derivative in frame A of v) by: ᴬd/dt(v) = ᴮd/dt(v) + ᴬωᴮ x v.  <br /></td></tr>
<tr class="memitem:a788977a35ad438eaac0c38b2885813b6" id="r_a788977a35ad438eaac0c38b2885813b6"><td class="memTemplParams" colspan="2">template&lt;typename Derived&gt; </td></tr>
<tr class="memitem:a788977a35ad438eaac0c38b2885813b6 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a3922cc0c6264e8ff225a6aa0dd993667">drake::Matrix3</a>&lt; typename Derived::Scalar &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a788977a35ad438eaac0c38b2885813b6">VectorToSkewSymmetric</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;p)</td></tr>
<tr class="memitem:aca90af6719e970d4aeefa53d5a7854ae" id="r_aca90af6719e970d4aeefa53d5a7854ae"><td class="memTemplParams" colspan="2">template&lt;typename Derived&gt; </td></tr>
<tr class="memitem:aca90af6719e970d4aeefa53d5a7854ae template"><td class="memItemLeft" align="right" valign="top">Derived::Scalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aca90af6719e970d4aeefa53d5a7854ae">DifferentiableNorm</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;<a class="el" href="pixel__types_8h.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a>)</td></tr>
<tr class="memdesc:aca90af6719e970d4aeefa53d5a7854ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">The 2-norm function |x| is not differentiable at x=0 (its gradient is x/|x|, which has a division-by-zero problem).  <br /></td></tr>
<tr class="memitem:afcef78b318bd0da2f388b83bc6fafa81" id="r_afcef78b318bd0da2f388b83bc6fafa81"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afcef78b318bd0da2f388b83bc6fafa81">DiscreteAlgebraicRiccatiEquation</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;A, const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;B, const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;Q, const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;R)</td></tr>
<tr class="memdesc:afcef78b318bd0da2f388b83bc6fafa81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the unique stabilizing solution X to the discrete-time algebraic Riccati equation:  <br /></td></tr>
<tr class="memitem:a6c67bf8aac3624a534979afd09689375" id="r_a6c67bf8aac3624a534979afd09689375"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6c67bf8aac3624a534979afd09689375">DiscreteAlgebraicRiccatiEquation</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;A, const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;B, const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;Q, const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;R, const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;N)</td></tr>
<tr class="memdesc:a6c67bf8aac3624a534979afd09689375"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the unique stabilizing solution X to the discrete-time algebraic Riccati equation:  <br /></td></tr>
<tr class="memitem:a1d907fb507b2003b9da9558489e48e44" id="r_a1d907fb507b2003b9da9558489e48e44"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1d907fb507b2003b9da9558489e48e44">RealDiscreteLyapunovEquation</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;A, const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;Q)</td></tr>
<tr class="memitem:ad55de6b340513cdc1351d509dc9d99e6" id="r_ad55de6b340513cdc1351d509dc9d99e6"><td class="memTemplParams" colspan="2">template&lt;typename Scalar, int Options, typename StorageIndex&gt; </td></tr>
<tr class="memitem:ad55de6b340513cdc1351d509dc9d99e6 template"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Eigen::Triplet&lt; Scalar &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad55de6b340513cdc1351d509dc9d99e6">SparseMatrixToTriplets</a> (const Eigen::SparseMatrix&lt; Scalar, Options, StorageIndex &gt; &amp;matrix)</td></tr>
<tr class="memdesc:ad55de6b340513cdc1351d509dc9d99e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a sparse matrix, return a vector of triplets, such that we can reconstruct the matrix using setFromTriplet function.  <br /></td></tr>
<tr class="memitem:a55e8440aa53d7db2a614142ae4e27941" id="r_a55e8440aa53d7db2a614142ae4e27941"><td class="memTemplParams" colspan="2">template&lt;typename Derived&gt; </td></tr>
<tr class="memitem:a55e8440aa53d7db2a614142ae4e27941 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a55e8440aa53d7db2a614142ae4e27941">SparseMatrixToRowColumnValueVectors</a> (const Derived &amp;matrix, std::vector&lt; Eigen::Index &gt; &amp;row_indices, std::vector&lt; Eigen::Index &gt; &amp;col_indices, std::vector&lt; typename Derived::Scalar &gt; &amp;val)</td></tr>
<tr class="memdesc:a55e8440aa53d7db2a614142ae4e27941"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a sparse matrix, return the row indices, the column indices, and value of the non-zero entries.  <br /></td></tr>
<tr class="memitem:adba688f2a2db17563f2ef13e199816d9" id="r_adba688f2a2db17563f2ef13e199816d9"><td class="memItemLeft" align="right" valign="top">Eigen::Matrix3Xd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adba688f2a2db17563f2ef13e199816d9">UniformPtsOnSphereFibonacci</a> (int num_points)</td></tr>
<tr class="memdesc:adba688f2a2db17563f2ef13e199816d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deterministically generates approximate evenly distributed points on a unit sphere.  <br /></td></tr>
<tr class="memitem:a214ceb8aa2e730b212e0b345f8199727" id="r_a214ceb8aa2e730b212e0b345f8199727"><td class="memTemplParams" colspan="2">template&lt;std::size_t Size&gt; </td></tr>
<tr class="memitem:a214ceb8aa2e730b212e0b345f8199727 template"><td class="memItemLeft" align="right" valign="top">std::array&lt; int, Size &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a214ceb8aa2e730b212e0b345f8199727">intRange</a> (int start)</td></tr>
<tr class="memitem:a94e7f89e2f4658e85200497129578c17" id="r_a94e7f89e2f4658e85200497129578c17"><td class="memTemplParams" colspan="2">template&lt;typename Derived&gt; </td></tr>
<tr class="memitem:a94e7f89e2f4658e85200497129578c17 template"><td class="memItemLeft" align="right" valign="top">Derived::PlainObject&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a94e7f89e2f4658e85200497129578c17">transposeGrad</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;dX, typename Derived::Index rows_X)</td></tr>
<tr class="memitem:ab27fe675e0248787ceda453ff874915d" id="r_ab27fe675e0248787ceda453ff874915d"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA, typename DerivedB, typename DerivedDA, typename DerivedDB&gt; </td></tr>
<tr class="memitem:ab27fe675e0248787ceda453ff874915d template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdrake_1_1math_1_1_mat_grad_mult_mat.html">MatGradMultMat</a>&lt; DerivedA, DerivedB, DerivedDA &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab27fe675e0248787ceda453ff874915d">matGradMultMat</a> (const Eigen::MatrixBase&lt; DerivedA &gt; &amp;A, const Eigen::MatrixBase&lt; DerivedB &gt; &amp;B, const Eigen::MatrixBase&lt; DerivedDA &gt; &amp;dA, const Eigen::MatrixBase&lt; DerivedDB &gt; &amp;dB)</td></tr>
<tr class="memitem:a62e57ade46ad4ef8cd2de2fa38986ac3" id="r_a62e57ade46ad4ef8cd2de2fa38986ac3"><td class="memTemplParams" colspan="2">template&lt;typename DerivedDA, typename DerivedB&gt; </td></tr>
<tr class="memitem:a62e57ade46ad4ef8cd2de2fa38986ac3 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdrake_1_1math_1_1_mat_grad_mult.html">MatGradMult</a>&lt; DerivedDA, DerivedB &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a62e57ade46ad4ef8cd2de2fa38986ac3">matGradMult</a> (const Eigen::MatrixBase&lt; DerivedDA &gt; &amp;dA, const Eigen::MatrixBase&lt; DerivedB &gt; &amp;B)</td></tr>
<tr class="memitem:a050ed765d82aab33969de2bd54ac49e2" id="r_a050ed765d82aab33969de2bd54ac49e2"><td class="memTemplParams" colspan="2">template&lt;typename Derived&gt; </td></tr>
<tr class="memitem:a050ed765d82aab33969de2bd54ac49e2 template"><td class="memItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename Derived::Scalar, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a050ed765d82aab33969de2bd54ac49e2">getSubMatrixGradient</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;dM, const std::vector&lt; int &gt; &amp;rows, const std::vector&lt; int &gt; &amp;cols, typename Derived::Index M_rows, int q_start=0, typename Derived::Index q_subvector_size=-1)</td></tr>
<tr class="memitem:a308bfb8a42ac830764e3e5420e5123f6" id="r_a308bfb8a42ac830764e3e5420e5123f6"><td class="memTemplParams" colspan="2">template&lt;int QSubvectorSize, typename Derived, std::size_t NRows, std::size_t NCols&gt; </td></tr>
<tr class="memitem:a308bfb8a42ac830764e3e5420e5123f6 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdrake_1_1math_1_1_get_sub_matrix_gradient_array.html">GetSubMatrixGradientArray</a>&lt; QSubvectorSize, Derived, NRows, NCols &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a308bfb8a42ac830764e3e5420e5123f6">getSubMatrixGradient</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;dM, const std::array&lt; int, NRows &gt; &amp;rows, const std::array&lt; int, NCols &gt; &amp;cols, typename Derived::Index M_rows, int q_start=0, typename Derived::Index q_subvector_size=QSubvectorSize)</td></tr>
<tr class="memitem:a3e880bbd06a798425a0fea851038109d" id="r_a3e880bbd06a798425a0fea851038109d"><td class="memTemplParams" colspan="2">template&lt;int QSubvectorSize, typename Derived&gt; </td></tr>
<tr class="memitem:a3e880bbd06a798425a0fea851038109d template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdrake_1_1math_1_1_get_sub_matrix_gradient_single_element.html">GetSubMatrixGradientSingleElement</a>&lt; QSubvectorSize, Derived &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3e880bbd06a798425a0fea851038109d">getSubMatrixGradient</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;dM, int row, int col, typename Derived::Index M_rows, typename Derived::Index q_start=0, typename Derived::Index q_subvector_size=QSubvectorSize)</td></tr>
<tr class="memitem:ab96376257045e5897019d7ced6537a0a" id="r_ab96376257045e5897019d7ced6537a0a"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA, typename DerivedB&gt; </td></tr>
<tr class="memitem:ab96376257045e5897019d7ced6537a0a template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab96376257045e5897019d7ced6537a0a">setSubMatrixGradient</a> (Eigen::MatrixBase&lt; DerivedA &gt; &amp;dM, const Eigen::MatrixBase&lt; DerivedB &gt; &amp;dM_submatrix, const std::vector&lt; int &gt; &amp;rows, const std::vector&lt; int &gt; &amp;cols, typename DerivedA::Index M_rows, typename DerivedA::Index q_start=0, typename DerivedA::Index q_subvector_size=-1)</td></tr>
<tr class="memitem:a8fa4d6793feb307a2df5ac3f5b5319e9" id="r_a8fa4d6793feb307a2df5ac3f5b5319e9"><td class="memTemplParams" colspan="2">template&lt;int QSubvectorSize, typename DerivedA, typename DerivedB, std::size_t NRows, std::size_t NCols&gt; </td></tr>
<tr class="memitem:a8fa4d6793feb307a2df5ac3f5b5319e9 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8fa4d6793feb307a2df5ac3f5b5319e9">setSubMatrixGradient</a> (Eigen::MatrixBase&lt; DerivedA &gt; &amp;dM, const Eigen::MatrixBase&lt; DerivedB &gt; &amp;dM_submatrix, const std::array&lt; int, NRows &gt; &amp;rows, const std::array&lt; int, NCols &gt; &amp;cols, typename DerivedA::Index M_rows, typename DerivedA::Index q_start=0, typename DerivedA::Index q_subvector_size=QSubvectorSize)</td></tr>
<tr class="memitem:a429d2d817112b0e4db22f5309f36f60f" id="r_a429d2d817112b0e4db22f5309f36f60f"><td class="memTemplParams" colspan="2">template&lt;int QSubvectorSize, typename DerivedDM, typename DerivedDMSub&gt; </td></tr>
<tr class="memitem:a429d2d817112b0e4db22f5309f36f60f template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a429d2d817112b0e4db22f5309f36f60f">setSubMatrixGradient</a> (Eigen::MatrixBase&lt; DerivedDM &gt; &amp;dM, const Eigen::MatrixBase&lt; DerivedDMSub &gt; &amp;dM_submatrix, int row, int col, typename DerivedDM::Index M_rows, typename DerivedDM::Index q_start=0, typename DerivedDM::Index q_subvector_size=QSubvectorSize)</td></tr>
<tr class="memitem:a1cf0d1e6ddb8878dded6253d7ef6b25d" id="r_a1cf0d1e6ddb8878dded6253d7ef6b25d"><td class="memTemplParams" colspan="2">template&lt;int NumDigits = Eigen::Dynamic&gt; </td></tr>
<tr class="memitem:a1cf0d1e6ddb8878dded6253d7ef6b25d template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdrake_1_1math_1_1_gray_codes_matrix.html">GrayCodesMatrix</a>&lt; NumDigits &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1cf0d1e6ddb8878dded6253d7ef6b25d">CalculateReflectedGrayCodes</a> (int num_digits=NumDigits)</td></tr>
<tr class="memdesc:a1cf0d1e6ddb8878dded6253d7ef6b25d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a matrix whose i'th row is the Gray code for integer i.  <br /></td></tr>
<tr class="memitem:a9b836de6a2619d82ebb7793a920e7b67" id="r_a9b836de6a2619d82ebb7793a920e7b67"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9b836de6a2619d82ebb7793a920e7b67">GrayCodeToInteger</a> (const Eigen::Ref&lt; const Eigen::VectorXi &gt; &amp;gray_code)</td></tr>
<tr class="memdesc:a9b836de6a2619d82ebb7793a920e7b67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the Gray code to an integer.  <br /></td></tr>
<tr class="memitem:a72586b90f00c2e690c2ab071e6585f60" id="r_a72586b90f00c2e690c2ab071e6585f60"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a72586b90f00c2e690c2ab071e6585f60 template"><td class="memItemLeft" align="right" valign="top">const Eigen::Quaternion&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a72586b90f00c2e690c2ab071e6585f60">HopfCoordinateToQuaternion</a> (const T &amp;theta, const T &amp;phi, const T &amp;psi)</td></tr>
<tr class="memdesc:a72586b90f00c2e690c2ab071e6585f60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms Hopf coordinates to a quaternion w, x, y, z as w = cos(θ/2)cos(ψ/2) x = cos(θ/2)sin(ψ/2) y = sin(θ/2)cos(φ+ψ/2) z = sin(θ/2)sin(φ+ψ/2) The user can refer to equation 5 of Generating Uniform Incremental Grids on SO(3) Using the Hopf Fibration by Anna Yershova, Steven LaValle and Julie Mitchell, 2008.  <br /></td></tr>
<tr class="memitem:add4e7be6e81ac1866c95b80bc8f48719" id="r_add4e7be6e81ac1866c95b80bc8f48719"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:add4e7be6e81ac1866c95b80bc8f48719 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#add4e7be6e81ac1866c95b80bc8f48719">QuaternionToHopfCoordinate</a> (const Eigen::Quaternion&lt; T &gt; &amp;quaternion)</td></tr>
<tr class="memdesc:add4e7be6e81ac1866c95b80bc8f48719"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a unit-length quaternion (w, x, y, z) (with the requirement w &gt;= 0) to Hopf coordinate as ψ = 2*atan2(x, w) φ = mod(atan2(z, y) - ψ/2, 2pi) θ = 2*atan2(√(y²+z²), √(w²+x²)) ψ is in the range of [-pi, pi].  <br /></td></tr>
<tr class="memitem:aed93d1c159660c20f44eefa5a0dad107" id="r_aed93d1c159660c20f44eefa5a0dad107"><td class="memTemplParams" colspan="2">template&lt;int MaxChunkSize = 10, class F, class Arg&gt; </td></tr>
<tr class="memitem:aed93d1c159660c20f44eefa5a0dad107 template"><td class="memItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aed93d1c159660c20f44eefa5a0dad107">jacobian</a> (F &amp;&amp;f, Arg &amp;&amp;<a class="el" href="pixel__types_8h.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a>)</td></tr>
<tr class="memdesc:aed93d1c159660c20f44eefa5a0dad107"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a matrix of AutoDiffScalars from which both the value and the Jacobian of a function.  <br /></td></tr>
<tr class="memitem:a26812991a25e8108bd02304887bbcaf0" id="r_a26812991a25e8108bd02304887bbcaf0"><td class="memTemplParams" colspan="2">template&lt;int MaxChunkSizeOuter = 10, int MaxChunkSizeInner = 10, class F, class Arg&gt; </td></tr>
<tr class="memitem:a26812991a25e8108bd02304887bbcaf0 template"><td class="memItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a26812991a25e8108bd02304887bbcaf0">hessian</a> (F &amp;&amp;f, Arg &amp;&amp;<a class="el" href="pixel__types_8h.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a>)</td></tr>
<tr class="memdesc:a26812991a25e8108bd02304887bbcaf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a matrix of AutoDiffScalars from which the value, Jacobian, and Hessian of a function.  <br /></td></tr>
<tr class="memitem:a8a6136c699d2e25f7515e8404cb65d79" id="r_a8a6136c699d2e25f7515e8404cb65d79"><td class="memTemplParams" colspan="2">template&lt;typename Derived&gt; </td></tr>
<tr class="memitem:a8a6136c699d2e25f7515e8404cb65d79 template"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8a6136c699d2e25f7515e8404cb65d79">IsSymmetric</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;matrix)</td></tr>
<tr class="memdesc:a8a6136c699d2e25f7515e8404cb65d79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a matrix is symmetric.  <br /></td></tr>
<tr class="memitem:a40335d2906e39ebe2a114f1cb6cf5d26" id="r_a40335d2906e39ebe2a114f1cb6cf5d26"><td class="memTemplParams" colspan="2">template&lt;typename Derived&gt; </td></tr>
<tr class="memitem:a40335d2906e39ebe2a114f1cb6cf5d26 template"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a40335d2906e39ebe2a114f1cb6cf5d26">IsSymmetric</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;matrix, const typename Derived::Scalar &amp;precision)</td></tr>
<tr class="memdesc:a40335d2906e39ebe2a114f1cb6cf5d26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a matrix is symmetric based on whether the difference between matrix(i, j) and matrix(j, i) is smaller than <code class="param">precision</code> for all i, j.  <br /></td></tr>
<tr class="memitem:ae4935d457d59fdb0a60b7f1d5cb465bb" id="r_ae4935d457d59fdb0a60b7f1d5cb465bb"><td class="memTemplParams" colspan="2">template&lt;typename Derived&gt; </td></tr>
<tr class="memitem:ae4935d457d59fdb0a60b7f1d5cb465bb template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">drake::MatrixX</a>&lt; typename Derived::Scalar &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae4935d457d59fdb0a60b7f1d5cb465bb">ToSymmetricMatrixFromLowerTriangularColumns</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;lower_triangular_columns)</td></tr>
<tr class="memdesc:ae4935d457d59fdb0a60b7f1d5cb465bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a column vector containing the stacked columns of the lower triangular part of a square matrix, returning a symmetric matrix whose lower triangular part is the same as the original matrix.  <br /></td></tr>
<tr class="memitem:a0b96f43056135e9ecb62b48421b787f9" id="r_a0b96f43056135e9ecb62b48421b787f9"><td class="memTemplParams" colspan="2">template&lt;int rows, typename Derived&gt; </td></tr>
<tr class="memitem:a0b96f43056135e9ecb62b48421b787f9 template"><td class="memItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename Derived::Scalar, rows, rows &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0b96f43056135e9ecb62b48421b787f9">ToSymmetricMatrixFromLowerTriangularColumns</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;lower_triangular_columns)</td></tr>
<tr class="memdesc:a0b96f43056135e9ecb62b48421b787f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a column vector containing the stacked columns of the lower triangular part of a square matrix, returning a symmetric matrix whose lower triangular part is the same as the original matrix.  <br /></td></tr>
<tr class="memitem:aa824bd31863a762bd2c1860534b7e39d" id="r_aa824bd31863a762bd2c1860534b7e39d"><td class="memTemplParams" colspan="2">template&lt;typename Derived&gt; </td></tr>
<tr class="memitem:aa824bd31863a762bd2c1860534b7e39d template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">drake::VectorX</a>&lt; typename Derived::Scalar &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa824bd31863a762bd2c1860534b7e39d">ToLowerTriangularColumnsFromMatrix</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;matrix)</td></tr>
<tr class="memdesc:aa824bd31863a762bd2c1860534b7e39d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a square matrix, extract the lower triangular part as a stacked column vector.  <br /></td></tr>
<tr class="memitem:a84bae8f78403884f4f5fa7ecd41a8846" id="r_a84bae8f78403884f4f5fa7ecd41a8846"><td class="memTemplParams" colspan="2">template&lt;typename Derived&gt; </td></tr>
<tr class="memitem:a84bae8f78403884f4f5fa7ecd41a8846 template"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a84bae8f78403884f4f5fa7ecd41a8846">IsPositiveDefinite</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;matrix, <a class="el" href="classdouble.html">double</a> eigenvalue_tolerance=0.0, <a class="el" href="classdouble.html">double</a> symmetry_tolerance=0.0)</td></tr>
<tr class="memdesc:a84bae8f78403884f4f5fa7ecd41a8846"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a matrix is symmetric (with tolerance <code class="param">symmetry_tolerance</code> &ndash; see IsSymmetric) and has all eigenvalues greater than <code class="param">eigenvalue_tolerance</code>.  <br /></td></tr>
<tr class="memitem:a6d14dacc3ba3d4cdacbf1936fe55c7f0" id="r_a6d14dacc3ba3d4cdacbf1936fe55c7f0"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a6d14dacc3ba3d4cdacbf1936fe55c7f0 template"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6d14dacc3ba3d4cdacbf1936fe55c7f0">EigenToStdVector</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &gt; &amp;mat)</td></tr>
<tr class="memdesc:a6d14dacc3ba3d4cdacbf1936fe55c7f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95" title="A matrix of dynamic size, templated on scalar type.">MatrixX&lt;T&gt;</a> into a std::vector&lt;MatrixX&lt;T&gt;&gt;, taking each column of the m-by-n matrix <span class="tt">mat</span> into an m-by-1 element of the returned std::vector.  <br /></td></tr>
<tr class="memitem:a9cf7a17a246897182cc65ec080840999" id="r_a9cf7a17a246897182cc65ec080840999"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a9cf7a17a246897182cc65ec080840999 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9cf7a17a246897182cc65ec080840999">StdVectorToEigen</a> (const std::vector&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &gt; &amp;vec)</td></tr>
<tr class="memdesc:a9cf7a17a246897182cc65ec080840999"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a std::vector&lt;MatrixX&lt;T&gt;&gt; into a <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95" title="A matrix of dynamic size, templated on scalar type.">MatrixX&lt;T&gt;</a>, composing each element of <span class="tt">vec</span> into a column of the returned matrix.  <br /></td></tr>
<tr class="memitem:aa16b8b886b1a84d38cf5de14e0780df0" id="r_aa16b8b886b1a84d38cf5de14e0780df0"><td class="memTemplParams" colspan="2">template&lt;typename Derived&gt; </td></tr>
<tr class="memitem:aa16b8b886b1a84d38cf5de14e0780df0 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; typename Derived::Scalar &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa16b8b886b1a84d38cf5de14e0780df0">ExtractPrincipalSubmatrix</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;mat, const std::set&lt; int &gt; &amp;indices)</td></tr>
<tr class="memdesc:aa16b8b886b1a84d38cf5de14e0780df0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the principal submatrix from the ordered set of indices.  <br /></td></tr>
<tr class="memitem:a2480fec6f9cfe246f8175e674d45341a" id="r_a2480fec6f9cfe246f8175e674d45341a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2480fec6f9cfe246f8175e674d45341a">GeneratePythonCsc</a> (const Eigen::SparseMatrix&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;mat, std::string_view name)</td></tr>
<tr class="memdesc:a2480fec6f9cfe246f8175e674d45341a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the python statement to construct scipy.sparse matrix.  <br /></td></tr>
<tr class="memitem:aa61c168d24baf12435cdc8b98a61c6a4" id="r_aa61c168d24baf12435cdc8b98a61c6a4"><td class="memTemplParams" colspan="2">template&lt;typename Derived&gt; </td></tr>
<tr class="memitem:aa61c168d24baf12435cdc8b98a61c6a4 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa61c168d24baf12435cdc8b98a61c6a4">NormalizeVector</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;<a class="el" href="pixel__types_8h.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a>, typename Derived::PlainObject &amp;x_norm, typename <a class="el" href="structdrake_1_1math_1_1_gradient.html">drake::math::Gradient</a>&lt; Derived, Derived::RowsAtCompileTime, 1 &gt;::type *dx_norm=nullptr, typename <a class="el" href="structdrake_1_1math_1_1_gradient.html">drake::math::Gradient</a>&lt; Derived, Derived::RowsAtCompileTime, 2 &gt;::type *ddx_norm=nullptr)</td></tr>
<tr class="memdesc:aa61c168d24baf12435cdc8b98a61c6a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the normalized vector, optionally with its gradient and second derivative.  <br /></td></tr>
<tr class="memitem:ac24fd667914c5489bdfed7973a1c7388" id="r_ac24fd667914c5489bdfed7973a1c7388"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac24fd667914c5489bdfed7973a1c7388">DecomposePSDmatrixIntoXtransposeTimesX</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;Y, <a class="el" href="classdouble.html">double</a> zero_tol, bool return_empty_if_not_psd=false)</td></tr>
<tr class="memdesc:ac24fd667914c5489bdfed7973a1c7388"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a symmetric positive semidefinite matrix Y, decompose it into XᵀX, where the number of rows in X equals to the rank of Y.  <br /></td></tr>
<tr class="memitem:ac0cb8ebf50f381b19b98f5901b6dea96" id="r_ac0cb8ebf50f381b19b98f5901b6dea96"><td class="memItemLeft" align="right" valign="top">std::pair&lt; Eigen::MatrixXd, Eigen::MatrixXd &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac0cb8ebf50f381b19b98f5901b6dea96">DecomposePositiveQuadraticForm</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;Q, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;b, <a class="el" href="classdouble.html">double</a> c, <a class="el" href="classdouble.html">double</a> tol=0)</td></tr>
<tr class="memdesc:ac0cb8ebf50f381b19b98f5901b6dea96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite a quadratic form xᵀQx + bᵀx + c to (Rx+d)ᵀ(Rx+d) where.  <br /></td></tr>
<tr class="memitem:a06e3b6d5de8ddc924a44a200f06d10f0" id="r_a06e3b6d5de8ddc924a44a200f06d10f0"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a06e3b6d5de8ddc924a44a200f06d10f0">BalanceQuadraticForms</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;S, const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;P)</td></tr>
<tr class="memdesc:a06e3b6d5de8ddc924a44a200f06d10f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given two quadratic forms, x'Sx &gt; 0 and x'Px, (with P symmetric and full rank), finds a change of variables x = Ty, which simultaneously diagonalizes both forms (as inspired by "balanced truncation" in model-order reduction [1]).  <br /></td></tr>
<tr class="memitem:a576be6d2ee0da7817d6b2632de99e482" id="r_a576be6d2ee0da7817d6b2632de99e482"><td class="memTemplParams" colspan="2">template&lt;typename Scalar&gt; </td></tr>
<tr class="memitem:a576be6d2ee0da7817d6b2632de99e482 template"><td class="memItemLeft" align="right" valign="top">Eigen::Quaternion&lt; Scalar &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a576be6d2ee0da7817d6b2632de99e482">ClosestQuaternion</a> (const Eigen::Quaternion&lt; Scalar &gt; &amp;quat1, const Eigen::Quaternion&lt; Scalar &gt; &amp;quat2)</td></tr>
<tr class="memdesc:a576be6d2ee0da7817d6b2632de99e482"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a unit quaternion that represents the same orientation as <span class="tt">quat2</span>, and has the "shortest" geodesic distance on the unit sphere to <span class="tt">quat1</span>.  <br /></td></tr>
<tr class="memitem:ae503a800803f4c8e12dafac65d466517" id="r_ae503a800803f4c8e12dafac65d466517"><td class="memTemplParams" colspan="2">template&lt;typename Derived&gt; </td></tr>
<tr class="memitem:ae503a800803f4c8e12dafac65d466517 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#af7e96394aef85f13f3fc84d3c3c238b3">Vector4</a>&lt; typename Derived::Scalar &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae503a800803f4c8e12dafac65d466517">quatConjugate</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;q)</td></tr>
<tr class="memitem:ab733c30c771e3930286e004dcf7174c0" id="r_ab733c30c771e3930286e004dcf7174c0"><td class="memTemplParams" colspan="2">template&lt;typename Derived1, typename Derived2&gt; </td></tr>
<tr class="memitem:ab733c30c771e3930286e004dcf7174c0 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#af7e96394aef85f13f3fc84d3c3c238b3">Vector4</a>&lt; typename Derived1::Scalar &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab733c30c771e3930286e004dcf7174c0">quatProduct</a> (const Eigen::MatrixBase&lt; Derived1 &gt; &amp;q1, const Eigen::MatrixBase&lt; Derived2 &gt; &amp;q2)</td></tr>
<tr class="memitem:a78031a9a3a9ede22a90564dd3297bab2" id="r_a78031a9a3a9ede22a90564dd3297bab2"><td class="memTemplParams" colspan="2">template&lt;typename DerivedQ, typename DerivedV&gt; </td></tr>
<tr class="memitem:a78031a9a3a9ede22a90564dd3297bab2 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; typename DerivedV::Scalar &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a78031a9a3a9ede22a90564dd3297bab2">quatRotateVec</a> (const Eigen::MatrixBase&lt; DerivedQ &gt; &amp;q, const Eigen::MatrixBase&lt; DerivedV &gt; &amp;v)</td></tr>
<tr class="memitem:ae3952e0b94673dab087b71aae0fe4264" id="r_ae3952e0b94673dab087b71aae0fe4264"><td class="memTemplParams" colspan="2">template&lt;typename Derived1, typename Derived2&gt; </td></tr>
<tr class="memitem:ae3952e0b94673dab087b71aae0fe4264 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#af7e96394aef85f13f3fc84d3c3c238b3">Vector4</a>&lt; typename Derived1::Scalar &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae3952e0b94673dab087b71aae0fe4264">quatDiff</a> (const Eigen::MatrixBase&lt; Derived1 &gt; &amp;q1, const Eigen::MatrixBase&lt; Derived2 &gt; &amp;q2)</td></tr>
<tr class="memitem:a8adec15eca22f51e09e025f5a6ff9171" id="r_a8adec15eca22f51e09e025f5a6ff9171"><td class="memTemplParams" colspan="2">template&lt;typename Derived1, typename Derived2, typename DerivedU&gt; </td></tr>
<tr class="memitem:a8adec15eca22f51e09e025f5a6ff9171 template"><td class="memItemLeft" align="right" valign="top">Derived1::Scalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8adec15eca22f51e09e025f5a6ff9171">quatDiffAxisInvar</a> (const Eigen::MatrixBase&lt; Derived1 &gt; &amp;q1, const Eigen::MatrixBase&lt; Derived2 &gt; &amp;q2, const Eigen::MatrixBase&lt; DerivedU &gt; &amp;u)</td></tr>
<tr class="memitem:a01008fbb23900d05b27e2d9ed5d3ec31" id="r_a01008fbb23900d05b27e2d9ed5d3ec31"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a01008fbb23900d05b27e2d9ed5d3ec31 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a01008fbb23900d05b27e2d9ed5d3ec31">is_quaternion_in_canonical_form</a> (const Eigen::Quaternion&lt; T &gt; &amp;quat)</td></tr>
<tr class="memdesc:a01008fbb23900d05b27e2d9ed5d3ec31"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function tests whether a quaternion is in "canonical form" meaning that it tests whether the quaternion [w, x, y, z] has a non-negative w value.  <br /></td></tr>
<tr class="memitem:aad5d8f41be198f8763008d964f9d596b" id="r_aad5d8f41be198f8763008d964f9d596b"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:aad5d8f41be198f8763008d964f9d596b template"><td class="memItemLeft" align="right" valign="top">Eigen::Quaternion&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aad5d8f41be198f8763008d964f9d596b">QuaternionToCanonicalForm</a> (const Eigen::Quaternion&lt; T &gt; &amp;quat)</td></tr>
<tr class="memdesc:aad5d8f41be198f8763008d964f9d596b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns a quaternion in its "canonical form" meaning that it returns a quaternion [w, x, y, z] with a non-negative w.  <br /></td></tr>
<tr class="memitem:a10aa6236fdaeb467f8734329bf60ec7d" id="r_a10aa6236fdaeb467f8734329bf60ec7d"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a10aa6236fdaeb467f8734329bf60ec7d template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a10aa6236fdaeb467f8734329bf60ec7d">AreQuaternionsEqualForOrientation</a> (const Eigen::Quaternion&lt; T &gt; &amp;quat1, const Eigen::Quaternion&lt; T &gt; &amp;quat2, const T tolerance)</td></tr>
<tr class="memdesc:a10aa6236fdaeb467f8734329bf60ec7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function tests whether two quaternions represent the same orientation.  <br /></td></tr>
<tr class="memitem:a68c366939df45d3e214806cebb9219ac" id="r_a68c366939df45d3e214806cebb9219ac"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a68c366939df45d3e214806cebb9219ac template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#af7e96394aef85f13f3fc84d3c3c238b3">Vector4</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a68c366939df45d3e214806cebb9219ac">CalculateQuaternionDtFromAngularVelocityExpressedInB</a> (const Eigen::Quaternion&lt; T &gt; &amp;quat_AB, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;w_AB_B)</td></tr>
<tr class="memdesc:a68c366939df45d3e214806cebb9219ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates a quaternion's time-derivative from its quaternion and angular velocity.  <br /></td></tr>
<tr class="memitem:add6ac3b937ea1491a1427fa17ab969b9" id="r_add6ac3b937ea1491a1427fa17ab969b9"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:add6ac3b937ea1491a1427fa17ab969b9 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#add6ac3b937ea1491a1427fa17ab969b9">CalculateAngularVelocityExpressedInBFromQuaternionDt</a> (const Eigen::Quaternion&lt; T &gt; &amp;quat_AB, const <a class="el" href="namespacedrake.html#af7e96394aef85f13f3fc84d3c3c238b3">Vector4</a>&lt; T &gt; &amp;quatDt)</td></tr>
<tr class="memdesc:add6ac3b937ea1491a1427fa17ab969b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates angular velocity from a quaternion and its time- derivative.  <br /></td></tr>
<tr class="memitem:a57f29f12dcb471da56ebb180929bba17" id="r_a57f29f12dcb471da56ebb180929bba17"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a57f29f12dcb471da56ebb180929bba17 template"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a57f29f12dcb471da56ebb180929bba17">CalculateQuaternionDtConstraintViolation</a> (const Eigen::Quaternion&lt; T &gt; &amp;quat, const <a class="el" href="namespacedrake.html#af7e96394aef85f13f3fc84d3c3c238b3">Vector4</a>&lt; T &gt; &amp;quatDt)</td></tr>
<tr class="memdesc:a57f29f12dcb471da56ebb180929bba17"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates how well a quaternion and its time-derivative satisfy the quaternion time-derivative constraint specified in [Kane, 1983] Section 1.13, equations 12-13, page 59.  <br /></td></tr>
<tr class="memitem:af9716f3d842206c012fe04b4545dc2bc" id="r_af9716f3d842206c012fe04b4545dc2bc"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:af9716f3d842206c012fe04b4545dc2bc template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af9716f3d842206c012fe04b4545dc2bc">IsQuaternionValid</a> (const Eigen::Quaternion&lt; T &gt; &amp;quat, const <a class="el" href="classdouble.html">double</a> tolerance)</td></tr>
<tr class="memdesc:af9716f3d842206c012fe04b4545dc2bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function tests if a quaternion satisfies the quaternion constraint specified in [Kane, 1983] Section 1.3, equation 4, page 12, i.e., a quaternion [w, x, y, z] must satisfy: w^2 + x^2 + y^2 + z^2 = 1.  <br /></td></tr>
<tr class="memitem:afd85f4c3652dc019638f54fba0fe5337" id="r_afd85f4c3652dc019638f54fba0fe5337"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:afd85f4c3652dc019638f54fba0fe5337 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afd85f4c3652dc019638f54fba0fe5337">IsBothQuaternionAndQuaternionDtOK</a> (const Eigen::Quaternion&lt; T &gt; &amp;quat, const <a class="el" href="namespacedrake.html#af7e96394aef85f13f3fc84d3c3c238b3">Vector4</a>&lt; T &gt; &amp;quatDt, const <a class="el" href="classdouble.html">double</a> tolerance)</td></tr>
<tr class="memdesc:afd85f4c3652dc019638f54fba0fe5337"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function tests if a quaternion satisfies the time-derivative constraint specified in [Kane, 1983] Section 1.13, equation 13, page 59.  <br /></td></tr>
<tr class="memitem:a8291c72eca9f98dfd2486c5c09f11fe5" id="r_a8291c72eca9f98dfd2486c5c09f11fe5"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a8291c72eca9f98dfd2486c5c09f11fe5 template"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8291c72eca9f98dfd2486c5c09f11fe5">IsQuaternionAndQuaternionDtEqualAngularVelocityExpressedInB</a> (const Eigen::Quaternion&lt; T &gt; &amp;quat, const <a class="el" href="namespacedrake.html#af7e96394aef85f13f3fc84d3c3c238b3">Vector4</a>&lt; T &gt; &amp;quatDt, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;w_B, const <a class="el" href="classdouble.html">double</a> tolerance)</td></tr>
<tr class="memdesc:a8291c72eca9f98dfd2486c5c09f11fe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function tests if a quaternion and a quaternion's time derivative can calculate and match an angular velocity to within a tolerance.  <br /></td></tr>
<tr class="memitem:a8aa04e5739514a4418de72e3300a60ba" id="r_a8aa04e5739514a4418de72e3300a60ba"><td class="memTemplParams" colspan="2">template&lt;typename T = double, class Generator = RandomGenerator&gt; </td></tr>
<tr class="memitem:a8aa04e5739514a4418de72e3300a60ba template"><td class="memItemLeft" align="right" valign="top">Eigen::Quaternion&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8aa04e5739514a4418de72e3300a60ba">UniformlyRandomQuaternion</a> (Generator *generator)</td></tr>
<tr class="memdesc:a8aa04e5739514a4418de72e3300a60ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a rotation (in the quaternion representation) that rotates a point on the unit sphere to another point on the unit sphere with a uniform distribution over the sphere.  <br /></td></tr>
<tr class="memitem:a94c069b2cc98fccfed321d9dbe21ac7c" id="r_a94c069b2cc98fccfed321d9dbe21ac7c"><td class="memTemplParams" colspan="2">template&lt;typename T = double, class Generator = RandomGenerator&gt; </td></tr>
<tr class="memitem:a94c069b2cc98fccfed321d9dbe21ac7c template"><td class="memItemLeft" align="right" valign="top">Eigen::AngleAxis&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a94c069b2cc98fccfed321d9dbe21ac7c">UniformlyRandomAngleAxis</a> (Generator *generator)</td></tr>
<tr class="memdesc:a94c069b2cc98fccfed321d9dbe21ac7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a rotation (in the axis-angle representation) that rotates a point on the unit sphere to another point on the unit sphere with a uniform distribution over the sphere.  <br /></td></tr>
<tr class="memitem:a99a6354b64c8945256e01ea4424ec30d" id="r_a99a6354b64c8945256e01ea4424ec30d"><td class="memTemplParams" colspan="2">template&lt;typename T = double, class Generator = RandomGenerator&gt; </td></tr>
<tr class="memitem:a99a6354b64c8945256e01ea4424ec30d template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a99a6354b64c8945256e01ea4424ec30d">UniformlyRandomRotationMatrix</a> (Generator *generator)</td></tr>
<tr class="memdesc:a99a6354b64c8945256e01ea4424ec30d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a rotation (in the rotation matrix representation) that rotates a point on the unit sphere to another point on the unit sphere with a uniform distribution over the sphere.  <br /></td></tr>
<tr class="memitem:a2d0dc847828b4e1ea981cc1d3425cd7d" id="r_a2d0dc847828b4e1ea981cc1d3425cd7d"><td class="memTemplParams" colspan="2">template&lt;typename T = double, class Generator = RandomGenerator&gt; </td></tr>
<tr class="memitem:a2d0dc847828b4e1ea981cc1d3425cd7d template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2d0dc847828b4e1ea981cc1d3425cd7d">UniformlyRandomRPY</a> (Generator *generator)</td></tr>
<tr class="memdesc:a2d0dc847828b4e1ea981cc1d3425cd7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a rotation (in the roll-pitch-yaw representation) that rotates a point on the unit sphere to another point on the unit sphere with a uniform distribution over the sphere.  <br /></td></tr>
<tr class="memitem:a133e7401303c1191fd2363fa630a5aeb" id="r_a133e7401303c1191fd2363fa630a5aeb"><td class="memTemplParams" colspan="2">template&lt;typename Derived&gt; </td></tr>
<tr class="memitem:a133e7401303c1191fd2363fa630a5aeb template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdrake_1_1math_1_1_gradient.html">drake::math::Gradient</a>&lt; Eigen::Matrix&lt; typenameDerived::Scalar, 3, 3 &gt;, 4 &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a133e7401303c1191fd2363fa630a5aeb">dquat2rotmat</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;quaternion)</td></tr>
<tr class="memdesc:a133e7401303c1191fd2363fa630a5aeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the gradient of the function that converts a unit length quaternion to a rotation matrix.  <br /></td></tr>
<tr class="memitem:a86089488f24d9c440c6486292b1732e0" id="r_a86089488f24d9c440c6486292b1732e0"><td class="memTemplParams" colspan="2">template&lt;typename DerivedR, typename DerivedDR&gt; </td></tr>
<tr class="memitem:a86089488f24d9c440c6486292b1732e0 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdrake_1_1math_1_1_gradient.html">drake::math::Gradient</a>&lt; Eigen::Matrix&lt; typenameDerivedR::Scalar, 3, 1 &gt;, DerivedDR::ColsAtCompileTime &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a86089488f24d9c440c6486292b1732e0">drotmat2rpy</a> (const Eigen::MatrixBase&lt; DerivedR &gt; &amp;R, const Eigen::MatrixBase&lt; DerivedDR &gt; &amp;dR)</td></tr>
<tr class="memdesc:a86089488f24d9c440c6486292b1732e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the gradient of the function that converts a rotation matrix to body-fixed z-y'-x'' Euler angles.  <br /></td></tr>
<tr class="memitem:afbb54825527e853ba8ea7ea1e8cf7ae3" id="r_afbb54825527e853ba8ea7ea1e8cf7ae3"><td class="memTemplParams" colspan="2">template&lt;typename DerivedR, typename DerivedDR&gt; </td></tr>
<tr class="memitem:afbb54825527e853ba8ea7ea1e8cf7ae3 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdrake_1_1math_1_1_gradient.html">drake::math::Gradient</a>&lt; Eigen::Matrix&lt; typenameDerivedR::Scalar, 4, 1 &gt;, DerivedDR::ColsAtCompileTime &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afbb54825527e853ba8ea7ea1e8cf7ae3">drotmat2quat</a> (const Eigen::MatrixBase&lt; DerivedR &gt; &amp;R, const Eigen::MatrixBase&lt; DerivedDR &gt; &amp;dR)</td></tr>
<tr class="memdesc:afbb54825527e853ba8ea7ea1e8cf7ae3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the gradient of the function that converts rotation matrix to quaternion.  <br /></td></tr>
<tr class="memitem:ad3e63a93f6a6d0e85c95da1ce7ee776d" id="r_ad3e63a93f6a6d0e85c95da1ce7ee776d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad3e63a93f6a6d0e85c95da1ce7ee776d">ProjectMatToRotMatWithAxis</a> (const Eigen::Matrix3d &amp;M, const Eigen::Vector3d &amp;axis, <a class="el" href="classdouble.html">double</a> angle_lb, <a class="el" href="classdouble.html">double</a> angle_ub)</td></tr>
<tr class="memdesc:ad3e63a93f6a6d0e85c95da1ce7ee776d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects an approximate 3 x 3 rotation matrix M onto an orthonormal matrix R so that R is a rotation matrix associated with a angle-axis rotation by an angle θ about a vector direction <span class="tt">axis</span>, with <span class="tt">angle_lb &lt;= θ &lt;= angle_ub</span>.  <br /></td></tr>
<tr class="memitem:a758d64dc7109ce2b49d24d1736e2ceb4" id="r_a758d64dc7109ce2b49d24d1736e2ceb4"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a758d64dc7109ce2b49d24d1736e2ceb4 template"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a758d64dc7109ce2b49d24d1736e2ceb4">SoftOverMax</a> (const std::vector&lt; T &gt; &amp;<a class="el" href="pixel__types_8h.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a>, <a class="el" href="classdouble.html">double</a> alpha=1.0)</td></tr>
<tr class="memdesc:a758d64dc7109ce2b49d24d1736e2ceb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a smooth over approximation of max function, namely SoftOverMax(x) &gt;= max(x).  <br /></td></tr>
<tr class="memitem:a85a1342c2e810987226bdc34fe974ad0" id="r_a85a1342c2e810987226bdc34fe974ad0"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a85a1342c2e810987226bdc34fe974ad0 template"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a85a1342c2e810987226bdc34fe974ad0">SoftUnderMax</a> (const std::vector&lt; T &gt; &amp;<a class="el" href="pixel__types_8h.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a>, <a class="el" href="classdouble.html">double</a> alpha=1.0)</td></tr>
<tr class="memdesc:a85a1342c2e810987226bdc34fe974ad0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a smooth under approximation of max function, namely SoftUnderMax(x) &lt;= max(x).  <br /></td></tr>
<tr class="memitem:a3c50f7950de875492fd065f398cc8a83" id="r_a3c50f7950de875492fd065f398cc8a83"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a3c50f7950de875492fd065f398cc8a83 template"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3c50f7950de875492fd065f398cc8a83">SoftOverMin</a> (const std::vector&lt; T &gt; &amp;<a class="el" href="pixel__types_8h.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a>, <a class="el" href="classdouble.html">double</a> alpha=1.0)</td></tr>
<tr class="memdesc:a3c50f7950de875492fd065f398cc8a83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a smooth over approximation of min function, namely SoftOverMin(x) &gt;= min(x).  <br /></td></tr>
<tr class="memitem:a63f9d06b6c78d0ee60a095cd5d84e9aa" id="r_a63f9d06b6c78d0ee60a095cd5d84e9aa"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a63f9d06b6c78d0ee60a095cd5d84e9aa template"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a63f9d06b6c78d0ee60a095cd5d84e9aa">SoftUnderMin</a> (const std::vector&lt; T &gt; &amp;<a class="el" href="pixel__types_8h.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a>, <a class="el" href="classdouble.html">double</a> alpha=1.0)</td></tr>
<tr class="memdesc:a63f9d06b6c78d0ee60a095cd5d84e9aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a smooth under approximation of min function, namely SoftUnderMin(x) &lt;= min(x).  <br /></td></tr>
<tr class="memitem:abd938f3f72e2bc3a2509e83f5587aad3" id="r_abd938f3f72e2bc3a2509e83f5587aad3"><td class="memTemplParams" colspan="2">template&lt;class T1, class T2&gt; </td></tr>
<tr class="memitem:abd938f3f72e2bc3a2509e83f5587aad3 template"><td class="memItemLeft" align="right" valign="top">T1&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abd938f3f72e2bc3a2509e83f5587aad3">wrap_to</a> (const T1 &amp;value, const T2 &amp;low, const T2 &amp;high)</td></tr>
<tr class="memdesc:abd938f3f72e2bc3a2509e83f5587aad3"><td class="mdescLeft">&#160;</td><td class="mdescRight">For variables that are meant to be periodic, (e.g.  <br /></td></tr>
<tr class="memitem:a25d3e276d5e4e1fad974214851ce0b46" id="r_a25d3e276d5e4e1fad974214851ce0b46"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a25d3e276d5e4e1fad974214851ce0b46 template"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#a25d3e276d5e4e1fad974214851ce0b46">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a>&lt; T &gt; &amp;X)</td></tr>
<tr class="memdesc:a25d3e276d5e4e1fad974214851ce0b46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream insertion operator to write an instance of <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html" title="This class represents a proper rigid transform between two frames which can be regarded in two ways.">RigidTransform</a> into a <span class="tt">std::ostream</span>.  <br /></td></tr>
<tr class="memitem:acc4f1cfde399c340eb155031eed2a485" id="r_acc4f1cfde399c340eb155031eed2a485"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:acc4f1cfde399c340eb155031eed2a485 template"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_roll_pitch_yaw.html#acc4f1cfde399c340eb155031eed2a485">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classdrake_1_1math_1_1_roll_pitch_yaw.html">RollPitchYaw</a>&lt; T &gt; &amp;rpy)</td></tr>
<tr class="memdesc:acc4f1cfde399c340eb155031eed2a485"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream insertion operator to write an instance of <a class="el" href="classdrake_1_1math_1_1_roll_pitch_yaw.html" title="This class represents the orientation between two arbitrary frames A and D associated with a Space-fi...">RollPitchYaw</a> into a <span class="tt">std::ostream</span>.  <br /></td></tr>
<tr id="func-members-0" class="groupHeader"><td colspan="2"><div class="groupHeader">solve linear system of equations with a given solver.</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p><a class="anchor" id="linear_solve_given_solver"></a> Solve linear system of equations A * x = b.</p>
<p>Where A is an Eigen matrix of double/AutoDiffScalar/symbolic::Expression, and b is an Eigen matrix of double/AutoDiffScalar/symbolic::Expression. Notice that if either A or b contains <a class="el" href="classdrake_1_1symbolic_1_1_expression.html" title="Represents a symbolic form of an expression.">symbolic::Expression</a>, then the other has to contain <a class="el" href="classdrake_1_1symbolic_1_1_expression.html" title="Represents a symbolic form of an expression.">symbolic::Expression</a>. This 3-argument version allows the user to re-use <code class="param">linear_solver</code> when <code class="param">b</code> changes or the gradient of <code class="param">A</code> changes. When either A or b contains AutoDiffScalar, we use implicit function theorem to find the gradient in x as ∂x/∂zᵢ = A⁻¹(∂b/∂zᵢ - ∂A/∂zᵢ * x) where z is the variable we take gradient with.</p>
<dl class="section note"><dt>Note</dt><dd>When both A and b are Eigen matrix of double, this function is almost as fast as calling linear_solver.solve(b) directly. When either A or b contains AutoDiffScalar, this function is a lot faster than first instantiating the linear solver of AutoDiffScalar, and then solving the equation with this autodiffable linear solver. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="classdrake_1_1math_1_1_linear_solver.html" title="Solves a linear system of equations A*x=b.">LinearSolver</a></td><td>The type of linear solver, for example Eigen::LLT&lt;Eigen::Matrix2d&gt; </td></tr>
    <tr><td class="paramname">DerivedA</td><td>An Eigen Matrix. </td></tr>
    <tr><td class="paramname">DerivedB</td><td>An Eigen <a class="el" href="namespacedrake.html#a01ae662d5635b7c9efe03d15d976f7a8" title="A column vector templated on the number of rows.">Vector</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">linear_solver</td><td>The linear solver constructed with the double-version of A. </td></tr>
    <tr><td class="paramname">A</td><td>The matrix A. </td></tr>
    <tr><td class="paramname">b</td><td>The vector b.</td></tr>
  </table>
  </dd>
</dl>
<p>Here is an example code. </p><div class="fragment"><div class="line">Eigen::Matrix&lt;AutoDiffd&lt;3&gt;, 2, 2&gt; A_ad;</div>
<div class="line"><span class="comment">// Set the value and gradient in A_ad with arbitrary values;</span></div>
<div class="line">Eigen::Matrix2d A_val;</div>
<div class="line">A_val &lt;&lt; 1, 2, 3, 4;</div>
<div class="line"><span class="comment">// Gradient of A.col(0).</span></div>
<div class="line">Eigen::Matrix&lt;double, 2, 3&gt; A0_gradient;</div>
<div class="line">A0_gradient &lt;&lt; 1, 2, 3, 4, 5, 6;</div>
<div class="line">A_ad.col(0) = <a class="code hl_function" href="#a41b52d9aa2a46f7d783f20b12085d9ab">InitializeAutoDiff</a>(A_val.col(0), A0_gradient);</div>
<div class="line"><span class="comment">// Gradient of A.col(1)</span></div>
<div class="line">Eigen::Matrix&lt;double, 2, 3&gt; A1_gradient;</div>
<div class="line">A1_gradient &lt;&lt; 7, 8, 9, 10, 11, 12;</div>
<div class="line">A_ad.col(1) = <a class="code hl_function" href="#a41b52d9aa2a46f7d783f20b12085d9ab">InitializeAutoDiff</a>(A_val.col(1), A1_gradient);</div>
<div class="line"><span class="comment">// Set the value and gradient of b to arbitrary value.</span></div>
<div class="line"><span class="keyword">const</span> Eigen::Vector2d b_val(2, 3);</div>
<div class="line">Eigen::Matrix&lt;double, 2, 3&gt; b_gradient;</div>
<div class="line">b_gradient &lt;&lt; 1, 3, 5, 7, 9, 11;</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> b_ad = <a class="code hl_function" href="#a41b52d9aa2a46f7d783f20b12085d9ab">InitializeAutoDiff</a>(b_val, b_gradient);</div>
<div class="line"><span class="comment">// Solve the linear system A_val * x_val = b_val.</span></div>
<div class="line">Eigen::PartialPivLU&lt;Eigen::Matrix2d&gt; linear_solver(A_val);</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> x_val = <a class="code hl_function" href="#a1f488e5d6f5e6d74ff2e0909c4223044">SolveLinearSystem</a>(linear_solver, A_val, b_val);</div>
<div class="line"><span class="comment">// Solve the linear system A*x=b, together with the gradient.</span></div>
<div class="line"><span class="comment">// x_ad contains both the value of the solution A*x=b, together with its</span></div>
<div class="line"><span class="comment">// gradient.</span></div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> x_ad = <a class="code hl_function" href="#a1f488e5d6f5e6d74ff2e0909c4223044">SolveLinearSystem</a>(linear_solver, A_ad, b_ad);</div>
<div class="ttc" id="anamespacedrake_1_1math_html_a1f488e5d6f5e6d74ff2e0909c4223044"><div class="ttname"><a href="#a1f488e5d6f5e6d74ff2e0909c4223044">drake::math::SolveLinearSystem</a></div><div class="ttdeci">std::enable_if&lt; internal::is_double_or_symbolic_v&lt; typenameDerivedA::Scalar &gt; &amp;&amp;internal::is_double_or_symbolic_v&lt; typenameDerivedB::Scalar &gt; &amp;&amp;std::is_same_v&lt; typenameDerivedA::Scalar, typenameDerivedB::Scalar &gt;, Eigen::Matrix&lt; typenameDerivedA::Scalar, DerivedA::RowsAtCompileTime, DerivedB::ColsAtCompileTime &gt; &gt;::type SolveLinearSystem(const LinearSolver &amp;linear_solver, const Eigen::MatrixBase&lt; DerivedA &gt; &amp;A, const Eigen::MatrixBase&lt; DerivedB &gt; &amp;b)</div><div class="ttdoc">Specialized when A and b are both double or symbolic::Expression matrices.</div><div class="ttdef"><b>Definition</b> linear_solve.h:122</div></div>
<div class="ttc" id="anamespacedrake_1_1math_html_a41b52d9aa2a46f7d783f20b12085d9ab"><div class="ttname"><a href="#a41b52d9aa2a46f7d783f20b12085d9ab">drake::math::InitializeAutoDiff</a></div><div class="ttdeci">void InitializeAutoDiff(const Eigen::MatrixBase&lt; Derived &gt; &amp;value, std::optional&lt; int &gt; num_derivatives, std::optional&lt; int &gt; deriv_num_start, Eigen::MatrixBase&lt; DerivedAutoDiff &gt; *auto_diff_matrix)</div><div class="ttdoc">Initializes a single AutoDiff matrix given the corresponding value matrix.</div><div class="ttdef"><b>Definition</b> autodiff.h:128</div></div>
</div><!-- fragment --> </div></td></tr>
<tr class="memitem:a1f488e5d6f5e6d74ff2e0909c4223044" id="r_a1f488e5d6f5e6d74ff2e0909c4223044"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classdrake_1_1math_1_1_linear_solver.html">LinearSolver</a>, typename DerivedA, typename DerivedB&gt; </td></tr>
<tr class="memitem:a1f488e5d6f5e6d74ff2e0909c4223044 template"><td class="memItemLeft" align="right" valign="top">std::enable_if&lt; internal::is_double_or_symbolic_v&lt; typenameDerivedA::Scalar &gt; &amp;&amp;internal::is_double_or_symbolic_v&lt; typenameDerivedB::Scalar &gt; &amp;&amp;std::is_same_v&lt; typenameDerivedA::Scalar, typenameDerivedB::Scalar &gt;, Eigen::Matrix&lt; typenameDerivedA::Scalar, DerivedA::RowsAtCompileTime, DerivedB::ColsAtCompileTime &gt; &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f488e5d6f5e6d74ff2e0909c4223044">SolveLinearSystem</a> (const <a class="el" href="classdrake_1_1math_1_1_linear_solver.html">LinearSolver</a> &amp;linear_solver, const Eigen::MatrixBase&lt; DerivedA &gt; &amp;A, const Eigen::MatrixBase&lt; DerivedB &gt; &amp;b)</td></tr>
<tr class="memdesc:a1f488e5d6f5e6d74ff2e0909c4223044"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized when A and b are both double or <a class="el" href="classdrake_1_1symbolic_1_1_expression.html" title="Represents a symbolic form of an expression.">symbolic::Expression</a> matrices.  <br /></td></tr>
<tr class="memitem:afd0c5c28f11ef2554ec39cd29240c095" id="r_afd0c5c28f11ef2554ec39cd29240c095"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classdrake_1_1math_1_1_linear_solver.html">LinearSolver</a>, typename DerivedB&gt; </td></tr>
<tr class="memitem:afd0c5c28f11ef2554ec39cd29240c095 template"><td class="memItemLeft" align="right" valign="top">std::enable_if&lt; internal::is_double_or_symbolic_v&lt; typenameLinearSolver::MatrixType::Scalar &gt; &amp;&amp;internal::is_double_or_symbolic_v&lt; typenameDerivedB::Scalar &gt; &amp;&amp;std::is_same_v&lt; typenameLinearSolver::MatrixType::Scalar, typenameDerivedB::Scalar &gt;, Eigen::Matrix&lt; typenameLinearSolver::MatrixType::Scalar, DerivedB::RowsAtCompileTime, DerivedB::ColsAtCompileTime &gt; &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afd0c5c28f11ef2554ec39cd29240c095">SolveLinearSystem</a> (const <a class="el" href="classdrake_1_1math_1_1_linear_solver.html">LinearSolver</a> &amp;linear_solver, const Eigen::MatrixBase&lt; DerivedB &gt; &amp;b)</td></tr>
<tr class="memdesc:afd0c5c28f11ef2554ec39cd29240c095"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized when the matrix in linear_solver and b are both double or <a class="el" href="classdrake_1_1symbolic_1_1_expression.html" title="Represents a symbolic form of an expression.">symbolic::Expression</a> matrices.  <br /></td></tr>
<tr class="memitem:aa4477ffa8132ff57594302f13bab5380" id="r_aa4477ffa8132ff57594302f13bab5380"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classdrake_1_1math_1_1_linear_solver.html">LinearSolver</a>, typename DerivedB&gt; </td></tr>
<tr class="memitem:aa4477ffa8132ff57594302f13bab5380 template"><td class="memItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same_v&lt; typenameLinearSolver::MatrixType::Scalar, <a class="el" href="classdouble.html">double</a> &gt; &amp;&amp;internal::is_autodiff_v&lt; typenameDerivedB::Scalar &gt;, Eigen::Matrix&lt; typenameDerivedB::Scalar, DerivedB::RowsAtCompileTime, DerivedB::ColsAtCompileTime &gt; &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa4477ffa8132ff57594302f13bab5380">SolveLinearSystem</a> (const <a class="el" href="classdrake_1_1math_1_1_linear_solver.html">LinearSolver</a> &amp;linear_solver, const Eigen::MatrixBase&lt; DerivedB &gt; &amp;b)</td></tr>
<tr class="memdesc:aa4477ffa8132ff57594302f13bab5380"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized the matrix in linear_solver is a double-valued matrix and b is an AutoDiffScalar-valued matrix.  <br /></td></tr>
<tr class="memitem:af1ad6cb210876e474e321b1ec677a5d0" id="r_af1ad6cb210876e474e321b1ec677a5d0"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classdrake_1_1math_1_1_linear_solver.html">LinearSolver</a>, typename DerivedA, typename DerivedB&gt; </td></tr>
<tr class="memitem:af1ad6cb210876e474e321b1ec677a5d0 template"><td class="memItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same_v&lt; typenameDerivedA::Scalar, <a class="el" href="classdouble.html">double</a> &gt; &amp;&amp;internal::is_autodiff_v&lt; typenameDerivedB::Scalar &gt;, Eigen::Matrix&lt; typenameDerivedB::Scalar, DerivedA::RowsAtCompileTime, DerivedB::ColsAtCompileTime &gt; &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af1ad6cb210876e474e321b1ec677a5d0">SolveLinearSystem</a> (const <a class="el" href="classdrake_1_1math_1_1_linear_solver.html">LinearSolver</a> &amp;linear_solver, const Eigen::MatrixBase&lt; DerivedA &gt; &amp;A, const Eigen::MatrixBase&lt; DerivedB &gt; &amp;b)</td></tr>
<tr class="memdesc:af1ad6cb210876e474e321b1ec677a5d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized when A is a double-valued matrix and b is an AutoDiffScalar-valued matrix.  <br /></td></tr>
<tr class="memitem:abbb4dcfd26d9913b0225231b8095f8b1" id="r_abbb4dcfd26d9913b0225231b8095f8b1"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classdrake_1_1math_1_1_linear_solver.html">LinearSolver</a>, typename DerivedA, typename DerivedB&gt; </td></tr>
<tr class="memitem:abbb4dcfd26d9913b0225231b8095f8b1 template"><td class="memItemLeft" align="right" valign="top">std::enable_if&lt; internal::is_autodiff_v&lt; typenameDerivedA::Scalar &gt;, Eigen::Matrix&lt; typenameDerivedA::Scalar, DerivedA::RowsAtCompileTime, DerivedB::ColsAtCompileTime &gt; &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abbb4dcfd26d9913b0225231b8095f8b1">SolveLinearSystem</a> (const <a class="el" href="classdrake_1_1math_1_1_linear_solver.html">LinearSolver</a> &amp;linear_solver, const Eigen::MatrixBase&lt; DerivedA &gt; &amp;A, const Eigen::MatrixBase&lt; DerivedB &gt; &amp;b)</td></tr>
<tr class="memdesc:abbb4dcfd26d9913b0225231b8095f8b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized when A is an AutoDiffScalar-valued matrix, and b can contain either AutoDiffScalar or double.  <br /></td></tr>
<tr id="func-members-1" class="groupHeader"><td colspan="2"><div class="groupHeader">Get linear solver</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p><a class="anchor" id="get_linear_solver"></a> Create the linear solver for a given matrix A, which will be used to solve the linear system of equations A * x = b.</p>
<p>The following table indicate the scalar type of the matrix in the returned linear solver, depending on the scalar type in matrix A</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">A  </th><th class="markdownTableHeadNone">double  </th><th class="markdownTableHeadNone">ADS  </th><th class="markdownTableHeadNone">Expr  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">solver  </td><td class="markdownTableBodyNone">double  </td><td class="markdownTableBodyNone">double  </td><td class="markdownTableBodyNone">Expr  </td></tr>
</table>
<p>where ADS stands for Eigen::AutoDiffScalar, and Expr stands for <a class="el" href="classdrake_1_1symbolic_1_1_expression.html" title="Represents a symbolic form of an expression.">symbolic::Expression</a>. Here is the example code </p><div class="fragment"><div class="line">Eigen::Matrix2d A_val;</div>
<div class="line">A_val &lt;&lt; 1, 2, 2, 5;</div>
<div class="line">Eigen::Vector2d b_val(3, 4);</div>
<div class="line"><span class="keyword">const</span> Eigen::Vector2d x_val =</div>
<div class="line">  <a class="code hl_function" href="#a1f488e5d6f5e6d74ff2e0909c4223044">SolveLinearSystem</a>(<a class="code hl_function" href="#a081ebae497dce90eb2e360cb4cd2d689">GetLinearSolver&lt;Eigen::LLT&gt;</a>(A_val), A_val, b_val);</div>
<div class="line">Eigen::Matrix&lt;AutoDiffXd, 2, 2&gt; A_ad;</div>
<div class="line">A_ad(0, 0).value() = A_val(0, 0);</div>
<div class="line">A_ad(0, 0).derivatives() = Eigen::Vector3d(1, 2, 3);</div>
<div class="line">A_ad(0, 1).value() = A_val(0, 1);</div>
<div class="line">A_ad(0, 1).derivatives() = Eigen::Vector3d(2, 3, 4);</div>
<div class="line">A_ad(1, 0).value() = A_val(1, 0);</div>
<div class="line">A_ad(1, 0).derivatives() = Eigen::Vector3d(3, 4, 5);</div>
<div class="line">A_ad(1, 1).value() = A_val(1, 1);</div>
<div class="line">A_ad(1, 1).derivatives() = Eigen::Vector3d(4, 5, 6);</div>
<div class="line"><span class="comment">// Solve A * x = b with A containing gradient.</span></div>
<div class="line"><span class="keyword">const</span> Eigen::Matrix&lt;AutoDiffXd, 2, 1&gt; x_ad1 =</div>
<div class="line">  <a class="code hl_function" href="#a1f488e5d6f5e6d74ff2e0909c4223044">SolveLinearSystem</a>(<a class="code hl_function" href="#a081ebae497dce90eb2e360cb4cd2d689">GetLinearSolver&lt;Eigen::LLT&gt;</a>(A_ad), A_ad, b_val);</div>
<div class="line">Eigen::Matrix&lt;AutoDiffXd, 2, 1&gt; b_ad;</div>
<div class="line">b_ad(0).value() = b_val(0);</div>
<div class="line">b_ad(0).derivatives() = Eigen::Vector3d(5, 6, 7);</div>
<div class="line">b_ad(1).value() = b_val(1);</div>
<div class="line">b_ad(1).derivatives() = Eigen::Vector3d(6, 7, 8);</div>
<div class="line"><span class="comment">// Solve A * x = b with b containing gradient.</span></div>
<div class="line"><span class="keyword">const</span> Eigen::Matrix&lt;AutoDiffXd, 2, 1&gt; x_ad2 =</div>
<div class="line">  <a class="code hl_function" href="#a1f488e5d6f5e6d74ff2e0909c4223044">SolveLinearSystem</a>(<a class="code hl_function" href="#a081ebae497dce90eb2e360cb4cd2d689">GetLinearSolver&lt;Eigen::LLT&gt;</a>(A_val), A_val, b_ad);</div>
<div class="line"><span class="comment">// Solve A * x = b with both A and b containing gradient.</span></div>
<div class="line"><span class="keyword">const</span> Eigen::Matrix&lt;AutoDiffXd, 2, 1&gt; x_ad3 =</div>
<div class="line">  <a class="code hl_function" href="#a1f488e5d6f5e6d74ff2e0909c4223044">SolveLinearSystem</a>(<a class="code hl_function" href="#a081ebae497dce90eb2e360cb4cd2d689">GetLinearSolver&lt;Eigen::LLT&gt;</a>(A_ad), A_ad, b_ad);</div>
<div class="ttc" id="anamespacedrake_1_1math_html_a081ebae497dce90eb2e360cb4cd2d689"><div class="ttname"><a href="#a081ebae497dce90eb2e360cb4cd2d689">drake::math::GetLinearSolver</a></div><div class="ttdeci">internal::EigenLinearSolver&lt; LinearSolverType, DerivedA &gt; GetLinearSolver(const Eigen::MatrixBase&lt; DerivedA &gt; &amp;A)</div><div class="ttdoc">Get the linear solver for a matrix A.</div><div class="ttdef"><b>Definition</b> linear_solve.h:422</div></div>
</div><!-- fragment --><p>{cc} </p>
</div></td></tr>
<tr class="memitem:a081ebae497dce90eb2e360cb4cd2d689" id="r_a081ebae497dce90eb2e360cb4cd2d689"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename, int... &gt; typename LinearSolverType, typename DerivedA&gt; </td></tr>
<tr class="memitem:a081ebae497dce90eb2e360cb4cd2d689 template"><td class="memItemLeft" align="right" valign="top">internal::EigenLinearSolver&lt; LinearSolverType, DerivedA &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a081ebae497dce90eb2e360cb4cd2d689">GetLinearSolver</a> (const Eigen::MatrixBase&lt; DerivedA &gt; &amp;A)</td></tr>
<tr class="memdesc:a081ebae497dce90eb2e360cb4cd2d689"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the linear solver for a matrix A.  <br /></td></tr>
<tr id="func-members-2" class="groupHeader"><td colspan="2"><div class="groupHeader">solve linear system of equations</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p><a class="anchor" id="linear_solve"></a> Solve linear system of equations A * x = b.</p>
<p>Where A is an Eigen matrix of double/AutoDiffScalar/symbolic::Expression, and b is an Eigen matrix of double/AutoDiffScalar/symbolic::Expression. Note that when either A or b contains <a class="el" href="classdrake_1_1symbolic_1_1_expression.html" title="Represents a symbolic form of an expression.">symbolic::Expression</a>, the other has to contain <a class="el" href="classdrake_1_1symbolic_1_1_expression.html" title="Represents a symbolic form of an expression.">symbolic::Expression</a> as well. When either A or b contains AutoDiffScalar, we use implicit function theorem to find the gradient in x as ∂x/∂zᵢ = A⁻¹(∂b/∂zᵢ - ∂A/∂zᵢ * x) where z is the variable we take gradient with.</p>
<p>The following table indicate the scalar type of x with A/b containing the specified scalar type. The entries with NA are not supported.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">b ＼ A  </th><th class="markdownTableHeadNone">double  </th><th class="markdownTableHeadNone">ADS  </th><th class="markdownTableHeadNone">Expr  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">double  </td><td class="markdownTableBodyNone">double  </td><td class="markdownTableBodyNone">ADS  </td><td class="markdownTableBodyNone">NA  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">ADS  </td><td class="markdownTableBodyNone">ADS  </td><td class="markdownTableBodyNone">ADS  </td><td class="markdownTableBodyNone">NA  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Expr  </td><td class="markdownTableBodyNone">NA  </td><td class="markdownTableBodyNone">NA  </td><td class="markdownTableBodyNone">Expr  </td></tr>
</table>
<p>where ADS stands for Eigen::AutoDiffScalar, and Expr stands for <a class="el" href="classdrake_1_1symbolic_1_1_expression.html" title="Represents a symbolic form of an expression.">symbolic::Expression</a>.</p>
<p>TODO(hongkai.dai): support one of A/b being a double matrix and the other being a <a class="el" href="classdrake_1_1symbolic_1_1_expression.html" title="Represents a symbolic form of an expression.">symbolic::Expression</a> matrix.</p>
<dl class="section note"><dt>Note</dt><dd>When both A and b are Eigen matrix of double, this function is almost as fast as calling linear_solver.solve(b) directly; when either A or b contains AutoDiffScalar, this function is a lot faster than first instantiating the linear solver of AutoDiffScalar, and then solving the equation with this autodiffable linear solver. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LinearSolverType</td><td>The type of linear solver, for example Eigen::LLT. Notice that this is just specifies the solver type (such as Eigen::LLT), not the matrix type (like Eigen::LLT&lt;Eigen::Matrix2d&gt;). All Eigen solvers we care about are templated on the matrix type. Some are further templated on configuration ints. The int... will account for zero or more of these ints, providing a common interface for both types of solvers. </td></tr>
    <tr><td class="paramname">DerivedA</td><td>An Eigen Matrix. </td></tr>
    <tr><td class="paramname">DerivedB</td><td>An Eigen <a class="el" href="namespacedrake.html#a01ae662d5635b7c9efe03d15d976f7a8" title="A column vector templated on the number of rows.">Vector</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The matrix A. </td></tr>
    <tr><td class="paramname">b</td><td>The vector b.</td></tr>
  </table>
  </dd>
</dl>
<p>Here is an example code. </p><div class="fragment"><div class="line">Eigen::Matrix&lt;AutoDiffd&lt;3&gt;, 2, 2&gt; A_ad;</div>
<div class="line"><span class="comment">// Set the value and gradient in A_ad with arbitrary values;</span></div>
<div class="line">Eigen::Matrix2d A_val;</div>
<div class="line">A_val &lt;&lt; 1, 2, 3, 4;</div>
<div class="line"><span class="comment">// Gradient of A.col(0).</span></div>
<div class="line">Eigen::Matrix&lt;double, 2, 3&gt; A0_gradient;</div>
<div class="line">A0_gradient &lt;&lt; 1, 2, 3, 4, 5, 6;</div>
<div class="line">A_ad.col(0) = <a class="code hl_function" href="#a41b52d9aa2a46f7d783f20b12085d9ab">InitializeAutoDiff</a>(A_val.col(0), A0_gradient);</div>
<div class="line"><span class="comment">// Gradient of A.col(1)</span></div>
<div class="line">Eigen::Matrix&lt;double, 2, 3&gt; A1_gradient;</div>
<div class="line">A1_gradient &lt;&lt; 7, 8, 9, 10, 11, 12;</div>
<div class="line">A_ad.col(1) = <a class="code hl_function" href="#a41b52d9aa2a46f7d783f20b12085d9ab">InitializeAutoDiff</a>(A_val.col(1), A1_gradient);</div>
<div class="line"><span class="comment">// Set the value and gradient of b to arbitrary value.</span></div>
<div class="line"><span class="keyword">const</span> Eigen::Vector2d b_val(2, 3);</div>
<div class="line">Eigen::Matrix&lt;double, 2, 3&gt; b_gradient;</div>
<div class="line">b_gradient &lt;&lt; 1, 3, 5, 7, 9, 11;</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> b_ad = <a class="code hl_function" href="#a41b52d9aa2a46f7d783f20b12085d9ab">InitializeAutoDiff</a>(b_val, b_gradient);</div>
<div class="line"><span class="comment">// Solve the linear system A*x=b without the gradient.</span></div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> x_val = <a class="code hl_function" href="#a1f488e5d6f5e6d74ff2e0909c4223044">SolveLinearSystem&lt;Eigen::PartialPivLU&gt;</a>(A_val, b_val);</div>
<div class="line"><span class="comment">// Solve the linear system A*x=b, together with the gradient.</span></div>
<div class="line"><span class="comment">// x_ad contains both the value of the solution A*x=b, together with its</span></div>
<div class="line"><span class="comment">// gradient.</span></div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> x_ad = <a class="code hl_function" href="#a1f488e5d6f5e6d74ff2e0909c4223044">SolveLinearSystem&lt;Eigen::PartialPivLU&gt;</a>(A_ad, b_ad);</div>
</div><!-- fragment --> </div></td></tr>
<tr class="memitem:a457f738539d660aec84e6fb0b6a93e93" id="r_a457f738539d660aec84e6fb0b6a93e93"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename, int... &gt; typename LinearSolverType, typename DerivedA, typename DerivedB&gt; </td></tr>
<tr class="memitem:a457f738539d660aec84e6fb0b6a93e93 template"><td class="memItemLeft" align="right" valign="top">internal::Solution&lt; DerivedA, DerivedB &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a457f738539d660aec84e6fb0b6a93e93">SolveLinearSystem</a> (const Eigen::MatrixBase&lt; DerivedA &gt; &amp;A, const Eigen::MatrixBase&lt; DerivedB &gt; &amp;b)</td></tr>
<tr class="memdesc:a457f738539d660aec84e6fb0b6a93e93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves system A*x=b.  <br /></td></tr>
</table>
<a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Typedef Documentation</h2>
<a id="a25ae6f07da9dbbdc55d02c5749c6a5b3" name="a25ae6f07da9dbbdc55d02c5749c6a5b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25ae6f07da9dbbdc55d02c5749c6a5b3">&#9670;&#160;</a></span>AutoDiffMatrixType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived, int nq&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a25ae6f07da9dbbdc55d02c5749c6a5b3">AutoDiffMatrixType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    <a class="code hl_typedef" href="namespacedrake.html#aae413ce2f94f0ecb301727a6781b69ff">MatrixLikewise&lt;Eigen::AutoDiffScalar&lt;Vector&lt;typename Derived::Scalar, nq&gt;</a>&gt;,</div>
<div class="line">                   Derived&gt;</div>
<div class="ttc" id="anamespacedrake_html_aae413ce2f94f0ecb301727a6781b69ff"><div class="ttname"><a href="namespacedrake.html#aae413ce2f94f0ecb301727a6781b69ff">drake::MatrixLikewise</a></div><div class="ttdeci">Eigen::Matrix&lt; Scalar, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime, Derived::IsRowMajor ? Eigen::RowMajor :Eigen::ColMajor, Derived::MaxRowsAtCompileTime, Derived::MaxColsAtCompileTime &gt; MatrixLikewise</div><div class="ttdoc">A matrix with the same compile-time sizes and storage order as Derived, but with a different scalar t...</div><div class="ttdef"><b>Definition</b> eigen_types.h:144</div></div>
</div><!-- fragment -->
<p>The appropriate AutoDiffScalar matrix type given the value type and the number of derivatives at compile time. </p>

</div>
</div>
<a name="doc-enum-members" id="doc-enum-members"></a><h2 id="header-doc-enum-members" class="groupheader">Enumeration Type Documentation</h2>
<a id="a2dc222f66e0f5092e8cfe879f24874b2" name="a2dc222f66e0f5092e8cfe879f24874b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dc222f66e0f5092e8cfe879f24874b2">&#9670;&#160;</a></span>KnotVectorType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a2dc222f66e0f5092e8cfe879f24874b2">KnotVectorType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enum representing types of knot vectors. </p>
<p>"Uniform" refers to the spacing between the knots. "Clamped" indicates that the first and last knots have multiplicity equal to the order of the spline.</p>
<p>Reference: <a href="http://web.mit.edu/hyperbook/Patrikalakis-Maekawa-Cho/node17.html">http://web.mit.edu/hyperbook/Patrikalakis-Maekawa-Cho/node17.html</a> </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a2dc222f66e0f5092e8cfe879f24874b2a3ea9f7aca87fd7b64469a0d1119f0b50" name="a2dc222f66e0f5092e8cfe879f24874b2a3ea9f7aca87fd7b64469a0d1119f0b50"></a>kUniform&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2dc222f66e0f5092e8cfe879f24874b2af1b493f6e43ce0d1371533ee4f1199d0" name="a2dc222f66e0f5092e8cfe879f24874b2af1b493f6e43ce0d1371533ee4f1199d0"></a>kClampedUniform&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a33f67c50b300b399043477a51861400a" name="a33f67c50b300b399043477a51861400a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33f67c50b300b399043477a51861400a">&#9670;&#160;</a></span>NumericalGradientMethod</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a33f67c50b300b399043477a51861400a">NumericalGradientMethod</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a33f67c50b300b399043477a51861400aae7c3602dce09c755e09250077a601a51" name="a33f67c50b300b399043477a51861400aae7c3602dce09c755e09250077a601a51"></a>kForward&#160;</td><td class="fielddoc"><p>Compute the gradient as (f(x + Δx) - f(x)) / Δx, with Δx &gt; 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="a33f67c50b300b399043477a51861400aa5cc7cc1518100eae9e3f2d83673a74ed" name="a33f67c50b300b399043477a51861400aa5cc7cc1518100eae9e3f2d83673a74ed"></a>kBackward&#160;</td><td class="fielddoc"><p>Compute the gradient as (f(x) - f(x - Δx)) / Δx, with Δx &gt; 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="a33f67c50b300b399043477a51861400aa39209ccaab9620e08ec04483c22a7eda" name="a33f67c50b300b399043477a51861400aa39209ccaab9620e08ec04483c22a7eda"></a>kCentral&#160;</td><td class="fielddoc"><p>Compute the gradient as (f(x + Δx) - f(x - Δx)) / (2Δx), with Δx &gt; 0. </p>
</td></tr>
</table>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="ab8de94fedb09b1b5dec16c615d68eb23" name="ab8de94fedb09b1b5dec16c615d68eb23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8de94fedb09b1b5dec16c615d68eb23">&#9670;&#160;</a></span>AreAutoDiffVecXdEqual()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AreAutoDiffVecXdEqual </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="namespacedrake.html#a35725b277b02aeb79f24fd7f724e6dbc">AutoDiffXd</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="namespacedrake.html#a35725b277b02aeb79f24fd7f724e6dbc">AutoDiffXd</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if a and b are equal. </p>
<p>a equals to b if they have the same value and gradients. TODO(hongkai.dai) implement and use std::equal_to&lt;&gt; for comparing Eigen vector of <a class="el" href="namespacedrake.html#a35725b277b02aeb79f24fd7f724e6dbc" title="An autodiff variable with a dynamic number of partials.">AutoDiffXd</a>. </p>

</div>
</div>
<a id="a10aa6236fdaeb467f8734329bf60ec7d" name="a10aa6236fdaeb467f8734329bf60ec7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10aa6236fdaeb467f8734329bf60ec7d">&#9670;&#160;</a></span>AreQuaternionsEqualForOrientation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; T &gt; AreQuaternionsEqualForOrientation </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Quaternion&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>quat1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Quaternion&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>quat2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T</td>          <td class="paramname"><span class="paramname"><em>tolerance</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function tests whether two quaternions represent the same orientation. </p>
<p>This function converts each quaternion to its canonical form and tests whether the absolute value of the difference in corresponding elements of these canonical quaternions is within tolerance. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">quat1</td><td><a class="el" href="namespacedrake.html#a4156bf453a5b323356d7cc784dfdf084" title="A quaternion templated on scalar type.">Quaternion</a> [w, x, y, z] that relates two right-handed orthogonal unitary bases e.g., Ax, Ay, Az (A) to Bx, By, Bz (B). Note: quat is analogous to the rotation matrix R_AB. </td></tr>
    <tr><td class="paramname">quat2</td><td><a class="el" href="namespacedrake.html#a4156bf453a5b323356d7cc784dfdf084" title="A quaternion templated on scalar type.">Quaternion</a> with a description analogous to quat1. </td></tr>
    <tr><td class="paramname">tolerance</td><td>Nonnegative real scalar defining the allowable difference in the orientation described by quat1 and quat2. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><span class="tt">true</span> if quat1 and quat2 represent the same orientation (to within tolerance), otherwise <span class="tt">false</span>. </dd></dl>

</div>
</div>
<a id="a06e3b6d5de8ddc924a44a200f06d10f0" name="a06e3b6d5de8ddc924a44a200f06d10f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06e3b6d5de8ddc924a44a200f06d10f0">&#9670;&#160;</a></span>BalanceQuadraticForms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd BalanceQuadraticForms </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>S</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>P</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given two quadratic forms, x'Sx &gt; 0 and x'Px, (with P symmetric and full rank), finds a change of variables x = Ty, which simultaneously diagonalizes both forms (as inspired by "balanced truncation" in model-order reduction [1]). </p>
<p>In this note, we use abs(M) to indicate the elementwise absolute value.</p>
<p>Adapting from [1], we observe that there is a family of coordinate systems that can simultaneously diagonalize T'ST and T'PT. Using D to denote a diagonal matrix, we call the result S-normal if T'ST = I and abs(T'PT) = D⁻², call it P-normal if T'ST = D² and abs(T'PT) = I, and call it "balanced" if T'ST = D and abs(T'PT) = D⁻¹. Note that if P &gt; 0, then T'PT = D⁻¹.</p>
<p>We find x=Ty such that T'ST = D and abs(T'PT) = D⁻¹, where D is diagonal. The recipe is:</p><ul>
<li>Factorize S = LL', and choose R=L⁻¹.</li>
<li>Take svd(RPR') = UΣV', and note that U=V for positive definite matrices, and V is U up to a sign flip of the singular vectors for all symmetric matrices.</li>
<li>Choose T = R'U Σ^{-1/4}, where the matrix exponent can be taken elementwise because Σ is diagonal. This gives T'ST = Σ^{-1/2} (by using U'U=I), and abs(T'PT) = Σ^{1/2}. If P &gt; 0, then T'PT = Σ^{1/2}.</li>
</ul>
<p>Note that the numerical "balancing" can address the absolute scaling of the quadratic forms, but not the relative scaling. To understand this, consider the scalar case: we have two quadratic functions, sx² and px², with s&gt;0, p&gt;0. We'd like to choose x=Ty so that sT²y² and pT²y² are "balanced" (we'd like them both to be close to y²). We'll choose T=p^{-1/4}s^{-1/4}, which gives sx² = sqrt(s/p)y², and px² = sqrt(p/s)y². For instance if s=1e8 and p=1e8, then t=1e-4 and st^2 = pt^2 = 1. But if s=10, p=1e7, then t=0.01, and st^2 = 1e-3, pt^2 = 1e3.</p>
<p>In the matrix case, the absolute scaling is important &ndash; it ensures that the two quadratic forms have the same matrix condition number and makes them as close as possible to 1. Besides absolute scaling, in the matrix case the balancing transform diagonalizes both quadratic forms.</p>
<p>[1] B. Moore, “Principal component analysis in linear systems: Controllability, observability, and model reduction,” IEEE Trans. Automat. Contr., vol. 26, no. 1, pp. 17–32, Feb. 1981. </p>

</div>
</div>
<a id="a961adeb2899673c1cee7062ad80aab81" name="a961adeb2899673c1cee7062ad80aab81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a961adeb2899673c1cee7062ad80aab81">&#9670;&#160;</a></span>BinomialCoefficient()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BinomialCoefficient </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>k</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the binomial coefficient <span class="tt">n</span>-choose-<span class="tt">k</span> efficiently using a dynamic programming recursion. </p>
<p><a href="https://en.wikipedia.org/wiki/Binomial_coefficient">https://en.wikipedia.org/wiki/Binomial_coefficient</a></p>
<dl class="section pre"><dt>Precondition</dt><dd>k &gt;= 0 </dd></dl>

</div>
</div>
<a id="add6ac3b937ea1491a1427fa17ab969b9" name="add6ac3b937ea1491a1427fa17ab969b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add6ac3b937ea1491a1427fa17ab969b9">&#9670;&#160;</a></span>CalculateAngularVelocityExpressedInBFromQuaternionDt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; CalculateAngularVelocityExpressedInBFromQuaternionDt </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Quaternion&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>quat_AB</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#af7e96394aef85f13f3fc84d3c3c238b3">Vector4</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>quatDt</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function calculates angular velocity from a quaternion and its time- derivative. </p>
<p>Algorithm from [Kane, 1983] Section 1.13, Pages 58-59.</p>
<ul>
<li>[Kane, 1983] "Spacecraft Dynamics," McGraw-Hill Book Co., New York, 1983. (with P. W. Likins and D. A. Levinson). Available for free .pdf download: <a href="https://ecommons.cornell.edu/handle/1813/637">https://ecommons.cornell.edu/handle/1813/637</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">quat_AB</td><td><a class="el" href="namespacedrake.html#a4156bf453a5b323356d7cc784dfdf084" title="A quaternion templated on scalar type.">Quaternion</a> [w, x, y, z] that relates two right-handed orthogonal unitary bases e.g., Ax, Ay, Az (A) to Bx, By, Bz (B). Note: quat_AB is analogous to the rotation matrix R_AB. </td></tr>
    <tr><td class="paramname">quatDt</td><td>Time-derivative of <span class="tt">quat_AB</span>, i.e. [ẇ, ẋ, ẏ, ż]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">w_AB_B</td><td>B's angular velocity in A, expressed in B. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a57f29f12dcb471da56ebb180929bba17" name="a57f29f12dcb471da56ebb180929bba17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57f29f12dcb471da56ebb180929bba17">&#9670;&#160;</a></span>CalculateQuaternionDtConstraintViolation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T CalculateQuaternionDtConstraintViolation </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Quaternion&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>quat</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#af7e96394aef85f13f3fc84d3c3c238b3">Vector4</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>quatDt</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function calculates how well a quaternion and its time-derivative satisfy the quaternion time-derivative constraint specified in [Kane, 1983] Section 1.13, equations 12-13, page 59. </p>
<p>For a quaternion [w, x, y, z], the quaternion must satisfy: w^2 + x^2 + y^2 + z^2 = 1, hence its time-derivative must satisfy: 2*(w*ẇ + x*ẋ + y*ẏ + z*ż) = 0.</p>
<ul>
<li>[Kane, 1983] "Spacecraft Dynamics," McGraw-Hill Book Co., New York, 1983. (with P. W. Likins and D. A. Levinson). Available for free .pdf download: <a href="https://ecommons.cornell.edu/handle/1813/637">https://ecommons.cornell.edu/handle/1813/637</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">quat</td><td><a class="el" href="namespacedrake.html#a4156bf453a5b323356d7cc784dfdf084" title="A quaternion templated on scalar type.">Quaternion</a> [w, x, y, z] that relates two right-handed orthogonal unitary bases e.g., Ax, Ay, Az (A) to Bx, By, Bz (B). Note: A quaternion like quat_AB is analogous to the rotation matrix R_AB. </td></tr>
    <tr><td class="paramname">quatDt</td><td>Time-derivative of <span class="tt">quat</span>, i.e., [ẇ, ẋ, ẏ, ż]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">quaternionDt_constraint_violation</td><td>The amount the time- derivative of the quaternion constraint has been violated, which may be positive or negative (0 means the constraint is perfectly satisfied). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a68c366939df45d3e214806cebb9219ac" name="a68c366939df45d3e214806cebb9219ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68c366939df45d3e214806cebb9219ac">&#9670;&#160;</a></span>CalculateQuaternionDtFromAngularVelocityExpressedInB()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#af7e96394aef85f13f3fc84d3c3c238b3">Vector4</a>&lt; T &gt; CalculateQuaternionDtFromAngularVelocityExpressedInB </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Quaternion&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>quat_AB</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>w_AB_B</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function calculates a quaternion's time-derivative from its quaternion and angular velocity. </p>
<p>Algorithm from [Kane, 1983] Section 1.13, Pages 58-59.</p>
<ul>
<li>[Kane, 1983] "Spacecraft Dynamics," McGraw-Hill Book Co., New York, 1983. (With P. W. Likins and D. A. Levinson). Available for free .pdf download: <a href="https://ecommons.cornell.edu/handle/1813/637">https://ecommons.cornell.edu/handle/1813/637</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">quat_AB</td><td><a class="el" href="namespacedrake.html#a4156bf453a5b323356d7cc784dfdf084" title="A quaternion templated on scalar type.">Quaternion</a> [w, x, y, z] that relates two right-handed orthogonal unitary bases e.g., Ax, Ay, Az (A) to Bx, By, Bz (B). Note: quat_AB is analogous to the rotation matrix R_AB. </td></tr>
    <tr><td class="paramname">w_AB_B</td><td>B's angular velocity in A, expressed in B. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">quatDt</td><td>Time-derivative of quat_AB, i.e., [ẇ, ẋ, ẏ, ż]. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1cf0d1e6ddb8878dded6253d7ef6b25d" name="a1cf0d1e6ddb8878dded6253d7ef6b25d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cf0d1e6ddb8878dded6253d7ef6b25d">&#9670;&#160;</a></span>CalculateReflectedGrayCodes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int NumDigits = Eigen::Dynamic&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdrake_1_1math_1_1_gray_codes_matrix.html">GrayCodesMatrix</a>&lt; NumDigits &gt;::type CalculateReflectedGrayCodes </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num_digits</em></span><span class="paramdefsep"> = </span><span class="paramdefval">NumDigits</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a matrix whose i'th row is the Gray code for integer i. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">NumDigits</td><td>The number of digits in the Gray code. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_digits</td><td>The number of digits in the Gray code. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M. M is a matrix of size 2ᵏ x k, where <span class="tt">k</span> is <span class="tt">num_digits</span>. M.row(i) is the Gray code for integer i. </dd></dl>

</div>
</div>
<a id="a576be6d2ee0da7817d6b2632de99e482" name="a576be6d2ee0da7817d6b2632de99e482"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a576be6d2ee0da7817d6b2632de99e482">&#9670;&#160;</a></span>ClosestQuaternion()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Quaternion&lt; Scalar &gt; ClosestQuaternion </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Quaternion&lt; Scalar &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>quat1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Quaternion&lt; Scalar &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>quat2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a unit quaternion that represents the same orientation as <span class="tt">quat2</span>, and has the "shortest" geodesic distance on the unit sphere to <span class="tt">quat1</span>. </p>

</div>
</div>
<a id="a25fb88b582a1cedece10b67353f2d18d" name="a25fb88b582a1cedece10b67353f2d18d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25fb88b582a1cedece10b67353f2d18d">&#9670;&#160;</a></span>ComputeNumericalGradient()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedX, typename DerivedY, typename DerivedCalcX&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt; typename DerivedX::Scalar, DerivedY::RowsAtCompileTime, DerivedX::RowsAtCompileTime &gt; ComputeNumericalGradient </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(const DerivedCalcX &amp;, DerivedY *y)&gt;</td>          <td class="paramname"><span class="paramname"><em>calc_func</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DerivedX &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_numerical_gradient_option.html">NumericalGradientOption</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>option</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classdrake_1_1math_1_1_numerical_gradient_option.html">NumericalGradientOption</a>{&#160;<a class="el" href="#a33f67c50b300b399043477a51861400aae7c3602dce09c755e09250077a601a51">NumericalGradientMethod::kForward</a>}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the gradient of a function f(x) through numerical difference. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">calc_func</td><td>calc_func(x, &amp;y) computes the value of f(x), and stores the value in y. <span class="tt">calc_func</span> is responsible for properly resizing the output <span class="tt">y</span> when it consists of an Eigen vector of Eigen::Dynamic size.</td></tr>
    <tr><td class="paramname">x</td><td>The point at which the numerical gradient is computed. </td></tr>
    <tr><td class="paramname">option</td><td>The options for computing numerical gradient. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DerivedX</td><td>an Eigen column vector. </td></tr>
    <tr><td class="paramname">DerivedY</td><td>an Eigen column vector. </td></tr>
    <tr><td class="paramname">DerivedCalcX</td><td>The type of x in the calc_func. Must be an Eigen column vector. It is possible to have DerivedCalcX being different from DerivedX, for example, <span class="tt">calc_func</span> could be solvers::EvaluatorBase(const
Eigen::Ref&lt;const Eigen::VectorXd&gt;&amp;, Eigen::VectorXd*), but <span class="tt">x</span> could be of type Eigen::VectorXd. TODO(hongkai.dai): understand why the default template DerivedCalcX = DerivedX doesn't compile when I instantiate ComputeNumericalGradient&lt;DerivedX, DerivedY&gt;(calc_func, x); </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">gradient</td><td>a matrix of size x.rows() x y.rows(). gradient(i, j) is ∂f(i) / ∂x(j)</td></tr>
  </table>
  </dd>
</dl>
<p>Examples: </p><div class="fragment"><div class="line"><span class="comment">// Create a std::function from a lambda expression.</span></div>
<div class="line">std::function&lt;void (<span class="keyword">const</span> Eigen::Vector2d&amp;, Vector3d*)&gt; foo = [](<span class="keyword">const</span></div>
<div class="line">Eigen::Vector2d&amp; <a class="code hl_variable" href="pixel__types_8h.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a>, Vector3d*y) { (*y)(0) = <a class="code hl_variable" href="pixel__types_8h.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a>(0); (*y)(1) = <a class="code hl_variable" href="pixel__types_8h.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a>(0) * <a class="code hl_variable" href="pixel__types_8h.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a>(1);</div>
<div class="line">(*y)(2) = <a class="code hl_variable" href="pixel__types_8h.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a>(0) * std::sin(<a class="code hl_variable" href="pixel__types_8h.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a>(1));};</div>
<div class="line">Eigen::Vector3d x_eval(1, 2, 3);</div>
<div class="line"><span class="keyword">auto</span> J = <a class="code hl_function" href="#a25fb88b582a1cedece10b67353f2d18d">ComputeNumericalGradient</a>(foo, x_eval);</div>
<div class="line"><span class="comment">// Note that if we pass in a lambda to ComputeNumericalGradient, then</span></div>
<div class="line"><span class="comment">// ComputeNumericalGradient has to instantiate the template types explicitly,</span></div>
<div class="line"><span class="comment">// as in this example. The issue of template deduction with std::function is</span></div>
<div class="line"><span class="comment">// explained in</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">https:<span class="comment">//stackoverflow.com/questions/48529410/template-arguments-deduction-failed-passing-func-pointer-to-stdfunction</span></div>
<div class="line"><span class="keyword">auto</span> bar = [](<span class="keyword">const</span> Eigen::Vector2d&amp; <a class="code hl_variable" href="pixel__types_8h.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a>, Eigen::Vector2d* y) {*y = <a class="code hl_variable" href="pixel__types_8h.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a>; };</div>
<div class="line"><span class="keyword">auto</span> J2 = <a class="code hl_function" href="#a25fb88b582a1cedece10b67353f2d18d">ComputeNumericalGradient</a>&lt;Eigen::Vector2d,</div>
<div class="line">Eigen::Vector2d, Eigen::Vector2d&gt;(bar, Eigen::Vector2d(2, 3));</div>
<div class="ttc" id="anamespacedrake_1_1math_html_a25fb88b582a1cedece10b67353f2d18d"><div class="ttname"><a href="#a25fb88b582a1cedece10b67353f2d18d">drake::math::ComputeNumericalGradient</a></div><div class="ttdeci">Eigen::Matrix&lt; typename DerivedX::Scalar, DerivedY::RowsAtCompileTime, DerivedX::RowsAtCompileTime &gt; ComputeNumericalGradient(std::function&lt; void(const DerivedCalcX &amp;, DerivedY *y)&gt; calc_func, const DerivedX &amp;x, const NumericalGradientOption &amp;option=NumericalGradientOption{ NumericalGradientMethod::kForward})</div><div class="ttdoc">Compute the gradient of a function f(x) through numerical difference.</div><div class="ttdef"><b>Definition</b> compute_numerical_gradient.h:94</div></div>
<div class="ttc" id="apixel__types_8h_html_a9336ebf25087d91c818ee6e9ec29f8c1"><div class="ttname"><a href="pixel__types_8h.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a></div><div class="ttdeci">x</div><div class="ttdef"><b>Definition</b> pixel_types.h:182</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a47d4e4f52f3321536bf570b3a1a23718" name="a47d4e4f52f3321536bf570b3a1a23718"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47d4e4f52f3321536bf570b3a1a23718">&#9670;&#160;</a></span>ContinuousAlgebraicRiccatiEquation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd ContinuousAlgebraicRiccatiEquation </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>Q</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::LLT&lt; Eigen::MatrixXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>R_cholesky</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is functionally the same as ContinuousAlgebraicRiccatiEquation(A, B, Q, R). </p>
<p>The Cholesky decomposition of R is passed in instead of R. </p>

</div>
</div>
<a id="aed596a7b73bd51a9acfa28df7be4214f" name="aed596a7b73bd51a9acfa28df7be4214f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed596a7b73bd51a9acfa28df7be4214f">&#9670;&#160;</a></span>ContinuousAlgebraicRiccatiEquation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd ContinuousAlgebraicRiccatiEquation </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>Q</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>R</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the unique stabilizing solution S to the continuous-time algebraic Riccati equation: </p>
<p class="formulaDsp">
\[S A + A&#39; S - S B R^{-1} B&#39; S + Q = 0
\]
</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the Hamiltanoian matrix <pre>
⌈A   BR⁻¹Bᵀ⌉
⌊Q      −Aᵀ⌋
</pre> is not invertible. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if R is not positive definite. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the pair (A, B) should be stabilizable, and (Q, A) should be detectable. For more information, please refer to page 526-527 of Linear Systems by Thomas Kailath.</dd></dl>
<p>Based on the Matrix Sign Function method outlined in this paper: <a href="http://www.engr.iupui.edu/~skoskie/ECE684/Riccati_algorithms.pdf">http://www.engr.iupui.edu/~skoskie/ECE684/Riccati_algorithms.pdf</a> </p>

</div>
</div>
<a id="a178c2116d7750bdd9ab8647b69e51a9d" name="a178c2116d7750bdd9ab8647b69e51a9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a178c2116d7750bdd9ab8647b69e51a9d">&#9670;&#160;</a></span>ConvertTimeDerivativeToOtherFrame()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename v_Type, typename DtB_v_Type, typename w_AB_Type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; typename v_Type::Scalar &gt; ConvertTimeDerivativeToOtherFrame </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; v_Type &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>v_E</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DtB_v_Type &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>DtB_v_E</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; w_AB_Type &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>w_AB_E</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given ᴮd/dt(v) (the time derivative in frame B of an arbitrary 3D vector v) and given ᴬωᴮ (frame B's angular velocity in another frame A), this method computes ᴬd/dt(v) (the time derivative in frame A of v) by: ᴬd/dt(v) = ᴮd/dt(v) + ᴬωᴮ x v. </p>
<p>This mathematical operation is known as the "Transport Theorem" or the "Golden Rule for Vector Differentiation" [Mitiguy 2016, §7.3]. It was discovered by Euler in 1758. Its explicit notation with superscript frames was invented by Thomas Kane in 1950. Its use as the defining property of angular velocity was by Mitiguy in 1993.</p>
<p>In source code and comments, we use the following monogram notations: DtA_v = ᴬd/dt(v) denotes the time derivative in frame A of the vector v. DtA_v_E = [ᴬd/dt(v)]_E denotes the time derivative in frame A of vector v, with the resulting new vector quantity expressed in a frame E.</p>
<p>In source code, this mathematical operation is performed with all vectors expressed in the same frame E as [ᴬd/dt(v)]ₑ = [ᴮd/dt(v)]ₑ + [ᴬωᴮ]ₑ x [v]ₑ which in monogram notation is: </p><pre>
  DtA_v_E = DtB_v_E + w_AB_E x v_E
</pre><p>[Mitiguy 2016] Mitiguy, P., 2016. Advanced Dynamics &amp; Motion Simulation. </p>

</div>
</div>
<a id="ac0cb8ebf50f381b19b98f5901b6dea96" name="ac0cb8ebf50f381b19b98f5901b6dea96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0cb8ebf50f381b19b98f5901b6dea96">&#9670;&#160;</a></span>DecomposePositiveQuadraticForm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; Eigen::MatrixXd, Eigen::MatrixXd &gt; DecomposePositiveQuadraticForm </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>Q</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>tol</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrite a quadratic form xᵀQx + bᵀx + c to (Rx+d)ᵀ(Rx+d) where. </p>
<pre>
RᵀR = Q
Rᵀd = b / 2
dᵀd = c
</pre><p>This decomposition requires the matrix </p><pre>
⌈Q     b/2⌉
⌊bᵀ/2    c⌋
</pre><p> to be positive semidefinite.</p>
<p>We return R and d with the minimal number of rows, namely the rows of R and d equal to the rank of the matrix </p><pre>
⌈Q     b/2⌉
⌊bᵀ/2    c⌋
</pre><p>Notice that R might have more rows than Q, For example, the quadratic expression x² + 2x + 5 =(x+1)² + 2², it can be decomposed as </p><pre>
⎛⌈1⌉ * x + ⌈1⌉⎞ᵀ * ⎛⌈1⌉ * x + ⌈1⌉⎞
⎝⌊0⌋       ⌊2⌋⎠    ⎝⌊0⌋       ⌊2⌋⎠
</pre><p> Here R has 2 rows while Q only has 1 row.</p>
<p>On the other hand the quadratic expression x² + 2x + 1 can be decomposed as (x+1) * (x+1), where R has 1 row, same as Q.</p>
<p>Also notice that this decomposition is not unique. For example, with any permutation matrix P, we can define </p><pre>
R₁ = P*R
d₁ = P*d
</pre><p> Then (R₁*x+d₁)ᵀ(R₁*x+d₁) gives the same quadratic form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Q</td><td>The square matrix. </td></tr>
    <tr><td class="paramname">b</td><td>The vector containing the linear coefficients. </td></tr>
    <tr><td class="paramname">c</td><td>The constant term. </td></tr>
    <tr><td class="paramname">tol</td><td>We will determine if this quadratic form is always non-negative, by checking the Eigen values of the matrix [Q b/2] [bᵀ/2 c] are all greater than -tol. <br  />
 <em class="arg">Default:</em> is 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">(R,d).</td><td>R and d have the same number of rows. R.cols() == x.rows(). R.rows() equals to the rank of the matrix <pre>
   [Q    b/2]
   [bᵀ/2   c]
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>1. The quadratic form is always non-negative, namely the matrix <pre>
        [Q    b/2]
        [bᵀ/2   c]
        </pre> is positive semidefinite.<ol type="1">
<li><span class="tt">Q</span> and <span class="tt">b</span> are of the correct size.</li>
<li><span class="tt">tol</span> is non-negative. </li>
</ol>
</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the precondition is not satisfied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac24fd667914c5489bdfed7973a1c7388" name="ac24fd667914c5489bdfed7973a1c7388"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac24fd667914c5489bdfed7973a1c7388">&#9670;&#160;</a></span>DecomposePSDmatrixIntoXtransposeTimesX()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd DecomposePSDmatrixIntoXtransposeTimesX </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>Y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>zero_tol</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>return_empty_if_not_psd</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For a symmetric positive semidefinite matrix Y, decompose it into XᵀX, where the number of rows in X equals to the rank of Y. </p>
<p>Notice that this decomposition is not unique. For any orthonormal matrix U, s.t UᵀU = identity, X_prime = UX also satisfies X_primeᵀX_prime = Y. Here we only return one valid decomposition. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Y</td><td>A symmetric positive semidefinite matrix. </td></tr>
    <tr><td class="paramname">zero_tol</td><td>We will need to check if some value (for example, the absolute value of Y's eigenvalues) is smaller than zero_tol. If it is, then we deem that value as 0. </td></tr>
    <tr><td class="paramname">return_empty_if_not_psd</td><td>If true, then return an empty matrix of size 0-by-Y.cols() if Y is not PSD (either the decomposition fails or the resulting eigenvalues are less that <code class="param">zero_tol</code>). If false (the default), then throw an exception if Y is not PSD. This option is particularly useful because it is brittle/expensive to test the exact success criteria before calling this function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">X.</td><td>The matrix X satisfies XᵀX = Y and X.rows() = rank(Y). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>1. Y is positive semidefinite or return_empty_if_not_psd = true.<ol type="1">
<li>zero_tol is non-negative. </li>
</ol>
</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>when the pre-conditions are not satisfied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>We only use the lower triangular part of Y. </dd></dl>

</div>
</div>
<a id="aca90af6719e970d4aeefa53d5a7854ae" name="aca90af6719e970d4aeefa53d5a7854ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca90af6719e970d4aeefa53d5a7854ae">&#9670;&#160;</a></span>DifferentiableNorm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Derived::Scalar DifferentiableNorm </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The 2-norm function |x| is not differentiable at x=0 (its gradient is x/|x|, which has a division-by-zero problem). </p>
<p>On the other hand, x=0 happens very often. Hence we return a subgradient x/(|x| + ε) when x is almost 0, and returns the original gradient, x/|x|, otherwise. </p>

</div>
</div>
<a id="aa6b853dffb7141874967340f9a18f4eb" name="aa6b853dffb7141874967340f9a18f4eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6b853dffb7141874967340f9a18f4eb">&#9670;&#160;</a></span>DiscardGradient()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) DiscardGradient </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><span class="tt">B = DiscardGradient(A)</span> enables casting from a matrix of AutoDiffScalars to AutoDiffScalar::Scalar type, explicitly throwing away any gradient information. </p>
<p>For a matrix of type, e.g. <span class="tt"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95" title="A matrix of dynamic size, templated on scalar type.">MatrixX</a>&lt;<a class="el" href="namespacedrake.html#a35725b277b02aeb79f24fd7f724e6dbc" title="An autodiff variable with a dynamic number of partials.">AutoDiffXd</a>&gt; A</span>, the comparable operation <span class="tt">B = A.cast&lt;double&gt;()</span> should (and does) fail to compile. Use <span class="tt">DiscardGradient(A)</span> if you want to force the cast (and explicitly declare that information is lost).</p>
<p>When called with a matrix that is already of type <span class="tt">double</span>, this function returns a <em>reference</em> to the argument without any copying. This efficiently avoids extra copying, but be careful about reference lifetimes!</p>
<p>See <a class="el" href="#a511506438ea2d8b648ef31f7957f118b" title="Extracts the value() portion from an AutoDiffScalar matrix into a pre-existing matrix (resizing if ne...">ExtractValue()</a> for a note on similar Drake functions.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a511506438ea2d8b648ef31f7957f118b" title="Extracts the value() portion from an AutoDiffScalar matrix into a pre-existing matrix (resizing if ne...">ExtractValue()</a>, <a class="el" href="#aa702a82946411f68e87bb6fb27cfdfa4" title="B = DiscardZeroGradient(A, precision) enables casting from a matrix of AutoDiffScalars to AutoDiffSca...">DiscardZeroGradient()</a> </dd></dl>

</div>
</div>
<a id="aa702a82946411f68e87bb6fb27cfdfa4" name="aa702a82946411f68e87bb6fb27cfdfa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa702a82946411f68e87bb6fb27cfdfa4">&#9670;&#160;</a></span>DiscardZeroGradient()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) DiscardZeroGradient </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>auto_diff_matrix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>precision</em></span><span class="paramdefsep"> = </span><span class="paramdefval">Eigen::NumTraits&lt;<a class="el" href="classdouble.html">double</a>&gt;::dummy_precision()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><span class="tt">B = DiscardZeroGradient(A, precision)</span> enables casting from a matrix of AutoDiffScalars to AutoDiffScalar::Scalar type, but first checking that the gradient matrix is empty or zero. </p>
<p>For a matrix of type, e.g. <span class="tt"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95" title="A matrix of dynamic size, templated on scalar type.">MatrixX</a>&lt;<a class="el" href="namespacedrake.html#a35725b277b02aeb79f24fd7f724e6dbc" title="An autodiff variable with a dynamic number of partials.">AutoDiffXd</a>&gt; A</span>, the comparable operation <span class="tt">B = A.cast&lt;double&gt;()</span> should (and does) fail to compile. Use <span class="tt">DiscardZeroGradient(A)</span> if you want to force the cast (and the check).</p>
<p>When called with a matrix that is already of type <span class="tt">double</span>, this function returns a <em>reference</em> to the argument without any copying. This efficiently avoids extra copying, but be careful about reference lifetimes!</p>
<p>See <a class="el" href="#a511506438ea2d8b648ef31f7957f118b" title="Extracts the value() portion from an AutoDiffScalar matrix into a pre-existing matrix (resizing if ne...">ExtractValue()</a> for a note on similar Drake functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">precision</td><td>is passed to Eigen's isZero(precision) to evaluate whether the gradients are zero. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the gradients were not empty nor zero. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#aa6b853dffb7141874967340f9a18f4eb" title="B = DiscardGradient(A) enables casting from a matrix of AutoDiffScalars to AutoDiffScalar::Scalar typ...">DiscardGradient()</a> </dd></dl>

</div>
</div>
<a id="afcef78b318bd0da2f388b83bc6fafa81" name="afcef78b318bd0da2f388b83bc6fafa81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcef78b318bd0da2f388b83bc6fafa81">&#9670;&#160;</a></span>DiscreteAlgebraicRiccatiEquation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd DiscreteAlgebraicRiccatiEquation </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>Q</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>R</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the unique stabilizing solution X to the discrete-time algebraic Riccati equation: </p>
<p>AᵀXA − X − AᵀXB(BᵀXB + R)⁻¹BᵀXA + Q = 0</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if Q is not symmetric positive semidefinite. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if R is not symmetric positive definite. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if (A, B) isn't a stabilizable pair. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if (A, C) isn't a detectable pair where Q = CᵀC. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6c67bf8aac3624a534979afd09689375" name="a6c67bf8aac3624a534979afd09689375"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c67bf8aac3624a534979afd09689375">&#9670;&#160;</a></span>DiscreteAlgebraicRiccatiEquation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd DiscreteAlgebraicRiccatiEquation </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>Q</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>R</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>N</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the unique stabilizing solution X to the discrete-time algebraic Riccati equation: </p>
<p>AᵀXA − X − (AᵀXB + N)(BᵀXB + R)⁻¹(BᵀXA + Nᵀ) + Q = 0</p>
<p>This is equivalent to solving the original DARE:</p>
<p>A₂ᵀXA₂ − X − A₂ᵀXB(BᵀXB + R)⁻¹BᵀXA₂ + Q₂ = 0</p>
<p>where A₂ and Q₂ are a change of variables:</p>
<p>A₂ = A − BR⁻¹Nᵀ and Q₂ = Q − NR⁻¹Nᵀ</p>
<p>This overload of the DARE is useful for finding the control law uₖ that minimizes the following cost function subject to xₖ₊₁ = Axₖ + Buₖ.</p>
<pre class="fragment">    ∞ [xₖ]ᵀ[Q  N][xₖ]
J = Σ [uₖ] [Nᵀ R][uₖ] ΔT
   k=0
</pre><p>This is a more general form of the following. The linear-quadratic regulator is the feedback control law uₖ that minimizes the following cost function subject to xₖ₊₁ = Axₖ + Buₖ:</p>
<pre class="fragment">    ∞
J = Σ (xₖᵀQxₖ + uₖᵀRuₖ) ΔT
   k=0
</pre><p>This can be refactored as:</p>
<pre class="fragment">    ∞ [xₖ]ᵀ[Q 0][xₖ]
J = Σ [uₖ] [0 R][uₖ] ΔT
   k=0
</pre><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if Q₂ is not symmetric positive semidefinite. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if R is not symmetric positive definite. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if (A₂, B) isn't a stabilizable pair. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if (A₂, C) isn't a detectable pair where Q₂ = CᵀC. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a133e7401303c1191fd2363fa630a5aeb" name="a133e7401303c1191fd2363fa630a5aeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a133e7401303c1191fd2363fa630a5aeb">&#9670;&#160;</a></span>dquat2rotmat()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdrake_1_1math_1_1_gradient.html">drake::math::Gradient</a>&lt; Eigen::Matrix&lt; typenameDerived::Scalar, 3, 3 &gt;, 4 &gt;::type dquat2rotmat </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>quaternion</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the gradient of the function that converts a unit length quaternion to a rotation matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">quaternion</td><td>A unit length quaternion [w;x;y;z] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The gradient </dd></dl>

</div>
</div>
<a id="afbb54825527e853ba8ea7ea1e8cf7ae3" name="afbb54825527e853ba8ea7ea1e8cf7ae3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbb54825527e853ba8ea7ea1e8cf7ae3">&#9670;&#160;</a></span>drotmat2quat()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedR, typename DerivedDR&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdrake_1_1math_1_1_gradient.html">drake::math::Gradient</a>&lt; Eigen::Matrix&lt; typenameDerivedR::Scalar, 4, 1 &gt;, DerivedDR::ColsAtCompileTime &gt;::type drotmat2quat </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedR &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>R</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedDR &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>dR</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the gradient of the function that converts rotation matrix to quaternion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">R</td><td>A 3 x 3 rotation matrix </td></tr>
    <tr><td class="paramname">dR</td><td>A 9 x N matrix, dR(i,j) is the gradient of R(i) w.r.t x_var(j) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The gradient G. G is a 4 x N matrix G(0,j) is the gradient of w w.r.t x_var(j) G(1,j) is the gradient of x w.r.t x_var(j) G(2,j) is the gradient of y w.r.t x_var(j) G(3,j) is the gradient of z w.r.t x_var(j) </dd></dl>

</div>
</div>
<a id="a86089488f24d9c440c6486292b1732e0" name="a86089488f24d9c440c6486292b1732e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86089488f24d9c440c6486292b1732e0">&#9670;&#160;</a></span>drotmat2rpy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedR, typename DerivedDR&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdrake_1_1math_1_1_gradient.html">drake::math::Gradient</a>&lt; Eigen::Matrix&lt; typenameDerivedR::Scalar, 3, 1 &gt;, DerivedDR::ColsAtCompileTime &gt;::type drotmat2rpy </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedR &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>R</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedDR &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>dR</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the gradient of the function that converts a rotation matrix to body-fixed z-y'-x'' Euler angles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">R</td><td>A 3 x 3 rotation matrix </td></tr>
    <tr><td class="paramname">dR</td><td>A 9 x N matrix, dR(i,j) is the gradient of R(i) w.r.t <a class="el" href="pixel__types_8h.html#a9336ebf25087d91c818ee6e9ec29f8c1">x(j)</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The gradient G. G is a 3 x N matrix. G(0,j) is the gradient of roll w.r.t <a class="el" href="pixel__types_8h.html#a9336ebf25087d91c818ee6e9ec29f8c1">x(j)</a> G(1,j) is the gradient of pitch w.r.t <a class="el" href="pixel__types_8h.html#a9336ebf25087d91c818ee6e9ec29f8c1">x(j)</a> G(2,j) is the gradient of yaw w.r.t <a class="el" href="pixel__types_8h.html#a9336ebf25087d91c818ee6e9ec29f8c1">x(j)</a> </dd></dl>

</div>
</div>
<a id="a6d14dacc3ba3d4cdacbf1936fe55c7f0" name="a6d14dacc3ba3d4cdacbf1936fe55c7f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d14dacc3ba3d4cdacbf1936fe55c7f0">&#9670;&#160;</a></span>EigenToStdVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &gt; EigenToStdVector </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>mat</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95" title="A matrix of dynamic size, templated on scalar type.">MatrixX&lt;T&gt;</a> into a std::vector&lt;MatrixX&lt;T&gt;&gt;, taking each column of the m-by-n matrix <span class="tt">mat</span> into an m-by-1 element of the returned std::vector. </p>

</div>
</div>
<a id="acdad302100e5da633d37a1a996d25acd" name="acdad302100e5da633d37a1a996d25acd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdad302100e5da633d37a1a996d25acd">&#9670;&#160;</a></span>ExtractGradient() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ExtractGradient </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>auto_diff_matrix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; int &gt;</td>          <td class="paramname"><span class="paramname"><em>num_derivatives</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; typename Derived::Scalar::Scalar, Derived::SizeAtCompileTime, Eigen::Dynamic &gt; *</td>          <td class="paramname"><span class="paramname"><em>gradient</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts the <span class="tt">derivatives()</span> portion from an AutoDiffScalar matrix into a pre-existing matrix (resizing if necessary). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">auto_diff_matrix</td><td>An object whose Eigen type represents a matrix of AutoDiffScalar entries. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_derivatives</td><td>The number of derivatives to return in case the input matrix has none, which we interpret as <span class="tt">num_derivatives</span> zeroes. If <span class="tt">num_derivatives</span> is supplied and the input matrix has derivatives, the sizes must match. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">gradient</td><td>An Eigen::Matrix resized if necessary to have rows equal to the total size (rows x cols) of the input matrix and number of columns equal to the number of derivatives. Each output row corresponds to one entry of the input matrix, using the input matrix storage order. For example, in the typical case of a ColMajor <span class="tt">auto_diff_matrix</span>, we have <span class="tt">auto_diff_matrix(r, c).derivatives() ==
    gradient_matrix.row(r + c * auto_diff_matrix.rows())</span>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Derived</td><td>An Eigen type representing a matrix with AutoDiffScalar entries. The type will be inferred from the type of the <span class="tt">auto_diff_matrix</span> parameter at the call site.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><span class="tt">gradient != nullptr</span>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the input matrix has elements with inconsistent, non-zero numbers of derivatives. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">num_derivatives</span> is specified but the input matrix has a different, non-zero number of derivatives. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afbd01251fe24c716eca07635c4861b7b" name="afbd01251fe24c716eca07635c4861b7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbd01251fe24c716eca07635c4861b7b">&#9670;&#160;</a></span>ExtractGradient() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt; typename Derived::Scalar::Scalar, Derived::SizeAtCompileTime, Eigen::Dynamic &gt; ExtractGradient </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>auto_diff_matrix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; int &gt;</td>          <td class="paramname"><span class="paramname"><em>num_derivatives</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the <span class="tt">derivatives()</span> portion from a matrix of AutoDiffScalar entries. </p>
<p>(Each entry contains a value and derivatives.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">auto_diff_matrix</td><td>An object whose Eigen type represents a matrix of AutoDiffScalar entries. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_derivatives</td><td>(Optional) The number of derivatives to return in case the input matrix has none, which we interpret as <span class="tt">num_derivatives</span> zeroes. If <span class="tt">num_derivatives</span> is supplied and the input matrix has derivatives, the sizes must match. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">gradient_matrix</td><td>An Eigen::Matrix with number of rows equal to the total size (rows x cols) of the input matrix and number of columns equal to the number of derivatives. Each output row corresponds to one entry of the input matrix, using the input matrix storage order. For example, in the typical case of a ColMajor <span class="tt">auto_diff_matrix</span>, we have <span class="tt">auto_diff_matrix(r, c).derivatives() ==
    gradient_matrix.row(r + c * auto_diff_matrix.rows())</span>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Derived</td><td>An Eigen type representing a matrix with AutoDiffScalar entries. The type will be inferred from the type of the <span class="tt">auto_diff_matrix</span> parameter at the call site.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the input matrix has elements with inconsistent, non-zero numbers of derivatives. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">num_derivatives</span> is specified but the input matrix has a different, non-zero number of derivatives. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa16b8b886b1a84d38cf5de14e0780df0" name="aa16b8b886b1a84d38cf5de14e0780df0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa16b8b886b1a84d38cf5de14e0780df0">&#9670;&#160;</a></span>ExtractPrincipalSubmatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; typename Derived::Scalar &gt; ExtractPrincipalSubmatrix </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>mat</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>indices</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts the principal submatrix from the ordered set of indices. </p>
<p>The indices must be in monotonically increasing order and non-empty. This method makes no assumptions about the symmetry of the matrix, nor that the matrix is square. However, all indices must be valid for both rows and columns. </p>

</div>
</div>
<a id="a483ac3b69e4ce09af0b0d977128ed769" name="a483ac3b69e4ce09af0b0d977128ed769"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a483ac3b69e4ce09af0b0d977128ed769">&#9670;&#160;</a></span>ExtractValue() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#aae413ce2f94f0ecb301727a6781b69ff">MatrixLikewise</a>&lt; typename Derived::Scalar::Scalar, Derived &gt; ExtractValue </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>auto_diff_matrix</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the <span class="tt">value()</span> portion from a matrix of AutoDiffScalar entries. </p>
<p>(Each entry contains a value and some derivatives.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">auto_diff_matrix</td><td>An object whose Eigen type represents a matrix of AutoDiffScalar entries. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">value</td><td>An Eigen::Matrix of the same dimensions as the input matrix, but containing only the value portion of each entry, without the derivatives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Derived</td><td>An Eigen type representing a matrix with AutoDiffScalar entries. The type will be inferred from the type of the <span class="tt">auto_diff_matrix</span> parameter at the call site.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Drake provides several similar functions: <a class="el" href="#aa6b853dffb7141874967340f9a18f4eb" title="B = DiscardGradient(A) enables casting from a matrix of AutoDiffScalars to AutoDiffScalar::Scalar typ...">DiscardGradient()</a> is specialized so that it can be applied to a <span class="tt">Matrix&lt;T&gt;</span> where T could be an AutoDiffScalar or an ordinary double, in which case it returns the original matrix at no cost. <a class="el" href="#aa702a82946411f68e87bb6fb27cfdfa4" title="B = DiscardZeroGradient(A, precision) enables casting from a matrix of AutoDiffScalars to AutoDiffSca...">DiscardZeroGradient()</a> is similar but requires that the discarded gradient was zero. <a class="el" href="namespacedrake.html#ad0da43c947d3694c1051212d4043d07e" title="Returns the autodiff scalar&#39;s value() as a double.">drake::ExtractDoubleOrThrow()</a> has many specializations, including one for <span class="tt">Matrix&lt;AutoDiffScalar&gt;</span> that behaves identically to <a class="el" href="#a511506438ea2d8b648ef31f7957f118b" title="Extracts the value() portion from an AutoDiffScalar matrix into a pre-existing matrix (resizing if ne...">ExtractValue()</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#aa6b853dffb7141874967340f9a18f4eb" title="B = DiscardGradient(A) enables casting from a matrix of AutoDiffScalars to AutoDiffScalar::Scalar typ...">DiscardGradient()</a>, <a class="el" href="namespacedrake.html#ad0da43c947d3694c1051212d4043d07e" title="Returns the autodiff scalar&#39;s value() as a double.">drake::ExtractDoubleOrThrow()</a> </dd></dl>

</div>
</div>
<a id="a511506438ea2d8b648ef31f7957f118b" name="a511506438ea2d8b648ef31f7957f118b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a511506438ea2d8b648ef31f7957f118b">&#9670;&#160;</a></span>ExtractValue() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ExtractValue </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>auto_diff_matrix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake.html#aae413ce2f94f0ecb301727a6781b69ff">MatrixLikewise</a>&lt; typename Derived::Scalar::Scalar, Derived &gt; *</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts the <span class="tt">value()</span> portion from an AutoDiffScalar matrix into a pre-existing matrix (resizing if necessary). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">auto_diff_matrix</td><td>An object whose Eigen type represents a matrix of AutoDiffScalar entries. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">value</td><td>An Eigen::Matrix resized if necessary to the same size as the input matrix, and copies only the value portion of each entry, without the derivatives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Derived</td><td>An Eigen type representing a matrix with AutoDiffScalar entries. The type will be inferred from the type of the <span class="tt">auto_diff_matrix</span> parameter at the call site. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><span class="tt">value != nullptr</span>. </dd></dl>

</div>
</div>
<a id="a2480fec6f9cfe246f8175e674d45341a" name="a2480fec6f9cfe246f8175e674d45341a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2480fec6f9cfe246f8175e674d45341a">&#9670;&#160;</a></span>GeneratePythonCsc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string GeneratePythonCsc </td>
          <td>(</td>
          <td class="paramtype">const Eigen::SparseMatrix&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>mat</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>name</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the python statement to construct scipy.sparse matrix. </p>
<p>The generated code will call sparse.csc_matrix() directly (please make sure you have imported the module through <span class="tt">from scipy import sparse</span>), and will end with a newline. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The Eigen matrix to be generated to python code. </td></tr>
    <tr><td class="paramname">name</td><td>The name of the python variable for the sparse matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the generated python code </dd></dl>

</div>
</div>
<a id="abff94f9cb54675e2c8979f98feb35324" name="abff94f9cb54675e2c8979f98feb35324"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abff94f9cb54675e2c8979f98feb35324">&#9670;&#160;</a></span>GetDerivativeSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!std::is_same_v&lt; typenameDerived::Scalar, <a class="el" href="classdouble.html">double</a> &gt;, int &gt;::type GetDerivativeSize </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a matrix of AutoDiffScalars, returns the size of the derivatives. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">runtime_error</td><td>if some entry has different (non-zero) number of derivatives as the others. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a081ebae497dce90eb2e360cb4cd2d689" name="a081ebae497dce90eb2e360cb4cd2d689"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a081ebae497dce90eb2e360cb4cd2d689">&#9670;&#160;</a></span>GetLinearSolver()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename, int... &gt; typename LinearSolverType, typename DerivedA&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">internal::EigenLinearSolver&lt; LinearSolverType, DerivedA &gt; GetLinearSolver </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedA &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the linear solver for a matrix A. </p>
<p>If A has scalar type of double or symbolic::Expressions, then the returned linear solver will have the same scalar type. If A has scalar type of Eigen::AutoDiffScalar, then the returned linear solver will have scalar type of double. See <a class="el" href="#get_linear_solver">get_linear_solver</a> for more details. </p>

</div>
</div>
<a id="a308bfb8a42ac830764e3e5420e5123f6" name="a308bfb8a42ac830764e3e5420e5123f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a308bfb8a42ac830764e3e5420e5123f6">&#9670;&#160;</a></span>getSubMatrixGradient() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int QSubvectorSize, typename Derived, std::size_t NRows, std::size_t NCols&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdrake_1_1math_1_1_get_sub_matrix_gradient_array.html">GetSubMatrixGradientArray</a>&lt; QSubvectorSize, Derived, NRows, NCols &gt;::type getSubMatrixGradient </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>dM</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; int, NRows &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rows</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; int, NCols &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>cols</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Derived::Index</td>          <td class="paramname"><span class="paramname"><em>M_rows</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>q_start</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Derived::Index</td>          <td class="paramname"><span class="paramname"><em>q_subvector_size</em></span><span class="paramdefsep"> = </span><span class="paramdefval">QSubvectorSize</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a050ed765d82aab33969de2bd54ac49e2" name="a050ed765d82aab33969de2bd54ac49e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a050ed765d82aab33969de2bd54ac49e2">&#9670;&#160;</a></span>getSubMatrixGradient() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt; typename Derived::Scalar, Eigen::Dynamic, Eigen::Dynamic &gt; getSubMatrixGradient </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>dM</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rows</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>cols</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Derived::Index</td>          <td class="paramname"><span class="paramname"><em>M_rows</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>q_start</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Derived::Index</td>          <td class="paramname"><span class="paramname"><em>q_subvector_size</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3e880bbd06a798425a0fea851038109d" name="a3e880bbd06a798425a0fea851038109d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e880bbd06a798425a0fea851038109d">&#9670;&#160;</a></span>getSubMatrixGradient() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int QSubvectorSize, typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdrake_1_1math_1_1_get_sub_matrix_gradient_single_element.html">GetSubMatrixGradientSingleElement</a>&lt; QSubvectorSize, Derived &gt;::type getSubMatrixGradient </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>dM</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Derived::Index</td>          <td class="paramname"><span class="paramname"><em>M_rows</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Derived::Index</td>          <td class="paramname"><span class="paramname"><em>q_start</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Derived::Index</td>          <td class="paramname"><span class="paramname"><em>q_subvector_size</em></span><span class="paramdefsep"> = </span><span class="paramdefval">QSubvectorSize</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9b836de6a2619d82ebb7793a920e7b67" name="a9b836de6a2619d82ebb7793a920e7b67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b836de6a2619d82ebb7793a920e7b67">&#9670;&#160;</a></span>GrayCodeToInteger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GrayCodeToInteger </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXi &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>gray_code</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the Gray code to an integer. </p>
<p>For example (0, 0) -&gt; 0 (0, 1) -&gt; 1 (1, 1) -&gt; 2 (1, 0) -&gt; 3 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gray_code</td><td>The N-digit Gray code, where N is gray_code.rows() </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The integer represented by the Gray code <span class="tt">gray_code</span>. </dd></dl>

</div>
</div>
<a id="a26812991a25e8108bd02304887bbcaf0" name="a26812991a25e8108bd02304887bbcaf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26812991a25e8108bd02304887bbcaf0">&#9670;&#160;</a></span>hessian()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int MaxChunkSizeOuter = 10, int MaxChunkSizeInner = 10, class F, class Arg&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) hessian </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Arg &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a matrix of AutoDiffScalars from which the value, Jacobian, and Hessian of a function. </p>
<p class="formulaDsp">
\[f:\mathbb{R}^{n\times m}\rightarrow\mathbb{R}^{p\times q}
\]
</p>
<p> (f: R^n*m -&gt; R^p*q) can be extracted.</p>
<p>The output is a matrix of nested AutoDiffScalars, being the result of calling <a class="el" href="#aed93d1c159660c20f44eefa5a0dad107" title="Computes a matrix of AutoDiffScalars from which both the value and the Jacobian of a function.">jacobian</a> on a function that returns the output of <a class="el" href="#aed93d1c159660c20f44eefa5a0dad107" title="Computes a matrix of AutoDiffScalars from which both the value and the Jacobian of a function.">jacobian</a>, called on <code class="param">f</code>.</p>
<p><code class="param">MaxChunkSizeOuter</code> and <code class="param">MaxChunkSizeInner</code> can be used to control chunk sizes (see <a class="el" href="#aed93d1c159660c20f44eefa5a0dad107" title="Computes a matrix of AutoDiffScalars from which both the value and the Jacobian of a function.">jacobian</a>).</p>
<p>See <a class="el" href="#aed93d1c159660c20f44eefa5a0dad107" title="Computes a matrix of AutoDiffScalars from which both the value and the Jacobian of a function.">jacobian</a> for requirements on the function <code class="param">f</code> and the argument <code class="param">x</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>function </td></tr>
    <tr><td class="paramname">x</td><td>function argument value at which Hessian will be evaluated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AutoDiffScalar matrix corresponding to the Hessian of f evaluated at x </dd></dl>

</div>
</div>
<a id="a72586b90f00c2e690c2ab071e6585f60" name="a72586b90f00c2e690c2ab071e6585f60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72586b90f00c2e690c2ab071e6585f60">&#9670;&#160;</a></span>HopfCoordinateToQuaternion()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const Eigen::Quaternion&lt; T &gt; HopfCoordinateToQuaternion </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>theta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>phi</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>psi</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transforms Hopf coordinates to a quaternion w, x, y, z as w = cos(θ/2)cos(ψ/2) x = cos(θ/2)sin(ψ/2) y = sin(θ/2)cos(φ+ψ/2) z = sin(θ/2)sin(φ+ψ/2) The user can refer to equation 5 of Generating Uniform Incremental Grids on SO(3) Using the Hopf Fibration by Anna Yershova, Steven LaValle and Julie Mitchell, 2008. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">theta</td><td>The θ angle. </td></tr>
    <tr><td class="paramname">phi</td><td>The φ angle. </td></tr>
    <tr><td class="paramname">psi</td><td>The ψ angle. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1fa7a3cb7b521d7f9c9973c5052f27c6" name="a1fa7a3cb7b521d7f9c9973c5052f27c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fa7a3cb7b521d7f9c9973c5052f27c6">&#9670;&#160;</a></span>InitializeAutoDiff() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived, typename DerivedAutoDiff&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void InitializeAutoDiff </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixBase&lt; DerivedAutoDiff &gt; *</td>          <td class="paramname"><span class="paramname"><em>auto_diff_matrix</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alternate signature provides default values for the number of derivatives (dynamic, determined at run time) and the starting index (0). </p>

</div>
</div>
<a id="a41b52d9aa2a46f7d783f20b12085d9ab" name="a41b52d9aa2a46f7d783f20b12085d9ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41b52d9aa2a46f7d783f20b12085d9ab">&#9670;&#160;</a></span>InitializeAutoDiff() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived, typename DerivedAutoDiff&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void InitializeAutoDiff </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; int &gt;</td>          <td class="paramname"><span class="paramname"><em>num_derivatives</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; int &gt;</td>          <td class="paramname"><span class="paramname"><em>deriv_num_start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixBase&lt; DerivedAutoDiff &gt; *</td>          <td class="paramname"><span class="paramname"><em>auto_diff_matrix</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a single AutoDiff matrix given the corresponding value matrix. </p>
<p>Sets the values of <span class="tt">auto_diff_matrix</span> (after resizing if necessary) to be equal to <span class="tt">value</span>, and for each element i of <span class="tt">auto_diff_matrix</span>, resizes the derivatives vector to <span class="tt">num_derivatives</span> and sets derivative number <span class="tt">deriv_num_start</span> + i to one (all other elements of the derivative vector set to zero).</p>
<p>When <span class="tt">value</span> and <span class="tt">auto_diff_matrix</span> are matrices (rather than just vectors) note in particular that the derivative numbers count up using the <em>storage order</em> of <span class="tt">value(i)</span> and <span class="tt">autodiff_matrix(i)</span> and so the ColMajor vs RowMajor storage order of the two must match.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>a 'regular' matrix of values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_derivatives</td><td>(Optional) size of the derivatives vector <br  />
 <em class="arg">Default:</em> total size of the value matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">deriv_num_start</td><td>(Optional) starting index into derivative vector (i.e. element deriv_num_start in derivative vector corresponds to value(0, 0)). <br  />
 <em class="arg">Default:</em> 0 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">auto_diff_matrix</td><td>AutoDiff matrix set as described above </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a72b0b18a66ef46995b64fa1d3945317b" name="a72b0b18a66ef46995b64fa1d3945317b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72b0b18a66ef46995b64fa1d3945317b">&#9670;&#160;</a></span>InitializeAutoDiff() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int nq = Eigen::Dynamic, typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a25ae6f07da9dbbdc55d02c5749c6a5b3">AutoDiffMatrixType</a>&lt; Derived, nq &gt; InitializeAutoDiff </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; int &gt;</td>          <td class="paramname"><span class="paramname"><em>num_derivatives</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; int &gt;</td>          <td class="paramname"><span class="paramname"><em>deriv_num_start</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a single AutoDiff matrix given the corresponding value matrix. </p>
<p>Creates an AutoDiff matrix that matches <span class="tt">value</span> in size with derivative of compile time size <span class="tt">nq</span> and runtime size <span class="tt">num_derivatives</span>. Sets its values to be equal to <span class="tt">value</span>, and for each element i of <span class="tt">auto_diff_matrix</span>, sets derivative number <span class="tt">deriv_num_start</span> + i to one (all other derivatives set to zero).</p>
<p>When <span class="tt">value</span> is a matrix (rather than just a vector) note in particular that the return value will use the same storage order (ColMajor vs RowMajor) and that the derivative numbers count up using the <em>storage order</em> of <span class="tt">value(i)</span>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>'regular' matrix of values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_derivatives</td><td>(Optional) size of the derivatives vector <br  />
 <em class="arg">Default:</em> total size of the value matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">deriv_num_start</td><td>(Optional) starting index into derivative vector (i.e. element deriv_num_start in derivative vector corresponds to matrix(0, 0)). <br  />
 <em class="arg">Default:</em> 0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">auto_diff_matrix</td><td>The result as described above. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a00bfe0f878b9f318900d47dd81e6e308" name="a00bfe0f878b9f318900d47dd81e6e308"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00bfe0f878b9f318900d47dd81e6e308">&#9670;&#160;</a></span>InitializeAutoDiff() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedValue, typename DerivedGradient&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a25ae6f07da9dbbdc55d02c5749c6a5b3">AutoDiffMatrixType</a>&lt; DerivedValue, DerivedGradient::ColsAtCompileTime &gt; InitializeAutoDiff </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedValue &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedGradient &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>gradient</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an AutoDiff matrix given a matrix of values and a gradient matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value matrix. Will be accessed with a single index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gradient</td><td>The gradient matrix. The number of rows must match the total size (nrow x ncol) of the value matrix. Derivatives of value(j) should be stored in row j of the gradient matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">auto_diff_matrix</td><td>The matrix of AutoDiffScalars. Will have the same dimensions and storage order as the value matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab9edc6655caed8198f72f998d6612223" name="ab9edc6655caed8198f72f998d6612223"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9edc6655caed8198f72f998d6612223">&#9670;&#160;</a></span>InitializeAutoDiff() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedValue, typename DerivedGradient, typename DerivedAutoDiff&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void InitializeAutoDiff </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedValue &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedGradient &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>gradient</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixBase&lt; DerivedAutoDiff &gt; *</td>          <td class="paramname"><span class="paramname"><em>auto_diff_matrix</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes an AutoDiff matrix given a matrix of values and a gradient matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value matrix. Will be accessed with a single index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gradient</td><td>The gradient matrix. The number of rows must match the total size (nrow x ncol) of the value matrix. Derivatives of value(j) should be stored in row j of the gradient matrix. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">auto_diff_matrix</td><td>The matrix of AutoDiffScalars. Will be resized as needed to have the same dimensions as the value matrix. Must have the same storage order as <span class="tt">value</span>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a75e80609d562cf17809fba18f9f68e30" name="a75e80609d562cf17809fba18f9f68e30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75e80609d562cf17809fba18f9f68e30">&#9670;&#160;</a></span>InitializeAutoDiffTuple()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Deriveds&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto InitializeAutoDiffTuple </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Deriveds &gt; &amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a series of Eigen matrices, creates a tuple of corresponding AutoDiff matrices with values equal to the input matrices and properly initialized derivative vectors. </p>
<p>The size of the derivative vector of each element of the matrices in the output tuple will be the same, and will equal the sum of the number of elements of the matrices in <span class="tt">args</span>. If all of the matrices in <span class="tt">args</span> have fixed size, then the derivative vectors will also have fixed size (being the sum of the sizes at compile time of all of the input arguments), otherwise the derivative vectors will have dynamic size. The 0th element of the derivative vectors will correspond to the derivative with respect to the 0th element of the first argument. Subsequent derivative vector elements correspond first to subsequent elements of the first input argument (traversed in the same order as <a class="el" href="#a41b52d9aa2a46f7d783f20b12085d9ab" title="Initializes a single AutoDiff matrix given the corresponding value matrix.">InitializeAutoDiff()</a> for that matrix), and so on for subsequent arguments.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>a series of Eigen matrices </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a tuple of properly initialized AutoDiff matrices corresponding to <span class="tt">args</span> </dd></dl>

</div>
</div>
<a id="a214ceb8aa2e730b212e0b345f8199727" name="a214ceb8aa2e730b212e0b345f8199727"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a214ceb8aa2e730b212e0b345f8199727">&#9670;&#160;</a></span>intRange()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Size&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; int, Size &gt; intRange </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>start</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a01008fbb23900d05b27e2d9ed5d3ec31" name="a01008fbb23900d05b27e2d9ed5d3ec31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01008fbb23900d05b27e2d9ed5d3ec31">&#9670;&#160;</a></span>is_quaternion_in_canonical_form()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; T &gt; is_quaternion_in_canonical_form </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Quaternion&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>quat</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function tests whether a quaternion is in "canonical form" meaning that it tests whether the quaternion [w, x, y, z] has a non-negative w value. </p>
<p>Example: [-0.3, +0.4, +0.5, +0.707] is not in canonical form. Example: [+0.3, -0.4, -0.5, -0.707] is in canonical form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">quat</td><td><a class="el" href="namespacedrake.html#a4156bf453a5b323356d7cc784dfdf084" title="A quaternion templated on scalar type.">Quaternion</a> [w, x, y, z] that relates two right-handed orthogonal unitary bases e.g., Ax, Ay, Az (A) to Bx, By, Bz (B). Note: quat is analogous to the rotation matrix R_AB. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><span class="tt">true</span> if quat.w() is nonnegative (in canonical form), else <span class="tt">false</span>. </dd></dl>

</div>
</div>
<a id="afd85f4c3652dc019638f54fba0fe5337" name="afd85f4c3652dc019638f54fba0fe5337"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd85f4c3652dc019638f54fba0fe5337">&#9670;&#160;</a></span>IsBothQuaternionAndQuaternionDtOK()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; T &gt; IsBothQuaternionAndQuaternionDtOK </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Quaternion&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>quat</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#af7e96394aef85f13f3fc84d3c3c238b3">Vector4</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>quatDt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>tolerance</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function tests if a quaternion satisfies the time-derivative constraint specified in [Kane, 1983] Section 1.13, equation 13, page 59. </p>
<p>A quaternion [w, x, y, z] must satisfy w^2 + x^2 + y^2 + z^2 = 1, hence its time-derivative must satisfy 2*(w*ẇ + x*ẋ + y*ẏ + z*ż) = 0. Note: To accurately test whether the time-derivative quaternion constraint is satisfied, the quaternion constraint is also tested to be accurate.</p>
<ul>
<li>[Kane, 1983] "Spacecraft Dynamics," McGraw-Hill Book Co., New York, 1983. (with P. W. Likins and D. A. Levinson). Available for free .pdf download: <a href="https://ecommons.cornell.edu/handle/1813/637">https://ecommons.cornell.edu/handle/1813/637</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">quat</td><td><a class="el" href="namespacedrake.html#a4156bf453a5b323356d7cc784dfdf084" title="A quaternion templated on scalar type.">Quaternion</a> [w, x, y, z] that relates two right-handed orthogonal unitary bases e.g., Ax, Ay, Az (A) to Bx, By, Bz (B). Note: A quaternion like quat_AB is analogous to the rotation matrix R_AB. </td></tr>
    <tr><td class="paramname">quatDt</td><td>Time-derivative of <span class="tt">quat</span>, i.e., [ẇ, ẋ, ẏ, ż]. </td></tr>
    <tr><td class="paramname">tolerance</td><td>Tolerance for quaternion constraints. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><span class="tt">true</span> if both of the two previous constraints are within tolerance. </dd></dl>

</div>
</div>
<a id="a84bae8f78403884f4f5fa7ecd41a8846" name="a84bae8f78403884f4f5fa7ecd41a8846"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84bae8f78403884f4f5fa7ecd41a8846">&#9670;&#160;</a></span>IsPositiveDefinite()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool IsPositiveDefinite </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>eigenvalue_tolerance</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>symmetry_tolerance</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a matrix is symmetric (with tolerance <code class="param">symmetry_tolerance</code> &ndash; see IsSymmetric) and has all eigenvalues greater than <code class="param">eigenvalue_tolerance</code>. </p>
<p><code class="param">eigenvalue_tolerance</code> must be &gt;= 0 &ndash; where 0 implies positive semi-definite (but is of course subject to all of the pitfalls of floating point).</p>
<p>To consider the numerical robustness of the eigenvalue estimation, we specifically check that min_eigenvalue &gt;= eigenvalue_tolerance * max(1,
max_abs_eigenvalue). </p>

</div>
</div>
<a id="a8291c72eca9f98dfd2486c5c09f11fe5" name="a8291c72eca9f98dfd2486c5c09f11fe5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8291c72eca9f98dfd2486c5c09f11fe5">&#9670;&#160;</a></span>IsQuaternionAndQuaternionDtEqualAngularVelocityExpressedInB()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool IsQuaternionAndQuaternionDtEqualAngularVelocityExpressedInB </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Quaternion&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>quat</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#af7e96394aef85f13f3fc84d3c3c238b3">Vector4</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>quatDt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>w_B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>tolerance</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function tests if a quaternion and a quaternion's time derivative can calculate and match an angular velocity to within a tolerance. </p>
<p>Note: This function first tests if the quaternion [w, x, y, z] satisfies w^2 + x^2 + y^2 + z^2 = 1 (to within tolerance) and if its time-derivative satisfies w*ẇ + x*ẋ + y*ẏ + z*ż = 0 (to within tolerance). Lastly, it tests if each element of the angular velocity calculated from quat and quatDt is within tolerance of w_B (described below). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">quat</td><td><a class="el" href="namespacedrake.html#a4156bf453a5b323356d7cc784dfdf084" title="A quaternion templated on scalar type.">Quaternion</a> [w, x, y, z] that relates two right-handed orthogonal unitary bases e.g., Ax, Ay, Az (A) to Bx, By, Bz (B). Note: A quaternion like quat_AB is analogous to the rotation matrix R_AB. </td></tr>
    <tr><td class="paramname">quatDt</td><td>Time-derivative of <span class="tt">quat</span>, i.e., [ẇ, ẋ, ẏ, ż]. </td></tr>
    <tr><td class="paramname">w_B</td><td>Rigid body B's angular velocity in frame A, expressed in B. </td></tr>
    <tr><td class="paramname">tolerance</td><td>Tolerance for quaternion constraints. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><span class="tt">true</span> if all three of the previous constraints are within tolerance. </dd></dl>

</div>
</div>
<a id="af9716f3d842206c012fe04b4545dc2bc" name="af9716f3d842206c012fe04b4545dc2bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9716f3d842206c012fe04b4545dc2bc">&#9670;&#160;</a></span>IsQuaternionValid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; T &gt; IsQuaternionValid </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Quaternion&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>quat</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>tolerance</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function tests if a quaternion satisfies the quaternion constraint specified in [Kane, 1983] Section 1.3, equation 4, page 12, i.e., a quaternion [w, x, y, z] must satisfy: w^2 + x^2 + y^2 + z^2 = 1. </p>
<ul>
<li>[Kane, 1983] "Spacecraft Dynamics," McGraw-Hill Book Co., New York, 1983. (with P. W. Likins and D. A. Levinson). Available for free .pdf download: <a href="https://ecommons.cornell.edu/handle/1813/637">https://ecommons.cornell.edu/handle/1813/637</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">quat</td><td><a class="el" href="namespacedrake.html#a4156bf453a5b323356d7cc784dfdf084" title="A quaternion templated on scalar type.">Quaternion</a> [w, x, y, z] that relates two right-handed orthogonal unitary bases e.g., Ax, Ay, Az (A) to Bx, By, Bz (B). Note: A quaternion like quat_AB is analogous to the rotation matrix R_AB. </td></tr>
    <tr><td class="paramname">tolerance</td><td>Tolerance for quaternion constraint, i.e., how much is w^2 + x^2 + y^2 + z^2 allowed to differ from 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><span class="tt">true</span> if the quaternion constraint is satisfied within tolerance. </dd></dl>

</div>
</div>
<a id="a8a6136c699d2e25f7515e8404cb65d79" name="a8a6136c699d2e25f7515e8404cb65d79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a6136c699d2e25f7515e8404cb65d79">&#9670;&#160;</a></span>IsSymmetric() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool IsSymmetric </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if a matrix is symmetric. </p>
<p>If std::equal_to&lt;&gt;()(matrix(i, j), matrix(j, i)) is true for all i, j, then the matrix is symmetric. </p>

</div>
</div>
<a id="a40335d2906e39ebe2a114f1cb6cf5d26" name="a40335d2906e39ebe2a114f1cb6cf5d26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40335d2906e39ebe2a114f1cb6cf5d26">&#9670;&#160;</a></span>IsSymmetric() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool IsSymmetric </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Derived::Scalar &amp;</td>          <td class="paramname"><span class="paramname"><em>precision</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if a matrix is symmetric based on whether the difference between matrix(i, j) and matrix(j, i) is smaller than <code class="param">precision</code> for all i, j. </p>
<p>The precision is absolute. Matrix with nan or inf entries is not allowed. </p>

</div>
</div>
<a id="aed93d1c159660c20f44eefa5a0dad107" name="aed93d1c159660c20f44eefa5a0dad107"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed93d1c159660c20f44eefa5a0dad107">&#9670;&#160;</a></span>jacobian()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int MaxChunkSize = 10, class F, class Arg&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) jacobian </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Arg &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a matrix of AutoDiffScalars from which both the value and the Jacobian of a function. </p>
<p class="formulaDsp">
\[f:\mathbb{R}^{n\times m}\rightarrow\mathbb{R}^{p\times q}
\]
</p>
<p> (f: R^n*m -&gt; R^p*q) can be extracted.</p>
<p>The derivative vector for each AutoDiffScalar in the output contains the derivatives with respect to all components of the argument \( x \).</p>
<p>The return type of this function is a matrix with the 'best' possible AutoDiffScalar scalar type, in the following sense:</p><ul>
<li>If the number of derivatives can be determined at compile time, the AutoDiffScalar derivative vector will have that fixed size.</li>
<li>If the maximum number of derivatives can be determined at compile time, the AutoDiffScalar derivative vector will have that maximum fixed size.</li>
<li>If neither the number, nor the maximum number of derivatives can be determined at compile time, the output AutoDiffScalar derivative vector will be dynamically sized.</li>
</ul>
<p><code class="param">f</code> should have a templated call operator that maps an Eigen matrix argument to another Eigen matrix. The scalar type of the output of \( f \) need not match the scalar type of the input (useful in recursive calls to the function to determine higher order derivatives). The easiest way to create an <code class="param">f</code> is using a C++14 generic lambda.</p>
<p>The algorithm computes the Jacobian in chunks of up to <code class="param">MaxChunkSize</code> derivatives at a time. This has three purposes:</p><ul>
<li>It makes it so that derivative vectors can be allocated on the stack, eliminating dynamic allocations and improving performance if the maximum number of derivatives cannot be determined at compile time.</li>
<li>It gives control over, and limits the number of required instantiations of the call operator of f and all the functions it calls.</li>
<li>Excessively large derivative vectors can result in CPU capacity cache misses; even if the number of derivatives is fixed at compile time, it may be better to break up into chunks if that means that capacity cache misses can be prevented.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>function </td></tr>
    <tr><td class="paramname">x</td><td>function argument value at which Jacobian will be evaluated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AutoDiffScalar matrix corresponding to the Jacobian of f evaluated at x. </dd></dl>

</div>
</div>
<a id="a62e57ade46ad4ef8cd2de2fa38986ac3" name="a62e57ade46ad4ef8cd2de2fa38986ac3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62e57ade46ad4ef8cd2de2fa38986ac3">&#9670;&#160;</a></span>matGradMult()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedDA, typename DerivedB&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdrake_1_1math_1_1_mat_grad_mult.html">MatGradMult</a>&lt; DerivedDA, DerivedB &gt;::type matGradMult </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedDA &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>dA</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedB &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab27fe675e0248787ceda453ff874915d" name="ab27fe675e0248787ceda453ff874915d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab27fe675e0248787ceda453ff874915d">&#9670;&#160;</a></span>matGradMultMat()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedA, typename DerivedB, typename DerivedDA, typename DerivedDB&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdrake_1_1math_1_1_mat_grad_mult_mat.html">MatGradMultMat</a>&lt; DerivedA, DerivedB, DerivedDA &gt;::type matGradMultMat </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedA &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedB &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedDA &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>dA</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedDB &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>dB</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa61c168d24baf12435cdc8b98a61c6a4" name="aa61c168d24baf12435cdc8b98a61c6a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa61c168d24baf12435cdc8b98a61c6a4">&#9670;&#160;</a></span>NormalizeVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void NormalizeVector </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Derived::PlainObject &amp;</td>          <td class="paramname"><span class="paramname"><em>x_norm</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structdrake_1_1math_1_1_gradient.html">drake::math::Gradient</a>&lt; Derived, Derived::RowsAtCompileTime, 1 &gt;::type *</td>          <td class="paramname"><span class="paramname"><em>dx_norm</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structdrake_1_1math_1_1_gradient.html">drake::math::Gradient</a>&lt; Derived, Derived::RowsAtCompileTime, 2 &gt;::type *</td>          <td class="paramname"><span class="paramname"><em>ddx_norm</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the normalized vector, optionally with its gradient and second derivative. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>An N x 1 vector to be normalized. Must not be zero. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">x_norm</td><td>The normalized vector (N x 1). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dx_norm</td><td>If non-null, returned as an N x N matrix, where dx_norm(i,j) = D x_norm(i)/D <a class="el" href="pixel__types_8h.html#a9336ebf25087d91c818ee6e9ec29f8c1">x(j)</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ddx_norm</td><td>If non-null, and dx_norm is non-null, returned as an N^2 x N matrix, where ddx_norm.col(j) = D dx_norm/D <a class="el" href="pixel__types_8h.html#a9336ebf25087d91c818ee6e9ec29f8c1">x(j)</a>, with dx_norm stacked columnwise.</td></tr>
  </table>
  </dd>
</dl>
<p>(D x / D y above means partial derivative of x with respect to y.) </p>

</div>
</div>
<a id="ad3e63a93f6a6d0e85c95da1ce7ee776d" name="ad3e63a93f6a6d0e85c95da1ce7ee776d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3e63a93f6a6d0e85c95da1ce7ee776d">&#9670;&#160;</a></span>ProjectMatToRotMatWithAxis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> ProjectMatToRotMatWithAxis </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix3d &amp;</td>          <td class="paramname"><span class="paramname"><em>M</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3d &amp;</td>          <td class="paramname"><span class="paramname"><em>axis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>angle_lb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>angle_ub</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Projects an approximate 3 x 3 rotation matrix M onto an orthonormal matrix R so that R is a rotation matrix associated with a angle-axis rotation by an angle θ about a vector direction <span class="tt">axis</span>, with <span class="tt">angle_lb &lt;= θ &lt;= angle_ub</span>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>the matrix to be projected. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axis</td><td>vector direction associated with angle-axis rotation for R. axis can be a non-unit vector, but cannot be the zero vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">angle_lb</td><td>the lower bound of the rotation angle θ. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">angle_ub</td><td>the upper bound of the rotation angle θ. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Rotation angle θ of the projected matrix, angle_lb &lt;= θ &lt;= angle_ub </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if axis is the zero vector or if angle_lb &gt; angle_ub. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method is useful for reconstructing a rotation matrix for a revolute joint with joint limits. </dd>
<dd>
This can be formulated as an optimization problem <pre>
  min_θ trace((R - M)ᵀ*(R - M))
  subject to R = I + sinθ * A + (1 - cosθ) * A²   (1)
             angle_lb &lt;= θ &lt;= angle_ub
</pre> where A is the cross product matrix of a = axis / axis.norm() = [a₁, a₂, a₃] <pre>
A = [ 0  -a₃  a₂]
    [ a₃  0  -a₁]
    [-a₂  a₁  0 ]
</pre> Equation (1) is the Rodriguez Formula that computes the rotation matrix R from the angle-axis rotation with angle θ and vector direction <span class="tt">axis</span>. For details, see <a href="http://mathworld.wolfram.com/RodriguesRotationFormula.html">http://mathworld.wolfram.com/RodriguesRotationFormula.html</a> The objective function can be simplified as <pre>
   max_θ trace(Rᵀ * M + Mᵀ * R)
</pre> By substituting the matrix <span class="tt">R</span> with the angle-axis representation, the optimization problem is formulated as <pre>
   max_θ sinθ * trace(Aᵀ*M) - cosθ * trace(Mᵀ * A²)
   subject to angle_lb &lt;= θ &lt;= angle_ub
</pre> By introducing α = atan2(-trace(Mᵀ * A²), trace(Aᵀ*M)), we can compute the optimal θ as <pre>
   θ = π/2 + 2kπ - α, if angle_lb &lt;= π/2 + 2kπ - α &lt;= angle_ub, k ∈ integers
else
   θ = angle_lb, if sin(angle_lb + α) &gt;= sin(angle_ub + α)
   θ = angle_ub, if sin(angle_lb + α) &lt;  sin(angle_ub + α)
</pre> </dd></dl>
<dl class="section see"><dt>See also</dt><dd>GlobalInverseKinematics for an usage of this function. </dd></dl>

</div>
</div>
<a id="ae503a800803f4c8e12dafac65d466517" name="ae503a800803f4c8e12dafac65d466517"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae503a800803f4c8e12dafac65d466517">&#9670;&#160;</a></span>quatConjugate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#af7e96394aef85f13f3fc84d3c3c238b3">Vector4</a>&lt; typename Derived::Scalar &gt; quatConjugate </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>q</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae3952e0b94673dab087b71aae0fe4264" name="ae3952e0b94673dab087b71aae0fe4264"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3952e0b94673dab087b71aae0fe4264">&#9670;&#160;</a></span>quatDiff()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived1, typename Derived2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#af7e96394aef85f13f3fc84d3c3c238b3">Vector4</a>&lt; typename Derived1::Scalar &gt; quatDiff </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived1 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>q1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>q2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8adec15eca22f51e09e025f5a6ff9171" name="a8adec15eca22f51e09e025f5a6ff9171"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8adec15eca22f51e09e025f5a6ff9171">&#9670;&#160;</a></span>quatDiffAxisInvar()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived1, typename Derived2, typename DerivedU&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Derived1::Scalar quatDiffAxisInvar </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived1 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>q1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>q2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedU &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aad5d8f41be198f8763008d964f9d596b" name="aad5d8f41be198f8763008d964f9d596b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad5d8f41be198f8763008d964f9d596b">&#9670;&#160;</a></span>QuaternionToCanonicalForm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Quaternion&lt; T &gt; QuaternionToCanonicalForm </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Quaternion&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>quat</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns a quaternion in its "canonical form" meaning that it returns a quaternion [w, x, y, z] with a non-negative w. </p>
<p>For example, if passed a quaternion [-0.3, +0.4, +0.5, +0.707], the function returns the quaternion's canonical form [+0.3, -0.4, -0.5, -0.707]. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">quat</td><td><a class="el" href="namespacedrake.html#a4156bf453a5b323356d7cc784dfdf084" title="A quaternion templated on scalar type.">Quaternion</a> [w, x, y, z] that relates two right-handed orthogonal unitary bases e.g., Ax, Ay, Az (A) to Bx, By, Bz (B). Note: quat is analogous to the rotation matrix R_AB. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Canonical form of quat, which means that either the original quat is returned or a quaternion representing the same orientation but with negated [w, x, y, z], to ensure a positive w in returned quaternion. </dd></dl>

</div>
</div>
<a id="add4e7be6e81ac1866c95b80bc8f48719" name="add4e7be6e81ac1866c95b80bc8f48719"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add4e7be6e81ac1866c95b80bc8f48719">&#9670;&#160;</a></span>QuaternionToHopfCoordinate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; QuaternionToHopfCoordinate </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Quaternion&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>quaternion</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a unit-length quaternion (w, x, y, z) (with the requirement w &gt;= 0) to Hopf coordinate as ψ = 2*atan2(x, w) φ = mod(atan2(z, y) - ψ/2, 2pi) θ = 2*atan2(√(y²+z²), √(w²+x²)) ψ is in the range of [-pi, pi]. </p>
<p>φ is in the range of [0, 2pi]. θ is in the range of [0, pi]. If the given quaternion has w &lt; 0, then we reverse the signs of (w, x, y, z), and compute the Hopf coordinate of (-w, -x, -y, -z). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">quaternion</td><td>A unit length quaternion. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>hopf_coordinate (θ, φ, ψ) as an Eigen vector. </dd></dl>

</div>
</div>
<a id="ab733c30c771e3930286e004dcf7174c0" name="ab733c30c771e3930286e004dcf7174c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab733c30c771e3930286e004dcf7174c0">&#9670;&#160;</a></span>quatProduct()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived1, typename Derived2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#af7e96394aef85f13f3fc84d3c3c238b3">Vector4</a>&lt; typename Derived1::Scalar &gt; quatProduct </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived1 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>q1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>q2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a78031a9a3a9ede22a90564dd3297bab2" name="a78031a9a3a9ede22a90564dd3297bab2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78031a9a3a9ede22a90564dd3297bab2">&#9670;&#160;</a></span>quatRotateVec()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedQ, typename DerivedV&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; typename DerivedV::Scalar &gt; quatRotateVec </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedQ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>q</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a87898df1c0be39d4073b61d033390502" name="a87898df1c0be39d4073b61d033390502"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87898df1c0be39d4073b61d033390502">&#9670;&#160;</a></span>RealContinuousLyapunovEquation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd RealContinuousLyapunovEquation </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>Q</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A user defined real square matrix. </td></tr>
    <tr><td class="paramname">Q</td><td>A user defined real symmetric matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Q is a symmetric matrix.</dd></dl>
<p>Computes a unique solution X to the continuous Lyapunov equation: <span class="tt">AᵀX + XA +
Q = 0</span>, where A is real and square, and Q is real, symmetric and of equal size as A. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if A or Q are not square matrices or do not have the same size.</td></tr>
  </table>
  </dd>
</dl>
<p>Limitations: Given the Eigenvalues of A as λ₁, ..., λₙ, there exists a unique solution if and only if λᵢ + λ̅ⱼ ≠ 0 ∀ i,j, where λ̅ⱼ is the complex conjugate of λⱼ. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the solution is not unique.</td></tr>
  </table>
  </dd>
</dl>
<p>There are no further limitations on the eigenvalues of A. Further, if all λᵢ have negative real parts, and if Q is positive semi-definite, then X is also positive semi-definite [1]. Therefore, if one searches for a Lyapunov function V(z) = zᵀXz for the stable linear system ż = Az, then the solution of the Lyapunov Equation <span class="tt">AᵀX + XA + Q = 0</span> only returns a valid Lyapunov function if Q is positive semi-definite.</p>
<p>The implementation is based on SLICOT routine SB03MD [2]. Note the transformation Q = -C. The complexity of this routine is O(n³). If A is larger than 2-by-2, then a Schur factorization is performed. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if Schur factorization failed.</td></tr>
  </table>
  </dd>
</dl>
<p>A tolerance of ε is used to check if a double variable is equal to zero, where the default value for ε is 1e-10. It has been used to check (1) if λᵢ + λ̅ⱼ = 0, ∀ i,j; (2) if A is a 1-by-1 zero matrix; (3) if A's trace or determinant is 0 when A is a 2-by-2 matrix.</p>
<p>[1] Bartels, R.H. and G.W. Stewart, "Solution of the Matrix Equation AX + XB
= C," Comm. of the ACM, Vol. 15, No. 9, 1972.</p>
<p>[2] <a href="http://slicot.org/objects/software/shared/doc/SB03MD.html">http://slicot.org/objects/software/shared/doc/SB03MD.html</a> </p>

</div>
</div>
<a id="a1d907fb507b2003b9da9558489e48e44" name="a1d907fb507b2003b9da9558489e48e44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d907fb507b2003b9da9558489e48e44">&#9670;&#160;</a></span>RealDiscreteLyapunovEquation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd RealDiscreteLyapunovEquation </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>Q</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A user defined real square matrix. </td></tr>
    <tr><td class="paramname">Q</td><td>A user defined real symmetric matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Q is a symmetric matrix.</dd></dl>
<p>Computes the unique solution X to the discrete Lyapunov equation: <span class="tt">AᵀXA - X +
Q = 0</span>, where A is real and square, and Q is real, symmetric and of equal size as A. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if A or Q are not square matrices or do not have the same size.</td></tr>
  </table>
  </dd>
</dl>
<p>Limitations: Given the Eigenvalues of A as λ₁, ..., λₙ, there exists a unique solution if and only if λᵢ * λⱼ ≠ 1 ∀ i,j and λᵢ ≠ ±1, ∀ i [1]. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the solution is not unique.[3]</td></tr>
  </table>
  </dd>
</dl>
<p>There are no further limitations on the eigenvalues of A. Further, if |λᵢ|&lt;1, ∀ i, and if Q is positive semi-definite, then X is also positive semi-definite [2]. Therefore, if one searches for a Lyapunov function V(z) = zᵀXz for the stable linear system zₙ₊₁ = Azₙ, then the solution of the Lyapunov Equation <span class="tt">AᵀXA -
X + Q = 0</span> only returns a valid Lyapunov function if Q is positive semi-definite.</p>
<p>The implementation is based on SLICOT routine SB03MD [2]. Note the transformation Q = -C. The complexity of this routine is O(n³). If A is larger than 2-by-2, then a Schur factorization is performed. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if Schur factorization fails.</td></tr>
  </table>
  </dd>
</dl>
<p>A tolerance of ε is used to check if a double variable is equal to zero, where the default value for ε is 1e-10. It has been used to check (1) if λᵢ = ±1 ∀ i; (2) if λᵢ * λⱼ = 1, i ≠ j.</p>
<p>[1] Barraud, A.Y., "A numerical algorithm to solve AᵀXA - X = Q," IEEE® Trans. Auto. Contr., AC-22, pp. 883-885, 1977.</p>
<p>[2] <a href="http://slicot.org/objects/software/shared/doc/SB03MD.html">http://slicot.org/objects/software/shared/doc/SB03MD.html</a></p>
<p>[3] <a href="https://www.mathworks.com/help/control/ref/dlyap.html">https://www.mathworks.com/help/control/ref/dlyap.html</a> </p>

</div>
</div>
<a id="a8fa4d6793feb307a2df5ac3f5b5319e9" name="a8fa4d6793feb307a2df5ac3f5b5319e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fa4d6793feb307a2df5ac3f5b5319e9">&#9670;&#160;</a></span>setSubMatrixGradient() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int QSubvectorSize, typename DerivedA, typename DerivedB, std::size_t NRows, std::size_t NCols&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void setSubMatrixGradient </td>
          <td>(</td>
          <td class="paramtype">Eigen::MatrixBase&lt; DerivedA &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>dM</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedB &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>dM_submatrix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; int, NRows &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rows</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; int, NCols &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>cols</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename DerivedA::Index</td>          <td class="paramname"><span class="paramname"><em>M_rows</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename DerivedA::Index</td>          <td class="paramname"><span class="paramname"><em>q_start</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename DerivedA::Index</td>          <td class="paramname"><span class="paramname"><em>q_subvector_size</em></span><span class="paramdefsep"> = </span><span class="paramdefval">QSubvectorSize</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab96376257045e5897019d7ced6537a0a" name="ab96376257045e5897019d7ced6537a0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab96376257045e5897019d7ced6537a0a">&#9670;&#160;</a></span>setSubMatrixGradient() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedA, typename DerivedB&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void setSubMatrixGradient </td>
          <td>(</td>
          <td class="paramtype">Eigen::MatrixBase&lt; DerivedA &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>dM</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedB &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>dM_submatrix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rows</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>cols</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename DerivedA::Index</td>          <td class="paramname"><span class="paramname"><em>M_rows</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename DerivedA::Index</td>          <td class="paramname"><span class="paramname"><em>q_start</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename DerivedA::Index</td>          <td class="paramname"><span class="paramname"><em>q_subvector_size</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a429d2d817112b0e4db22f5309f36f60f" name="a429d2d817112b0e4db22f5309f36f60f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a429d2d817112b0e4db22f5309f36f60f">&#9670;&#160;</a></span>setSubMatrixGradient() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int QSubvectorSize, typename DerivedDM, typename DerivedDMSub&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void setSubMatrixGradient </td>
          <td>(</td>
          <td class="paramtype">Eigen::MatrixBase&lt; DerivedDM &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>dM</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedDMSub &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>dM_submatrix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename DerivedDM::Index</td>          <td class="paramname"><span class="paramname"><em>M_rows</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename DerivedDM::Index</td>          <td class="paramname"><span class="paramname"><em>q_start</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename DerivedDM::Index</td>          <td class="paramname"><span class="paramname"><em>q_subvector_size</em></span><span class="paramdefsep"> = </span><span class="paramdefval">QSubvectorSize</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a758d64dc7109ce2b49d24d1736e2ceb4" name="a758d64dc7109ce2b49d24d1736e2ceb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a758d64dc7109ce2b49d24d1736e2ceb4">&#9670;&#160;</a></span>SoftOverMax()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T SoftOverMax </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>alpha</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1.0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes a smooth over approximation of max function, namely SoftOverMax(x) &gt;= max(x). </p>
<p>Mathematically we compute this as (log (∑ᵢ exp(αxᵢ))) / α. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The vector for which we want to compute its soft max. </td></tr>
    <tr><td class="paramname">alpha</td><td>α in the documentation above. Larger α makes the soft max more similar to max, with a sharper corner. Must be strictly positive and finite. <br  />
 <em class="arg">Default:</em> is 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if α &lt;= 0. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if α is non-finite. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The scalar type, which must be one of the <a class="el" href="group__default__scalars.html">default nonsymbolic scalars</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3c50f7950de875492fd065f398cc8a83" name="a3c50f7950de875492fd065f398cc8a83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c50f7950de875492fd065f398cc8a83">&#9670;&#160;</a></span>SoftOverMin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T SoftOverMin </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>alpha</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1.0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes a smooth over approximation of min function, namely SoftOverMin(x) &gt;= min(x). </p>
<p>Mathematically we compute this as ∑ᵢ exp(-αxᵢ)*xᵢ / d, where d = ∑ⱼ exp(-αxⱼ) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The vector for which we want to compute its soft min. </td></tr>
    <tr><td class="paramname">alpha</td><td>α in the documentation above. Larger α makes the soft min more similar to min, with a sharper corner. Must be strictly positive and finite. <br  />
 <em class="arg">Default:</em> is 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if α &lt;= 0. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if α is non-finite. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The scalar type, which must be one of the <a class="el" href="group__default__scalars.html">default nonsymbolic scalars</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a85a1342c2e810987226bdc34fe974ad0" name="a85a1342c2e810987226bdc34fe974ad0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85a1342c2e810987226bdc34fe974ad0">&#9670;&#160;</a></span>SoftUnderMax()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T SoftUnderMax </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>alpha</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1.0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes a smooth under approximation of max function, namely SoftUnderMax(x) &lt;= max(x). </p>
<p>Mathematically we compute this as ∑ᵢ exp(αxᵢ)*xᵢ / d, where d = ∑ⱼ exp(αxⱼ) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The vector for which we want to compute its soft max. </td></tr>
    <tr><td class="paramname">alpha</td><td>α in the documentation above. Larger α makes the soft max more similar to max, with a sharper corner. Must be strictly positive and finite. <br  />
 <em class="arg">Default:</em> is 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if α &lt;= 0. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if α is non-finite. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The scalar type, which must be one of the <a class="el" href="group__default__scalars.html">default nonsymbolic scalars</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a63f9d06b6c78d0ee60a095cd5d84e9aa" name="a63f9d06b6c78d0ee60a095cd5d84e9aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63f9d06b6c78d0ee60a095cd5d84e9aa">&#9670;&#160;</a></span>SoftUnderMin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T SoftUnderMin </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>alpha</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1.0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes a smooth under approximation of min function, namely SoftUnderMin(x) &lt;= min(x). </p>
<p>Mathematically we compute this as -(log (∑ᵢ exp(-αxᵢ))) / α </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The vector for which we want to compute its soft min. </td></tr>
    <tr><td class="paramname">alpha</td><td>α in the documentation above. Larger α makes the soft min more similar to min, with a sharper corner. Must be strictly positive and finite. <br  />
 <em class="arg">Default:</em> is 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if α &lt;= 0. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if α is non-finite. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The scalar type, which must be one of the <a class="el" href="group__default__scalars.html">default nonsymbolic scalars</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a457f738539d660aec84e6fb0b6a93e93" name="a457f738539d660aec84e6fb0b6a93e93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a457f738539d660aec84e6fb0b6a93e93">&#9670;&#160;</a></span>SolveLinearSystem() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename, int... &gt; typename LinearSolverType, typename DerivedA, typename DerivedB&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">internal::Solution&lt; DerivedA, DerivedB &gt; SolveLinearSystem </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedA &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedB &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solves system A*x=b. </p>
<p>The supported combinations of scalar types are summarized in the table above. See <a class="el" href="#linear_solve">linear_solve</a> for more details. </p>

</div>
</div>
<a id="a1f488e5d6f5e6d74ff2e0909c4223044" name="a1f488e5d6f5e6d74ff2e0909c4223044"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f488e5d6f5e6d74ff2e0909c4223044">&#9670;&#160;</a></span>SolveLinearSystem() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classdrake_1_1math_1_1_linear_solver.html">LinearSolver</a>, typename DerivedA, typename DerivedB&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; internal::is_double_or_symbolic_v&lt; typenameDerivedA::Scalar &gt; &amp;&amp;internal::is_double_or_symbolic_v&lt; typenameDerivedB::Scalar &gt; &amp;&amp;std::is_same_v&lt; typenameDerivedA::Scalar, typenameDerivedB::Scalar &gt;, Eigen::Matrix&lt; typenameDerivedA::Scalar, DerivedA::RowsAtCompileTime, DerivedB::ColsAtCompileTime &gt; &gt;::type SolveLinearSystem </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_linear_solver.html">LinearSolver</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>linear_solver</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedA &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedB &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specialized when A and b are both double or <a class="el" href="classdrake_1_1symbolic_1_1_expression.html" title="Represents a symbolic form of an expression.">symbolic::Expression</a> matrices. </p>
<p>See <a class="el" href="#linear_solve_given_solver">linear_solve_given_solver</a> for more details. Note that <code class="param">A</code> is unused, as we already compute its factorization in <code class="param">linear_solver</code>. But we keep it here for consistency with the overloaded function, where A is a matrix of AutoDiffScalar. </p>

</div>
</div>
<a id="af1ad6cb210876e474e321b1ec677a5d0" name="af1ad6cb210876e474e321b1ec677a5d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1ad6cb210876e474e321b1ec677a5d0">&#9670;&#160;</a></span>SolveLinearSystem() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classdrake_1_1math_1_1_linear_solver.html">LinearSolver</a>, typename DerivedA, typename DerivedB&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same_v&lt; typenameDerivedA::Scalar, <a class="el" href="classdouble.html">double</a> &gt; &amp;&amp;internal::is_autodiff_v&lt; typenameDerivedB::Scalar &gt;, Eigen::Matrix&lt; typenameDerivedB::Scalar, DerivedA::RowsAtCompileTime, DerivedB::ColsAtCompileTime &gt; &gt;::type SolveLinearSystem </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_linear_solver.html">LinearSolver</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>linear_solver</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedA &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedB &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specialized when A is a double-valued matrix and b is an AutoDiffScalar-valued matrix. </p>
<p>See <a class="el" href="#linear_solve_given_solver">linear_solve_given_solver</a> for more details. Note that <code class="param">A</code> is unused, as we already compute its factorization in <code class="param">linear_solver</code>. But we keep it here for consistency with the overloaded function, where A is a matrix of AutoDiffScalar. </p>

</div>
</div>
<a id="abbb4dcfd26d9913b0225231b8095f8b1" name="abbb4dcfd26d9913b0225231b8095f8b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbb4dcfd26d9913b0225231b8095f8b1">&#9670;&#160;</a></span>SolveLinearSystem() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classdrake_1_1math_1_1_linear_solver.html">LinearSolver</a>, typename DerivedA, typename DerivedB&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; internal::is_autodiff_v&lt; typenameDerivedA::Scalar &gt;, Eigen::Matrix&lt; typenameDerivedA::Scalar, DerivedA::RowsAtCompileTime, DerivedB::ColsAtCompileTime &gt; &gt;::type SolveLinearSystem </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_linear_solver.html">LinearSolver</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>linear_solver</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedA &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedB &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specialized when A is an AutoDiffScalar-valued matrix, and b can contain either AutoDiffScalar or double. </p>
<p>See <a class="el" href="#linear_solve_given_solver">linear_solve_given_solver</a> for more details. </p>

</div>
</div>
<a id="afd0c5c28f11ef2554ec39cd29240c095" name="afd0c5c28f11ef2554ec39cd29240c095"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd0c5c28f11ef2554ec39cd29240c095">&#9670;&#160;</a></span>SolveLinearSystem() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classdrake_1_1math_1_1_linear_solver.html">LinearSolver</a>, typename DerivedB&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; internal::is_double_or_symbolic_v&lt; typenameLinearSolver::MatrixType::Scalar &gt; &amp;&amp;internal::is_double_or_symbolic_v&lt; typenameDerivedB::Scalar &gt; &amp;&amp;std::is_same_v&lt; typenameLinearSolver::MatrixType::Scalar, typenameDerivedB::Scalar &gt;, Eigen::Matrix&lt; typenameLinearSolver::MatrixType::Scalar, DerivedB::RowsAtCompileTime, DerivedB::ColsAtCompileTime &gt; &gt;::type SolveLinearSystem </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_linear_solver.html">LinearSolver</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>linear_solver</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedB &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specialized when the matrix in linear_solver and b are both double or <a class="el" href="classdrake_1_1symbolic_1_1_expression.html" title="Represents a symbolic form of an expression.">symbolic::Expression</a> matrices. </p>
<p>See <a class="el" href="#linear_solve_given_solver">linear_solve_given_solver</a> for more details. </p>

</div>
</div>
<a id="aa4477ffa8132ff57594302f13bab5380" name="aa4477ffa8132ff57594302f13bab5380"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4477ffa8132ff57594302f13bab5380">&#9670;&#160;</a></span>SolveLinearSystem() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classdrake_1_1math_1_1_linear_solver.html">LinearSolver</a>, typename DerivedB&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same_v&lt; typenameLinearSolver::MatrixType::Scalar, <a class="el" href="classdouble.html">double</a> &gt; &amp;&amp;internal::is_autodiff_v&lt; typenameDerivedB::Scalar &gt;, Eigen::Matrix&lt; typenameDerivedB::Scalar, DerivedB::RowsAtCompileTime, DerivedB::ColsAtCompileTime &gt; &gt;::type SolveLinearSystem </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_linear_solver.html">LinearSolver</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>linear_solver</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedB &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specialized the matrix in linear_solver is a double-valued matrix and b is an AutoDiffScalar-valued matrix. </p>
<p>See <a class="el" href="#linear_solve_given_solver">linear_solve_given_solver</a> for more details. </p>

</div>
</div>
<a id="a55e8440aa53d7db2a614142ae4e27941" name="a55e8440aa53d7db2a614142ae4e27941"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55e8440aa53d7db2a614142ae4e27941">&#9670;&#160;</a></span>SparseMatrixToRowColumnValueVectors()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SparseMatrixToRowColumnValueVectors </td>
          <td>(</td>
          <td class="paramtype">const Derived &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Eigen::Index &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>row_indices</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Eigen::Index &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>col_indices</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; typename Derived::Scalar &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>val</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For a sparse matrix, return the row indices, the column indices, and value of the non-zero entries. </p>
<p>For example, the matrix          </p><p class="formulaDsp">
\[mat = \begin{bmatrix} 1 &amp; 0 &amp; 2\\
                      0 &amp; 3 &amp; 4\end{bmatrix}
\]
</p>
<p> has     </p><p class="formulaDsp">
\[row = \begin{bmatrix} 0 &amp; 1 &amp; 0 &amp; 1\end{bmatrix}\\
col = \begin{bmatrix} 0 &amp; 1 &amp; 2 &amp; 2\end{bmatrix}\\
val = \begin{bmatrix} 1 &amp; 3 &amp; 2 &amp; 4\end{bmatrix}
\]
</p>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>the input sparse matrix </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">row_indices</td><td>a vector containing the row indices of the non-zero entries </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">col_indices</td><td>a vector containing the column indices of the non-zero entries </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">val</td><td>a vector containing the values of the non-zero entries. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad55de6b340513cdc1351d509dc9d99e6" name="ad55de6b340513cdc1351d509dc9d99e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad55de6b340513cdc1351d509dc9d99e6">&#9670;&#160;</a></span>SparseMatrixToTriplets()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar, int Options, typename StorageIndex&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Eigen::Triplet&lt; Scalar &gt; &gt; SparseMatrixToTriplets </td>
          <td>(</td>
          <td class="paramtype">const Eigen::SparseMatrix&lt; Scalar, Options, StorageIndex &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For a sparse matrix, return a vector of triplets, such that we can reconstruct the matrix using setFromTriplet function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>A sparse matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A triplet with the row, column and value of the non-zero entries. See <a href="https://eigen.tuxfamily.org/dox/group__TutorialSparse.html">https://eigen.tuxfamily.org/dox/group__TutorialSparse.html</a> for more information on the triplet </dd></dl>

</div>
</div>
<a id="a9cf7a17a246897182cc65ec080840999" name="a9cf7a17a246897182cc65ec080840999"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cf7a17a246897182cc65ec080840999">&#9670;&#160;</a></span>StdVectorToEigen()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; StdVectorToEigen </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vec</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a std::vector&lt;MatrixX&lt;T&gt;&gt; into a <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95" title="A matrix of dynamic size, templated on scalar type.">MatrixX&lt;T&gt;</a>, composing each element of <span class="tt">vec</span> into a column of the returned matrix. </p>
<dl class="section pre"><dt>Precondition</dt><dd>all elements of <span class="tt">vec</span> must have one column and the same number of rows. </dd></dl>

</div>
</div>
<a id="aa824bd31863a762bd2c1860534b7e39d" name="aa824bd31863a762bd2c1860534b7e39d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa824bd31863a762bd2c1860534b7e39d">&#9670;&#160;</a></span>ToLowerTriangularColumnsFromMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">drake::VectorX</a>&lt; typename Derived::Scalar &gt; ToLowerTriangularColumnsFromMatrix </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a square matrix, extract the lower triangular part as a stacked column vector. </p>
<p>This is a particularly useful operation when vectorizing symmetric matrices. </p>

</div>
</div>
<a id="ae4935d457d59fdb0a60b7f1d5cb465bb" name="ae4935d457d59fdb0a60b7f1d5cb465bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4935d457d59fdb0a60b7f1d5cb465bb">&#9670;&#160;</a></span>ToSymmetricMatrixFromLowerTriangularColumns() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">drake::MatrixX</a>&lt; typename Derived::Scalar &gt; ToSymmetricMatrixFromLowerTriangularColumns </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lower_triangular_columns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a column vector containing the stacked columns of the lower triangular part of a square matrix, returning a symmetric matrix whose lower triangular part is the same as the original matrix. </p>

</div>
</div>
<a id="a0b96f43056135e9ecb62b48421b787f9" name="a0b96f43056135e9ecb62b48421b787f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b96f43056135e9ecb62b48421b787f9">&#9670;&#160;</a></span>ToSymmetricMatrixFromLowerTriangularColumns() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rows, typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt; typename Derived::Scalar, rows, rows &gt; ToSymmetricMatrixFromLowerTriangularColumns </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lower_triangular_columns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a column vector containing the stacked columns of the lower triangular part of a square matrix, returning a symmetric matrix whose lower triangular part is the same as the original matrix. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">rows</td><td>The number of rows in the symmetric matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a94e7f89e2f4658e85200497129578c17" name="a94e7f89e2f4658e85200497129578c17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94e7f89e2f4658e85200497129578c17">&#9670;&#160;</a></span>transposeGrad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Derived::PlainObject transposeGrad </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>dX</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Derived::Index</td>          <td class="paramname"><span class="paramname"><em>rows_X</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a94c069b2cc98fccfed321d9dbe21ac7c" name="a94c069b2cc98fccfed321d9dbe21ac7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94c069b2cc98fccfed321d9dbe21ac7c">&#9670;&#160;</a></span>UniformlyRandomAngleAxis()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = double, class Generator = RandomGenerator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::AngleAxis&lt; T &gt; UniformlyRandomAngleAxis </td>
          <td>(</td>
          <td class="paramtype">Generator *</td>          <td class="paramname"><span class="paramname"><em>generator</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a rotation (in the axis-angle representation) that rotates a point on the unit sphere to another point on the unit sphere with a uniform distribution over the sphere. </p>

</div>
</div>
<a id="a8aa04e5739514a4418de72e3300a60ba" name="a8aa04e5739514a4418de72e3300a60ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aa04e5739514a4418de72e3300a60ba">&#9670;&#160;</a></span>UniformlyRandomQuaternion()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = double, class Generator = RandomGenerator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Quaternion&lt; T &gt; UniformlyRandomQuaternion </td>
          <td>(</td>
          <td class="paramtype">Generator *</td>          <td class="paramname"><span class="paramname"><em>generator</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a rotation (in the quaternion representation) that rotates a point on the unit sphere to another point on the unit sphere with a uniform distribution over the sphere. </p>
<p>This method is briefly explained in <a href="http://planning.cs.uiuc.edu/node198.html">http://planning.cs.uiuc.edu/node198.html</a>, a full explanation can be found in K. Shoemake. Uniform Random Rotations in D. Kirk, editor, Graphics Gems III, pages 124-132. Academic, New York, 1992. </p>

</div>
</div>
<a id="a99a6354b64c8945256e01ea4424ec30d" name="a99a6354b64c8945256e01ea4424ec30d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99a6354b64c8945256e01ea4424ec30d">&#9670;&#160;</a></span>UniformlyRandomRotationMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = double, class Generator = RandomGenerator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a>&lt; T &gt; UniformlyRandomRotationMatrix </td>
          <td>(</td>
          <td class="paramtype">Generator *</td>          <td class="paramname"><span class="paramname"><em>generator</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a rotation (in the rotation matrix representation) that rotates a point on the unit sphere to another point on the unit sphere with a uniform distribution over the sphere. </p>

</div>
</div>
<a id="a2d0dc847828b4e1ea981cc1d3425cd7d" name="a2d0dc847828b4e1ea981cc1d3425cd7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d0dc847828b4e1ea981cc1d3425cd7d">&#9670;&#160;</a></span>UniformlyRandomRPY()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = double, class Generator = RandomGenerator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; UniformlyRandomRPY </td>
          <td>(</td>
          <td class="paramtype">Generator *</td>          <td class="paramname"><span class="paramname"><em>generator</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a rotation (in the roll-pitch-yaw representation) that rotates a point on the unit sphere to another point on the unit sphere with a uniform distribution over the sphere. </p>

</div>
</div>
<a id="adba688f2a2db17563f2ef13e199816d9" name="adba688f2a2db17563f2ef13e199816d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adba688f2a2db17563f2ef13e199816d9">&#9670;&#160;</a></span>UniformPtsOnSphereFibonacci()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix3Xd UniformPtsOnSphereFibonacci </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num_points</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deterministically generates approximate evenly distributed points on a unit sphere. </p>
<p>This method uses Fibonacci number. For the detailed math, please refer to <a href="http://stackoverflow.com/questions/9600801/evenly-distributing-n-points-on-a-sphere">http://stackoverflow.com/questions/9600801/evenly-distributing-n-points-on-a-sphere</a> This algorithm generates the points in O(n) time, where <span class="tt">n</span> is the number of points. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_points</td><td>The number of points we want on the unit sphere. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The generated points. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>num_samples &gt;= 1. Throw std::exception if num_points &lt; 1 </dd></dl>

</div>
</div>
<a id="a788977a35ad438eaac0c38b2885813b6" name="a788977a35ad438eaac0c38b2885813b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a788977a35ad438eaac0c38b2885813b6">&#9670;&#160;</a></span>VectorToSkewSymmetric()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a3922cc0c6264e8ff225a6aa0dd993667">drake::Matrix3</a>&lt; typename Derived::Scalar &gt; VectorToSkewSymmetric </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abd938f3f72e2bc3a2509e83f5587aad3" name="abd938f3f72e2bc3a2509e83f5587aad3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd938f3f72e2bc3a2509e83f5587aad3">&#9670;&#160;</a></span>wrap_to()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T1 wrap_to </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;</td>          <td class="paramname"><span class="paramname"><em>low</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;</td>          <td class="paramname"><span class="paramname"><em>high</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For variables that are meant to be periodic, (e.g. </p>
<p>over a 2π interval), wraps <span class="tt">value</span> into the interval <span class="tt">[low, high)</span>. Precisely, <span class="tt">wrap_to</span> returns: value + k*(high-low) for the unique integer value <span class="tt">k</span> that lands the output in the desired interval. <code class="param">low</code> and <code class="param">high</code> must be finite, and low &lt; high. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- footer -->
<div class="navpath">
  <ul>
    <li class="navelem"><a href="namespacedrake.html">drake</a></li><li class="navelem"><a href="namespacedrake_1_1math.html">math</a></li>
  </ul>
</div>
<footer id="nav-path", class="site-footer padding">
  <div class="contain">
    <a href="/" class="drake-logo">
      <img src="/images/drake-logo.svg"/>
    </a>
    <div class="footer-menu">
      <ul>    
        <li>
          <a href="/doxygen_cxx/index.html" class="site-menu-item">C++</a>
        </li>    
        <li>
          <a href="/pydrake/index.html" class="site-menu-item">Python</a>
        </li>
        <li class="github-link">
          <a href="https://github.com/RobotLocomotion/drake" class="site-menu-item">GitHub <img src="/third_party/images/GitHub-Mark-64px.png"/></a>
        </li>
      </ul>
    </div>
  </div>
</footer>
<script type="text/javascript">
searchBox.searchLabel = 'Go to name…';
searchBox.DOMSearchField().placeholder = searchBox.searchLabel;
searchBox.DOMSearchField().value = '';
</script>
</body>
</html>
