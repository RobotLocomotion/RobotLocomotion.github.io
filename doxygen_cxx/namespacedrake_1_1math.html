<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: drake::math Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<header class="site-header">
 <div class="site-header-inner contain">
  <a class="drake-logo" href="/"><img src="/images/drake-logo-white.svg"></a>
  <div class="menu-mobile-toggle">
   <span></span>
  </div>
  <nav class="site-menu">
   <ul>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/">Home</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/installation.html">Installation</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/gallery.html">Gallery</a>
    </li>
    <li class="site-menu-item site-menu-item-main">API Documentation
     <div class="sub">
      <a class="site-menu-item" href="https://drake.mit.edu/doxygen_cxx/index.html">C++</a>
      <a class="site-menu-item" href="https://drake.mit.edu/pydrake/index.html">Python</a>
     </div>
    </li>
    <li class="site-menu-item site-menu-item-main">Resources
     <div class="sub">
      <a class="site-menu-item" href="/getting_help.html">Getting Help</a>
      <a class="site-menu-item" href="https://github.com/RobotLocomotion/drake/tree/master/tutorials">Tutorials</a>
      <a class="site-menu-item" href="/python_bindings.html">Python Bindings</a>
      <a class="site-menu-item" href="/developers.html">For Developers</a>
      <a class="site-menu-item" href="/credits.html">Credits</a>
     </div>
    </li>
    <li class="github-link">
     <a class="site-menu-item" href="https://github.com/RobotLocomotion/drake">GitHub <img src="/third_party/images/GitHub-Mark-Light-64px.png"></a>
    </li>
   </ul>
  </nav>
 </div>
</header>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
<div class="title-banner">
 <div class="title-banner__title">
  Drake C++ Documentation
 </div>
 <div id="DDGSearch">
  <form id="ddg-search-form" class="wy_form" action="https://duckduckgo.com/" method="get">
   <input type="text" name="q" placeholder="Search C++ API only…">
   <input type="hidden" name="sites" value="drake.mit.edu/doxygen_cxx">
  </form>
  <form id="ddg-search-form" class="wy_form" action="https://duckduckgo.com/" method="get">
   <input type="text" name="q" placeholder="Search all of Drake…">
   <input type="hidden" name="sites" value="drake.mit.edu">
  </form>
 </div>
 <div id="MSearchBoxContainer">
          <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
 </div>
</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespacedrake_1_1math.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">drake::math Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_barycentric_mesh.html">BarycentricMesh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a multi-linear function (from vector inputs to vector outputs) by interpolating between points on a mesh using (triangular) barycentric interpolation.  <a href="classdrake_1_1math_1_1_barycentric_mesh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_bspline_basis.html">BsplineBasis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a set of non-descending breakpoints t₀ ≤ t₁ ≤ ⋅⋅⋅ ≤ tₘ, a B-spline basis of order k is a set of n + 1 (where n = m - k) piecewise polynomials of degree k - 1 defined over those breakpoints.  <a href="classdrake_1_1math_1_1_bspline_basis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1math_1_1_get_sub_matrix_gradient_array.html">GetSubMatrixGradientArray</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1math_1_1_get_sub_matrix_gradient_single_element.html">GetSubMatrixGradientSingleElement</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1math_1_1_gradient.html">Gradient</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively defined template specifying a matrix type of the correct size for a gradient of a matrix function with respect to <code>nq</code> variables, of any order.  <a href="structdrake_1_1math_1_1_gradient.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1math_1_1_gradient_3_01_derived_00_01nq_00_011_01_4.html">Gradient&lt; Derived, nq, 1 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base case for recursively defined gradient template.  <a href="structdrake_1_1math_1_1_gradient_3_01_derived_00_01nq_00_011_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1math_1_1_gray_codes_matrix.html">GrayCodesMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structdrake_1_1math_1_1_gray_codes_matrix.html#a83c3b24ce255b931f182e59775510cb1">GrayCodesMatrix::type</a> returns an Eigen matrix of integers.  <a href="structdrake_1_1math_1_1_gray_codes_matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>GrayCodesMatrix&lt; Eigen::Dynamic &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_linear_solver.html">LinearSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves a linear system of equations A*x=b.  <a href="classdrake_1_1math_1_1_linear_solver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1math_1_1_mat_grad_mult.html">MatGradMult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1math_1_1_mat_grad_mult_mat.html">MatGradMultMat</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_numerical_gradient_option.html">NumericalGradientOption</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a proper rigid transform between two frames which can be regarded in two ways.  <a href="classdrake_1_1math_1_1_rigid_transform.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_roll_pitch_yaw.html">RollPitchYaw</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents the orientation between two arbitrary frames A and D associated with a Space-fixed (extrinsic) X-Y-Z rotation by "roll-pitch-yaw" angles <code>[r, p, y]</code>, which is equivalent to a Body-fixed (intrinsic) Z-Y-X rotation by "yaw-pitch-roll" angles <code>[y, p, r]</code>.  <a href="classdrake_1_1math_1_1_roll_pitch_yaw.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a 3x3 rotation matrix between two arbitrary frames A and B and helps ensure users create valid rotation matrices.  <a href="classdrake_1_1math_1_1_rotation_matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:af0249a3cc715341eaf27380878eb1df9"><td class="memTemplParams" colspan="2">template&lt;typename Derived , int nq&gt; </td></tr>
<tr class="memitem:af0249a3cc715341eaf27380878eb1df9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#af0249a3cc715341eaf27380878eb1df9">AutoDiffMatrixType</a> = Eigen::Matrix&lt; Eigen::AutoDiffScalar&lt; Eigen::Matrix&lt; typename Derived::Scalar, nq, 1 &gt; &gt;, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime, 0, Derived::MaxRowsAtCompileTime, Derived::MaxColsAtCompileTime &gt;</td></tr>
<tr class="memdesc:af0249a3cc715341eaf27380878eb1df9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The appropriate AutoDiffScalar matrix type given the value type and the number of derivatives at compile time.  <a href="#af0249a3cc715341eaf27380878eb1df9">More...</a><br /></td></tr>
<tr class="separator:af0249a3cc715341eaf27380878eb1df9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a33f67c50b300b399043477a51861400a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a33f67c50b300b399043477a51861400a">NumericalGradientMethod</a> { <a class="el" href="namespacedrake_1_1math.html#a33f67c50b300b399043477a51861400aae7c3602dce09c755e09250077a601a51">kForward</a>, 
<a class="el" href="namespacedrake_1_1math.html#a33f67c50b300b399043477a51861400aa5cc7cc1518100eae9e3f2d83673a74ed">kBackward</a>, 
<a class="el" href="namespacedrake_1_1math.html#a33f67c50b300b399043477a51861400aa39209ccaab9620e08ec04483c22a7eda">kCentral</a>
 }</td></tr>
<tr class="separator:a33f67c50b300b399043477a51861400a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dc222f66e0f5092e8cfe879f24874b2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a2dc222f66e0f5092e8cfe879f24874b2">KnotVectorType</a> { <a class="el" href="namespacedrake_1_1math.html#a2dc222f66e0f5092e8cfe879f24874b2a3ea9f7aca87fd7b64469a0d1119f0b50">kUniform</a>, 
<a class="el" href="namespacedrake_1_1math.html#a2dc222f66e0f5092e8cfe879f24874b2af1b493f6e43ce0d1371533ee4f1199d0">kClampedUniform</a>
 }</td></tr>
<tr class="memdesc:a2dc222f66e0f5092e8cfe879f24874b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum representing types of knot vectors.  <a href="namespacedrake_1_1math.html#a2dc222f66e0f5092e8cfe879f24874b2">More...</a><br /></td></tr>
<tr class="separator:a2dc222f66e0f5092e8cfe879f24874b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:abb0cd738c70309748ff3cbc5c6b2d50e"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:abb0cd738c70309748ff3cbc5c6b2d50e"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename Derived::Scalar::Scalar, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#abb0cd738c70309748ff3cbc5c6b2d50e">ExtractValue</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;auto_diff_matrix)</td></tr>
<tr class="memdesc:abb0cd738c70309748ff3cbc5c6b2d50e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the <code>value()</code> portion from a matrix of AutoDiffScalar entries.  <a href="#abb0cd738c70309748ff3cbc5c6b2d50e">More...</a><br /></td></tr>
<tr class="separator:abb0cd738c70309748ff3cbc5c6b2d50e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdc21793a127ffbebcb28a2442123390"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:abdc21793a127ffbebcb28a2442123390"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; !std::is_same_v&lt; typename Derived::Scalar, double &gt;, Eigen::Matrix&lt; typename Derived::Scalar::Scalar, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime, 0, Derived::MaxRowsAtCompileTime, Derived::MaxColsAtCompileTime &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#abdc21793a127ffbebcb28a2442123390">DiscardGradient</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;auto_diff_matrix)</td></tr>
<tr class="memdesc:abdc21793a127ffbebcb28a2442123390"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>B = DiscardGradient(A)</code> enables casting from a matrix of AutoDiffScalars to AutoDiffScalar::Scalar type, explicitly throwing away any gradient information.  <a href="#abdc21793a127ffbebcb28a2442123390">More...</a><br /></td></tr>
<tr class="separator:abdc21793a127ffbebcb28a2442123390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04e58f14dcca01f3684a820cff4c61b0"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a04e58f14dcca01f3684a820cff4c61b0"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Derived::Scalar, double &gt;, const Eigen::MatrixBase&lt; Derived &gt; &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a04e58f14dcca01f3684a820cff4c61b0">DiscardGradient</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;matrix)</td></tr>
<tr class="separator:a04e58f14dcca01f3684a820cff4c61b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32942f788a67278f27426f128e50e0b2"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename DerivedAutoDiff &gt; </td></tr>
<tr class="memitem:a32942f788a67278f27426f128e50e0b2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a32942f788a67278f27426f128e50e0b2">InitializeAutoDiff</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;value, std::optional&lt; <a class="el" href="classint.html">int</a> &gt; num_derivatives, std::optional&lt; <a class="el" href="classint.html">int</a> &gt; deriv_num_start, Eigen::MatrixBase&lt; DerivedAutoDiff &gt; *auto_diff_matrix)</td></tr>
<tr class="memdesc:a32942f788a67278f27426f128e50e0b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a single AutoDiff matrix given the corresponding value matrix.  <a href="#a32942f788a67278f27426f128e50e0b2">More...</a><br /></td></tr>
<tr class="separator:a32942f788a67278f27426f128e50e0b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a563f68724c579b35cdaf62b72c056e5e"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename DerivedAutoDiff &gt; </td></tr>
<tr class="memitem:a563f68724c579b35cdaf62b72c056e5e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a563f68724c579b35cdaf62b72c056e5e">InitializeAutoDiff</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;value, Eigen::MatrixBase&lt; DerivedAutoDiff &gt; *auto_diff_matrix)</td></tr>
<tr class="memdesc:a563f68724c579b35cdaf62b72c056e5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate signature provides default values for the number of derivatives (dynamic, determined at run time) and the starting index (0).  <a href="#a563f68724c579b35cdaf62b72c056e5e">More...</a><br /></td></tr>
<tr class="separator:a563f68724c579b35cdaf62b72c056e5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e75abd55fa93ee21998756cf8c6e244"><td class="memTemplParams" colspan="2">template&lt;int nq = Eigen::Dynamic, typename Derived &gt; </td></tr>
<tr class="memitem:a3e75abd55fa93ee21998756cf8c6e244"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1math.html#af0249a3cc715341eaf27380878eb1df9">AutoDiffMatrixType</a>&lt; Derived, nq &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a3e75abd55fa93ee21998756cf8c6e244">InitializeAutoDiff</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;value, std::optional&lt; <a class="el" href="classint.html">int</a> &gt; num_derivatives={}, std::optional&lt; <a class="el" href="classint.html">int</a> &gt; deriv_num_start={})</td></tr>
<tr class="memdesc:a3e75abd55fa93ee21998756cf8c6e244"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a single AutoDiff matrix given the corresponding value matrix.  <a href="#a3e75abd55fa93ee21998756cf8c6e244">More...</a><br /></td></tr>
<tr class="separator:a3e75abd55fa93ee21998756cf8c6e244"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad148a2735129010d96646652ec1f4986"><td class="memTemplParams" colspan="2">template&lt;typename... Deriveds&gt; </td></tr>
<tr class="memitem:ad148a2735129010d96646652ec1f4986"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="namespacedrake_1_1math.html#af0249a3cc715341eaf27380878eb1df9">AutoDiffMatrixType</a>&lt; Deriveds, internal::total_size_at_compile_time&lt; Deriveds... &gt;)&gt;... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#ad148a2735129010d96646652ec1f4986">InitializeAutoDiffTuple</a> (const Eigen::MatrixBase&lt; Deriveds &gt; &amp;... args)</td></tr>
<tr class="separator:ad148a2735129010d96646652ec1f4986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a099a62886c181d6f9b917f0215a1a947"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a099a62886c181d6f9b917f0215a1a947"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename Derived::Scalar::Scalar, Derived::SizeAtCompileTime, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a099a62886c181d6f9b917f0215a1a947">ExtractGradient</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;auto_diff_matrix, std::optional&lt; <a class="el" href="classint.html">int</a> &gt; num_derivatives={})</td></tr>
<tr class="memdesc:a099a62886c181d6f9b917f0215a1a947"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the <code>derivatives()</code> portion from a matrix of AutoDiffScalar entries.  <a href="#a099a62886c181d6f9b917f0215a1a947">More...</a><br /></td></tr>
<tr class="separator:a099a62886c181d6f9b917f0215a1a947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac01d5aa7f58a485b614ddc46e7be7dd4"><td class="memTemplParams" colspan="2">template&lt;typename DerivedValue , typename DerivedGradient , typename DerivedAutoDiff &gt; </td></tr>
<tr class="memitem:ac01d5aa7f58a485b614ddc46e7be7dd4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#ac01d5aa7f58a485b614ddc46e7be7dd4">InitializeAutoDiff</a> (const Eigen::MatrixBase&lt; DerivedValue &gt; &amp;value, const Eigen::MatrixBase&lt; DerivedGradient &gt; &amp;gradient, Eigen::MatrixBase&lt; DerivedAutoDiff &gt; *auto_diff_matrix)</td></tr>
<tr class="memdesc:ac01d5aa7f58a485b614ddc46e7be7dd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes an AutoDiff matrix given a matrix of values and a gradient matrix.  <a href="#ac01d5aa7f58a485b614ddc46e7be7dd4">More...</a><br /></td></tr>
<tr class="separator:ac01d5aa7f58a485b614ddc46e7be7dd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af23c3981782540c98f8a1cb2abc59627"><td class="memTemplParams" colspan="2">template&lt;typename DerivedValue , typename DerivedGradient &gt; </td></tr>
<tr class="memitem:af23c3981782540c98f8a1cb2abc59627"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1math.html#af0249a3cc715341eaf27380878eb1df9">AutoDiffMatrixType</a>&lt; DerivedValue, DerivedGradient::ColsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#af23c3981782540c98f8a1cb2abc59627">InitializeAutoDiff</a> (const Eigen::MatrixBase&lt; DerivedValue &gt; &amp;value, const Eigen::MatrixBase&lt; DerivedGradient &gt; &amp;gradient)</td></tr>
<tr class="memdesc:af23c3981782540c98f8a1cb2abc59627"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an AutoDiff matrix given a matrix of values and a gradient matrix.  <a href="#af23c3981782540c98f8a1cb2abc59627">More...</a><br /></td></tr>
<tr class="separator:af23c3981782540c98f8a1cb2abc59627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ea20cd66ae96c7e1390e7ebb3e2f8a8"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a1ea20cd66ae96c7e1390e7ebb3e2f8a8"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; !std::is_same_v&lt; typename Derived::Scalar, double &gt;, Eigen::Matrix&lt; typename Derived::Scalar::Scalar, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime, 0, Derived::MaxRowsAtCompileTime, Derived::MaxColsAtCompileTime &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a1ea20cd66ae96c7e1390e7ebb3e2f8a8">DiscardZeroGradient</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;auto_diff_matrix, const typename Eigen::NumTraits&lt; typename Derived::Scalar::Scalar &gt;::Real &amp;precision=Eigen::NumTraits&lt; typename Derived::Scalar::Scalar &gt;::dummy_precision())</td></tr>
<tr class="memdesc:a1ea20cd66ae96c7e1390e7ebb3e2f8a8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>B = DiscardZeroGradient(A, precision)</code> enables casting from a matrix of AutoDiffScalars to AutoDiffScalar::Scalar type, but first checking that the gradient matrix is empty or zero.  <a href="#a1ea20cd66ae96c7e1390e7ebb3e2f8a8">More...</a><br /></td></tr>
<tr class="separator:a1ea20cd66ae96c7e1390e7ebb3e2f8a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f4c633cee6230932aa3be941609ebed"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a2f4c633cee6230932aa3be941609ebed"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Derived::Scalar, double &gt;, const Eigen::MatrixBase&lt; Derived &gt; &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a2f4c633cee6230932aa3be941609ebed">DiscardZeroGradient</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;matrix, double precision=0.)</td></tr>
<tr class="separator:a2f4c633cee6230932aa3be941609ebed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4360e58bcb10c6b20aa3e28fed7297fb"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a4360e58bcb10c6b20aa3e28fed7297fb"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!std::is_same_v&lt; typename Derived::Scalar, double &gt;, <a class="el" href="classint.html">int</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a4360e58bcb10c6b20aa3e28fed7297fb">GetDerivativeSize</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:a4360e58bcb10c6b20aa3e28fed7297fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a matrix of AutoDiffScalars, returns the size of the derivatives.  <a href="#a4360e58bcb10c6b20aa3e28fed7297fb">More...</a><br /></td></tr>
<tr class="separator:a4360e58bcb10c6b20aa3e28fed7297fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a480ac0ac10adfac21eab2d72f8694704"><td class="memTemplParams" colspan="2">template&lt;typename DerivedX , typename DerivedY , typename DerivedCalcX &gt; </td></tr>
<tr class="memitem:a480ac0ac10adfac21eab2d72f8694704"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename DerivedX::Scalar, DerivedY::RowsAtCompileTime, DerivedX::RowsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a480ac0ac10adfac21eab2d72f8694704">ComputeNumericalGradient</a> (std::function&lt; void(const DerivedCalcX &amp;, DerivedY *y)&gt; calc_fun, const DerivedX &amp;x, const <a class="el" href="classdrake_1_1math_1_1_numerical_gradient_option.html">NumericalGradientOption</a> &amp;option=<a class="el" href="classdrake_1_1math_1_1_numerical_gradient_option.html">NumericalGradientOption</a>{ <a class="el" href="namespacedrake_1_1math.html#a33f67c50b300b399043477a51861400aae7c3602dce09c755e09250077a601a51">NumericalGradientMethod::kForward</a>})</td></tr>
<tr class="memdesc:a480ac0ac10adfac21eab2d72f8694704"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the gradient of a function f(x) through numerical difference.  <a href="#a480ac0ac10adfac21eab2d72f8694704">More...</a><br /></td></tr>
<tr class="separator:a480ac0ac10adfac21eab2d72f8694704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a527ab4851f7449ff47374855c79b8413"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a527ab4851f7449ff47374855c79b8413">ContinuousAlgebraicRiccatiEquation</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;A, const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;B, const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;Q, const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;R)</td></tr>
<tr class="memdesc:a527ab4851f7449ff47374855c79b8413"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the unique stabilizing solution S to the continuous-time algebraic Riccati equation:  <a href="#a527ab4851f7449ff47374855c79b8413">More...</a><br /></td></tr>
<tr class="separator:a527ab4851f7449ff47374855c79b8413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44ee9a3e4b4fa7d4359e3b05af563979"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a44ee9a3e4b4fa7d4359e3b05af563979">ContinuousAlgebraicRiccatiEquation</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;A, const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;B, const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;Q, const Eigen::LLT&lt; Eigen::MatrixXd &gt; &amp;R_cholesky)</td></tr>
<tr class="memdesc:a44ee9a3e4b4fa7d4359e3b05af563979"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is functionally the same as ContinuousAlgebraicRiccatiEquation(A, B, Q, R).  <a href="#a44ee9a3e4b4fa7d4359e3b05af563979">More...</a><br /></td></tr>
<tr class="separator:a44ee9a3e4b4fa7d4359e3b05af563979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a781bfc30740843ad1203fa68b7497401"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a781bfc30740843ad1203fa68b7497401">RealContinuousLyapunovEquation</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;A, const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;Q)</td></tr>
<tr class="separator:a781bfc30740843ad1203fa68b7497401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ad7ab2561d0c05591eb9720adccc7d5"><td class="memTemplParams" colspan="2">template&lt;typename v_Type , typename DtB_v_Type , typename w_AB_Type &gt; </td></tr>
<tr class="memitem:a7ad7ab2561d0c05591eb9720adccc7d5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; typename v_Type::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a7ad7ab2561d0c05591eb9720adccc7d5">ConvertTimeDerivativeToOtherFrame</a> (const Eigen::MatrixBase&lt; v_Type &gt; &amp;v_E, const Eigen::MatrixBase&lt; DtB_v_Type &gt; &amp;DtB_v_E, const Eigen::MatrixBase&lt; w_AB_Type &gt; &amp;w_AB_E)</td></tr>
<tr class="memdesc:a7ad7ab2561d0c05591eb9720adccc7d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given ᴮd/dt(v) (the time derivative in frame B of an arbitrary 3D vector v) and given ᴬωᴮ (frame B's angular velocity in another frame A), this method computes ᴬd/dt(v) (the time derivative in frame A of v) by: ᴬd/dt(v) = ᴮd/dt(v) + ᴬωᴮ x v.  <a href="#a7ad7ab2561d0c05591eb9720adccc7d5">More...</a><br /></td></tr>
<tr class="separator:a7ad7ab2561d0c05591eb9720adccc7d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d78f6f294270fdc03dcb68de424536a"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a2d78f6f294270fdc03dcb68de424536a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a3922cc0c6264e8ff225a6aa0dd993667">drake::Matrix3</a>&lt; typename Derived::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a2d78f6f294270fdc03dcb68de424536a">VectorToSkewSymmetric</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;p)</td></tr>
<tr class="separator:a2d78f6f294270fdc03dcb68de424536a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae918eb0a5749b337a92058e92bd039c9"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:ae918eb0a5749b337a92058e92bd039c9"><td class="memTemplItemLeft" align="right" valign="top">Derived::Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#ae918eb0a5749b337a92058e92bd039c9">DifferentiableNorm</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;x)</td></tr>
<tr class="memdesc:ae918eb0a5749b337a92058e92bd039c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The 2-norm function |x| is not differentiable at x=0 (its gradient is x/|x|, which has a division-by-zero problem).  <a href="#ae918eb0a5749b337a92058e92bd039c9">More...</a><br /></td></tr>
<tr class="separator:ae918eb0a5749b337a92058e92bd039c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cd8a0787e886faf633f2c1f5be2365e"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a8cd8a0787e886faf633f2c1f5be2365e">DiscreteAlgebraicRiccatiEquation</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;A, const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;B, const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;Q, const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;R)</td></tr>
<tr class="memdesc:a8cd8a0787e886faf633f2c1f5be2365e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the unique stabilizing solution X to the discrete-time algebraic Riccati equation:  <a href="#a8cd8a0787e886faf633f2c1f5be2365e">More...</a><br /></td></tr>
<tr class="separator:a8cd8a0787e886faf633f2c1f5be2365e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa957c0c1b13e62f96ae84dd8abe45dd9"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#aa957c0c1b13e62f96ae84dd8abe45dd9">DiscreteAlgebraicRiccatiEquation</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;A, const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;B, const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;Q, const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;R, const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;N)</td></tr>
<tr class="memdesc:aa957c0c1b13e62f96ae84dd8abe45dd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the unique stabilizing solution X to the discrete-time algebraic Riccati equation:  <a href="#aa957c0c1b13e62f96ae84dd8abe45dd9">More...</a><br /></td></tr>
<tr class="separator:aa957c0c1b13e62f96ae84dd8abe45dd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41733a5b284046800224cd293e055ff7"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a41733a5b284046800224cd293e055ff7">RealDiscreteLyapunovEquation</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;A, const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;Q)</td></tr>
<tr class="separator:a41733a5b284046800224cd293e055ff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a731362436a359883cbac2c59abf95168"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , int Options, typename StorageIndex &gt; </td></tr>
<tr class="memitem:a731362436a359883cbac2c59abf95168"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Eigen::Triplet&lt; Scalar &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a731362436a359883cbac2c59abf95168">SparseMatrixToTriplets</a> (const Eigen::SparseMatrix&lt; Scalar, Options, StorageIndex &gt; &amp;matrix)</td></tr>
<tr class="memdesc:a731362436a359883cbac2c59abf95168"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a sparse matrix, return a vector of triplets, such that we can reconstruct the matrix using setFromTriplet function.  <a href="#a731362436a359883cbac2c59abf95168">More...</a><br /></td></tr>
<tr class="separator:a731362436a359883cbac2c59abf95168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9681555f84d48a48d09601d913246934"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a9681555f84d48a48d09601d913246934"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a9681555f84d48a48d09601d913246934">SparseMatrixToRowColumnValueVectors</a> (const Derived &amp;matrix, std::vector&lt; Eigen::Index &gt; &amp;row_indices, std::vector&lt; Eigen::Index &gt; &amp;col_indices, std::vector&lt; typename Derived::Scalar &gt; &amp;val)</td></tr>
<tr class="memdesc:a9681555f84d48a48d09601d913246934"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a sparse matrix, return the row indices, the column indices, and value of the non-zero entries.  <a href="#a9681555f84d48a48d09601d913246934">More...</a><br /></td></tr>
<tr class="separator:a9681555f84d48a48d09601d913246934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33baecb77517d26dcea8ab1fb880fcbe"><td class="memItemLeft" align="right" valign="top">Eigen::Matrix3Xd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a33baecb77517d26dcea8ab1fb880fcbe">UniformPtsOnSphereFibonacci</a> (<a class="el" href="classint.html">int</a> num_points)</td></tr>
<tr class="memdesc:a33baecb77517d26dcea8ab1fb880fcbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deterministically generates approximate evenly distributed points on a unit sphere.  <a href="#a33baecb77517d26dcea8ab1fb880fcbe">More...</a><br /></td></tr>
<tr class="separator:a33baecb77517d26dcea8ab1fb880fcbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eb0d39dab703d87f0f582cf310c6134"><td class="memTemplParams" colspan="2">template&lt;std::size_t Size&gt; </td></tr>
<tr class="memitem:a6eb0d39dab703d87f0f582cf310c6134"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; <a class="el" href="classint.html">int</a>, Size &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a6eb0d39dab703d87f0f582cf310c6134">intRange</a> (<a class="el" href="classint.html">int</a> start)</td></tr>
<tr class="separator:a6eb0d39dab703d87f0f582cf310c6134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20c21cde851510ab3ae5a7527ed62d22"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a20c21cde851510ab3ae5a7527ed62d22"><td class="memTemplItemLeft" align="right" valign="top">Derived::PlainObject&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a20c21cde851510ab3ae5a7527ed62d22">transposeGrad</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;dX, typename Derived::Index rows_X)</td></tr>
<tr class="separator:a20c21cde851510ab3ae5a7527ed62d22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41fb0200e4ab7c796576b2fe17408ec8"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA , typename DerivedB , typename DerivedDA , typename DerivedDB &gt; </td></tr>
<tr class="memitem:a41fb0200e4ab7c796576b2fe17408ec8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structdrake_1_1math_1_1_mat_grad_mult_mat.html">MatGradMultMat</a>&lt; DerivedA, DerivedB, DerivedDA &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a41fb0200e4ab7c796576b2fe17408ec8">matGradMultMat</a> (const Eigen::MatrixBase&lt; DerivedA &gt; &amp;A, const Eigen::MatrixBase&lt; DerivedB &gt; &amp;B, const Eigen::MatrixBase&lt; DerivedDA &gt; &amp;dA, const Eigen::MatrixBase&lt; DerivedDB &gt; &amp;dB)</td></tr>
<tr class="separator:a41fb0200e4ab7c796576b2fe17408ec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4805a6b4a327bedeb7793cd1ce11523c"><td class="memTemplParams" colspan="2">template&lt;typename DerivedDA , typename DerivedB &gt; </td></tr>
<tr class="memitem:a4805a6b4a327bedeb7793cd1ce11523c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structdrake_1_1math_1_1_mat_grad_mult.html">MatGradMult</a>&lt; DerivedDA, DerivedB &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a4805a6b4a327bedeb7793cd1ce11523c">matGradMult</a> (const Eigen::MatrixBase&lt; DerivedDA &gt; &amp;dA, const Eigen::MatrixBase&lt; DerivedB &gt; &amp;B)</td></tr>
<tr class="separator:a4805a6b4a327bedeb7793cd1ce11523c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c5269630d172b12a31b34d6c98b4e64"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a5c5269630d172b12a31b34d6c98b4e64"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename Derived::Scalar, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a5c5269630d172b12a31b34d6c98b4e64">getSubMatrixGradient</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;dM, const std::vector&lt; <a class="el" href="classint.html">int</a> &gt; &amp;rows, const std::vector&lt; <a class="el" href="classint.html">int</a> &gt; &amp;cols, typename Derived::Index M_rows, <a class="el" href="classint.html">int</a> q_start=0, typename Derived::Index q_subvector_size=-1)</td></tr>
<tr class="separator:a5c5269630d172b12a31b34d6c98b4e64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4b8fed3ad399a2bd53630c3b5b6d335"><td class="memTemplParams" colspan="2">template&lt;int QSubvectorSize, typename Derived , std::size_t NRows, std::size_t NCols&gt; </td></tr>
<tr class="memitem:ad4b8fed3ad399a2bd53630c3b5b6d335"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structdrake_1_1math_1_1_get_sub_matrix_gradient_array.html">GetSubMatrixGradientArray</a>&lt; QSubvectorSize, Derived, NRows, NCols &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#ad4b8fed3ad399a2bd53630c3b5b6d335">getSubMatrixGradient</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;dM, const std::array&lt; <a class="el" href="classint.html">int</a>, NRows &gt; &amp;rows, const std::array&lt; <a class="el" href="classint.html">int</a>, NCols &gt; &amp;cols, typename Derived::Index M_rows, <a class="el" href="classint.html">int</a> q_start=0, typename Derived::Index q_subvector_size=QSubvectorSize)</td></tr>
<tr class="separator:ad4b8fed3ad399a2bd53630c3b5b6d335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a259ed4f41a444e8eed6a2a30998af53f"><td class="memTemplParams" colspan="2">template&lt;int QSubvectorSize, typename Derived &gt; </td></tr>
<tr class="memitem:a259ed4f41a444e8eed6a2a30998af53f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structdrake_1_1math_1_1_get_sub_matrix_gradient_single_element.html">GetSubMatrixGradientSingleElement</a>&lt; QSubvectorSize, Derived &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a259ed4f41a444e8eed6a2a30998af53f">getSubMatrixGradient</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;dM, <a class="el" href="classint.html">int</a> row, <a class="el" href="classint.html">int</a> col, typename Derived::Index M_rows, typename Derived::Index q_start=0, typename Derived::Index q_subvector_size=QSubvectorSize)</td></tr>
<tr class="separator:a259ed4f41a444e8eed6a2a30998af53f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30d857f8398886aff22da2ea64bc1113"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA , typename DerivedB &gt; </td></tr>
<tr class="memitem:a30d857f8398886aff22da2ea64bc1113"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a30d857f8398886aff22da2ea64bc1113">setSubMatrixGradient</a> (Eigen::MatrixBase&lt; DerivedA &gt; &amp;dM, const Eigen::MatrixBase&lt; DerivedB &gt; &amp;dM_submatrix, const std::vector&lt; <a class="el" href="classint.html">int</a> &gt; &amp;rows, const std::vector&lt; <a class="el" href="classint.html">int</a> &gt; &amp;cols, typename DerivedA::Index M_rows, typename DerivedA::Index q_start=0, typename DerivedA::Index q_subvector_size=-1)</td></tr>
<tr class="separator:a30d857f8398886aff22da2ea64bc1113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae748bcfe9270b9ed5dd2fb71df3941b6"><td class="memTemplParams" colspan="2">template&lt;int QSubvectorSize, typename DerivedA , typename DerivedB , std::size_t NRows, std::size_t NCols&gt; </td></tr>
<tr class="memitem:ae748bcfe9270b9ed5dd2fb71df3941b6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#ae748bcfe9270b9ed5dd2fb71df3941b6">setSubMatrixGradient</a> (Eigen::MatrixBase&lt; DerivedA &gt; &amp;dM, const Eigen::MatrixBase&lt; DerivedB &gt; &amp;dM_submatrix, const std::array&lt; <a class="el" href="classint.html">int</a>, NRows &gt; &amp;rows, const std::array&lt; <a class="el" href="classint.html">int</a>, NCols &gt; &amp;cols, typename DerivedA::Index M_rows, typename DerivedA::Index q_start=0, typename DerivedA::Index q_subvector_size=QSubvectorSize)</td></tr>
<tr class="separator:ae748bcfe9270b9ed5dd2fb71df3941b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab54df9b3b01c7c5509373712fda88ad4"><td class="memTemplParams" colspan="2">template&lt;int QSubvectorSize, typename DerivedDM , typename DerivedDMSub &gt; </td></tr>
<tr class="memitem:ab54df9b3b01c7c5509373712fda88ad4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#ab54df9b3b01c7c5509373712fda88ad4">setSubMatrixGradient</a> (Eigen::MatrixBase&lt; DerivedDM &gt; &amp;dM, const Eigen::MatrixBase&lt; DerivedDMSub &gt; &amp;dM_submatrix, <a class="el" href="classint.html">int</a> row, <a class="el" href="classint.html">int</a> col, typename DerivedDM::Index M_rows, typename DerivedDM::Index q_start=0, typename DerivedDM::Index q_subvector_size=QSubvectorSize)</td></tr>
<tr class="separator:ab54df9b3b01c7c5509373712fda88ad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad276064dcd8cb5e77d3dc41140840e8c"><td class="memTemplParams" colspan="2">template&lt;int NumDigits = Eigen::Dynamic&gt; </td></tr>
<tr class="memitem:ad276064dcd8cb5e77d3dc41140840e8c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structdrake_1_1math_1_1_gray_codes_matrix.html">GrayCodesMatrix</a>&lt; NumDigits &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#ad276064dcd8cb5e77d3dc41140840e8c">CalculateReflectedGrayCodes</a> (<a class="el" href="classint.html">int</a> num_digits=NumDigits)</td></tr>
<tr class="memdesc:ad276064dcd8cb5e77d3dc41140840e8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a matrix whose i'th row is the Gray code for integer i.  <a href="#ad276064dcd8cb5e77d3dc41140840e8c">More...</a><br /></td></tr>
<tr class="separator:ad276064dcd8cb5e77d3dc41140840e8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5390cdccf326541855e43a3dd5c2a9d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#ab5390cdccf326541855e43a3dd5c2a9d">GrayCodeToInteger</a> (const Eigen::Ref&lt; const Eigen::VectorXi &gt; &amp;gray_code)</td></tr>
<tr class="memdesc:ab5390cdccf326541855e43a3dd5c2a9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the Gray code to an integer.  <a href="#ab5390cdccf326541855e43a3dd5c2a9d">More...</a><br /></td></tr>
<tr class="separator:ab5390cdccf326541855e43a3dd5c2a9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82d0a7052d08481add2e9086b98144dd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a82d0a7052d08481add2e9086b98144dd"><td class="memTemplItemLeft" align="right" valign="top">const Eigen::Quaternion&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a82d0a7052d08481add2e9086b98144dd">HopfCoordinateToQuaternion</a> (const T &amp;theta, const T &amp;phi, const T &amp;psi)</td></tr>
<tr class="memdesc:a82d0a7052d08481add2e9086b98144dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms Hopf coordinates to a quaternion w, x, y, z as w = cos(θ/2)cos(ψ/2) x = cos(θ/2)sin(ψ/2) y = sin(θ/2)cos(φ+ψ/2) z = sin(θ/2)sin(φ+ψ/2) The user can refer to equation 5 of Generating Uniform Incremental Grids on SO(3) Using the Hopf Fibration by Anna Yershova, Steven LaValle and Julie Mitchell, 2008.  <a href="#a82d0a7052d08481add2e9086b98144dd">More...</a><br /></td></tr>
<tr class="separator:a82d0a7052d08481add2e9086b98144dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab948fdacb210871495edea82aa001473"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab948fdacb210871495edea82aa001473"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#ab948fdacb210871495edea82aa001473">QuaternionToHopfCoordinate</a> (const Eigen::Quaternion&lt; T &gt; &amp;quaternion)</td></tr>
<tr class="memdesc:ab948fdacb210871495edea82aa001473"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a unit-length quaternion (w, x, y, z) to Hopf coordinate as if w &gt;= 0 ψ = 2*atan2(x, w) else ψ = 2*atan2(-x, -w) φ = mod(atan2(z, y) - ψ/2, 2pi) θ = 2*atan2(√(y²+z²), √(w²+x²)) ψ is in the range of [-pi, pi].  <a href="#ab948fdacb210871495edea82aa001473">More...</a><br /></td></tr>
<tr class="separator:ab948fdacb210871495edea82aa001473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57457683becdddf605a55be881c065b4"><td class="memTemplParams" colspan="2">template&lt;int MaxChunkSize = 10, class F , class Arg &gt; </td></tr>
<tr class="memitem:a57457683becdddf605a55be881c065b4"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a57457683becdddf605a55be881c065b4">jacobian</a> (F &amp;&amp;f, Arg &amp;&amp;x)</td></tr>
<tr class="memdesc:a57457683becdddf605a55be881c065b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a matrix of AutoDiffScalars from which both the value and the Jacobian of a function </p><p class="formulaDsp">
\[ f:\mathbb{R}^{n\times m}\rightarrow\mathbb{R}^{p\times q} \]
</p>
<p> (f: R^n*m -&gt; R^p*q) can be extracted.  <a href="#a57457683becdddf605a55be881c065b4">More...</a><br /></td></tr>
<tr class="separator:a57457683becdddf605a55be881c065b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dce37732e3e532f7b87cd517789da7f"><td class="memTemplParams" colspan="2">template&lt;int MaxChunkSizeOuter = 10, int MaxChunkSizeInner = 10, class F , class Arg &gt; </td></tr>
<tr class="memitem:a6dce37732e3e532f7b87cd517789da7f"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a6dce37732e3e532f7b87cd517789da7f">hessian</a> (F &amp;&amp;f, Arg &amp;&amp;x)</td></tr>
<tr class="memdesc:a6dce37732e3e532f7b87cd517789da7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a matrix of AutoDiffScalars from which the value, Jacobian, and Hessian of a function </p><p class="formulaDsp">
\[ f:\mathbb{R}^{n\times m}\rightarrow\mathbb{R}^{p\times q} \]
</p>
<p> (f: R^n*m -&gt; R^p*q) can be extracted.  <a href="#a6dce37732e3e532f7b87cd517789da7f">More...</a><br /></td></tr>
<tr class="separator:a6dce37732e3e532f7b87cd517789da7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84760cbea23b50efdbe9a85f3967f098"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a84760cbea23b50efdbe9a85f3967f098"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a84760cbea23b50efdbe9a85f3967f098">IsSymmetric</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;matrix)</td></tr>
<tr class="memdesc:a84760cbea23b50efdbe9a85f3967f098"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a matrix is symmetric.  <a href="#a84760cbea23b50efdbe9a85f3967f098">More...</a><br /></td></tr>
<tr class="separator:a84760cbea23b50efdbe9a85f3967f098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a141ec70804c105e09ab3b0a855152b8b"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a141ec70804c105e09ab3b0a855152b8b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a141ec70804c105e09ab3b0a855152b8b">IsSymmetric</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;matrix, const typename Derived::Scalar &amp;precision)</td></tr>
<tr class="memdesc:a141ec70804c105e09ab3b0a855152b8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a matrix is symmetric based on whether the difference between matrix(i, j) and matrix(j, i) is smaller than <code>precision</code> for all i, j.  <a href="#a141ec70804c105e09ab3b0a855152b8b">More...</a><br /></td></tr>
<tr class="separator:a141ec70804c105e09ab3b0a855152b8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5390bb2dadbe96cd6dfbe26c6891f100"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a5390bb2dadbe96cd6dfbe26c6891f100"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">drake::MatrixX</a>&lt; typename Derived::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a5390bb2dadbe96cd6dfbe26c6891f100">ToSymmetricMatrixFromLowerTriangularColumns</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;lower_triangular_columns)</td></tr>
<tr class="memdesc:a5390bb2dadbe96cd6dfbe26c6891f100"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a column vector containing the stacked columns of the lower triangular part of a square matrix, returning a symmetric matrix whose lower triangular part is the same as the original matrix.  <a href="#a5390bb2dadbe96cd6dfbe26c6891f100">More...</a><br /></td></tr>
<tr class="separator:a5390bb2dadbe96cd6dfbe26c6891f100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d81fb8e0b28f46bad7838ed39bffbce"><td class="memTemplParams" colspan="2">template&lt;int rows, typename Derived &gt; </td></tr>
<tr class="memitem:a6d81fb8e0b28f46bad7838ed39bffbce"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename Derived::Scalar, rows, rows &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a6d81fb8e0b28f46bad7838ed39bffbce">ToSymmetricMatrixFromLowerTriangularColumns</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;lower_triangular_columns)</td></tr>
<tr class="memdesc:a6d81fb8e0b28f46bad7838ed39bffbce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a column vector containing the stacked columns of the lower triangular part of a square matrix, returning a symmetric matrix whose lower triangular part is the same as the original matrix.  <a href="#a6d81fb8e0b28f46bad7838ed39bffbce">More...</a><br /></td></tr>
<tr class="separator:a6d81fb8e0b28f46bad7838ed39bffbce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a6d10bc0b3dfc5902d0a06f186dba8f"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a8a6d10bc0b3dfc5902d0a06f186dba8f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a8a6d10bc0b3dfc5902d0a06f186dba8f">IsPositiveDefinite</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;matrix, double eigenvalue_tolerance=0.0, double symmetry_tolerance=0.0)</td></tr>
<tr class="memdesc:a8a6d10bc0b3dfc5902d0a06f186dba8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a matrix is symmetric (with tolerance <code>symmetry_tolerance</code> &ndash;.  <a href="#a8a6d10bc0b3dfc5902d0a06f186dba8f">More...</a><br /></td></tr>
<tr class="separator:a8a6d10bc0b3dfc5902d0a06f186dba8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48484009086db12d881bea6bcaab2514"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a48484009086db12d881bea6bcaab2514"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a48484009086db12d881bea6bcaab2514">NormalizeVector</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;x, typename Derived::PlainObject &amp;x_norm, typename <a class="el" href="structdrake_1_1math_1_1_gradient.html">drake::math::Gradient</a>&lt; Derived, Derived::RowsAtCompileTime, 1 &gt;::type *dx_norm=nullptr, typename <a class="el" href="structdrake_1_1math_1_1_gradient.html">drake::math::Gradient</a>&lt; Derived, Derived::RowsAtCompileTime, 2 &gt;::type *ddx_norm=nullptr)</td></tr>
<tr class="memdesc:a48484009086db12d881bea6bcaab2514"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the normalized vector, optionally with its gradient and second derivative.  <a href="#a48484009086db12d881bea6bcaab2514">More...</a><br /></td></tr>
<tr class="separator:a48484009086db12d881bea6bcaab2514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fccff311f09a5a35afac17388541c7f"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a2fccff311f09a5a35afac17388541c7f">DecomposePSDmatrixIntoXtransposeTimesX</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;Y, double zero_tol)</td></tr>
<tr class="memdesc:a2fccff311f09a5a35afac17388541c7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a symmetric positive semidefinite matrix Y, decompose it into XᵀX, where the number of rows in X equals to the rank of Y.  <a href="#a2fccff311f09a5a35afac17388541c7f">More...</a><br /></td></tr>
<tr class="separator:a2fccff311f09a5a35afac17388541c7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a296872692791b1e6d9e27311fc55a694"><td class="memItemLeft" align="right" valign="top">std::pair&lt; Eigen::MatrixXd, Eigen::MatrixXd &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a296872692791b1e6d9e27311fc55a694">DecomposePositiveQuadraticForm</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;Q, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;b, double c, double tol=0)</td></tr>
<tr class="memdesc:a296872692791b1e6d9e27311fc55a694"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite a quadratic form xᵀQx + bᵀx + c to (Rx+d)ᵀ(Rx+d) where.  <a href="#a296872692791b1e6d9e27311fc55a694">More...</a><br /></td></tr>
<tr class="separator:a296872692791b1e6d9e27311fc55a694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c66e16411c4f0d53e005658a49ccf6a"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a8c66e16411c4f0d53e005658a49ccf6a">BalanceQuadraticForms</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;S, const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;P)</td></tr>
<tr class="memdesc:a8c66e16411c4f0d53e005658a49ccf6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given two quadratic forms, x'Sx &gt; 0 and x'Px, (with P symmetric and full rank), finds a change of variables x = Ty, which simultaneously diagonalizes both forms (as inspired by "balanced truncation" in model-order reduction [1]).  <a href="#a8c66e16411c4f0d53e005658a49ccf6a">More...</a><br /></td></tr>
<tr class="separator:a8c66e16411c4f0d53e005658a49ccf6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e37615af3b6facc6f7dec51323a628e"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a5e37615af3b6facc6f7dec51323a628e"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Quaternion&lt; Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a5e37615af3b6facc6f7dec51323a628e">ClosestQuaternion</a> (const Eigen::Quaternion&lt; Scalar &gt; &amp;q0, const Eigen::Quaternion&lt; Scalar &gt; &amp;q1)</td></tr>
<tr class="memdesc:a5e37615af3b6facc6f7dec51323a628e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a unit quaternion that represents the same orientation as <code>q1</code>, and has the "shortest" geodesic distance on the unit sphere to <code>q0</code>.  <a href="#a5e37615af3b6facc6f7dec51323a628e">More...</a><br /></td></tr>
<tr class="separator:a5e37615af3b6facc6f7dec51323a628e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e6bdc00adb60394da9687fc9aa5b0aa"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a7e6bdc00adb60394da9687fc9aa5b0aa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#af7e96394aef85f13f3fc84d3c3c238b3">Vector4</a>&lt; typename Derived::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a7e6bdc00adb60394da9687fc9aa5b0aa">quatConjugate</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;q)</td></tr>
<tr class="separator:a7e6bdc00adb60394da9687fc9aa5b0aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29059591a43a840c9a7e2f31a2d55130"><td class="memTemplParams" colspan="2">template&lt;typename Derived1 , typename Derived2 &gt; </td></tr>
<tr class="memitem:a29059591a43a840c9a7e2f31a2d55130"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#af7e96394aef85f13f3fc84d3c3c238b3">Vector4</a>&lt; typename Derived1::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a29059591a43a840c9a7e2f31a2d55130">quatProduct</a> (const Eigen::MatrixBase&lt; Derived1 &gt; &amp;q1, const Eigen::MatrixBase&lt; Derived2 &gt; &amp;q2)</td></tr>
<tr class="separator:a29059591a43a840c9a7e2f31a2d55130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fc70ebdc0ea497711e6e7b69eddef2d"><td class="memTemplParams" colspan="2">template&lt;typename DerivedQ , typename DerivedV &gt; </td></tr>
<tr class="memitem:a0fc70ebdc0ea497711e6e7b69eddef2d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; typename DerivedV::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a0fc70ebdc0ea497711e6e7b69eddef2d">quatRotateVec</a> (const Eigen::MatrixBase&lt; DerivedQ &gt; &amp;q, const Eigen::MatrixBase&lt; DerivedV &gt; &amp;v)</td></tr>
<tr class="separator:a0fc70ebdc0ea497711e6e7b69eddef2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2ef93ff1fa2dc788507d6eadb4bb78f"><td class="memTemplParams" colspan="2">template&lt;typename Derived1 , typename Derived2 &gt; </td></tr>
<tr class="memitem:ae2ef93ff1fa2dc788507d6eadb4bb78f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#af7e96394aef85f13f3fc84d3c3c238b3">Vector4</a>&lt; typename Derived1::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#ae2ef93ff1fa2dc788507d6eadb4bb78f">quatDiff</a> (const Eigen::MatrixBase&lt; Derived1 &gt; &amp;q1, const Eigen::MatrixBase&lt; Derived2 &gt; &amp;q2)</td></tr>
<tr class="separator:ae2ef93ff1fa2dc788507d6eadb4bb78f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad298b049679492bf3e846165c6c7e023"><td class="memTemplParams" colspan="2">template&lt;typename Derived1 , typename Derived2 , typename DerivedU &gt; </td></tr>
<tr class="memitem:ad298b049679492bf3e846165c6c7e023"><td class="memTemplItemLeft" align="right" valign="top">Derived1::Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#ad298b049679492bf3e846165c6c7e023">quatDiffAxisInvar</a> (const Eigen::MatrixBase&lt; Derived1 &gt; &amp;q1, const Eigen::MatrixBase&lt; Derived2 &gt; &amp;q2, const Eigen::MatrixBase&lt; DerivedU &gt; &amp;u)</td></tr>
<tr class="separator:ad298b049679492bf3e846165c6c7e023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88a6d40e458bc9f766f33b819a7b4900"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a88a6d40e458bc9f766f33b819a7b4900"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a88a6d40e458bc9f766f33b819a7b4900">is_quaternion_in_canonical_form</a> (const Eigen::Quaternion&lt; T &gt; &amp;quat)</td></tr>
<tr class="memdesc:a88a6d40e458bc9f766f33b819a7b4900"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function tests whether a quaternion is in "canonical form" meaning that it tests whether the quaternion [w, x, y, z] has a non-negative w value.  <a href="#a88a6d40e458bc9f766f33b819a7b4900">More...</a><br /></td></tr>
<tr class="separator:a88a6d40e458bc9f766f33b819a7b4900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad74d3c5baa84fa6ef04b6ada5ffcbe5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aad74d3c5baa84fa6ef04b6ada5ffcbe5"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Quaternion&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#aad74d3c5baa84fa6ef04b6ada5ffcbe5">QuaternionToCanonicalForm</a> (const Eigen::Quaternion&lt; T &gt; &amp;quat)</td></tr>
<tr class="memdesc:aad74d3c5baa84fa6ef04b6ada5ffcbe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns a quaternion in its "canonical form" meaning that it returns a quaternion [w, x, y, z] with a non-negative w.  <a href="#aad74d3c5baa84fa6ef04b6ada5ffcbe5">More...</a><br /></td></tr>
<tr class="separator:aad74d3c5baa84fa6ef04b6ada5ffcbe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc96357c54438cadae5c8aefbd16713d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adc96357c54438cadae5c8aefbd16713d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#adc96357c54438cadae5c8aefbd16713d">AreQuaternionsEqualForOrientation</a> (const Eigen::Quaternion&lt; T &gt; &amp;quat1, const Eigen::Quaternion&lt; T &gt; &amp;quat2, const T tolerance)</td></tr>
<tr class="memdesc:adc96357c54438cadae5c8aefbd16713d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function tests whether two quaternions represent the same orientation.  <a href="#adc96357c54438cadae5c8aefbd16713d">More...</a><br /></td></tr>
<tr class="separator:adc96357c54438cadae5c8aefbd16713d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4bf90f81dcf655d829ed2d718251215"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab4bf90f81dcf655d829ed2d718251215"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#af7e96394aef85f13f3fc84d3c3c238b3">Vector4</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#ab4bf90f81dcf655d829ed2d718251215">CalculateQuaternionDtFromAngularVelocityExpressedInB</a> (const Eigen::Quaternion&lt; T &gt; &amp;quat_AB, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;w_AB_B)</td></tr>
<tr class="memdesc:ab4bf90f81dcf655d829ed2d718251215"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates a quaternion's time-derivative from its quaternion and angular velocity.  <a href="#ab4bf90f81dcf655d829ed2d718251215">More...</a><br /></td></tr>
<tr class="separator:ab4bf90f81dcf655d829ed2d718251215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98411a94334e6d40ef2ca10bfc053118"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a98411a94334e6d40ef2ca10bfc053118"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a98411a94334e6d40ef2ca10bfc053118">CalculateAngularVelocityExpressedInBFromQuaternionDt</a> (const Eigen::Quaternion&lt; T &gt; &amp;quat_AB, const <a class="el" href="namespacedrake.html#af7e96394aef85f13f3fc84d3c3c238b3">Vector4</a>&lt; T &gt; &amp;quatDt)</td></tr>
<tr class="memdesc:a98411a94334e6d40ef2ca10bfc053118"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates angular velocity from a quaternion and its time- derivative.  <a href="#a98411a94334e6d40ef2ca10bfc053118">More...</a><br /></td></tr>
<tr class="separator:a98411a94334e6d40ef2ca10bfc053118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06541dcb249b4b951ea73d45d2067337"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a06541dcb249b4b951ea73d45d2067337"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a06541dcb249b4b951ea73d45d2067337">CalculateQuaternionDtConstraintViolation</a> (const Eigen::Quaternion&lt; T &gt; &amp;quat, const <a class="el" href="namespacedrake.html#af7e96394aef85f13f3fc84d3c3c238b3">Vector4</a>&lt; T &gt; &amp;quatDt)</td></tr>
<tr class="memdesc:a06541dcb249b4b951ea73d45d2067337"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates how well a quaternion and its time-derivative satisfy the quaternion time-derivative constraint specified in [Kane, 1983] Section 1.13, equations 12-13, page 59.  <a href="#a06541dcb249b4b951ea73d45d2067337">More...</a><br /></td></tr>
<tr class="separator:a06541dcb249b4b951ea73d45d2067337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a056f9de21690e59551e2904bde9ac928"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a056f9de21690e59551e2904bde9ac928"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a056f9de21690e59551e2904bde9ac928">IsQuaternionValid</a> (const Eigen::Quaternion&lt; T &gt; &amp;quat, const double tolerance)</td></tr>
<tr class="memdesc:a056f9de21690e59551e2904bde9ac928"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function tests if a quaternion satisfies the quaternion constraint specified in [Kane, 1983] Section 1.3, equation 4, page 12, i.e., a quaternion [w, x, y, z] must satisfy: w^2 + x^2 + y^2 + z^2 = 1.  <a href="#a056f9de21690e59551e2904bde9ac928">More...</a><br /></td></tr>
<tr class="separator:a056f9de21690e59551e2904bde9ac928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b38bdfc1e3df8662c8726bc89a08ed0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3b38bdfc1e3df8662c8726bc89a08ed0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a3b38bdfc1e3df8662c8726bc89a08ed0">IsBothQuaternionAndQuaternionDtOK</a> (const Eigen::Quaternion&lt; T &gt; &amp;quat, const <a class="el" href="namespacedrake.html#af7e96394aef85f13f3fc84d3c3c238b3">Vector4</a>&lt; T &gt; &amp;quatDt, const double tolerance)</td></tr>
<tr class="memdesc:a3b38bdfc1e3df8662c8726bc89a08ed0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function tests if a quaternion satisfies the time-derivative constraint specified in [Kane, 1983] Section 1.13, equation 13, page 59.  <a href="#a3b38bdfc1e3df8662c8726bc89a08ed0">More...</a><br /></td></tr>
<tr class="separator:a3b38bdfc1e3df8662c8726bc89a08ed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e47f892f2417dfc861a095328019361"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2e47f892f2417dfc861a095328019361"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a2e47f892f2417dfc861a095328019361">IsQuaternionAndQuaternionDtEqualAngularVelocityExpressedInB</a> (const Eigen::Quaternion&lt; T &gt; &amp;quat, const <a class="el" href="namespacedrake.html#af7e96394aef85f13f3fc84d3c3c238b3">Vector4</a>&lt; T &gt; &amp;quatDt, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;w_B, const double tolerance)</td></tr>
<tr class="memdesc:a2e47f892f2417dfc861a095328019361"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function tests if a quaternion and a quaternions time-derivative can calculate and match an angular velocity to within a tolerance.  <a href="#a2e47f892f2417dfc861a095328019361">More...</a><br /></td></tr>
<tr class="separator:a2e47f892f2417dfc861a095328019361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c92561b046b32c1ebe172bd32dc8276"><td class="memTemplParams" colspan="2">template&lt;typename T  = double, class Generator  = RandomGenerator&gt; </td></tr>
<tr class="memitem:a6c92561b046b32c1ebe172bd32dc8276"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Quaternion&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a6c92561b046b32c1ebe172bd32dc8276">UniformlyRandomQuaternion</a> (Generator *generator)</td></tr>
<tr class="memdesc:a6c92561b046b32c1ebe172bd32dc8276"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a rotation (in the quaternion representation) that rotates a point on the unit sphere to another point on the unit sphere with a uniform distribution over the sphere.  <a href="#a6c92561b046b32c1ebe172bd32dc8276">More...</a><br /></td></tr>
<tr class="separator:a6c92561b046b32c1ebe172bd32dc8276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6aefde593f0fbe2f9ef04f40979827f"><td class="memTemplParams" colspan="2">template&lt;typename T  = double, class Generator  = RandomGenerator&gt; </td></tr>
<tr class="memitem:ae6aefde593f0fbe2f9ef04f40979827f"><td class="memTemplItemLeft" align="right" valign="top">Eigen::AngleAxis&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#ae6aefde593f0fbe2f9ef04f40979827f">UniformlyRandomAngleAxis</a> (Generator *generator)</td></tr>
<tr class="memdesc:ae6aefde593f0fbe2f9ef04f40979827f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a rotation (in the axis-angle representation) that rotates a point on the unit sphere to another point on the unit sphere with a uniform distribution over the sphere.  <a href="#ae6aefde593f0fbe2f9ef04f40979827f">More...</a><br /></td></tr>
<tr class="separator:ae6aefde593f0fbe2f9ef04f40979827f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af27920d083eb816f24f832091a662f28"><td class="memTemplParams" colspan="2">template&lt;typename T  = double, class Generator  = RandomGenerator&gt; </td></tr>
<tr class="memitem:af27920d083eb816f24f832091a662f28"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#af27920d083eb816f24f832091a662f28">UniformlyRandomRotationMatrix</a> (Generator *generator)</td></tr>
<tr class="memdesc:af27920d083eb816f24f832091a662f28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a rotation (in the rotation matrix representation) that rotates a point on the unit sphere to another point on the unit sphere with a uniform distribution over the sphere.  <a href="#af27920d083eb816f24f832091a662f28">More...</a><br /></td></tr>
<tr class="separator:af27920d083eb816f24f832091a662f28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc24ae9bbbf0b9d253f3344b97a9f3d4"><td class="memTemplParams" colspan="2">template&lt;typename T  = double, class Generator  = RandomGenerator&gt; </td></tr>
<tr class="memitem:acc24ae9bbbf0b9d253f3344b97a9f3d4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#acc24ae9bbbf0b9d253f3344b97a9f3d4">UniformlyRandomRPY</a> (Generator *generator)</td></tr>
<tr class="memdesc:acc24ae9bbbf0b9d253f3344b97a9f3d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a rotation (in the roll-pitch-yaw representation) that rotates a point on the unit sphere to another point on the unit sphere with a uniform distribution over the sphere.  <a href="#acc24ae9bbbf0b9d253f3344b97a9f3d4">More...</a><br /></td></tr>
<tr class="separator:acc24ae9bbbf0b9d253f3344b97a9f3d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00f832c0837ee2ac76c713ed23440e8e"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a00f832c0837ee2ac76c713ed23440e8e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structdrake_1_1math_1_1_gradient.html">drake::math::Gradient</a>&lt; Eigen::Matrix&lt; typename Derived::Scalar, 3, 3 &gt;, <a class="el" href="namespacedrake.html#a07869e660ffe730425feca7595de2273">drake::kQuaternionSize</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a00f832c0837ee2ac76c713ed23440e8e">dquat2rotmat</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;quaternion)</td></tr>
<tr class="memdesc:a00f832c0837ee2ac76c713ed23440e8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the gradient of the function that converts a unit length quaternion to a rotation matrix.  <a href="#a00f832c0837ee2ac76c713ed23440e8e">More...</a><br /></td></tr>
<tr class="separator:a00f832c0837ee2ac76c713ed23440e8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adee0d3618f370d3b31682a8ca479376e"><td class="memTemplParams" colspan="2">template&lt;typename DerivedR , typename DerivedDR &gt; </td></tr>
<tr class="memitem:adee0d3618f370d3b31682a8ca479376e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structdrake_1_1math_1_1_gradient.html">drake::math::Gradient</a>&lt; Eigen::Matrix&lt; typename DerivedR::Scalar, <a class="el" href="namespacedrake.html#aeab5b0d99cafc2f6ae5812128cea27a3">drake::kRpySize</a>, 1 &gt;, DerivedDR::ColsAtCompileTime &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#adee0d3618f370d3b31682a8ca479376e">drotmat2rpy</a> (const Eigen::MatrixBase&lt; DerivedR &gt; &amp;R, const Eigen::MatrixBase&lt; DerivedDR &gt; &amp;dR)</td></tr>
<tr class="memdesc:adee0d3618f370d3b31682a8ca479376e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the gradient of the function that converts a rotation matrix to body-fixed z-y'-x'' Euler angles.  <a href="#adee0d3618f370d3b31682a8ca479376e">More...</a><br /></td></tr>
<tr class="separator:adee0d3618f370d3b31682a8ca479376e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa02d13e3a0cbc27e905be533959b8d2a"><td class="memTemplParams" colspan="2">template&lt;typename DerivedR , typename DerivedDR &gt; </td></tr>
<tr class="memitem:aa02d13e3a0cbc27e905be533959b8d2a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structdrake_1_1math_1_1_gradient.html">drake::math::Gradient</a>&lt; Eigen::Matrix&lt; typename DerivedR::Scalar, <a class="el" href="namespacedrake.html#a07869e660ffe730425feca7595de2273">drake::kQuaternionSize</a>, 1 &gt;, DerivedDR::ColsAtCompileTime &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#aa02d13e3a0cbc27e905be533959b8d2a">drotmat2quat</a> (const Eigen::MatrixBase&lt; DerivedR &gt; &amp;R, const Eigen::MatrixBase&lt; DerivedDR &gt; &amp;dR)</td></tr>
<tr class="memdesc:aa02d13e3a0cbc27e905be533959b8d2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the gradient of the function that converts rotation matrix to quaternion.  <a href="#aa02d13e3a0cbc27e905be533959b8d2a">More...</a><br /></td></tr>
<tr class="separator:aa02d13e3a0cbc27e905be533959b8d2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab095ea87a1517bb9bae78d221f5d34da"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#ab095ea87a1517bb9bae78d221f5d34da">ProjectMatToRotMatWithAxis</a> (const Eigen::Matrix3d &amp;M, const Eigen::Vector3d &amp;axis, double angle_lb, double angle_ub)</td></tr>
<tr class="memdesc:ab095ea87a1517bb9bae78d221f5d34da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects an approximate 3 x 3 rotation matrix M onto an orthonormal matrix R so that R is a rotation matrix associated with a angle-axis rotation by an angle θ about a vector direction <code>axis</code>, with <code>angle_lb &lt;= θ &lt;= angle_ub</code>.  <a href="#ab095ea87a1517bb9bae78d221f5d34da">More...</a><br /></td></tr>
<tr class="separator:ab095ea87a1517bb9bae78d221f5d34da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adecdf6a7ef606861457807da4b56e7ff"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 , class T3 &gt; </td></tr>
<tr class="memitem:adecdf6a7ef606861457807da4b56e7ff"><td class="memTemplItemLeft" align="right" valign="top">T1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#adecdf6a7ef606861457807da4b56e7ff">saturate</a> (const T1 &amp;value, const T2 &amp;low, const T3 &amp;high)</td></tr>
<tr class="memdesc:adecdf6a7ef606861457807da4b56e7ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saturates the input <code>value</code> between upper and lower bounds.  <a href="#adecdf6a7ef606861457807da4b56e7ff">More...</a><br /></td></tr>
<tr class="separator:adecdf6a7ef606861457807da4b56e7ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64bd1ea33cbb7fd030ff6bf3061eb3fe"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:a64bd1ea33cbb7fd030ff6bf3061eb3fe"><td class="memTemplItemLeft" align="right" valign="top">T1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a64bd1ea33cbb7fd030ff6bf3061eb3fe">wrap_to</a> (const T1 &amp;value, const T2 &amp;low, const T2 &amp;high)</td></tr>
<tr class="memdesc:a64bd1ea33cbb7fd030ff6bf3061eb3fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">For variables that are meant to be periodic, (e.g.  <a href="#a64bd1ea33cbb7fd030ff6bf3061eb3fe">More...</a><br /></td></tr>
<tr class="separator:a64bd1ea33cbb7fd030ff6bf3061eb3fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">solve linear system of equations with a given solver.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="linear_solve_given_solver"></a> Solve linear system of equations A * x = b. Where A is an Eigen matrix of double/AutoDiffScalar/symbolic::Expression, and b is an Eigen matrix of double/AutoDiffScalar/symbolic::Expression. Notice that if either A or b contains <a class="el" href="classdrake_1_1symbolic_1_1_expression.html" title="Represents a symbolic form of an expression.">symbolic::Expression</a>, then the other has to contain <a class="el" href="classdrake_1_1symbolic_1_1_expression.html" title="Represents a symbolic form of an expression.">symbolic::Expression</a>. This 3-argument version allows the user to re-use <code>linear_solver</code> when <code>b</code> changes or the gradient of <code>A</code> changes. When either A or b contains AutoDiffScalar, we use implicit function theorem to find the gradient in x as ∂x/∂zᵢ = A⁻¹(∂b/∂zᵢ - ∂A/∂zᵢ * x) where z is the variable we take gradient with.</p>
<dl class="section note"><dt>Note</dt><dd>When both A and b are Eigen matrix of double, this function is almost as fast as calling linear_solver.solve(b) directly. When either A or b contains AutoDiffScalar, this function is a lot faster than first instantiating the linear solver of AutoDiffScalar, and then solving the equation with this autodiffable linear solver. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="classdrake_1_1math_1_1_linear_solver.html" title="Solves a linear system of equations A*x=b.">LinearSolver</a></td><td>The type of linear solver, for example Eigen::LLT&lt;Eigen::Matrix2d&gt; </td></tr>
    <tr><td class="paramname">DerivedA</td><td>An Eigen Matrix. </td></tr>
    <tr><td class="paramname">DerivedB</td><td>An Eigen Vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">linear_solver</td><td>The linear solver constructed with the double-version of A. </td></tr>
    <tr><td class="paramname">A</td><td>The matrix A. </td></tr>
    <tr><td class="paramname">b</td><td>The vector b.</td></tr>
  </table>
  </dd>
</dl>
<p>Here is an example code. </p><div class="fragment"><div class="line">Eigen::Matrix&lt;AutoDiffd&lt;3&gt;, 2, 2&gt; A_ad;</div><div class="line"><span class="comment">// Set the value and gradient in A_ad with arbitrary values;</span></div><div class="line">Eigen::Matrix2d A_val;</div><div class="line">A_val &lt;&lt; 1, 2, 3, 4;</div><div class="line"><span class="comment">// Gradient of A.col(0).</span></div><div class="line">Eigen::Matrix&lt;double, 2, 3&gt; A0_gradient;</div><div class="line">A0_gradient &lt;&lt; 1, 2, 3, 4, 5, 6;</div><div class="line">A_ad.col(0) = <a class="code" href="namespacedrake_1_1math.html#a32942f788a67278f27426f128e50e0b2">InitializeAutoDiff</a>(A_val.col(0), A0_gradient);</div><div class="line"><span class="comment">// Gradient of A.col(1)</span></div><div class="line">Eigen::Matrix&lt;double, 2, 3&gt; A1_gradient;</div><div class="line">A1_gradient &lt;&lt; 7, 8, 9, 10, 11, 12;</div><div class="line">A_ad.col(1) = <a class="code" href="namespacedrake_1_1math.html#a32942f788a67278f27426f128e50e0b2">InitializeAutoDiff</a>(A_val.col(1), A1_gradient);</div><div class="line"><span class="comment">// Set the value and gradient of b to arbitrary value.</span></div><div class="line"><span class="keyword">const</span> <a class="code" href="namespacedrake_1_1systems_1_1analysis_1_1test.html#a322dbcada3667894a629fe3f1a476f2a">Eigen::Vector2d</a> b_val(2, 3);</div><div class="line">Eigen::Matrix&lt;double, 2, 3&gt; b_gradient;</div><div class="line">b_gradient &lt;&lt; 1, 3, 5, 7, 9, 11;</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> b_ad = <a class="code" href="namespacedrake_1_1math.html#a32942f788a67278f27426f128e50e0b2">InitializeAutoDiff</a>(b_val, b_gradient);</div><div class="line"><span class="comment">// Solve the linear system A_val * x_val = b_val.</span></div><div class="line">Eigen::PartialPivLU&lt;Eigen::Matrix2d&gt; linear_solver(A_val);</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> x_val = <a class="code" href="namespacedrake_1_1math.html#a058825f71b44c44e61dd90c3b89ec87d">SolveLinearSystem</a>(linear_solver, A_val, b_val);</div><div class="line"><span class="comment">// Solve the linear system A*x=b, together with the gradient.</span></div><div class="line"><span class="comment">// x_ad contains both the value of the solution A*x=b, together with its</span></div><div class="line"><span class="comment">// gradient.</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> x_ad = <a class="code" href="namespacedrake_1_1math.html#a058825f71b44c44e61dd90c3b89ec87d">SolveLinearSystem</a>(linear_solver, A_ad, b_ad);</div></div><!-- fragment --> </div></td></tr>
<tr class="memitem:a058825f71b44c44e61dd90c3b89ec87d"><td class="memTemplParams" colspan="2">template&lt;typename LinearSolver , typename DerivedA , typename DerivedB &gt; </td></tr>
<tr class="memitem:a058825f71b44c44e61dd90c3b89ec87d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; internal::is_double_or_symbolic_v&lt; typename DerivedA::Scalar &gt; &amp;&amp;internal::is_double_or_symbolic_v&lt; typename DerivedB::Scalar &gt; &amp;&amp;std::is_same_v&lt; typename DerivedA::Scalar, typename DerivedB::Scalar &gt;, Eigen::Matrix&lt; typename DerivedA::Scalar, DerivedA::RowsAtCompileTime, DerivedB::ColsAtCompileTime &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a058825f71b44c44e61dd90c3b89ec87d">SolveLinearSystem</a> (const <a class="el" href="classdrake_1_1math_1_1_linear_solver.html">LinearSolver</a> &amp;linear_solver, const Eigen::MatrixBase&lt; DerivedA &gt; &amp;A, const Eigen::MatrixBase&lt; DerivedB &gt; &amp;b)</td></tr>
<tr class="memdesc:a058825f71b44c44e61dd90c3b89ec87d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized when A and b are both double or <a class="el" href="classdrake_1_1symbolic_1_1_expression.html" title="Represents a symbolic form of an expression.">symbolic::Expression</a> matrices.  <a href="#a058825f71b44c44e61dd90c3b89ec87d">More...</a><br /></td></tr>
<tr class="separator:a058825f71b44c44e61dd90c3b89ec87d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34a14f4ecff0af11999f7d416c3316bf"><td class="memTemplParams" colspan="2">template&lt;typename LinearSolver , typename DerivedB &gt; </td></tr>
<tr class="memitem:a34a14f4ecff0af11999f7d416c3316bf"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; internal::is_double_or_symbolic_v&lt; typename LinearSolver::MatrixType::Scalar &gt; &amp;&amp;internal::is_double_or_symbolic_v&lt; typename DerivedB::Scalar &gt; &amp;&amp;std::is_same_v&lt; typename LinearSolver::MatrixType::Scalar, typename DerivedB::Scalar &gt;, Eigen::Matrix&lt; typename LinearSolver::MatrixType::Scalar, DerivedB::RowsAtCompileTime, DerivedB::ColsAtCompileTime &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a34a14f4ecff0af11999f7d416c3316bf">SolveLinearSystem</a> (const <a class="el" href="classdrake_1_1math_1_1_linear_solver.html">LinearSolver</a> &amp;linear_solver, const Eigen::MatrixBase&lt; DerivedB &gt; &amp;b)</td></tr>
<tr class="memdesc:a34a14f4ecff0af11999f7d416c3316bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized when the matrix in linear_solver and b are both double or <a class="el" href="classdrake_1_1symbolic_1_1_expression.html" title="Represents a symbolic form of an expression.">symbolic::Expression</a> matrices.  <a href="#a34a14f4ecff0af11999f7d416c3316bf">More...</a><br /></td></tr>
<tr class="separator:a34a14f4ecff0af11999f7d416c3316bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1ecf90a76392d69deecb8feb29e19a7"><td class="memTemplParams" colspan="2">template&lt;typename LinearSolver , typename DerivedB &gt; </td></tr>
<tr class="memitem:ac1ecf90a76392d69deecb8feb29e19a7"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same_v&lt; typename LinearSolver::MatrixType::Scalar, double &gt; &amp;&amp;internal::is_autodiff_v&lt; typename DerivedB::Scalar &gt;, Eigen::Matrix&lt; typename DerivedB::Scalar, DerivedB::RowsAtCompileTime, DerivedB::ColsAtCompileTime &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#ac1ecf90a76392d69deecb8feb29e19a7">SolveLinearSystem</a> (const <a class="el" href="classdrake_1_1math_1_1_linear_solver.html">LinearSolver</a> &amp;linear_solver, const Eigen::MatrixBase&lt; DerivedB &gt; &amp;b)</td></tr>
<tr class="memdesc:ac1ecf90a76392d69deecb8feb29e19a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized the matrix in linear_solver is a double-valued matrix and b is an AutoDiffScalar-valued matrix.  <a href="#ac1ecf90a76392d69deecb8feb29e19a7">More...</a><br /></td></tr>
<tr class="separator:ac1ecf90a76392d69deecb8feb29e19a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fe42b78445dde235cc217342ba8ab87"><td class="memTemplParams" colspan="2">template&lt;typename LinearSolver , typename DerivedA , typename DerivedB &gt; </td></tr>
<tr class="memitem:a2fe42b78445dde235cc217342ba8ab87"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same_v&lt; typename DerivedA::Scalar, double &gt; &amp;&amp;internal::is_autodiff_v&lt; typename DerivedB::Scalar &gt;, Eigen::Matrix&lt; typename DerivedB::Scalar, DerivedA::RowsAtCompileTime, DerivedB::ColsAtCompileTime &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a2fe42b78445dde235cc217342ba8ab87">SolveLinearSystem</a> (const <a class="el" href="classdrake_1_1math_1_1_linear_solver.html">LinearSolver</a> &amp;linear_solver, const Eigen::MatrixBase&lt; DerivedA &gt; &amp;A, const Eigen::MatrixBase&lt; DerivedB &gt; &amp;b)</td></tr>
<tr class="memdesc:a2fe42b78445dde235cc217342ba8ab87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized when A is a double-valued matrix and b is an AutoDiffScalar-valued matrix.  <a href="#a2fe42b78445dde235cc217342ba8ab87">More...</a><br /></td></tr>
<tr class="separator:a2fe42b78445dde235cc217342ba8ab87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bfcba20c731dc23e4f48c367e36c9de"><td class="memTemplParams" colspan="2">template&lt;typename LinearSolver , typename DerivedA , typename DerivedB &gt; </td></tr>
<tr class="memitem:a9bfcba20c731dc23e4f48c367e36c9de"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; internal::is_autodiff_v&lt; typename DerivedA::Scalar &gt;, Eigen::Matrix&lt; typename DerivedA::Scalar, DerivedA::RowsAtCompileTime, DerivedB::ColsAtCompileTime &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a9bfcba20c731dc23e4f48c367e36c9de">SolveLinearSystem</a> (const <a class="el" href="classdrake_1_1math_1_1_linear_solver.html">LinearSolver</a> &amp;linear_solver, const Eigen::MatrixBase&lt; DerivedA &gt; &amp;A, const Eigen::MatrixBase&lt; DerivedB &gt; &amp;b)</td></tr>
<tr class="memdesc:a9bfcba20c731dc23e4f48c367e36c9de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized when A is an AutoDiffScalar-valued matrix, and b can contain either AutoDiffScalar or double.  <a href="#a9bfcba20c731dc23e4f48c367e36c9de">More...</a><br /></td></tr>
<tr class="separator:a9bfcba20c731dc23e4f48c367e36c9de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Get linear solver</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="get_linear_solver"></a></p>
<p>Create the linear solver for a given matrix A, which will be used to solve the linear system of equations A * x = b.</p>
<p>The following table indicate the scalar type of the matrix in the returned linear solver, depending on the scalar type in matrix A</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">A  </th><th class="markdownTableHeadNone">double  </th><th class="markdownTableHeadNone">ADS  </th><th class="markdownTableHeadNone">Expr   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">solver  </td><td class="markdownTableBodyNone">double  </td><td class="markdownTableBodyNone">double  </td><td class="markdownTableBodyNone">Expr   </td></tr>
</table>
<p>where ADS stands for Eigen::AutoDiffScalar, and Expr stands for <a class="el" href="classdrake_1_1symbolic_1_1_expression.html" title="Represents a symbolic form of an expression.">symbolic::Expression</a>. Here is the example code </p><div class="fragment"><div class="line">Eigen::Matrix2d A_val;</div><div class="line">A_val &lt;&lt; 1, 2, 2, 5;</div><div class="line"><a class="code" href="namespacedrake_1_1systems_1_1analysis_1_1test.html#a322dbcada3667894a629fe3f1a476f2a">Eigen::Vector2d</a> b_val(3, 4);</div><div class="line"><span class="keyword">const</span> <a class="code" href="namespacedrake_1_1systems_1_1analysis_1_1test.html#a322dbcada3667894a629fe3f1a476f2a">Eigen::Vector2d</a> x_val =</div><div class="line">  <a class="code" href="namespacedrake_1_1math.html#a058825f71b44c44e61dd90c3b89ec87d">SolveLinearSystem</a>(GetLinearSolver&lt;Eigen::LLT&gt;(A_val), A_val, b_val);</div><div class="line">Eigen::Matrix&lt;AutoDiffXd, 2, 2&gt; A_ad;</div><div class="line">A_ad(0, 0).value() = A_val(0, 0);</div><div class="line">A_ad(0, 0).derivatives() = Eigen::Vector3d(1, 2, 3);</div><div class="line">A_ad(0, 1).value() = A_val(0, 1);</div><div class="line">A_ad(0, 1).derivatives() = Eigen::Vector3d(2, 3, 4);</div><div class="line">A_ad(1, 0).value() = A_val(1, 0);</div><div class="line">A_ad(1, 0).derivatives() = Eigen::Vector3d(3, 4, 5);</div><div class="line">A_ad(1, 1).value() = A_val(1, 1);</div><div class="line">A_ad(1, 1).derivatives() = Eigen::Vector3d(4, 5, 6);</div><div class="line"><span class="comment">// Solve A * x = b with A containing gradient.</span></div><div class="line"><span class="keyword">const</span> Eigen::Matrix&lt;AutoDiffXd, 2, 1&gt; x_ad1 =</div><div class="line">  <a class="code" href="namespacedrake_1_1math.html#a058825f71b44c44e61dd90c3b89ec87d">SolveLinearSystem</a>(GetLinearSolver&lt;Eigen::LLT&gt;(A_ad), A_ad, b_val);</div><div class="line">Eigen::Matrix&lt;AutoDiffXd, 2, 1&gt; b_ad;</div><div class="line">b_ad(0).value() = b_val(0);</div><div class="line">b_ad(0).derivatives() = Eigen::Vector3d(5, 6, 7);</div><div class="line">b_ad(1).value() = b_val(1);</div><div class="line">b_ad(1).derivatives() = Eigen::Vector3d(6, 7, 8);</div><div class="line"><span class="comment">// Solve A * x = b with b containing gradient.</span></div><div class="line"><span class="keyword">const</span> Eigen::Matrix&lt;AutoDiffXd, 2, 1&gt; x_ad2 =</div><div class="line">  <a class="code" href="namespacedrake_1_1math.html#a058825f71b44c44e61dd90c3b89ec87d">SolveLinearSystem</a>(GetLinearSolver&lt;Eigen::LLT&gt;(A_val), A_val, b_ad);</div><div class="line"><span class="comment">// Solve A * x = b with both A and b containing gradient.</span></div><div class="line"><span class="keyword">const</span> Eigen::Matrix&lt;AutoDiffXd, 2, 1&gt; x_ad3 =</div><div class="line">  <a class="code" href="namespacedrake_1_1math.html#a058825f71b44c44e61dd90c3b89ec87d">SolveLinearSystem</a>(GetLinearSolver&lt;Eigen::LLT&gt;(A_ad), A_ad, b_ad);</div></div><!-- fragment --><p>{cc} </p>
</div></td></tr>
<tr class="memitem:a145b102b8109265146ea4a0c63596873"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename, int... &gt; typename LinearSolverType, typename DerivedA &gt; </td></tr>
<tr class="memitem:a145b102b8109265146ea4a0c63596873"><td class="memTemplItemLeft" align="right" valign="top">internal::EigenLinearSolver&lt; LinearSolverType, DerivedA &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a145b102b8109265146ea4a0c63596873">GetLinearSolver</a> (const Eigen::MatrixBase&lt; DerivedA &gt; &amp;A)</td></tr>
<tr class="memdesc:a145b102b8109265146ea4a0c63596873"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the linear solver for a matrix A.  <a href="#a145b102b8109265146ea4a0c63596873">More...</a><br /></td></tr>
<tr class="separator:a145b102b8109265146ea4a0c63596873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">solve linear system of equations</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="linear_solve"></a> Solve linear system of equations A * x = b. Where A is an Eigen matrix of double/AutoDiffScalar/symbolic::Expression, and b is an Eigen matrix of double/AutoDiffScalar/symbolic::Expression. Note that when either A or b contains <a class="el" href="classdrake_1_1symbolic_1_1_expression.html" title="Represents a symbolic form of an expression.">symbolic::Expression</a>, the other has to contain <a class="el" href="classdrake_1_1symbolic_1_1_expression.html" title="Represents a symbolic form of an expression.">symbolic::Expression</a> as well. When either A or b contains AutoDiffScalar, we use implicit function theorem to find the gradient in x as ∂x/∂zᵢ = A⁻¹(∂b/∂zᵢ - ∂A/∂zᵢ * x) where z is the variable we take gradient with.</p>
<p>The following table indicate the scalar type of x with A/b containing the specified scalar type. The entries with NA are not supported.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">b ＼ A  </th><th class="markdownTableHeadNone">double  </th><th class="markdownTableHeadNone">ADS  </th><th class="markdownTableHeadNone">Expr   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">double  </td><td class="markdownTableBodyNone">double  </td><td class="markdownTableBodyNone">ADS  </td><td class="markdownTableBodyNone">NA   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">ADS  </td><td class="markdownTableBodyNone">ADS  </td><td class="markdownTableBodyNone">ADS  </td><td class="markdownTableBodyNone">NA   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Expr  </td><td class="markdownTableBodyNone">NA  </td><td class="markdownTableBodyNone">NA  </td><td class="markdownTableBodyNone">Expr   </td></tr>
</table>
<p>where ADS stands for Eigen::AutoDiffScalar, and Expr stands for <a class="el" href="classdrake_1_1symbolic_1_1_expression.html" title="Represents a symbolic form of an expression.">symbolic::Expression</a>.</p>
<p>TODO(hongkai.dai): support one of A/b being a double matrix and the other being a <a class="el" href="classdrake_1_1symbolic_1_1_expression.html" title="Represents a symbolic form of an expression.">symbolic::Expression</a> matrix.</p>
<dl class="section note"><dt>Note</dt><dd>When both A and b are Eigen matrix of double, this function is almost as fast as calling linear_solver.solve(b) directly; when either A or b contains AutoDiffScalar, this function is a lot faster than first instantiating the linear solver of AutoDiffScalar, and then solving the equation with this autodiffable linear solver. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LinearSolverType</td><td>The type of linear solver, for example Eigen::LLT. Notice that this is just specifies the solver type (such as Eigen::LLT), not the matrix type (like Eigen::LLT&lt;Eigen::Matrix2d&gt;). All Eigen solvers we care about are templated on the matrix type. Some are further templated on configuration ints. The int... will acount for zero or more of these ints, providing a common interface for both types of solvers. </td></tr>
    <tr><td class="paramname">DerivedA</td><td>An Eigen Matrix. </td></tr>
    <tr><td class="paramname">DerivedB</td><td>An Eigen Vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The matrix A. </td></tr>
    <tr><td class="paramname">b</td><td>The vector b.</td></tr>
  </table>
  </dd>
</dl>
<p>Here is an example code. </p><div class="fragment"><div class="line">Eigen::Matrix&lt;AutoDiffd&lt;3&gt;, 2, 2&gt; A_ad;</div><div class="line"><span class="comment">// Set the value and gradient in A_ad with arbitrary values;</span></div><div class="line">Eigen::Matrix2d A_val;</div><div class="line">A_val &lt;&lt; 1, 2, 3, 4;</div><div class="line"><span class="comment">// Gradient of A.col(0).</span></div><div class="line">Eigen::Matrix&lt;double, 2, 3&gt; A0_gradient;</div><div class="line">A0_gradient &lt;&lt; 1, 2, 3, 4, 5, 6;</div><div class="line">A_ad.col(0) = <a class="code" href="namespacedrake_1_1math.html#a32942f788a67278f27426f128e50e0b2">InitializeAutoDiff</a>(A_val.col(0), A0_gradient);</div><div class="line"><span class="comment">// Gradient of A.col(1)</span></div><div class="line">Eigen::Matrix&lt;double, 2, 3&gt; A1_gradient;</div><div class="line">A1_gradient &lt;&lt; 7, 8, 9, 10, 11, 12;</div><div class="line">A_ad.col(1) = <a class="code" href="namespacedrake_1_1math.html#a32942f788a67278f27426f128e50e0b2">InitializeAutoDiff</a>(A_val.col(1), A1_gradient);</div><div class="line"><span class="comment">// Set the value and gradient of b to arbitrary value.</span></div><div class="line"><span class="keyword">const</span> <a class="code" href="namespacedrake_1_1systems_1_1analysis_1_1test.html#a322dbcada3667894a629fe3f1a476f2a">Eigen::Vector2d</a> b_val(2, 3);</div><div class="line">Eigen::Matrix&lt;double, 2, 3&gt; b_gradient;</div><div class="line">b_gradient &lt;&lt; 1, 3, 5, 7, 9, 11;</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> b_ad = <a class="code" href="namespacedrake_1_1math.html#a32942f788a67278f27426f128e50e0b2">InitializeAutoDiff</a>(b_val, b_gradient);</div><div class="line"><span class="comment">// Solve the linear system A*x=b without the gradient.</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> x_val = SolveLinearSystem&lt;Eigen::PartialPivLU&gt;(A_val, b_val);</div><div class="line"><span class="comment">// Solve the linear system A*x=b, together with the gradient.</span></div><div class="line"><span class="comment">// x_ad contains both the value of the solution A*x=b, together with its</span></div><div class="line"><span class="comment">// gradient.</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> x_ad = SolveLinearSystem&lt;Eigen::PartialPivLU&gt;(A_ad, b_ad);</div></div><!-- fragment --> </div></td></tr>
<tr class="memitem:a579e00c8ae91d6bcdb32eb4d723eba73"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename, int... &gt; typename LinearSolverType, typename DerivedA , typename DerivedB &gt; </td></tr>
<tr class="memitem:a579e00c8ae91d6bcdb32eb4d723eba73"><td class="memTemplItemLeft" align="right" valign="top">internal::Solution&lt; DerivedA, DerivedB &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a579e00c8ae91d6bcdb32eb4d723eba73">SolveLinearSystem</a> (const Eigen::MatrixBase&lt; DerivedA &gt; &amp;A, const Eigen::MatrixBase&lt; DerivedB &gt; &amp;b)</td></tr>
<tr class="memdesc:a579e00c8ae91d6bcdb32eb4d723eba73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves system A*x=b.  <a href="#a579e00c8ae91d6bcdb32eb4d723eba73">More...</a><br /></td></tr>
<tr class="separator:a579e00c8ae91d6bcdb32eb4d723eba73"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="af0249a3cc715341eaf27380878eb1df9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0249a3cc715341eaf27380878eb1df9">&#9670;&nbsp;</a></span>AutoDiffMatrixType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake_1_1math.html#af0249a3cc715341eaf27380878eb1df9">AutoDiffMatrixType</a> =  Eigen::Matrix&lt; Eigen::AutoDiffScalar&lt;Eigen::Matrix&lt;typename Derived::Scalar, nq, 1&gt; &gt;, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime, 0, Derived::MaxRowsAtCompileTime, Derived::MaxColsAtCompileTime&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The appropriate AutoDiffScalar matrix type given the value type and the number of derivatives at compile time. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a2dc222f66e0f5092e8cfe879f24874b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dc222f66e0f5092e8cfe879f24874b2">&#9670;&nbsp;</a></span>KnotVectorType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacedrake_1_1math.html#a2dc222f66e0f5092e8cfe879f24874b2">KnotVectorType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enum representing types of knot vectors. </p>
<p>"Uniform" refers to the spacing between the knots. "Clamped" indicates that the first and last knots have multiplicity equal to the order of the spline.</p>
<p>Reference: <a href="http://web.mit.edu/hyperbook/Patrikalakis-Maekawa-Cho/node17.html">http://web.mit.edu/hyperbook/Patrikalakis-Maekawa-Cho/node17.html</a> </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a2dc222f66e0f5092e8cfe879f24874b2a3ea9f7aca87fd7b64469a0d1119f0b50"></a>kUniform&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2dc222f66e0f5092e8cfe879f24874b2af1b493f6e43ce0d1371533ee4f1199d0"></a>kClampedUniform&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a33f67c50b300b399043477a51861400a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33f67c50b300b399043477a51861400a">&#9670;&nbsp;</a></span>NumericalGradientMethod</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacedrake_1_1math.html#a33f67c50b300b399043477a51861400a">NumericalGradientMethod</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a33f67c50b300b399043477a51861400aae7c3602dce09c755e09250077a601a51"></a>kForward&#160;</td><td class="fielddoc"><p>Compute the gradient as (f(x + Δx) - f(x)) / Δx, with Δx &gt; 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="a33f67c50b300b399043477a51861400aa5cc7cc1518100eae9e3f2d83673a74ed"></a>kBackward&#160;</td><td class="fielddoc"><p>Compute the gradient as (f(x) - f(x - Δx)) / Δx, with Δx &gt; 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="a33f67c50b300b399043477a51861400aa39209ccaab9620e08ec04483c22a7eda"></a>kCentral&#160;</td><td class="fielddoc"><p>Compute the gradient as (f(x + Δx) - f(x - Δx)) / (2Δx), with Δx &gt; 0. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="adc96357c54438cadae5c8aefbd16713d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc96357c54438cadae5c8aefbd16713d">&#9670;&nbsp;</a></span>AreQuaternionsEqualForOrientation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::math::AreQuaternionsEqualForOrientation </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Quaternion&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>quat1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Quaternion&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>quat2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>tolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function tests whether two quaternions represent the same orientation. </p>
<p>This function converts each quaternion to its canonical form and tests whether the absolute value of the difference in corresponding elements of these canonical quaternions is within tolerance. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">quat1</td><td>Quaternion [w, x, y, z] that relates two right-handed orthogonal unitary bases e.g., Ax, Ay, Az (A) to Bx, By, Bz (B). Note: quat is analogous to the rotation matrix R_AB. </td></tr>
    <tr><td class="paramname">quat2</td><td>Quaternion with a description analogous to quat1. </td></tr>
    <tr><td class="paramname">tolerance</td><td>Nonnegative real scalar defining the allowable difference in the orientation described by quat1 and quat2. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if quat1 and quat2 represent the same orientation (to within tolerance), otherwise <code>false</code>. </dd></dl>

</div>
</div>
<a id="a8c66e16411c4f0d53e005658a49ccf6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c66e16411c4f0d53e005658a49ccf6a">&#9670;&nbsp;</a></span>BalanceQuadraticForms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd drake::math::BalanceQuadraticForms </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given two quadratic forms, x'Sx &gt; 0 and x'Px, (with P symmetric and full rank), finds a change of variables x = Ty, which simultaneously diagonalizes both forms (as inspired by "balanced truncation" in model-order reduction [1]). </p>
<p>In this note, we use abs(M) to indicate the elementwise absolute value.</p>
<p>Adapting from [1], we observe that there is a family of coordinate systems that can simultaneously diagonalize T'ST and T'PT. Using D to denote a diagonal matrix, we call the result S-normal if T'ST = I and abs(T'PT) = D⁻², call it P-normal if T'ST = D² and abs(T'PT) = I, and call it "balanced" if T'ST = D and abs(T'PT) = D⁻¹. Note that if P &gt; 0, then T'PT = D⁻¹.</p>
<p>We find x=Ty such that T'ST = D and abs(T'PT) = D⁻¹, where D is diagonal. The recipe is:</p><ul>
<li>Factorize S = LL', and choose R=L⁻¹.</li>
<li>Take svd(RPR') = UΣV', and note that U=V for positive definite matrices, and V is U up to a sign flip of the singular vectors for all symmetric matrices.</li>
<li>Choose T = R'U Σ^{-1/4}, where the matrix exponent can be taken elementwise because Σ is diagonal. This gives T'ST = Σ^{-1/2} (by using U'U=I), and abs(T'PT) = Σ^{1/2}. If P &gt; 0, then T'PT = Σ^{1/2}.</li>
</ul>
<p>Note that the numerical "balancing" can address the absolute scaling of the quadratic forms, but not the relative scaling. To understand this, consider the scalar case: we have two quadratic functions, sx² and px², with s&gt;0, p&gt;0. We'd like to choose x=Ty so that sT²y² and pT²y² are "balanced" (we'd like them both to be close to y²). We'll choose T=p^{-1/4}s^{-1/4}, which gives sx² = sqrt(s/p)y², and px² = sqrt(p/s)y². For instance if s=1e8 and p=1e8, then t=1e-4 and st^2 = pt^2 = 1. But if s=10, p=1e7, then t=0.01, and st^2 = 1e-3, pt^2 = 1e3.</p>
<p>In the matrix case, the absolute scaling is important &ndash; it ensures that the two quadratic forms have the same matrix condition number and makes them as close as possible to 1. Besides absolute scaling, in the matrix case the balancing transform diagonalizes both quadratic forms.</p>
<p>[1] B. Moore, “Principal component analysis in linear systems: Controllability, observability, and model reduction,” IEEE Trans. Automat. Contr., vol. 26, no. 1, pp. 17–32, Feb. 1981. </p>

</div>
</div>
<a id="a98411a94334e6d40ef2ca10bfc053118"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98411a94334e6d40ef2ca10bfc053118">&#9670;&nbsp;</a></span>CalculateAngularVelocityExpressedInBFromQuaternionDt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt;T&gt; drake::math::CalculateAngularVelocityExpressedInBFromQuaternionDt </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Quaternion&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>quat_AB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#af7e96394aef85f13f3fc84d3c3c238b3">Vector4</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>quatDt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function calculates angular velocity from a quaternion and its time- derivative. </p>
<p>Algorithm from [Kane, 1983] Section 1.13, Pages 58-59.</p>
<ul>
<li>[Kane, 1983] "Spacecraft Dynamics," McGraw-Hill Book Co., New York, 1983. (with P. W. Likins and D. A. Levinson). Available for free .pdf download: <a href="https://ecommons.cornell.edu/handle/1813/637">https://ecommons.cornell.edu/handle/1813/637</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">quat_AB</td><td>Quaternion [w, x, y, z] that relates two right-handed orthogonal unitary bases e.g., Ax, Ay, Az (A) to Bx, By, Bz (B). Note: quat_AB is analogous to the rotation matrix R_AB. </td></tr>
    <tr><td class="paramname">quatDt</td><td>Time-derivative of <code>quat_AB</code>, i.e. [ẇ, ẋ, ẏ, ż]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">w_AB_B</td><td>B's angular velocity in A, expressed in B. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a06541dcb249b4b951ea73d45d2067337"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06541dcb249b4b951ea73d45d2067337">&#9670;&nbsp;</a></span>CalculateQuaternionDtConstraintViolation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T drake::math::CalculateQuaternionDtConstraintViolation </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Quaternion&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>quat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#af7e96394aef85f13f3fc84d3c3c238b3">Vector4</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>quatDt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function calculates how well a quaternion and its time-derivative satisfy the quaternion time-derivative constraint specified in [Kane, 1983] Section 1.13, equations 12-13, page 59. </p>
<p>For a quaternion [w, x, y, z], the quaternion must satisfy: w^2 + x^2 + y^2 + z^2 = 1, hence its time-derivative must satisfy: 2*(w*ẇ + x*ẋ + y*ẏ + z*ż) = 0.</p>
<ul>
<li>[Kane, 1983] "Spacecraft Dynamics," McGraw-Hill Book Co., New York, 1983. (with P. W. Likins and D. A. Levinson). Available for free .pdf download: <a href="https://ecommons.cornell.edu/handle/1813/637">https://ecommons.cornell.edu/handle/1813/637</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">quat</td><td>Quaternion [w, x, y, z] that relates two right-handed orthogonal unitary bases e.g., Ax, Ay, Az (A) to Bx, By, Bz (B). Note: A quaternion like quat_AB is analogous to the rotation matrix R_AB. </td></tr>
    <tr><td class="paramname">quatDt</td><td>Time-derivative of <code>quat</code>, i.e., [ẇ, ẋ, ẏ, ż]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">quaternionDt_constraint_violation</td><td>The amount the time- derivative of the quaternion constraint has been violated, which may be positive or negative (0 means the constraint is perfectly satisfied). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab4bf90f81dcf655d829ed2d718251215"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4bf90f81dcf655d829ed2d718251215">&#9670;&nbsp;</a></span>CalculateQuaternionDtFromAngularVelocityExpressedInB()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#af7e96394aef85f13f3fc84d3c3c238b3">Vector4</a>&lt;T&gt; drake::math::CalculateQuaternionDtFromAngularVelocityExpressedInB </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Quaternion&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>quat_AB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>w_AB_B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function calculates a quaternion's time-derivative from its quaternion and angular velocity. </p>
<p>Algorithm from [Kane, 1983] Section 1.13, Pages 58-59.</p>
<ul>
<li>[Kane, 1983] "Spacecraft Dynamics," McGraw-Hill Book Co., New York, 1983. (With P. W. Likins and D. A. Levinson). Available for free .pdf download: <a href="https://ecommons.cornell.edu/handle/1813/637">https://ecommons.cornell.edu/handle/1813/637</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">quat_AB</td><td>Quaternion [w, x, y, z] that relates two right-handed orthogonal unitary bases e.g., Ax, Ay, Az (A) to Bx, By, Bz (B). Note: quat_AB is analogous to the rotation matrix R_AB. </td></tr>
    <tr><td class="paramname">w_AB_B</td><td>B's angular velocity in A, expressed in B. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">quatDt</td><td>Time-derivative of quat_AB, i.e., [ẇ, ẋ, ẏ, ż]. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad276064dcd8cb5e77d3dc41140840e8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad276064dcd8cb5e77d3dc41140840e8c">&#9670;&nbsp;</a></span>CalculateReflectedGrayCodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdrake_1_1math_1_1_gray_codes_matrix.html">GrayCodesMatrix</a>&lt;NumDigits&gt;::type drake::math::CalculateReflectedGrayCodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>num_digits</em> = <code>NumDigits</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a matrix whose i'th row is the Gray code for integer i. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">NumDigits</td><td>The number of digits in the Gray code. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_digits</td><td>The number of digits in the Gray code. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M. M is a matrix of size 2ᵏ x k, where <code>k</code> is <code>num_digits</code>. M.row(i) is the Gray code for integer i. </dd></dl>

</div>
</div>
<a id="a5e37615af3b6facc6f7dec51323a628e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e37615af3b6facc6f7dec51323a628e">&#9670;&nbsp;</a></span>ClosestQuaternion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Quaternion&lt;Scalar&gt; drake::math::ClosestQuaternion </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Quaternion&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>q0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Quaternion&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>q1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a unit quaternion that represents the same orientation as <code>q1</code>, and has the "shortest" geodesic distance on the unit sphere to <code>q0</code>. </p>

</div>
</div>
<a id="a480ac0ac10adfac21eab2d72f8694704"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a480ac0ac10adfac21eab2d72f8694704">&#9670;&nbsp;</a></span>ComputeNumericalGradient()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;typename DerivedX::Scalar, DerivedY::RowsAtCompileTime, DerivedX::RowsAtCompileTime&gt; drake::math::ComputeNumericalGradient </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(const DerivedCalcX &amp;, DerivedY *y)&gt;&#160;</td>
          <td class="paramname"><em>calc_fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DerivedX &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_numerical_gradient_option.html">NumericalGradientOption</a> &amp;&#160;</td>
          <td class="paramname"><em>option</em> = <code><a class="el" href="classdrake_1_1math_1_1_numerical_gradient_option.html">NumericalGradientOption</a>{&#160;<a class="el" href="namespacedrake_1_1math.html#a33f67c50b300b399043477a51861400aae7c3602dce09c755e09250077a601a51">NumericalGradientMethod::kForward</a>}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the gradient of a function f(x) through numerical difference. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">calc_fun</td><td>calc_fun(x, &amp;y) computes the value of f(x), and stores the value in y. <code>calc_fun</code> is responsible for properly resizing the output <code>y</code> when it consists of an Eigen vector of Eigen::Dynamic size.</td></tr>
    <tr><td class="paramname">x</td><td>The point at which the numerical gradient is computed. </td></tr>
    <tr><td class="paramname">option</td><td>The options for computing numerical gradient. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DerivedX</td><td>an Eigen column vector. </td></tr>
    <tr><td class="paramname">DerivedY</td><td>an Eigen column vector. </td></tr>
    <tr><td class="paramname">DerivedCalcX</td><td>The type of x in the calc_fun. Must be an Eigen column vector. It is possible to have DerivedCalcX being different from DerivedX, for example, <code>calc_fun</code> could be <a class="el" href="classdrake_1_1solvers_1_1_evaluator_base.html" title="Provides an abstract interface to represent an expression, mapping a fixed or dynamic number of input...">solvers::EvaluatorBase</a>(const Eigen::Ref&lt;const Eigen::VectorXd&gt;&amp;, Eigen::VectorXd*), but <code>x</code> could be of type Eigen::VectorXd. TODO(hongkai.dai): understand why the default template DerivedCalcX = DerivedX doesn't compile when I instantiate ComputeNumericalGradient&lt;DerivedX, DerivedY&gt;(calc_fun, x); </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">gradient</td><td>a matrix of size x.rows() x y.rows(). gradient(i, j) is ∂f(i) / ∂x(j)</td></tr>
  </table>
  </dd>
</dl>
<p>Examples: </p><div class="fragment"><div class="line"><span class="comment">// Create a std::function from a lambda expression.</span></div><div class="line">std::function&lt;void (<span class="keyword">const</span> <a class="code" href="namespacedrake_1_1systems_1_1analysis_1_1test.html#a322dbcada3667894a629fe3f1a476f2a">Eigen::Vector2d</a>&amp;, Vector3d*)&gt; foo = [](<span class="keyword">const</span></div><div class="line"><a class="code" href="namespacedrake_1_1systems_1_1analysis_1_1test.html#a322dbcada3667894a629fe3f1a476f2a">Eigen::Vector2d</a>&amp; x, Vector3d*y) { (*y)(0) = x(0); (*y)(1) = x(0) * x(1);</div><div class="line">(*y)(2) = x(0) * <a class="code" href="namespacedrake_1_1symbolic.html#a90efdc7cf4be8bddc1fa365fb78b8e4a">std::sin</a>(x(1));};</div><div class="line">Eigen::Vector3d x_eval(1, 2, 3);</div><div class="line"><span class="keyword">auto</span> J = <a class="code" href="namespacedrake_1_1math.html#a480ac0ac10adfac21eab2d72f8694704">ComputeNumericalGradient</a>(foo, x_eval);</div><div class="line"><span class="comment">// Note that if we pass in a lambda to ComputeNumericalGradient, then</span></div><div class="line"><span class="comment">// ComputeNumericalGradient has to instantiate the template types explicitly,</span></div><div class="line"><span class="comment">// as in this example. The issue of template deduction with std::function is</span></div><div class="line"><span class="comment">// explained in</span></div><div class="line"><span class="comment">//</span></div><div class="line">https:<span class="comment">//stackoverflow.com/questions/48529410/template-arguments-deduction-failed-passing-func-pointer-to-stdfunction</span></div><div class="line"><span class="keyword">auto</span> bar = [](<span class="keyword">const</span> <a class="code" href="namespacedrake_1_1systems_1_1analysis_1_1test.html#a322dbcada3667894a629fe3f1a476f2a">Eigen::Vector2d</a>&amp; x, <a class="code" href="namespacedrake_1_1systems_1_1analysis_1_1test.html#a322dbcada3667894a629fe3f1a476f2a">Eigen::Vector2d</a>* y) {*y = x; };</div><div class="line"><span class="keyword">auto</span> J2 = <a class="code" href="namespacedrake_1_1math.html#a480ac0ac10adfac21eab2d72f8694704">ComputeNumericalGradient</a>&lt;<a class="code" href="namespacedrake_1_1systems_1_1analysis_1_1test.html#a322dbcada3667894a629fe3f1a476f2a">Eigen::Vector2d</a>,</div><div class="line"><a class="code" href="namespacedrake_1_1systems_1_1analysis_1_1test.html#a322dbcada3667894a629fe3f1a476f2a">Eigen::Vector2d</a>, <a class="code" href="namespacedrake_1_1systems_1_1analysis_1_1test.html#a322dbcada3667894a629fe3f1a476f2a">Eigen::Vector2d</a>&gt;(bar, <a class="code" href="namespacedrake_1_1systems_1_1analysis_1_1test.html#a322dbcada3667894a629fe3f1a476f2a">Eigen::Vector2d</a>(2, 3));</div></div><!-- fragment --> 
</div>
</div>
<a id="a527ab4851f7449ff47374855c79b8413"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a527ab4851f7449ff47374855c79b8413">&#9670;&nbsp;</a></span>ContinuousAlgebraicRiccatiEquation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd drake::math::ContinuousAlgebraicRiccatiEquation </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the unique stabilizing solution S to the continuous-time algebraic Riccati equation: </p>
<p class="formulaDsp">
\[ S A + A&#39; S - S B R^{-1} B&#39; S + Q = 0 \]
</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if R is not positive definite.</td></tr>
  </table>
  </dd>
</dl>
<p>Based on the Matrix Sign Function method outlined in this paper: <a href="http://www.engr.iupui.edu/~skoskie/ECE684/Riccati_algorithms.pdf">http://www.engr.iupui.edu/~skoskie/ECE684/Riccati_algorithms.pdf</a> </p>

</div>
</div>
<a id="a44ee9a3e4b4fa7d4359e3b05af563979"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44ee9a3e4b4fa7d4359e3b05af563979">&#9670;&nbsp;</a></span>ContinuousAlgebraicRiccatiEquation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd drake::math::ContinuousAlgebraicRiccatiEquation </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::LLT&lt; Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>R_cholesky</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is functionally the same as ContinuousAlgebraicRiccatiEquation(A, B, Q, R). </p>
<p>The Cholesky decomposition of R is passed in instead of R. </p>

</div>
</div>
<a id="a7ad7ab2561d0c05591eb9720adccc7d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ad7ab2561d0c05591eb9720adccc7d5">&#9670;&nbsp;</a></span>ConvertTimeDerivativeToOtherFrame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt;typename v_Type::Scalar&gt; drake::math::ConvertTimeDerivativeToOtherFrame </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; v_Type &gt; &amp;&#160;</td>
          <td class="paramname"><em>v_E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DtB_v_Type &gt; &amp;&#160;</td>
          <td class="paramname"><em>DtB_v_E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; w_AB_Type &gt; &amp;&#160;</td>
          <td class="paramname"><em>w_AB_E</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given ᴮd/dt(v) (the time derivative in frame B of an arbitrary 3D vector v) and given ᴬωᴮ (frame B's angular velocity in another frame A), this method computes ᴬd/dt(v) (the time derivative in frame A of v) by: ᴬd/dt(v) = ᴮd/dt(v) + ᴬωᴮ x v. </p>
<p>This mathematical operation is known as the "Transport Theorem" or the "Golden Rule for Vector Differentiation" [Mitiguy 2016, §7.3]. It was discovered by Euler in 1758. Its explicit notation with superscript frames was invented by Thomas Kane in 1950. Its use as the defining property of angular velocity was by Mitiguy in 1993.</p>
<p>In source code and comments, we use the following monogram notations: DtA_v = ᴬd/dt(v) denotes the time derivative in frame A of the vector v. DtA_v_E = [ᴬd/dt(v)]_E denotes the time derivative in frame A of vector v, with the resulting new vector quantity expressed in a frame E.</p>
<p>In source code, this mathematical operation is performed with all vectors expressed in the same frame E as [ᴬd/dt(v)]ₑ = [ᴮd/dt(v)]ₑ + [ᴬωᴮ]ₑ x [v]ₑ which in monogram notation is: </p><pre>
  DtA_v_E = DtB_v_E + w_AB_E x v_E
</pre><p>[Mitiguy 2016] Mitiguy, P., 2016. Advanced Dynamics &amp; Motion Simulation. </p>

</div>
</div>
<a id="a296872692791b1e6d9e27311fc55a694"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a296872692791b1e6d9e27311fc55a694">&#9670;&nbsp;</a></span>DecomposePositiveQuadraticForm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;Eigen::MatrixXd, Eigen::MatrixXd&gt; drake::math::DecomposePositiveQuadraticForm </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrite a quadratic form xᵀQx + bᵀx + c to (Rx+d)ᵀ(Rx+d) where. </p>
<pre>
RᵀR = Q
Rᵀd = b / 2
dᵀd = c
</pre><p>This decomposition requires the matrix </p><pre>
⌈Q     b/2⌉
⌊bᵀ/2    c⌋
</pre><p> to be positive semidefinite.</p>
<p>We return R and d with the minimal number of rows, namely the rows of R and d equal to the rank of the matrix </p><pre>
⌈Q     b/2⌉
⌊bᵀ/2    c⌋
</pre><p>Notice that R might have more rows than Q, For example, the quadratic expression x² + 2x + 5 =(x+1)² + 2², it can be decomposed as </p><pre>
⎛⌈1⌉ * x + ⌈1⌉⎞ᵀ * ⎛⌈1⌉ * x + ⌈1⌉⎞
⎝⌊0⌋       ⌊2⌋⎠    ⎝⌊0⌋       ⌊2⌋⎠
</pre><p> Here R has 2 rows while Q only has 1 row.</p>
<p>On the other hand the quadratic expression x² + 2x + 1 can be decomposed as (x+1) * (x+1), where R has 1 row, same as Q.</p>
<p>Also notice that this decomposition is not unique. For example, with any permutation matrix P, we can define </p><pre>
R₁ = P*R
d₁ = P*d
</pre><p> Then (R₁*x+d₁)ᵀ(R₁*x+d₁) gives the same quadratic form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Q</td><td>The square matrix. </td></tr>
    <tr><td class="paramname">b</td><td>The vector containing the linear coefficients. </td></tr>
    <tr><td class="paramname">c</td><td>The constant term. </td></tr>
    <tr><td class="paramname">tol</td><td>We will determine if this quadratic form is always non-negative, by checking the Eigen values of the matrix [Q b/2] [bᵀ/2 c] are all greater than -tol. <br />
 <em>Default:</em> is 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">(R,d).</td><td>R and d have the same number of rows. R.cols() == x.rows(). R.rows() equals to the rank of the matrix <pre>
   [Q    b/2]
   [bᵀ/2   c]
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>1. The quadratic form is always non-negative, namely the matrix <pre>
        [Q    b/2]
        [bᵀ/2   c]
        </pre> is positive semidefinite.<ol type="1">
<li><code>Q</code> and <code>b</code> are of the correct size.</li>
<li><code>tol</code> is non-negative. </li>
</ol>
</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the precondition is not satisfied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2fccff311f09a5a35afac17388541c7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fccff311f09a5a35afac17388541c7f">&#9670;&nbsp;</a></span>DecomposePSDmatrixIntoXtransposeTimesX()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd drake::math::DecomposePSDmatrixIntoXtransposeTimesX </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>zero_tol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For a symmetric positive semidefinite matrix Y, decompose it into XᵀX, where the number of rows in X equals to the rank of Y. </p>
<p>Notice that this decomposition is not unique. For any orthonormal matrix U, s.t UᵀU = identity, X_prime = UX also satisfies X_primeᵀX_prime = Y. Here we only return one valid decomposition. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Y</td><td>A symmetric positive semidefinite matrix. </td></tr>
    <tr><td class="paramname">zero_tol</td><td>We will need to check if some value (for example, the absolute value of Y's eigenvalues) is smaller than zero_tol. If it is, then we deem that value as 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">X.</td><td>The matrix X satisfies XᵀX = Y and X.rows() = rank(Y). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>1. Y is positive semidefinite.<ol type="1">
<li>zero_tol is non-negative. </li>
</ol>
</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>when the pre-conditions are not satisfied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>We only use the lower triangular part of Y. </dd></dl>

</div>
</div>
<a id="ae918eb0a5749b337a92058e92bd039c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae918eb0a5749b337a92058e92bd039c9">&#9670;&nbsp;</a></span>DifferentiableNorm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Derived::Scalar drake::math::DifferentiableNorm </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The 2-norm function |x| is not differentiable at x=0 (its gradient is x/|x|, which has a division-by-zero problem). </p>
<p>On the other hand, x=0 happens very often. Hence we return a subgradient x/(|x| + ε) when x is almost 0, and returns the original gradient, x/|x|, otherwise. </p>

</div>
</div>
<a id="abdc21793a127ffbebcb28a2442123390"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdc21793a127ffbebcb28a2442123390">&#9670;&nbsp;</a></span>DiscardGradient() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; !std::is_same_v&lt;typename Derived::Scalar, double&gt;, Eigen::Matrix&lt;typename Derived::Scalar::Scalar, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime, 0, Derived::MaxRowsAtCompileTime, Derived::MaxColsAtCompileTime&gt; &gt; drake::math::DiscardGradient </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>auto_diff_matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>B = DiscardGradient(A)</code> enables casting from a matrix of AutoDiffScalars to AutoDiffScalar::Scalar type, explicitly throwing away any gradient information. </p>
<p>For a matrix of type, e.g. <code>MatrixX&lt;AutoDiffXd&gt; A</code>, the comparable operation <code>B = A.cast&lt;double&gt;()</code> should (and does) fail to compile. Use <code>DiscardGradient(A)</code> if you want to force the cast (and explicitly declare that information is lost).</p>
<p>This method is overloaded to permit the user to call it for double types and AutoDiffScalar types (to avoid the calling function having to handle the two cases differently).</p>
<p>See <a class="el" href="namespacedrake_1_1math.html#abb0cd738c70309748ff3cbc5c6b2d50e" title="Extracts the value() portion from a matrix of AutoDiffScalar entries.">ExtractValue()</a> for a note on similar Drake functions.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacedrake_1_1math.html#abb0cd738c70309748ff3cbc5c6b2d50e" title="Extracts the value() portion from a matrix of AutoDiffScalar entries.">ExtractValue()</a>, <a class="el" href="namespacedrake_1_1math.html#a1ea20cd66ae96c7e1390e7ebb3e2f8a8" title="B = DiscardZeroGradient(A, precision) enables casting from a matrix of AutoDiffScalars to AutoDiffSca...">DiscardZeroGradient()</a> </dd></dl>

</div>
</div>
<a id="a04e58f14dcca01f3684a820cff4c61b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04e58f14dcca01f3684a820cff4c61b0">&#9670;&nbsp;</a></span>DiscardGradient() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_same_v&lt;typename Derived::Scalar, double&gt;, const Eigen::MatrixBase&lt;Derived&gt;&amp;&gt; drake::math::DiscardGradient </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacedrake_1_1math.html#abdc21793a127ffbebcb28a2442123390" title="B = DiscardGradient(A) enables casting from a matrix of AutoDiffScalars to AutoDiffScalar::Scalar typ...">DiscardGradient()</a>. </dd></dl>

</div>
</div>
<a id="a1ea20cd66ae96c7e1390e7ebb3e2f8a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ea20cd66ae96c7e1390e7ebb3e2f8a8">&#9670;&nbsp;</a></span>DiscardZeroGradient() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; !std::is_same_v&lt;typename Derived::Scalar, double&gt;, Eigen::Matrix&lt;typename Derived::Scalar::Scalar, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime, 0, Derived::MaxRowsAtCompileTime, Derived::MaxColsAtCompileTime&gt; &gt; drake::math::DiscardZeroGradient </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>auto_diff_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Eigen::NumTraits&lt; typename Derived::Scalar::Scalar &gt;::Real &amp;&#160;</td>
          <td class="paramname"><em>precision</em> = <code>Eigen::NumTraits&lt;typename&#160;Derived::Scalar::Scalar&gt;::dummy_precision()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>B = DiscardZeroGradient(A, precision)</code> enables casting from a matrix of AutoDiffScalars to AutoDiffScalar::Scalar type, but first checking that the gradient matrix is empty or zero. </p>
<p>For a matrix of type, e.g. <code>MatrixX&lt;AutoDiffXd&gt; A</code>, the comparable operation <code>B = A.cast&lt;double&gt;()</code> should (and does) fail to compile. Use <code>DiscardZeroGradient(A)</code> if you want to force the cast (and the check).</p>
<p>This method is overloaded to permit the user to call it for double types and AutoDiffScalar types (to avoid the calling function having to handle the two cases differently).</p>
<p>See <a class="el" href="namespacedrake_1_1math.html#abb0cd738c70309748ff3cbc5c6b2d50e" title="Extracts the value() portion from a matrix of AutoDiffScalar entries.">ExtractValue()</a> for a note on similar Drake functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">precision</td><td>is passed to Eigen's isZero(precision) to evaluate whether the gradients are zero. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the gradients were not empty nor zero. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacedrake_1_1math.html#abdc21793a127ffbebcb28a2442123390" title="B = DiscardGradient(A) enables casting from a matrix of AutoDiffScalars to AutoDiffScalar::Scalar typ...">DiscardGradient()</a> </dd></dl>

</div>
</div>
<a id="a2f4c633cee6230932aa3be941609ebed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f4c633cee6230932aa3be941609ebed">&#9670;&nbsp;</a></span>DiscardZeroGradient() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_same_v&lt;typename Derived::Scalar, double&gt;, const Eigen::MatrixBase&lt;Derived&gt;&amp;&gt; drake::math::DiscardZeroGradient </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>precision</em> = <code>0.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacedrake_1_1math.html#a1ea20cd66ae96c7e1390e7ebb3e2f8a8" title="B = DiscardZeroGradient(A, precision) enables casting from a matrix of AutoDiffScalars to AutoDiffSca...">DiscardZeroGradient()</a>. </dd></dl>

</div>
</div>
<a id="a8cd8a0787e886faf633f2c1f5be2365e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cd8a0787e886faf633f2c1f5be2365e">&#9670;&nbsp;</a></span>DiscreteAlgebraicRiccatiEquation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd drake::math::DiscreteAlgebraicRiccatiEquation </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the unique stabilizing solution X to the discrete-time algebraic Riccati equation: </p>
<p>AᵀXA − X − AᵀXB(BᵀXB + R)⁻¹BᵀXA + Q = 0</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if Q is not positive semi-definite. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if R is not positive definite.</td></tr>
  </table>
  </dd>
</dl>
<p>Based on the Schur Vector approach outlined in this paper: "On the Numerical Solution of the Discrete-Time Algebraic Riccati Equation" by Thrasyvoulos Pappas, Alan J. Laub, and Nils R. Sandell </p>

</div>
</div>
<a id="aa957c0c1b13e62f96ae84dd8abe45dd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa957c0c1b13e62f96ae84dd8abe45dd9">&#9670;&nbsp;</a></span>DiscreteAlgebraicRiccatiEquation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd drake::math::DiscreteAlgebraicRiccatiEquation </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the unique stabilizing solution X to the discrete-time algebraic Riccati equation: </p>
<p>AᵀXA − X − (AᵀXB + N)(BᵀXB + R)⁻¹(BᵀXA + Nᵀ) + Q = 0</p>
<p>This is equivalent to solving the original DARE:</p>
<p>A₂ᵀXA₂ − X − A₂ᵀXB(BᵀXB + R)⁻¹BᵀXA₂ + Q₂ = 0</p>
<p>where A₂ and Q₂ are a change of variables:</p>
<p>A₂ = A − BR⁻¹Nᵀ and Q₂ = Q − NR⁻¹Nᵀ</p>
<p>This overload of the DARE is useful for finding the control law uₖ that minimizes the following cost function subject to xₖ₊₁ = Axₖ + Buₖ.</p>
<pre class="fragment">    ∞ [xₖ]ᵀ[Q  N][xₖ]
J = Σ [uₖ] [Nᵀ R][uₖ] ΔT
   k=0
</pre><p>This is a more general form of the following. The linear-quadratic regulator is the feedback control law uₖ that minimizes the following cost function subject to xₖ₊₁ = Axₖ + Buₖ:</p>
<pre class="fragment">    ∞
J = Σ (xₖᵀQxₖ + uₖᵀRuₖ) ΔT
   k=0
</pre><p>This can be refactored as:</p>
<pre class="fragment">    ∞ [xₖ]ᵀ[Q 0][xₖ]
J = Σ [uₖ] [0 R][uₖ] ΔT
   k=0
</pre><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if Q − NR⁻¹Nᵀ is not positive semi-definite. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if R is not positive definite. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a00f832c0837ee2ac76c713ed23440e8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00f832c0837ee2ac76c713ed23440e8e">&#9670;&nbsp;</a></span>dquat2rotmat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdrake_1_1math_1_1_gradient.html">drake::math::Gradient</a>&lt;Eigen::Matrix&lt;typename Derived::Scalar, 3, 3&gt;, <a class="el" href="namespacedrake.html#a07869e660ffe730425feca7595de2273">drake::kQuaternionSize</a>&gt;::type drake::math::dquat2rotmat </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>quaternion</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the gradient of the function that converts a unit length quaternion to a rotation matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">quaternion</td><td>A unit length quaternion [w;x;y;z] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The gradient </dd></dl>

</div>
</div>
<a id="aa02d13e3a0cbc27e905be533959b8d2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa02d13e3a0cbc27e905be533959b8d2a">&#9670;&nbsp;</a></span>drotmat2quat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdrake_1_1math_1_1_gradient.html">drake::math::Gradient</a>&lt; Eigen::Matrix&lt;typename DerivedR::Scalar, <a class="el" href="namespacedrake.html#a07869e660ffe730425feca7595de2273">drake::kQuaternionSize</a>, 1&gt;, DerivedDR::ColsAtCompileTime&gt;::type drake::math::drotmat2quat </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedR &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedDR &gt; &amp;&#160;</td>
          <td class="paramname"><em>dR</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the gradient of the function that converts rotation matrix to quaternion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">R</td><td>A 3 x 3 rotation matrix </td></tr>
    <tr><td class="paramname">dR</td><td>A 9 x N matrix, dR(i,j) is the gradient of R(i) w.r.t x_var(j) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The gradient G. G is a 4 x N matrix G(0,j) is the gradient of w w.r.t x_var(j) G(1,j) is the gradient of x w.r.t x_var(j) G(2,j) is the gradient of y w.r.t x_var(j) G(3,j) is the gradient of z w.r.t x_var(j) </dd></dl>

</div>
</div>
<a id="adee0d3618f370d3b31682a8ca479376e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adee0d3618f370d3b31682a8ca479376e">&#9670;&nbsp;</a></span>drotmat2rpy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdrake_1_1math_1_1_gradient.html">drake::math::Gradient</a>&lt; Eigen::Matrix&lt;typename DerivedR::Scalar, <a class="el" href="namespacedrake.html#aeab5b0d99cafc2f6ae5812128cea27a3">drake::kRpySize</a>, 1&gt;, DerivedDR::ColsAtCompileTime&gt;::type drake::math::drotmat2rpy </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedR &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedDR &gt; &amp;&#160;</td>
          <td class="paramname"><em>dR</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the gradient of the function that converts a rotation matrix to body-fixed z-y'-x'' Euler angles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">R</td><td>A 3 x 3 rotation matrix </td></tr>
    <tr><td class="paramname">dR</td><td>A 9 x N matrix, dR(i,j) is the gradient of R(i) w.r.t x(j) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The gradient G. G is a 3 x N matrix. G(0,j) is the gradient of roll w.r.t x(j) G(1,j) is the gradient of pitch w.r.t x(j) G(2,j) is the gradient of yaw w.r.t x(j) </dd></dl>

</div>
</div>
<a id="a099a62886c181d6f9b917f0215a1a947"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a099a62886c181d6f9b917f0215a1a947">&#9670;&nbsp;</a></span>ExtractGradient()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;typename Derived::Scalar::Scalar, Derived::SizeAtCompileTime, Eigen::Dynamic&gt; drake::math::ExtractGradient </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>auto_diff_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="classint.html">int</a> &gt;&#160;</td>
          <td class="paramname"><em>num_derivatives</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts the <code>derivatives()</code> portion from a matrix of AutoDiffScalar entries. </p>
<p>(Each entry contains a value and derivatives.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">auto_diff_matrix</td><td>An object whose Eigen type represents a matrix of AutoDiffScalar entries. </td></tr>
    <tr><td class="paramname">num_derivatives</td><td>(Optional) The number of derivatives to return in case the input matrix has none, which we interpret as <code>num_derivatives</code> zeroes. If <code>num_derivatives</code> is supplied and the input matrix has derivatives, the sizes must match. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">gradient_matrix</td><td>An Eigen::Matrix with number of rows equal to the total size (rows x cols) of the input matrix and number of columns equal to the number of derivatives. Each output row corresponds to one entry of the input matrix, in input row order.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Derived</td><td>An Eigen type representing a matrix with AutoDiffScalar entries. The type will be inferred from the type of the <code>auto_diff_matrix</code> parameter at the call site.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the input matrix has elements with inconsistent, non-zero numbers of derivatives. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if <code>num_derivatives</code> is specified but the input matrix has a different, non-zero number of derivatives. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abb0cd738c70309748ff3cbc5c6b2d50e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb0cd738c70309748ff3cbc5c6b2d50e">&#9670;&nbsp;</a></span>ExtractValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;typename Derived::Scalar::Scalar, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime&gt; drake::math::ExtractValue </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>auto_diff_matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts the <code>value()</code> portion from a matrix of AutoDiffScalar entries. </p>
<p>(Each entry contains a value and some derivatives.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">auto_diff_matrix</td><td>An object whose Eigen type represents a matrix of AutoDiffScalar entries. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">value</td><td>An Eigen::Matrix of the same dimensions as the input matrix, but containing only the value portion of each entry, without the derivatives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Derived</td><td>An Eigen type representing a matrix with AutoDiffScalar entries. The type will be inferred from the type of the <code>auto_diff_matrix</code> parameter at the call site.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Drake provides several similar functions: <a class="el" href="namespacedrake_1_1math.html#abdc21793a127ffbebcb28a2442123390" title="B = DiscardGradient(A) enables casting from a matrix of AutoDiffScalars to AutoDiffScalar::Scalar typ...">DiscardGradient()</a> is specialized so that it can be applied to a <code>Matrix&lt;T&gt;</code> where T could be an AutoDiffScalar or an ordinary double, in which case it returns the original matrix at no cost. <a class="el" href="namespacedrake_1_1math.html#a1ea20cd66ae96c7e1390e7ebb3e2f8a8" title="B = DiscardZeroGradient(A, precision) enables casting from a matrix of AutoDiffScalars to AutoDiffSca...">DiscardZeroGradient()</a> is similar but requires that the discarded gradient was zero. <a class="el" href="namespacedrake.html#aa9721f3a5897b05ef2168f7a6d886dc8" title="Returns the autodiff scalar&#39;s value() as a double.">drake::ExtractDoubleOrThrow()</a> has many specializations, including one for <code>Matrix&lt;AutoDiffScalar&gt;</code> that behaves identically to <a class="el" href="namespacedrake_1_1math.html#abb0cd738c70309748ff3cbc5c6b2d50e" title="Extracts the value() portion from a matrix of AutoDiffScalar entries.">ExtractValue()</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacedrake_1_1math.html#abdc21793a127ffbebcb28a2442123390" title="B = DiscardGradient(A) enables casting from a matrix of AutoDiffScalars to AutoDiffScalar::Scalar typ...">DiscardGradient()</a>, <a class="el" href="namespacedrake.html#aa9721f3a5897b05ef2168f7a6d886dc8" title="Returns the autodiff scalar&#39;s value() as a double.">drake::ExtractDoubleOrThrow()</a> </dd></dl>

</div>
</div>
<a id="a4360e58bcb10c6b20aa3e28fed7297fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4360e58bcb10c6b20aa3e28fed7297fb">&#9670;&nbsp;</a></span>GetDerivativeSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!std::is_same_v&lt;typename Derived::Scalar, double&gt;, <a class="el" href="classint.html">int</a>&gt;::type drake::math::GetDerivativeSize </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a matrix of AutoDiffScalars, returns the size of the derivatives. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">runtime_error</td><td>if some entry has different (non-zero) number of derivatives as the others. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a145b102b8109265146ea4a0c63596873"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a145b102b8109265146ea4a0c63596873">&#9670;&nbsp;</a></span>GetLinearSolver()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">internal::EigenLinearSolver&lt;LinearSolverType, DerivedA&gt; drake::math::GetLinearSolver </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedA &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the linear solver for a matrix A. </p>
<p>If A has scalar type of double or symbolic::Expressions, then the returned linear solver will have the same scalar type. If A has scalar type of Eigen::AutoDiffScalar, then the returned linear solver will have scalar type of double. See <a class="el" href="namespacedrake_1_1math.html#get_linear_solver">get_linear_solver</a> for more details. </p>

</div>
</div>
<a id="a5c5269630d172b12a31b34d6c98b4e64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c5269630d172b12a31b34d6c98b4e64">&#9670;&nbsp;</a></span>getSubMatrixGradient() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;typename Derived::Scalar, Eigen::Dynamic, Eigen::Dynamic&gt; drake::math::getSubMatrixGradient </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>dM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Derived::Index&#160;</td>
          <td class="paramname"><em>M_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>q_start</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Derived::Index&#160;</td>
          <td class="paramname"><em>q_subvector_size</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad4b8fed3ad399a2bd53630c3b5b6d335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4b8fed3ad399a2bd53630c3b5b6d335">&#9670;&nbsp;</a></span>getSubMatrixGradient() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdrake_1_1math_1_1_get_sub_matrix_gradient_array.html">GetSubMatrixGradientArray</a>&lt;QSubvectorSize, Derived, NRows, NCols&gt;::type drake::math::getSubMatrixGradient </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>dM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; <a class="el" href="classint.html">int</a>, NRows &gt; &amp;&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; <a class="el" href="classint.html">int</a>, NCols &gt; &amp;&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Derived::Index&#160;</td>
          <td class="paramname"><em>M_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>q_start</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Derived::Index&#160;</td>
          <td class="paramname"><em>q_subvector_size</em> = <code>QSubvectorSize</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a259ed4f41a444e8eed6a2a30998af53f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a259ed4f41a444e8eed6a2a30998af53f">&#9670;&nbsp;</a></span>getSubMatrixGradient() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdrake_1_1math_1_1_get_sub_matrix_gradient_single_element.html">GetSubMatrixGradientSingleElement</a>&lt;QSubvectorSize, Derived&gt;::type drake::math::getSubMatrixGradient </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>dM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Derived::Index&#160;</td>
          <td class="paramname"><em>M_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Derived::Index&#160;</td>
          <td class="paramname"><em>q_start</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Derived::Index&#160;</td>
          <td class="paramname"><em>q_subvector_size</em> = <code>QSubvectorSize</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab5390cdccf326541855e43a3dd5c2a9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5390cdccf326541855e43a3dd5c2a9d">&#9670;&nbsp;</a></span>GrayCodeToInteger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> drake::math::GrayCodeToInteger </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXi &gt; &amp;&#160;</td>
          <td class="paramname"><em>gray_code</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the Gray code to an integer. </p>
<p>For example (0, 0) -&gt; 0 (0, 1) -&gt; 1 (1, 1) -&gt; 2 (1, 0) -&gt; 3 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gray_code</td><td>The N-digit Gray code, where N is gray_code.rows() </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The integer represented by the Gray code <code>gray_code</code>. </dd></dl>

</div>
</div>
<a id="a6dce37732e3e532f7b87cd517789da7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dce37732e3e532f7b87cd517789da7f">&#9670;&nbsp;</a></span>hessian()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) drake::math::hessian </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a matrix of AutoDiffScalars from which the value, Jacobian, and Hessian of a function </p><p class="formulaDsp">
\[ f:\mathbb{R}^{n\times m}\rightarrow\mathbb{R}^{p\times q} \]
</p>
<p> (f: R^n*m -&gt; R^p*q) can be extracted. </p>
<p>The output is a matrix of nested AutoDiffScalars, being the result of calling <a class="el" href="namespacedrake_1_1math.html#a57457683becdddf605a55be881c065b4" title="Computes a matrix of AutoDiffScalars from which both the value and the Jacobian of a function  (f: R^...">jacobian</a> on a function that returns the output of <a class="el" href="namespacedrake_1_1math.html#a57457683becdddf605a55be881c065b4" title="Computes a matrix of AutoDiffScalars from which both the value and the Jacobian of a function  (f: R^...">jacobian</a>, called on <code>f</code>.</p>
<p><code>MaxChunkSizeOuter</code> and <code>MaxChunkSizeInner</code> can be used to control chunk sizes (see <a class="el" href="namespacedrake_1_1math.html#a57457683becdddf605a55be881c065b4" title="Computes a matrix of AutoDiffScalars from which both the value and the Jacobian of a function  (f: R^...">jacobian</a>).</p>
<p>See <a class="el" href="namespacedrake_1_1math.html#a57457683becdddf605a55be881c065b4" title="Computes a matrix of AutoDiffScalars from which both the value and the Jacobian of a function  (f: R^...">jacobian</a> for requirements on the function <code>f</code> and the argument <code>x</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>function </td></tr>
    <tr><td class="paramname">x</td><td>function argument value at which Hessian will be evaluated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AutoDiffScalar matrix corresponding to the Hessian of f evaluated at x </dd></dl>

</div>
</div>
<a id="a82d0a7052d08481add2e9086b98144dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82d0a7052d08481add2e9086b98144dd">&#9670;&nbsp;</a></span>HopfCoordinateToQuaternion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Eigen::Quaternion&lt;T&gt; drake::math::HopfCoordinateToQuaternion </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>psi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transforms Hopf coordinates to a quaternion w, x, y, z as w = cos(θ/2)cos(ψ/2) x = cos(θ/2)sin(ψ/2) y = sin(θ/2)cos(φ+ψ/2) z = sin(θ/2)sin(φ+ψ/2) The user can refer to equation 5 of Generating Uniform Incremental Grids on SO(3) Using the Hopf Fibration by Anna Yershova, Steven LaValle and Julie Mitchell, 2008. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">theta</td><td>The θ angle. </td></tr>
    <tr><td class="paramname">phi</td><td>The φ angle. </td></tr>
    <tr><td class="paramname">psi</td><td>The ψ angle. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac01d5aa7f58a485b614ddc46e7be7dd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac01d5aa7f58a485b614ddc46e7be7dd4">&#9670;&nbsp;</a></span>InitializeAutoDiff() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::math::InitializeAutoDiff </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedValue &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedGradient &gt; &amp;&#160;</td>
          <td class="paramname"><em>gradient</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixBase&lt; DerivedAutoDiff &gt; *&#160;</td>
          <td class="paramname"><em>auto_diff_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes an AutoDiff matrix given a matrix of values and a gradient matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value matrix. Will be accessed with a single index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gradient</td><td>The gradient matrix. The number of rows must match the total size (nrow x ncol) of the value matrix. Derivatives of value(j) should be stored in row j of the gradient matrix. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">auto_diff_matrix</td><td>The matrix of AutoDiffScalars. Will be resized as needed to have the same dimensions as the value matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a32942f788a67278f27426f128e50e0b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32942f788a67278f27426f128e50e0b2">&#9670;&nbsp;</a></span>InitializeAutoDiff() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::math::InitializeAutoDiff </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="classint.html">int</a> &gt;&#160;</td>
          <td class="paramname"><em>num_derivatives</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="classint.html">int</a> &gt;&#160;</td>
          <td class="paramname"><em>deriv_num_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixBase&lt; DerivedAutoDiff &gt; *&#160;</td>
          <td class="paramname"><em>auto_diff_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a single AutoDiff matrix given the corresponding value matrix. </p>
<p>Sets the values of <code>auto_diff_matrix</code> (after resizing if necessary) to be equal to <code>value</code>, and for each element i of <code>auto_diff_matrix</code>, resizes the derivatives vector to <code>num_derivatives</code> and sets derivative number <code>deriv_num_start</code> + i to one (all other elements of the derivative vector set to zero).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>a 'regular' matrix of values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_derivatives</td><td>(Optional) size of the derivatives vector <br />
 <em>Default:</em> total size of the value matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">deriv_num_start</td><td>(Optional) starting index into derivative vector (i.e. element deriv_num_start in derivative vector corresponds to value(0, 0)). <br />
 <em>Default:</em> 0 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">auto_diff_matrix</td><td>AutoDiff matrix set as described above </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a563f68724c579b35cdaf62b72c056e5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a563f68724c579b35cdaf62b72c056e5e">&#9670;&nbsp;</a></span>InitializeAutoDiff() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::math::InitializeAutoDiff </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixBase&lt; DerivedAutoDiff &gt; *&#160;</td>
          <td class="paramname"><em>auto_diff_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alternate signature provides default values for the number of derivatives (dynamic, determined at run time) and the starting index (0). </p>

</div>
</div>
<a id="af23c3981782540c98f8a1cb2abc59627"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af23c3981782540c98f8a1cb2abc59627">&#9670;&nbsp;</a></span>InitializeAutoDiff() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1math.html#af0249a3cc715341eaf27380878eb1df9">AutoDiffMatrixType</a>&lt;DerivedValue, DerivedGradient::ColsAtCompileTime&gt; drake::math::InitializeAutoDiff </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedValue &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedGradient &gt; &amp;&#160;</td>
          <td class="paramname"><em>gradient</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an AutoDiff matrix given a matrix of values and a gradient matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value matrix. Will be accessed with a single index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gradient</td><td>The gradient matrix. The number of rows must match the total size (nrow x ncol) of the value matrix. Derivatives of value(j) should be stored in row j of the gradient matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">auto_diff_matrix</td><td>The matrix of AutoDiffScalars. Will have the same dimensions as the value matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3e75abd55fa93ee21998756cf8c6e244"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e75abd55fa93ee21998756cf8c6e244">&#9670;&nbsp;</a></span>InitializeAutoDiff() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1math.html#af0249a3cc715341eaf27380878eb1df9">AutoDiffMatrixType</a>&lt;Derived, nq&gt; drake::math::InitializeAutoDiff </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="classint.html">int</a> &gt;&#160;</td>
          <td class="paramname"><em>num_derivatives</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="classint.html">int</a> &gt;&#160;</td>
          <td class="paramname"><em>deriv_num_start</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a single AutoDiff matrix given the corresponding value matrix. </p>
<p>Creates an AutoDiff matrix that matches <code>value</code> in size with derivative of compile time size <code>nq</code> and runtime size <code>num_derivatives</code>. Sets its values to be equal to <code>value</code>, and for each element i of <code>auto_diff_matrix</code>, sets derivative number <code>deriv_num_start</code> + i to one (all other derivatives set to zero).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>'regular' matrix of values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_derivatives</td><td>(Optional) size of the derivatives vector <br />
 <em>Default:</em> total size of the value matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">deriv_num_start</td><td>(Optional) starting index into derivative vector (i.e. element deriv_num_start in derivative vector corresponds to matrix(0, 0)). <br />
 <em>Default:</em> 0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">auto_diff_matrix</td><td>The result as described above. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad148a2735129010d96646652ec1f4986"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad148a2735129010d96646652ec1f4986">&#9670;&nbsp;</a></span>InitializeAutoDiffTuple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;<a class="el" href="namespacedrake_1_1math.html#af0249a3cc715341eaf27380878eb1df9">AutoDiffMatrixType</a>&lt; Deriveds, internal::total_size_at_compile_time&lt;Deriveds...&gt;)&gt;...&gt; drake::math::InitializeAutoDiffTuple </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Deriveds &gt; &amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6eb0d39dab703d87f0f582cf310c6134"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eb0d39dab703d87f0f582cf310c6134">&#9670;&nbsp;</a></span>intRange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;<a class="el" href="classint.html">int</a>, Size&gt; drake::math::intRange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>start</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a88a6d40e458bc9f766f33b819a7b4900"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88a6d40e458bc9f766f33b819a7b4900">&#9670;&nbsp;</a></span>is_quaternion_in_canonical_form()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::math::is_quaternion_in_canonical_form </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Quaternion&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>quat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function tests whether a quaternion is in "canonical form" meaning that it tests whether the quaternion [w, x, y, z] has a non-negative w value. </p>
<p>Example: [-0.3, +0.4, +0.5, +0.707] is not in canonical form. Example: [+0.3, -0.4, -0.5, -0.707] is in canonical form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">quat</td><td>Quaternion [w, x, y, z] that relates two right-handed orthogonal unitary bases e.g., Ax, Ay, Az (A) to Bx, By, Bz (B). Note: quat is analogous to the rotation matrix R_AB. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if quat.w() is nonnegative (in canonical form), else <code>false</code>. </dd></dl>

</div>
</div>
<a id="a3b38bdfc1e3df8662c8726bc89a08ed0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b38bdfc1e3df8662c8726bc89a08ed0">&#9670;&nbsp;</a></span>IsBothQuaternionAndQuaternionDtOK()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::math::IsBothQuaternionAndQuaternionDtOK </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Quaternion&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>quat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#af7e96394aef85f13f3fc84d3c3c238b3">Vector4</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>quatDt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>tolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function tests if a quaternion satisfies the time-derivative constraint specified in [Kane, 1983] Section 1.13, equation 13, page 59. </p>
<p>A quaternion [w, x, y, z] must satisfy w^2 + x^2 + y^2 + z^2 = 1, hence its time-derivative must satisfy 2*(w*ẇ + x*ẋ + y*ẏ + z*ż) = 0. Note: To accurately test whether the time-derivative quaternion constraint is satisfied, the quaternion constraint is also tested to be accurate.</p>
<ul>
<li>[Kane, 1983] "Spacecraft Dynamics," McGraw-Hill Book Co., New York, 1983. (with P. W. Likins and D. A. Levinson). Available for free .pdf download: <a href="https://ecommons.cornell.edu/handle/1813/637">https://ecommons.cornell.edu/handle/1813/637</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">quat</td><td>Quaternion [w, x, y, z] that relates two right-handed orthogonal unitary bases e.g., Ax, Ay, Az (A) to Bx, By, Bz (B). Note: A quaternion like quat_AB is analogous to the rotation matrix R_AB. </td></tr>
    <tr><td class="paramname">quatDt</td><td>Time-derivative of <code>quat</code>, i.e., [ẇ, ẋ, ẏ, ż]. </td></tr>
    <tr><td class="paramname">tolerance</td><td>Tolerance for quaternion constraints. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if both of the two previous constraints are within tolerance. </dd></dl>

</div>
</div>
<a id="a8a6d10bc0b3dfc5902d0a06f186dba8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a6d10bc0b3dfc5902d0a06f186dba8f">&#9670;&nbsp;</a></span>IsPositiveDefinite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::math::IsPositiveDefinite </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eigenvalue_tolerance</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>symmetry_tolerance</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a matrix is symmetric (with tolerance <code>symmetry_tolerance</code> &ndash;. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacedrake_1_1math.html#a84760cbea23b50efdbe9a85f3967f098" title="Determines if a matrix is symmetric.">IsSymmetric</a>) and has <a class="el" href="namespacedrake.html#adcc2d90ce6051e150effadd72fac548c" title="Checks truth for all elements in matrix m.">all</a> eigenvalues greater than <code>eigenvalue_tolerance</code>. <code>eigenvalue_tolerance</code> must be &gt;= 0 &ndash; where 0 implies positive semi-definite (but is of course subject to <a class="el" href="namespacedrake.html#adcc2d90ce6051e150effadd72fac548c" title="Checks truth for all elements in matrix m.">all</a> of the pitfalls of floating point).</dd></dl>
<p>To consider the numerical robustness of the eigenvalue estimation, we specifically check that min_eigenvalue &gt;= eigenvalue_tolerance * max(1, max_abs_eigenvalue). </p>

</div>
</div>
<a id="a2e47f892f2417dfc861a095328019361"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e47f892f2417dfc861a095328019361">&#9670;&nbsp;</a></span>IsQuaternionAndQuaternionDtEqualAngularVelocityExpressedInB()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::math::IsQuaternionAndQuaternionDtEqualAngularVelocityExpressedInB </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Quaternion&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>quat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#af7e96394aef85f13f3fc84d3c3c238b3">Vector4</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>quatDt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>w_B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>tolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function tests if a quaternion and a quaternions time-derivative can calculate and match an angular velocity to within a tolerance. </p>
<p>Note: This function first tests if the quaternion [w, x, y, z] satisfies w^2 + x^2 + y^2 + z^2 = 1 (to within tolerance) and if its time-derivative satisfies w*ẇ + x*ẋ + y*ẏ + z*ż = 0 (to within tolerance). Lastly, it tests if each element of the angular velocity calculated from quat and quatDt is within tolerance of w_B (described below). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">quat</td><td>Quaternion [w, x, y, z] that relates two right-handed orthogonal unitary bases e.g., Ax, Ay, Az (A) to Bx, By, Bz (B). Note: A quaternion like quat_AB is analogous to the rotation matrix R_AB. </td></tr>
    <tr><td class="paramname">quatDt</td><td>Time-derivative of <code>quat</code>, i.e., [ẇ, ẋ, ẏ, ż]. </td></tr>
    <tr><td class="paramname">w_B</td><td>Rigid body B's angular velocity in frame A, expressed in B. </td></tr>
    <tr><td class="paramname">tolerance</td><td>Tolerance for quaternion constraints. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if all three of the previous constraints are within tolerance. </dd></dl>

</div>
</div>
<a id="a056f9de21690e59551e2904bde9ac928"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a056f9de21690e59551e2904bde9ac928">&#9670;&nbsp;</a></span>IsQuaternionValid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::math::IsQuaternionValid </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Quaternion&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>quat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>tolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function tests if a quaternion satisfies the quaternion constraint specified in [Kane, 1983] Section 1.3, equation 4, page 12, i.e., a quaternion [w, x, y, z] must satisfy: w^2 + x^2 + y^2 + z^2 = 1. </p>
<ul>
<li>[Kane, 1983] "Spacecraft Dynamics," McGraw-Hill Book Co., New York, 1983. (with P. W. Likins and D. A. Levinson). Available for free .pdf download: <a href="https://ecommons.cornell.edu/handle/1813/637">https://ecommons.cornell.edu/handle/1813/637</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">quat</td><td>Quaternion [w, x, y, z] that relates two right-handed orthogonal unitary bases e.g., Ax, Ay, Az (A) to Bx, By, Bz (B). Note: A quaternion like quat_AB is analogous to the rotation matrix R_AB. </td></tr>
    <tr><td class="paramname">tolerance</td><td>Tolerance for quaternion constraint, i.e., how much is w^2 + x^2 + y^2 + z^2 allowed to differ from 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the quaternion constraint is satisfied within tolerance. </dd></dl>

</div>
</div>
<a id="a84760cbea23b50efdbe9a85f3967f098"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84760cbea23b50efdbe9a85f3967f098">&#9670;&nbsp;</a></span>IsSymmetric() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::math::IsSymmetric </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if a matrix is symmetric. </p>
<p>If std::equal_to&lt;&gt;()(matrix(i, j), matrix(j, i)) is true for all i, j, then the matrix is symmetric. </p>

</div>
</div>
<a id="a141ec70804c105e09ab3b0a855152b8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a141ec70804c105e09ab3b0a855152b8b">&#9670;&nbsp;</a></span>IsSymmetric() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::math::IsSymmetric </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Derived::Scalar &amp;&#160;</td>
          <td class="paramname"><em>precision</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if a matrix is symmetric based on whether the difference between matrix(i, j) and matrix(j, i) is smaller than <code>precision</code> for all i, j. </p>
<p>The precision is absolute. Matrix with nan or inf entries is not allowed. </p>

</div>
</div>
<a id="a57457683becdddf605a55be881c065b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57457683becdddf605a55be881c065b4">&#9670;&nbsp;</a></span>jacobian()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) drake::math::jacobian </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a matrix of AutoDiffScalars from which both the value and the Jacobian of a function </p><p class="formulaDsp">
\[ f:\mathbb{R}^{n\times m}\rightarrow\mathbb{R}^{p\times q} \]
</p>
<p> (f: R^n*m -&gt; R^p*q) can be extracted. </p>
<p>The derivative vector for each AutoDiffScalar in the output contains the derivatives with respect to all components of the argument \( x \).</p>
<p>The return type of this function is a matrix with the &lsquo;best&rsquo; possible AutoDiffScalar scalar type, in the following sense:</p><ul>
<li>If the number of derivatives can be determined at compile time, the AutoDiffScalar derivative vector will have that fixed size.</li>
<li>If the maximum number of derivatives can be determined at compile time, the AutoDiffScalar derivative vector will have that maximum fixed size.</li>
<li>If neither the number, nor the maximum number of derivatives can be determined at compile time, the output AutoDiffScalar derivative vector will be dynamically sized.</li>
</ul>
<p><code>f</code> should have a templated call operator that maps an Eigen matrix argument to another Eigen matrix. The scalar type of the output of \( f \) need not match the scalar type of the input (useful in recursive calls to the function to determine higher order derivatives). The easiest way to create an <code>f</code> is using a C++14 generic lambda.</p>
<p>The algorithm computes the Jacobian in chunks of up to <code>MaxChunkSize</code> derivatives at a time. This has three purposes:</p><ul>
<li>It makes it so that derivative vectors can be allocated on the stack, eliminating dynamic allocations and improving performance if the maximum number of derivatives cannot be determined at compile time.</li>
<li>It gives control over, and limits the number of required instantiations of the call operator of f and all the functions it calls.</li>
<li>Excessively large derivative vectors can result in CPU capacity cache misses; even if the number of derivatives is fixed at compile time, it may be better to break up into chunks if that means that capacity cache misses can be prevented.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>function </td></tr>
    <tr><td class="paramname">x</td><td>function argument value at which Jacobian will be evaluated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AutoDiffScalar matrix corresponding to the Jacobian of f evaluated at x. </dd></dl>

</div>
</div>
<a id="a4805a6b4a327bedeb7793cd1ce11523c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4805a6b4a327bedeb7793cd1ce11523c">&#9670;&nbsp;</a></span>matGradMult()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdrake_1_1math_1_1_mat_grad_mult.html">MatGradMult</a>&lt;DerivedDA, DerivedB&gt;::type drake::math::matGradMult </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedDA &gt; &amp;&#160;</td>
          <td class="paramname"><em>dA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedB &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a41fb0200e4ab7c796576b2fe17408ec8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41fb0200e4ab7c796576b2fe17408ec8">&#9670;&nbsp;</a></span>matGradMultMat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdrake_1_1math_1_1_mat_grad_mult_mat.html">MatGradMultMat</a>&lt;DerivedA, DerivedB, DerivedDA&gt;::type drake::math::matGradMultMat </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedA &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedB &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedDA &gt; &amp;&#160;</td>
          <td class="paramname"><em>dA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedDB &gt; &amp;&#160;</td>
          <td class="paramname"><em>dB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a48484009086db12d881bea6bcaab2514"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48484009086db12d881bea6bcaab2514">&#9670;&nbsp;</a></span>NormalizeVector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::math::NormalizeVector </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Derived::PlainObject &amp;&#160;</td>
          <td class="paramname"><em>x_norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structdrake_1_1math_1_1_gradient.html">drake::math::Gradient</a>&lt; Derived, Derived::RowsAtCompileTime, 1 &gt;::type *&#160;</td>
          <td class="paramname"><em>dx_norm</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structdrake_1_1math_1_1_gradient.html">drake::math::Gradient</a>&lt; Derived, Derived::RowsAtCompileTime, 2 &gt;::type *&#160;</td>
          <td class="paramname"><em>ddx_norm</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the normalized vector, optionally with its gradient and second derivative. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>An N x 1 vector to be normalized. Must not be zero. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">x_norm</td><td>The normalized vector (N x 1). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dx_norm</td><td>If non-null, returned as an N x N matrix, where dx_norm(i,j) = D x_norm(i)/D x(j). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ddx_norm</td><td>If non-null, and dx_norm is non-null, returned as an N^2 x N matrix, where ddx_norm.col(j) = D dx_norm/D x(j), with dx_norm stacked columnwise.</td></tr>
  </table>
  </dd>
</dl>
<p>(D x / D y above means partial derivative of x with respect to y.) </p>

</div>
</div>
<a id="ab095ea87a1517bb9bae78d221f5d34da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab095ea87a1517bb9bae78d221f5d34da">&#9670;&nbsp;</a></span>ProjectMatToRotMatWithAxis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double drake::math::ProjectMatToRotMatWithAxis </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix3d &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>angle_lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>angle_ub</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Projects an approximate 3 x 3 rotation matrix M onto an orthonormal matrix R so that R is a rotation matrix associated with a angle-axis rotation by an angle θ about a vector direction <code>axis</code>, with <code>angle_lb &lt;= θ &lt;= angle_ub</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>the matrix to be projected. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axis</td><td>vector direction associated with angle-axis rotation for R. axis can be a non-unit vector, but cannot be the zero vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">angle_lb</td><td>the lower bound of the rotation angle θ. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">angle_ub</td><td>the upper bound of the rotation angle θ. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Rotation angle θ of the projected matrix, angle_lb &lt;= θ &lt;= angle_ub </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if axis is the zero vector or if angle_lb &gt; angle_ub. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method is useful for reconstructing a rotation matrix for a revolute joint with joint limits. </dd>
<dd>
This can be formulated as an optimization problem <pre>
  min_θ trace((R - M)ᵀ*(R - M))
  subject to R = I + sinθ * A + (1 - cosθ) * A²   (1)
             angle_lb &lt;= θ &lt;= angle_ub
</pre> where A is the cross product matrix of a = axis / axis.norm() = [a₁, a₂, a₃] <pre>
A = [ 0  -a₃  a₂]
    [ a₃  0  -a₁]
    [-a₂  a₁  0 ]
</pre> Equation (1) is the Rodriguez Formula that computes the rotation matrix R from the angle-axis rotation with angle θ and vector direction <code>axis</code>. For details, see <a href="http://mathworld.wolfram.com/RodriguesRotationFormula.html">http://mathworld.wolfram.com/RodriguesRotationFormula.html</a> The objective function can be simplified as <pre>
   max_θ trace(Rᵀ * M + Mᵀ * R)
</pre> By substituting the matrix <code>R</code> with the angle-axis representation, the optimization problem is formulated as <pre>
   max_θ sinθ * trace(Aᵀ*M) - cosθ * trace(Mᵀ * A²)
   subject to angle_lb &lt;= θ &lt;= angle_ub
</pre> By introducing α = atan2(-trace(Mᵀ * A²), trace(Aᵀ*M)), we can compute the optimal θ as <pre>
   θ = π/2 + 2kπ - α, if angle_lb &lt;= π/2 + 2kπ - α &lt;= angle_ub, k ∈ integers
else
   θ = angle_lb, if sin(angle_lb + α) &gt;= sin(angle_ub + α)
   θ = angle_ub, if sin(angle_lb + α) &lt;  sin(angle_ub + α)
</pre> </dd></dl>
<dl class="section see"><dt>See also</dt><dd>GlobalInverseKinematics for an usage of this function. </dd></dl>

</div>
</div>
<a id="a7e6bdc00adb60394da9687fc9aa5b0aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e6bdc00adb60394da9687fc9aa5b0aa">&#9670;&nbsp;</a></span>quatConjugate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#af7e96394aef85f13f3fc84d3c3c238b3">Vector4</a>&lt;typename Derived::Scalar&gt; drake::math::quatConjugate </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae2ef93ff1fa2dc788507d6eadb4bb78f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2ef93ff1fa2dc788507d6eadb4bb78f">&#9670;&nbsp;</a></span>quatDiff()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#af7e96394aef85f13f3fc84d3c3c238b3">Vector4</a>&lt;typename Derived1::Scalar&gt; drake::math::quatDiff </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad298b049679492bf3e846165c6c7e023"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad298b049679492bf3e846165c6c7e023">&#9670;&nbsp;</a></span>quatDiffAxisInvar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Derived1::Scalar drake::math::quatDiffAxisInvar </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedU &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aad74d3c5baa84fa6ef04b6ada5ffcbe5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad74d3c5baa84fa6ef04b6ada5ffcbe5">&#9670;&nbsp;</a></span>QuaternionToCanonicalForm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Quaternion&lt;T&gt; drake::math::QuaternionToCanonicalForm </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Quaternion&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>quat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns a quaternion in its "canonical form" meaning that it returns a quaternion [w, x, y, z] with a non-negative w. </p>
<p>For example, if passed a quaternion [-0.3, +0.4, +0.5, +0.707], the function returns the quaternion's canonical form [+0.3, -0.4, -0.5, -0.707]. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">quat</td><td>Quaternion [w, x, y, z] that relates two right-handed orthogonal unitary bases e.g., Ax, Ay, Az (A) to Bx, By, Bz (B). Note: quat is analogous to the rotation matrix R_AB. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Canonical form of quat, which means that either the original quat is returned or a quaternion representing the same orientation but with negated [w, x, y, z], to ensure a positive w in returned quaternion. </dd></dl>

</div>
</div>
<a id="ab948fdacb210871495edea82aa001473"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab948fdacb210871495edea82aa001473">&#9670;&nbsp;</a></span>QuaternionToHopfCoordinate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt;T&gt; drake::math::QuaternionToHopfCoordinate </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Quaternion&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>quaternion</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a unit-length quaternion (w, x, y, z) to Hopf coordinate as if w &gt;= 0 ψ = 2*atan2(x, w) else ψ = 2*atan2(-x, -w) φ = mod(atan2(z, y) - ψ/2, 2pi) θ = 2*atan2(√(y²+z²), √(w²+x²)) ψ is in the range of [-pi, pi]. </p>
<p>φ is in the range of [0, 2pi]. θ is in the range of [0, pi]. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">quaternion</td><td>A unit length quaternion. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>hopf_coordinate (θ, φ, ψ) as an Eigen vector. </dd></dl>

</div>
</div>
<a id="a29059591a43a840c9a7e2f31a2d55130"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29059591a43a840c9a7e2f31a2d55130">&#9670;&nbsp;</a></span>quatProduct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#af7e96394aef85f13f3fc84d3c3c238b3">Vector4</a>&lt;typename Derived1::Scalar&gt; drake::math::quatProduct </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0fc70ebdc0ea497711e6e7b69eddef2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fc70ebdc0ea497711e6e7b69eddef2d">&#9670;&nbsp;</a></span>quatRotateVec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt;typename DerivedV::Scalar&gt; drake::math::quatRotateVec </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedQ &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a781bfc30740843ad1203fa68b7497401"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a781bfc30740843ad1203fa68b7497401">&#9670;&nbsp;</a></span>RealContinuousLyapunovEquation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd drake::math::RealContinuousLyapunovEquation </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A user defined real square matrix. </td></tr>
    <tr><td class="paramname">Q</td><td>A user defined real symmetric matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Q is a symmetric matrix.</dd></dl>
<p>Computes a unique solution X to the continuous Lyapunov equation: <code>AᵀX + XA + Q = 0</code>, where A is real and square, and Q is real, symmetric and of equal size as A. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if A or Q are not square matrices or do not have the same size.</td></tr>
  </table>
  </dd>
</dl>
<p>Limitations: Given the Eigenvalues of A as λ₁, ..., λₙ, there exists a unique solution if and only if λᵢ + λ̅ⱼ ≠ 0 ∀ i,j, where λ̅ⱼ is the complex conjugate of λⱼ. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the solution is not unique.</td></tr>
  </table>
  </dd>
</dl>
<p>There are no further limitations on the eigenvalues of A. Further, if all λᵢ have negative real parts, and if Q is positive semi-definite, then X is also positive semi-definite [1]. Therefore, if one searches for a Lyapunov function V(z) = zᵀXz for the stable linear system ż = Az, then the solution of the Lyapunov Equation <code>AᵀX + XA + Q = 0</code> only returns a valid Lyapunov function if Q is positive semi-definite.</p>
<p>The implementation is based on SLICOT routine SB03MD [2]. Note the transformation Q = -C. The complexity of this routine is O(n³). If A is larger than 2-by-2, then a Schur factorization is performed. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if Schur factorization failed.</td></tr>
  </table>
  </dd>
</dl>
<p>A tolerance of ε is used to check if a double variable is equal to zero, where the default value for ε is 1e-10. It has been used to check (1) if λᵢ + λ̅ⱼ = 0, ∀ i,j; (2) if A is a 1-by-1 zero matrix; (3) if A's trace or determinant is 0 when A is a 2-by-2 matrix.</p>
<p>[1] Bartels, R.H. and G.W. Stewart, "Solution of the Matrix Equation AX + XB
= C," Comm. of the ACM, Vol. 15, No. 9, 1972.</p>
<p>[2] <a href="http://slicot.org/objects/software/shared/doc/SB03MD.html">http://slicot.org/objects/software/shared/doc/SB03MD.html</a> </p>

</div>
</div>
<a id="a41733a5b284046800224cd293e055ff7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41733a5b284046800224cd293e055ff7">&#9670;&nbsp;</a></span>RealDiscreteLyapunovEquation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd drake::math::RealDiscreteLyapunovEquation </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A user defined real square matrix. </td></tr>
    <tr><td class="paramname">Q</td><td>A user defined real symmetric matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Q is a symmetric matrix.</dd></dl>
<p>Computes the unique solution X to the discrete Lyapunov equation: <code>AᵀXA - X + Q = 0</code>, where A is real and square, and Q is real, symmetric and of equal size as A. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if A or Q are not square matrices or do not have the same size.</td></tr>
  </table>
  </dd>
</dl>
<p>Limitations: Given the Eigenvalues of A as λ₁, ..., λₙ, there exists a unique solution if and only if λᵢ * λⱼ ≠ 1 ∀ i,j and λᵢ ≠ ±1, ∀ i [1]. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the solution is not unique.[3]</td></tr>
  </table>
  </dd>
</dl>
<p>There are no further limitations on the eigenvalues of A. Further, if |λᵢ|&lt;1, ∀ i, and if Q is positive semi-definite, then X is also positive semi-definite [2]. Therefore, if one searches for a Lyapunov function V(z) = zᵀXz for the stable linear system zₙ₊₁ = Azₙ, then the solution of the Lyapunov Equation <code>AᵀXA - X + Q = 0</code> only returns a valid Lyapunov function if Q is positive semi-definite.</p>
<p>The implementation is based on SLICOT routine SB03MD [2]. Note the transformation Q = -C. The complexity of this routine is O(n³). If A is larger than 2-by-2, then a Schur factorization is performed. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if Schur factorization fails.</td></tr>
  </table>
  </dd>
</dl>
<p>A tolerance of ε is used to check if a double variable is equal to zero, where the default value for ε is 1e-10. It has been used to check (1) if λᵢ = ±1 ∀ i; (2) if λᵢ * λⱼ = 1, i ≠ j.</p>
<p>[1] Barraud, A.Y., "A numerical algorithm to solve AᵀXA - X = Q," IEEE® Trans. Auto. Contr., AC-22, pp. 883-885, 1977.</p>
<p>[2] <a href="http://slicot.org/objects/software/shared/doc/SB03MD.html">http://slicot.org/objects/software/shared/doc/SB03MD.html</a></p>
<p>[3] <a href="https://www.mathworks.com/help/control/ref/dlyap.html">https://www.mathworks.com/help/control/ref/dlyap.html</a> </p>

</div>
</div>
<a id="adecdf6a7ef606861457807da4b56e7ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adecdf6a7ef606861457807da4b56e7ff">&#9670;&nbsp;</a></span>saturate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T1 drake::math::saturate </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T3 &amp;&#160;</td>
          <td class="paramname"><em>high</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Saturates the input <code>value</code> between upper and lower bounds. </p>
<p>If <code>value</code> is within <code>[low, high]</code> then return it; else return the boundary. </p>

</div>
</div>
<a id="a30d857f8398886aff22da2ea64bc1113"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30d857f8398886aff22da2ea64bc1113">&#9670;&nbsp;</a></span>setSubMatrixGradient() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::math::setSubMatrixGradient </td>
          <td>(</td>
          <td class="paramtype">Eigen::MatrixBase&lt; DerivedA &gt; &amp;&#160;</td>
          <td class="paramname"><em>dM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedB &gt; &amp;&#160;</td>
          <td class="paramname"><em>dM_submatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename DerivedA::Index&#160;</td>
          <td class="paramname"><em>M_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename DerivedA::Index&#160;</td>
          <td class="paramname"><em>q_start</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename DerivedA::Index&#160;</td>
          <td class="paramname"><em>q_subvector_size</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae748bcfe9270b9ed5dd2fb71df3941b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae748bcfe9270b9ed5dd2fb71df3941b6">&#9670;&nbsp;</a></span>setSubMatrixGradient() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::math::setSubMatrixGradient </td>
          <td>(</td>
          <td class="paramtype">Eigen::MatrixBase&lt; DerivedA &gt; &amp;&#160;</td>
          <td class="paramname"><em>dM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedB &gt; &amp;&#160;</td>
          <td class="paramname"><em>dM_submatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; <a class="el" href="classint.html">int</a>, NRows &gt; &amp;&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; <a class="el" href="classint.html">int</a>, NCols &gt; &amp;&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename DerivedA::Index&#160;</td>
          <td class="paramname"><em>M_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename DerivedA::Index&#160;</td>
          <td class="paramname"><em>q_start</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename DerivedA::Index&#160;</td>
          <td class="paramname"><em>q_subvector_size</em> = <code>QSubvectorSize</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab54df9b3b01c7c5509373712fda88ad4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab54df9b3b01c7c5509373712fda88ad4">&#9670;&nbsp;</a></span>setSubMatrixGradient() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::math::setSubMatrixGradient </td>
          <td>(</td>
          <td class="paramtype">Eigen::MatrixBase&lt; DerivedDM &gt; &amp;&#160;</td>
          <td class="paramname"><em>dM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedDMSub &gt; &amp;&#160;</td>
          <td class="paramname"><em>dM_submatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename DerivedDM::Index&#160;</td>
          <td class="paramname"><em>M_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename DerivedDM::Index&#160;</td>
          <td class="paramname"><em>q_start</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename DerivedDM::Index&#160;</td>
          <td class="paramname"><em>q_subvector_size</em> = <code>QSubvectorSize</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a058825f71b44c44e61dd90c3b89ec87d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a058825f71b44c44e61dd90c3b89ec87d">&#9670;&nbsp;</a></span>SolveLinearSystem() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; internal::is_double_or_symbolic_v&lt;typename DerivedA::Scalar&gt; &amp;&amp; internal::is_double_or_symbolic_v&lt;typename DerivedB::Scalar&gt; &amp;&amp; std::is_same_v&lt;typename DerivedA::Scalar, typename DerivedB::Scalar&gt;, Eigen::Matrix&lt;typename DerivedA::Scalar, DerivedA::RowsAtCompileTime, DerivedB::ColsAtCompileTime&gt; &gt;::type drake::math::SolveLinearSystem </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_linear_solver.html">LinearSolver</a> &amp;&#160;</td>
          <td class="paramname"><em>linear_solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedA &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedB &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specialized when A and b are both double or <a class="el" href="classdrake_1_1symbolic_1_1_expression.html" title="Represents a symbolic form of an expression.">symbolic::Expression</a> matrices. </p>
<p>See <a class="el" href="namespacedrake_1_1math.html#linear_solve_given_solver">linear_solve_given_solver</a> for more details. Note that <code>A</code> is unused, as we already compute its factorization in <code>linear_solver</code>. But we keep it here for consistency with the overloaded function, where A is a matrix of AutoDiffScalar. </p>

</div>
</div>
<a id="a34a14f4ecff0af11999f7d416c3316bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34a14f4ecff0af11999f7d416c3316bf">&#9670;&nbsp;</a></span>SolveLinearSystem() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; internal::is_double_or_symbolic_v&lt; typename LinearSolver::MatrixType::Scalar&gt; &amp;&amp; internal::is_double_or_symbolic_v&lt;typename DerivedB::Scalar&gt; &amp;&amp; std::is_same_v&lt;typename LinearSolver::MatrixType::Scalar, typename DerivedB::Scalar&gt;, Eigen::Matrix&lt;typename LinearSolver::MatrixType::Scalar, DerivedB::RowsAtCompileTime, DerivedB::ColsAtCompileTime&gt; &gt;::type drake::math::SolveLinearSystem </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_linear_solver.html">LinearSolver</a> &amp;&#160;</td>
          <td class="paramname"><em>linear_solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedB &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specialized when the matrix in linear_solver and b are both double or <a class="el" href="classdrake_1_1symbolic_1_1_expression.html" title="Represents a symbolic form of an expression.">symbolic::Expression</a> matrices. </p>
<p>See <a class="el" href="namespacedrake_1_1math.html#linear_solve_given_solver">linear_solve_given_solver</a> for more details. </p>

</div>
</div>
<a id="ac1ecf90a76392d69deecb8feb29e19a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1ecf90a76392d69deecb8feb29e19a7">&#9670;&nbsp;</a></span>SolveLinearSystem() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same_v&lt;typename LinearSolver::MatrixType::Scalar, double&gt; &amp;&amp; internal::is_autodiff_v&lt;typename DerivedB::Scalar&gt;, Eigen::Matrix&lt;typename DerivedB::Scalar, DerivedB::RowsAtCompileTime, DerivedB::ColsAtCompileTime&gt; &gt;::type drake::math::SolveLinearSystem </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_linear_solver.html">LinearSolver</a> &amp;&#160;</td>
          <td class="paramname"><em>linear_solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedB &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specialized the matrix in linear_solver is a double-valued matrix and b is an AutoDiffScalar-valued matrix. </p>
<p>See <a class="el" href="namespacedrake_1_1math.html#linear_solve_given_solver">linear_solve_given_solver</a> for more details. </p>

</div>
</div>
<a id="a2fe42b78445dde235cc217342ba8ab87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fe42b78445dde235cc217342ba8ab87">&#9670;&nbsp;</a></span>SolveLinearSystem() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same_v&lt;typename DerivedA::Scalar, double&gt; &amp;&amp; internal::is_autodiff_v&lt;typename DerivedB::Scalar&gt;, Eigen::Matrix&lt;typename DerivedB::Scalar, DerivedA::RowsAtCompileTime, DerivedB::ColsAtCompileTime&gt; &gt;::type drake::math::SolveLinearSystem </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_linear_solver.html">LinearSolver</a> &amp;&#160;</td>
          <td class="paramname"><em>linear_solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedA &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedB &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specialized when A is a double-valued matrix and b is an AutoDiffScalar-valued matrix. </p>
<p>See <a class="el" href="namespacedrake_1_1math.html#linear_solve_given_solver">linear_solve_given_solver</a> for more details. Note that <code>A</code> is unused, as we already compute its factorization in <code>linear_solver</code>. But we keep it here for consistency with the overloaded function, where A is a matrix of AutoDiffScalar. </p>

</div>
</div>
<a id="a9bfcba20c731dc23e4f48c367e36c9de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bfcba20c731dc23e4f48c367e36c9de">&#9670;&nbsp;</a></span>SolveLinearSystem() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; internal::is_autodiff_v&lt;typename DerivedA::Scalar&gt;, Eigen::Matrix&lt;typename DerivedA::Scalar, DerivedA::RowsAtCompileTime, DerivedB::ColsAtCompileTime&gt; &gt;::type drake::math::SolveLinearSystem </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_linear_solver.html">LinearSolver</a> &amp;&#160;</td>
          <td class="paramname"><em>linear_solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedA &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedB &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specialized when A is an AutoDiffScalar-valued matrix, and b can contain either AutoDiffScalar or double. </p>
<p>See <a class="el" href="namespacedrake_1_1math.html#linear_solve_given_solver">linear_solve_given_solver</a> for more details. </p>

</div>
</div>
<a id="a579e00c8ae91d6bcdb32eb4d723eba73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a579e00c8ae91d6bcdb32eb4d723eba73">&#9670;&nbsp;</a></span>SolveLinearSystem() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">internal::Solution&lt;DerivedA, DerivedB&gt; drake::math::SolveLinearSystem </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedA &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedB &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solves system A*x=b. </p>
<p>The supported combinations of scalar types are summarized in the table above. See <a class="el" href="namespacedrake_1_1math.html#linear_solve">linear_solve</a> for more details. </p>

</div>
</div>
<a id="a9681555f84d48a48d09601d913246934"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9681555f84d48a48d09601d913246934">&#9670;&nbsp;</a></span>SparseMatrixToRowColumnValueVectors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::math::SparseMatrixToRowColumnValueVectors </td>
          <td>(</td>
          <td class="paramtype">const Derived &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Eigen::Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>row_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Eigen::Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; typename Derived::Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For a sparse matrix, return the row indices, the column indices, and value of the non-zero entries. </p>
<p>For example, the matrix</p>
<p class="formulaDsp">
\[ mat = \begin{bmatrix} 1 &amp; 0 &amp; 2\\ 0 &amp; 3 &amp; 4\end{bmatrix} \]
</p>
<p> has </p><p class="formulaDsp">
\[ row = \begin{bmatrix} 0 &amp; 1 &amp; 0 &amp; 1\end{bmatrix}\\ col = \begin{bmatrix} 0 &amp; 1 &amp; 2 &amp; 2\end{bmatrix}\\ val = \begin{bmatrix} 1 &amp; 3 &amp; 2 &amp; 4\end{bmatrix} \]
</p>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>the input sparse matrix </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">row_indices</td><td>a vector containing the row indices of the non-zero entries </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">col_indices</td><td>a vector containing the column indices of the non-zero entries </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">val</td><td>a vector containing the values of the non-zero entries. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a731362436a359883cbac2c59abf95168"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a731362436a359883cbac2c59abf95168">&#9670;&nbsp;</a></span>SparseMatrixToTriplets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;Eigen::Triplet&lt;Scalar&gt; &gt; drake::math::SparseMatrixToTriplets </td>
          <td>(</td>
          <td class="paramtype">const Eigen::SparseMatrix&lt; Scalar, Options, StorageIndex &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For a sparse matrix, return a vector of triplets, such that we can reconstruct the matrix using setFromTriplet function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>A sparse matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A triplet with the row, column and value of the non-zero entries. See <a href="https://eigen.tuxfamily.org/dox/group__TutorialSparse.html">https://eigen.tuxfamily.org/dox/group__TutorialSparse.html</a> for more information on the triplet </dd></dl>

</div>
</div>
<a id="a5390bb2dadbe96cd6dfbe26c6891f100"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5390bb2dadbe96cd6dfbe26c6891f100">&#9670;&nbsp;</a></span>ToSymmetricMatrixFromLowerTriangularColumns() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">drake::MatrixX</a>&lt;typename Derived::Scalar&gt; drake::math::ToSymmetricMatrixFromLowerTriangularColumns </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>lower_triangular_columns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a column vector containing the stacked columns of the lower triangular part of a square matrix, returning a symmetric matrix whose lower triangular part is the same as the original matrix. </p>

</div>
</div>
<a id="a6d81fb8e0b28f46bad7838ed39bffbce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d81fb8e0b28f46bad7838ed39bffbce">&#9670;&nbsp;</a></span>ToSymmetricMatrixFromLowerTriangularColumns() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;typename Derived::Scalar, rows, rows&gt; drake::math::ToSymmetricMatrixFromLowerTriangularColumns </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>lower_triangular_columns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a column vector containing the stacked columns of the lower triangular part of a square matrix, returning a symmetric matrix whose lower triangular part is the same as the original matrix. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">rows</td><td>The number of rows in the symmetric matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a20c21cde851510ab3ae5a7527ed62d22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20c21cde851510ab3ae5a7527ed62d22">&#9670;&nbsp;</a></span>transposeGrad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Derived::PlainObject drake::math::transposeGrad </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>dX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Derived::Index&#160;</td>
          <td class="paramname"><em>rows_X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae6aefde593f0fbe2f9ef04f40979827f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6aefde593f0fbe2f9ef04f40979827f">&#9670;&nbsp;</a></span>UniformlyRandomAngleAxis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::AngleAxis&lt;T&gt; drake::math::UniformlyRandomAngleAxis </td>
          <td>(</td>
          <td class="paramtype">Generator *&#160;</td>
          <td class="paramname"><em>generator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a rotation (in the axis-angle representation) that rotates a point on the unit sphere to another point on the unit sphere with a uniform distribution over the sphere. </p>

</div>
</div>
<a id="a6c92561b046b32c1ebe172bd32dc8276"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c92561b046b32c1ebe172bd32dc8276">&#9670;&nbsp;</a></span>UniformlyRandomQuaternion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Quaternion&lt;T&gt; drake::math::UniformlyRandomQuaternion </td>
          <td>(</td>
          <td class="paramtype">Generator *&#160;</td>
          <td class="paramname"><em>generator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a rotation (in the quaternion representation) that rotates a point on the unit sphere to another point on the unit sphere with a uniform distribution over the sphere. </p>
<p>This method is briefly explained in <a href="http://planning.cs.uiuc.edu/node198.html,">http://planning.cs.uiuc.edu/node198.html,</a> a full explanation can be found in K. Shoemake. Uniform Random Rotations in D. Kirk, editor, Graphics Gems III, pages 124-132. Academic, New York, 1992. </p>

</div>
</div>
<a id="af27920d083eb816f24f832091a662f28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af27920d083eb816f24f832091a662f28">&#9670;&nbsp;</a></span>UniformlyRandomRotationMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a>&lt;T&gt; drake::math::UniformlyRandomRotationMatrix </td>
          <td>(</td>
          <td class="paramtype">Generator *&#160;</td>
          <td class="paramname"><em>generator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a rotation (in the rotation matrix representation) that rotates a point on the unit sphere to another point on the unit sphere with a uniform distribution over the sphere. </p>

</div>
</div>
<a id="acc24ae9bbbf0b9d253f3344b97a9f3d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc24ae9bbbf0b9d253f3344b97a9f3d4">&#9670;&nbsp;</a></span>UniformlyRandomRPY()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt;T&gt; drake::math::UniformlyRandomRPY </td>
          <td>(</td>
          <td class="paramtype">Generator *&#160;</td>
          <td class="paramname"><em>generator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a rotation (in the roll-pitch-yaw representation) that rotates a point on the unit sphere to another point on the unit sphere with a uniform distribution over the sphere. </p>

</div>
</div>
<a id="a33baecb77517d26dcea8ab1fb880fcbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33baecb77517d26dcea8ab1fb880fcbe">&#9670;&nbsp;</a></span>UniformPtsOnSphereFibonacci()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix3Xd drake::math::UniformPtsOnSphereFibonacci </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>num_points</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deterministically generates approximate evenly distributed points on a unit sphere. </p>
<p>This method uses Fibonacci number. For the detailed math, please refer to <a href="http://stackoverflow.com/questions/9600801/evenly-distributing-n-points-on-a-sphere">http://stackoverflow.com/questions/9600801/evenly-distributing-n-points-on-a-sphere</a> This algorithm generates the points in O(n) time, where <code>n</code> is the number of points. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_points</td><td>The number of points we want on the unit sphere. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The generated points. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>num_samples &gt;= 1. Throw std::exception if num_points &lt; 1 </dd></dl>

</div>
</div>
<a id="a2d78f6f294270fdc03dcb68de424536a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d78f6f294270fdc03dcb68de424536a">&#9670;&nbsp;</a></span>VectorToSkewSymmetric()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a3922cc0c6264e8ff225a6aa0dd993667">drake::Matrix3</a>&lt;typename Derived::Scalar&gt; drake::math::VectorToSkewSymmetric </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a64bd1ea33cbb7fd030ff6bf3061eb3fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64bd1ea33cbb7fd030ff6bf3061eb3fe">&#9670;&nbsp;</a></span>wrap_to()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T1 drake::math::wrap_to </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>high</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For variables that are meant to be periodic, (e.g. </p>
<p>over a 2π interval), wraps <code>value</code> into the interval <code>[low, high)</code>. Precisely, <code>wrap_to</code> returns: value + k*(high-low) for the unique integer value <code>k</code> that lands the output in the desired interval. <code>low</code> and <code>high</code> must be finite, and low &lt; high. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- footer -->
<div id="nav-path" class="navpath">
  <ul>
    <li class="navelem"><a class="el" href="namespacedrake.html">drake</a></li><li class="navelem"><a class="el" href="namespacedrake_1_1math.html">math</a></li>
  </ul>
</div>
<footer class="site-footer padding">
  <div class="contain">
    <a href="/" class="drake-logo">
      <img src="/images/drake-logo.svg"/>
    </a>
    <div class="footer-menu">
      <ul>    
        <li>
          <a href="/doxygen_cxx/index.html" class="site-menu-item">C++</a>
        </li>    
        <li>
          <a href="/pydrake/index.html" class="site-menu-item">Python</a>
        </li>
        <li class="github-link">
          <a href="https://github.com/RobotLocomotion/drake" class="site-menu-item">GitHub <img src="/third_party/images/GitHub-Mark-64px.png"/></a>
        </li>
      </ul>
    </div>
  </div>
</footer>
<script type="text/javascript">
searchBox.searchLabel = 'Go to name…';
searchBox.DOMSearchField().value = searchBox.searchLabel;
</script>
</body>
</html>
