<!-- HTML header for doxygen 1.15.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: Hydroelastic Contact User Guide</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(function() { init_search(); });
</script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@4/tex-chtml.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<header class="site-header">
 <div class="site-header-inner contain">
  <a class="drake-logo" href="/"><img src="/images/drake-logo-white.svg"></a>
  <div class="menu-mobile-toggle">
   <span></span>
  </div>
  <nav class="site-menu">
   <ul>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/">Home</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/installation.html">Installation</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/gallery.html">Gallery</a>
    </li>
    <li class="site-menu-item site-menu-item-main">API Documentation
     <div class="sub">
      <a class="site-menu-item" href="/doxygen_cxx/index.html">C++</a>
      <a class="site-menu-item" href="/pydrake/index.html">Python</a>
     </div>
    </li>
    <li class="site-menu-item site-menu-item-main">Resources
     <div class="sub">
      <a class="site-menu-item" href="/getting_help.html">Getting Help</a>
      <a class="site-menu-item" href="https://deepnote.com/workspace/Drake-0b3b2c53-a7ad-441b-80f8-bf8350752305/project/Tutorials-2b4fc509-aef2-417d-a40d-6071dfed9199/notebook/index-753e3c9d261247ba9f0eb1d7868c18c8">Tutorials</a>
      <a class="site-menu-item" href="/python_bindings.html">Python Bindings</a>
      <a class="site-menu-item" href="/developers.html">For Developers</a>
      <a class="site-menu-item" href="/credits.html">Credits</a>
     </div>
    </li>
    <li class="github-link">
     <a class="site-menu-item" href="https://github.com/RobotLocomotion/drake">GitHub <img src="/third_party/images/GitHub-Mark-Light-64px.png"></a>
    </li>
   </ul>
  </nav>
 </div>
</header>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<div class="title-banner">
 <div class="title-banner__title">
  Drake C++ Documentation
 </div>
 <div id="DDGSearch">
  <form id="search_form_cpp" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search C++ API only…">
   <input type="hidden" name="q" value="site:drake.mit.edu/doxygen_cxx">
  </form>
  <form id="search_form" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search all of Drake…">
   <input type="hidden" name="q" value="site:drake.mit.edu OR site:underactuated.csail.mit.edu OR site:manipulation.csail.mit.edu">
  </form>
 </div>
 <div id="MSearchBoxContainer">
  <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect" class="search-icon" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"><span class="search-icon-dropdown"></span></span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><div id="MSearchCloseImg" class="close-icon"></div></a>
          </span>
        </div>
</td>
 </div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('group__hydroelastic__user__guide.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">Hydroelastic Contact User Guide <div class="ingroups"><a class="el" href="group__multibody.html">Multibody Kinematics and Dynamics</a></div></div></div>
</div><!--header-->
<div class="contents">
<p>A guide to using hydroelastic contact in practice. </p>
<h1 class="doxsection"><a class="anchor" id="hug_introduction"></a>
Introduction</h1>
<p>There are many ways to model contact between rigid bodies. Drake uses an approach we call “compliant” contact. In compliant contact, nominally rigid bodies are allowed to penetrate slightly, as if the rigid body had a slightly deformable layer, but whose compression has no appreciable effect on the body’s mass properties. The contact force between two deformed bodies is distributed over a contact patch with an uneven pressure distribution over that patch. It is common in robotics to model that as a single point contact or a set of point contacts. Hydroelastic contact instead attempts to approximate the patch and pressure distribution to provide much richer and more realistic contact behavior. For a high-level overview, see <a href="https://medium.com/toyotaresearch/rethinking-contact-simulation-for-robot-manipulation-434a56b5ec88">this blog post</a>.</p>
<p>Drake implements two models for resolving contact to forces: point contact and hydroelastic contact. See <a class="el" href="group__compliant__contact.html">Modeling Compliant Contact</a> for a fuller discussion of the theory and practice of contact models. For notes on implementation status, see <a class="el" href="#hydro_appendix_a">Appendix A: Current state of implementation</a>. Also see <a class="el" href="#hydro_appendix_examples_and_tutorials">Appendix B: Examples and Tutorials</a>.</p>
<h2 class="doxsection"><a class="anchor" id="hug_quick_hydro"></a>
Hydroelastic Quick-start</h2>
<p>The <a class="el" href="structdrake_1_1geometry_1_1_default_proximity_properties.html">proximity default configuration settings</a> of SceneGraph offer a quick-start path to using hydroelastic contact without the need to fully annotate the collision geometries of robot models. (The full annotation process is described in <a class="el" href="#creating_hydro_reps">Creating hydroelastic representations of collision geometries</a>.)</p>
<p>While it is unlikely that the homogeneous parameters set by automatic hydroelastic configuration will be sufficient to model diverse sets of collision geometries, it may be a good starting point for some. It allows an incremental approach to adding hydroelastic annotations as needed.</p>
<p>To get very simple and quick hydroelastic configuration, all that is needed is to set the configuration for <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html" title="SceneGraph serves as the nexus for all geometry (and geometry-based operations) in a Diagram.">drake::geometry::SceneGraph</a>:</p>
<div class="fragment"><div class="line">geometry::SceneGraphConfig scene_graph_config;</div>
<div class="line">scene_graph_config.default_proximity_properties.compliance_type = <span class="stringliteral">&quot;compliant&quot;</span>;</div>
<div class="line"><span class="keyword">auto</span> [plant, scene_graph] =</div>
<div class="line">    <a class="code hl_function" href="namespacedrake_1_1multibody.html#ac4a3829265b73aef3b61b21d2cabe360">multibody::AddMultibodyPlant</a>(plant_config, scene_graph_config, &amp;builder);</div>
<div class="ttc" id="anamespacedrake_1_1multibody_html_ac4a3829265b73aef3b61b21d2cabe360"><div class="ttname"><a href="namespacedrake_1_1multibody.html#ac4a3829265b73aef3b61b21d2cabe360">drake::multibody::AddMultibodyPlant</a></div><div class="ttdeci">AddMultibodyPlantSceneGraphResult&lt; double &gt; AddMultibodyPlant(const MultibodyPlantConfig &amp;config, systems::DiagramBuilder&lt; double &gt; *builder)</div><div class="ttdoc">Adds a new MultibodyPlant and SceneGraph to the given builder.</div></div>
</div><!-- fragment --><p>For an example of a trivial conversion of an existing simulation, see the <a href="https://github.com/RobotLocomotion/drake/tree/master/examples/simple_gripper">examples/simple_gripper</a> program in the Drake source code. It offers a <span class="tt">--default_compliance_type</span> command line option, which permits trying various compliance types.</p>
<p>All of the geometries in contexts created for the scene graph will be annotated with a default set of proximity properties.</p>
<p>These transformations will allow hydroelastic contact to work, but the values of the properties may not be ideal. The default set of properties are controlled by <a class="el" href="structdrake_1_1geometry_1_1_default_proximity_properties.html" title="These properties will be used as defaults when the geometry as added via API calls or parsed from mod...">drake::geometry::DefaultProximityProperties</a>. They can be changed for each application.</p>
<p>Having used scene graph configuration proximity defaults to get up and running, it may still be useful to add specific hydroelastic annotations to model files. Any explicit properties in model files (or applied by calling Drake APIs) will take precedence over the default proximity properties for the annotated geometries.</p>
<h1 class="doxsection"><a class="anchor" id="hug_working_with_hydro"></a>
Working with Hydroelastic Contact</h1>
<p>It is relatively simple to enable a simulation to use hydroelastic contact. However, using it effectively requires some experience and consideration. This section details the mechanisms and choices involved in enabling hydroelastic contact and the next section helps guide you through some common tips, tricks, and traps.</p>
<p>Using hydroelastic contact requires two things:</p><ul>
<li>Configuring the system (<a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">drake::multibody::MultibodyPlant</a>) to use hydroelastic contact.</li>
<li>Applying appropriate properties to the collision geometries to enable hydroelastic contact calculations.</li>
</ul>
<p>Collision geometries for hydroelastic contact can be either "compliant-hydroelastic" with tetrahedral meshes describing an internal pressure field or "rigid-hydroelastic" with triangle surface meshes that are regarded as infinitely stiff. The figure below shows examples of a compliant hydroelastic box and a rigid hydroelastic box.</p>
<div class="image">
<img src="HydroelasticTutorialCompliantRigidOutsideInside800x669.jpg" alt=""/>
</div>
<p>The figure below shows a contact surface between a compliant-hydroelastic cylinder and a compliant-hydroelastic sphere. The contact surface is internal to both solids and is defined as the surface where the two pressure fields are equal.</p>
<div class="image">
<img src="HydroelasticTutorialContactSurfaceCompliantCompliant.png" alt=""/>
</div>
<p>Pictured below, a rigid-hydroelastic cylindrical spatula handle is grasped by two hydroelastic-compliant ellipsoidal bubble grippers. The contact surface between the spatula handle's rigid-hydroelastic geometry and either gripper is on the <b>surface</b> of the rigid-hydroelastic geometry.</p>
<div class="image">
<img src="HydroelasticTutorialContactSurfaceRigidCompliantBubble.png" alt=""/>
</div>
<h2 class="doxsection"><a class="anchor" id="hug_enabling"></a>
Enabling Hydroelastic contact in your simulation</h2>
<p>Because <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html">MultibodyPlant</a> is responsible for computing the dynamics of the system (and the contact forces are part of that), the ability to enable/disable the hydroelastic contact model is part of <span class="tt">MultibodyPlant</span>’s API: <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ad253ab790ff8e142080cedd210e982da" title="Sets the contact model to be used by this MultibodyPlant, see ContactModel for available options.">drake::multibody::MultibodyPlant::set_contact_model()</a>.</p>
<p>There are three different options:</p><ul>
<li><a class="el" href="namespacedrake_1_1multibody.html#a6f6e054758d34b83e86bea87d65dfe4ea20e722b15a1b587c30633f0a136b7009" title="Contact forces are computed using a point contact model, see Compliant Point Contact.">drake::multibody::ContactModel::kPoint</a></li>
<li><a class="el" href="namespacedrake_1_1multibody.html#a6f6e054758d34b83e86bea87d65dfe4ea873aefb0d70a0478c541b2d98484595d" title="Contact forces are computed using the Hydroelastic model.">drake::multibody::ContactModel::kHydroelastic</a></li>
<li><a class="el" href="namespacedrake_1_1multibody.html#a6f6e054758d34b83e86bea87d65dfe4ea8ad3adce463edb0d2843e1f1c0057d4a" title="Contact forces are computed using the hydroelastic model, where possible.">drake::multibody::ContactModel::kHydroelasticWithFallback</a></li>
</ul>
<p>The default model is <a class="el" href="namespacedrake_1_1multibody.html#a6f6e054758d34b83e86bea87d65dfe4ea8ad3adce463edb0d2843e1f1c0057d4a">kHydroelasticWithFallback</a>.</p>
<p><a class="el" href="namespacedrake_1_1multibody.html#a6f6e054758d34b83e86bea87d65dfe4ea20e722b15a1b587c30633f0a136b7009">kPoint</a> is the implementation of the point contact model (see <a class="el" href="group__compliant__contact.html">Modeling Compliant Contact</a>).</p>
<p>Models <a class="el" href="namespacedrake_1_1multibody.html#a6f6e054758d34b83e86bea87d65dfe4ea873aefb0d70a0478c541b2d98484595d">kHydroelastic</a> and <a class="el" href="namespacedrake_1_1multibody.html#a6f6e054758d34b83e86bea87d65dfe4ea8ad3adce463edb0d2843e1f1c0057d4a">kHydroelasticWithFallback</a> will both enable the hydroelastic contact. For forces to be created from hydroelastic contact, geometries need to have hydroelastic representations (see <a class="el" href="#hug_quick_hydro">Hydroelastic Quick-start</a>, <a class="el" href="#creating_hydro_reps">Creating hydroelastic representations of collision geometries</a>).</p>
<p><a class="el" href="namespacedrake_1_1multibody.html#a6f6e054758d34b83e86bea87d65dfe4ea873aefb0d70a0478c541b2d98484595d">kHydroelastic</a> is a strict contact model that will attempt to create a hydroelastic contact surface whenever a geometry with a hydroelastic representation appears to be in contact (based on broad-phase bounding volume culling). With this contact model, the simulator will throw an exception if:</p>
<ul>
<li>The contact is between two geometries with rigid hydroelastic representation, or</li>
<li>The contact is between a geometry with a hydroelastic representation and one without.</li>
</ul>
<p>Collisions between two geometries where neither has a hydroelastic representation are simply ignored.</p>
<p><a class="el" href="namespacedrake_1_1multibody.html#a6f6e054758d34b83e86bea87d65dfe4ea8ad3adce463edb0d2843e1f1c0057d4a">kHydroelasticWithFallback</a> provides “fallback” behavior for when <a class="el" href="namespacedrake_1_1multibody.html#a6f6e054758d34b83e86bea87d65dfe4ea873aefb0d70a0478c541b2d98484595d">kHydroelastic</a> would throw. When those scenarios are detected, it uses the point contact model between the colliding geometries so that the contact can be accounted for and produce contact forces. As the implementation evolves, more and more contact will be captured with hydroelastic contact and the circumstances in which the point-contact fallback is applied will decrease.</p>
<h2 class="doxsection"><a class="anchor" id="creating_hydro_reps"></a>
Creating hydroelastic representations of collision geometries</h2>
<p>There are three ways to configure hydroelastic representations for collision geometries:</p><ul>
<li>by using <a class="el" href="structdrake_1_1geometry_1_1_default_proximity_properties.html" title="These properties will be used as defaults when the geometry as added via API calls or parsed from mod...">drake::geometry::DefaultProximityProperties</a> (see <a class="el" href="#hug_quick_hydro">Hydroelastic Quick-start</a>)</li>
<li>by annotating model files (see <a class="el" href="#hug_file_specs">Assigning hydroelastic properties in file specifications</a>)</li>
<li>programmatically (see <a class="el" href="#hug_code_properties">Assigning hydroelastic properties in code</a>)</li>
</ul>
<p>If none of the above are done, no geometry in <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html" title="SceneGraph serves as the nexus for all geometry (and geometry-based operations) in a Diagram.">drake::geometry::SceneGraph</a> has a hydroelastic representation. So, enabling hydroelastic contact in <span class="tt">MultibodyPlant</span>, but forgetting to configure the geometries will lead to either simulation crashes or point contact-based forces.</p>
<p>In order for a mesh to be given a hydroelastic representation, it must be assigned certain properties. The exact properties it needs depends on the Shape type and whether it is rigid or compliant. Some properties can be defined, but if they are absent they’ll be provided by <span class="tt">MultibodyPlant</span>. First we’ll discuss each of the properties and then discuss how they can be specified.</p>
<h3 class="doxsection"><a class="anchor" id="hug_properties"></a>
Properties for hydroelastic contact</h3>
<ul>
<li>Hydroelastic classification<ul>
<li>To have a hydroelastic representation, a shape needs to be classified as either “compliant” or “rigid”. This must be explicit &ndash; there are no implicit assumptions. Otherwise, it will participate in point contact only.</li>
</ul>
</li>
<li>Resolution hint (meters)<ul>
<li>A positive real value in meters.</li>
<li>Most shapes (capsules, cylinders, ellipsoids, spheres) need to be tessellated into meshes. The resolution hint controls the fineness of the meshes.</li>
<li>For all tessellated geometries, Drake puts hard limits on the effect of the resolution hint property. There is a limit to how fine Drake will tessellate a primitive. Drake has hard-coded internal limits that are still very generous (approximately 100 million tetrahedra or triangles) which should be more than enough for any application. In practice, resolution hints will be quite “large” as coarser meshes are typically more desirable.</li>
<li>Notes on choosing a value:<ul>
<li>Generally, the coarsest mesh that produces desirable results will allow the simulation to run as efficiently as possible.<ul>
<li>The coarsest mesh will typically be generated when the resolution is equal to the geometry’s maximum measure (see the details below).</li>
</ul>
</li>
<li>If tessellation artifacts become obvious in the simulation, either make the object more compliant (see hydroelastic modulus) or increase the resolution (as discussed for the various shapes below).</li>
</ul>
</li>
<li>Geometric detail:<ul>
<li>For each geometry type, the resolution hint works with some (maybe abstract) choice of a representative circle, and its effect is defined in terms of the circumference of that circle. The resolution hint is the target length of each edge of the tessellated mesh around the circle. The circle will have N = ⌈2πr/h⌉ edges, where r is the capsule radius and h is the resolution hint. The number N changes discontinuously as h changes. However, generally, decreasing the resolution hint by some factor will increase the number of edges by that same factor. The number of elements will grow quadratically.<ul>
<li>Sphere<ul>
<li>The representative circle is the great circle of the sphere.</li>
</ul>
</li>
<li>Cylinder<ul>
<li>The representative circle is the base of the cylinder.</li>
</ul>
</li>
<li>Capsule<ul>
<li>The representative circle is the base of the cylinder, which is also the great circle of each hemisphere.</li>
</ul>
</li>
<li>Ellipsoid<ul>
<li>The representative circle is an abstract circle whose radius is that of the largest semi-axis of the elllipsoid.</li>
</ul>
</li>
</ul>
</li>
<li>Resolution hint has no effect on Box.</li>
</ul>
</li>
</ul>
</li>
<li>Hydroelastic modulus (Pa (N/m²))<ul>
<li>This is the measure of how stiff the material is. It directly defines how much pressure is exerted given a certain amount of penetration. More pressure leads to greater forces. Larger values create stiffer objects. An infinite modulus is mathematically equivalent to a “rigid” object. (Although, it is definitely better, in that case, to simply declare it “rigid”.)</li>
<li><a class="el" href="group__hydro__params.html">Estimation of Hydroelastic Parameters</a> shows how to estimate the hydroelastic modulus using analytical formulas.</li>
<li>Notes on choosing a value:<ul>
<li>Starting with the value for Young’s modulus is not unreasonable. However, large values (corresponding for instance to the Young’s modulus of metals) can cause numerical problems. In practice, values as high or larger than 10⁸ Pa are seldom used. Refer to <a class="el" href="group__hydro__params.html">Estimation of Hydroelastic Parameters</a> for further details.</li>
<li>For large modulus values, the resolution of the representations matter more. A very high modulus will keep the contact near the surface of the geometry, exposing tessellation artifacts. A smaller modulus has a smoothing effect.</li>
</ul>
</li>
<li>This is <em>only</em> required for shapes declared to be “compliant”. It can be defined for shapes declared as “rigid”, but the value will be ignored. (It can be convenient to always define it to enable tests where one might toggle the classification between rigid and compliant such that the compliant declaration is always well formed.)</li>
<li>Declaring a geometry to be compliant but not providing a valid hydroelastic modulus will produce an error at the time the geometry is added to <span class="tt">SceneGraph</span>.</li>
</ul>
</li>
<li>Hunt-Crossley dissipation (s/m)<ul>
<li>A non-negative real value.</li>
<li>This gives the contact an energy-damping property.</li>
<li>The larger the value, the more energy is damped.</li>
<li>If no value is provided, <span class="tt">MultibodyPlant</span> provides a default value of zero.</li>
<li>Notes on choosing a value:<ul>
<li>For objects that are nominally rigid, starting with zero-damping is good.</li>
<li>If the behavior seems “jittery”, gradually increase the amount of dissipation. Typical values would remain in the range [0, 100] with 10 to 50 being a typical damping amount.</li>
<li>The inverse of the Hunt-Crossley dissipation is the maximum bounce velocity between two objects. Therefore, if maximum bounce velocities of 10 cm/s are acceptable, a dissipation of 10 s/m will keep bounce velocities bounded to this range.</li>
<li>Warning: values larger than about 500 s/m are unphysical and typically lead to numerical problems. Due to time discretization errors, the user will see objects that take a long time to go back to their rest state.</li>
<li>Remember, as this value increases, your simulation will lose energy at a higher rate.</li>
</ul>
</li>
<li>See <a class="el" href="group__compliant__contact.html#mbp_dissipation_model">Modeling Dissipation</a> for details.</li>
</ul>
</li>
<li>Margin (m), see <a class="el" href="group__hydro__margin.html">Margin for Hydroelastic Contact</a><ul>
<li>A non-negative real value.</li>
<li>Used in discrete mode to mitigate spurious oscillations in the contact of nearly flat surfaces.</li>
<li>Notes on choosing a value:<ul>
<li>For typical simulations in robotics, a good start is a margin value of δ = 10⁻⁴ m.</li>
<li>How to estimate margin is thoroughly explained in <a class="el" href="group__hydro__margin.html#margin_how_much">But How Much Margin?</a>.</li>
<li>The scale of the system matters. For small mechanical components, a new value might need to be estimated based on the analysis in <a class="el" href="group__hydro__margin.html#margin_how_much">But How Much Margin?</a>.</li>
<li>A value of zero means that no speculative constraints are added, see <a class="el" href="group__hydro__margin.html#speculative_constraints">Speculative Contact Constraints</a>.</li>
<li>The default value is set in <a class="el" href="structdrake_1_1geometry_1_1_default_proximity_properties.html#ada2ca25da33c3b3bf317fc190210df77" title="(Advanced) Specifies a thin layer of thickness &quot;margin&quot; (in meters) around each geometry.">drake::geometry::DefaultProximityProperties::margin</a>.</li>
</ul>
</li>
</ul>
</li>
<li>Slab thickness<ul>
<li>A positive real value in meters</li>
<li>Only used for compliant half spaces. Declaring a half space to be compliant but lacking a value for slab thickness will cause the simulation to error out.</li>
<li>A measure of the thickness of the compliant material near the boundary of the half space.<ul>
<li>A compliant half space can be made more rigid by:<ul>
<li>Increasing the hydroelastic modulus and fixing slab thickness.</li>
<li>Fixing the hydroelastic modulus and decreasing the slab thickness.</li>
<li>Increasing the hydroelastic modulus and decreasing the slab thickness.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="hug_geometry_properties"></a>
Assigning hydroelastic properties to geometries</h2>
<p>Properties can be assigned to geometries inside a URDF or SDFormat file using some custom Drake XML tags. Alternatively, the properties can be assigned programmatically.</p>
<h3 class="doxsection"><a class="anchor" id="hug_file_specs"></a>
Assigning hydroelastic properties in file specifications</h3>
<p>Drake has introduced a number of custom tags to provide a uniform language to specify hydroelastic properties in both URDF and SDFormat. The tag names are the same but the values are expressed differently (to align with the practices common to URDF and SDFormat). For example, consider a custom tag &lt;drake:foo&gt; that takes a single integer value. In an SDFormat file it would look like: </p><pre class="fragment">&lt;drake:foo&gt;17&lt;/drake:foo&gt;
</pre><p>But in a URDF file it would look like this: </p><pre class="fragment">&lt;drake:foo value=”17”/&gt;
</pre><p>Both URDF and SDFormat files define a &lt;collision&gt; tag. This tag contains the tag for specifying the geometry type and associated properties. The hydroelastic properties can be specified as a child of the &lt;collision&gt; tag. Consider the following SDFormat example: </p><pre class="fragment">…
  &lt;collision name="body1_collision"&gt;
    &lt;geometry&gt;
      ...
    &lt;/geometry&gt;
    &lt;drake:proximity_properties&gt;
      &lt;drake:compliant_hydroelastic/&gt;
      &lt;drake:mesh_resolution_hint&gt;0.1&lt;/drake:mesh_resolution_hint&gt;
      &lt;drake:hydroelastic_modulus&gt;5e7&lt;/drake:hydroelastic_modulus&gt;
      &lt;drake:hunt_crossley_dissipation&gt;1.25&lt;/drake:hunt_crossley_dissipation&gt;
    &lt;/drake:proximity_properties&gt;
  &lt;/collision&gt;
…
</pre><p> and the following equivalent URDF example: </p><pre class="fragment">…
  &lt;collision name="body1_collision"&gt;
    &lt;geometry&gt;
      ...
    &lt;/geometry&gt;
    &lt;drake:proximity_properties&gt;
      &lt;drake:compliant_hydroelastic/&gt;
      &lt;drake:mesh_resolution_hint value="0.1"/&gt;
      &lt;drake:hydroelastic_modulus value="5e7/&gt;
      &lt;drake:hunt_crossley_dissipation value="1.25/&gt;
    &lt;/drake:proximity_properties&gt;
  &lt;/collision&gt;
…
</pre><p>For a body, we’ve defined a collision geometry called “body1_collision”. Inside the &lt;collision&gt; tag (as a sibling to the &lt;geometry&gt; tag), we’ve introduced the Drake-specific &lt;drake:proximity_properties&gt; tag. In it we’ve defined the geometry to be compliant for hydroelastic contact and specified its resolution hint, its hydroelastic modulus, and its dissipation.</p>
<p>Let’s look at the specific tags:</p>
<ul>
<li>&lt;<a class="el" href="group__multibody__parsing.html#tag_drake_proximity_properties">drake:proximity_properties</a>&gt;: This is the container for all Drake-specific proximity property values.</li>
<li>The following tags define hydroelastic properties for the collision geometry and would be contained in the &lt;<a class="el" href="group__multibody__parsing.html#tag_drake_proximity_properties">drake:proximity_properties</a>&gt; tag.<ul>
<li>&lt;<a class="el" href="group__multibody__parsing.html#tag_drake_rigid_hydroelastic">drake:rigid_hydroelastic</a>&gt; or &lt;<a class="el" href="group__multibody__parsing.html#tag_drake_compliant_hydroelastic">drake:compliant_hydroelastic</a>&gt;</li>
<li>&lt;<a class="el" href="group__multibody__parsing.html#tag_drake_mesh_resolution_hint">drake:mesh_resolution_hint</a>&gt;</li>
<li>&lt;<a class="el" href="group__multibody__parsing.html#tag_drake_hydroelastic_modulus">drake:hydroelastic_modulus</a>&gt; (for compliant geometry only)</li>
<li>&lt;<a class="el" href="group__multibody__parsing.html#tag_drake_hunt_crossley_dissipation">drake:hunt_crossley_dissipation</a>&gt;</li>
</ul>
</li>
<li>In the name of completeness, the following tags would be children of the &lt;<a class="el" href="group__multibody__parsing.html#tag_drake_proximity_properties">drake:proximity_properties</a>&gt; tag as well, but are not restricted to use with hydroelastic contact.<ul>
<li>&lt;<a class="el" href="group__multibody__parsing.html#tag_drake_point_contact_stiffness">drake:point_contact_stiffness</a>&gt;: Only used when this geometry is for point contact. Defines the compliance of the point contact. This property is allowed to exist even if the geometry has been specified to be of hydroelastic type, it will have no effect on hydroelastic computations.</li>
<li>&lt;<a class="el" href="group__multibody__parsing.html#tag_drake_mu_static">drake:mu_static</a>&gt; The coefficient for static friction; this applies to both point contact and hydroelastic contact.</li>
<li>&lt;<a class="el" href="group__multibody__parsing.html#tag_drake_mu_dynamic">drake:mu_dynamic</a>&gt; The coefficient for dynamic friction; this applies to both point contact and hydroelastic contact.</li>
</ul>
</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="hug_code_properties"></a>
Assigning hydroelastic properties in code</h3>
<p>Hydroelastic properties can be set to objects programmatically via the following APIs (see their documentation for further details):</p>
<ul>
<li>AddContactMaterial()</li>
<li>AddRigidHydroelasticProperties()</li>
<li>AddCompliantHydroelasticProperties()</li>
<li>AddCompliantHydroelasticPropertiesForHalfSpace()</li>
</ul>
<p>Some extra notes:</p>
<p>AddContactMaterial() isn’t hydroelastic contact specific, but does provide a mechanism for setting the friction coefficients that hydroelastic and point contact models both use.</p>
<p>AddRigidHydroelasticProperties() is overloaded. One version accepts a value for resolution hint, one does not. When in doubt which to use, it is harmless to provide a resolution hint value that would be ignored for some geometries, but failing to provide one where necessary will cause the simulation to throw an exception. Note the special case for declaring a compliant half space &ndash; it takes the required slab thickness parameter in addition to the hydroelastic modulus value.</p>
<h1 class="doxsection"><a class="anchor" id="hug_visualizing"></a>
Visualizing hydroelastic contact</h1>
<p>Start Meldis by: </p><pre class="fragment">$ bazel run //tools:meldis -- --open-window &amp;
</pre><p>Run a simulation with hydroelastic contact model; for example, </p><pre class="fragment">$ bazel run //examples/hydroelastic/ball_plate:ball_plate_run_dynamics -- \
   --mbp_dt=0.001 --x0=0.10 --z0=0.15 --vz=-7.0 \
   --simulation_time=0.015 --simulator_publish_every_time_step
</pre><p>At the time of this writing, the Meldis view of this example looks like this:</p>
<div class="image">
<img src="drake-vis-01.png" alt="" width="90%"/>
</div>
<p>In the above picture, we see two red force vectors acting at the centroids of the two contact surfaces and also the two blue moment vectors. One contact surface represents the ball pushing the dinner plate down. The other contact surface represents the rectangular floor pushing the dinner plate up. (Gravity forces are not shown, nor is the contact between the ball and the floor.) Notice that only approximately half of the bottom of the plate makes contact with the floor.</p>
<p>The Scene panel can toggle on/off many different aspects of the visualization using checkboxes, including: which contacts are shown, whether to view the illustration (visual) geometry and/or collision (proximity) geometry and/or the bodies' inertia, as well as sliders for controlling transparency to better view overlapping shapes.</p>
<p>When viewing collisions, note that red arrows indicate a hydroelastic contact, with an associated contact patch. Green arrows indicate point contact, which does not have any contact patch.</p>
<h1 class="doxsection"><a class="anchor" id="hug_pitfalls"></a>
Pitfalls/Troubleshooting</h1>
<p>Here are various ways that hydroelastic contact may surprise you.</p><ul>
<li>A rigid body is not a rigid hydroelastic body until users say so (see <a class="el" href="#creating_hydro_reps">Creating hydroelastic representations of collision geometries</a>). Otherwise, it is ignored by the hydroelastic contact model and might get point contact instead.<ul>
<li>Users need to call AddRigidHydroelasticProperties() or use the URDF or SDFormat tag &lt;drake:rigid_hydroelastic/&gt;.</li>
</ul>
</li>
<li>Backface culling &ndash; the visualized contact surface is not what you expect. Or, “Why are there holes?” </li>
<li>Hydroelastic modulus is not properly a material property; it combines material and geometry.<ul>
<li>Make the sphere bigger, the force gets weaker for the same contact surface.</li>
</ul>
</li>
<li>“I don’t seem to be getting any contact surfaces although my spheres are clearly overlapping!” Depending on how coarsely you tessellated your geometry (a sphere, at its coarsest, is an octahedron), there can be a large amount of error between the primitive surface and discrete mesh’s surface. Make sure you visualize the hydro meshes and have what you expect.</li>
<li>Stiff and coarse is seldom a good thing. The stiffer an object is, the more the details of the discrete tessellation will directly contribute to the dynamics.  </li>
<li>Getting moments out of the contact depends on how many elements are in the contact surface. If the elements of the two contributing meshes are much larger than the actual contact surface, the contact can become, in essence, point contact.</li>
<li>Half spaces are not represented by meshes. They don’t contribute <em>any</em> geometry to the resultant contact surface. The contact surface’s refinement will depend on the other geometry’s level of refinement.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="hug_tips"></a>
Tips and Tricks</h2>
<p>This is a random collection of things we can do to maximize the benefits of the hydroelastic contact model. Some of these tricks accommodate current implementation limitations, and some are to work within the theoretical framework.</p>
<h3 class="doxsection"><a class="anchor" id="hug_gaming"></a>
Gaming the model</h3>
<ul>
<li>Rigid meshes need not be closed. You can use this to provide fine grained control over where a contact surface can actually exist. Be careful to have a consistent direction of surface normals on the triangles. They should point outward.</li>
<li>For a given relative configuration between bodies, the magnitude of force can be tuned in two ways: increasing the hydroelastic modulus and/or scaling the geometry up (in essence, increasing the average penetration depth).</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="hydro_appendix_a"></a>
Appendix A: Current state of implementation</h1>
<p>This section will be updated as the scope and feature set of hydroelastic contact is advanced. The main crux of this section is to clearly indicate what can and cannot be done with hydroelastic contact.</p>
<h2 class="doxsection"><a class="anchor" id="hug_implemented"></a>
What can you do with hydroelastic contact?</h2>
<ul>
<li>Hydroelastic contact can be used with MultibodyPlant in either continuous or discrete mode.</li>
<li>You can visualize the contact surfaces, their pressure fields, and the resultant contact forces in MeshCat as the simulation progresses. However, for playing back recordings in MeshCat, only the contact forces and moments are available (see issue <a href="https://github.com/RobotLocomotion/drake/issues/19142">19142</a>).</li>
<li>All Drake Shape types can be used to create rigid hydroelastic bodies (this includes arbitrary meshes defined as OBJs).</li>
<li>Drake primitive Shape types (Box, Capsule, Cylinder, Ellipsoid, HalfSpace, and Cylinder) can all be used to create both compliant hydroelastic bodies and rigid hydroelastic bodies.</li>
<li>The Drake Convex Shape type can be used both as a compliant hydroelastic body and a rigid hydroelastic body. To use Convex, add the custom tag <span class="tt">&lt;<a class="el" href="namespacedrake.html">drake</a>:declare_convex/&gt;</span> tag under the <span class="tt">&lt;mesh&gt;</span> tag in either an SDFormat or URDF file.</li>
<li>The Drake Mesh Shape type can be used as a compliant hydroelastic body using a tetrahedral mesh in VTK file. See <a href="https://github.com/RobotLocomotion/drake/tree/master/examples/hydroelastic/python_nonconvex_mesh">examples/hydroelastic/python_nonconvex_mesh.</a></li>
</ul>
<h2 class="doxsection"><a class="anchor" id="hug_not_yet_implemented"></a>
What can’t you do with hydroelastic contact?</h2>
<ul>
<li>You can’t get contact surfaces between two rigid hydroelastic geometries. The contact surface between rigid geometries is ill defined and will most likely never be supported. The default <a class="el" href="namespacedrake_1_1multibody.html#a6f6e054758d34b83e86bea87d65dfe4ea8ad3adce463edb0d2843e1f1c0057d4a" title="Contact forces are computed using the hydroelastic model, where possible.">drake::multibody::ContactModel::kHydroelasticWithFallback</a> uses compliant point contact as a reliable default. See <a class="el" href="#hug_enabling">Enabling Hydroelastic contact in your simulation</a>.</li>
<li>Hydroelastics cannot model true deformations given the model does not introduce state. Therefore effects such as tangential compliance or short time scale waves are not captured by the model. Currently we are actively developing code for deformable bodies in <a class="el" href="classdrake_1_1multibody_1_1_deformable_model.html">DeformableModel</a>.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="hug_dissipation_and_solver"></a>
Current dissipation models</h2>
<ul>
<li>The TAMSI (DiscreteContactApproximation::kTamsi), Similar (DiscreteContactApproximation::kSimilar), and Lagged (DiscreteContactApproximation::kLagged) model approximations use a Hunt-Crossley model of dissipation, parameterized by <span class="tt">hunt_crossley_dissipation</span>, for both point and hydroelastic contact. The SAP approximation parameter <span class="tt">relaxation_time</span> is ignored by these approximations.</li>
<li>The SAP model approximation (DiscreteContactApproximation::kSap) uses a linear Kelvin–Voigt model of dissipation parameterized by <span class="tt">relaxation_time</span>, for both point and hydroelastic contact. The Hunt-Crossley dissipation parameter is ignored by this approximation.</li>
<li>We allow the user to specify both <span class="tt">hunt_crossley_dissipation</span> (TAMSI, Similar and Lagged discrete approximations as well as continuous plant model) and <span class="tt">relaxation_time</span> (SAP approximation specific parameter) on the model, but the parameter may be ignored depending on your plant configuration. See the documentation for that in the <a href="https://drake.mit.edu/doxygen_cxx/classdrake_1_1multibody_1_1_multibody_plant.html#:~:text=%E2%81%B4%20We%20allow%20to,will%20be%20ignored.">MultibodyPlant documentation.</a></li>
</ul>
<h1 class="doxsection"><a class="anchor" id="hydro_appendix_examples_and_tutorials"></a>
Appendix B: Examples and Tutorials</h1>
<ul>
<li>Example <a href="https://github.com/RobotLocomotion/drake/tree/master/examples/hydroelastic/ball_plate">Contact between a ball, dinner plate, and floor in C++</a> uses the hydroelastic contact model for a convex ball and non-convex dinner plate.</li>
<li>Example <a href="https://github.com/RobotLocomotion/drake/tree/master/examples/hydroelastic/python_ball_paddle">Contact between a ball and paddle (box) in Python</a> uses the hydroelastic contact model for a ball on stationary paddle (box).</li>
<li>Example <a href="https://github.com/RobotLocomotion/drake/tree/master/examples/hydroelastic/python_nonconvex_mesh">Contact between a bell pepper, dinner bowl, and floor in Python</a> uses the hydroelastic contact model for a non-convex bell pepper in a non-convex dinner bowl.</li>
<li>Example <a href="https://github.com/RobotLocomotion/drake/tree/master/examples/hydroelastic/spatula_slip_control">Slip control for a spatula handle between finger grippers in C++</a> uses the hydroelastic contact model for a spatula handle between finger grippers.</li>
<li>Tutorial <a href="https://github.com/RobotLocomotion/drake/blob/master/tutorials/hydroelastic_contact_basics.ipynb">Hydroelastic Contact Basics with Jupyter Python notebook</a> shows how to simulate hydroelastic contact for a compliant block dropped on a rigid rectangular plate. The below-left picture shows one frame of the block's contact with the contact force as a red arrow and the contact torque as a blue arrow. The below-right picture zooms into the hydroelastic contact surface showing pressure distribution.</li>
</ul>
<div class="image">
<img src="HydroelasticTutorialImage600x388.jpg" alt=""/>
</div>
<h1 class="doxsection"><a class="anchor" id="hydro_references"></a>
Sources referenced within this documentation</h1>
<ul>
<li><a class="anchor" id="Elandt2019"></a>[Elandt 2019] Elandt, R., Drumwright, E., Sherman, M., &amp; Ruina, A. (2019, November). A pressure field model for fast, robust approximation of net contact force and moment between nominally rigid objects. In 2019 IEEE/RSJ International Conference on Intelligent Robots and Systems(IROS) (pp. 8238-8245). IEEE. <a href="https://arxiv.org/abs/1904.11433">https://arxiv.org/abs/1904.11433</a> .</li>
<li><a class="anchor" id="Masterjohn2022"></a>[Masterjohn 2022] Masterjohn, J., Guoy, D., Shepherd, J., &amp; Castro, A. (2022). Velocity Level Approximation of Pressure Field Contact Patches. In 2022 IEEE/RSJ International Conference on Intelligent Robots and Systems(IROS). <a href="https://arxiv.org/abs/2110.04157">https://arxiv.org/abs/2110.04157</a> .</li>
<li><a class="anchor" id="Sherman2022"></a>[Sherman 2022] Sherman, M. (2022, June). Rethinking Contact Simulation for Robot Manipulation. Blog post in Medium. <a href="https://medium.com/toyotaresearch/rethinking-contact-simulation-for-robot-manipulation-434a56b5ec88">https://medium.com/toyotaresearch/rethinking-contact-simulation-for-robot-manipulation-434a56b5ec88</a> . </li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- footer -->
<div class="navpath">
  <ul>
  </ul>
</div>
<footer id="nav-path", class="site-footer padding">
  <div class="contain">
    <a href="/" class="drake-logo">
      <img src="/images/drake-logo.svg"/>
    </a>
    <div class="footer-menu">
      <ul>
        <li>
          <a href="https://accessibility.mit.edu/" class="site-menu-item">Accessibility</a>
        </li>
        <li>
          <a href="/doxygen_cxx/index.html" class="site-menu-item">C++</a>
        </li>
        <li>
          <a href="/pydrake/index.html" class="site-menu-item">Python</a>
        </li>
        <li class="github-link">
          <a href="https://github.com/RobotLocomotion/drake" class="site-menu-item">GitHub <img src="/third_party/images/GitHub-Mark-64px.png"/></a>
        </li>
      </ul>
    </div>
  </div>
</footer>
<script type="text/javascript">
searchBox.searchLabel = 'Go to name…';
searchBox.DOMSearchField().placeholder = searchBox.searchLabel;
searchBox.DOMSearchField().value = '';
</script>
</body>
</html>
