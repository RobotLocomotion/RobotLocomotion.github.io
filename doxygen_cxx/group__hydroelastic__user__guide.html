<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: Hydroelastic Contact User Guide</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<header class="site-header">
 <div class="site-header-inner contain">
  <a class="drake-logo" href="/"><img src="/images/drake-logo-white.svg"></a>
  <div class="menu-mobile-toggle">
   <span></span>
  </div>
  <nav class="site-menu">
   <ul>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/">Home</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/installation.html">Installation</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/gallery.html">Gallery</a>
    </li>
    <li class="site-menu-item site-menu-item-main">API Documentation
     <div class="sub">
      <a class="site-menu-item" href="/doxygen_cxx/index.html">C++</a>
      <a class="site-menu-item" href="/pydrake/index.html">Python</a>
     </div>
    </li>
    <li class="site-menu-item site-menu-item-main">Resources
     <div class="sub">
      <a class="site-menu-item" href="/getting_help.html">Getting Help</a>
      <a class="site-menu-item" href="https://deepnote.com/workspace/Drake-0b3b2c53-a7ad-441b-80f8-bf8350752305/project/Tutorials-2b4fc509-aef2-417d-a40d-6071dfed9199/%2Findex.ipynb">Tutorials</a>
      <a class="site-menu-item" href="/python_bindings.html">Python Bindings</a>
      <a class="site-menu-item" href="/developers.html">For Developers</a>
      <a class="site-menu-item" href="/credits.html">Credits</a>
     </div>
    </li>
    <li class="github-link">
     <a class="site-menu-item" href="https://github.com/RobotLocomotion/drake">GitHub <img src="/third_party/images/GitHub-Mark-Light-64px.png"></a>
    </li>
   </ul>
  </nav>
 </div>
</header>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
<div class="title-banner">
 <div class="title-banner__title">
  Drake C++ Documentation
 </div>
 <div id="DDGSearch">
  <form id="search_form_cpp" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search C++ API only…">
   <input type="hidden" name="q" value="site:drake.mit.edu/doxygen_cxx">
  </form>
  <form id="search_form" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search all of Drake…">
   <input type="hidden" name="q" value="site:drake.mit.edu OR site:underactuated.csail.mit.edu OR site:manipulation.csail.mit.edu">
  </form>
 </div>
 <div id="MSearchBoxContainer">
          <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
 </div>
</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__hydroelastic__user__guide.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Hydroelastic Contact User Guide<div class="ingroups"><a class="el" href="group__multibody.html">Multibody Kinematics and Dynamics</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<h1><a class="anchor" id="hug_title"></a>
Hydroelastic Contact User Guide</h1>
<h2><a class="anchor" id="hug_introduction"></a>
Introduction</h2>
<p>There are many ways to model contact between rigid bodies. Drake uses an approach we call “compliant” contact. In compliant contact, nominally rigid bodies are allowed to penetrate slightly, as if the rigid body had a slightly deformable layer, but whose compression has no appreciable effect on the body’s mass properties. The contact force between two deformed bodies is distributed over a contact patch with an uneven pressure distribution over that patch. It is common in robotics to model that as a single point contact or a set of point contacts. Hydroelastic contact instead attempts to approximate the patch and pressure distribution to provide much richer and more realistic contact behavior. For a high-level overview, see <a href="https://medium.com/toyotaresearch/rethinking-contact-simulation-for-robot-manipulation-434a56b5ec88">this blog post</a>.</p>
<p>Drake implements two models for resolving contact to forces: point contact and hydroelastic contact. See <a class="el" href="group__hydroelastic__user__guide.html#hydro_appendix_a">Appendix A: Compliant Contact Models</a> for a fuller discussion of the theory and practice of contact models. For notes on implementation status, see <a class="el" href="group__hydroelastic__user__guide.html#hydro_appendix_b">Appendix B: Current state of implementation</a>. Also see <a class="el" href="group__hydroelastic__user__guide.html#hydro_appendix_examples_and_tutorials">Appendix C: Examples and Tutorials</a>.</p>
<h3><a class="anchor" id="hug_quick_hydro"></a>
Hydroelastic Quick-start</h3>
<p>The <a class="el" href="structdrake_1_1geometry_1_1_default_proximity_properties.html">proximity default configuration settings</a> of SceneGraph offer a quick-start path to using hydroelastic contact without the need to fully annotate the collision geometries of robot models. (The full annotation process is described in <a class="el" href="group__hydroelastic__user__guide.html#creating_hydro_reps">Creating hydroelastic representations of collision geometries</a>.)</p>
<p>While it is unlikely that the homogeneous parameters set by automatic hydroelastic configuration will be sufficient to model diverse sets of collision geometries, it may be a good starting point for some. It allows an incremental approach to adding hydroelastic annotations as needed.</p>
<p>To get very simple and quick hydroelastic configuration, all that is needed is to set the configuration for <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html" title="SceneGraph serves as the nexus for all geometry (and geometry-based operations) in a Diagram.">drake::geometry::SceneGraph</a>:</p>
<div class="fragment"><div class="line">geometry::SceneGraphConfig scene_graph_config;</div><div class="line">scene_graph_config.default_proximity_properties.compliance_type = <span class="stringliteral">&quot;compliant&quot;</span>;</div><div class="line"><span class="keyword">auto</span> [plant, scene_graph] =</div><div class="line">    <a class="code" href="namespacedrake_1_1multibody.html#a7e468aa35ef6a84196ac20a13065ca0c">multibody::AddMultibodyPlant</a>(plant_config, scene_graph_config, &amp;builder);</div></div><!-- fragment --><p>For an example of a trivial conversion of an existing simulation, see the <a href="https://github.com/RobotLocomotion/drake/tree/master/examples/simple_gripper">examples/simple_gripper</a> program in the Drake source code. It offers a <code>--default_compliance_type</code> command line option, which permits trying various compliance types.</p>
<p>All of the geometries in contexts created for the scene graph will be annotated with a default set of proximity properties.</p>
<p>These transformations will allow hydroelastic contact to work, but the values of the properties may not be ideal. The default set of properties are controlled by <a class="el" href="structdrake_1_1geometry_1_1_default_proximity_properties.html" title="These properties will be used as defaults when the geometry as added via API calls or parsed from mod...">drake::geometry::DefaultProximityProperties</a>. They can be changed for each application.</p>
<p>Having used scene graph configuration proximity defaults to get up and running, it may still be useful to add specific hydroelastic annotations to model files. Any explicit properties in model files (or applied by calling Drake APIs) will take precedence over the default proximity properties for the annotated geometries.</p>
<h2><a class="anchor" id="hug_working_with_hydro"></a>
Working with Hydroelastic Contact</h2>
<p>It is relatively simple to enable a simulation to use hydroelastic contact. However, using it effectively requires some experience and consideration. This section details the mechanisms and choices involved in enabling hydroelastic contact and the next section helps guide you through some common tips, tricks, and traps.</p>
<p>Using hydroelastic contact requires two things:</p><ul>
<li>Configuring the system (<a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">drake::multibody::MultibodyPlant</a>) to use hydroelastic contact.</li>
<li>Applying appropriate properties to the collision geometries to enable hydroelastic contact calculations.</li>
</ul>
<p>Collision geometries for hydroelastic contact can be either "compliant-hydroelastic" with tetrahedral meshes describing an internal pressure field or "rigid-hydroelastic" with triangle surface meshes that are regarded as infinitely stiff. The figure below shows examples of a compliant hydroelastic box and a rigid hydroelastic box.</p>
<div class="image">
<img src="HydroelasticTutorialCompliantRigidOutsideInside800x669.jpg" alt="HydroelasticTutorialCompliantRigidOutsideInside800x669.jpg"/>
</div>
<p>The figure below shows a contact surface between a compliant-hydroelastic cylinder and a compliant-hydroelastic sphere. The contact surface is internal to both solids and is defined as the surface where the two pressure fields are equal.</p>
<div class="image">
<img src="HydroelasticTutorialContactSurfaceCompliantCompliant.png" alt="HydroelasticTutorialContactSurfaceCompliantCompliant.png"/>
</div>
<p>Pictured below, a rigid-hydroelastic cylindrical spatula handle is grasped by two hydroelastic-compliant ellipsoidal bubble grippers. The contact surface between the spatula handle's rigid-hydroelastic geometry and either gripper is on the <b>surface</b> of the rigid-hydroelastic geometry.</p>
<div class="image">
<img src="HydroelasticTutorialContactSurfaceRigidCompliantBubble.png" alt="HydroelasticTutorialContactSurfaceRigidCompliantBubble.png"/>
</div>
<h3><a class="anchor" id="hug_enabling"></a>
Enabling Hydroelastic contact in your simulation</h3>
<p>Because <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html">MultibodyPlant</a> is responsible for computing the dynamics of the system (and the contact forces are part of that), the ability to enable/disable the hydroelastic contact model is part of <code>MultibodyPlant</code>’s API: <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ad253ab790ff8e142080cedd210e982da" title="Sets the contact model to be used by this MultibodyPlant, see ContactModel for available options.">drake::multibody::MultibodyPlant::set_contact_model()</a>.</p>
<p>There are three different options:</p><ul>
<li><a class="el" href="namespacedrake_1_1multibody.html#a6f6e054758d34b83e86bea87d65dfe4ea20e722b15a1b587c30633f0a136b7009" title="Contact forces are computed using a point contact model, see Numerical Approximation of Point Contact...">drake::multibody::ContactModel::kPoint</a></li>
<li><a class="el" href="namespacedrake_1_1multibody.html#a6f6e054758d34b83e86bea87d65dfe4ea873aefb0d70a0478c541b2d98484595d" title="Contact forces are computed using the Hydroelastic model.">drake::multibody::ContactModel::kHydroelastic</a></li>
<li><a class="el" href="namespacedrake_1_1multibody.html#a6f6e054758d34b83e86bea87d65dfe4ea8ad3adce463edb0d2843e1f1c0057d4a" title="Contact forces are computed using the hydroelastic model, where possible.">drake::multibody::ContactModel::kHydroelasticWithFallback</a></li>
</ul>
<p>The default model is <a class="el" href="namespacedrake_1_1multibody.html#a6f6e054758d34b83e86bea87d65dfe4ea8ad3adce463edb0d2843e1f1c0057d4a">kHydroelasticWithFallback</a>.</p>
<p><a class="el" href="namespacedrake_1_1multibody.html#a6f6e054758d34b83e86bea87d65dfe4ea20e722b15a1b587c30633f0a136b7009">kPoint</a> is the implementation of the point contact model (see <a class="el" href="group__hydroelastic__user__guide.html#hydro_appendix_a">Appendix A: Compliant Contact Models</a>).</p>
<p>Models <a class="el" href="namespacedrake_1_1multibody.html#a6f6e054758d34b83e86bea87d65dfe4ea873aefb0d70a0478c541b2d98484595d">kHydroelastic</a> and <a class="el" href="namespacedrake_1_1multibody.html#a6f6e054758d34b83e86bea87d65dfe4ea8ad3adce463edb0d2843e1f1c0057d4a">kHydroelasticWithFallback</a> will both enable the hydroelastic contact. For forces to be created from hydroelastic contact, geometries need to have hydroelastic representations (see <a class="el" href="group__hydroelastic__user__guide.html#hug_quick_hydro">Hydroelastic Quick-start</a>, <a class="el" href="group__hydroelastic__user__guide.html#creating_hydro_reps">Creating hydroelastic representations of collision geometries</a>).</p>
<p><a class="el" href="namespacedrake_1_1multibody.html#a6f6e054758d34b83e86bea87d65dfe4ea873aefb0d70a0478c541b2d98484595d">kHydroelastic</a> is a strict contact model that will attempt to create a hydroelastic contact surface whenever a geometry with a hydroelastic representation appears to be in contact (based on broad-phase bounding volume culling). With this contact model, the simulator will throw an exception if:</p>
<ul>
<li>The contact is between two geometries with rigid hydroelastic representation, or</li>
<li>The contact is between a geometry with a hydroelastic representation and one without.</li>
</ul>
<p>Collisions between two geometries where neither has a hydroelastic representation are simply ignored.</p>
<p><a class="el" href="namespacedrake_1_1multibody.html#a6f6e054758d34b83e86bea87d65dfe4ea8ad3adce463edb0d2843e1f1c0057d4a">kHydroelasticWithFallback</a> provides “fallback” behavior for when <a class="el" href="namespacedrake_1_1multibody.html#a6f6e054758d34b83e86bea87d65dfe4ea873aefb0d70a0478c541b2d98484595d">kHydroelastic</a> would throw. When those scenarios are detected, it uses the point contact model between the colliding geometries so that the contact can be accounted for and produce contact forces. As the implementation evolves, more and more contact will be captured with hydroelastic contact and the circumstances in which the point-contact fallback is applied will decrease.</p>
<h3><a class="anchor" id="creating_hydro_reps"></a>
Creating hydroelastic representations of collision geometries</h3>
<p>There are three ways to configure hydroelastic representations for collision geometries:</p><ul>
<li>by using <a class="el" href="structdrake_1_1geometry_1_1_default_proximity_properties.html" title="These properties will be used as defaults when the geometry as added via API calls or parsed from mod...">drake::geometry::DefaultProximityProperties</a> (see <a class="el" href="group__hydroelastic__user__guide.html#hug_quick_hydro">Hydroelastic Quick-start</a>)</li>
<li>by annotating model files (see <a class="el" href="group__hydroelastic__user__guide.html#hug_file_specs">Assigning hydroelastic properties in file specifications</a>)</li>
<li>programmatically (see <a class="el" href="group__hydroelastic__user__guide.html#hug_code_properties">Assigning hydroelastic properties in code</a>)</li>
</ul>
<p>If none of the above are done, no geometry in <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html" title="SceneGraph serves as the nexus for all geometry (and geometry-based operations) in a Diagram.">drake::geometry::SceneGraph</a> has a hydroelastic representation. So, enabling hydroelastic contact in <code>MultibodyPlant</code>, but forgetting to configure the geometries will lead to either simulation crashes or point contact-based forces.</p>
<p>In order for a mesh to be given a hydroelastic representation, it must be assigned certain properties. The exact properties it needs depends on the Shape type and whether it is rigid or compliant. Some properties can be defined, but if they are absent they’ll be provided by <code>MultibodyPlant</code>. First we’ll discuss each of the properties and then discuss how they can be specified.</p>
<h4><a class="anchor" id="hug_properties"></a>
Properties for hydroelastic contact</h4>
<ul>
<li>Hydroelastic classification<ul>
<li>To have a hydroelastic representation, a shape needs to be classified as either “compliant” or “rigid”. This must be explicit &ndash; there are no implicit assumptions. Otherwise, it will participate in point contact only.</li>
</ul>
</li>
<li>Resolution hint (meters)<ul>
<li>A positive real value in meters.</li>
<li>Most shapes (capsules, cylinders, ellipsoids, spheres) need to be tessellated into meshes. The resolution hint controls the fineness of the meshes.</li>
<li>For all tessellated geometries, Drake puts hard limits on the effect of the resolution hint property. There is a limit to how fine Drake will tessellate a primitive. Drake has hard-coded internal limits that are still very generous (approximately 100 million tetrahedra or triangles) which should be more than enough for any application. In practice, resolution hints will be quite “large” as coarser meshes are typically more desirable.</li>
<li>Notes on choosing a value:<ul>
<li>Generally, the coarsest mesh that produces desirable results will allow the simulation to run as efficiently as possible.<ul>
<li>The coarsest mesh will typically be generated when the resolution is equal to the geometry’s maximum measure (see the details below).</li>
</ul>
</li>
<li>If tessellation artifacts become obvious in the simulation, either make the object more compliant (see hydroelastic modulus) or increase the resolution (as discussed for the various shapes below).</li>
</ul>
</li>
<li>Geometric detail:<ul>
<li>For each geometry type, the resolution hint works with some (maybe abstract) choice of a representative circle, and its effect is defined in terms of the circumference of that circle. The resolution hint is the target length of each edge of the tessellated mesh around the circle. The circle will have N = ⌈2πr/h⌉ edges, where r is the capsule radius and h is the resolution hint. The number N changes discontinuously as h changes. However, generally, decreasing the resolution hint by some factor will increase the number of edges by that same factor. The number of elements will grow quadratically.<ul>
<li>Sphere<ul>
<li>The representative circle is the great circle of the sphere.</li>
</ul>
</li>
<li>Cylinder<ul>
<li>The representative circle is the base of the cylinder.</li>
</ul>
</li>
<li>Capsule<ul>
<li>The representative circle is the base of the cylinder, which is also the great circle of each hemisphere.</li>
</ul>
</li>
<li>Ellipsoid<ul>
<li>The representative circle is an abstract circle whose radius is that of the largest semi-axis of the elllipsoid.</li>
</ul>
</li>
</ul>
</li>
<li>Resolution hint has no effect on Box.</li>
</ul>
</li>
</ul>
</li>
<li>Hydroelastic modulus (Pa (N/m²))<ul>
<li>This is the measure of how stiff the material is. It directly defines how much pressure is exerted given a certain amount of penetration. More pressure leads to greater forces. Larger values create stiffer objects. An infinite modulus is mathematically equivalent to a “rigid” object. (Although, it is definitely better, in that case, to simply declare it “rigid”.)</li>
<li>This is <em>only</em> required for shapes declared to be “compliant”. It can be defined for shapes declared as “rigid”, but the value will be ignored. (It can be convenient to always define it to enable tests where one might toggle the classification between rigid and compliant such that the compliant declaration is always well formed.)</li>
<li>Declaring a geometry to be compliant but not providing a valid hydroelastic modulus will produce an error at the time the geometry is added to <code>SceneGraph</code>.</li>
<li>This is similar to something like Young’s modulus but it is not identical.<ul>
<li>The primary distinction is this isn’t purely a material property. The value is entangled with the geometry. It essentially scales the force based on the <em>percentage</em> of penetration into an object (i.e., strain). So, a fixed modulus value might lead to a 1cm penetration on one sphere. But if the sphere were scaled up by a factor of 10, the penetration would become 10cm. So, if there are constraints on penetration depth, the modulus would have to increase with the scale of the geometry.</li>
</ul>
</li>
<li>Notes on choosing a value:<ul>
<li>Starting with the value for Young’s modulus is not unreasonable. Empirical evidence suggests that the hydroelastic modulus tends to be smaller depending on the size of the objects.</li>
<li>For large modulus values, the resolution of the representations matter more. A very high modulus will keep the contact near the surface of the geometry, exposing tessellation artifacts. A smaller modulus has a smoothing effect.</li>
</ul>
</li>
</ul>
</li>
<li>Hunt-Crossley dissipation (s/m)<ul>
<li>A non-negative real value.</li>
<li>This gives the contact an energy-damping property.</li>
<li>The larger the value, the more energy is damped.</li>
<li>If no value is provided, <code>MultibodyPlant</code> provides a default value of zero.</li>
<li>Notes on choosing a value:<ul>
<li>For objects that are nominally rigid, starting with zero-damping is good.</li>
<li>If the behavior seems “jittery”, gradually increase the amount of dissipation. Typical values would remain in the range [0, 100] with 10 to 50 being a typical damping amount.</li>
<li>The inverse of the Hunt-Crossley dissipation is the maximum bounce velocity between two objects. Therefore, if maximum bounce velocities of 10 cm/s are acceptable, a dissipation of 10 s/m will keep bounce velocities bounded to this range.</li>
<li>Warning: values larger than about 500 s/m are unphysical and typically lead to numerical problems. Due to time discretization errors, the user will see objects that take a long time to go back to their rest state.</li>
<li>Remember, as this value increases, your simulation will lose energy at a higher rate.</li>
</ul>
</li>
<li>See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#mbp_dissipation_model">Modeling Dissipation</a> for details.</li>
</ul>
</li>
<li>Slab thickness<ul>
<li>A positive real value in meters</li>
<li>Only used for compliant half spaces. Declaring a half space to be compliant but lacking a value for slab thickness will cause the simulation to error out.</li>
<li>A measure of the thickness of the compliant material near the boundary of the half space.<ul>
<li>A compliant half space can be made more rigid by:<ul>
<li>Increasing the hydroelastic modulus and fixing slab thickness.</li>
<li>Fixing the hydroelastic modulus and decreasing the slab thickness.</li>
<li>Increasing the hydroelastic modulus and decreasing the slab thickness.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3><a class="anchor" id="hug_geometry_properties"></a>
Assigning hydroelastic properties to geometries</h3>
<p>Properties can be assigned to geometries inside a URDF or SDFormat file using some custom Drake XML tags. Alternatively, the properties can be assigned programmatically.</p>
<h4><a class="anchor" id="hug_file_specs"></a>
Assigning hydroelastic properties in file specifications</h4>
<p>Drake has introduced a number of custom tags to provide a uniform language to specify hydroelastic properties in both URDF and SDFormat. The tag names are the same but the values are expressed differently (to align with the practices common to URDF and SDFormat). For example, consider a custom tag &lt;drake:foo&gt; that takes a single integer value. In an SDFormat file it would look like: </p><pre class="fragment">&lt;drake:foo&gt;17&lt;/drake:foo&gt;
</pre><p>But in a URDF file it would look like this: </p><pre class="fragment">&lt;drake:foo value=”17”/&gt;
</pre><p>Both URDF and SDFormat files define a &lt;collision&gt; tag. This tag contains the tag for specifying the geometry type and associated properties. The hydroelastic properties can be specified as a child of the &lt;collision&gt; tag. Consider the following SDFormat example: </p><pre class="fragment">…
  &lt;collision name="body1_collision"&gt;
    &lt;geometry&gt;
      ...
    &lt;/geometry&gt;
    &lt;drake:proximity_properties&gt;
      &lt;drake:compliant_hydroelastic/&gt;
      &lt;drake:mesh_resolution_hint&gt;0.1&lt;/drake:mesh_resolution_hint&gt;
      &lt;drake:hydroelastic_modulus&gt;5e7&lt;/drake:hydroelastic_modulus&gt;
      &lt;drake:hunt_crossley_dissipation&gt;1.25&lt;/drake:hunt_crossley_dissipation&gt;
    &lt;/drake:proximity_properties&gt;
  &lt;/collision&gt;
…
</pre><p> and the following equivalent URDF example: </p><pre class="fragment">…
  &lt;collision name="body1_collision"&gt;
    &lt;geometry&gt;
      ...
    &lt;/geometry&gt;
    &lt;drake:proximity_properties&gt;
      &lt;drake:compliant_hydroelastic/&gt;
      &lt;drake:mesh_resolution_hint value="0.1"/&gt;
      &lt;drake:hydroelastic_modulus value="5e7/&gt;
      &lt;drake:hunt_crossley_dissipation value="1.25/&gt;
    &lt;/drake:proximity_properties&gt;
  &lt;/collision&gt;
…
</pre><p>For a body, we’ve defined a collision geometry called “body1_collision”. Inside the &lt;collision&gt; tag (as a sibling to the &lt;geometry&gt; tag), we’ve introduced the Drake-specific &lt;drake:proximity_properties&gt; tag. In it we’ve defined the geometry to be compliant for hydroelastic contact and specified its resolution hint, its hydroelastic modulus, and its dissipation.</p>
<p>Let’s look at the specific tags:</p>
<ul>
<li>&lt;<a class="el" href="group__multibody__parsing.html#tag_drake_proximity_properties">drake:proximity_properties</a>&gt;: This is the container for all Drake-specific proximity property values.</li>
<li>The following tags define hydroelastic properties for the collision geometry and would be contained in the &lt;<a class="el" href="group__multibody__parsing.html#tag_drake_proximity_properties">drake:proximity_properties</a>&gt; tag.<ul>
<li>&lt;<a class="el" href="group__multibody__parsing.html#tag_drake_rigid_hydroelastic">drake:rigid_hydroelastic</a>&gt; or &lt;<a class="el" href="group__multibody__parsing.html#tag_drake_compliant_hydroelastic">drake:compliant_hydroelastic</a>&gt;</li>
<li>&lt;<a class="el" href="group__multibody__parsing.html#tag_drake_mesh_resolution_hint">drake:mesh_resolution_hint</a>&gt;</li>
<li>&lt;<a class="el" href="group__multibody__parsing.html#tag_drake_hydroelastic_modulus">drake:hydroelastic_modulus</a>&gt; (for compliant geometry only)</li>
<li>&lt;<a class="el" href="group__multibody__parsing.html#tag_drake_hunt_crossley_dissipation">drake:hunt_crossley_dissipation</a>&gt;</li>
</ul>
</li>
<li>In the name of completeness, the following tags would be children of the &lt;<a class="el" href="group__multibody__parsing.html#tag_drake_proximity_properties">drake:proximity_properties</a>&gt; tag as well, but are not restricted to use with hydroelastic contact.<ul>
<li>&lt;<a class="el" href="group__multibody__parsing.html#tag_drake_point_contact_stiffness">drake:point_contact_stiffness</a>&gt;: Only used when this geometry is for point contact. Defines the compliance of the point contact. This property is allowed to exist even if the geometry has been specified to be of hydroelastic type, it will have no effect on hydroelastic computations.</li>
<li>&lt;<a class="el" href="group__multibody__parsing.html#tag_drake_mu_static">drake:mu_static</a>&gt; The coefficient for static friction; this applies to both point contact and hydroelastic contact.</li>
<li>&lt;<a class="el" href="group__multibody__parsing.html#tag_drake_mu_dynamic">drake:mu_dynamic</a>&gt; The coefficient for dynamic friction; this applies to both point contact and hydroelastic contact.</li>
</ul>
</li>
</ul>
<h4><a class="anchor" id="hug_code_properties"></a>
Assigning hydroelastic properties in code</h4>
<p>Hydroelastic properties can be set to objects programmatically via the following APIs (see their documentation for further details):</p>
<ul>
<li><a class="el" href="namespacedrake_1_1geometry.html#a524d11f70b0594572404257e3f8640ee" title="AddContactMaterial() adds general contact material properties to the given set of proximity propertie...">AddContactMaterial()</a></li>
<li><a class="el" href="namespacedrake_1_1geometry.html#af76ed94bef3f81765a1b3ce069562e00" title="Adds properties to the given set of proximity properties sufficient to cause the associated geometry ...">AddRigidHydroelasticProperties()</a></li>
<li><a class="el" href="namespacedrake_1_1geometry.html#a5a4cec840d5cb801271dbe609deaf0fe" title="Adds properties to the given set of proximity properties sufficient to cause the associated geometry ...">AddCompliantHydroelasticProperties()</a></li>
<li><a class="el" href="namespacedrake_1_1geometry.html#a331f457a6ce0d146213faa844725dcda" title="Compliant half spaces are handled as a special case; they do not get tessellated.">AddCompliantHydroelasticPropertiesForHalfSpace()</a></li>
</ul>
<p>Some extra notes:</p>
<p><a class="el" href="namespacedrake_1_1geometry.html#a524d11f70b0594572404257e3f8640ee" title="AddContactMaterial() adds general contact material properties to the given set of proximity propertie...">AddContactMaterial()</a> isn’t hydroelastic contact specific, but does provide a mechanism for setting the friction coefficients that hydroelastic and point contact models both use.</p>
<p><a class="el" href="namespacedrake_1_1geometry.html#af76ed94bef3f81765a1b3ce069562e00" title="Adds properties to the given set of proximity properties sufficient to cause the associated geometry ...">AddRigidHydroelasticProperties()</a> is overloaded. One version accepts a value for resolution hint, one does not. When in doubt which to use, it is harmless to provide a resolution hint value that would be ignored for some geometries, but failing to provide one where necessary will cause the simulation to throw an exception. Note the special case for declaring a compliant half space &ndash; it takes the required slab thickness parameter in addition to the hydroelastic modulus value.</p>
<h2><a class="anchor" id="hug_visualizing"></a>
Visualizing hydroelastic contact</h2>
<p>Start Meldis by: </p><pre class="fragment">$ bazel run //tools:meldis -- --open-window &amp;
</pre><p>Run a simulation with hydroelastic contact model; for example, </p><pre class="fragment">$ bazel run //examples/hydroelastic/ball_plate:ball_plate_run_dynamics -- \
   --mbp_dt=0.001 --x0=0.10 --z0=0.15 --vz=-7.0 \
   --simulation_time=0.015 --simulator_publish_every_time_step
</pre><p>At the time of this writing, the Meldis view of this example looks like this:</p>
<div class="image">
<img src="drake-vis-01.png" alt="drake-vis-01.png" width="90%"/>
</div>
<p>In the above picture, we see two red force vectors acting at the centroids of the two contact surfaces and also the two blue moment vectors. One contact surface represents the ball pushing the dinner plate down. The other contact surface represents the rectangular floor pushing the dinner plate up. (Gravity forces are not shown, nor is the contact between the ball and the floor.) Notice that only approximately half of the bottom of the plate makes contact with the floor.</p>
<p>The Scene panel can toggle on/off many different aspects of the visualization using checkboxes, including: which contacts are shown, whether to view the illustration (visual) geometry and/or collision (proximity) geometry and/or the bodies' inertia, as well as sliders for controlling transparency to better view overlapping shapes.</p>
<p>When viewing collisions, note that red arrows indicate a hydroelastic contact, with an associated contact patch. Green arrows indicate point contact, which does not have any contact patch.</p>
<h2><a class="anchor" id="hug_pitfalls"></a>
Pitfalls/Troubleshooting</h2>
<p>Here are various ways that hydroelastic contact may surprise you.</p><ul>
<li>A rigid body is not a rigid hydroelastic body until users say so (see <a class="el" href="group__hydroelastic__user__guide.html#creating_hydro_reps">Creating hydroelastic representations of collision geometries</a>). Otherwise, it is ignored by the hydroelastic contact model and might get point contact instead.<ul>
<li>Users need to call <a class="el" href="namespacedrake_1_1geometry.html#af76ed94bef3f81765a1b3ce069562e00" title="Adds properties to the given set of proximity properties sufficient to cause the associated geometry ...">AddRigidHydroelasticProperties()</a> or use the URDF or SDFormat tag &lt;drake:rigid_hydroelastic/&gt;.</li>
</ul>
</li>
<li>Backface culling &ndash; the visualized contact surface is not what you expect. Or, “Why are there holes?”</li>
<li>Hydroelastic modulus is not properly a material property; it combines material and geometry.<ul>
<li>Make the sphere bigger, the force gets weaker for the same contact surface.</li>
</ul>
</li>
<li>“I don’t seem to be getting any contact surfaces although my spheres are clearly overlapping!” Depending on how coarsely you tessellated your geometry (a sphere, at its coarsest, is an octahedron), there can be a large amount of error between the primitive surface and discrete mesh’s surface. Make sure you visualize the hydro meshes and have what you expect.</li>
<li>Stiff and coarse is seldom a good thing. The stiffer an object is, the more the details of the discrete tessellation will directly contribute to the dynamics.</li>
<li>Getting moments out of the contact depends on how many elements are in the contact surface. If the elements of the two contributing meshes are much larger than the actual contact surface, the contact can become, in essence, point contact.</li>
<li>Half spaces are not represented by meshes. They don’t contribute <em>any</em> geometry to the resultant contact surface. The contact surface’s refinement will depend on the other geometry’s level of refinement.</li>
</ul>
<h3><a class="anchor" id="hug_tips"></a>
Tips and Tricks</h3>
<p>This is a random collection of things we can do to maximize the benefits of the hydroelastic contact model. Some of these tricks accommodate current implementation limitations, and some are to work within the theoretical framework.</p>
<h4><a class="anchor" id="hug_gaming"></a>
Gaming the model</h4>
<ul>
<li>Rigid meshes need not be closed. You can use this to provide fine grained control over where a contact surface can actually exist. Be careful to have a consistent direction of surface normals on the triangles. They should point outward.</li>
<li>For a given relative configuration between bodies, the magnitude of force can be tuned in two ways: increasing the hydroelastic modulus and/or scaling the geometry up (in essence, increasing the average penetration depth).</li>
</ul>
<h1><a class="anchor" id="hydro_appendix_a"></a>
Appendix A: Compliant Contact Models</h1>
<h2><a class="anchor" id="hug_point_contact_theory"></a>
Compliant Point Contact</h2>
<p>Before we get into hydroelastic contact, it’s worth describing the compliant point contact model as a reference model. The point contact model defines the contact force by determining the minimum translational displacement (MTD). The minimum translational displacement is the smallest relative displacement between two volumes that will take them from intersecting to just touching. This quantity need not be unique (if two spheres have coincident centers, any direction will serve). Once we have this displacement, we get three quantities that we use to define the contact force:</p><ul>
<li>The direction of the displacement vector is the contact normal.</li>
<li>The magnitude is a measure of the amount of penetration (and is correlated with the magnitude of the normal component of the contact force).</li>
<li>Two witness points for the MTD. The witness points comprise one point on the surface of each volume such that when we apply the minimum translational displacement, they are coincident. We use the witness points (and other physical parameters) to define the point at which the contact force is applied.</li>
</ul>
<p>This model is simple to implement and cheap to compute, but has some drawbacks.</p>
<ul>
<li>A single measure of “maximum penetration” cannot distinguish between a large intersecting volume and a small intersecting volume (see Figure 1). The two intersections would produce the same amount of contact force despite the fact that one is clearly compressing more material.</li>
<li>Contact along a large interface is treated as contact at a single point (see Figure 2). Effects that depend on a contact interface over a domain with non-zero area disappear (e.g., torsional friction).</li>
<li>The witness points are not necessarily unique. This means, generally, there is no guarantee that the witness points will be consistent from frame to frame, which means that the point at which the force is applied will not be consistent. This can produce non-physical artifacts like sudden changes in force direction.</li>
</ul>
<div class="image">
<img src="contact-fig-01.png" alt="contact-fig-01.png"/>
</div>
<p>Figure 1: Two intersections with significantly different intersecting volumes characterized with the same measure: d.</p>
<div class="image">
<img src="contact-fig-02.png" alt="contact-fig-02.png"/>
</div>
<p>Figure 2: Modeling contact forces with point contact (considering the blue half space as rigid). (a) the actual intersection of the simulated bodies. (b) the conceptual deformation of the orange body creating a large area of contact. (c) how point contact sees the deformation: contact at a single point.</p>
<p>Hydroelastic contact was created to address some of the short-comings in point contact. In fact, one might argue that many of the strategies used to mitigate the shortcomings of point contact (such as using lots of points) push it closer and closer to hydroelastic contact.</p>
<h2><a class="anchor" id="hug_hydro_theory"></a>
Hydroelastic Contact</h2>
<p>Hydroelastic Contact is another compliant contact formulation. It was originally introduced by <a class="el" href="group__hydroelastic__user__guide.html#Elandt2019">[Elandt 2019]</a>. Modifications and further development of the model can be found in <a class="el" href="group__hydroelastic__user__guide.html#Masterjohn2022">[Masterjohn 2022]</a>. In Drake, we refer to this model as the “hydroelastic” model. It differs from point contact in how it characterizes the contact. Rather than a single point, it imagines an entire contact surface. This surface is an approximation of the contact surface as visualized in Figure 2(b).</p>
<p>When two objects come into contact, forces are produced due to deformation ("strain") of the objects at the contact interface. At first touch, there are no forces but as the objects are pressed further they deform to produce a region over which contact pressure is non-zero, causing equal-and-opposite forces to act on the objects. Calculating the actual deformations is expensive. Hydroelastic contact is based on the idea that for relatively small deformations we can approximate the resulting contact interface and pressure distribution without having to compute the actual deformations. We do that by precalculating a "pressure field" on the interior of compliant objects (see Figure 3). The pressure field approximates the pressure that would result from deforming the surface to some point within the field. A point on the surface (that is, no deformation) experiences zero pressure, but as it is pressed inward, it experiences an increase in pressure (up to a maximum pressure on the interior of the body). When two bodies are colliding, we look for a surface in the intersecting volume where the pressure on the surface is the same in each object; it’s an equilibrium surface (see Figure 4). There is pressure defined across the entire contact surface. It is integrated to define the resultant contact force and moment.</p>
<div class="image">
<img src="contact-fig-03.png" alt="contact-fig-03.png"/>
</div>
<p>Figure 3: Three shapes and possible pressure fields in the interior of the object. Pressure is zero at the outer boundary, and maximum on the interior.</p>
<div class="image">
<img src="contact-fig-04.png" alt="contact-fig-04.png"/>
</div>
<p>Figure 4: The equilibrium contact surface (pale green) between two bodies where the left-hand, yellow body has (a) less compliance, (b) equal compliance, and (c) greater compliance.</p>
<p>This equilibrium surface has important properties:</p><ul>
<li>The contact surface will always be contained within the intersecting volume.</li>
<li>The surface’s edge will always lie on the surface of both objects and have zero pressure.</li>
<li>The location of the surface depends on the relative compliance of the two objects. As one object becomes more rigid than the other, the contact surface begins to converge to its surface (see Figure 4). As one surface becomes perfectly rigid, the other object deforms completely to conform to its shape.</li>
<li>The contacting bodies need not be convex, nor will the contact surface between two objects necessarily be a single contiguous patch. For non-convex geometries, the contact can be meaningfully represented by multiple disjoint patches. The resultant contact force will still be meaningful.</li>
<li>The resultant contact force is continuous with respect to the relative pose between bodies. In fact, the contact surface’s mesh, its area, and the pressures measured on the surface are likewise continuous.</li>
</ul>
<h2><a class="anchor" id="hug_hydro_practice"></a>
Hydroelastic Contact in practice</h2>
<p>The theory operates on arbitrary geometries and pressure fields. In practice, we operate on discrete representations of both the geometry and the field.</p>
<p>Compliant objects are represented by tetrahedral meshes. The Drake data type is <a class="el" href="classdrake_1_1geometry_1_1_volume_mesh.html">VolumeMesh</a>. The pressure fields on those meshes are piecewise linear.</p>
<p>The resulting contact surface is likewise a discrete mesh. This mesh may be built of nothing but triangles or polygons. The choice of representation has various implications on the computation of contact forces (see below). The pressure on the contact surface is likewise a piecewise linear function.</p>
<p>We model perfectly rigid objects (objects with no compliance at all) as triangle surface meshes. They have no pressure field associated with them because any penetration from the surface instantaneously produces infinite pressure. When colliding a rigid object against a compliant object, the contact surface always follows the surface of the rigid object. Think of it as the compliant object doing 100% of the deformation, so it conforms to the shape of the rigid object.</p>
<p>Important points to note:</p><ul>
<li>The time cost of resolving contact scales with the complexity of the contact surface (number of faces).</li>
<li>The complexity of the contact surface is a function of the complexity of the contacting geometries.</li>
<li>The best performance comes from the lowest resolution meshes that produce “acceptable” behaviors.</li>
<li>It is not universally true that every geometry is represented discretely. The implementation may represent some shapes differently when it allows performance improvements. The canonical example would be a half space geometry. As a shape with infinite volume, it would be infeasible to create a finite, discrete representation. It is also unnecessary. Intersecting meshes directly with a half space is far more efficient.</li>
<li>When an object is very near rigid it is more efficient to model it as rigid than as a very stiff compliant object. Modeling as rigid allows us to take advantage of the fact that the contact surface will lie on the surface of the rigid object.</li>
</ul>
<h1><a class="anchor" id="hydro_appendix_b"></a>
Appendix B: Current state of implementation</h1>
<p>This section will be updated as the scope and feature set of hydroelastic contact is advanced. The main crux of this section is to clearly indicate what can and cannot be done with hydroelastic contact.</p>
<h2><a class="anchor" id="hug_implemented"></a>
What can you do with hydroelastic contact?</h2>
<ul>
<li>Hydroelastic contact can be used with MultibodyPlant in either continuous or discrete mode.</li>
<li>You can visualize the contact surfaces, their pressure fields, and the resultant contact forces in MeshCat as the simulation progresses. However, for playing back recordings in MeshCat, only the contact forces and moments are available (see issue <a href="https://github.com/RobotLocomotion/drake/issues/19142">19142</a>).</li>
<li>All Drake Shape types can be used to create rigid hydroelastic bodies (this includes arbitrary meshes defined as OBJs).</li>
<li>Drake primitive Shape types (Box, Capsule, Cylinder, Ellipsoid, HalfSpace, and Cylinder) can all be used to create both compliant hydroelastic bodies and rigid hydroelastic bodies.</li>
<li>The Drake Convex Shape type can be used both as a compliant hydroelastic body and a rigid hydroelastic body. To use Convex, add the custom tag <code>&lt;drake:declare_convex/&gt;</code> tag under the <code>&lt;mesh&gt;</code> tag in either an SDFormat or URDF file.</li>
<li>The Drake Mesh Shape type can be used as a compliant hydroelastic body using a tetrahedral mesh in VTK file. See <a href="https://github.com/RobotLocomotion/drake/tree/master/examples/hydroelastic/python_nonconvex_mesh">examples/hydroelastic/python_nonconvex_mesh.</a></li>
</ul>
<h2><a class="anchor" id="hug_not_yet_implemented"></a>
What can’t you do with hydroelastic contact?</h2>
<ul>
<li>You can’t get contact surfaces between two rigid hydroelastic geometries. The contact surface between rigid geometries is ill defined and will most likely never be supported. The default <a class="el" href="namespacedrake_1_1multibody.html#a6f6e054758d34b83e86bea87d65dfe4ea8ad3adce463edb0d2843e1f1c0057d4a" title="Contact forces are computed using the hydroelastic model, where possible.">drake::multibody::ContactModel::kHydroelasticWithFallback</a> uses point contact model for the rigid-rigid contact. See <a class="el" href="group__hydroelastic__user__guide.html#hug_enabling">Enabling Hydroelastic contact in your simulation</a>.</li>
<li>Hydroelastics cannot model true deformations given the model does not introduce state. Therefore effects such as tangential compliance or short time scale waves are not captured by the model. Currently we are actively developing code for deformable bodies in <a class="el" href="classdrake_1_1multibody_1_1_deformable_model.html">drake::multibody::DeformableModel</a>.</li>
</ul>
<h2><a class="anchor" id="hug_dissipation_and_solver"></a>
Current dissipation models</h2>
<ul>
<li>The TAMSI (DiscreteContactApproximation::kTamsi), Similar (DiscreteContactApproximation::kSimilar), and Lagged (DiscreteContactApproximation::kLagged) model approximations use a Hunt-Crossley model of dissipation, parameterized by <code>hunt_crossley_dissipation</code>, for both point and hydroelastic contact. The SAP approximation parameter <code>relaxation_time</code> is ignored by these approximations.</li>
<li>The SAP model approximation (DiscreteContactApproximation::kSap) uses a linear Kelvin–Voigt model of dissipation parameterized by <code>relaxation_time</code>, for both point and hydroelastic contact. The Hunt-Crossley dissipation parameter is ignored by this approximation.</li>
<li>We allow the user to specify both <code>hunt_crossley_dissipation</code> (TAMSI, Similar and Lagged discrete approximations as well as continuous plant model) and <code>relaxation_time</code> (SAP approximation specific parameter) on the model, but the parameter may be ignored depending on your plant configuration. See the documentation for that in the <a href="https://drake.mit.edu/doxygen_cxx/classdrake_1_1multibody_1_1_multibody_plant.html#:~:text=%E2%81%B4%20We%20allow%20to,will%20be%20ignored.">MultibodyPlant documentation.</a></li>
</ul>
<h1><a class="anchor" id="hydro_appendix_examples_and_tutorials"></a>
Appendix C: Examples and Tutorials</h1>
<ul>
<li>Example <a href="https://github.com/RobotLocomotion/drake/tree/master/examples/hydroelastic/ball_plate">Contact between a ball, dinner plate, and floor in C++</a> uses the hydroelastic contact model for a convex ball and non-convex dinner plate.</li>
<li>Example <a href="https://github.com/RobotLocomotion/drake/tree/master/examples/hydroelastic/python_ball_paddle">Contact between a ball and paddle (box) in Python</a> uses the hydroelastic contact model for a ball on stationary paddle (box).</li>
<li>Example <a href="https://github.com/RobotLocomotion/drake/tree/master/examples/hydroelastic/python_nonconvex_mesh">Contact between a bell pepper, dinner bowl, and floor in Python</a> uses the hydroelastic contact model for a non-convex bell pepper in a non-convex dinner bowl.</li>
<li>Example <a href="https://github.com/RobotLocomotion/drake/tree/master/examples/hydroelastic/spatula_slip_control">Slip control for a spatula handle between finger grippers in C++</a> uses the hydroelastic contact model for a spatula handle between finger grippers.</li>
<li><p class="startli">Tutorial <a href="https://github.com/RobotLocomotion/drake/blob/master/tutorials/hydroelastic_contact_basics.ipynb">Hydroelastic Contact Basics with Jupyter Python notebook</a> shows how to simulate hydroelastic contact for a compliant block dropped on a rigid rectangular plate. The below-left picture shows one frame of the block's contact with the contact force as a red arrow and the contact torque as a blue arrow. The below-right picture zooms into the hydroelastic contact surface showing pressure distribution.</p>
<div class="image">
<img src="HydroelasticTutorialImage600x388.jpg" alt="HydroelasticTutorialImage600x388.jpg"/>
</div>
</li>
</ul>
<h1><a class="anchor" id="hydro_references"></a>
Sources referenced within this documentation</h1>
<ul>
<li><a class="anchor" id="Elandt2019"></a>[Elandt 2019] Elandt, R., Drumwright, E., Sherman, M., &amp; Ruina, A. (2019, November). A pressure field model for fast, robust approximation of net contact force and moment between nominally rigid objects. In 2019 IEEE/RSJ International Conference on Intelligent Robots and Systems(IROS) (pp. 8238-8245). IEEE. <a href="https://arxiv.org/abs/1904.11433">https://arxiv.org/abs/1904.11433</a> .</li>
<li><a class="anchor" id="Masterjohn2022"></a>[Masterjohn 2022] Masterjohn, J., Guoy, D., Shepherd, J., &amp; Castro, A. (2022). Velocity Level Approximation of Pressure Field Contact Patches. In 2022 IEEE/RSJ International Conference on Intelligent Robots and Systems(IROS). <a href="https://arxiv.org/abs/2110.04157">https://arxiv.org/abs/2110.04157</a> .</li>
<li><a class="anchor" id="Sherman2022"></a>[Sherman 2022] Sherman, M. (2022, June). Rethinking Contact Simulation for Robot Manipulation. Blog post in Medium. <a href="https://medium.com/toyotaresearch/rethinking-contact-simulation-for-robot-manipulation-434a56b5ec88">https://medium.com/toyotaresearch/rethinking-contact-simulation-for-robot-manipulation-434a56b5ec88</a> . </li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- footer -->
<div class="navpath">
  <ul>
  </ul>
</div>
<footer id="nav-path", class="site-footer padding">
  <div class="contain">
    <a href="/" class="drake-logo">
      <img src="/images/drake-logo.svg"/>
    </a>
    <div class="footer-menu">
      <ul>    
        <li>
          <a href="/doxygen_cxx/index.html" class="site-menu-item">C++</a>
        </li>    
        <li>
          <a href="/pydrake/index.html" class="site-menu-item">Python</a>
        </li>
        <li class="github-link">
          <a href="https://github.com/RobotLocomotion/drake" class="site-menu-item">GitHub <img src="/third_party/images/GitHub-Mark-64px.png"/></a>
        </li>
      </ul>
    </div>
  </div>
</footer>
<script type="text/javascript">
searchBox.searchLabel = 'Go to name…';
searchBox.DOMSearchField().value = searchBox.searchLabel;
</script>
</body>
</html>
