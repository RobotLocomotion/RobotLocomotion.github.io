<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: Analysis</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__analysis.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Analysis<div class="ingroups"><a class="el" href="group__algorithms.html">Algorithms</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga2ccd9a43fd950b9e3490dd8c98534c3e"><td class="memItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__analysis.html#ga2ccd9a43fd950b9e3490dd8c98534c3e">SampleBasedLyapunovAnalysis</a> (const <a class="el" href="classdrake_1_1systems_1_1_system.html">System</a>&lt; double &gt; &amp;system, const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; double &gt; &amp;context, const std::function&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="namespacedrake.html#a35725b277b02aeb79f24fd7f724e6dbc">AutoDiffXd</a> &gt;(const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="namespacedrake.html#a35725b277b02aeb79f24fd7f724e6dbc">AutoDiffXd</a> &gt; &amp;state)&gt; &amp;basis_functions, const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;state_samples, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;V_zero_state)</td></tr>
<tr class="memdesc:ga2ccd9a43fd950b9e3490dd8c98534c3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up a linear program to search for the coefficients of a Lyapunov function that satisfies the Lyapunov conditions at a set of sample points.  <a href="group__analysis.html#ga2ccd9a43fd950b9e3490dd8c98534c3e">More...</a><br /></td></tr>
<tr class="separator:ga2ccd9a43fd950b9e3490dd8c98534c3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f3c726f3a915c5188fbcd8bff683cb5"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__analysis.html#ga9f3c726f3a915c5188fbcd8bff683cb5">RandomSimulation</a> (const <a class="el" href="namespacedrake_1_1systems_1_1analysis.html#a093baffca68144967ca38da942917459">SimulatorFactory</a> &amp;make_simulator, const <a class="el" href="namespacedrake_1_1systems_1_1analysis.html#acba2b2630b11f7f987c6924bcdba3c8e">ScalarSystemFunction</a> &amp;output, double final_time, <a class="el" href="classdrake_1_1_random_generator.html">RandomGenerator</a> *generator)</td></tr>
<tr class="memdesc:ga9f3c726f3a915c5188fbcd8bff683cb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run a deterministic simulation of a (stochastic) <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a> using the <code>generator</code> to instantiate all "random" quantities.  <a href="group__analysis.html#ga9f3c726f3a915c5188fbcd8bff683cb5">More...</a><br /></td></tr>
<tr class="separator:ga9f3c726f3a915c5188fbcd8bff683cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08757b3b0c28f5051e1c37d98f2cc58b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structdrake_1_1systems_1_1analysis_1_1_random_simulation_result.html">RandomSimulationResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__analysis.html#ga08757b3b0c28f5051e1c37d98f2cc58b">MonteCarloSimulation</a> (const <a class="el" href="namespacedrake_1_1systems_1_1analysis.html#a093baffca68144967ca38da942917459">SimulatorFactory</a> &amp;make_simulator, const <a class="el" href="namespacedrake_1_1systems_1_1analysis.html#acba2b2630b11f7f987c6924bcdba3c8e">ScalarSystemFunction</a> &amp;output, double final_time, <a class="el" href="classint.html">int</a> num_samples, <a class="el" href="classdrake_1_1_random_generator.html">RandomGenerator</a> *generator=nullptr)</td></tr>
<tr class="memdesc:ga08757b3b0c28f5051e1c37d98f2cc58b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate samples of a scalar random variable output by running many random simulations drawn from independent samples of the distributions governing the stochastic simulation.  <a href="group__analysis.html#ga08757b3b0c28f5051e1c37d98f2cc58b">More...</a><br /></td></tr>
<tr class="separator:ga08757b3b0c28f5051e1c37d98f2cc58b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaafb17ca05a19fe7365d28f8a105cff76"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__analysis.html#gaafb17ca05a19fe7365d28f8a105cff76">RegionOfAttraction</a> (const <a class="el" href="classdrake_1_1systems_1_1_system.html">System</a>&lt; double &gt; &amp;system, const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; double &gt; &amp;context, const <a class="el" href="structdrake_1_1systems_1_1analysis_1_1_region_of_attraction_options.html">RegionOfAttractionOptions</a> &amp;options=<a class="el" href="structdrake_1_1systems_1_1analysis_1_1_region_of_attraction_options.html">RegionOfAttractionOptions</a>())</td></tr>
<tr class="memdesc:gaafb17ca05a19fe7365d28f8a105cff76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimates the region of attraction of the time-invariant <code>system</code> at the fixed point defined by <code>context</code>.  <a href="group__analysis.html#gaafb17ca05a19fe7365d28f8a105cff76">More...</a><br /></td></tr>
<tr class="separator:gaafb17ca05a19fe7365d28f8a105cff76"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga08757b3b0c28f5051e1c37d98f2cc58b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08757b3b0c28f5051e1c37d98f2cc58b">&#9670;&nbsp;</a></span>MonteCarloSimulation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="structdrake_1_1systems_1_1analysis_1_1_random_simulation_result.html">RandomSimulationResult</a>&gt; drake::systems::analysis::MonteCarloSimulation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1systems_1_1analysis.html#a093baffca68144967ca38da942917459">SimulatorFactory</a> &amp;&#160;</td>
          <td class="paramname"><em>make_simulator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1systems_1_1analysis.html#acba2b2630b11f7f987c6924bcdba3c8e">ScalarSystemFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>final_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>num_samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_random_generator.html">RandomGenerator</a> *&#160;</td>
          <td class="paramname"><em>generator</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate samples of a scalar random variable output by running many random simulations drawn from independent samples of the distributions governing the stochastic simulation. </p>
<p>In pseudo-code, this algorithm implements: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> i=1:num_samples</div><div class="line">  <span class="keyword">const</span> generator_snapshot = deepcopy(generator)</div><div class="line">  output = <a class="code" href="group__analysis.html#ga9f3c726f3a915c5188fbcd8bff683cb5">RandomSimulation</a>(..., generator)</div><div class="line">  data(i) = std::pair(generator_snapshot, output)</div><div class="line"><span class="keywordflow">return</span> data</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__analysis.html#ga9f3c726f3a915c5188fbcd8bff683cb5" title="Run a deterministic simulation of a (stochastic) System using the generator to instantiate all &quot;rando...">RandomSimulation()</a> for details about <code>make_simulator</code>, <code>output</code>, and <code>final_time</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_samples</td><td>Number of independent samples to draw from the distribution (and equivalently, the number of simulations to run).</td></tr>
    <tr><td class="paramname">generator</td><td>Random number generator to be used to generate the random samples. If null, then a new <a class="el" href="classdrake_1_1_random_generator.html" title="Defines Drake&#39;s canonical implementation of the UniformRandomBitGenerator C++ concept (as well as a f...">RandomGenerator</a> will be allocated and used internally (and repeated calls to this method will return identical results). To produce statistically "independent" samples on a future call to MonteCarloSimulation, you should make repeated uses of the same <a class="el" href="classdrake_1_1_random_generator.html" title="Defines Drake&#39;s canonical implementation of the UniformRandomBitGenerator C++ concept (as well as a f...">RandomGenerator</a> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a list of <a class="el" href="structdrake_1_1systems_1_1analysis_1_1_random_simulation_result.html" title="A snapshot of the generator used to produce the random simulation.">RandomSimulationResult</a>'s. </dd></dl>

</div>
</div>
<a id="ga9f3c726f3a915c5188fbcd8bff683cb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f3c726f3a915c5188fbcd8bff683cb5">&#9670;&nbsp;</a></span>RandomSimulation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double drake::systems::analysis::RandomSimulation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1systems_1_1analysis.html#a093baffca68144967ca38da942917459">SimulatorFactory</a> &amp;&#160;</td>
          <td class="paramname"><em>make_simulator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1systems_1_1analysis.html#acba2b2630b11f7f987c6924bcdba3c8e">ScalarSystemFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>final_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_random_generator.html">RandomGenerator</a> *&#160;</td>
          <td class="paramname"><em>generator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run a deterministic simulation of a (stochastic) <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a> using the <code>generator</code> to instantiate all "random" quantities. </p>
<p>In pseudo-code, this algorithm implements: </p><div class="fragment"><div class="line">simulator = make_simulator(generator)</div><div class="line">simulator.get_system().SetRandomContext(generator)</div><div class="line">simulator.AdvanceTo(final_time)</div><div class="line"><span class="keywordflow">return</span> output(simulator.get_context())</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">make_simulator</td><td>Callers to this method define a stochastic simulation by providing the <code>make_simulator</code> factory method to return a <a class="el" href="classdrake_1_1systems_1_1_simulator.html" title="A class for advancing the state of hybrid dynamic systems, represented by System&lt;T&gt; objects,...">Simulator</a> using the supplied <a class="el" href="classdrake_1_1_random_generator.html" title="Defines Drake&#39;s canonical implementation of the UniformRandomBitGenerator C++ concept (as well as a f...">RandomGenerator</a> as the only source of randomness. This interface was designed to support cases where the System/Diagram is random (not only the <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>), e.g. in the case where are variable number of objects are added to a multibody simulation.</td></tr>
    <tr><td class="paramname">output</td><td>The scalar random variable output, denoted <code>output</code>, is defined as a function of the <a class="el" href="classdrake_1_1systems_1_1_simulator.html" title="A class for advancing the state of hybrid dynamic systems, represented by System&lt;T&gt; objects,...">Simulator</a>'s <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a>'s <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>, evaluated at the <code>final_time</code>. Monte-Carlo investigations that studying the details of an entire trajectory can still use this interface, e.g. by including a "runtime monitor" <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a> that latches the worst-case deviation of a specification into it's <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> to be queried at the final time.</td></tr>
    <tr><td class="paramname">final_time</td><td>The time that each instance of the <a class="el" href="classdrake_1_1systems_1_1_simulator.html" title="A class for advancing the state of hybrid dynamic systems, represented by System&lt;T&gt; objects,...">Simulator</a> is stepped to. In many cases, this will be equivalent to the duration of the simulation, but it need not be because SetRandomContext() could initialize the time to a non-zero value, or an event could trigger premature termination of the simulation (see #4447).</td></tr>
    <tr><td class="paramname">generator</td><td>Random number generator to be used to generate the random samples.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <code>output</code> evaluated from the <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> at <code>final_time</code>. </dd></dl>

</div>
</div>
<a id="gaafb17ca05a19fe7365d28f8a105cff76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaafb17ca05a19fe7365d28f8a105cff76">&#9670;&nbsp;</a></span>RegionOfAttraction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> drake::systems::analysis::RegionOfAttraction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_system.html">System</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>system</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdrake_1_1systems_1_1analysis_1_1_region_of_attraction_options.html">RegionOfAttractionOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code><a class="el" href="structdrake_1_1systems_1_1analysis_1_1_region_of_attraction_options.html">RegionOfAttractionOptions</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Estimates the region of attraction of the time-invariant <code>system</code> at the fixed point defined by <code>context</code>. </p>
<p>This implementation only searches for the largest level set of the <code>lyapunov_candidate</code> function from <code>options</code> (or a candidate obtained from solving the Lyapunov equation on the linearization).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">system</td><td>a time-invariant continuous-time <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a> that supports scalar-type conversion to <a class="el" href="classdrake_1_1symbolic_1_1_expression.html" title="Represents a symbolic form of an expression.">symbolic::Expression</a>. The dynamics of the system must be polynomial.</td></tr>
    <tr><td class="paramname">context</td><td>a <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> that defines the parameters of the system and the fixed-point about which we are analyzing the regional stability.</td></tr>
    <tr><td class="paramname">options</td><td>provides a variety of configuration options. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structdrake_1_1systems_1_1analysis_1_1_region_of_attraction_options.html" title="Consolidates the many possible options to be passed to the region of attraction algorithm.">RegionOfAttractionOptions</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classdrake_1_1symbolic_1_1_expression.html" title="Represents a symbolic form of an expression.">symbolic::Expression</a> representing a Lyapunov function using the symbolic Variables named x0, x1..., where the order matches the continuous state vector in the <code>context</code>, or the vector state_variables passed in through the options structure (if it is non-empty). The level set {x | V(x)&lt;=1} containing the fixed-point in <code>context</code> represents the region of attraction.</dd></dl>
<p>Note: There are more numerical techniques that we know how to apply here. Do report an issue if you discover a system for which this code does not perform well. </p>

</div>
</div>
<a id="ga2ccd9a43fd950b9e3490dd8c98534c3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2ccd9a43fd950b9e3490dd8c98534c3e">&#9670;&nbsp;</a></span>SampleBasedLyapunovAnalysis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXd drake::systems::analysis::SampleBasedLyapunovAnalysis </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_system.html">System</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>system</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="namespacedrake.html#a35725b277b02aeb79f24fd7f724e6dbc">AutoDiffXd</a> &gt;(const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="namespacedrake.html#a35725b277b02aeb79f24fd7f724e6dbc">AutoDiffXd</a> &gt; &amp;state)&gt; &amp;&#160;</td>
          <td class="paramname"><em>basis_functions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>state_samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>V_zero_state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets up a linear program to search for the coefficients of a Lyapunov function that satisfies the Lyapunov conditions at a set of sample points. </p>
<p>∀xᵢ, V(xᵢ) ≥ 0, ∀xᵢ, V̇(xᵢ) = ∂V/∂x f(xᵢ) ≤ 0. In order to provide boundary conditions to the problem, and improve numerical conditioning, we additionally impose the constraint V(x₀) = 0, and add an objective that pushes V̇(xᵢ) towards -1 (time-to-go): min ∑ |V̇(xᵢ) + 1|.</p>
<p>For background, and a description of this algorithm, see <a href="http://underactuated.csail.mit.edu/underactuated.html?chapter=lyapunov">http://underactuated.csail.mit.edu/underactuated.html?chapter=lyapunov</a> . It currently requires that the system to be optimized has only continuous state and it is assumed to be time invariant.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">system</td><td>to be verified. We currently require that the system has only continuous state, and it is assumed to be time invariant. Unlike many analysis algorithms, the system does <em>not</em> need to support conversion to other ScalarTypes (double is sufficient).</td></tr>
    <tr><td class="paramname">context</td><td>is used only to specify any parameters of the system, and to fix any input ports. The system/context must have all inputs assigned.</td></tr>
    <tr><td class="paramname">basis_functions</td><td>must define an AutoDiffXd function that takes the state vector as an input argument and returns the vector of values of the basis functions at that state. The Lyapunov function will then have the form V(x) = ∑ pᵢ φᵢ(x), where <code>p</code> is the vector to be solved for and <code>φ(x)</code> is the vector of basis function evaluations returned by this function.</td></tr>
    <tr><td class="paramname">state_samples</td><td>is a list of sample states (one per column) at which to apply the optimization constraints and the objective.</td></tr>
    <tr><td class="paramname">V_zero_state</td><td>is a particular state, x₀, where we impose the condition: V(x₀) = 0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>params the VectorXd of parameters, p, that satisfies the Lyapunov conditions described above. The resulting Lyapunov function is V(x) = ∑ pᵢ φᵢ(x), </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.15 -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.nl/">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a></li>
  </ul>
</div>
</body>
</html>
