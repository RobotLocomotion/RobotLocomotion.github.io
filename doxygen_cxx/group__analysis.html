<!-- HTML header for doxygen 1.15.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: Analysis</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(function() { init_search(); });
</script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@4/tex-chtml.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<header class="site-header">
 <div class="site-header-inner contain">
  <a class="drake-logo" href="/"><img src="/images/drake-logo-white.svg"></a>
  <div class="menu-mobile-toggle">
   <span></span>
  </div>
  <nav class="site-menu">
   <ul>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/">Home</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/installation.html">Installation</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/gallery.html">Gallery</a>
    </li>
    <li class="site-menu-item site-menu-item-main">API Documentation
     <div class="sub">
      <a class="site-menu-item" href="/doxygen_cxx/index.html">C++</a>
      <a class="site-menu-item" href="/pydrake/index.html">Python</a>
     </div>
    </li>
    <li class="site-menu-item site-menu-item-main">Resources
     <div class="sub">
      <a class="site-menu-item" href="/getting_help.html">Getting Help</a>
      <a class="site-menu-item" href="https://deepnote.com/workspace/Drake-0b3b2c53-a7ad-441b-80f8-bf8350752305/project/Tutorials-2b4fc509-aef2-417d-a40d-6071dfed9199/notebook/index-753e3c9d261247ba9f0eb1d7868c18c8">Tutorials</a>
      <a class="site-menu-item" href="/python_bindings.html">Python Bindings</a>
      <a class="site-menu-item" href="/developers.html">For Developers</a>
      <a class="site-menu-item" href="/credits.html">Credits</a>
     </div>
    </li>
    <li class="github-link">
     <a class="site-menu-item" href="https://github.com/RobotLocomotion/drake">GitHub <img src="/third_party/images/GitHub-Mark-Light-64px.png"></a>
    </li>
   </ul>
  </nav>
 </div>
</header>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<div class="title-banner">
 <div class="title-banner__title">
  Drake C++ Documentation
 </div>
 <div id="DDGSearch">
  <form id="search_form_cpp" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search C++ API only…">
   <input type="hidden" name="q" value="site:drake.mit.edu/doxygen_cxx">
  </form>
  <form id="search_form" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search all of Drake…">
   <input type="hidden" name="q" value="site:drake.mit.edu OR site:underactuated.csail.mit.edu OR site:manipulation.csail.mit.edu">
  </form>
 </div>
 <div id="MSearchBoxContainer">
  <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect" class="search-icon" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"><span class="search-icon-dropdown"></span></span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><div id="MSearchCloseImg" class="close-icon"></div></a>
          </span>
        </div>
</td>
 </div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('group__analysis.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">Analysis <div class="ingroups"><a class="el" href="group__algorithms.html">Algorithms</a></div></div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga235dadbbb0fa017348f63b631d461a71" id="r_ga235dadbbb0fa017348f63b631d461a71"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:ga235dadbbb0fa017348f63b631d461a71 template"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_linear_system.html">LinearSystem</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga235dadbbb0fa017348f63b631d461a71">DiscreteTimeApproximation</a> (const <a class="el" href="classdrake_1_1systems_1_1_linear_system.html">LinearSystem</a>&lt; T &gt; &amp;linear_system, double time_period)</td></tr>
<tr class="memdesc:ga235dadbbb0fa017348f63b631d461a71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a continuous-time linear system to a discrete-time linear system using the zero-order hold method.  <br /></td></tr>
<tr class="memitem:gaf8909e134530f169368f3dd17053d427" id="r_gaf8909e134530f169368f3dd17053d427"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:gaf8909e134530f169368f3dd17053d427 template"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_affine_system.html">AffineSystem</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf8909e134530f169368f3dd17053d427">DiscreteTimeApproximation</a> (const <a class="el" href="classdrake_1_1systems_1_1_affine_system.html">AffineSystem</a>&lt; T &gt; &amp;affine_system, double time_period)</td></tr>
<tr class="memdesc:gaf8909e134530f169368f3dd17053d427"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a continuous-time affine system to a discrete-time affine system using the zero-order hold method.  <br /></td></tr>
<tr class="memitem:ga8aff0c0ef9f5366a496d9d062d19ad35" id="r_ga8aff0c0ef9f5366a496d9d062d19ad35"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:ga8aff0c0ef9f5366a496d9d062d19ad35 template"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_system.html">System</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8aff0c0ef9f5366a496d9d062d19ad35">DiscreteTimeApproximation</a> (std::shared_ptr&lt; const <a class="el" href="classdrake_1_1systems_1_1_system.html">System</a>&lt; T &gt; &gt; system, double time_period, const <a class="el" href="structdrake_1_1systems_1_1_simulator_config.html">SimulatorConfig</a> &amp;integrator_config=<a class="el" href="structdrake_1_1systems_1_1_simulator_config.html">SimulatorConfig</a>())</td></tr>
<tr class="memdesc:ga8aff0c0ef9f5366a496d9d062d19ad35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a general continuous-time system \( \dot{x} = f(t,x(t),u(t)) \) to a discrete-time system with zero-order hold on the input.  <br /></td></tr>
<tr class="memitem:gaa8163caadd583fdd8bd34f02473e0a20" id="r_gaa8163caadd583fdd8bd34f02473e0a20"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:gaa8163caadd583fdd8bd34f02473e0a20 template"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_system.html">System</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa8163caadd583fdd8bd34f02473e0a20">DiscreteTimeApproximation</a> (const <a class="el" href="classdrake_1_1systems_1_1_system.html">System</a>&lt; T &gt; &amp;system, double time_period, const <a class="el" href="structdrake_1_1systems_1_1_simulator_config.html">SimulatorConfig</a> &amp;integrator_config=<a class="el" href="structdrake_1_1systems_1_1_simulator_config.html">SimulatorConfig</a>())</td></tr>
<tr class="memdesc:gaa8163caadd583fdd8bd34f02473e0a20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as above, without claiming ownership of <code class="param">system</code>.  <br /></td></tr>
<tr class="memitem:gaa45c33cbb4e7b6d78925e207e5be823e" id="r_gaa45c33cbb4e7b6d78925e207e5be823e"><td class="memItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa45c33cbb4e7b6d78925e207e5be823e">SampleBasedLyapunovAnalysis</a> (const <a class="el" href="classdrake_1_1systems_1_1_system.html">System</a>&lt; double &gt; &amp;system, const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; double &gt; &amp;context, const std::function&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="namespacedrake.html#a3d6302a0051e9403c9df3ed6808f3854">AutoDiffXd</a> &gt;(const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="namespacedrake.html#a3d6302a0051e9403c9df3ed6808f3854">AutoDiffXd</a> &gt; &amp;state)&gt; &amp;basis_functions, const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;state_samples, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;V_zero_state)</td></tr>
<tr class="memdesc:gaa45c33cbb4e7b6d78925e207e5be823e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up a linear program to search for the coefficients of a Lyapunov function that satisfies the Lyapunov conditions at a set of sample points.  <br /></td></tr>
<tr class="memitem:ga4fe7cf4bc3e0884933987f93d2ec47ec" id="r_ga4fe7cf4bc3e0884933987f93d2ec47ec"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga4fe7cf4bc3e0884933987f93d2ec47ec">RandomSimulation</a> (const <a class="el" href="namespacedrake_1_1systems_1_1analysis.html#a1cc9416d47e29d3a284bc8d4bc3afee0">RandomSimulatorFactory</a> &amp;make_simulator, const <a class="el" href="namespacedrake_1_1systems_1_1analysis.html#acba2b2630b11f7f987c6924bcdba3c8e">ScalarSystemFunction</a> &amp;output, double final_time, <a class="el" href="classdrake_1_1_random_generator.html">RandomGenerator</a> *generator)</td></tr>
<tr class="memdesc:ga4fe7cf4bc3e0884933987f93d2ec47ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run a deterministic simulation of a (stochastic) <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a> using the <code class="param">generator</code> to instantiate all "random" quantities.  <br /></td></tr>
<tr class="memitem:gab1b68e9d211eb49b9d5b240b0da5be23" id="r_gab1b68e9d211eb49b9d5b240b0da5be23"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structdrake_1_1systems_1_1analysis_1_1_random_simulation_result.html">RandomSimulationResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab1b68e9d211eb49b9d5b240b0da5be23">MonteCarloSimulation</a> (const <a class="el" href="namespacedrake_1_1systems_1_1analysis.html#a1cc9416d47e29d3a284bc8d4bc3afee0">RandomSimulatorFactory</a> &amp;make_simulator, const <a class="el" href="namespacedrake_1_1systems_1_1analysis.html#acba2b2630b11f7f987c6924bcdba3c8e">ScalarSystemFunction</a> &amp;output, double final_time, int num_samples, <a class="el" href="classdrake_1_1_random_generator.html">RandomGenerator</a> *generator=nullptr, <a class="el" href="classdrake_1_1_parallelism.html">Parallelism</a> parallelism=false)</td></tr>
<tr class="memdesc:gab1b68e9d211eb49b9d5b240b0da5be23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates samples of a scalar random variable output by running many random simulations drawn from independent samples of the distributions governing the stochastic simulation.  <br /></td></tr>
<tr class="memitem:gaa9b757561b8a410998aa5a612986e842" id="r_gaa9b757561b8a410998aa5a612986e842"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa9b757561b8a410998aa5a612986e842">RegionOfAttraction</a> (const <a class="el" href="classdrake_1_1systems_1_1_system.html">System</a>&lt; double &gt; &amp;system, const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; double &gt; &amp;context, const <a class="el" href="structdrake_1_1systems_1_1analysis_1_1_region_of_attraction_options.html">RegionOfAttractionOptions</a> &amp;options=<a class="el" href="structdrake_1_1systems_1_1analysis_1_1_region_of_attraction_options.html">RegionOfAttractionOptions</a>())</td></tr>
<tr class="memdesc:gaa9b757561b8a410998aa5a612986e842"><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimates the region of attraction of the time-invariant <code class="param">system</code> at the fixed point defined by <code class="param">context</code>.  <br /></td></tr>
</table>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="gaf8909e134530f169368f3dd17053d427" name="gaf8909e134530f169368f3dd17053d427"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf8909e134530f169368f3dd17053d427">&#9670;&#160;</a></span>DiscreteTimeApproximation() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_affine_system.html">AffineSystem</a>&lt; T &gt; &gt; DiscreteTimeApproximation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_affine_system.html">AffineSystem</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>affine_system</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>time_period</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a continuous-time affine system to a discrete-time affine system using the zero-order hold method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">affine_system</td><td>The continuous-time <a class="el" href="classdrake_1_1systems_1_1_affine_system.html" title="A discrete OR continuous affine system (with constant coefficients).">AffineSystem</a>. </td></tr>
    <tr><td class="paramname">time_period</td><td>The discrete time period. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A discrete-time <a class="el" href="classdrake_1_1systems_1_1_affine_system.html" title="A discrete OR continuous affine system (with constant coefficients).">AffineSystem</a>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">if</td><td>the <code class="param">affine_system</code> is not continuous or <code class="param">time_period</code> &lt;= 0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The scalar type, which must be one of the <a class="el" href="group__default__scalars.html">default scalars</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga235dadbbb0fa017348f63b631d461a71" name="ga235dadbbb0fa017348f63b631d461a71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga235dadbbb0fa017348f63b631d461a71">&#9670;&#160;</a></span>DiscreteTimeApproximation() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_linear_system.html">LinearSystem</a>&lt; T &gt; &gt; DiscreteTimeApproximation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_linear_system.html">LinearSystem</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>linear_system</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>time_period</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a continuous-time linear system to a discrete-time linear system using the zero-order hold method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">linear_system</td><td>The continuous-time <a class="el" href="classdrake_1_1systems_1_1_linear_system.html" title="A discrete OR continuous linear system.">LinearSystem</a>. </td></tr>
    <tr><td class="paramname">time_period</td><td>The discrete time period. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A discrete-time <a class="el" href="classdrake_1_1systems_1_1_linear_system.html" title="A discrete OR continuous linear system.">LinearSystem</a>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">if</td><td>the <code class="param">linear_system</code> is not continuous or <code class="param">time_period</code> &lt;= 0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The scalar type, which must be one of the <a class="el" href="group__default__scalars.html">default scalars</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa8163caadd583fdd8bd34f02473e0a20" name="gaa8163caadd583fdd8bd34f02473e0a20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8163caadd583fdd8bd34f02473e0a20">&#9670;&#160;</a></span>DiscreteTimeApproximation() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_system.html">System</a>&lt; T &gt; &gt; DiscreteTimeApproximation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_system.html">System</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>system</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>time_period</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdrake_1_1systems_1_1_simulator_config.html">SimulatorConfig</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>integrator_config</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="structdrake_1_1systems_1_1_simulator_config.html">SimulatorConfig</a>()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as above, without claiming ownership of <code class="param">system</code>. </p>
<dl class="section warning"><dt>Warning</dt><dd>The <code class="param">system</code> reference must remain valid for the lifetime of the returned system.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The scalar type, which must be one of the <a class="el" href="group__default__scalars.html">default scalars</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8aff0c0ef9f5366a496d9d062d19ad35" name="ga8aff0c0ef9f5366a496d9d062d19ad35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8aff0c0ef9f5366a496d9d062d19ad35">&#9670;&#160;</a></span>DiscreteTimeApproximation() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_system.html">System</a>&lt; T &gt; &gt; DiscreteTimeApproximation </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1systems_1_1_system.html">System</a>&lt; T &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>system</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>time_period</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdrake_1_1systems_1_1_simulator_config.html">SimulatorConfig</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>integrator_config</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="structdrake_1_1systems_1_1_simulator_config.html">SimulatorConfig</a>()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a general continuous-time system \( \dot{x} = f(t,x(t),u(t)) \) to a discrete-time system with zero-order hold on the input. </p>
<p>The approximate discrete-time dynamics is given by  \( x[n+1] = f_d(n,x[n],u[n]) = x[n] +
\int_{t[n]}^{t[n+1]} f(t,x(t),u[n]) \, dt \), where the integration is performed using numerical integration via an <a class="el" href="classdrake_1_1systems_1_1_integrator_base.html" title="An abstract class for an integrator for ODEs and DAEs as represented by a Drake System.">IntegratorBase</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">system</td><td>The continuous-time <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a>. </td></tr>
    <tr><td class="paramname">time_period</td><td>The discrete time period. </td></tr>
    <tr><td class="paramname">integrator_config</td><td>Use this parameter to configure the integrator (e.g. choose non-default integration_scheme, max_step_size, use_error_control, or accuracy). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A discrete-time <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">if</td><td>the <code class="param">system</code> is not continuous or <code class="param">time_period</code> &lt;= 0. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if the integration scheme does not support the scalar type T.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The scalar type, which must be one of the <a class="el" href="group__default__scalars.html">default scalars</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab1b68e9d211eb49b9d5b240b0da5be23" name="gab1b68e9d211eb49b9d5b240b0da5be23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab1b68e9d211eb49b9d5b240b0da5be23">&#9670;&#160;</a></span>MonteCarloSimulation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structdrake_1_1systems_1_1analysis_1_1_random_simulation_result.html">RandomSimulationResult</a> &gt; MonteCarloSimulation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1systems_1_1analysis.html#a1cc9416d47e29d3a284bc8d4bc3afee0">RandomSimulatorFactory</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>make_simulator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1systems_1_1analysis.html#acba2b2630b11f7f987c6924bcdba3c8e">ScalarSystemFunction</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>output</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>final_time</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num_samples</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_random_generator.html">RandomGenerator</a> *</td>          <td class="paramname"><span class="paramname"><em>generator</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_parallelism.html">Parallelism</a></td>          <td class="paramname"><span class="paramname"><em>parallelism</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates samples of a scalar random variable output by running many random simulations drawn from independent samples of the distributions governing the stochastic simulation. </p>
<p>In pseudo-code, this algorithm implements: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> i=1:num_samples</div>
<div class="line">  <span class="keyword">const</span> generator_snapshot = deepcopy(generator)</div>
<div class="line">  output = <a class="code hl_function" href="#ga4fe7cf4bc3e0884933987f93d2ec47ec">RandomSimulation</a>(..., generator)</div>
<div class="line">  data(i) = std::pair(generator_snapshot, output)</div>
<div class="line"><span class="keywordflow">return</span> data</div>
<div class="ttc" id="agroup__analysis_html_ga4fe7cf4bc3e0884933987f93d2ec47ec"><div class="ttname"><a href="#ga4fe7cf4bc3e0884933987f93d2ec47ec">drake::systems::analysis::RandomSimulation</a></div><div class="ttdeci">double RandomSimulation(const RandomSimulatorFactory &amp;make_simulator, const ScalarSystemFunction &amp;output, double final_time, RandomGenerator *generator)</div><div class="ttdoc">Run a deterministic simulation of a (stochastic) System using the generator to instantiate all &quot;rando...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga4fe7cf4bc3e0884933987f93d2ec47ec" title="Run a deterministic simulation of a (stochastic) System using the generator to instantiate all &quot;rando...">RandomSimulation()</a> for details about <code class="param">make_simulator</code>, <code class="param">output</code>, and <code class="param">final_time</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_samples</td><td>Number of independent samples to draw from the distribution (and equivalently, the number of simulations to run).</td></tr>
    <tr><td class="paramname">generator</td><td>Random number generator to be used to generate the random samples. If null, then a new <a class="el" href="classdrake_1_1_random_generator.html" title="Defines Drake&#39;s canonical implementation of the UniformRandomBitGenerator C++ concept (as well as a f...">RandomGenerator</a> will be allocated and used internally (and repeated calls to this method will return identical results). To produce statistically "independent" samples on a future call to MonteCarloSimulation, you should make repeated uses of the same <a class="el" href="classdrake_1_1_random_generator.html" title="Defines Drake&#39;s canonical implementation of the UniformRandomBitGenerator C++ concept (as well as a f...">RandomGenerator</a> object.</td></tr>
    <tr><td class="paramname">parallelism</td><td>Specify number of parallel executions to use while performing <span class="tt">num_samples</span> simulations. The default value (false) specifies that simulations should be executed in serial. To use the concurrency available on your hardware, specify either <span class="tt">Parallellism::Max()</span> or its terse abbreviation <span class="tt">true</span>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a list of <a class="el" href="structdrake_1_1systems_1_1analysis_1_1_random_simulation_result.html" title="A snapshot of the generator used to produce the random simulation.">RandomSimulationResult</a>'s.</dd></dl>
<p>Thread safety when parallel execution is specified:</p><ul>
<li><code class="param">make_simulator</code> and <code class="param">generator</code> are only accessed from the main thread.</li>
<li>Each simulator created by <code class="param">make_simulator</code> and its context are only accessed from within a single worker thread; however, any resource shared between these simulators must be safe for concurrent use.</li>
<li><code class="param">output</code> is called from within worker threads performing simulation with the simulator and context belonging to each worker thread. It must be safe to make concurrent calls to <code class="param">output</code> (i.e. any mutable state inside the function must be safe for concurrent use). </li>
</ul>

</div>
</div>
<a id="ga4fe7cf4bc3e0884933987f93d2ec47ec" name="ga4fe7cf4bc3e0884933987f93d2ec47ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4fe7cf4bc3e0884933987f93d2ec47ec">&#9670;&#160;</a></span>RandomSimulation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double RandomSimulation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1systems_1_1analysis.html#a1cc9416d47e29d3a284bc8d4bc3afee0">RandomSimulatorFactory</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>make_simulator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1systems_1_1analysis.html#acba2b2630b11f7f987c6924bcdba3c8e">ScalarSystemFunction</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>output</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>final_time</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_random_generator.html">RandomGenerator</a> *</td>          <td class="paramname"><span class="paramname"><em>generator</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run a deterministic simulation of a (stochastic) <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a> using the <code class="param">generator</code> to instantiate all "random" quantities. </p>
<p>In pseudo-code, this algorithm implements: </p><div class="fragment"><div class="line">simulator = make_simulator(generator)</div>
<div class="line">simulator.get_system().SetRandomContext(generator)</div>
<div class="line">simulator.AdvanceTo(final_time)</div>
<div class="line"><span class="keywordflow">return</span> output(simulator.get_context())</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">make_simulator</td><td>Callers to this method define a stochastic simulation by providing the <code class="param">make_simulator</code> factory method to return a <a class="el" href="classdrake_1_1systems_1_1_simulator.html" title="A class for advancing the state of hybrid dynamic systems, represented by System&lt;T&gt; objects,...">Simulator</a> using the supplied <a class="el" href="classdrake_1_1_random_generator.html" title="Defines Drake&#39;s canonical implementation of the UniformRandomBitGenerator C++ concept (as well as a f...">RandomGenerator</a> as the only source of randomness. This interface was designed to support cases where the System/Diagram is random (not only the <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>), e.g. in the case where are variable number of objects are added to a multibody simulation.</td></tr>
    <tr><td class="paramname">output</td><td>The scalar random variable output, denoted <code class="param">output</code>, is defined as a function of the <a class="el" href="classdrake_1_1systems_1_1_simulator.html" title="A class for advancing the state of hybrid dynamic systems, represented by System&lt;T&gt; objects,...">Simulator</a>'s <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a>'s <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>, evaluated at the <code class="param">final_time</code>. Monte-Carlo investigations that studying the details of an entire trajectory can still use this interface, e.g. by including a "runtime monitor" <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a> that latches the worst-case deviation of a specification into it's <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> to be queried at the final time.</td></tr>
    <tr><td class="paramname">final_time</td><td>The time that each instance of the <a class="el" href="classdrake_1_1systems_1_1_simulator.html" title="A class for advancing the state of hybrid dynamic systems, represented by System&lt;T&gt; objects,...">Simulator</a> is stepped to. In many cases, this will be equivalent to the duration of the simulation, but it need not be because SetRandomContext() could initialize the time to a non-zero value, or an event could trigger premature termination of the simulation (see #4447).</td></tr>
    <tr><td class="paramname">generator</td><td>Random number generator to be used to generate the random samples.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <code class="param">output</code> evaluated from the <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> at <code class="param">final_time</code>. </dd></dl>

</div>
</div>
<a id="gaa9b757561b8a410998aa5a612986e842" name="gaa9b757561b8a410998aa5a612986e842"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa9b757561b8a410998aa5a612986e842">&#9670;&#160;</a></span>RegionOfAttraction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> RegionOfAttraction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_system.html">System</a>&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>system</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdrake_1_1systems_1_1analysis_1_1_region_of_attraction_options.html">RegionOfAttractionOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="structdrake_1_1systems_1_1analysis_1_1_region_of_attraction_options.html">RegionOfAttractionOptions</a>()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Estimates the region of attraction of the time-invariant <code class="param">system</code> at the fixed point defined by <code class="param">context</code>. </p>
<p>This implementation only searches for the largest level set of the <span class="tt">lyapunov_candidate</span> function from <code class="param">options</code> (or a candidate obtained from solving the Lyapunov equation on the linearization).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">system</td><td>a time-invariant continuous-time <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a> that supports scalar-type conversion to <a class="el" href="classdrake_1_1symbolic_1_1_expression.html" title="Represents a symbolic form of an expression.">symbolic::Expression</a>. The dynamics of the system must be polynomial.</td></tr>
    <tr><td class="paramname">context</td><td>a <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> that defines the parameters of the system and the fixed-point about which we are analyzing the regional stability.</td></tr>
    <tr><td class="paramname">options</td><td>provides a variety of configuration options. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structdrake_1_1systems_1_1analysis_1_1_region_of_attraction_options.html" title="Consolidates the many possible options to be passed to the region of attraction algorithm.">RegionOfAttractionOptions</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classdrake_1_1symbolic_1_1_expression.html" title="Represents a symbolic form of an expression.">symbolic::Expression</a> representing a Lyapunov function using the symbolic Variables named x0, x1..., where the order matches the continuous state vector in the <code class="param">context</code>, or the vector state_variables passed in through the options structure (if it is non-empty). The level set {x | V(x)&lt;=1} containing the fixed-point in <code class="param">context</code> represents the region of attraction.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>For the given <code class="param">system</code> and <code class="param">context</code>, any required input ports on <code class="param">system</code> must be "defined", i.e., connected to other systems in a larger diagram or holding fixed values; see <a class="el" href="classdrake_1_1systems_1_1_system.html#a601fb2c6cf565d954253d25725ae9d6b" title="Fixes all of the input ports in target_context to their current values in other_context,...">System::FixInputPortsFrom</a> for possible caveats. Analyzing a closed-loop system would typically be accomplished by having both the plant and the controller in a diagram (which then has no input ports), and passing the diagram into this method as <code class="param">system</code>.</dd></dl>
<p>Note: There are more numerical recipes for region of attraction analysis that could extend the current implementation. Do report an issue if you discover a system for which this code does not perform well. </p>

</div>
</div>
<a id="gaa45c33cbb4e7b6d78925e207e5be823e" name="gaa45c33cbb4e7b6d78925e207e5be823e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa45c33cbb4e7b6d78925e207e5be823e">&#9670;&#160;</a></span>SampleBasedLyapunovAnalysis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXd SampleBasedLyapunovAnalysis </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_system.html">System</a>&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>system</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="namespacedrake.html#a3d6302a0051e9403c9df3ed6808f3854">AutoDiffXd</a> &gt;(const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="namespacedrake.html#a3d6302a0051e9403c9df3ed6808f3854">AutoDiffXd</a> &gt; &amp;state)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>basis_functions</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>state_samples</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>V_zero_state</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets up a linear program to search for the coefficients of a Lyapunov function that satisfies the Lyapunov conditions at a set of sample points. </p>
<p>∀xᵢ, V(xᵢ) ≥ 0, ∀xᵢ, V̇(xᵢ) = ∂V/∂x f(xᵢ) ≤ 0. In order to provide boundary conditions to the problem, and improve numerical conditioning, we additionally impose the constraint V(x₀) = 0, and add an objective that pushes V̇(xᵢ) towards -1 (time-to-go): min ∑ |V̇(xᵢ) + 1|.</p>
<p>For background, and a description of this algorithm, see <a href="http://underactuated.csail.mit.edu/underactuated.html?chapter=lyapunov">http://underactuated.csail.mit.edu/underactuated.html?chapter=lyapunov</a> . It currently requires that the system to be optimized has only continuous state and it is assumed to be time invariant.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">system</td><td>to be verified. We currently require that the system has only continuous state, and it is assumed to be time invariant. Unlike many analysis algorithms, the system does <em>not</em> need to support conversion to other ScalarTypes (double is sufficient).</td></tr>
    <tr><td class="paramname">context</td><td>is used only to specify any parameters of the system, and to fix any input ports. The system/context must have all inputs assigned.</td></tr>
    <tr><td class="paramname">basis_functions</td><td>must define an <a class="el" href="namespacedrake.html#a3d6302a0051e9403c9df3ed6808f3854" title="A scalar type that performs automatic differentiation.">AutoDiffXd</a> function that takes the state vector as an input argument and returns the vector of values of the basis functions at that state. The Lyapunov function will then have the form V(x) = ∑ pᵢ φᵢ(x), where <span class="tt">p</span> is the vector to be solved for and <span class="tt">φ(x)</span> is the vector of basis function evaluations returned by this function.</td></tr>
    <tr><td class="paramname">state_samples</td><td>is a list of sample states (one per column) at which to apply the optimization constraints and the objective.</td></tr>
    <tr><td class="paramname">V_zero_state</td><td>is a particular state, x₀, where we impose the condition: V(x₀) = 0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>params the VectorXd of parameters, p, that satisfies the Lyapunov conditions described above. The resulting Lyapunov function is V(x) = ∑ pᵢ φᵢ(x), </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- footer -->
<div class="navpath">
  <ul>
  </ul>
</div>
<footer id="nav-path", class="site-footer padding">
  <div class="contain">
    <a href="/" class="drake-logo">
      <img src="/images/drake-logo.svg"/>
    </a>
    <div class="footer-menu">
      <ul>    
        <li>
          <a href="/doxygen_cxx/index.html" class="site-menu-item">C++</a>
        </li>    
        <li>
          <a href="/pydrake/index.html" class="site-menu-item">Python</a>
        </li>
        <li class="github-link">
          <a href="https://github.com/RobotLocomotion/drake" class="site-menu-item">GitHub <img src="/third_party/images/GitHub-Mark-64px.png"/></a>
        </li>
      </ul>
    </div>
  </div>
</footer>
<script type="text/javascript">
searchBox.searchLabel = 'Go to name…';
searchBox.DOMSearchField().placeholder = searchBox.searchLabel;
searchBox.DOMSearchField().value = '';
</script>
</body>
</html>
